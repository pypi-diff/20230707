# Comparing `tmp/pymor-2022.2.1.tar.gz` & `tmp/pymor-2023.1.0.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "pymor-2022.2.1.tar", last modified: Thu Mar 30 17:57:34 2023, max compression
+gzip compressed data, last modified: Sun Feb  2 00:00:00 2020, max compression
```

## Comparing `pymor-2022.2.1.tar` & `pymor-2023.1.0.tar`

### file list

```diff
@@ -1,447 +1,391 @@
-drwxr-xr-x   0 root         (0) root         (0)        0 2023-03-30 17:57:34.303608 pymor-2022.2.1/
--rw-rw-rw-   0 root         (0) root         (0)      260 2023-03-30 17:57:23.000000 pymor-2022.2.1/.env
--rw-rw-rw-   0 root         (0) root         (0)     5905 2023-03-30 17:57:23.000000 pymor-2022.2.1/AUTHORS.md
--rw-rw-rw-   0 root         (0) root         (0)     1112 2023-03-30 17:57:23.000000 pymor-2022.2.1/CITATION.cff
--rw-rw-rw-   0 root         (0) root         (0)     5496 2023-03-30 17:57:23.000000 pymor-2022.2.1/CODE_OF_CONDUCT.md
--rw-rw-rw-   0 root         (0) root         (0)     6427 2023-03-30 17:57:23.000000 pymor-2022.2.1/CONTRIBUTING.md
--rw-rw-rw-   0 root         (0) root         (0)     1547 2023-03-30 17:57:23.000000 pymor-2022.2.1/LICENSE.txt
--rw-rw-rw-   0 root         (0) root         (0)      589 2023-03-30 17:57:23.000000 pymor-2022.2.1/MANIFEST.in
--rw-rw-rw-   0 root         (0) root         (0)     4200 2023-03-30 17:57:23.000000 pymor-2022.2.1/Makefile
--rw-r--r--   0 root         (0) root         (0)     9807 2023-03-30 17:57:34.303608 pymor-2022.2.1/PKG-INFO
--rw-rw-rw-   0 root         (0) root         (0)     9095 2023-03-30 17:57:23.000000 pymor-2022.2.1/README.md
--rw-rw-rw-   0 root         (0) root         (0)     2364 2023-03-30 17:57:23.000000 pymor-2022.2.1/conftest.py
--rwxrwxrwx   0 root         (0) root         (0)     7404 2023-03-30 17:57:23.000000 pymor-2022.2.1/dependencies.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2023-03-30 17:57:34.203604 pymor-2022.2.1/docs/
--rw-rw-rw-   0 root         (0) root         (0)       58 2023-03-30 17:57:23.000000 pymor-2022.2.1/docs/.gitignore
--rw-rw-rw-   0 root         (0) root         (0)     5929 2023-03-30 17:57:23.000000 pymor-2022.2.1/docs/Makefile
--rw-rw-rw-   0 root         (0) root         (0)     1337 2023-03-30 17:57:23.000000 pymor-2022.2.1/docs/RELEASE_CHECKLIST.md
-drwxr-xr-x   0 root         (0) root         (0)        0 2023-03-30 17:57:34.211604 pymor-2022.2.1/docs/source/
--rw-rw-rw-   0 root         (0) root         (0)       18 2023-03-30 17:57:23.000000 pymor-2022.2.1/docs/source/.gitignore
--rw-rw-rw-   0 root         (0) root         (0)     1493 2023-03-30 17:57:23.000000 pymor-2022.2.1/docs/source/B.png
--rw-rw-rw-   0 root         (0) root         (0)     1472 2023-03-30 17:57:23.000000 pymor-2022.2.1/docs/source/R.png
--rw-rw-rw-   0 root         (0) root         (0)     2395 2023-03-30 17:57:23.000000 pymor-2022.2.1/docs/source/RB.png
-drwxr-xr-x   0 root         (0) root         (0)        0 2023-03-30 17:57:34.215604 pymor-2022.2.1/docs/source/_static/
--rw-rw-rw-   0 root         (0) root         (0)     3390 2023-03-30 17:57:23.000000 pymor-2022.2.1/docs/source/_static/pymor.css
-drwxr-xr-x   0 root         (0) root         (0)        0 2023-03-30 17:57:34.215604 pymor-2022.2.1/docs/source/_templates/
-drwxr-xr-x   0 root         (0) root         (0)        0 2023-03-30 17:57:34.187603 pymor-2022.2.1/docs/source/_templates/autoapi/
-drwxr-xr-x   0 root         (0) root         (0)        0 2023-03-30 17:57:34.215604 pymor-2022.2.1/docs/source/_templates/autoapi/python/
--rw-rw-rw-   0 root         (0) root         (0)     2602 2023-03-30 17:57:23.000000 pymor-2022.2.1/docs/source/_templates/autoapi/python/class.rst
--rw-rw-rw-   0 root         (0) root         (0)     2735 2023-03-30 17:57:23.000000 pymor-2022.2.1/docs/source/_templates/autoapi/python/module.rst
--rw-rw-rw-   0 root         (0) root         (0)      592 2023-03-30 17:57:23.000000 pymor-2022.2.1/docs/source/_templates/layout.html
--rw-rw-rw-   0 root         (0) root         (0)     4317 2023-03-30 17:57:23.000000 pymor-2022.2.1/docs/source/autoapi_pymor.py
--rw-rw-rw-   0 root         (0) root         (0)    17416 2023-03-30 17:57:23.000000 pymor-2022.2.1/docs/source/bibliography.bib
--rw-rw-rw-   0 root         (0) root         (0)      146 2023-03-30 17:57:23.000000 pymor-2022.2.1/docs/source/bibliography.rst
--rw-rw-rw-   0 root         (0) root         (0)    10380 2023-03-30 17:57:23.000000 pymor-2022.2.1/docs/source/conf.py
--rw-rw-rw-   0 root         (0) root         (0)    12294 2023-03-30 17:57:23.000000 pymor-2022.2.1/docs/source/developer_docs.md
--rw-rw-rw-   0 root         (0) root         (0)       40 2023-03-30 17:57:23.000000 pymor-2022.2.1/docs/source/docutils.conf
--rw-rw-rw-   0 root         (0) root         (0)     1417 2023-03-30 17:57:23.000000 pymor-2022.2.1/docs/source/environment.rst
-drwxr-xr-x   0 root         (0) root         (0)        0 2023-03-30 17:57:34.215604 pymor-2022.2.1/docs/source/generated/
--rw-rw-rw-   0 root         (0) root         (0)        0 2023-03-30 17:57:23.000000 pymor-2022.2.1/docs/source/generated/KEEPDIR
--rw-rw-rw-   0 root         (0) root         (0)    11144 2023-03-30 17:57:23.000000 pymor-2022.2.1/docs/source/getting_started.md
--rw-rw-rw-   0 root         (0) root         (0)      480 2023-03-30 17:57:23.000000 pymor-2022.2.1/docs/source/heat_equation.py
--rw-rw-rw-   0 root         (0) root         (0)     1038 2023-03-30 17:57:23.000000 pymor-2022.2.1/docs/source/index.rst
--rw-rw-rw-   0 root         (0) root         (0)      518 2023-03-30 17:57:23.000000 pymor-2022.2.1/docs/source/jupyter_init.txt
--rw-rw-rw-   0 root         (0) root         (0)    45379 2023-03-30 17:57:23.000000 pymor-2022.2.1/docs/source/lstm.svg
--rw-rw-rw-   0 root         (0) root         (0)    38398 2023-03-30 17:57:23.000000 pymor-2022.2.1/docs/source/lstm_cell.svg
--rw-rw-rw-   0 root         (0) root         (0)    46299 2023-03-30 17:57:23.000000 pymor-2022.2.1/docs/source/lstm_cell_forget_gate.svg
--rw-rw-rw-   0 root         (0) root         (0)    46938 2023-03-30 17:57:23.000000 pymor-2022.2.1/docs/source/lstm_cell_input_gate.svg
--rw-rw-rw-   0 root         (0) root         (0)    45997 2023-03-30 17:57:23.000000 pymor-2022.2.1/docs/source/lstm_cell_output_gate.svg
-drwxr-xr-x   0 root         (0) root         (0)        0 2023-03-30 17:57:34.215604 pymor-2022.2.1/docs/source/minimal_cpp_demo/
--rw-rw-rw-   0 root         (0) root         (0)      797 2023-03-30 17:57:23.000000 pymor-2022.2.1/docs/source/minimal_cpp_demo/CMakeLists.txt
--rw-rw-rw-   0 root         (0) root         (0)     2428 2023-03-30 17:57:23.000000 pymor-2022.2.1/docs/source/minimal_cpp_demo/model.cc
--rw-rw-rw-   0 root         (0) root         (0)      667 2023-03-30 17:57:23.000000 pymor-2022.2.1/docs/source/minimal_cpp_demo/model.hh
--rw-rw-rw-   0 root         (0) root         (0)      355 2023-03-30 17:57:23.000000 pymor-2022.2.1/docs/source/myst_code_init.py
--rw-rw-rw-   0 root         (0) root         (0)   277681 2023-03-30 17:57:23.000000 pymor-2022.2.1/docs/source/neural_network.png
--rw-rw-rw-   0 root         (0) root         (0)    56925 2023-03-30 17:57:23.000000 pymor-2022.2.1/docs/source/neural_network.svg
--rw-rw-rw-   0 root         (0) root         (0)       77 2023-03-30 17:57:23.000000 pymor-2022.2.1/docs/source/pymor_defaults.py
--rw-rw-rw-   0 root         (0) root         (0)    13944 2023-03-30 17:57:23.000000 pymor-2022.2.1/docs/source/pymordocstring.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2023-03-30 17:57:34.219604 pymor-2022.2.1/docs/source/release_notes/
--rw-rw-rw-   0 root         (0) root         (0)     1555 2023-03-30 17:57:23.000000 pymor-2022.2.1/docs/source/release_notes/0.3.rst
--rw-rw-rw-   0 root         (0) root         (0)    20566 2023-03-30 17:57:23.000000 pymor-2022.2.1/docs/source/release_notes/0.4.rst
--rw-rw-rw-   0 root         (0) root         (0)    16616 2023-03-30 17:57:23.000000 pymor-2022.2.1/docs/source/release_notes/0.5.rst
--rw-rw-rw-   0 root         (0) root         (0)    16827 2023-03-30 17:57:23.000000 pymor-2022.2.1/docs/source/release_notes/2019.2.rst
--rw-rw-rw-   0 root         (0) root         (0)    11656 2023-03-30 17:57:23.000000 pymor-2022.2.1/docs/source/release_notes/2020.1.rst
--rw-rw-rw-   0 root         (0) root         (0)    10684 2023-03-30 17:57:23.000000 pymor-2022.2.1/docs/source/release_notes/2020.2.rst
--rw-rw-rw-   0 root         (0) root         (0)    10273 2023-03-30 17:57:23.000000 pymor-2022.2.1/docs/source/release_notes/2021.1.rst
--rw-rw-rw-   0 root         (0) root         (0)     7126 2023-03-30 17:57:23.000000 pymor-2022.2.1/docs/source/release_notes/2021.2.rst
--rw-rw-rw-   0 root         (0) root         (0)     7411 2023-03-30 17:57:23.000000 pymor-2022.2.1/docs/source/release_notes/2022.1.rst
--rw-rw-rw-   0 root         (0) root         (0)     7159 2023-03-30 17:57:23.000000 pymor-2022.2.1/docs/source/release_notes/2022.2.rst
--rw-rw-rw-   0 root         (0) root         (0)      294 2023-03-30 17:57:23.000000 pymor-2022.2.1/docs/source/release_notes/all.rst
--rw-rw-rw-   0 root         (0) root         (0)    13278 2023-03-30 17:57:23.000000 pymor-2022.2.1/docs/source/substitutions.py
--rw-rw-rw-   0 root         (0) root         (0)    21244 2023-03-30 17:57:23.000000 pymor-2022.2.1/docs/source/technical_overview.rst
--rw-rw-rw-   0 root         (0) root         (0)     1814 2023-03-30 17:57:23.000000 pymor-2022.2.1/docs/source/try_on_binder.py
--rw-rw-rw-   0 root         (0) root         (0)    32791 2023-03-30 17:57:23.000000 pymor-2022.2.1/docs/source/tutorial_basis_generation.md
--rw-rw-rw-   0 root         (0) root         (0)     7301 2023-03-30 17:57:23.000000 pymor-2022.2.1/docs/source/tutorial_bt.md
--rw-rw-rw-   0 root         (0) root         (0)    14374 2023-03-30 17:57:23.000000 pymor-2022.2.1/docs/source/tutorial_builtin_discretizer.md
--rw-rw-rw-   0 root         (0) root         (0)    15319 2023-03-30 17:57:23.000000 pymor-2022.2.1/docs/source/tutorial_external_solver.md
--rw-rw-rw-   0 root         (0) root         (0)    17171 2023-03-30 17:57:23.000000 pymor-2022.2.1/docs/source/tutorial_lti_systems.md
--rw-rw-rw-   0 root         (0) root         (0)    24683 2023-03-30 17:57:23.000000 pymor-2022.2.1/docs/source/tutorial_mor_with_anns.md
--rw-rw-rw-   0 root         (0) root         (0)    31861 2023-03-30 17:57:23.000000 pymor-2022.2.1/docs/source/tutorial_optimization.md
--rw-rw-rw-   0 root         (0) root         (0)    24360 2023-03-30 17:57:23.000000 pymor-2022.2.1/docs/source/tutorial_projection.md
--rw-rw-rw-   0 root         (0) root         (0)     8968 2023-03-30 17:57:23.000000 pymor-2022.2.1/docs/source/tutorial_unstable_lti_systems.md
--rw-rw-rw-   0 root         (0) root         (0)      290 2023-03-30 17:57:23.000000 pymor-2022.2.1/docs/source/tutorials.rst
--rw-rw-rw-   0 root         (0) root         (0)      395 2023-03-30 17:57:23.000000 pymor-2022.2.1/docs/source/unstable_heat_equation.py
--rw-rw-rw-   0 root         (0) root         (0)     1227 2023-03-30 17:57:23.000000 pymor-2022.2.1/docs/test_tutorials.py
--rw-rw-rw-   0 root         (0) root         (0)      184 2023-03-30 17:57:23.000000 pymor-2022.2.1/pyproject.toml
--rw-rw-rw-   0 root         (0) root         (0)      546 2023-03-30 17:57:23.000000 pymor-2022.2.1/requirements-ci.txt
--rw-rw-rw-   0 root         (0) root         (0)      997 2023-03-30 17:57:23.000000 pymor-2022.2.1/requirements-optional.txt
--rw-rw-rw-   0 root         (0) root         (0)      322 2023-03-30 17:57:23.000000 pymor-2022.2.1/requirements.txt
--rw-rw-rw-   0 root         (0) root         (0)     1158 2023-03-30 17:57:34.307608 pymor-2022.2.1/setup.cfg
--rw-rw-rw-   0 root         (0) root         (0)     3187 2023-03-30 17:57:23.000000 pymor-2022.2.1/setup.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2023-03-30 17:57:34.191603 pymor-2022.2.1/src/
-drwxr-xr-x   0 root         (0) root         (0)        0 2023-03-30 17:57:34.307608 pymor-2022.2.1/src/pymor/
--rw-rw-rw-   0 root         (0) root         (0)     3484 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/__init__.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2023-03-30 17:57:34.231605 pymor-2022.2.1/src/pymor/algorithms/
--rw-rw-rw-   0 root         (0) root         (0)      214 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/algorithms/__init__.py
--rw-rw-rw-   0 root         (0) root         (0)    23266 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/algorithms/adaptivegreedy.py
--rw-rw-rw-   0 root         (0) root         (0)     3274 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/algorithms/basic.py
--rw-rw-rw-   0 root         (0) root         (0)     5128 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/algorithms/bernoulli.py
--rw-rw-rw-   0 root         (0) root         (0)     4063 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/algorithms/dmd.py
--rw-rw-rw-   0 root         (0) root         (0)    24115 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/algorithms/ei.py
--rw-rw-rw-   0 root         (0) root         (0)     7699 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/algorithms/eigs.py
--rw-rw-rw-   0 root         (0) root         (0)    20108 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/algorithms/error.py
--rw-rw-rw-   0 root         (0) root         (0)    35044 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/algorithms/genericsolvers.py
--rw-rw-rw-   0 root         (0) root         (0)     8399 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/algorithms/gram_schmidt.py
--rw-rw-rw-   0 root         (0) root         (0)    11365 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/algorithms/greedy.py
--rw-rw-rw-   0 root         (0) root         (0)    14705 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/algorithms/hapod.py
--rw-rw-rw-   0 root         (0) root         (0)    11171 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/algorithms/image.py
--rw-rw-rw-   0 root         (0) root         (0)     5323 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/algorithms/krylov.py
--rw-rw-rw-   0 root         (0) root         (0)    12089 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/algorithms/lincomb.py
--rw-rw-rw-   0 root         (0) root         (0)     2703 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/algorithms/line_search.py
--rw-rw-rw-   0 root         (0) root         (0)    12988 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/algorithms/lradi.py
--rw-rw-rw-   0 root         (0) root         (0)    12102 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/algorithms/lrradi.py
--rw-rw-rw-   0 root         (0) root         (0)    14161 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/algorithms/lyapunov.py
--rw-rw-rw-   0 root         (0) root         (0)     9098 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/algorithms/newton.py
--rw-rw-rw-   0 root         (0) root         (0)     3101 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/algorithms/pod.py
--rw-rw-rw-   0 root         (0) root         (0)     1899 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/algorithms/preassemble.py
--rw-rw-rw-   0 root         (0) root         (0)    17349 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/algorithms/projection.py
--rw-rw-rw-   0 root         (0) root         (0)    11656 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/algorithms/rand_la.py
--rw-rw-rw-   0 root         (0) root         (0)    11591 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/algorithms/riccati.py
--rw-rw-rw-   0 root         (0) root         (0)    14173 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/algorithms/rules.py
--rw-rw-rw-   0 root         (0) root         (0)    16757 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/algorithms/samdp.py
--rw-rw-rw-   0 root         (0) root         (0)     7757 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/algorithms/simplify.py
--rw-rw-rw-   0 root         (0) root         (0)     6629 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/algorithms/svd_va.py
--rw-rw-rw-   0 root         (0) root         (0)     4804 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/algorithms/sylvester.py
--rw-rw-rw-   0 root         (0) root         (0)    17136 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/algorithms/symplectic.py
--rw-rw-rw-   0 root         (0) root         (0)    12569 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/algorithms/timestepping.py
--rw-rw-rw-   0 root         (0) root         (0)     8987 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/algorithms/to_matrix.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2023-03-30 17:57:34.231605 pymor-2022.2.1/src/pymor/analyticalproblems/
--rw-rw-rw-   0 root         (0) root         (0)      214 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/analyticalproblems/__init__.py
--rw-rw-rw-   0 root         (0) root         (0)     4399 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/analyticalproblems/burgers.py
--rw-rw-rw-   0 root         (0) root         (0)    10605 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/analyticalproblems/domaindescriptions.py
--rw-rw-rw-   0 root         (0) root         (0)     6164 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/analyticalproblems/elliptic.py
--rw-rw-rw-   0 root         (0) root         (0)    26274 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/analyticalproblems/expressions.py
--rw-rw-rw-   0 root         (0) root         (0)    21266 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/analyticalproblems/functions.py
--rw-rw-rw-   0 root         (0) root         (0)     1744 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/analyticalproblems/helmholtz.py
--rw-rw-rw-   0 root         (0) root         (0)     2492 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/analyticalproblems/instationary.py
--rw-rw-rw-   0 root         (0) root         (0)     3446 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/analyticalproblems/text.py
--rw-rw-rw-   0 root         (0) root         (0)     3113 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/analyticalproblems/thermalblock.py
--rw-rw-rw-   0 root         (0) root         (0)     4980 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/basic.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2023-03-30 17:57:34.235605 pymor-2022.2.1/src/pymor/bindings/
--rw-rw-rw-   0 root         (0) root         (0)      213 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/bindings/__init__.py
--rw-rw-rw-   0 root         (0) root         (0)     7042 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/bindings/dunegdt.py
--rw-rw-rw-   0 root         (0) root         (0)    27520 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/bindings/fenics.py
--rw-rw-rw-   0 root         (0) root         (0)     7267 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/bindings/ngsolve.py
--rw-rw-rw-   0 root         (0) root         (0)    25168 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/bindings/pymess.py
--rw-rw-rw-   0 root         (0) root         (0)    24684 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/bindings/scipy.py
--rw-rw-rw-   0 root         (0) root         (0)    13069 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/bindings/slycot.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2023-03-30 17:57:34.235605 pymor-2022.2.1/src/pymor/core/
--rw-rw-rw-   0 root         (0) root         (0)      213 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/core/__init__.py
--rw-rw-rw-   0 root         (0) root         (0)    13923 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/core/base.py
--rw-rw-rw-   0 root         (0) root         (0)    14922 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/core/cache.py
--rw-rw-rw-   0 root         (0) root         (0)     8791 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/core/config.py
--rw-rw-rw-   0 root         (0) root         (0)    16085 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/core/defaults.py
--rw-rw-rw-   0 root         (0) root         (0)     2979 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/core/exceptions.py
--rw-rw-rw-   0 root         (0) root         (0)    11228 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/core/logger.py
--rw-rw-rw-   0 root         (0) root         (0)     6582 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/core/pickle.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2023-03-30 17:57:34.239605 pymor-2022.2.1/src/pymor/discretizers/
--rw-rw-rw-   0 root         (0) root         (0)      214 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/discretizers/__init__.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2023-03-30 17:57:34.239605 pymor-2022.2.1/src/pymor/discretizers/builtin/
--rw-rw-rw-   0 root         (0) root         (0)      641 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/discretizers/builtin/__init__.py
--rw-rw-rw-   0 root         (0) root         (0)    56830 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/discretizers/builtin/cg.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2023-03-30 17:57:34.239605 pymor-2022.2.1/src/pymor/discretizers/builtin/domaindiscretizers/
--rw-rw-rw-   0 root         (0) root         (0)      214 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/discretizers/builtin/domaindiscretizers/__init__.py
--rw-rw-rw-   0 root         (0) root         (0)     8510 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/discretizers/builtin/domaindiscretizers/default.py
--rw-rw-rw-   0 root         (0) root         (0)     9353 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/discretizers/builtin/domaindiscretizers/gmsh.py
--rw-rw-rw-   0 root         (0) root         (0)    50735 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/discretizers/builtin/fv.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2023-03-30 17:57:34.243605 pymor-2022.2.1/src/pymor/discretizers/builtin/grids/
--rw-rw-rw-   0 root         (0) root         (0)      214 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/discretizers/builtin/grids/__init__.py
--rw-rw-rw-   0 root         (0) root         (0)     2796 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/discretizers/builtin/grids/boundaryinfos.py
--rw-rw-rw-   0 root         (0) root         (0)     4619 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/discretizers/builtin/grids/constructions.py
--rw-rw-rw-   0 root         (0) root         (0)     3295 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/discretizers/builtin/grids/gmsh.py
--rw-rw-rw-   0 root         (0) root         (0)    24552 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/discretizers/builtin/grids/interfaces.py
--rw-rw-rw-   0 root         (0) root         (0)     1815 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/discretizers/builtin/grids/io.py
--rw-rw-rw-   0 root         (0) root         (0)     4212 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/discretizers/builtin/grids/oned.py
--rw-rw-rw-   0 root         (0) root         (0)    10871 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/discretizers/builtin/grids/rect.py
--rw-rw-rw-   0 root         (0) root         (0)    12233 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/discretizers/builtin/grids/referenceelements.py
--rw-rw-rw-   0 root         (0) root         (0)     6290 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/discretizers/builtin/grids/subgrid.py
--rw-rw-rw-   0 root         (0) root         (0)    11794 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/discretizers/builtin/grids/tria.py
--rw-rw-rw-   0 root         (0) root         (0)     5116 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/discretizers/builtin/grids/unstructured.py
--rw-rw-rw-   0 root         (0) root         (0)      685 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/discretizers/builtin/grids/vtkio.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2023-03-30 17:57:34.243605 pymor-2022.2.1/src/pymor/discretizers/builtin/gui/
--rw-rw-rw-   0 root         (0) root         (0)      214 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/discretizers/builtin/gui/__init__.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2023-03-30 17:57:34.247605 pymor-2022.2.1/src/pymor/discretizers/builtin/gui/jupyter/
--rw-rw-rw-   0 root         (0) root         (0)     3344 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/discretizers/builtin/gui/jupyter/__init__.py
--rw-rw-rw-   0 root         (0) root         (0)     2907 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/discretizers/builtin/gui/jupyter/logging.py
--rw-rw-rw-   0 root         (0) root         (0)     7060 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/discretizers/builtin/gui/jupyter/matplotlib.py
--rw-rw-rw-   0 root         (0) root         (0)    14913 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/discretizers/builtin/gui/jupyter/threejs.py
--rw-rw-rw-   0 root         (0) root         (0)     4177 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/discretizers/builtin/gui/matplotlib_base.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2023-03-30 17:57:34.247605 pymor-2022.2.1/src/pymor/discretizers/builtin/gui/qt/
--rw-rw-rw-   0 root         (0) root         (0)    19333 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/discretizers/builtin/gui/qt/__init__.py
--rw-rw-rw-   0 root         (0) root         (0)    11926 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/discretizers/builtin/gui/qt/gl.py
--rw-rw-rw-   0 root         (0) root         (0)     2381 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/discretizers/builtin/gui/qt/matplotlib.py
--rw-rw-rw-   0 root         (0) root         (0)     8479 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/discretizers/builtin/gui/visualizers.py
--rw-rw-rw-   0 root         (0) root         (0)     1412 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/discretizers/builtin/inverse.py
--rw-rw-rw-   0 root         (0) root         (0)     2972 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/discretizers/builtin/list.py
--rw-rw-rw-   0 root         (0) root         (0)    22819 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/discretizers/builtin/quadratures.py
--rw-rw-rw-   0 root         (0) root         (0)     1042 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/discretizers/builtin/relations.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2023-03-30 17:57:34.247605 pymor-2022.2.1/src/pymor/discretizers/fenics/
--rw-rw-rw-   0 root         (0) root         (0)      354 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/discretizers/fenics/__init__.py
--rw-rw-rw-   0 root         (0) root         (0)     7419 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/discretizers/fenics/cg.py
--rw-rw-rw-   0 root         (0) root         (0)     2864 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/discretizers/fenics/domaindiscretizer.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2023-03-30 17:57:34.247605 pymor-2022.2.1/src/pymor/discretizers/skfem/
--rw-rw-rw-   0 root         (0) root         (0)        0 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/discretizers/skfem/__init__.py
--rw-rw-rw-   0 root         (0) root         (0)    12332 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/discretizers/skfem/cg.py
--rw-rw-rw-   0 root         (0) root         (0)     3230 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/discretizers/skfem/domaindiscretizer.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2023-03-30 17:57:34.251606 pymor-2022.2.1/src/pymor/models/
--rw-rw-rw-   0 root         (0) root         (0)      214 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/models/__init__.py
--rw-rw-rw-   0 root         (0) root         (0)    15844 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/models/basic.py
--rw-rw-rw-   0 root         (0) root         (0)    28057 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/models/interface.py
--rw-rw-rw-   0 root         (0) root         (0)   120572 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/models/iosys.py
--rw-rw-rw-   0 root         (0) root         (0)     7267 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/models/mpi.py
--rw-rw-rw-   0 root         (0) root         (0)    17352 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/models/neural_network.py
--rw-rw-rw-   0 root         (0) root         (0)     8417 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/models/symplectic.py
--rw-rw-rw-   0 root         (0) root         (0)    25650 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/models/transfer_function.py
--rw-rw-rw-   0 root         (0) root         (0)     5849 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/models/transforms.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2023-03-30 17:57:34.255606 pymor-2022.2.1/src/pymor/operators/
--rw-rw-rw-   0 root         (0) root         (0)      214 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/operators/__init__.py
--rw-rw-rw-   0 root         (0) root         (0)    13498 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/operators/block.py
--rw-rw-rw-   0 root         (0) root         (0)    53056 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/operators/constructions.py
--rw-rw-rw-   0 root         (0) root         (0)    11365 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/operators/ei.py
--rw-rw-rw-   0 root         (0) root         (0)    24488 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/operators/interface.py
--rw-rw-rw-   0 root         (0) root         (0)     9698 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/operators/list.py
--rw-rw-rw-   0 root         (0) root         (0)    13943 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/operators/mpi.py
--rw-rw-rw-   0 root         (0) root         (0)    20273 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/operators/numpy.py
--rw-rw-rw-   0 root         (0) root         (0)     1029 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/operators/symplectic.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2023-03-30 17:57:34.255606 pymor-2022.2.1/src/pymor/parallel/
--rw-rw-rw-   0 root         (0) root         (0)      214 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/parallel/__init__.py
--rw-rw-rw-   0 root         (0) root         (0)     4361 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/parallel/basic.py
--rw-rw-rw-   0 root         (0) root         (0)     2173 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/parallel/default.py
--rw-rw-rw-   0 root         (0) root         (0)     1648 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/parallel/dummy.py
--rw-rw-rw-   0 root         (0) root         (0)     8374 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/parallel/interface.py
--rw-rw-rw-   0 root         (0) root         (0)     8120 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/parallel/ipython.py
--rw-rw-rw-   0 root         (0) root         (0)     1380 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/parallel/manager.py
--rw-rw-rw-   0 root         (0) root         (0)     3227 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/parallel/mpi.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2023-03-30 17:57:34.255606 pymor-2022.2.1/src/pymor/parameters/
--rw-rw-rw-   0 root         (0) root         (0)      214 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/parameters/__init__.py
--rw-rw-rw-   0 root         (0) root         (0)    23435 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/parameters/base.py
--rw-rw-rw-   0 root         (0) root         (0)    25194 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/parameters/functionals.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2023-03-30 17:57:34.259606 pymor-2022.2.1/src/pymor/reductors/
--rw-rw-rw-   0 root         (0) root         (0)      214 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/reductors/__init__.py
--rw-rw-rw-   0 root         (0) root         (0)    18983 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/reductors/aaa.py
--rw-rw-rw-   0 root         (0) root         (0)    20360 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/reductors/basic.py
--rw-rw-rw-   0 root         (0) root         (0)     7036 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/reductors/bt.py
--rw-rw-rw-   0 root         (0) root         (0)    14436 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/reductors/coercive.py
--rw-rw-rw-   0 root         (0) root         (0)    13248 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/reductors/dwr.py
--rw-rw-rw-   0 root         (0) root         (0)    10663 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/reductors/era.py
--rw-rw-rw-   0 root         (0) root         (0)    32154 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/reductors/h2.py
--rw-rw-rw-   0 root         (0) root         (0)    13187 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/reductors/interpolation.py
--rw-rw-rw-   0 root         (0) root         (0)     8336 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/reductors/mt.py
--rw-rw-rw-   0 root         (0) root         (0)    60588 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/reductors/neural_network.py
--rw-rw-rw-   0 root         (0) root         (0)     7551 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/reductors/parabolic.py
--rw-rw-rw-   0 root         (0) root         (0)    13697 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/reductors/residual.py
--rw-rw-rw-   0 root         (0) root         (0)    14357 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/reductors/sobt.py
--rw-rw-rw-   0 root         (0) root         (0)     4776 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/reductors/sor_irka.py
--rw-rw-rw-   0 root         (0) root         (0)     3948 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/reductors/symplectic.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2023-03-30 17:57:34.263606 pymor-2022.2.1/src/pymor/scripts/
--rw-rw-rw-   0 root         (0) root         (0)      214 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/scripts/__init__.py
--rwxrwxrwx   0 root         (0) root         (0)     2099 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/scripts/pymor_demo.py
--rwxrwxrwx   0 root         (0) root         (0)      993 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/scripts/pymor_vis.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2023-03-30 17:57:34.267606 pymor-2022.2.1/src/pymor/tools/
--rw-rw-rw-   0 root         (0) root         (0)      346 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/tools/__init__.py
--rw-rw-rw-   0 root         (0) root         (0)      363 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/tools/context.py
--rw-rw-rw-   0 root         (0) root         (0)      361 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/tools/counter.py
--rw-rw-rw-   0 root         (0) root         (0)     1380 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/tools/deprecated.py
--rw-rw-rw-   0 root         (0) root         (0)     2384 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/tools/floatcmp.py
--rw-rw-rw-   0 root         (0) root         (0)     3910 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/tools/formatrepr.py
--rw-rw-rw-   0 root         (0) root         (0)     1276 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/tools/formatsrc.py
--rw-rw-rw-   0 root         (0) root         (0)     1554 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/tools/frozendict.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2023-03-30 17:57:34.267606 pymor-2022.2.1/src/pymor/tools/io/
--rw-rw-rw-   0 root         (0) root         (0)     1847 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/tools/io/__init__.py
--rw-rw-rw-   0 root         (0) root         (0)     6736 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/tools/io/matrices.py
--rw-rw-rw-   0 root         (0) root         (0)     4123 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/tools/io/vtk.py
--rw-rw-rw-   0 root         (0) root         (0)    10259 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/tools/mpi.py
--rw-rw-rw-   0 root         (0) root         (0)     6685 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/tools/plot.py
--rw-rw-rw-   0 root         (0) root         (0)     1471 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/tools/pprint.py
--rw-rw-rw-   0 root         (0) root         (0)     7176 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/tools/random.py
--rw-rw-rw-   0 root         (0) root         (0)     1640 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/tools/table.py
--rw-rw-rw-   0 root         (0) root         (0)     1781 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/tools/timing.py
--rwxrwxrwx   0 root         (0) root         (0)      815 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/tools/typer.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2023-03-30 17:57:34.267606 pymor-2022.2.1/src/pymor/vectorarrays/
--rw-rw-rw-   0 root         (0) root         (0)      213 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/vectorarrays/__init__.py
--rw-rw-rw-   0 root         (0) root         (0)    10525 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/vectorarrays/block.py
--rw-rw-rw-   0 root         (0) root         (0)      577 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/vectorarrays/constructions.py
--rw-rw-rw-   0 root         (0) root         (0)    37300 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/vectorarrays/interface.py
--rw-rw-rw-   0 root         (0) root         (0)    20624 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/vectorarrays/list.py
--rw-rw-rw-   0 root         (0) root         (0)    15234 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/vectorarrays/mpi.py
--rw-rw-rw-   0 root         (0) root         (0)    10898 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymor/vectorarrays/numpy.py
--rw-r--r--   0 root         (0) root         (0)      500 2023-03-30 17:57:34.307608 pymor-2022.2.1/src/pymor/version.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2023-03-30 17:57:34.219604 pymor-2022.2.1/src/pymor.egg-info/
--rw-r--r--   0 root         (0) root         (0)     9807 2023-03-30 17:57:34.000000 pymor-2022.2.1/src/pymor.egg-info/PKG-INFO
--rw-r--r--   0 root         (0) root         (0)    13979 2023-03-30 17:57:34.000000 pymor-2022.2.1/src/pymor.egg-info/SOURCES.txt
--rw-r--r--   0 root         (0) root         (0)        1 2023-03-30 17:57:34.000000 pymor-2022.2.1/src/pymor.egg-info/dependency_links.txt
--rw-r--r--   0 root         (0) root         (0)      100 2023-03-30 17:57:34.000000 pymor-2022.2.1/src/pymor.egg-info/entry_points.txt
--rw-r--r--   0 root         (0) root         (0)        1 2023-03-30 17:57:33.000000 pymor-2022.2.1/src/pymor.egg-info/not-zip-safe
--rw-r--r--   0 root         (0) root         (0)     1748 2023-03-30 17:57:34.000000 pymor-2022.2.1/src/pymor.egg-info/requires.txt
--rw-r--r--   0 root         (0) root         (0)       28 2023-03-30 17:57:34.000000 pymor-2022.2.1/src/pymor.egg-info/top_level.txt
-drwxr-xr-x   0 root         (0) root         (0)        0 2023-03-30 17:57:34.279607 pymor-2022.2.1/src/pymordemos/
--rw-rw-rw-   0 root         (0) root         (0)      214 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymordemos/__init__.py
--rwxrwxrwx   0 root         (0) root         (0)     8148 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymordemos/analyze_pickle.py
--rwxrwxrwx   0 root         (0) root         (0)     2337 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymordemos/burgers.py
--rwxrwxrwx   0 root         (0) root         (0)     3346 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymordemos/burgers_dmd.py
--rwxrwxrwx   0 root         (0) root         (0)    10194 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymordemos/burgers_ei.py
--rw-rw-rw-   0 root         (0) root         (0)     3911 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymordemos/dd_parametric_heat.py
--rwxrwxrwx   0 root         (0) root         (0)     1254 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymordemos/delay.py
--rwxrwxrwx   0 root         (0) root         (0)     1017 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymordemos/dmd_identification.py
--rwxrwxrwx   0 root         (0) root         (0)     3477 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymordemos/elliptic.py
--rwxrwxrwx   0 root         (0) root         (0)     4250 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymordemos/elliptic2.py
--rwxrwxrwx   0 root         (0) root         (0)     2042 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymordemos/elliptic_oned.py
--rwxrwxrwx   0 root         (0) root         (0)     2031 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymordemos/elliptic_unstructured.py
--rwxrwxrwx   0 root         (0) root         (0)     3157 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymordemos/era.py
--rwxrwxrwx   0 root         (0) root         (0)     4372 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymordemos/fenics_nonlinear.py
--rwxrwxrwx   0 root         (0) root         (0)     4720 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymordemos/function_ei.py
--rwxrwxrwx   0 root         (0) root         (0)     3145 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymordemos/hapod.py
--rwxrwxrwx   0 root         (0) root         (0)     9442 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymordemos/heat.py
--rwxrwxrwx   0 root         (0) root         (0)     6567 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymordemos/linear_optimization.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2023-03-30 17:57:34.279607 pymor-2022.2.1/src/pymordemos/minimal_cpp_demo/
--rw-rw-rw-   0 root         (0) root         (0)      525 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymordemos/minimal_cpp_demo/CMakeLists.txt
--rw-rw-rw-   0 root         (0) root         (0)     2960 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymordemos/minimal_cpp_demo/demo.py
--rw-rw-rw-   0 root         (0) root         (0)     2474 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymordemos/minimal_cpp_demo/model.cc
--rw-rw-rw-   0 root         (0) root         (0)      667 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymordemos/minimal_cpp_demo/model.hh
--rw-rw-rw-   0 root         (0) root         (0)     2420 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymordemos/minimal_cpp_demo/wrapper.py
--rwxrwxrwx   0 root         (0) root         (0)     5801 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymordemos/neural_networks.py
--rwxrwxrwx   0 root         (0) root         (0)     3927 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymordemos/neural_networks_fenics.py
--rwxrwxrwx   0 root         (0) root         (0)    12306 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymordemos/neural_networks_instationary.py
--rwxrwxrwx   0 root         (0) root         (0)     7641 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymordemos/output_error_estimation.py
--rwxrwxrwx   0 root         (0) root         (0)     7930 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymordemos/output_error_estimation_with_dwr.py
--rwxrwxrwx   0 root         (0) root         (0)     3693 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymordemos/parabolic.py
--rwxrwxrwx   0 root         (0) root         (0)    10478 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymordemos/parabolic_mor.py
--rwxrwxrwx   0 root         (0) root         (0)     1477 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymordemos/parametric_delay.py
--rwxrwxrwx   0 root         (0) root         (0)     9019 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymordemos/parametric_heat.py
--rwxrwxrwx   0 root         (0) root         (0)     3084 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymordemos/parametric_string.py
--rwxrwxrwx   0 root         (0) root         (0)     2322 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymordemos/parametric_synthetic.py
--rwxrwxrwx   0 root         (0) root         (0)     4373 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymordemos/phlti.py
--rwxrwxrwx   0 root         (0) root         (0)     3734 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymordemos/string_equation.py
--rw-rw-rw-   0 root         (0) root         (0)     6932 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymordemos/symplectic_wave_equation.py
--rwxrwxrwx   0 root         (0) root         (0)    15519 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymordemos/thermalblock.py
--rwxrwxrwx   0 root         (0) root         (0)     7682 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymordemos/thermalblock_adaptive.py
--rwxrwxrwx   0 root         (0) root         (0)    12905 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymordemos/thermalblock_simple.py
--rwxrwxrwx   0 root         (0) root         (0)     2458 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymordemos/unstable_heat.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2023-03-30 17:57:34.283607 pymor-2022.2.1/src/pymortests/
--rw-rw-rw-   0 root         (0) root         (0)      214 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymortests/__init__.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2023-03-30 17:57:34.287607 pymor-2022.2.1/src/pymortests/algorithms/
--rw-rw-rw-   0 root         (0) root         (0)      214 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymortests/algorithms/__init__.py
--rw-rw-rw-   0 root         (0) root         (0)     7920 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymortests/algorithms/basic.py
--rw-rw-rw-   0 root         (0) root         (0)     2255 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymortests/algorithms/bernoulli.py
--rw-rw-rw-   0 root         (0) root         (0)     2071 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymortests/algorithms/ei.py
--rw-rw-rw-   0 root         (0) root         (0)      752 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymortests/algorithms/eigs.py
--rw-rw-rw-   0 root         (0) root         (0)     5423 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymortests/algorithms/gram_schmidt.py
--rw-rw-rw-   0 root         (0) root         (0)     6873 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymortests/algorithms/lyapunov.py
--rw-rw-rw-   0 root         (0) root         (0)     1815 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymortests/algorithms/pod.py
--rw-rw-rw-   0 root         (0) root         (0)     4375 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymortests/algorithms/projection.py
--rw-rw-rw-   0 root         (0) root         (0)     3056 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymortests/algorithms/rand_la.py
--rw-rw-rw-   0 root         (0) root         (0)     5468 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymortests/algorithms/riccati.py
--rw-rw-rw-   0 root         (0) root         (0)     2472 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymortests/algorithms/samdp.py
--rw-rw-rw-   0 root         (0) root         (0)     2133 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymortests/algorithms/simplify.py
--rw-rw-rw-   0 root         (0) root         (0)     2157 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymortests/algorithms/solver.py
--rw-rw-rw-   0 root         (0) root         (0)     2105 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymortests/algorithms/stuff.py
--rw-rw-rw-   0 root         (0) root         (0)     2535 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymortests/algorithms/svd_va.py
--rw-rw-rw-   0 root         (0) root         (0)     4308 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymortests/algorithms/sylvester.py
--rw-rw-rw-   0 root         (0) root         (0)     3362 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymortests/algorithms/symplectic.py
--rw-rw-rw-   0 root         (0) root         (0)     8583 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymortests/algorithms/to_matrix.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2023-03-30 17:57:34.291607 pymor-2022.2.1/src/pymortests/analyticalproblems/
--rw-rw-rw-   0 root         (0) root         (0)      214 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymortests/analyticalproblems/__init__.py
--rw-rw-rw-   0 root         (0) root         (0)     1035 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymortests/analyticalproblems/analyticalproblem.py
--rw-rw-rw-   0 root         (0) root         (0)     2824 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymortests/analyticalproblems/function.py
--rw-rw-rw-   0 root         (0) root         (0)      689 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymortests/analyticalproblems/polygonal_chain.py
--rw-rw-rw-   0 root         (0) root         (0)     4989 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymortests/base.py
--rw-rw-rw-   0 root         (0) root         (0)      268 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymortests/basic.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2023-03-30 17:57:34.291607 pymor-2022.2.1/src/pymortests/bindings/
--rw-rw-rw-   0 root         (0) root         (0)      214 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymortests/bindings/__init__.py
--rw-rw-rw-   0 root         (0) root         (0)     1323 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymortests/bindings/fenics_expressions.py
--rw-rw-rw-   0 root         (0) root         (0)     2184 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymortests/bindings/skfem.py
--rw-rw-rw-   0 root         (0) root         (0)     3602 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymortests/complex_values.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2023-03-30 17:57:34.291607 pymor-2022.2.1/src/pymortests/core/
--rw-rw-rw-   0 root         (0) root         (0)      214 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymortests/core/__init__.py
--rw-rw-rw-   0 root         (0) root         (0)      647 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymortests/core/base.py
--rw-rw-rw-   0 root         (0) root         (0)     3230 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymortests/core/cache.py
--rw-rw-rw-   0 root         (0) root         (0)     1110 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymortests/core/config.py
--rw-rw-rw-   0 root         (0) root         (0)     1477 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymortests/core/defaults.py
--rw-rw-rw-   0 root         (0) root         (0)     1783 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymortests/core/logger.py
--rw-rw-rw-   0 root         (0) root         (0)     4643 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymortests/core/pickling.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2023-03-30 17:57:34.195603 pymor-2022.2.1/src/pymortests/data/
-drwxr-xr-x   0 root         (0) root         (0)        0 2023-03-30 17:57:34.295607 pymor-2022.2.1/src/pymortests/data/matrices/
--rw-rw-rw-   0 root         (0) root         (0)      160 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymortests/data/matrices/eye.npy
--rw-rw-rw-   0 root         (0) root         (0)      100 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymortests/data/matrices/eye.txt
--rw-rw-rw-   0 root         (0) root         (0)      216 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymortests/data/matrices/eye_compressed.npz
--rw-rw-rw-   0 root         (0) root         (0)      296 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymortests/data/matrices/eye_uncompressed.npz
--rw-rw-rw-   0 root         (0) root         (0)      213 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymortests/data/matrices/matlab.mat
--rw-rw-rw-   0 root         (0) root         (0)    12888 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymortests/demos.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2023-03-30 17:57:34.295607 pymor-2022.2.1/src/pymortests/discretizers/
--rw-rw-rw-   0 root         (0) root         (0)      214 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymortests/discretizers/__init__.py
--rw-rw-rw-   0 root         (0) root         (0)    11550 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymortests/discretizers/affine_grid.py
--rw-rw-rw-   0 root         (0) root         (0)    13914 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymortests/discretizers/grid.py
--rw-rw-rw-   0 root         (0) root         (0)     2079 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymortests/discretizers/gui.py
--rw-rw-rw-   0 root         (0) root         (0)     1421 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymortests/docker_ci_smoketest.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2023-03-30 17:57:34.295607 pymor-2022.2.1/src/pymortests/fixtures/
--rw-rw-rw-   0 root         (0) root         (0)      214 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymortests/fixtures/__init__.py
--rw-rw-rw-   0 root         (0) root         (0)     2643 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymortests/fixtures/analyticalproblem.py
--rw-rw-rw-   0 root         (0) root         (0)     2088 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymortests/fixtures/function.py
--rw-rw-rw-   0 root         (0) root         (0)     4699 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymortests/fixtures/grid.py
--rw-rw-rw-   0 root         (0) root         (0)     1624 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymortests/fixtures/model.py
--rw-rw-rw-   0 root         (0) root         (0)    28753 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymortests/fixtures/operator.py
--rw-rw-rw-   0 root         (0) root         (0)      463 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymortests/fixtures/parameter.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2023-03-30 17:57:34.299608 pymor-2022.2.1/src/pymortests/models/
--rw-rw-rw-   0 root         (0) root         (0)      214 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymortests/models/__init__.py
--rw-rw-rw-   0 root         (0) root         (0)     6527 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymortests/models/iosys_add_sub_mul.py
--rw-rw-rw-   0 root         (0) root         (0)     5842 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymortests/models/iosys_save_load.py
--rw-rw-rw-   0 root         (0) root         (0)     4507 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymortests/models/model.py
--rw-rw-rw-   0 root         (0) root         (0)     2662 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymortests/models/transforms.py
--rw-rw-rw-   0 root         (0) root         (0)     2029 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymortests/mpi_run_demo_tests.py
--rw-rw-rw-   0 root         (0) root         (0)     3174 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymortests/neural_network.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2023-03-30 17:57:34.299608 pymor-2022.2.1/src/pymortests/operators/
--rw-rw-rw-   0 root         (0) root         (0)      214 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymortests/operators/__init__.py
--rw-rw-rw-   0 root         (0) root         (0)     3537 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymortests/operators/block.py
--rw-rw-rw-   0 root         (0) root         (0)      887 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymortests/operators/la.py
--rw-rw-rw-   0 root         (0) root         (0)     4906 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymortests/operators/low_rank_op.py
--rw-rw-rw-   0 root         (0) root         (0)    18626 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymortests/operators/operators.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2023-03-30 17:57:34.299608 pymor-2022.2.1/src/pymortests/parameters/
--rw-rw-rw-   0 root         (0) root         (0)      214 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymortests/parameters/__init__.py
--rw-rw-rw-   0 root         (0) root         (0)     3493 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymortests/parameters/min_max_theta_functionals.py
--rw-rw-rw-   0 root         (0) root         (0)    14505 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymortests/parameters/mu_derivatives.py
--rw-rw-rw-   0 root         (0) root         (0)     2563 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymortests/parameters/parameter_functionals.py
--rw-rw-rw-   0 root         (0) root         (0)     4160 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymortests/parameters/parameters.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2023-03-30 17:57:34.303608 pymor-2022.2.1/src/pymortests/reductors/
--rw-rw-rw-   0 root         (0) root         (0)      214 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymortests/reductors/__init__.py
--rw-rw-rw-   0 root         (0) root         (0)     1117 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymortests/reductors/h2.py
--rw-rw-rw-   0 root         (0) root         (0)    19331 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymortests/strategies.py
-drwxr-xr-x   0 root         (0) root         (0)        0 2023-03-30 17:57:34.195603 pymor-2022.2.1/src/pymortests/testdata/
-drwxr-xr-x   0 root         (0) root         (0)        0 2023-03-30 17:57:34.303608 pymor-2022.2.1/src/pymortests/testdata/check_results/
--rw-rw-rw-   0 root         (0) root         (0)       10 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymortests/testdata/check_results/.artifactignore
-drwxr-xr-x   0 root         (0) root         (0)        0 2023-03-30 17:57:34.303608 pymor-2022.2.1/src/pymortests/testdata/check_results/test_burgers_ei_results/
--rw-rw-rw-   0 root         (0) root         (0)     2191 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymortests/testdata/check_results/test_burgers_ei_results/b399b079a09b42fb54f545f09470717519130bbb
-drwxr-xr-x   0 root         (0) root         (0)        0 2023-03-30 17:57:34.303608 pymor-2022.2.1/src/pymortests/testdata/check_results/test_parabolic_mor_results/
--rw-rw-rw-   0 root         (0) root         (0)     3722 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymortests/testdata/check_results/test_parabolic_mor_results/ca3b1109e5bd10d21b0b9bc432d6ac101cf1fa4d
-drwxr-xr-x   0 root         (0) root         (0)        0 2023-03-30 17:57:34.303608 pymor-2022.2.1/src/pymortests/testdata/check_results/test_thermalblock_results/
--rw-rw-rw-   0 root         (0) root         (0)     1558 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymortests/testdata/check_results/test_thermalblock_results/105686ef68a9b4b3655c790d395526c623efd162
--rw-rw-rw-   0 root         (0) root         (0)     1528 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymortests/testdata/check_results/test_thermalblock_results/29e5f263a02a275f4d29b7e5bdf32ad20c1e6346
--rw-rw-rw-   0 root         (0) root         (0)     1552 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymortests/testdata/check_results/test_thermalblock_results/2f2da29c16865fb149a8025deb79bf849d6631db
--rw-rw-rw-   0 root         (0) root         (0)     1552 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymortests/testdata/check_results/test_thermalblock_results/38a8bfe939551df7383a6058a2862fb9d2eea5a4
--rw-rw-rw-   0 root         (0) root         (0)     1540 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymortests/testdata/check_results/test_thermalblock_results/60f38cd8ac4c21f2c30fafbec18e36e74a42a0be
--rw-rw-rw-   0 root         (0) root         (0)     4668 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymortests/testdata/check_results/test_thermalblock_results/a92ec4631a6f0edc2eae1cc3b0fa17af6c467cef
--rw-rw-rw-   0 root         (0) root         (0)     1529 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymortests/testdata/check_results/test_thermalblock_results/c8a460e412d9170f12508ab3608fd7e1e1750603
--rw-rw-rw-   0 root         (0) root         (0)     1539 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymortests/testdata/check_results/test_thermalblock_results/ce0770de067386276c9e89afa2d63daeb512a9f5
--rw-rw-rw-   0 root         (0) root         (0)     1543 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymortests/testdata/check_results/test_thermalblock_results/ea8f66e263715fd0185d0dd23ab6d57feb6ee898
--rw-rw-rw-   0 root         (0) root         (0)    10228 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymortests/tools.py
--rw-rw-rw-   0 root         (0) root         (0)    35201 2023-03-30 17:57:23.000000 pymor-2022.2.1/src/pymortests/vectorarray.py
--rw-rw-rw-   0 root         (0) root         (0)    70188 2023-03-30 17:57:23.000000 pymor-2022.2.1/versioneer.py
+-rw-r--r--   0        0        0     1213 2020-02-02 00:00:00.000000 pymor-2023.1.0/CITATION.cff
+-rw-r--r--   0        0        0     5936 2020-02-02 00:00:00.000000 pymor-2023.1.0/docs/Makefile
+-rw-r--r--   0        0        0     3570 2020-02-02 00:00:00.000000 pymor-2023.1.0/docs/RELEASE_CHECKLIST.md
+-rw-r--r--   0        0        0     3013 2020-02-02 00:00:00.000000 pymor-2023.1.0/docs/RELEASE_PROCESS.md
+-rw-r--r--   0        0        0     1228 2020-02-02 00:00:00.000000 pymor-2023.1.0/docs/test_tutorials.py
+-rw-r--r--   0        0        0     1493 2020-02-02 00:00:00.000000 pymor-2023.1.0/docs/source/B.png
+-rw-r--r--   0        0        0     1472 2020-02-02 00:00:00.000000 pymor-2023.1.0/docs/source/R.png
+-rw-r--r--   0        0        0     2395 2020-02-02 00:00:00.000000 pymor-2023.1.0/docs/source/RB.png
+-rw-r--r--   0        0        0     4409 2020-02-02 00:00:00.000000 pymor-2023.1.0/docs/source/autoapi_pymor.py
+-rw-r--r--   0        0        0    19502 2020-02-02 00:00:00.000000 pymor-2023.1.0/docs/source/bibliography.bib
+-rw-r--r--   0        0        0      143 2020-02-02 00:00:00.000000 pymor-2023.1.0/docs/source/bibliography.md
+-rw-r--r--   0        0        0    11064 2020-02-02 00:00:00.000000 pymor-2023.1.0/docs/source/conf.py
+-rw-r--r--   0        0        0    10969 2020-02-02 00:00:00.000000 pymor-2023.1.0/docs/source/developer_docs.md
+-rw-r--r--   0        0        0       40 2020-02-02 00:00:00.000000 pymor-2023.1.0/docs/source/docutils.conf
+-rw-r--r--   0        0        0     1923 2020-02-02 00:00:00.000000 pymor-2023.1.0/docs/source/environment.md
+-rw-r--r--   0        0        0     7643 2020-02-02 00:00:00.000000 pymor-2023.1.0/docs/source/getting_started.md
+-rw-r--r--   0        0        0      480 2020-02-02 00:00:00.000000 pymor-2023.1.0/docs/source/heat_equation.py
+-rw-r--r--   0        0        0      597 2020-02-02 00:00:00.000000 pymor-2023.1.0/docs/source/index.md
+-rw-r--r--   0        0        0      518 2020-02-02 00:00:00.000000 pymor-2023.1.0/docs/source/jupyter_init.txt
+-rw-r--r--   0        0        0    45379 2020-02-02 00:00:00.000000 pymor-2023.1.0/docs/source/lstm.svg
+-rw-r--r--   0        0        0    38398 2020-02-02 00:00:00.000000 pymor-2023.1.0/docs/source/lstm_cell.svg
+-rw-r--r--   0        0        0    46299 2020-02-02 00:00:00.000000 pymor-2023.1.0/docs/source/lstm_cell_forget_gate.svg
+-rw-r--r--   0        0        0    46938 2020-02-02 00:00:00.000000 pymor-2023.1.0/docs/source/lstm_cell_input_gate.svg
+-rw-r--r--   0        0        0    45997 2020-02-02 00:00:00.000000 pymor-2023.1.0/docs/source/lstm_cell_output_gate.svg
+-rw-r--r--   0        0        0      441 2020-02-02 00:00:00.000000 pymor-2023.1.0/docs/source/myst_code_init.py
+-rw-r--r--   0        0        0    56925 2020-02-02 00:00:00.000000 pymor-2023.1.0/docs/source/neural_network.svg
+-rw-r--r--   0        0        0      173 2020-02-02 00:00:00.000000 pymor-2023.1.0/docs/source/pymor_defaults.py
+-rw-r--r--   0        0        0    13944 2020-02-02 00:00:00.000000 pymor-2023.1.0/docs/source/pymordocstring.py
+-rw-r--r--   0        0        0    13319 2020-02-02 00:00:00.000000 pymor-2023.1.0/docs/source/substitutions.py
+-rw-r--r--   0        0        0    20682 2020-02-02 00:00:00.000000 pymor-2023.1.0/docs/source/technical_overview.rst
+-rw-r--r--   0        0        0     1993 2020-02-02 00:00:00.000000 pymor-2023.1.0/docs/source/try_on_binder.py
+-rw-r--r--   0        0        0    32611 2020-02-02 00:00:00.000000 pymor-2023.1.0/docs/source/tutorial_basis_generation.md
+-rw-r--r--   0        0        0     7300 2020-02-02 00:00:00.000000 pymor-2023.1.0/docs/source/tutorial_bt.md
+-rw-r--r--   0        0        0    14408 2020-02-02 00:00:00.000000 pymor-2023.1.0/docs/source/tutorial_builtin_discretizer.md
+-rw-r--r--   0        0        0    15240 2020-02-02 00:00:00.000000 pymor-2023.1.0/docs/source/tutorial_external_solver.md
+-rw-r--r--   0        0        0     4272 2020-02-02 00:00:00.000000 pymor-2023.1.0/docs/source/tutorial_interact.md
+-rw-r--r--   0        0        0    17671 2020-02-02 00:00:00.000000 pymor-2023.1.0/docs/source/tutorial_lti_systems.md
+-rw-r--r--   0        0        0    24474 2020-02-02 00:00:00.000000 pymor-2023.1.0/docs/source/tutorial_mor_with_anns.md
+-rw-r--r--   0        0        0    32047 2020-02-02 00:00:00.000000 pymor-2023.1.0/docs/source/tutorial_optimization.md
+-rw-r--r--   0        0        0    23955 2020-02-02 00:00:00.000000 pymor-2023.1.0/docs/source/tutorial_projection.md
+-rw-r--r--   0        0        0     8929 2020-02-02 00:00:00.000000 pymor-2023.1.0/docs/source/tutorial_unstable_lti_systems.md
+-rw-r--r--   0        0        0      262 2020-02-02 00:00:00.000000 pymor-2023.1.0/docs/source/tutorials.md
+-rw-r--r--   0        0        0      395 2020-02-02 00:00:00.000000 pymor-2023.1.0/docs/source/unstable_heat_equation.py
+-rw-r--r--   0        0        0     3489 2020-02-02 00:00:00.000000 pymor-2023.1.0/docs/source/_static/pymor.css
+-rw-r--r--   0        0        0      592 2020-02-02 00:00:00.000000 pymor-2023.1.0/docs/source/_templates/layout.html
+-rw-r--r--   0        0        0     2602 2020-02-02 00:00:00.000000 pymor-2023.1.0/docs/source/_templates/autoapi/python/class.rst
+-rw-r--r--   0        0        0     2735 2020-02-02 00:00:00.000000 pymor-2023.1.0/docs/source/_templates/autoapi/python/module.rst
+-rw-r--r--   0        0        0        0 2020-02-02 00:00:00.000000 pymor-2023.1.0/docs/source/generated/KEEPDIR
+-rw-r--r--   0        0        0      735 2020-02-02 00:00:00.000000 pymor-2023.1.0/docs/source/minimal_cpp_demo/CMakeLists.txt
+-rw-r--r--   0        0        0     2428 2020-02-02 00:00:00.000000 pymor-2023.1.0/docs/source/minimal_cpp_demo/model.cc
+-rw-r--r--   0        0        0      667 2020-02-02 00:00:00.000000 pymor-2023.1.0/docs/source/minimal_cpp_demo/model.hh
+-rw-r--r--   0        0        0     1554 2020-02-02 00:00:00.000000 pymor-2023.1.0/docs/source/release_notes/0.3.rst
+-rw-r--r--   0        0        0    19186 2020-02-02 00:00:00.000000 pymor-2023.1.0/docs/source/release_notes/0.4.rst
+-rw-r--r--   0        0        0    16142 2020-02-02 00:00:00.000000 pymor-2023.1.0/docs/source/release_notes/0.5.rst
+-rw-r--r--   0        0        0    15823 2020-02-02 00:00:00.000000 pymor-2023.1.0/docs/source/release_notes/2019.2.rst
+-rw-r--r--   0        0        0    11654 2020-02-02 00:00:00.000000 pymor-2023.1.0/docs/source/release_notes/2020.1.rst
+-rw-r--r--   0        0        0    10528 2020-02-02 00:00:00.000000 pymor-2023.1.0/docs/source/release_notes/2020.2.rst
+-rw-r--r--   0        0        0    10272 2020-02-02 00:00:00.000000 pymor-2023.1.0/docs/source/release_notes/2021.1.rst
+-rw-r--r--   0        0        0     7125 2020-02-02 00:00:00.000000 pymor-2023.1.0/docs/source/release_notes/2021.2.rst
+-rw-r--r--   0        0        0     7410 2020-02-02 00:00:00.000000 pymor-2023.1.0/docs/source/release_notes/2022.1.rst
+-rw-r--r--   0        0        0     7159 2020-02-02 00:00:00.000000 pymor-2023.1.0/docs/source/release_notes/2022.2.rst
+-rw-r--r--   0        0        0     6831 2020-02-02 00:00:00.000000 pymor-2023.1.0/docs/source/release_notes/2023.1.rst
+-rw-r--r--   0        0        0      318 2020-02-02 00:00:00.000000 pymor-2023.1.0/docs/source/release_notes/all.rst
+-rw-r--r--   0        0        0     3418 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/__init__.py
+-rw-r--r--   0        0        0     6279 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/basic.py
+-rw-r--r--   0        0        0      214 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/algorithms/__init__.py
+-rw-r--r--   0        0        0    23266 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/algorithms/adaptivegreedy.py
+-rw-r--r--   0        0        0     3413 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/algorithms/basic.py
+-rw-r--r--   0        0        0     5128 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/algorithms/bernoulli.py
+-rw-r--r--   0        0        0    13155 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/algorithms/bfgs.py
+-rw-r--r--   0        0        0     4063 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/algorithms/dmd.py
+-rw-r--r--   0        0        0    24115 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/algorithms/ei.py
+-rw-r--r--   0        0        0     7699 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/algorithms/eigs.py
+-rw-r--r--   0        0        0    20108 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/algorithms/error.py
+-rw-r--r--   0        0        0    35045 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/algorithms/genericsolvers.py
+-rw-r--r--   0        0        0     8399 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/algorithms/gram_schmidt.py
+-rw-r--r--   0        0        0    11365 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/algorithms/greedy.py
+-rw-r--r--   0        0        0    14713 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/algorithms/hapod.py
+-rw-r--r--   0        0        0    11171 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/algorithms/image.py
+-rw-r--r--   0        0        0     5323 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/algorithms/krylov.py
+-rw-r--r--   0        0        0    12388 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/algorithms/lincomb.py
+-rw-r--r--   0        0        0     6839 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/algorithms/line_search.py
+-rw-r--r--   0        0        0    12988 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/algorithms/lradi.py
+-rw-r--r--   0        0        0    12244 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/algorithms/lrradi.py
+-rw-r--r--   0        0        0    14160 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/algorithms/lyapunov.py
+-rw-r--r--   0        0        0     9101 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/algorithms/newton.py
+-rw-r--r--   0        0        0     3101 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/algorithms/pod.py
+-rw-r--r--   0        0        0     1990 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/algorithms/preassemble.py
+-rw-r--r--   0        0        0    17436 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/algorithms/projection.py
+-rw-r--r--   0        0        0    11656 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/algorithms/rand_la.py
+-rw-r--r--   0        0        0    12871 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/algorithms/riccati.py
+-rw-r--r--   0        0        0    14241 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/algorithms/rules.py
+-rw-r--r--   0        0        0    16993 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/algorithms/samdp.py
+-rw-r--r--   0        0        0     8191 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/algorithms/simplify.py
+-rw-r--r--   0        0        0     6629 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/algorithms/svd_va.py
+-rw-r--r--   0        0        0     4804 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/algorithms/sylvester.py
+-rw-r--r--   0        0        0    17036 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/algorithms/symplectic.py
+-rw-r--r--   0        0        0    15644 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/algorithms/timestepping.py
+-rw-r--r--   0        0        0     9003 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/algorithms/to_matrix.py
+-rw-r--r--   0        0        0    23098 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/algorithms/tr.py
+-rw-r--r--   0        0        0      214 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/analyticalproblems/__init__.py
+-rw-r--r--   0        0        0     4399 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/analyticalproblems/burgers.py
+-rw-r--r--   0        0        0    10604 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/analyticalproblems/domaindescriptions.py
+-rw-r--r--   0        0        0     6338 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/analyticalproblems/elliptic.py
+-rw-r--r--   0        0        0    27360 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/analyticalproblems/expressions.py
+-rw-r--r--   0        0        0    21942 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/analyticalproblems/functions.py
+-rw-r--r--   0        0        0     1744 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/analyticalproblems/helmholtz.py
+-rw-r--r--   0        0        0     2492 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/analyticalproblems/instationary.py
+-rw-r--r--   0        0        0     3446 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/analyticalproblems/text.py
+-rw-r--r--   0        0        0     3095 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/analyticalproblems/thermalblock.py
+-rw-r--r--   0        0        0      213 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/bindings/__init__.py
+-rw-r--r--   0        0        0     7136 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/bindings/dunegdt.py
+-rw-r--r--   0        0        0    27517 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/bindings/fenics.py
+-rw-r--r--   0        0        0     7266 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/bindings/ngsolve.py
+-rw-r--r--   0        0        0    25435 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/bindings/pymess.py
+-rw-r--r--   0        0        0    25073 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/bindings/scipy.py
+-rw-r--r--   0        0        0    13471 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/bindings/slycot.py
+-rw-r--r--   0        0        0      213 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/core/__init__.py
+-rw-r--r--   0        0        0    13948 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/core/base.py
+-rw-r--r--   0        0        0    14922 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/core/cache.py
+-rw-r--r--   0        0        0     8746 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/core/config.py
+-rw-r--r--   0        0        0    16094 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/core/defaults.py
+-rw-r--r--   0        0        0     3353 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/core/exceptions.py
+-rw-r--r--   0        0        0    11228 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/core/logger.py
+-rw-r--r--   0        0        0     6813 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/core/pickle.py
+-rw-r--r--   0        0        0      214 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/discretizers/__init__.py
+-rw-r--r--   0        0        0      641 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/discretizers/builtin/__init__.py
+-rw-r--r--   0        0        0    57910 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/discretizers/builtin/cg.py
+-rw-r--r--   0        0        0    51115 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/discretizers/builtin/fv.py
+-rw-r--r--   0        0        0     1414 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/discretizers/builtin/inverse.py
+-rw-r--r--   0        0        0     3001 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/discretizers/builtin/list.py
+-rw-r--r--   0        0        0    22820 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/discretizers/builtin/quadratures.py
+-rw-r--r--   0        0        0     1041 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/discretizers/builtin/relations.py
+-rw-r--r--   0        0        0      214 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/discretizers/builtin/domaindiscretizers/__init__.py
+-rw-r--r--   0        0        0     8817 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/discretizers/builtin/domaindiscretizers/default.py
+-rw-r--r--   0        0        0     9295 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/discretizers/builtin/domaindiscretizers/gmsh.py
+-rw-r--r--   0        0        0      214 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/discretizers/builtin/grids/__init__.py
+-rw-r--r--   0        0        0     2796 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/discretizers/builtin/grids/boundaryinfos.py
+-rw-r--r--   0        0        0     4619 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/discretizers/builtin/grids/constructions.py
+-rw-r--r--   0        0        0     3275 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/discretizers/builtin/grids/gmsh.py
+-rw-r--r--   0        0        0    24593 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/discretizers/builtin/grids/interfaces.py
+-rw-r--r--   0        0        0     1816 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/discretizers/builtin/grids/io.py
+-rw-r--r--   0        0        0     4212 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/discretizers/builtin/grids/oned.py
+-rw-r--r--   0        0        0    10871 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/discretizers/builtin/grids/rect.py
+-rw-r--r--   0        0        0    12233 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/discretizers/builtin/grids/referenceelements.py
+-rw-r--r--   0        0        0     6198 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/discretizers/builtin/grids/subgrid.py
+-rw-r--r--   0        0        0    11794 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/discretizers/builtin/grids/tria.py
+-rw-r--r--   0        0        0     5116 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/discretizers/builtin/grids/unstructured.py
+-rw-r--r--   0        0        0      687 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/discretizers/builtin/grids/vtkio.py
+-rw-r--r--   0        0        0      214 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/discretizers/builtin/gui/__init__.py
+-rw-r--r--   0        0        0     4238 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/discretizers/builtin/gui/matplotlib_base.py
+-rw-r--r--   0        0        0     9123 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/discretizers/builtin/gui/visualizers.py
+-rw-r--r--   0        0        0     3553 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/discretizers/builtin/gui/jupyter/__init__.py
+-rw-r--r--   0        0        0      985 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/discretizers/builtin/gui/jupyter/animation_widget.py
+-rw-r--r--   0        0        0    13406 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/discretizers/builtin/gui/jupyter/kthreed.py
+-rw-r--r--   0        0        0     2908 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/discretizers/builtin/gui/jupyter/logging.py
+-rw-r--r--   0        0        0    11111 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/discretizers/builtin/gui/jupyter/matplotlib.py
+-rw-r--r--   0        0        0    19358 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/discretizers/builtin/gui/qt/__init__.py
+-rw-r--r--   0        0        0    11951 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/discretizers/builtin/gui/qt/gl.py
+-rw-r--r--   0        0        0     2381 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/discretizers/builtin/gui/qt/matplotlib.py
+-rw-r--r--   0        0        0      354 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/discretizers/fenics/__init__.py
+-rw-r--r--   0        0        0     7533 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/discretizers/fenics/cg.py
+-rw-r--r--   0        0        0     2835 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/discretizers/fenics/domaindiscretizer.py
+-rw-r--r--   0        0        0        0 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/discretizers/skfem/__init__.py
+-rw-r--r--   0        0        0    12339 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/discretizers/skfem/cg.py
+-rw-r--r--   0        0        0     3201 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/discretizers/skfem/domaindiscretizer.py
+-rw-r--r--   0        0        0      214 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/models/__init__.py
+-rw-r--r--   0        0        0    15895 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/models/basic.py
+-rw-r--r--   0        0        0     1212 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/models/examples.py
+-rw-r--r--   0        0        0    10264 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/models/interact.py
+-rw-r--r--   0        0        0    28079 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/models/interface.py
+-rw-r--r--   0        0        0   119220 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/models/iosys.py
+-rw-r--r--   0        0        0     7267 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/models/mpi.py
+-rw-r--r--   0        0        0    17368 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/models/neural_network.py
+-rw-r--r--   0        0        0     8418 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/models/symplectic.py
+-rw-r--r--   0        0        0    27954 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/models/transfer_function.py
+-rw-r--r--   0        0        0     5849 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/models/transforms.py
+-rw-r--r--   0        0        0      214 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/operators/__init__.py
+-rw-r--r--   0        0        0    13998 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/operators/block.py
+-rw-r--r--   0        0        0    55512 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/operators/constructions.py
+-rw-r--r--   0        0        0    11340 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/operators/ei.py
+-rw-r--r--   0        0        0    24910 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/operators/interface.py
+-rw-r--r--   0        0        0     9811 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/operators/list.py
+-rw-r--r--   0        0        0    13943 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/operators/mpi.py
+-rw-r--r--   0        0        0    20273 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/operators/numpy.py
+-rw-r--r--   0        0        0     1029 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/operators/symplectic.py
+-rw-r--r--   0        0        0      214 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/parallel/__init__.py
+-rw-r--r--   0        0        0     4425 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/parallel/basic.py
+-rw-r--r--   0        0        0     2173 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/parallel/default.py
+-rw-r--r--   0        0        0     1710 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/parallel/dummy.py
+-rw-r--r--   0        0        0     8338 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/parallel/interface.py
+-rw-r--r--   0        0        0     8134 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/parallel/ipython.py
+-rw-r--r--   0        0        0     1380 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/parallel/manager.py
+-rw-r--r--   0        0        0     3226 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/parallel/mpi.py
+-rw-r--r--   0        0        0      214 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/parameters/__init__.py
+-rw-r--r--   0        0        0    28791 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/parameters/base.py
+-rw-r--r--   0        0        0    25196 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/parameters/functionals.py
+-rw-r--r--   0        0        0      214 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/reductors/__init__.py
+-rw-r--r--   0        0        0    19876 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/reductors/aaa.py
+-rw-r--r--   0        0        0    20360 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/reductors/basic.py
+-rw-r--r--   0        0        0     7744 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/reductors/bt.py
+-rw-r--r--   0        0        0    14436 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/reductors/coercive.py
+-rw-r--r--   0        0        0    13222 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/reductors/dwr.py
+-rw-r--r--   0        0        0    10663 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/reductors/era.py
+-rw-r--r--   0        0        0    32154 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/reductors/h2.py
+-rw-r--r--   0        0        0    13181 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/reductors/interpolation.py
+-rw-r--r--   0        0        0    14745 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/reductors/loewner.py
+-rw-r--r--   0        0        0     8337 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/reductors/mt.py
+-rw-r--r--   0        0        0    60557 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/reductors/neural_network.py
+-rw-r--r--   0        0        0     7551 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/reductors/parabolic.py
+-rw-r--r--   0        0        0    13697 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/reductors/residual.py
+-rw-r--r--   0        0        0    14357 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/reductors/sobt.py
+-rw-r--r--   0        0        0     4776 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/reductors/sor_irka.py
+-rw-r--r--   0        0        0     5952 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/reductors/spectral_factor.py
+-rw-r--r--   0        0        0     3910 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/reductors/symplectic.py
+-rw-r--r--   0        0        0      213 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/reductors/ph/__init__.py
+-rw-r--r--   0        0        0     2795 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/reductors/ph/basic.py
+-rw-r--r--   0        0        0     4689 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/reductors/ph/ph_irka.py
+-rw-r--r--   0        0        0      214 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/scripts/__init__.py
+-rwxr-xr-x   0        0        0     2035 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/scripts/pymor_demo.py
+-rwxr-xr-x   0        0        0      993 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/scripts/pymor_vis.py
+-rw-r--r--   0        0        0      311 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/tools/__init__.py
+-rw-r--r--   0        0        0      363 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/tools/context.py
+-rw-r--r--   0        0        0      361 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/tools/counter.py
+-rw-r--r--   0        0        0     1381 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/tools/deprecated.py
+-rw-r--r--   0        0        0     2384 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/tools/floatcmp.py
+-rw-r--r--   0        0        0     3910 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/tools/formatrepr.py
+-rw-r--r--   0        0        0     1276 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/tools/formatsrc.py
+-rw-r--r--   0        0        0     1554 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/tools/frozendict.py
+-rw-r--r--   0        0        0    10260 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/tools/mpi.py
+-rw-r--r--   0        0        0     6689 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/tools/plot.py
+-rw-r--r--   0        0        0     1471 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/tools/pprint.py
+-rw-r--r--   0        0        0     7191 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/tools/random.py
+-rw-r--r--   0        0        0     1641 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/tools/table.py
+-rw-r--r--   0        0        0     1782 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/tools/timing.py
+-rwxr-xr-x   0        0        0      816 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/tools/typer.py
+-rw-r--r--   0        0        0     1849 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/tools/io/__init__.py
+-rw-r--r--   0        0        0     6736 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/tools/io/matrices.py
+-rw-r--r--   0        0        0     4136 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/tools/io/vtk.py
+-rw-r--r--   0        0        0      213 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/vectorarrays/__init__.py
+-rw-r--r--   0        0        0    10554 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/vectorarrays/block.py
+-rw-r--r--   0        0        0      577 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/vectorarrays/constructions.py
+-rw-r--r--   0        0        0    37337 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/vectorarrays/interface.py
+-rw-r--r--   0        0        0    20748 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/vectorarrays/list.py
+-rw-r--r--   0        0        0    15234 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/vectorarrays/mpi.py
+-rw-r--r--   0        0        0    11035 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymor/vectorarrays/numpy.py
+-rw-r--r--   0        0        0      214 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymordemos/__init__.py
+-rwxr-xr-x   0        0        0     8148 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymordemos/analyze_pickle.py
+-rwxr-xr-x   0        0        0     2337 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymordemos/burgers.py
+-rwxr-xr-x   0        0        0     3347 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymordemos/burgers_dmd.py
+-rwxr-xr-x   0        0        0    10183 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymordemos/burgers_ei.py
+-rwxr-xr-x   0        0        0     3075 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymordemos/dd_heat.py
+-rwxr-xr-x   0        0        0     3911 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymordemos/dd_parametric_heat.py
+-rwxr-xr-x   0        0        0     1179 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymordemos/delay.py
+-rwxr-xr-x   0        0        0     1016 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymordemos/dmd_identification.py
+-rwxr-xr-x   0        0        0     3459 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymordemos/elliptic.py
+-rwxr-xr-x   0        0        0     4250 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymordemos/elliptic2.py
+-rwxr-xr-x   0        0        0     2042 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymordemos/elliptic_oned.py
+-rwxr-xr-x   0        0        0     2031 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymordemos/elliptic_unstructured.py
+-rwxr-xr-x   0        0        0     3232 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymordemos/era.py
+-rwxr-xr-x   0        0        0     4373 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymordemos/fenics_nonlinear.py
+-rwxr-xr-x   0        0        0     4713 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymordemos/function_ei.py
+-rwxr-xr-x   0        0        0     3145 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymordemos/hapod.py
+-rwxr-xr-x   0        0        0    13674 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymordemos/heat.py
+-rwxr-xr-x   0        0        0     6594 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymordemos/linear_optimization.py
+-rwxr-xr-x   0        0        0     5812 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymordemos/neural_networks.py
+-rwxr-xr-x   0        0        0     3936 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymordemos/neural_networks_fenics.py
+-rwxr-xr-x   0        0        0    12242 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymordemos/neural_networks_instationary.py
+-rwxr-xr-x   0        0        0     7641 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymordemos/output_error_estimation.py
+-rwxr-xr-x   0        0        0     7930 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymordemos/output_error_estimation_with_dwr.py
+-rwxr-xr-x   0        0        0     3617 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymordemos/parabolic.py
+-rwxr-xr-x   0        0        0    10432 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymordemos/parabolic_mor.py
+-rwxr-xr-x   0        0        0     1477 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymordemos/parametric_delay.py
+-rwxr-xr-x   0        0        0    12411 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymordemos/parametric_heat.py
+-rwxr-xr-x   0        0        0     3077 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymordemos/parametric_string.py
+-rwxr-xr-x   0        0        0     2322 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymordemos/parametric_synthetic.py
+-rwxr-xr-x   0        0        0     5955 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymordemos/phlti.py
+-rwxr-xr-x   0        0        0     2808 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymordemos/string_equation.py
+-rwxr-xr-x   0        0        0     6932 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymordemos/symplectic_wave_equation.py
+-rwxr-xr-x   0        0        0    15519 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymordemos/thermalblock.py
+-rwxr-xr-x   0        0        0     7682 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymordemos/thermalblock_adaptive.py
+-rwxr-xr-x   0        0        0    12966 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymordemos/thermalblock_simple.py
+-rwxr-xr-x   0        0        0     7026 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymordemos/trust_region.py
+-rwxr-xr-x   0        0        0     2373 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymordemos/unstable_heat.py
+-rw-r--r--   0        0        0      525 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymordemos/minimal_cpp_demo/CMakeLists.txt
+-rw-r--r--   0        0        0     2960 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymordemos/minimal_cpp_demo/demo.py
+-rw-r--r--   0        0        0     2474 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymordemos/minimal_cpp_demo/model.cc
+-rw-r--r--   0        0        0      667 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymordemos/minimal_cpp_demo/model.hh
+-rw-r--r--   0        0        0     2421 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymordemos/minimal_cpp_demo/wrapper.py
+-rw-r--r--   0        0        0      214 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/__init__.py
+-rw-r--r--   0        0        0     4442 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/base.py
+-rw-r--r--   0        0        0      317 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/basic.py
+-rw-r--r--   0        0        0     3650 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/complex_values.py
+-rw-r--r--   0        0        0    14131 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/demos.py
+-rw-r--r--   0        0        0     2095 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/mpi_run_demo_tests.py
+-rw-r--r--   0        0        0     3179 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/neural_network.py
+-rw-r--r--   0        0        0    20150 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/strategies.py
+-rw-r--r--   0        0        0    10264 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/tools.py
+-rw-r--r--   0        0        0    35253 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/vectorarray.py
+-rw-r--r--   0        0        0      214 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/algorithms/__init__.py
+-rw-r--r--   0        0        0     8015 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/algorithms/basic.py
+-rw-r--r--   0        0        0     2287 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/algorithms/bernoulli.py
+-rw-r--r--   0        0        0     1479 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/algorithms/bfgs.py
+-rw-r--r--   0        0        0     2071 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/algorithms/ei.py
+-rw-r--r--   0        0        0      786 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/algorithms/eigs.py
+-rw-r--r--   0        0        0     5709 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/algorithms/gram_schmidt.py
+-rw-r--r--   0        0        0     7011 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/algorithms/lyapunov.py
+-rw-r--r--   0        0        0     2138 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/algorithms/newton.py
+-rw-r--r--   0        0        0     1781 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/algorithms/pod.py
+-rw-r--r--   0        0        0     5127 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/algorithms/projection.py
+-rw-r--r--   0        0        0     3104 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/algorithms/rand_la.py
+-rw-r--r--   0        0        0     6363 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/algorithms/riccati.py
+-rw-r--r--   0        0        0     2589 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/algorithms/samdp.py
+-rw-r--r--   0        0        0     2243 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/algorithms/simplify.py
+-rw-r--r--   0        0        0     2191 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/algorithms/solver.py
+-rw-r--r--   0        0        0     2522 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/algorithms/svd_va.py
+-rw-r--r--   0        0        0     4341 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/algorithms/sylvester.py
+-rw-r--r--   0        0        0     3548 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/algorithms/symplectic.py
+-rw-r--r--   0        0        0     8838 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/algorithms/to_matrix.py
+-rw-r--r--   0        0        0     1783 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/algorithms/tr.py
+-rw-r--r--   0        0        0      214 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/analyticalproblems/__init__.py
+-rw-r--r--   0        0        0     1084 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/analyticalproblems/analyticalproblem.py
+-rw-r--r--   0        0        0     2776 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/analyticalproblems/function.py
+-rw-r--r--   0        0        0      952 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/analyticalproblems/polygonal_chain.py
+-rw-r--r--   0        0        0      214 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/bindings/__init__.py
+-rw-r--r--   0        0        0     1297 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/bindings/fenics_expressions.py
+-rw-r--r--   0        0        0     2081 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/bindings/skfem.py
+-rw-r--r--   0        0        0      214 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/core/__init__.py
+-rw-r--r--   0        0        0      695 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/core/base.py
+-rw-r--r--   0        0        0     3266 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/core/cache.py
+-rw-r--r--   0        0        0     1155 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/core/config.py
+-rw-r--r--   0        0        0     1511 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/core/defaults.py
+-rw-r--r--   0        0        0     1814 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/core/logger.py
+-rw-r--r--   0        0        0     4644 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/core/pickling.py
+-rw-r--r--   0        0        0      160 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/data/matrices/eye.npy
+-rw-r--r--   0        0        0      100 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/data/matrices/eye.txt
+-rw-r--r--   0        0        0      216 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/data/matrices/eye_compressed.npz
+-rw-r--r--   0        0        0      296 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/data/matrices/eye_uncompressed.npz
+-rw-r--r--   0        0        0      213 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/data/matrices/matlab.mat
+-rw-r--r--   0        0        0      214 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/discretizers/__init__.py
+-rw-r--r--   0        0        0    11595 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/discretizers/affine_grid.py
+-rw-r--r--   0        0        0      733 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/discretizers/fenics.py
+-rw-r--r--   0        0        0    13694 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/discretizers/grid.py
+-rw-r--r--   0        0        0     2122 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/discretizers/gui.py
+-rw-r--r--   0        0        0      214 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/fixtures/__init__.py
+-rw-r--r--   0        0        0     2642 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/fixtures/analyticalproblem.py
+-rw-r--r--   0        0        0     2164 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/fixtures/function.py
+-rw-r--r--   0        0        0     4699 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/fixtures/grid.py
+-rw-r--r--   0        0        0     1741 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/fixtures/model.py
+-rw-r--r--   0        0        0    29291 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/fixtures/operator.py
+-rw-r--r--   0        0        0      463 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/fixtures/parameter.py
+-rw-r--r--   0        0        0      214 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/models/__init__.py
+-rw-r--r--   0        0        0    10056 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/models/iosys_add_sub_mul.py
+-rw-r--r--   0        0        0     7648 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/models/iosys_save_load.py
+-rw-r--r--   0        0        0     4541 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/models/model.py
+-rw-r--r--   0        0        0     2696 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/models/transforms.py
+-rw-r--r--   0        0        0      214 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/operators/__init__.py
+-rw-r--r--   0        0        0     4808 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/operators/block.py
+-rw-r--r--   0        0        0      935 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/operators/la.py
+-rw-r--r--   0        0        0     4954 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/operators/low_rank_op.py
+-rw-r--r--   0        0        0    20805 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/operators/operators.py
+-rw-r--r--   0        0        0      214 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/parameters/__init__.py
+-rw-r--r--   0        0        0     3471 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/parameters/min_max_theta_functionals.py
+-rw-r--r--   0        0        0    14112 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/parameters/mu_derivatives.py
+-rw-r--r--   0        0        0     2612 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/parameters/parameter_functionals.py
+-rw-r--r--   0        0        0     5508 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/parameters/parameters.py
+-rw-r--r--   0        0        0      214 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/reductors/__init__.py
+-rw-r--r--   0        0        0     1165 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/reductors/h2.py
+-rw-r--r--   0        0        0     2862 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/reductors/loewner.py
+-rw-r--r--   0        0        0     1212 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/reductors/mt.py
+-rw-r--r--   0        0        0     1750 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/reductors/spectral_factor.py
+-rw-r--r--   0        0        0        0 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/reductors/ph/__init__.py
+-rw-r--r--   0        0        0     2383 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/reductors/ph/ph_irka.py
+-rw-r--r--   0        0        0       10 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/testdata/check_results/.artifactignore
+-rw-r--r--   0        0        0      264 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/testdata/check_results/test_burgers_ei_results/888007625b352b77c250f281c02bedc152df479a
+-rw-r--r--   0        0        0     3722 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/testdata/check_results/test_parabolic_mor_results/ca3b1109e5bd10d21b0b9bc432d6ac101cf1fa4d
+-rw-r--r--   0        0        0     1558 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/testdata/check_results/test_thermalblock_results/105686ef68a9b4b3655c790d395526c623efd162
+-rw-r--r--   0        0        0     1528 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/testdata/check_results/test_thermalblock_results/29e5f263a02a275f4d29b7e5bdf32ad20c1e6346
+-rw-r--r--   0        0        0     1552 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/testdata/check_results/test_thermalblock_results/2f2da29c16865fb149a8025deb79bf849d6631db
+-rw-r--r--   0        0        0     1552 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/testdata/check_results/test_thermalblock_results/38a8bfe939551df7383a6058a2862fb9d2eea5a4
+-rw-r--r--   0        0        0     1540 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/testdata/check_results/test_thermalblock_results/60f38cd8ac4c21f2c30fafbec18e36e74a42a0be
+-rw-r--r--   0        0        0     4668 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/testdata/check_results/test_thermalblock_results/a92ec4631a6f0edc2eae1cc3b0fa17af6c467cef
+-rw-r--r--   0        0        0     1529 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/testdata/check_results/test_thermalblock_results/c8a460e412d9170f12508ab3608fd7e1e1750603
+-rw-r--r--   0        0        0     1539 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/testdata/check_results/test_thermalblock_results/ce0770de067386276c9e89afa2d63daeb512a9f5
+-rw-r--r--   0        0        0     1543 2020-02-02 00:00:00.000000 pymor-2023.1.0/src/pymortests/testdata/check_results/test_thermalblock_results/ea8f66e263715fd0185d0dd23ab6d57feb6ee898
+-rw-r--r--   0        0        0     1241 2020-02-02 00:00:00.000000 pymor-2023.1.0/.gitignore
+-rw-r--r--   0        0        0     6714 2020-02-02 00:00:00.000000 pymor-2023.1.0/AUTHORS.md
+-rw-r--r--   0        0        0     1547 2020-02-02 00:00:00.000000 pymor-2023.1.0/LICENSE.txt
+-rw-r--r--   0        0        0     7241 2020-02-02 00:00:00.000000 pymor-2023.1.0/README.md
+-rw-r--r--   0        0        0     7017 2020-02-02 00:00:00.000000 pymor-2023.1.0/pyproject.toml
+-rw-r--r--   0        0        0    12599 2020-02-02 00:00:00.000000 pymor-2023.1.0/PKG-INFO
```

### Comparing `pymor-2022.2.1/AUTHORS.md` & `pymor-2023.1.0/AUTHORS.md`

 * *Files 11% similar despite different names*

```diff
@@ -7,14 +7,35 @@
 * Hendrik Kleikamp, hendrik.kleikamp@uni-muenster.de (2022-)
 * Petar Mlinari, mlinaric@vt.edu (2016-)
 * Stephan Rave, stephan.rave@uni-muenster.de (2012-)
 * Felix Schindler, felix.schindler@uni-muenster.de (2012-)
 
 ## Contributors
 
+### pyMOR 2023.1
+
+* Tim Keil, tim.keil@uni-muenster.de
+  * adaptive trust region algorithm and specific BFGS implementation for PDE-constrained optimization
+
+* Steffen Mller, steffenmu@outlook.de
+  * positive-real balanced truncation
+  * passivity preserving model reduction via spectral factorization
+
+* Mohamed Adel Naguib Ahmed, mohamedadel1551998@gmail.com
+  * input-output selection in `bode_plot` function
+
+* Jonas Nicodemus, jonas.nicodemus@simtech.uni-stuttgart.de
+  * port-Hamiltonian IRKA
+  * positive-real balanced truncation
+
+* Peter Oehme, oehme.pb@gmail.com
+  * quadratic functionals and quadratic output keyword for CG discretization
+  * simple algebraic operations for parameter values
+  * adaptive trust region algorithm and specific BFGS implementation for PDE-constrained optimization
+
 ### pyMOR 2022.2
 
 * Tim Keil, tim.keil@uni-muenster.de
   * Dual-weighted residual (DWR) output estimation for elliptic problems
 
 * Art Pelling, a.pelling@tu-berlin.de
   * Eigensystem Realization Algorithm
@@ -81,15 +102,15 @@
     algorithms.eigs
   * subspace accelerated dominant pole algorithm in algorithms.samdp
 
 * Tim Keil, tim.keil@uni-muenster.de
   * second order derivatives for parameters
   * speed up of LincombOperators
   * add LincombParameterFunctional
-  * pruduct rule for ProductParameterFunctional
+  * product rule for ProductParameterFunctional
   * BaseMaxThetaParameterFunctional
 
 * Hendrik Kleikamp, hendrik.kleikamp@uni-muenster.de
   * Armijo line search algorithm
   * artificial neural networks for model order reduction
 
 * Luca Mechelli, luca.mechelli@uni-konstanz.de
@@ -124,15 +145,15 @@
   * NGSolve model in thermalblock_simple.py
 
 ### pyMOR 0.4
 
 * Andreas Buhr, andreas@andreasbuhr.de
   * ability to rescale colorbar in each frame
   * SelectionOperator
-  * support for advection and rection terms in finite element discretizations
+  * support for advection and reaction terms in finite element discretizations
   * improved Robin boundary condition support
 
 * Michael Laier, m_laie01@uni-muenster.de
   * PolygonalDomain, CircularSectorDomain, DiscDomain
   * pymor.domaindiscretizers.gmsh
   * ParabolicProblem, discretize_parabolic_cg, discretize_parabolic_fv
   * reductors.parabolic
@@ -144,15 +165,15 @@
   * pymor.discretizers.disk
 
 * Petar Mlinari, mlinaric@mpi-magdeburg.mpg.de
   * complex number support for NumpyVectorArray and NumpyMatrixOperator
   * BlockOperator and BlockDiagonalOperator
 
 * Michael Schaefer, michael.schaefer@uni-muenster.de
-  * Robin bondary condition support for pymor.operators.cg
+  * Robin boundary condition support for pymor.operators.cg
 
 ### pyMOR 0.3
 
 * Andreas Buhr, andreas@andreasbuhr.de
   * improved PIL compatibility for BitmapFunction
   * improvements to Gram-Schmidt algorithm
```

### Comparing `pymor-2022.2.1/CITATION.cff` & `pymor-2023.1.0/CITATION.cff`

 * *Files 12% similar despite different names*

```diff
@@ -13,14 +13,17 @@
     orcid: https://orcid.org/0000-0003-1582-7118
   - family-names: Mlinari
     given-names: Petar
     orcid: https://orcid.org/0000-0002-9437-7698
   - family-names: Balicki
     given-names: Linus
     orcid: https://orcid.org/0000-0002-8901-2889
+  - family-names: Kleikamp
+    given-names: Hendrik
+    orcid: https://orcid.org/0000-0003-1264-5941
 cff-version: "1.2.0"
 preferred-citation:
   title: pyMOR -- Generic Algorithms and Interfaces for Model Order Reduction
   doi: "10.1137/15M1026614"
   type: article
   authors:
   - family-names: Milk
```

### Comparing `pymor-2022.2.1/LICENSE.txt` & `pymor-2023.1.0/LICENSE.txt`

 * *Files identical despite different names*

### Comparing `pymor-2022.2.1/README.md` & `pymor-2023.1.0/README.md`

 * *Files 25% similar despite different names*

```diff
@@ -1,172 +1,163 @@
 ![pyMOR Logo](./logo/pymor_logo.svg)
 
-pyMOR - Model Order Reduction with Python
-=========================================
-
-pyMOR is a software library for building model order
-reduction applications with the Python programming language. Implemented
-algorithms include reduced basis methods for parametric linear and non-linear
-problems, as well as system-theoretic methods such as balanced truncation or
-IRKA (Iterative Rational Krylov Algorithm).  All algorithms in pyMOR are
-formulated in terms of abstract interfaces for seamless integration with
-external PDE (Partial Differential Equation) solver packages.  Moreover, pure
-Python implementations of FEM (Finite Element Method) and FVM (Finite Volume
-Method) discretizations using the NumPy/SciPy scientific computing stack are
-provided for getting started quickly.
-
 [![PyPI](https://img.shields.io/pypi/pyversions/pymor.svg)](https://pypi.python.org/pypi/pymor)
 [![PyPI](https://img.shields.io/pypi/v/pymor.svg)](https://pypi.python.org/pypi/pymor)
 [![Docs](https://img.shields.io/endpoint?url=https%3A%2F%2Fdocs.pymor.org%2Fbadge.json)](https://docs.pymor.org/)
 [![DOI](https://zenodo.org/badge/9220688.svg)](https://zenodo.org/badge/latestdoi/9220688)
 [![GitLab Pipeline](https://zivgitlab.uni-muenster.de/pymor/pymor/badges/main/pipeline.svg)](https://zivgitlab.uni-muenster.de/pymor/pymor/commits/main)
 [![Conda Tests](https://github.com/pymor/pymor/actions/workflows/conda_tests.yml/badge.svg)](https://github.com/pymor/pymor/actions/workflows/conda_tests.yml)
 [![codecov](https://codecov.io/gh/pymor/pymor/branch/main/graph/badge.svg)](https://codecov.io/gh/pymor/pymor)
+[![pre-commit.ci status](https://results.pre-commit.ci/badge/github/pymor/pymor/main.svg)](https://results.pre-commit.ci/latest/github/pymor/pymor/main)
 
-License
--------
-
-Copyright pyMOR developers and contributors. All rights reserved.
-
-Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
-following conditions are met:
+# pyMOR - Model Order Reduction with Python
 
-* Redistributions of source code must retain the above copyright notice, this list of conditions and the following
-  disclaimer.
-* Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
-  disclaimer in the documentation and/or other materials provided with the distribution.
+pyMOR is a software library for building
+[model order reduction](https://morwiki.mpi-magdeburg.mpg.de)
+applications with the Python programming language.
+All algorithms in pyMOR are formulated in terms of abstract interfaces,
+allowing generic implementations to work with different backends,
+from NumPy/SciPy to external partial differential equation solver packages.
+
+## Features
+
+* Reduced basis methods for parametric linear and non-linear problems.
+* System-theoretic methods for linear time-invariant systems.
+* Neural network-based methods for parametric problems.
+* Proper orthogonal decomposition.
+* Dynamic mode decomposition.
+* Rational interpolation of data (Loewner, AAA).
+* Numerical linear algebra (Gram-Schmidt, time-stepping, ...).
+* Pure Python implementations of finite element and finite volume
+  discretizations using the NumPy/SciPy scientific computing stack.
 
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
-INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
-WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+## License
 
-The following files contain source code originating from other open source software projects:
+pyMOR is licensed under BSD-2-clause.
+See [LICENSE.txt](LICENSE.txt).
 
-* docs/source/pymordocstring.py  (sphinxcontrib-napoleon)
-* src/pymor/algorithms/genericsolvers.py (SciPy)
-
-See these files for more information.
-
-Citing
-------
+## Citing
 
 If you use pyMOR for academic work, please consider citing our
-[publication](https://doi.org/10.1137/15M1026614):
+[publication](https://epubs.siam.org/doi/10.1137/15M1026614):
 
     R. Milk, S. Rave, F. Schindler
     pyMOR - Generic Algorithms and Interfaces for Model Order Reduction
     SIAM J. Sci. Comput., 38(5), pp. S194--S216, 2016
 
-Installation via pip
---------------------
+## Installation via pip
 
 We recommend installation of pyMOR in a [virtual environment](https://virtualenv.pypa.io/en/latest/).
 
 pyMOR can easily be installed with the [pip](https://pip.pypa.io/en/stable/)
-command:
+command.
+Please note that pip versions prior to 21.1 might have problems resolving all
+dependencies, so running the following first is recommended:
 
-    pip install --upgrade pip  # make sure that pip is reasonably new
-    pip install pymor[full]
+    pip install --upgrade pip
 
-(Please note that pip versions prior to 21.1 might have problems resolving all dependencies)
+If you are not operating in a virtual environment, you can pass the optional
+`--user` argument to pip.
+pyMOR will then only be installed for your local user, not requiring
+administrator privileges.
 
-This will install the latest release of pyMOR on your system with most optional
-dependencies.
-For Linux we provide binary wheels, so no further system packages should
-be required. Use
+### Latest Release (without Optional Dependencies)
+
+For an installation with minimal dependencies, run
 
     pip install pymor
 
-for an installation with minimal dependencies.
+Note that most included demo scripts additionally require Qt bindings such as
+`pyside2` to function.
+Therefore we recommend install pyMOR with the `gui` extra:
+
+    pip install pymor[gui]  # 2023.1 and later
+
+### Latest Release (with all Optional Dependencies)
+
+The following installs the latest release of pyMOR on your system with most
+optional dependencies:
+
+    pip install pymor[full]
+
 There are some optional packages not included with `pymor[full]`
 because they need additional setup on your system:
 
-* for support of MPI distributed models and parallelization of greedy algorithms
-  (requires MPI development headers and a C compiler):
+* [mpi4py](https://mpi4py.readthedocs.io/en/stable/mpi4py.html):
+  support of MPI distributed models and parallelization of greedy
+  algorithms (requires MPI development headers and a C compiler):
 
       pip install mpi4py
 
-* dense matrix equation solver for system-theoretic MOR methods, required for
-  H-infinity norm calculation (requires OpenBLAS headers and a Fortran
-  compiler):
+* [Slycot](https://github.com/python-control/Slycot):
+  dense matrix equation solvers for system-theoretic methods and
+  H-infinity norm calculation (requires OpenBLAS headers and a
+  Fortran compiler):
 
       pip install slycot
 
-* dense and sparse matrix equation solver for system-theoretic MOR methods
-  (other backends available):
-  * from [source](https://gitlab.mpi-magdeburg.mpg.de/mess/cmess-releases)
-    (recommended)
-  * using a [wheel](https://www.mpi-magdeburg.mpg.de/projects/mess)
-
-If you are not operating in a virtual environment, you can pass the optional `--user`
-argument to pip. pyMOR will then only be installed for your
-local user, not requiring administrator privileges.
+* [Py-M.E.S.S.](https://www.mpi-magdeburg.mpg.de/projects/mess):
+  dense and sparse matrix equation solvers for system-theoretic methods
+  (it is recommended to install from
+  [source](https://gitlab.mpi-magdeburg.mpg.de/mess/cmess-releases)):
+
+      pip install pymess
+
+### Latest Development Version
 
 To install the latest development version of pyMOR, execute
 
-    pip install git+https://github.com/pymor/pymor#egg=pymor[full]
+    pip install 'pymor[full] @ git+https://github.com/pymor/pymor'
 
-which will require that the [git](https://git-scm.com/) version control system is
+which requires that the [git](https://git-scm.com/) version control system is
 installed on your system.
 
+### Current Release Branch Version
+
 From time to time, the main branch of pyMOR undergoes major changes and things
-might break (this is usually announced in our [discussion forum](https://github.com/pymor/pymor/discussions)),
+might break (this is usually announced in our
+[discussion forum](https://github.com/pymor/pymor/discussions)),
 so you might prefer to install pyMOR from the current release branch:
 
-    pip install git+https://github.com/pymor/pymor@2022.2.x#egg=pymor[full]
+    pip install 'pymor[full] @ git+https://github.com/pymor/pymor@2023.1.x'
 
 Release branches will always stay stable and will only receive bugfix commits
 after the corresponding release has been made.
 
-Installation via conda
-----------------------
+## Installation via conda/mamba
+
+We recommend installation of pyMOR in a
+[conda environment](https://docs.conda.io/projects/conda/en/latest/user-guide/tasks/manage-environments.html)
+with mamba.
+
+pyMOR can be installed using conda/mamba by running
 
-pyMOR can be installed using `conda` by running
+    conda install -c conda-forge mamba
+    mamba install -c conda-forge pymor
 
-    conda install -c conda-forge pymor
+## Documentation
 
-Documentation
--------------
+Documentation is available [online](https://docs.pymor.org/).
+We recommend starting with
+[getting started](https://docs.pymor.org/latest/getting_started.html),
+[tutorials](https://docs.pymor.org/latest/tutorials.html), and
+[technical overview](https://docs.pymor.org/latest/technical_overview.html).
 
-Documentation is available [online](https://docs.pymor.org/)
-or you can build it yourself from inside the root directory of the pyMOR source tree
-by executing:
+To build the documentation locally,
+run the following from inside the root directory of the pyMOR source tree:
 
     make docs
 
 This will generate HTML documentation in `docs/_build/html`.
 
-Useful Links
-------------
+## External PDE Solvers
 
-* [Latest Changelog](https://docs.pymor.org/latest/release_notes/all.html)
-* [Getting Started](https://docs.pymor.org/latest/getting_started.html)
-* [Dependencies](https://github.com/pymor/pymor/blob/2022.2.x/requirements.txt)
-
-External PDE solvers
---------------------
-
-pyMOR has been designed with easy integration of external PDE solvers
-in mind.
-
-A basic approach is to use the solver only to generate high-dimensional
-system matrices which are then read by pyMOR from disk (`pymor.discretizers.disk`).
-Another possibility is to steer the solver via an appropriate network
-protocol.
-
-Whenever possible, we recommend to recompile the solver as a
-Python extension module which gives pyMOR direct access to the solver without
-any communication overhead. A basic example using
-[pybind11](https://github.com/pybind/pybind11) can be found in
-`src/pymordemos/minimal_cpp_demo`. Moreover,
-we provide bindings for the following solver libraries:
+pyMOR has been designed with easy integration of external PDE solvers in mind.
+
+We provide bindings for the following solver libraries:
 
 * [FEniCS](https://fenicsproject.org)
 
     MPI-compatible wrapper classes for dolfin linear algebra data structures are
     shipped with pyMOR (`pymor.bindings.fenics`).
     For an example see `pymordemos.thermalblock`, `pymordemos.thermalblock_simple`.
     It is tested using FEniCS version 2019.1.0.
@@ -179,38 +170,23 @@
 * [NGSolve](https://ngsolve.org)
 
     Wrapper classes for the NGSolve finite element library are shipped with pyMOR
     (`pymor.bindings.ngsolve`).
     For an example see `pymordemos.thermalblock_simple`.
     It is tested using NGSolve version v6.2.2104.
 
-Do not hesitate to contact
-[us](https://github.com/pymor/pymor/discussions) if you
-need help with the integration of your PDE solver.
-
-External Matrix Equation Solvers
---------------------------------
-
-pyMOR also provides bindings to matrix equation solvers (in `pymor.bindings`),
-which are needed for the system-theoretic methods and need to be installed
-separately. Bindings for the following solver libraries are included:
-
-* [Py-M.E.S.S.](https://www.mpi-magdeburg.mpg.de/projects/mess)
-
-    The Matrix Equation Sparse Solver library is intended for solving large sparse matrix equations (`pymor.bindings.pymess`).
-
-* [Slycot](https://github.com/python-control/Slycot)
+A simple example for direct integration of pyMOR with a a custom solver
+can be found in `pymordemos.minimal_cpp_demo`.
 
-    Python wrapper for the Subroutine Library in Systems and Control Theory (SLICOT) is also used for Hardy norm computations (`pymor.bindings.slycot`).
+An alternative approach is to import system matrices from file and use
+`scipy.sparse`-based solvers.
 
-Environments for pyMOR Development and Tests
------------------------------------------------
+## Environments for pyMOR Development and Tests
 
 Please see the [Developer Documentation](https://docs.pymor.org/latest/developer_docs.html).
 
-Contact
--------
+## Contact
 
 Should you have any questions regarding pyMOR or wish to contribute,
-do not hesitate to contact us via our GitHub discussions forum:
+do not hesitate to send us an email at
 
-<https://github.com/pymor/pymor/discussions>
+    main.developers@pymor.org
```

### Comparing `pymor-2022.2.1/docs/Makefile` & `pymor-2023.1.0/docs/Makefile`

 * *Files 1% similar despite different names*

```diff
@@ -40,19 +40,20 @@
 	@echo "  changes    to make an overview of all changed/added/deprecated items"
 	@echo "  linkcheck  to check all external links for integrity"
 	@echo "  doctest    to run all doctests embedded in the documentation (if enabled)"
 
 clean:
 	-rm -rf $(BUILDDIR)/*
 	-rm -f source/generated/*.rst
+	-rm -rf source/autoapi/
 
 html:
 	cp -a source/*png .
 	cp -a source/pymor_defaults.py .
-	PYMOR_NBCONVERT=1 $(SPHINXBUILD) -b html $(ALLSPHINXOPTS) $(BUILDDIR)/html
+	$(SPHINXBUILD) -b html $(ALLSPHINXOPTS) $(BUILDDIR)/html
 	@echo
 	@echo "Build finished. The HTML pages are in $(BUILDDIR)/html."
 
 dirhtml:
 	$(SPHINXBUILD) -b dirhtml $(ALLSPHINXOPTS) $(BUILDDIR)/dirhtml
 	@echo
 	@echo "Build finished. The HTML pages are in $(BUILDDIR)/dirhtml."
```

### Comparing `pymor-2022.2.1/docs/source/B.png` & `pymor-2023.1.0/docs/source/B.png`

 * *Files identical despite different names*

### Comparing `pymor-2022.2.1/docs/source/R.png` & `pymor-2023.1.0/docs/source/R.png`

 * *Files identical despite different names*

### Comparing `pymor-2022.2.1/docs/source/RB.png` & `pymor-2023.1.0/docs/source/RB.png`

 * *Files identical despite different names*

### Comparing `pymor-2022.2.1/docs/source/_static/pymor.css` & `pymor-2023.1.0/docs/source/_static/pymor.css`

 * *Files 8% similar despite different names*

```diff
@@ -145,7 +145,15 @@
 .py.method, .py.function {
     border-left: .1rem solid #448aff !important;
 }
 
 .align-left {
     float: left;
 }
+
+.k3d-target canvas {
+    z-index: 0 !important;
+}
+
+.colorMapLegend {
+    z-index: 0 !important;
+}
```

### Comparing `pymor-2022.2.1/docs/source/_templates/autoapi/python/class.rst` & `pymor-2023.1.0/docs/source/_templates/autoapi/python/class.rst`

 * *Files identical despite different names*

### Comparing `pymor-2022.2.1/docs/source/_templates/autoapi/python/module.rst` & `pymor-2023.1.0/docs/source/_templates/autoapi/python/module.rst`

 * *Files identical despite different names*

### Comparing `pymor-2022.2.1/docs/source/_templates/layout.html` & `pymor-2023.1.0/docs/source/_templates/layout.html`

 * *Files identical despite different names*

### Comparing `pymor-2022.2.1/docs/source/autoapi_pymor.py` & `pymor-2023.1.0/docs/source/autoapi_pymor.py`

 * *Files 2% similar despite different names*

```diff
@@ -57,16 +57,18 @@
                 'pymor.vectorarrays.interface.VectorSpace.is_scalar',
                 )
 
 SKIPS_RE = re.compile(r'(?:{})'.format('|'.join(map(re.escape, sorted(MANUAL_SKIPS, key=len, reverse=True)))))
 
 
 def skip(app, what, name, obj, skip, options):
+    if name == 'pymor.operators.interface.Operator._assemble_lincomb':
+        return False
     try:
-        if ":noindex:" in obj.docstring:
+        if ':noindex:' in obj.docstring:
             print(f'HERE DO_SKIP {name}')
             return True
     except AttributeError:
         pass
     return SKIPS_RE.search(name)
```

### Comparing `pymor-2022.2.1/docs/source/bibliography.bib` & `pymor-2023.1.0/docs/source/bibliography.bib`

 * *Files 9% similar despite different names*

```diff
@@ -20,23 +20,25 @@
   year =         2010,
   editor =       {Mohammadpour, Javad and Grigoriadis, Karolos M.},
   pages =        {3--58},
   isbn =         {978-1-4419-5756-6},
   doi =          {10.1007/978-1-4419-5757-3_1}
 }
 
-@TechReport{BBG19,
+@InCollection{BBG19,
     title={{$\mathcal{H}_2$}-gap model reduction for stabilizable and detectable systems},
     author={Tobias Breiten and Chris A. Beattie and Serkan Gugercin},
-    institution={arXiv},
-    year={2019},
-    type={e-prints},
-    number={1909.13764},
-    note={math.NA},
-    url={http://arxiv.org/abs/1909.13764}
+    bookTitle={Realization and Model Reduction of Dynamical Systems: A Festschrift in Honor of the 70th Birthday of Thanos Antoulas},
+    editor={Beattie, Christopher and Benner, Peter and Embree, Mark and Gugercin, Serkan and Lefteriu, Sanda},
+    publisher={Springer International Publishing},
+    year={2022},
+    address={Cham},
+    pages={317--334},
+    isbn={978-3-030-95157-3},
+    doi={10.1007/978-3-030-95157-3_17}
 }
 
 @article{BBKS18,
   title={RADI: a low-rank ADI-type algorithm for large scale algebraic Riccati equations},
   author={Benner, Peter and Bujanovi{\'c}, Zvonimir and K{\"u}rschner, Patrick and Saak, Jens},
   journal={Numerische mathematik},
   volume={138},
@@ -146,14 +148,25 @@
   volume={40},
   number={4},
   pages={A2120--A2151},
   year={2018},
   publisher={SIAM}
 }
 
+@article{BU22,
+    title = {Passivity preserving model reduction via spectral factorization},
+    journal = {Automatica},
+    volume = {142},
+    pages = {110368},
+    year = {2022},
+    issn = {0005-1098},
+    doi = {10.1016/j.automatica.2022.110368},
+    author = {Tobias Breiten and Benjamin Unger},
+}
+
 @article{CCA96,
   author={Clapperton, B. and Crusca, F. and Aldeen, M.},
   journal={IEEE Transactions on Automatic Control},
   title={Bilinear transformation and generalized singular perturbation model reduction},
   year={1996},
   volume={41},
   number={4},
@@ -233,14 +246,25 @@
   publisher =    {SIAM},
   year =         2017,
   editor =       {Benner, P. and Cohen, A. and Ohlberger, M. and Willcox, K.},
   pages =        {65--136},
   doi =          {10.1137/1.9781611974829.ch2}
 }
 
+@InCollection{ALI17,,
+  author = {Athanasios C. Antoulas and Sanda Lefteriu and A. Cosmin Ionita},
+  title = {A Tutorial Introduction to the Loewner Framework for Model Reduction},
+  booktitle =    {Model Reduction and Approximation: Theory and Algorithms},
+  publisher =    {SIAM},
+  year =         2017,
+  editor =       {Benner, P. and Cohen, A. and Ohlberger, M. and Willcox, K.},
+  pages = {335--376},
+  doi = {10.1137/1.9781611974829.ch8},
+}
+
 @Article{HDO11,
   author =       {Haasdonk, B. and Dihlmann, M. and Ohlberger, M.},
   title =        {A Training Set and Multiple Basis Generation Approach for
                   Parametrized Model Reduction Based on Adaptive Grids in
                   Parameter Space},
   journal =      {Math. Comput. Model. Dyn. Syst.},
   year =         2011,
@@ -339,14 +363,25 @@
   title = {A New Identification and Model Reduction Algorithm via Singular Value Decomposition},
   booktitle = {Proceedings of the 12th {{Asilomar Conference}} on {{Circuits}}, {{Systems}} and {{Computers}}},
   author = {Kung, S.},
   year = {1978},
   pages = {705--714}
 }
 
+@Article{KMOSV21,
+	author =       {Keil, Tim and Mechelli, Luca and Ohlberger, Mario and Schindler, Felix and Volkwein, Stefan},
+	title =        {A non-conforming dual approach for adaptive Trust-Region reduced basis approximation of PDE-constrained parameter optimization},
+	DOI=           {10.1051/m2an/2021019},
+	journal =      {ESAIM: M2AN},
+	year =         2021,
+	volume =       55,
+	number =       3,
+	pages =        {1239--1269}
+}
+
 @Article{LiW02,
   author =       {J.-R. Li and J. White},
   title =        {Low Rank Solution of {L}yapunov Equations},
   journal =      {SIAM J. Matrix Anal. Appl.},
   year =         2002,
   volume =       24,
   number =       1,
@@ -496,14 +531,25 @@
   title = {On Dynamic Mode Decomposition: Theory and Applications},
   journal = {Journal of Computational Dynamics},
   issue = {1(2)},
   pages = {391--421},
   year = {2014}
 }
 
+@article{DP84,
+  author={Desai, U. and Pal, D.},
+  journal={IEEE Transactions on Automatic Control},
+  title={A transformation approach to stochastic model reduction},
+  year={1984},
+  volume={29},
+  number={12},
+  pages={1097-1100},
+  doi={10.1109/TAC.1984.1103438}
+}
+
 @PhdThesis{W12,
   author =       {Wyatt, S.},
   title =        {Issues in Interpolatory Model Reduction: Inexact Solves,
                   Second-order Systems and {DAE}s},
   school =       {Virginia Polytechnic Institute and State University},
   year =         2012,
   address =      {Blacksburg, Virginia, USA},
@@ -529,14 +575,25 @@
   year =         2011,
   volume =       8,
   number =       1,
   pages =        {174--188},
   url =          {http://www.math.ualberta.ca/ijnam/Volume-8-2011/No-1-11/2011-01-10.pdf}
 }
 
+@Article{YM13,
+  author =       {Yue, Y. and Meerbergen, K.},
+  title =        {Accelerating Optimization of Parametric Linear Systems by Model Order Reduction},
+  journal =      {SIAM Journal on Optimization},
+  year =         2013,
+  volume =       23,
+  number =       2,
+  pages =        {1344--1370},
+  doi =          {10.1137/120869171}
+}
+
 @Article{ZSW99,
   author =       {K. Zhou and G. Salomon and E. Wu},
   title =        {Balanced realization and model reduction for unstable systems},
   journal =      {Internat. J. Robust Nonlinear Control},
   year =         1999,
   volume =       9,
   number =       3,
```

### Comparing `pymor-2022.2.1/docs/source/conf.py` & `pymor-2023.1.0/docs/source/conf.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,22 +1,23 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
-import sys
-import os
-import slugify
 import glob
-import sphinx
+import os
+import sys
 import sysconfig
 from pathlib import Path
 
+import slugify
+import sphinx
+
 # Check Sphinx version
-if sphinx.__version__ < "3.4":
-    raise RuntimeError("Sphinx 3.4 or newer required")
+if sphinx.__version__ < '3.4':
+    raise RuntimeError('Sphinx 3.4 or newer required')
 
 needs_sphinx = '3.4'
 os.environ['PYMOR_WITH_SPHINX'] = '1'
 os.environ['PYBIND11_DIR'] = sysconfig.get_path('purelib')
 
 # -----------------------------------------------------------------------------
 # General configuration
@@ -34,39 +35,38 @@
               'sphinx.ext.autosummary',
               'sphinx.ext.linkcode',
               'sphinx.ext.intersphinx',
               'pymordocstring',
               'try_on_binder',
               'myst_nb',
               'sphinx.ext.mathjax',
-              'sphinx_qt_documentation',
               'autoapi.extension',
               'autoapi_pymor',
               'sphinxcontrib.bibtex',
               'IPython.sphinxext.ipython_console_highlighting',
               ]
 # this enables:
 # substitutions-with-jinja2, direct-latex-math and definition-lists
 # ref: https://myst-parser.readthedocs.io/en/latest/using/syntax-optional.html
 myst_enable_extensions = [
-    "dollarmath",
-    "amsmath",
-    "deflist",
-    "html_image",
-    "colon_fence",
-    "smartquotes",
-    "replacements",
-    "substitution",
+    'dollarmath',
+    'amsmath',
+    'deflist',
+    'html_image',
+    'colon_fence',
+    'smartquotes',
+    'replacements',
+    'substitution',
 ]
-myst_url_schemes = ("http", "https", "mailto")
-# auto genereated link anchors
+myst_url_schemes = ('http', 'https', 'mailto')
+# auto generated link anchors
 myst_heading_anchors = 2
 import substitutions # noqa
 myst_substitutions = substitutions.myst_substitutions
-nb_execute_notebooks = "cache"
+nb_execute_notebooks = 'cache'
 nb_execution_timeout = 180
 # print tracebacks to stdout
 nb_execution_show_tb = True
 
 bibtex_bibfiles = ['bibliography.bib']
 # Add any paths that contain templates here, relative to this directory.
 templates_path = ['_templates']
@@ -104,15 +104,15 @@
 # Else, today_fmt is used as the format for a strftime call.
 today_fmt = '%B %d, %Y'
 
 # List of documents that shouldn't be included in the build.
 # unused_docs = []
 
 # The reST default role (used for this markup: `text`) to use for all documents.
-default_role = "literal"
+default_role = 'literal'
 
 # List of directories, relative to source directories, that shouldn't be searched
 # for source files.
 exclude_dirs = []
 
 # If true, '()' will be appended to :func: etc. cross-reference text.
 add_function_parentheses = False
@@ -124,14 +124,28 @@
 # If true, sectionauthor and moduleauthor directives will be shown in the
 # output. They are ignored by default.
 # show_authors = False
 
 # The name of the Pygments (syntax highlighting) style to use.
 pygments_style = 'sphinx'
 
+# Ensure all our internal links work
+nitpicky = True
+nitpick_ignore = [
+    ('py:obj', 'ipywidgets.HBox'),
+    ('py:obj', 'k3d.plot.Plot'),
+    ('py:obj', 'qtpy.QtWidgets.QOpenGLWidget'),
+    ('py:obj', 'qtpy.QtWidgets.QWidget'),
+]
+nitpick_ignore_regex = [
+    ('py:class', 'Choices(.+)'),  # pymor.tools.typer.Choices(...) cannot be referred to
+    ('py:.*', 'pymess.*'),  # pymess does not have online Sphinx documentation
+    ('py:.*', 'matplotlib.backends.*'),  # matplotlib backends are not auto documented
+]
+
 
 # -----------------------------------------------------------------------------
 # HTML output
 # -----------------------------------------------------------------------------
 
 # The style sheet to use for HTML and HTML Help pages. A file of that name
 # must exist either in Sphinx' static/ path, or in one of the custom paths
@@ -141,24 +155,24 @@
 
 html_theme = 'sphinx_material'
 html_theme_options = {
     'base_url': 'https://gh-docs.pymor.org/',
     'html_minify': False,
     'css_minify': on_gitlab_ci,
     'nav_title': 'Documentation',
-    'globaltoc_depth': 5,
+    'globaltoc_depth': 6,
     'theme_color': 'indigo',
     'color_primary': 'indigo',
     'color_accent': 'blue',
     'version_dropdown': True,
     'version_json': '/versions.json'
 }
 # The name for this set of Sphinx documents.  If None, it defaults to
 # "<project> v<release> documentation".
-html_title = "%s v%s Manual" % (project, version)
+html_title = '%s v%s Manual' % (project, version)
 
 # The name of an image file (within the static path) to place at the top of
 # the sidebar.
 html_logo = '../../logo/pymor_logo_white.svg'
 
 # The name of an image file to use as favicon.
 html_favicon = '../../logo/pymor_favicon.png'
@@ -175,22 +189,24 @@
 # If true, SmartyPants will be used to convert quotes and dashes to
 # typographically correct entities.
 # html_use_smartypants = True
 
 # Custom sidebar templates, maps document names to template names.
 # all: "**": ["logo-text.html", "globaltoc.html", "localtoc.html", "searchbox.html"]
 html_sidebars = {
-    "**": ["logo-text.html", "globaltoc.html", "searchbox.html"]
+    '**': ['logo-text.html', 'globaltoc.html', 'searchbox.html']
 }
 # Additional templates that should be rendered to pages, maps page names to
 # template names.
 # html_additional_pages = {
 #    'index': 'indexcontent.html',
 # }
 
+html_css_files = ['https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css']
+
 # If false, no module index is generated.
 html_use_modindex = True
 
 # If true, the reST sources are included in the HTML build as _sources/<name>.
 # html_copy_source = True
 
 # If true, an OpenSearch description file will be output, and all pages will
@@ -248,15 +264,15 @@
 latex_use_modindex = False
 
 
 # -----------------------------------------------------------------------------
 # Autosummary
 # -----------------------------------------------------------------------------
 
-autosummary_generate = glob.glob("generated/*.rst")
+autosummary_generate = glob.glob('generated/*.rst')
 
 # -----------------------------------------------------------------------------
 # Coverage checker
 # -----------------------------------------------------------------------------
 coverage_ignore_modules = r"""
     """.split()
 coverage_ignore_functions = r"""
@@ -269,20 +285,25 @@
 coverage_c_path = []
 coverage_c_regexes = {}
 coverage_ignore_c_items = {}
 
 # autodoc_default_flags = ['members', 'undoc-members', 'show-inheritance']
 
 # PyQt5 inventory is only used internally, actual link targets PySide2
-intersphinx_mapping = {'python': ('https://docs.python.org/3/', None),
-                       'numpy': ('https://numpy.org/doc/stable/', None),
-                       'PyQt5': ("https://www.riverbankcomputing.com/static/Docs/PyQt5", None),
-                       'scipy': ('https://docs.scipy.org/doc/scipy/', None),
-                       'matplotlib': ('https://matplotlib.org/stable/', None),
-                       'Sphinx': (' https://www.sphinx-doc.org/en/stable/', None)}
+intersphinx_mapping = {
+    'python': ('https://docs.python.org/3/', None),
+    'numpy': ('https://numpy.org/doc/stable/', None),
+    'PyQt5': ('https://www.riverbankcomputing.com/static/Docs/PyQt5', None),
+    'scipy': ('https://docs.scipy.org/doc/scipy/', None),
+    'matplotlib': ('https://matplotlib.org/stable/', None),
+    'Sphinx': (' https://www.sphinx-doc.org/en/stable/', None),
+    'torch': ('https://pytorch.org/docs/stable/', None),
+    'ipywidgets': ('https://ipywidgets.readthedocs.io/en/stable/', None),
+    'k3d': ('https://k3d-jupyter.org/', None),
+}
 
 modindex_common_prefix = ['pymor.']
 
 
 # make intersphinx link to pyside2 docs
 qt_documentation = 'PySide2'
 
@@ -297,16 +318,16 @@
         if not info['module']:
             return None
         filename = info['module'].replace('.', '/')
         return f'https://github.com/pymor/pymor/tree/{branch}/src/{filename}.py'
     return None
 
 
-autoapi_dirs = [src_dir / 'pymor']
+autoapi_dirs = [src_dir / 'pymor', src_dir / 'pymordemos']
 autoapi_type = 'python'
 # allows incremental build
 autoapi_keep_files = True
 autoapi_ignore = ['*/pymordemos/minimal_cpp_demo/*']
-suppress_warnings = ["autoapi"]
+suppress_warnings = ['autoapi']
 autoapi_template_dir = this_dir / '_templates' / 'autoapi'
-autoapi_member_order = "groupwise"
-autoapi_options = ["show-inheritance", "members", "undoc-members"]
+autoapi_member_order = 'groupwise'
+autoapi_options = ['show-inheritance', 'members', 'undoc-members']
```

### Comparing `pymor-2022.2.1/docs/source/getting_started.md` & `pymor-2023.1.0/docs/source/tutorial_builtin_discretizer.md`

 * *Files 26% similar despite different names*

```diff
@@ -17,299 +17,489 @@
   name: python3
 ---
 
 ```{try_on_binder}
 ```
 
 ```{code-cell}
-:tags: [remove-cell]
 :load: myst_code_init.py
-```
+:tags: [remove-cell]
 
-(getting-started)=
 
-# Getting started
+```
 
-## Trying it out
+# Tutorial: Using pyMORs discretization toolkit
 
-While we consider pyMOR mainly as a library for building MOR applications, we
-ship a few example scripts. These can be found in the `src/pymordemos`
-directory of the source repository (some are available as Jupyter notebooks in
-the `notebooks` directory). Try launching one of them using the `pymor-demo`
-script:
+pyMORs discretization toolkit allows to quickly build parameterized
+full-order models based on the NumPy/SciPy software stack. Currently
+supported are stationary or instationary scalar PDEs of up to second
+order with possibly nonlinear advection or reaction terms in one or two
+spatial dimensions. Unstructured meshes can be imported in the Gmsh file
+format.
 
+In this tutorial we will focus on elliptic equations of the form
+
+```{math}
+-\nabla \cdot \big(\sigma(x, \mu) \nabla u(x, \mu) \big) = f(x, \mu),\quad x \in \Omega,
 ```
-pymor-demo thermalblock --plot-err --plot-solutions 3 2 3 32
+
+on the domain {math}`\Omega:= (0, 1)^2 \subset \mathbb{R}^2` with data
+functions {math}`f(\cdot, \mu) \in L^2(\Omega)`,
+{math}`\sigma(\cdot, \mu) \in L^\infty(\Omega)`.
+
+## A first equation without parameters
+
+First, let us assume that the source {math}`f(x, \mu)` is an indicator
+function of a circular disk with radius {math}`0.3` and that
+{math}`\sigma(x, \mu)` is constant:
+
+```{math}
+f(x, \mu) :=
+\begin{cases}
+   1, & |x - (0.5, 0.5)| < 0.3, \\
+   0, & \text{otherwise},
+\end{cases} \quad\text{and}\quad
+\sigma(x, \mu) :\equiv 1.
 ```
 
-The demo scripts can also be launched directly from the source tree:
+We start by importing commonly used pyMOR classes and methods from the
+{mod}`~pymor.basic` module:
 
+```{code-cell}
+from pymor.basic import *
 ```
-./thermalblock.py --plot-err --plot-solutions 3 2 3 32
+
+To specify the problem at hand using pyMORs discretization toolkit, we
+first need to specify the computational domain {math}`\Omega`. Multiple
+classes are available to define such domains in the
+{mod}`~pymor.analyticalproblems.domaindescriptions` module,
+which all derive from the {{ DomainDescription }} interface class.
+
+In our case, we can use a {{ RectDomain }}:
+
+```{code-cell}
+domain = RectDomain([[0.,0.], [1.,1.]])
 ```
 
-This will reduce the so called thermal block problem using the reduced basis
-method with a greedy basis generation algorithm. The thermal block problem
-consists in solving the stationary heat equation
+Data functions are defined using classes which derive from
+the {{ Function }} interface. We specify the constant diffusivity {math}`\sigma`
+using a {{ ConstantFunction }}:
 
+```{code-cell}
+diffusion = ConstantFunction(1, 2)
 ```
--   [ d(x, )  u(x, ) ] = 1     for x in 
-                  u(x, )   = 0     for x in 
+
+Here, the first argument is the functions constant value. The second
+argument is the spatial dimension of the domain the problem is defined
+on.
+
+For the definition of the source term {math}`f` we use an
+{{ ExpressionFunction }} which is given an arbitrary Python expression
+used to evaluate the function. In this expression, the coordinates at
+which the function shall be evaluated are given as the variable `x`.
+Many NumPy functions can be used directly.
+Thus, to define {math}`f` we can write
+
+```{code-cell}
+rhs = ExpressionFunction('(sqrt( (x[0]-0.5)**2 + (x[1]-0.5)**2) <= 0.3) * 1.', 2)
 ```
 
-on the domain  = [0,1]^2 for the unknown u. The domain is partitioned into
-`XBLOCKS x YBLOCKS` blocks (`XBLOCKS` and `YBLOCKS` are the first
-two arguments to `thermalblock.py`). The thermal conductivity d(x, )
-is constant on each block (i,j) with value _ij:
+Similarly to {{ ConstantFunction }}, the second argument is the dimension
+of the computational domain.
 
+Finally, the computational domain and all data functions are collected
+in a {{ StationaryProblem }}:
+
+```{code-cell}
+problem = StationaryProblem(
+   domain=domain,
+   diffusion=diffusion,
+   rhs=rhs,
+)
 ```
-(0,1)------------------(1,1)
-|        |        |        |
-|  _11  |  _12  |  _13  |
-|        |        |        |
-|---------------------------
-|        |        |        |
-|  _21  |  _22  |  _23  |
-|        |        |        |
-(0,0)------------------(1,0)
+
+This problem definition can now be handed over to discretization methods
+(see {mod}`pymor.discretizers.builtin`) which assemble corresponding
+discrete full-order models. For finite elements, we use
+{func}`~pymor.discretizers.builtin.cg.discretize_stationary_cg`,
+which receives the maximum mesh element diameter via the `diameter`
+argument:
+
+```{code-cell}
+m, data = discretize_stationary_cg(problem, diameter=1/4)
 ```
 
-The real numbers _ij form the `XBLOCKS x YBLOCKS` - dimensional parameter
-on which the solution depends.
+The resulting {{ Model }} can be {meth}`solved <pymor.models.interface.Model.solve>`,
+returning a {{ VectorArray }} with the solution data:
 
-Running `thermalblock.py` will first produce plots of two detailed
-solutions of the problem for different randomly chosen parameters
-using linear finite elements. (The size of the grid can be controlled
-via the `--grid` parameter. The randomly chosen parameters will
-actually be the same for each run, since a the random generator
-is initialized with a fixed default seed in
-{func}`~pymor.tools.random.default_random_state`.)
+```{code-cell}
+U = m.solve()
+```
 
-After closing the window, the reduced basis for model order reduction
-is generated using a greedy search algorithm with error estimator.
-The third parameter `SNAPSHOTS` of `thermalblock.py` determines how many
-different values per parameter component _ij should be considered.
-I.e. the parameter training set for basis generation will have the
-size `SNAPSHOTS^(XBLOCKS x YBLOCKS)`. After the basis of size 32 (the
-last parameter) has been computed, the quality of the obtained reduced model
-(on the 32-dimensional reduced basis space) is evaluated by comparing the
-solutions of the reduced and detailed models for new, randomly chosen
-parameter values. Finally, plots of the detailed and reduced solutions, as well
-as the difference between the two, are displayed for the random
-parameter values which maximises reduction error.
+Finally, we visualize the solution:
 
-## The thermalblock demo explained
+```{code-cell}
+m.visualize(U)
+```
 
-In the following we will walk through the thermal block demo step by
-step in an interactive Python shell. We assume that you are familiar
-with the reduced basis method and that you know the basics of
-[Python](<https://www.python.org>) programming as well as working
-with {{ NumPy }}. (Note that our code will differ a bit from
-`thermalblock.py` as we will hardcode the various options the script
-offers and leave out some features.)
+In case a specific grid type shall be used ({{ RectGrid }} or
+{{ TriaGrid }}), the corresponding class has to be passed to the
+discretizer as the `grid_type` argument. By using {{ RectGrid }} we get
+bilinear finite elements:
+
+```{code-cell}
+m, data = discretize_stationary_cg(problem, diameter=1/4, grid_type=RectGrid)
+m.visualize(m.solve())
+```
 
-First, start a Python shell. We recommend using
-[IPython](<https://ipython.org>)
+We get a finite volume model using
+{func}`~pymor.discretizers.builtin.fv.discretize_stationary_fv`:
 
+```{code-cell}
+m, data = discretize_stationary_fv(problem, diameter=1/4, grid_type=TriaGrid)
+m.visualize(m.solve())
 ```
-ipython
+
+## Defining boundary conditions
+
+As the vigilant reader will already have noticed, we did not specify any
+boundary conditions when defining and solving our problem. When no
+boundary conditions are specified, pyMORs discretization toolkit will
+assume that homogeneous Dirichlet conditions are implied over the entire
+boundary of {math}`\Omega`.
+
+As the next example, let us now assume that the data functions are given
+by
+
+```{math}
+f(x, \mu) :\equiv 0 \quad\text{and}\quad
+\sigma(x, \mu) :=
+\begin{cases}
+   0.001, & |x - (0.5, 0.5)| < 0.3, \\
+   1, & \text{otherwise},
+\end{cases}
 ```
 
-You can paste the following input lines starting with `>>>` by copying
-them to the system clipboard and then executing
+and that we have the following mixed boundary conditions
 
+```{math}
+\begin{align}
+ -\sigma(x, \mu) \nabla u(x, \mu) \cdot n &= g_N(x), && x \in (0,1) \times \{0\} =: \Omega_N \\
+ u(x, \mu) &= 0, && x \in \partial\Omega \setminus \Omega_N,
+\end{align}
 ```
-%paste
+
+with {math}`g_N(x) \equiv -1`.
+
+Before solving this problem, let us first silence pyMORs verbose log
+messages for the rest of this tutorial using the {func}`~pymor.core.logger.set_log_levels`
+method:
+
+```{code-cell}
+set_log_levels({'pymor': 'WARN'})
 ```
 
-inside the IPython shell.
+To impose the correct boundary conditions we need to declare which type of
+boundary condition should be active on which part of
+{math}`\partial\Omega` when defining the computational domain:
+
+```{code-cell}
+domain = RectDomain(bottom='neumann')
+```
 
-First, we will import the most commonly used methods and classes of pyMOR
-by executing:
+Then all we need is to pass the Neumann data function {math}`g_N` to the
+{{ StationaryProblem }}. Here, we can use again a {{ ConstantFunction }}.
+The diffusivity can be defined similarly as above:
 
 ```{code-cell}
+neumann_data = ConstantFunction(-1., 2)
 
-from pymor.basic import *
-from pymor.core.logger import set_log_levels
-set_log_levels({'pymor.algorithms.greedy': 'ERROR', 'pymor.algorithms.gram_schmidt.gram_schmidt': 'ERROR', 'pymor.algorithms.image.estimate_image_hierarchical': 'ERROR'})
+diffusion = ExpressionFunction('1. - (sqrt( (x[0]-0.5)**2 + (x[1]-0.5)**2) <= 0.3) * 0.999' , 2)
+
+problem = StationaryProblem(
+   domain=domain,
+   diffusion=diffusion,
+   neumann_data=neumann_data
+)
 ```
 
-Next we will instantiate a class describing the analytical problem
-we want so solve. In this case, a
-{meth}`~pymor.analyticalproblems.thermalblock.thermal_block_problem`:
+Finally, we discretize and solve:
 
 ```{code-cell}
-p = thermal_block_problem(num_blocks=(3, 2))
+m, data = discretize_stationary_cg(problem, diameter=1/32)
+m.visualize(m.solve())
 ```
 
-We want to discretize this problem using the finite element method.
-We could do this by hand, creating a {{ Grid }}, instatiating
-{class}`~pymor.discretizers.builtin.cg.DiffusionOperatorP1` finite element diffusion
-operators for each subblock of the domain, forming a {{ LincombOperator }}
-to represent the affine decomposition, instantiating a
-{class}`~pymor.discretizers.builtin.cg.L2ProductFunctionalP1` as right hand side, and
-putting it all together into a {{ StationaryModel }}. However, since
-{meth}`~pymor.analyticalproblems.thermalblock.thermal_block_problem` returns
-a {class}`~pymor.analyticalproblems.elliptic.StationaryProblem`, we can use
-a predifined *discretizer* to do the work for us. In this case, we use
-{func}`~pymor.discretizers.builtin.cg.discretize_stationary_cg`:
+## Another example
+
+Even with a single {{ ExpressionFunction }} we can build many different examples.
+For instance, to let {math}`\sigma` be given by a periodic pattern of
+{math}`K\times K` circular disks of radius {math}`0.3/K` we can use the
+following definition:
 
 ```{code-cell}
-fom, fom_data = discretize_stationary_cg(p, diameter=1./50.)
+diffusion = ExpressionFunction(
+   '1. - (sqrt( ((x[0] % (1./K))-0.5/K)**2 + ((x[1] % (1./K))-0.5/K)**2) <= 0.3/K) * 0.999',
+   2, values={'K': 10}
+)
 ```
 
-`fom` is the {{ StationaryModel }} which has been created for us,
-whereas `fom_data` contains some additional data, in particular the {{ Grid }}
-and the {{ BoundaryInfo }} which have been created during discretization. We
-can have a look at the grid,
+Here, we have used the `values` parameter of {{ ExpressionFunction }} to
+make `K` available as an additional constant in the defining
+expression. In particular, we can easily change `K` programatically
+without having to resort to string manipulations. The solution looks
+like this:
 
 ```{code-cell}
-print(fom_data['grid'])
+problem = StationaryProblem(
+   domain=domain,
+   diffusion=diffusion,
+   neumann_data=neumann_data
+)
+
+
+m, data = discretize_stationary_cg(problem, diameter=1/100)
+m.visualize(m.solve())
 ```
 
-and, as always, we can display its class documentation using
-`help(fom_data['grid'])`.
+## Data functions defined from pixel graphics
 
-Let's solve the thermal block problem and visualize the solution:
+{{ BitmapFunction }} uses the Python Imaging Library (PIL) to read gray
+scale images in various image file formats. The resulting
+two-dimensional NumPy array of pixel values defines a piecewise constant
+data function on a rectangular domain, where the range of the function
+(from black to white) is specified via the `range` parameter. For
+instance, when using a {{ BitmapFunction }} for {math}`\sigma` with the
+following graphic stored in `RB.png`:
+
+```{image} RB.png
+
+```
+
+and a range of `[0.001 1]` we obtain:
 
 ```{code-cell}
-U = fom.solve([1.0, 0.1, 0.3, 0.1, 0.2, 1.0])
-fom.visualize(U, title='Solution')
+diffusion = BitmapFunction('RB.png', range=[0.001, 1])
+problem = StationaryProblem(
+   domain=domain,
+   diffusion=diffusion,
+   neumann_data=neumann_data
+)
+
+m, data = discretize_stationary_cg(problem, diameter=1/100)
+m.visualize(m.solve())
+```
+
+The displayed warning results from the fact that the used image file has
+an additional channel of transparency values (alpha channel) and can be
+ignored.
+
+## A parametric problem
+
+Now, let us consider the Neumann data function:
+
+```{math}
+g_N((x_0, x_1), \mu_{\text{neum}}) := -\cos(\pi \cdot x_0)^2 \cdot\mu_{\text{neum}}
 ```
 
-Each class in pyMOR that describes a {{ Parameter }}-dependent mathematical
-object, like the {{ StationaryModel }} in our case, derives from
-{{ ParametricObject }}. {{ ParametricObjects }} automatically determine the
-{{ Parameters }} they depend on from {{ ParametricObjects }} that have been passed
-as {meth}`__init__` arguments and from the
-{meth}`~pymor.parameters.base.ParametricObject.parameters_own` and
-{meth}`~pymor.parameters.base.ParametricObject.parameters_internal`
-attributes that have been set in {meth}`__init__`.
-Let's have a look:
+with a single {{ Parameter }} {math}`\mu_{\text{neum}} \in \mathbb{R}`.
+
+In pyMOR, {{ parameter_values }} are specified as a dictionary of one-dimensional
+{{ NumPy_arrays }}. Each value in the dictionary must have a correct size specified by the
+{{ Parameters }} of the {{ ParametricObject }}. In this example we have a single scalar
+valued parameter which we call `'neum'`. Thus, the {{ Parameters }} of the function
+will be
+
+```
+{'neum': 1}
+```
+
+We can then make the following definition of the Neumann data:
 
 ```{code-cell}
-print(fom.parameters)
+neumann_data = ExpressionFunction('-cos(pi*x[0])**2*neum[0]', 2, parameters= {'neum': 1})
 ```
 
-This tells us, that the {{ Parameters }} which
-{meth}`~pymor.models.interface.Model.solve` expects
-should be a dictionary with one key `'diffusion'` whose value is a one-dimensional
-{{ NumPy_array }} of size `6`, corresponding to the block structure of
-the problem. However, as an exception to this rule, the interface methods of
-{{ Models }} allow simply passing the list `[1.0, 0.1, 0.3, 0.1, 0.2, 1.0]` by
-internally calling {meth}`~pymor.parameters.Parameters.parse`.
+Similar to the range of the function, pyMOR cannot infer from the given
+string expression the parameters used in the expression, so these
+{{ Parameters }} have to be provided as the `parameters` argument.
+The individual parameters are then available as variables in
+the expression.
 
-Next we want to use the {func}`~pymor.algorithms.greedy.greedy` algorithm
-to reduce the problem. For this we need to choose a reductor which will keep
-track of the reduced basis and perform the actual RB-projection. We will use
-{class}`~pymor.reductors.coercive.CoerciveRBReductor`, which will
-also assemble an error estimator to estimate the reduction error. This
-will significantly speed up the basis generation, as we will only need to
-solve the high-dimensional problem for those parameters in the training set
-which are actually selected for basis extension. To control the condition of
-the reduced system matrix, we must ensure that the generated basis is
-orthonormal w.r.t. the H1_0-product on the solution space. For this we pass
-the {attr}`h1_0_semi_product` attribute of the model as inner product to
-the reductor, which will also use it for computing the Riesz representatives
-required for error estimation. Moreover, we have to provide
-the reductor with a {{ ParameterFunctional }} which computes a lower bound for
-the coercivity of the problem for given {{ parameter_values }}.
+We can then proceed as usual and automatically obtain a parametric
+{{ Model }}:
 
 ```{code-cell}
-reductor = CoerciveRBReductor(
-   fom,
-   product=fom.h1_0_semi_product,
-   coercivity_estimator=ExpressionParameterFunctional('min(diffusion)', fom.parameters)
+diffusion = ExpressionFunction(
+   '1. - (sqrt( ((x[0] % (1./K))-0.5/K)**2 + ((x[1] % (1./K))-0.5/K)**2) <= 0.3/K) * 0.999',
+   2, values={'K': 10}
+)
+problem = StationaryProblem(
+   domain=domain,
+   diffusion=diffusion,
+   neumann_data=neumann_data
 )
+
+m, data = discretize_stationary_cg(problem, diameter=1/100)
+m.parameters
 ```
 
-Moreover, we need to select a training set of {{ parameter_values }}. The problem
-`p` already comes with a {{ ParameterSpace }}, from which we can easily sample
-these values.  E.g.:
+When solving the model, we now need to specify appropriate
+{{ parameter_values }}:
 
 ```{code-cell}
-training_set = p.parameter_space.sample_uniformly(4)
-print(training_set[0])
+m.visualize(m.solve({'neum': [1.]}))
 ```
 
-Now we start the basis generation:
+For the {meth}`~pymor.models.interface.Model.solve` method, the
+parameter value can also be specified as a single number:
 
 ```{code-cell}
-greedy_data = rb_greedy(fom, reductor, training_set, max_extensions=32)
+m.visualize(m.solve(-100))
 ```
 
-The `max_extensions` parameter defines how many basis vectors we want to
-obtain. `greedy_data` is a dictionary containing various data that has
-been generated during the run of the algorithm:
+## Multiple parameters
+
+Next we also want to parameterize the diffusivity in the
+{math}`K \times K` circular disks by a scalar factor
+{math}`\mu_{\text{diffu}}`. To this end we define:
 
 ```{code-cell}
-print(greedy_data.keys())
+diffusion = ExpressionFunction(
+   '1. - (sqrt( ((x[0] % (1./K))-0.5/K)**2 + ((x[1] % (1./K))-0.5/K)**2) <= 0.3/K) * (1 - diffu[0])',
+   2, values={'K': 10},
+   parameters= {'diffu': 1}
+)
 ```
 
-The most important items is `'rom'` which holds the reduced {{ Model }}
-obtained from applying our reductor with the final reduced basis.
+We proceed as usual:
 
 ```{code-cell}
-rom = greedy_data['rom']
+problem = StationaryProblem(
+   domain=domain,
+   diffusion=diffusion,
+   neumann_data=neumann_data
+)
+
+m, data = discretize_stationary_cg(problem, diameter=1/100)
+m.parameters
 ```
 
-All vectors in pyMOR are stored in so called {{ VectorArrays }}. For example
-the solution `U` computed above is given as a {{ VectorArray }} of length 1.
-For the reduced basis we have:
+As we can see, pyMOR automatically derives that in this case the model
+depends on two {{ Parameters }}, and we have to provide two values
+when solving the model:
 
 ```{code-cell}
-RB = reductor.bases['RB']
-print(type(RB))
-print(len(RB))
-print(RB.dim)
+m.visualize(m.solve({'diffu': 0.001, 'neum': 1}))
 ```
 
-Let us check if the reduced basis really is orthonormal with respect to
-the H1-product. For this we use the {meth}`~pymor.vectorarrays.interface.VectorArray.gramian`
-method:
+For {meth}`~pymor.models.interface.Model.solve` we can also
+simply pass a list of parameter values, in which case
+pyMOR assumes an alphabetical ordering of the parameters:
 
 ```{code-cell}
-import numpy as np
-gram_matrix = RB.gramian(fom.h1_0_semi_product)
-print(np.max(np.abs(gram_matrix - np.eye(32))))
+m.visualize(m.solve([1, -1]))
+```
+
+## Parameter-separability
+
+For the generation of online-efficient reduced-order models, it is often
+crucial that data functions are parameter separable. We call a
+parametric function {math}`f(x, \mu)` parameter separable if it admits a
+decomposition
+
+```{math}
+f(x, \mu) = \sum_{q=1}^Q f_q(x) \cdot \theta_q(\mu)
 ```
 
-Looks good! We can now solve the reduced model for the same {{ parameter_values }}
-as above.  The result is a vector of coefficients w.r.t. the reduced basis, which is
-currently stored in `RB`. To form the linear combination, we can use the
-`reconstruct` method of the reductor:
+where the {math}`f_q` are non-parametric and the *parameter
+functionals* {math}`\theta_q` map parameters to real numbers.
+
+To model such a decomposition using pyMORs discretization toolkit, we
+specify the {math}`f_q` as non-parametric {{ Functions }}, the
+{math}`\theta_q` are represented by {{ ParameterFunctionals }} and the
+given sum decomposition is represented by a {{ LincombFunction }} of these
+objects.
+
+As an example let us go back to the case where the diffusivity is
+represented by indicator functions of point sets forming the letters
+`RB`. We now want to parameterize the diffusivity in the individual
+letters. This admits a decomposition of the form
+
+```{math}
+\sigma(x,y) = 1 + f_R \cdot (\mu_R - 1) + f_B \cdot (\mu_L - 1)
+```
+
+Again, we define {math}`f_R` and {math}`f_L` as {{ BitmapFunctions }} for
+the following image files:
+
+```{image} R.png
+
+```
+
+```{image} B.png
+
+```
 
 ```{code-cell}
-u = rom.solve([1.0, 0.1, 0.3, 0.1, 0.2, 1.0])
-print(u)
-U_red = reductor.reconstruct(u)
-print(U_red.dim)
+f_R = BitmapFunction('R.png', range=[1, 0])
+f_B = BitmapFunction('B.png', range=[1, 0])
+```
+
+Next we need to define the {{ ParameterFunctionals }}
+
+```{math}
+\theta_R(\mu) = \mu_R - 1 \quad\text{and}\quad \theta_B(\mu) = \mu_B - 1.
 ```
 
-Finally we compute the reduction error and display the reduced solution along with
-the detailed solution and the error:
+Similar to an {{ ExpressionFunction }}, we can use
+{{ ExpressionParameterFunctionals }} for that:
 
 ```{code-cell}
-ERR = U - U_red
-print(ERR.norm(fom.h1_0_semi_product))
-fom.visualize((U, U_red, ERR),
-             legend=('Detailed', 'Reduced', 'Error'),
-             separate_colorbars=True)
+theta_R = ExpressionParameterFunctional('R[0] - 1', {'R': 1})
+theta_B = ExpressionParameterFunctional('B[0] - 1', {'B': 1})
 ```
 
-We can nicely observe that, as expected, the error is maximized along the
-jumps of the diffusion coefficient.
+Note that the second argument is again the {{ Parameters }}
+that are used in the expression. Finally, we form the linear
+combination using a {{ LincombFunction }} which is given a list of
+{{ Functions }} as the first and a corresponding list of
+{{ ParameterFunctionals }} or constants as the second argument:
 
-Download the code: {download}`getting_started.md` {nb-download}`getting_started.ipynb`
+```{code-cell}
+diffusion = LincombFunction(
+   [ConstantFunction(1., 2), f_R, f_B],
+   [1., theta_R, theta_B]
+)
+diffusion.parameters
+```
 
-## Learning more
+Again, pyMOR automatically derives that the evaluation of `diffusion`
+depends on the two {{ Parameters }} `'B'` and `'R'`. Now, we can
+proceed as usual:
 
-As a next step, you should read our {ref}`technical_overview` which discusses the
-most important concepts and design decisions behind pyMOR. You can also follow our
-growing set of {doc}`tutorials`, which focus on specific aspects of pyMOR.
+```{code-cell}
+problem = StationaryProblem(
+   domain=domain,
+   diffusion=diffusion,
+   neumann_data=ConstantFunction(-1, 2)
+)
+m, data = discretize_stationary_cg(problem, diameter=1/100)
+m.visualize((m.solve([1., 0.001]), m.solve([0.001, 1])))
+```
 
-Should you have any problems regarding pyMOR, questions or
-[feature requests](<https://github.com/pymor/pymor/issues>), do not hesitate
-to contact us via
-[GitHub discussions](<https://github.com/pymor/pymor/discussions>)!
+Looking at the {{ Model }} `m`, we can see that the decomposition of
+{math}`\sigma` has been preserved by the discretizer:
+
+```{code-cell}
+m.operator
+```
 
+The {{ LincombFunction }} has become a {{ LincombOperator }}, with the same
+linear coefficients but the {{ BitmapFunctions }} replaced by
+corresponding stiffness matrices. Note that an additional summand
+appears which ensures correct enforcement of Dirichlet boundary values
+for all possible parameter value combinations.
 
+Download the code:
+{download}`tutorial_builtin_discretizer.md`
+{nb-download}`tutorial_builtin_discretizer.ipynb`
```

### Comparing `pymor-2022.2.1/docs/source/jupyter_init.txt` & `pymor-2023.1.0/docs/source/jupyter_init.txt`

 * *Files identical despite different names*

### Comparing `pymor-2022.2.1/docs/source/lstm.svg` & `pymor-2023.1.0/docs/source/lstm.svg`

 * *Files identical despite different names*

### Comparing `pymor-2022.2.1/docs/source/lstm_cell.svg` & `pymor-2023.1.0/docs/source/lstm_cell.svg`

 * *Files identical despite different names*

### Comparing `pymor-2022.2.1/docs/source/lstm_cell_forget_gate.svg` & `pymor-2023.1.0/docs/source/lstm_cell_forget_gate.svg`

 * *Files identical despite different names*

### Comparing `pymor-2022.2.1/docs/source/lstm_cell_input_gate.svg` & `pymor-2023.1.0/docs/source/lstm_cell_input_gate.svg`

 * *Files identical despite different names*

### Comparing `pymor-2022.2.1/docs/source/lstm_cell_output_gate.svg` & `pymor-2023.1.0/docs/source/lstm_cell_output_gate.svg`

 * *Files identical despite different names*

### Comparing `pymor-2022.2.1/docs/source/minimal_cpp_demo/CMakeLists.txt` & `pymor-2023.1.0/docs/source/minimal_cpp_demo/CMakeLists.txt`

 * *Files 9% similar despite different names*

```diff
@@ -1,10 +1,9 @@
-cmake_minimum_required(VERSION 3.1)
+cmake_minimum_required(VERSION 3.15)
 
-set(Python3_EXECUTABLE /usr/local/bin/python3 CACHE PATH "")
 project(minimal-cpp-demo)
 
 if(${CMAKE_VERSION} VERSION_GREATER_EQUAL "3.18.0")
   find_package(Python3 COMPONENTS Interpreter Development.Module REQUIRED)
 else()
   find_package(Python3 COMPONENTS Interpreter Development REQUIRED)
 endif()
@@ -14,9 +13,7 @@
 message(STATUS "Found pybind11 v${pybind11_VERSION}: ${pybind11_INCLUDE_DIRS}")
 
 # Create an extension module
 add_library(model MODULE model.cc)
 target_link_libraries(model pybind11::module)
 set_target_properties(model PROPERTIES PREFIX "${PYTHON_MODULE_PREFIX}")
 set_target_properties(model PROPERTIES SUFFIX "${PYTHON_MODULE_EXTENSION}")
-
-
```

### Comparing `pymor-2022.2.1/docs/source/minimal_cpp_demo/model.cc` & `pymor-2023.1.0/docs/source/minimal_cpp_demo/model.cc`

 * *Files identical despite different names*

### Comparing `pymor-2022.2.1/docs/source/minimal_cpp_demo/model.hh` & `pymor-2023.1.0/docs/source/minimal_cpp_demo/model.hh`

 * *Files identical despite different names*

### Comparing `pymor-2022.2.1/docs/source/neural_network.svg` & `pymor-2023.1.0/docs/source/neural_network.svg`

 * *Files identical despite different names*

### Comparing `pymor-2022.2.1/docs/source/pymordocstring.py` & `pymor-2023.1.0/docs/source/pymordocstring.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,18 +1,18 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 # This file was originally based upon sphinxcontrib-napoleon
 # Copyright 2013 Rob Ruana
 
-from collections import deque, defaultdict, OrderedDict
-from types import MethodType, FunctionType
-import re
 import functools
+import re
+from collections import OrderedDict, defaultdict, deque
+from types import FunctionType, MethodType
 
 from sphinx.util.inspect import safe_getattr
 
 STRING_TYPE = str
 
 INCLUDE_SPECIAL_WITH_DOC = False
 INCLUDE_PRIVATE_WITH_DOC = False
```

### Comparing `pymor-2022.2.1/docs/source/release_notes/0.3.rst` & `pymor-2023.1.0/docs/source/release_notes/0.3.rst`

 * *Files 0% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-
 pyMOR 0.3 (March 2, 2015)
 -------------------------
 
 - Introduction of the vector space concept for even simpler
   integration with external solvers.
 
 - Addition of a generic Newton algorithm.
```

### Comparing `pymor-2022.2.1/docs/source/release_notes/0.4.rst` & `pymor-2023.1.0/docs/source/release_notes/0.4.rst`

 * *Files 11% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-
 pyMOR 0.4 (September 28, 2016)
 ------------------------------
 
 With the pyMOR 0.4 release we have changed the copyright of
 pyMOR to
 
   Copyright 2013-2016 pyMOR developers and contributors. All rights reserved.
@@ -32,119 +31,119 @@
 
 
 Parallelization of pyMOR's reduction algorithms
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 We have added a parallelization framework to pyMOR which allows
 parallel execution of reduction algorithms based on a simple
 |WorkerPool| interface `[#14] <https://github.com/pymor/pymor/issues/14>`_.
-The :meth:`~pymor.algorithms.greedy.greedy` `[#155] <https://github.com/pymor/pymor/pull/155>`_
+The :meth:`!greedy` `[#155] <https://github.com/pymor/pymor/pull/155>`_
 and :meth:`~pymor.algorithms.ei.ei_greedy` algorithms `[#162] <https://github.com/pymor/pymor/pull/162>`_
 have been refactored to utilize this interface.
 Two |WorkerPool| implementations are shipped with pyMOR:
 :class:`~pymor.parallel.ipython.IPythonPool` utilizes the parallel
 computing features of `IPython <https://ipython.org/>`_, allowing
 parallel algorithm execution in large heterogeneous clusters of
 computing nodes. :class:`~pymor.parallel.mpi.MPIPool` can be used
 to benefit from existing MPI-based parallel HPC computing architectures
 `[#161] <https://github.com/pymor/pymor/issues/161>`_.
 
 
 Support classes for MPI distributed external PDE solvers
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-While pyMOR's |VectorArray|, |Operator| and `Discretization`
+While pyMOR's `VectorArrayInterface`, `OperatorInterface` and `Discretization`
 interfaces are agnostic to the concrete (parallel) implementation
 of the corresponding objects in the PDE solver, external solvers
 are often integrated by creating wrapper classes directly corresponding
 to the solvers data structures. However, when the solver is executed
 in an MPI distributed context, these wrapper classes will then only
-correspond to the rank-local data of a distributed |VectorArray| or
-|Operator|.
+correspond to the rank-local data of a distributed `VectorArrayInterface` or
+`OperatorInterface`.
 
 To facilitate the integration of MPI parallel solvers, we have added
 MPI helper classes `[#163] <https://github.com/pymor/pymor/pull/163>`_
 in :mod:`pymor.vectorarrays.mpi`, :mod:`pymor.operators.mpi`
-and :mod:`pymor.discretizations.mpi` that allow an automatic
+and :mod:`!pymor.discretizations.mpi` that allow an automatic
 wrapping of existing sequential bindings for MPI distributed use.
 These wrapper classes are based on a simple event loop provided
 by :mod:`pymor.tools.mpi`, which is used in the interface methods of
 the wrapper classes to dispatch into MPI distributed execution
 of the corresponding methods on the underlying MPI distributed
 objects.
 
 The resulting objects can be used on MPI rank 0 (including interactive
 Python sessions) without any further changes to pyMOR or the user code.
 For an example, see :meth:`pymordemos.thermalblock_simple.discretize_fenics`.
 
 
 New reduction algorithms
 ~~~~~~~~~~~~~~~~~~~~~~~~
-- :meth:`~pymor.algorithms.adaptivegreedy.adaptive_greedy` uses adaptive
+- :meth:`!adaptive_greedy` uses adaptive
   parameter training set refinement according to :cite:`HDO11` to prevent
   overfitting of the reduced model to the training set `[#213] <https://github.com/pymor/pymor/pull/213>`_.
 
-- :meth:`~pymor.reductors.parabolic.reduce_parabolic` reduces linear parabolic
-  problems using :meth:`~pymor.reductors.basic.reduce_generic_rb` and
+- :meth:`!reduce_parabolic` reduces linear parabolic
+  problems using :meth:`!reduce_generic_rb` and
   assembles an error estimator similar to :cite:`GP05`, :cite:`HO08`.
   The :mod:`~pymordemos.parabolic_mor` demo contains a simple sample
   application using this reductor `[#190] <https://github.com/pymor/pymor/issues/190>`_.
 
 - The :meth:`~pymor.algorithms.image.estimate_image` and
   :meth:`~pymor.algorithms.image.estimate_image_hierarchical` algorithms
   can be used to find an as small as possible space in which the images of
   a given list of operators for a given source space are contained for all
   possible parameters `mu`. For possible applications, see
-  :meth:`~pymor.reductors.residual.reduce_residual` which now uses
+  :meth:`!reduce_residual` which now uses
   :meth:`~pymor.algorithms.image.estimate_image_hierarchical` for
   Petrov-Galerkin projection of the residual operator `[#223] <https://github.com/pymor/pymor/pull/223>`_.
 
 
-Copy-on-write semantics for |VectorArrays|
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-The :meth:`~pymor.vectorarrays.interfaces.VectorArrayInterface.copy` method
-of the |VectorArray| interface is now assumed to have copy-on-write
-semantics. I.e., the returned |VectorArray| will contain a reference to the same
+Copy-on-write semantics for `VectorArrayInterfaces`
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+The :meth:`!copy` method
+of the `VectorArrayInterface` is now assumed to have copy-on-write
+semantics. I.e., the returned `VectorArrayInterface` will contain a reference to the same
 data as the original array, and the actual data will only be copied when one of
 the arrays is changed. Both |NumpyVectorArray| and |ListVectorArray| have been
 updated accordingly `[#55] <https://github.com/pymor/pymor/issues/55>`_.
-As a main benefit of this approach, |immutable| objects having a |VectorArray| as
-an attribute now can safely create copies of the passed |VectorArrays| (to ensure
+As a main benefit of this approach, |immutable| objects having a `VectorArrayInterface` as
+an attribute now can safely create copies of the passed `VectorArrayInterfacess` (to ensure
 the immutability of their state) without having to worry about unnecessarily
 increased memory consumption.
 
 
 Improvements to pyMOR's discretizaion tookit
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-- An unstructured triangular |Grid| is now provided by :class:`~pymor.grids.unstructured.UnstructuredTriangleGrid`.
-  Such a |Grid| can be obtained using the :meth:`~pymor.domaindiscretizers.gmsh.discretize_gmsh`
+- An unstructured triangular |Grid| is now provided by :class:`!UnstructuredTriangleGrid`.
+  Such a |Grid| can be obtained using the :meth:`!discretize_gmsh`
   method, which can parse `Gmsh <https://gmsh.info/>`_ output files. Moreover, this
   method can generate `Gmsh` input files to create unstructured meshes for
-  an arbitrary :class:`~pymor.domaindescriptions.polygonal.PolygonalDomain`
+  an arbitrary :class:`!PolygonalDomain`
   `[#9] <https://github.com/pymor/pymor/issues/9>`_.
 
 - Basic support for parabolic problems has been added.
-  The :meth:`~pymor.discretizers.parabolic.discretize_parabolic_cg` and
-  :meth:`~pymor.discretizers.parabolic.discretize_parabolic_fv` methods can
+  The :meth:`!discretize_parabolic_cg` and
+  :meth:`!discretize_parabolic_fv` methods can
   be used to build continuous finite element or finite volume `Discretizations`
-  from a given :class:`pymor.analyticalproblems.parabolic.ParabolicProblem`.
+  from a given :class:`!pymor.analyticalproblems.parabolic.ParabolicProblem`.
   The :mod:`~pymordemos.parabolic` demo demonstrates the use of these methods
   `[#189] <https://github.com/pymor/pymor/issues/189>`_.
 
-- The :mod:`pymor.discretizers.disk` module contains methods to create stationary and
+- The :mod:`!pymor.discretizers.disk` module contains methods to create stationary and
   instationary affinely decomposed `Discretizations` from matrix data files
   and an `.ini` file defining the given problem.
 
-- :class:`EllipticProblems <pymor.analyticalproblems.elliptic.EllipticProblem>`
+- :class:`!EllipticProblems`
   can now also contain advection and reaction terms in addition to the diffusion part.
-  :meth:`~pymor.discretizers.cg.discretize_elliptic_cg` has been
+  :meth:`!discretize_elliptic_cg` has been
   extended accordingly `[#211] <https://github.com/pymor/pymor/pull/211>`_.
 
-- The :mod:`continuous Galerkin <pymor.operators.cg>` module has been extended to
+- The :mod:`!continuous Galerkin` module has been extended to
   support Robin boundary conditions `[#110] <https://github.com/pymor/pymor/pull/110>`_.
 
-- :class:`~pymor.functions.bitmap.BitmapFunction` allows to use grayscale
+- :class:`!BitmapFunction` allows to use grayscale
   image data as data |Functions| `[#194] <https://github.com/pymor/pymor/issues/194>`_.
 
 - For the visualization of time-dependent data, the colorbars can now be
   rescaled with each new frame `[#91] <https://github.com/pymor/pymor/pull/91>`_.
 
 
 Caching improvements
@@ -162,17 +161,16 @@
   `state id` calculation `[#106] <https://github.com/pymor/pymor/issues/106>`_.
 
 - :class:`CacheRegions <pymor.core.cache.CacheRegion>` now have a
   :attr:`~pymor.core.cache.CacheRegion.persistent` attribute indicating
   whether the cache data will be kept between program runs. For persistent
   cache regions the `state id` of the object for which the cached method is
   called has to be computed to obtain a unique persistent id for the given object.
-  For non-persistent regions the object's
-  `~pymor.core.interfaces.BasicInterface.uid` can be used instead.
-  :attr:`pymor.core.cache_regions` now by default contains `'memory'`,
+  For non-persistent regions the object's :attr:`!uid` can be used instead.
+  :attr:`!pymor.core.cache_regions` now by default contains `'memory'`,
   `'disk'` and `'persistent'` cache regions
   `[#182] <https://github.com/pymor/pymor/pull/182>`_, `[#121] <https://github.com/pymor/pymor/issues/121>`_ .
 
 - |defaults| can now be marked to not affect `state id` computation.
   In previous version of pyMOR, changing any |default| value caused
   a change of the `state id` pyMOR's defaults dictionary, leading to cache
   misses. While this in general is desirable, as, for instance, changed linear
@@ -180,146 +178,155 @@
   the same `Discretization` object, it is clear for many I/O related defaults,
   that these will not affect the outcome of any computation. For these defaults,
   the :meth:`~pymor.core.defaults.defaults` decorator now accepts a `sid_ignore`
   parameter, to exclude these defaults from `state id` computation, preventing
   changes of these defaults causing cache misses `[#81] <https://github.com/pymor/pymor/issues/81>`_.
 
 - As an alternative to using the :meth:`@cached <pymor.core.cache.cached>`
-  decorator, :meth:`~pymor.core.cache.CacheableInterface.cached_method_call`
+  decorator, :meth:`!cached_method_call`
   can be used to cache the results of a function call. This is now used
-  in :meth:`~pymor.discretizations.interfaces.DiscretizationInterface.solve`
+  in :meth:`!solve`
   to enable parsing of the input parameter before it enters the cache key
   calculation `[#231] <https://github.com/pymor/pymor/pull/231>`_.
 
 
 Additional new features
 ^^^^^^^^^^^^^^^^^^^^^^^
-- :meth:`~pymor.operators.interfaces.OperatorInterface.apply_inverse_adjoint` has been added to the |Operator| interface `[#133] <https://github.com/pymor/pymor/issues/133>`_.
+- :meth:`!apply_inverse_adjoint`
+  has been added to the `OperatorInterface` interface `[#133] <https://github.com/pymor/pymor/issues/133>`_.
 
 - Support for complex values in |NumpyVectorArray| and |NumpyMatrixOperator| `[#131] <https://github.com/pymor/pymor/issues/131>`_.
 
 - New :class:`~pymor.parameters.functionals.ProductParameterFunctional`.
-    This |ParameterFunctional| represents the product of a given list of
-    |ParameterFunctionals|.
+    This `ParameterFunctionalInterface` represents the product of a given list of
+    `ParameterFunctionalInterfaces`.
 
 - New :class:`~pymor.operators.constructions.SelectionOperator` `[#105] <https://github.com/pymor/pymor/pull/105>`_.
-    This |Operator| represents one |Operator| of a given list of |Operators|,
-    depending on the evaluation of a provided |ParameterFunctional|,
+    This `OperatorInterface` represents one `OperatorInterface` of a given list of `OperatorInterfaces`,
+    depending on the evaluation of a provided `ParameterFunctionalInterface`,
 
 - New block matrix operators `[#215] <https://github.com/pymor/pymor/pull/215>`_.
     :class:`~pymor.operators.block.BlockOperator` and
     :class:`~pymor.operators.block.BlockDiagonalOperator` represent block
-    matrices of |Operators| which can be applied to appropriately shaped
+    matrices of `OperatorsInterfaces` which can be applied to appropriately shaped
     :class:`BlockVectorArrays <pymor.vectorarrays.block.BlockVectorArray>`.
 
 - `from_file` factory method for |NumpyVectorArray| and |NumpyMatrixOperator| `[#118] <https://github.com/pymor/pymor/issues/118>`_.
-    :meth:`NumpyVectorArray.from_file <pymor.vectorarrays.numpy.NumpyVectorArray.from_file>` and
+    :meth:`!NumpyVectorArray.from_file` and
     :meth:`NumpyMatrixOperator.from_file <pymor.operators.numpy.NumpyMatrixOperator.from_file>`
     can be used to construct such objects from data files of various formats
     (MATLAB, matrix market, NumPy data files, text).
 
 - |ListVectorArray|-based |NumpyMatrixOperator| `[#164] <https://github.com/pymor/pymor/pull/164>`_.
-    The :mod:`~pymor.playground` now contains
-    :class:`~pymor.playground.operators.numpy.NumpyListVectorArrayMatrixOperator`
+    The :mod:`!playground` now contains
+    :class:`!NumpyListVectorArrayMatrixOperator`
     which can apply |NumPy|/|SciPy| matrices to a |ListVectorArray|.
-    This |Operator| is mainly intended for performance testing purposes.
+    This `OperatorInterface` is mainly intended for performance testing purposes.
     The :mod:`~pymordemos.thermalblock` demo now has an option
     `--list-vector-array` for using this operator instead of |NumpyMatrixOperator|.
 
 - Log indentation support `[#230] <https://github.com/pymor/pymor/pull/230>`_.
     pyMOR's log output can now be indented via the `logger.block(msg)`
     context manger to reflect the hierarchy of subalgorithms.
 
 - Additional `INFO2` and `INFO3` log levels `[#212] <https://github.com/pymor/pymor/pull/212>`_.
     :mod:`Loggers <pymor.core.logger>` now have additional `info2`
     and `info3` methods to highlight important information (which does
     fall in the 'warning' category).
 
-- Default implementation of :meth:`~pymor.operators.interfaces.OperatorInterface.as_vector` for functionals `[#107] <https://github.com/pymor/pymor/issues/107>`_.
-    :meth:`OperatorBase.as_vector <pymor.operators.basic.OperatorBase>` now
+- Default implementation of :meth:`!OperatorInterface.as_vector`
+    for functionals `[#107] <https://github.com/pymor/pymor/issues/107>`_.
+    :meth:`!OperatorBase.as_vector` now
     contains a default implementation for functionals by calling
-    :meth:`~pymor.operators.interfaces.OperatorInterface.apply_adjoint`.
+    :meth:`!apply_adjoint`.
 
 - `pycontracts` has been removed as a dependency of pyMOR `[#127] <https://github.com/pymor/pymor/pull/127>`_.
 
 - Test coverage has been raised to 80 percent.
 
 
 Backward incompatible changes
 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
-- |VectorArray| implementations have been moved to the :mod:`pymor.vectorarrays` sub-package `[#89] <https://github.com/pymor/pymor/issues/89>`_.
+- `VectorArrayInterface` implementations have been moved to the :mod:`pymor.vectorarrays` sub-package `[#89] <https://github.com/pymor/pymor/issues/89>`_.
 
-- The `dot` method of the |VectorArray| interface has been split into :meth:`~pymor.vectorarrays.interfaces.VectorArrayInterface.dot` and :meth:`~pymor.vectorarrays.interfaces.VectorArrayInterface.pairwise_dot` `[#76] <https://github.com/pymor/pymor/issues/76>`_.
-    The `pairwise` parameter of :meth:`~pymor.vectorarrays.interfaces.VectorArrayInterface.dot`
+- The `dot` method of the `VectorArrayInterface` interface has been split into
+    :meth:`!dot` and
+    :meth:`!pairwise_dot`
+    `[#76] <https://github.com/pymor/pymor/issues/76>`_.
+    The `pairwise` parameter of :meth:`!dot`
     has been removed, always assuming `pairwise == False`. The method
-    :meth:`~pymor.vectorarrays.interfaces.VectorArrayInterface.pairwise_dot`
-    corresponds to the `pairwise == True` case. Similarly the `pariwise` parameter
-    of the :meth:`~pymor.operators.interfaces.OperatorInterface.apply2` method
-    of the |Operator| interface has been removed and a
-    :meth:`~pymor.operators.interfaces.OperatorInterface.pairwise_apply2` method
+    :meth:`!pairwise_dot`
+    corresponds to the `pairwise == True` case. Similarly the `pairwise` parameter
+    of the :meth:`!apply2` method
+    of the `OperatorInterface` interface has been removed and a
+    :meth:`!pairwise_apply2` method
     has been added.
 
-- `almost_equal` has been removed from the |VectorArray| interface `[#143] <https://github.com/pymor/pymor/issues/143>`_.
+- `almost_equal` has been removed from the `VectorArrayInterface` interface `[#143] <https://github.com/pymor/pymor/issues/143>`_.
     As a replacement, the new method :meth:`pymor.algorithms.basic.almost_equal`
-    can be used to compare |VectorArrays| for almost equality by the norm
+    can be used to compare `VectorArrayInterfaces` for almost equality by the norm
     of their difference.
 
-- `lincomb` has been removed from the |Operator| interface `[#83] <https://github.com/pymor/pymor/issues/83>`_.
+- `lincomb` has been removed from the `OperatorInterface` interface `[#83] <https://github.com/pymor/pymor/issues/83>`_.
     Instead, a |LincombOperator| should be directly instantiated.
 
-- Removal of the `options` parameter of :meth:`~pymor.operators.interfaces.OperatorInterface.apply_inverse` in favor of :attr:`~pymor.operators.interfaces.OperatorInterface.solver_options` attribute `[#122] <https://github.com/pymor/pymor/issues/122>`_.
-    The `options` parameter of :meth:`OperatorInterface.apply_inverse <pymor.operators.interfaces.OperatorInterface.apply_inverse>`
-    has been replaced by the :attr:`~pymor.operators.interfaces.OperatorInterface.solver_options`
+- Removal of the `options` parameter of :meth:`!apply_inverse`
+    in favor of :attr:`!solver_options` attribute
+    `[#122] <https://github.com/pymor/pymor/issues/122>`_.  The `options` parameter of
+    :meth:`!OperatorInterface.apply_inverse`
+    has been replaced by the :attr:`!solver_options`
     attribute. This attribute controls which fixed (linear) solver options are
-    used when :meth:`~pymor.operators.interfaces.OperatorInterface.apply_inverse` is
+    used when :meth:`!apply_inverse` is
     called. See `here <https://github.com/pymor/pymor/pull/184>`__ for more details.
 
 - Renaming of reductors for coercive problems `[#224] <https://github.com/pymor/pymor/issues/224>`_.
-    :meth:`pymor.reductors.linear.reduce_stationary_affine_linear` and
-    :meth:`pymor.reductors.stationary.reduce_stationary_coercive` have been
-    renamed to :meth:`pymor.reductors.coercive.reduce_coercive` and
-    :meth:`pymor.reductors.coercive.reduce_coercive_simple`. The old names
+    :meth:`!pymor.reductors.linear.reduce_stationary_affine_linear` and
+    :meth:`!pymor.reductors.stationary.reduce_stationary_coercive` have been
+    renamed to :meth:`!pymor.reductors.coercive.reduce_coercive` and
+    :meth:`!pymor.reductors.coercive.reduce_coercive_simple`. The old names
     are deprecated and will be removed in pyMOR 0.5.
 
-- Non-parametric objects have now `~pymor.parameters.base.Parametric.parameter_type` `{}` instead of `None` `[#84] <https://github.com/pymor/pymor/issues/84>`_.
+- Non-parametric objects have now :attr:`!parameter_type` `{}`
+    instead of `None` `[#84] <https://github.com/pymor/pymor/issues/84>`_.
 
 - Sampling methods of |ParameterSpaces| now return iterables instead of iterators `[#108] <https://github.com/pymor/pymor/issues/108>`_.
 
-- Caching of :meth:`~pymor.discretizations.interfaces.DiscretizationInterface.solve` is now disabled by default `[#178] <https://github.com/pymor/pymor/issues/178>`_.
-    Caching of :meth:`~pymor.discretizations.interfaces.DiscretizationInterface.solve`
+- Caching of :meth:`!solve`
+    is now disabled by default `[#178] <https://github.com/pymor/pymor/issues/178>`_.
+    Caching of :meth:`!solve`
     must now be explicitly enabled by using
-    :meth:`pymor.core.cache.CacheableInterface.enable_caching`.
+    :meth:`!pymor.core.cache.CacheableInterface.enable_caching`.
 
-- The default value for `extension_algorithm` parameter of :meth:`~pymor.algorithms.greedy.greedy` has been removed `[#82] <https://github.com/pymor/pymor/issues/82>`_.
+- The default value for `extension_algorithm` parameter of :meth:`!greedy` has been removed `[#82] <https://github.com/pymor/pymor/issues/82>`_.
 
 - Changes to :meth:`~pymor.algorithms.ei.ei_greedy` `[#159] <https://github.com/pymor/pymor/issues/159>`_, `[#160] <https://github.com/pymor/pymor/issues/160>`_.
     The default for the `projection` parameter has been changed from `'orthogonal'`
     to `'ei'` to let the default algorithm agree with literature. In
     addition a `copy` parameter with default `True` has been added.
     When `copy` is `True`, the input data is copied before executing
-    the algorithm, ensuring, that the original |VectorArray| is left
+    the algorithm, ensuring, that the original `VectorArrayInterface` is left
     unchanged. When possible, `copy` should be set to `False` in order
     to reduce memory consumption.
 
 - The `copy` parameter of :meth:`pymor.algorithms.gram_schmidt.gram_schmidt` now defaults to `True` `[#123] <https://github.com/pymor/pymor/issues/123>`_.
 
 - `with_` has been moved from `BasicInterface` to `ImmutableInterface` `[#154] <https://github.com/pymor/pymor/issues/154>`_.
 
 - `BasicInterface.add_attributes` has been removed `[#158] <https://github.com/pymor/pymor/issues/158>`_.
 
-- Auto-generated names no longer contain the :attr:`~pymor.core.interfaces.BasicInterface.uid` `[#198] <https://github.com/pymor/pymor/issues/198>`_.
-    The auto-generated `~pymor.core.interfaces.BasicInterface.name`
+- Auto-generated names no longer contain the :attr:`!uid` `[#198] <https://github.com/pymor/pymor/issues/198>`_.
+    The auto-generated :attr:`!name`
     of pyMOR objects no longer contains their
-    `~pymor.core.interfaces.BasicInterface.uid`. Instead, the name
+    :attr:`!uid`. Instead, the name
     is now simply set to the class name.
 
 - Python fallbacks to Cython functions have been removed `[#145] <https://github.com/pymor/pymor/issues/145>`_.
     In order to use pyMOR's discretization toolkit, building of the
-    :mod:`~pymor.grids._unstructured`, :mod:`~pymor.tools.inplace`,
-    :mod:`~pymor.tools.relations` Cython extension modules is now
+    :mod:`!_unstructured`, :mod:`!inplace`,
+    :mod:`!relations` Cython extension modules is now
     required.
 
 
 
 Further improvements
 ^^^^^^^^^^^^^^^^^^^^
```

### Comparing `pymor-2022.2.1/docs/source/release_notes/0.5.rst` & `pymor-2023.1.0/docs/source/release_notes/0.5.rst`

 * *Files 6% similar despite different names*

```diff
@@ -1,24 +1,22 @@
-
-
 pyMOR 0.5 (January 17, 2019)
 ----------------------------
 
 After more than two years of development, we are proud to announce the release
 of pyMOR 0.5! Highlights of this release are support for Python 3, bindings for
 the NGSolve finite element library, new linear algebra algorithms, various
-|VectorArray| usability improvements, as well as a redesign of pyMOR's
+`VectorArrayInterface` usability improvements, as well as a redesign of pyMOR's
 projection algorithms based on |RuleTables|.
 
 Especially we would like to highlight the addition of various system-theoretic
 reduction methods such as Balanced Truncation or IRKA. All algorithms are
-implemented in terms of pyMOR's |Operator| and |VectorArray| interfaces,
-allowing their application to any model implemented using one of the PDE solver
-supported by pyMOR. In particular, no import of the system matrices is
-required.
+implemented in terms of pyMOR's `OperatorInterface` and `VectorArrayInterface`
+interfaces, allowing their application to any model implemented using one of the
+PDE solver supported by pyMOR. In particular, no import of the system matrices
+is required.
 
 Over 1,500 single commits have entered this release. For a full list of changes
 see `here <https://github.com/pymor/pymor/compare/0.4.x...0.5.x>`__.
 
 pyMOR 0.5 contains contributions by Linus Balicki, Julia Brunken and Christoph
 Lehrenfeld. See `here <https://github.com/pymor/pymor/blob/main/AUTHORS.md>`__
 for more details.
@@ -33,24 +31,24 @@
 ~~~~~~~~~~~~~~~~
 
 pyMOR is now compatible with Python 3.5 or greater. Since the use of Python 3 is
 now standard in the scientific computing community and security updates for
 Python 2 will stop in less than a year (https://pythonclock.org), we decided to
 no longer support Python 2 and make pyMOR 0.5 a Python 3-only release. Switching
 to Python 3 also allows us to leverage newer language features such as the `@`
-binary operator for concatenation of |Operators|, keyword-only arguments or
-improved support for asynchronous programming.
+binary operator for concatenation of `OperatorInterfaces`, keyword-only
+arguments or improved support for asynchronous programming.
 
 
 
 System-theoretic MOR methods
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 With 386 commits, `[#464] <https://github.com/pymor/pymor/pull/464>`_ added
-systems-theoretic methods to pyMOR. Module :mod:`pymor.discretizations.iosys`
+systems-theoretic methods to pyMOR. Module :mod:`!pymor.discretizations.iosys`
 contains new discretization classes for input-output systems, e.g. `LTISystem`,
 `SecondOrderSystem` and |TransferFunction|. At present, methods related to these
 classes mainly focus on continuous-time, non-parametric systems.
 
 Since matrix equation solvers are important tools in many system-theoretic
 methods, support for Lyapunov, Riccati and Sylvester equations has been added in
 :mod:`pymor.algorithms.lyapunov`, :mod:`pymor.algorithms.riccati` and
@@ -67,39 +65,39 @@
 
 Balancing Truncation (BT) and Iterative Rational Krylov Algorithm (IRKA) are
 implemented in :class:`~pymor.reductors.bt.BTReductor` and
 :class:`~pymor.reductors.h2.IRKAReductor`. LQG and Bounded Real variants of BT
 are also available (:class:`~pymor.reductors.bt.LQGBTReductor`,
 :class:`~pymor.reductors.bt.BRBTReductor`). Bitangential Hermite interpolation
 (used in IRKA) is implemented in
-:class:`~pymor.reductors.interpolation.LTI_BHIReductor`. Two-Sided Iteration
+:class:`!LTI_BHIReductor`. Two-Sided Iteration
 Algorithm (TSIA), a method related to IRKA, is implemented in
 :class:`~pymor.reductors.h2.TSIAReductor`.
 
 Several structure-preserving MOR methods for second-order systems have been
 implemented. Balancing-based MOR methods are implemented in
 :mod:`pymor.reductors.sobt`, bitangential Hermite interpolation in
-:class:`~pymor.reductors.interpolation.SO_BHIReductor` and Second-Order Reduced
-IRKA (SOR-IRKA) in :class:`~pymor.reductors.sor_irka.SOR_IRKAReductor`.
+:class:`!SO_BHIReductor` and Second-Order Reduced
+IRKA (SOR-IRKA) in :class:`!SOR_IRKAReductor`.
 
 For more general transfer functions, MOR methods which return `LTISystems` are
 also available. Bitangential Hermite interpolation is implemented in
-:class:`~pymor.reductors.interpolation.TFInterpReductor` and Transfer Function
-IRKA (TF-IRKA) in :class:`~pymor.reductors.h2.TF_IRKAReductor`.
+:class:`!TFInterpReductor` and Transfer Function
+IRKA (TF-IRKA) in :class:`!TF_IRKAReductor`.
 
 Usage examples can be found in the `heat` and `string_equation` demo scripts.
 
 
 NGSolve support
 ~~~~~~~~~~~~~~~
 
 We now ship bindings for the `NGSolve <https://ngsolve.org>`_ finite element
-library. Wrapper classes for |VectorArrays| and matrix-based |Operators| can be
-found in the :mod:`pymor.bindings.ngsolve` module. A usage example can be found
-in the `thermalblock_simple` demo script.
+library. Wrapper classes for `VectorArrayInterfaces` and matrix-based
+`OperatorInterfaces` can be found in the :mod:`pymor.bindings.ngsolve` module. A
+usage example can be found in the `thermalblock_simple` demo script.
 
 
 New linear algebra algorithms
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 pyMOR now includes an implementation of the
 `HAPOD algorithm <https://doi.org/10.1137/16M1085413>`_ for fast distributed
@@ -112,115 +110,119 @@
 In addition, the Gram-Schmidt biorthogonalization algorithm has been included in
 :mod:`pymor.algorithms.gram_schmidt`.
 
 
 VectorArray improvements
 ~~~~~~~~~~~~~~~~~~~~~~~~
 
-|VectorArrays| in pyMOR have undergone several usability improvements:
+`VectorArrayInterfaces` in pyMOR have undergone several usability improvements:
 
 - The somewhat dubious concept of a `subtype` has been superseded by the concept
-  of |VectorSpaces| which act as factories for |VectorArrays|. In particular,
-  instead of a `subtype`, |VectorSpaces| can now hold meaningful attributes
-  (e.g. the dimension) which are required to construct |VectorArrays| contained
-  in the space. The
-  :attr:`~pymor.vectorarrays.interfaces.VectorSpaceInterface.id` attribute
+  of `VectorSpaceInterfaces` which act as factories for `VectorArrayInterfaces`.
+  In particular, instead of a `subtype`, `VectorSpaceInterfaces` can now hold
+  meaningful attributes (e.g. the dimension) which are required to construct
+  `VectorArrayInterfaces` contained in the space. The
+  :attr:`!id` attribute
   allows to differentiate between technically identical but mathematically
   different spaces `[#323] <https://github.com/pymor/pymor/pull/323>`_.
 
-- |VectorArrays| can now be indexed to select a subset of vectors to operate on.
-  In contrast to advanced indexing in |NumPy|, indexing a |VectorArray| will
-  always return a view onto the original array data
+- `VectorArrayInterfaces` can now be indexed to select a subset of vectors to
+  operate on.  In contrast to advanced indexing in |NumPy|, indexing a
+  `VectorArrayInterface` will always return a view onto the original array data
   `[#299] <https://github.com/pymor/pymor/pull/299>`_.
 
 - New methods with clear semantics have been introduced for the conversion of
-  |VectorArrays| to
-  (:meth:`~pymor.vectorarrays.interfaces.VectorArrayInterface.to_numpy`) and
-  from (:meth:`~pymor.vectorarrays.interfaces.VectorSpaceInterface.from_numpy`)
+  `VectorArrayInterfaces` to
+  (:meth:`!to_numpy`) and
+  from (:meth:`!from_numpy`)
   |NumPy arrays| `[#446] <https://github.com/pymor/pymor/pull/446>`_.
 
-- Inner products between |VectorArrays| w.r.t. to a given inner product
-  |Operator| or their norm w.r.t. such an operator can now easily be computed by
-  passing the |Operator| as the optional `product` argument to the new
-  :meth:`~pymor.vectorarrays.interfaces.VectorArrayInterface.inner` and
-  :meth:`~pymor.vectorarrays.interfaces.VectorArrayInterface.norm` methods
+- Inner products between `VectorArrayInterfaces` w.r.t. to a given inner product
+  `OperatorInterface` or their norm w.r.t. such an operator can now easily be
+  computed by passing the `OperatorInterface` as the optional `product` argument
+  to the new
+  :meth:`!inner` and
+  :meth:`!norm` methods
   `[#407] <https://github.com/pymor/pymor/pull/407>`_.
 
-- The `components` method of |VectorArrays| has been renamed to the more
-  intuitive name
-  :meth:`~pymor.vectorarrays.interfaces.VectorArrayInterface.dofs`
+- The `components` method of `VectorArrayInterfaces` has been renamed to the
+  more intuitive name
+  :meth:`!dofs`
   `[#414] <https://github.com/pymor/pymor/pull/414>`_.
 
-- The :meth:`~pymor.vectorarrays.interfaces.VectorArrayInterface.l2_norm2` and
-  :meth:`~pymor.vectorarrays.interfaces.VectorArrayInterface.norm2` have been
+- The :meth:`!l2_norm2` and
+  :meth:`!norm2` have been
   introduced to compute the squared vector norms
   `[#237] <https://github.com/pymor/pymor/pull/237>`_.
 
 
 
 RuleTable based algorithms
 ~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 In pyMOR 0.5, projection algorithms are implemented via recursively applied
 tables of transformation rules. This replaces the previous inheritance-based
 approach. In particular, the `projected` method to perform a (Petrov-)Galerkin
-projection of an arbitrary |Operator| has been removed and replaced by a free
-|project| function. Rule-based algorithms are implemented by deriving from the
-|RuleTable| base class `[#367] <https://github.com/pymor/pymor/pull/367>`_,
+projection of an arbitrary `OperatorInterface` has been removed and replaced by
+a free |project| function. Rule-based algorithms are implemented by deriving
+from the |RuleTable| base class
+`[#367] <https://github.com/pymor/pymor/pull/367>`_,
 `[#408] <https://github.com/pymor/pymor/pull/408>`_.
 
 This approach has several advantages:
 
 - Rules can match based on the class of the object, but also on more general
-  conditions, e.g. the name of the |Operator| or being linear and
+  conditions, e.g. the name of the `OperatorInterface` or being linear and
   non-|parametric|.
 - The entire mathematical algorithm can be specified in a single file even when
   the definition of the possible classes the algorithm can be applied to is
   scattered over various files.
 - The precedence of rules is directly apparent from the definition of the
   |RuleTable|.
-- Generic rules (e.g. the projection of a linear non-|parametric| |Operator| by
-  simply applying the basis) can be easily scheduled to take precedence over
-  more specific rules.
+- Generic rules (e.g. the projection of a linear non-|parametric|
+  `OperatorInterface` by simply applying the basis) can be easily scheduled to
+  take precedence over more specific rules.
 - Users can implement or modify |RuleTables| without modification of the classes
   shipped with pyMOR.
 
 
 
 Additional new features
 ^^^^^^^^^^^^^^^^^^^^^^^
 
 - Reduction algorithms are now implemented using mutable reductor objects, e.g.
-  :class:`~pymor.reductors.basic.GenericRBReductor`, which store and
-  :meth:`extend <pymor.reductors.basic.GenericRBReductor.extend_basis>` the
+  :class:`!GenericRBReductor`, which store and
+  :meth:`!extend (extend_basis)` the
   reduced bases onto which the model is projected. The only return value of the
-  reductor's :meth:`~pymor.reductors.basic.GenericRBReductor.reduce` method is
+  reductor's :meth:`!reduce` method is
   now the reduced discretization. Instead of a separate reconstructor, the
-  reductor's :meth:`~pymor.reductors.basic.GenericRBReductor.reconstruct` method
+  reductor's :meth:`!reconstruct` method
   can be used to reconstruct a high-dimensional state-space representation.
   Additional reduction data (e.g. used to speed up repeated reductions in greedy
   algorithms) is now managed by the reductor
   `[#375] <https://github.com/pymor/pymor/pull/375>`_.
 
-- Linear combinations and concatenations of |Operators| can now easily be formed
-  using arithmetic operators `[#421] <https://github.com/pymor/pymor/pull/421>`_.
+- Linear combinations and concatenations of `OperatorInterfaces` can now easily
+  be formed using arithmetic operators
+  `[#421] <https://github.com/pymor/pymor/pull/421>`_.
 
 - The handling of complex numbers in pyMOR is now more consistent. See
   `[#458] <https://github.com/pymor/pymor/pull/459>`_,
   `[#362] <https://github.com/pymor/pymor/pull/362>`_,
   `[#447] <https://github.com/pymor/pymor/pull/447>`_
-  for details. As a consequence of these changes, the `rhs` |Operator| in
-  `StationaryDiscretization` is now a vector-like |Operator| instead of a functional.
+  for details. As a consequence of these changes, the `rhs` `OperatorInterface`
+  in `StationaryDiscretization` is now a vector-like `OperatorInterface` instead
+  of a functional.
 
 - The analytical problems and discretizers of pyMOR's discretization toolbox
   have been reorganized and improved. All problems are now implemented as
   instances of |StationaryProblem| or |InstationaryProblem|, which allows an
   easy exchange of data |Functions| of a predefined problem with user-defined
   |Functions|. Affine decomposition of |Functions| is now represented by
-  specifying a :class:`~pymor.functions.basic.LincombFunction` as the respective
+  specifying a :class:`!LincombFunction` as the respective
   data function
   `[#312] <https://github.com/pymor/pymor/pull/312>`_,
   `[#316] <https://github.com/pymor/pymor/pull/316>`_,
   `[#318] <https://github.com/pymor/pymor/pull/318>`_,
   `[#337] <https://github.com/pymor/pymor/pull/337>`_.
 
 - The :mod:`pymor.core.config` module allows simple run-time checking of the
@@ -267,15 +269,15 @@
 - The identifiers `discretization`, `rb_discretization`, `ei_discretization`
   have been replaced by `d`, `rd`, `ei_d` throughout pyMOR
   `[#416] <https://github.com/pymor/pymor/pull/416>`_.
 
 - The `_matrix` attribute of |NumpyMatrixOperator| has been renamed to `matrix`
   `[#436] <https://github.com/pymor/pymor/pull/436>`_. If `matrix` holds a
   |NumPy array| this array is automatically made read-only to prevent accidental
-  modification of the |Operator| `[#462] <https://github.com/pymor/pymor/pull/462>`_.
+  modification of the `OperatorInterface` `[#462] <https://github.com/pymor/pymor/pull/462>`_.
 
 - The `BoundaryType` class has been removed in favor of simple strings `[#305]
   <https://github.com/pymor/pymor/pull/305>`_.
 
 - The complicated and unused mapping of local parameter component names to
   global names has been removed `[#306] <https://github.com/pymor/pymor/pull/306>`_.
 
@@ -305,13 +307,13 @@
 - `[#425] [ParameterType] base implementation on OrderedDict <https://github.com/pymor/pymor/pull/425>`_.
 - `[#431] [operators.cg] fix first order integration <https://github.com/pymor/pymor/pull/431>`_.
 - `[#437] [LincombOperator] implement 'apply_inverse' <https://github.com/pymor/pymor/pull/437>`_.
 - `[#438] Fix VectorArrayOperator, generalize as_range/source_array <https://github.com/pymor/pymor/pull/438>`_.
 - `[#441] fix #439 (assemble_lincomb "operators" parameter sometimes list, sometimes tuple) <https://github.com/pymor/pymor/pull/441>`_.
 - `[#452] Several improvements to pymor.algorithms.ei.deim <https://github.com/pymor/pymor/pull/452>`_.
 - `[#453] Extend test_assemble <https://github.com/pymor/pymor/pull/453>`_.
-- `[#480| [operators] Improve subtraction of LincombOperators <https://github.com/pymor/pymor/pull/480>`_.
+- `[#480] [operators] Improve subtraction of LincombOperators <https://github.com/pymor/pymor/pull/480>`_.
 - `[#481] [project] ensure solver_options are removed from projected operators <https://github.com/pymor/pymor/pull/481>`_.
 - `[#484] [docs] move all references to bibliography.rst <https://github.com/pymor/pymor/pull/484>`_.
 - `[#488] [operators.block] add BlockRowOperator, BlockColumnOperator <https://github.com/pymor/pymor/pull/488>`_.
 - `[#489] Output functionals in CG discretizations <https://github.com/pymor/pymor/pull/489>`_.
 - `[#497] Support automatic conversion of InstationaryDiscretization to LTISystem <https://github.com/pymor/pymor/pull/497>`_.
```

### Comparing `pymor-2022.2.1/docs/source/release_notes/2019.2.rst` & `pymor-2023.1.0/docs/source/release_notes/2019.2.rst`

 * *Files 9% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-
 pyMOR 2019.2 (December 16, 2019)
 --------------------------------
 We are proud to announce the release of pyMOR 2019.2! For this release we have
 worked hard to make implementing new models and reduction algorithms with pyMOR
 even easier. Further highlights of this release are an extended VectorArray
 interface with generic support for complex numbers, vastly extended and
 improved system-theoretic MOR methods, as well as builtin support for model
@@ -20,106 +19,106 @@
 ^^^^^^^^^^^^^^^^^^
 
 Implement new models and reductors more easily
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 As many users have been struggling with the notion of `Discretization` in pyMOR
 and to account for the fact that not every full-order model needs to be a discretized
 PDE model, we have decided to rename `DiscretizationInterface` to
-:class:`~pymor.models.interfaces.ModelInterface` and all deriving classes accordingly
+`ModelInterface` and all deriving classes accordingly
 `[#568] <https://github.com/pymor/pymor/pull/568>`_. Consequently, the variable names
 `m`, `rom`, `fom` will now be found throughout pyMOR's code to refer to an arbitrary
-|Model|, a reduced-order |Model| or a full-order |Model|.
+`ModelInterface`, a reduced-order `ModelInterface` or a full-order `ModelInterface`.
 
 Moreover, following the `Zen of Python's <https://www.python.org/dev/peps/pep-0020/>`_
 'Explicit is better than implicit' and 'Simple is better than complex', we have
-completely revamped the implementation of |Models| and :mod:`~pymor.reductors`
+completely revamped the implementation of `ModelInterfaces` and :mod:`~pymor.reductors`
 to facilitate the implementation of new model types and reduction methods
 `[#592] <https://github.com/pymor/pymor/pull/592>`_. In particular, the complicated
-and error-prone approach of trying to automatically correctly project the |Operators|
-of any given |Model| in `GenericRBReductor` and `GenericPGReductor` has been replaced
-by simple |Model|-adapted reductors which explicitly state with which bases each
-|Operator| shall be projected. As a consequence, we could remove the `operators` dict
-and the notion of `special_operators` in :class:`~pymor.models.basic.ModelBase`,
-vastly simplifying its implementation and the definition of new |Model| classes.
+and error-prone approach of trying to automatically correctly project the `OperatorInterfaces`
+of any given `ModelInterface` in `GenericRBReductor` and `GenericPGReductor` has been replaced
+by simple `ModelInterface`-adapted reductors which explicitly state with which bases each
+`OperatorInterface` shall be projected. As a consequence, we could remove the `operators` dict
+and the notion of `special_operators` in :class:`!ModelBase`,
+vastly simplifying its implementation and the definition of new `ModelInterface` classes.
 
 
 Extended VectorArray interface with generic complex number support
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-The :class:`~pymor.vectorarrays.interfaces.VectorArrayInterface` has been extended to
+The :class:`!VectorArrayInterface` has been extended to
 allow the creation of non-zero vectors using the
-:meth:`~pymor.vectorarrays.interfaces.VectorArrayInterface.ones` and
-:meth:`~pymor.vectorarrays.interfaces.VectorArrayInterface.full` methods
+:meth:`!ones` and
+:meth:`!full` methods
 `[#612] <https://github.com/pymor/pymor/pull/612>`_. Vectors with random values can
-be created using the :meth:`~pymor.vectorarrays.interfaces.VectorArrayInterface.random`
-method `[#618] <https://github.com/pymor/pymor/pull/618>`_. All |VectorArray|
+be created using the :meth:`!random`
+method `[#618] <https://github.com/pymor/pymor/pull/618>`_. All `VectorArrayInterface`
 implementations shipped with pyMOR support these new interface methods.
 As an important step to improve the support for system-theoretic MOR methods with
 external PDE solvers, we have implemented facilities to provide generic support
-for complex-valued |VectorArrays| even for PDE solvers that do not support complex
+for complex-valued `VectorArrayInterfaces` even for PDE solvers that do not support complex
 vectors natively `[#755] <https://github.com/pymor/pymor/pull/755>`_.
 
 
 Improved and extended support for system-theoretic MOR methods
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 To increase compatibility between input-output models in
 :mod:`~pymor.models.iosys` and the |InstationaryModel|, support for models with
 parametric operators has been added
 `[#626] <https://github.com/pymor/pymor/pull/626>`_, which also enables
 implementation of parametric MOR methods for such models.
 Furthermore, the `state_space` attribute was removed in favor of
 `solution_space` `[#648] <https://github.com/pymor/pymor/pull/648>`_ to make
 more explicit the result of the
-:meth:`~pymor.models.interfaces.ModelInterface.solve` method.
+:meth:`!solve` method.
 Further improvements in naming has been renaming attributes `n`, `m`, and `p` to
 `order`, `input_dim`, and `output_dim`
 `[#578] <https://github.com/pymor/pymor/pull/578>`_ and the `bode` method to
-:meth:`~pymor.models.iosys.InputOutputModel.freq_resp`
+:meth:`!freq_resp`
 `[#729] <https://github.com/pymor/pymor/pull/729>`_.
 Reductors in :mod:`~pymor.reductors.bt` and :mod:`~pymor.reductors.h2` received
 numerous improvements (`[#656] <https://github.com/pymor/pymor/pull/656>`_,
 `[#661] <https://github.com/pymor/pymor/pull/661>`_,
 `[#807] <https://github.com/pymor/pymor/pull/807>`_) and variants of one-sided
 IRKA have been added `[#579] <https://github.com/pymor/pymor/pull/579>`_.
 As for Lyapunov equations, a low-rank solver for Riccati equations has been
 added `[#736] <https://github.com/pymor/pymor/pull/736>`_.
 
 
 Model outputs and parameter sensitivities
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-The notion of a |Model|'s output has been formally added to the
-:class:`~pymor.models.interfaces.ModelInterface` `[#750] <https://github.com/pymor/pymor/pull/750>`_:
-The output of a |Model| is defined to be a |VectorArray| of the model's
-:attr:`~pymor.models.interfaces.ModelInterface.output_space` |VectorSpace| and
-can be computed using the new :meth:`~pymor.models.interfaces.ModelInterface.output` method.
-Alternatively, :meth:`~pymor.models.interfaces.ModelInterface.solve` method can
+The notion of a `ModelInterface`'s output has been formally added to the
+`ModelInterface` `[#750] <https://github.com/pymor/pymor/pull/750>`_:
+The output of a `ModelInterface` is defined to be a `VectorArrayInterface` of the model's
+:attr:`!output_space` `VectorSpaceInterface` and
+can be computed using the new :meth:`!output` method.
+Alternatively, :meth:`!solve` method can
 now be called with `return_output=True` to return the output alongside the state space
 solution.
 
 To compute parameter sensitivities, we have added `d_mu` methods to
-:meth:`OperatorInterface <pymor.operators.interfaces.OperatorInterface.d_mu>` and
-:meth:`ParameterFunctionalInterface <pymor.parameters.interfaces.ParameterFunctionalInterface.d_mu>`
+`OperatorInterface` and
+`ParameterFunctionalInterface`
 which return the partial derivative with respect to a given parameter component
 `[#748] <https://github.com/pymor/pymor/pull/748>`_.
 
 
 Additional new features
 ^^^^^^^^^^^^^^^^^^^^^^^
 
 Extended FEniCS bindings
 ~~~~~~~~~~~~~~~~~~~~~~~~
-FEniCS support has been improved by adding support for nonlinear |Operators| including
-an implementation of :meth:`~pymor.operators.interfaces.OperatorInterface.restricted`
+FEniCS support has been improved by adding support for nonlinear `OperatorInterfaces` including
+an implementation of :meth:`!restricted`
 to enable fast local evaluation of the operator for efficient
 :class:`empirical interpolation <pymor.operators.ei.EmpiricalInterpolatedOperator>`
 `[#819] <https://github.com/pymor/pymor/pull/819>`_. Moreover the parallel implementations
-of :meth:`~pymor.vectorarrays.interfaces.VectorArrayInterface.amax` and
-:meth:`~pymor.vectorarrays.interfaces.VectorArrayInterface.dofs` have been fixed
+of :meth:`!amax` and
+:meth:`!dofs` have been fixed
 `[#616] <https://github.com/pymor/pymor/pull/616>`_ and
-:attr:`~pymor.operators.interfaces.OperatorInterface.solver_options` are now correctly
-handled in :meth:`~pymor.operators.interfaces.OperatorInterface._assemble_lincomb`
+:attr:`!solver_options` are now correctly
+handled in :meth:`!_assemble_lincomb`
 `[#812] <https://github.com/pymor/pymor/pull/812>`_.
 
 
 
 Improved greedy algorithms
 ~~~~~~~~~~~~~~~~~~~~~~~~~~
 pyMOR's greedy algorithms have been refactored into :func:`~pymor.algorithms.greedy.weak_greedy`
@@ -129,71 +128,71 @@
 used more flexible, e.g. for goal-oriented basis generation, by implementing a new
 :class:`~pymor.algorithms.greedy.WeakGreedySurrogate` `[#757] <https://github.com/pymor/pymor/pull/757>`_.
 
 
 Numerical linear algebra algorithms
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 By specifying `return_R=True`, the :func:`~pymor.algorithms.gram_schmidt.gram_schmidt`
-algorithm can now also be used to compute a QR decomposition of a given |VectorArray|
+algorithm can now also be used to compute a QR decomposition of a given `VectorArrayInterface`
 `[#577] <https://github.com/pymor/pymor/pull/577>`_. Moreover,
 :func:`~pymor.algorithms.gram_schmidt.gram_schmidt` can be used as a more accurate
 (but often more expensive) alternative for computing the :func:`~pymor.algorithms.pod.pod` of
-a |Vectorarray|. Both, the older method-of-snapshots approach as well as the QR decomposition
-are now available for computing a truncated SVD of a |VectorArray| via the newly added
+a `VectorarrayInterface`. Both, the older method-of-snapshots approach as well as the QR decomposition
+are now available for computing a truncated SVD of a `VectorArrayInterface` via the newly added
 :mod:`~pymor.algorithms.svd_va` module `[#718] <https://github.com/pymor/pymor/pull/718>`_.
-Basic randomized algorithms for approximating the image of a linear |Operator| are
-implemented in the :mod:`~pymor.algorithms.randrangefinder` module
+Basic randomized algorithms for approximating the image of a linear `OperatorInterface` are
+implemented in the :mod:`!randrangefinder` module
 `[#665] <https://github.com/pymor/pymor/pull/665>`_.
 
 
 Support for low-rank operators
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-Low-rank |Operators| and as well as sums of arbitrary |Operators| with a low-rank
-|Operator| can now be represented by :class:`~pymor.operators.constructions.LowRankOperator`
+Low-rank `OperatorInterfaces` and as well as sums of arbitrary `OperatorInterfaces` with a low-rank
+`OperatorInterface` can now be represented by :class:`~pymor.operators.constructions.LowRankOperator`
 and :class:`~pymor.operators.constructions.LowRankUpdatedOperator`. For the latter,
-:meth:`~pymor.operators.interfaces.OperatorInterface.apply_inverse` and
-:meth:`~pymor.operators.interfaces.OperatorInterface.apply_inverse_adjoint` are implemented
+:meth:`!apply_inverse` and
+:meth:`!apply_inverse_adjoint` are implemented
 via the Sherman-Morrison-Woodbury formula `[#743] <https://github.com/pymor/pymor/pull/743>`_.
 
 
 Improved string representations of pyMOR objects
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-Custom  `__str__` special methods have been implemented for all |Model| classes shipped with
+Custom  `__str__` special methods have been implemented for all `ModelInterface` classes shipped with
 pyMOR `[#652] <https://github.com/pymor/pymor/pull/652>`_. Moreover, we have added a generic
 `__repr__` implementation to `BasicInterface` which recursively prints all class attributes
 corresponding to an `__init__` argument (with a non-default value)
 `[#706] <https://github.com/pymor/pymor/pull/706>`_.
 
 
 Easier working with immutable objects
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-A new check in :class:`~pymor.core.interfaces.ImmutableMeta` enforces all `__init__` arguments
+A new check in :class:`!ImmutableMeta` enforces all `__init__` arguments
 of an |immutable| object to be available as object attributes, thus ensuring that
-`~pymor.core.interfaces.ImmutableInterface.with_` works reliably with all |immutable| objects
+:meth:`!with_` works reliably with all |immutable| objects
 in pyMOR `[#694] <https://github.com/pymor/pymor/pull/694>`_. To facilitate the initialization
 of these attributes in `__init__` the
 `__auto_init <https://github.com/pymor/pymor/pull/732/files#diff-9ff4f0e773ee7352ff323cb88a3adeabR149-R164>`_
 method has been added to `BasicInterface` `[#732] <https://github.com/pymor/pymor/pull/732>`_.
-Finally, `~pymor.core.interfaces.ImmutableInterface.with_` now has a `new_type` parameter
+Finally, :meth:`!with_` now has a `new_type` parameter
 which allows to change the class of the object returned by it
 `[#705] <https://github.com/pymor/pymor/pull/705>`_.
 
 
 project and assemble_lincomb are easier to extend
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 In pyMOR 0.5, we have introduced |RuleTables| to make central algorithms in
-pyMOR, like the projection of an |Operator| via |project|, easier to trace and
+pyMOR, like the projection of an `OperatorInterface` via |project|, easier to trace and
 extend.
 For pyMOR 2019.2, we have further simplified |project| by removing the `product`
 argument from the underlying |RuleTable| `[#785] <https://github.com/pymor/pymor/pull/785>`_.
 As the inheritance-based implementation of `assemble_lincomb` was showing similar
 complexity issues as the old inheritance-based implementation of `projected`, we
 moved all backend-agnostic logic into the |RuleTable|-based free function
 :func:`~pymor.algorithms.lincomb.assemble_lincomb`, leaving the remaining backend
-code in :meth:`~pymor.operators.interfaces.OperatorInterface._assemble_lincomb`
+code in :meth:`!_assemble_lincomb`
 `[#619] <https://github.com/pymor/pymor/pull/619>`_.
 
 
 Improvements to pyMOR's discretization toolbox
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 pyMOR's builtin discretization toolbox as seen multiple minor improvements:
 
@@ -215,27 +214,27 @@
 preservation `[#553] <https://github.com/pymor/pymor/pull/553>`_,
 `[#584] <https://github.com/pymor/pymor/pull/553>`_.
 
 
 Global RandomState
 ~~~~~~~~~~~~~~~~~~
 pyMOR now has a (mutable) global default :class:`~numpy.random.RandomState`. This means
-that when :meth:`~pymor.parameters.spaces.CubicParameterSpace.sample_randomly` is called
+that when :meth:`!sample_randomly` is called
 repeatedly without specifying a `random_state` or `seed` argument, different |Parameter|
 samples will be returned in contrast to the (surprising) previous behavior where the
 same samples would have been returned. The same :class:`~numpy.random.RandomState` is
-used by the newly introduced :meth:`~pymor.vectorarrays.interfaces.VectorArrayInterface.random`
-method of the :class:`~pymor.vectorarrays.interfaces.VectorArrayInterface`
+used by the newly introduced :meth:`!random`
+method of the `VectorArrayInterface`
 `[#620] <https://github.com/pymor/pymor/pull/620>`_.
 
 
 Space id handling
 ~~~~~~~~~~~~~~~~~
-The usage of |VectorSpace| :attr:`ids <pymor.vectorarrays.interfaces.VectorSpace.id>` in pyMOR
-has been reduced throughout pyMOR to avoid unwanted errors due to incompatible |VectorSpaces|
+The usage of `VectorSpaceInterface` :attr:`!ids` in pyMOR
+has been reduced throughout pyMOR to avoid unwanted errors due to incompatible `VectorSpaceInterfaces`
 (that only differ by their id):
 
 - `[#611] [models.iosys] remove space id handling except for factory methods <https://github.com/pymor/pymor/pull/611>`_
 - `[#613] Remove VectorSpace id handling from projection methods <https://github.com/pymor/pymor/pull/613>`_
 - `[#614] Remove id from BlockVectorSpace <https://github.com/pymor/pymor/pull/614>`_
 - `[#615] Remove 'space' parameter from as_vector <https://github.com/pymor/pymor/pull/615>`_
```

### Comparing `pymor-2022.2.1/docs/source/release_notes/2020.1.rst` & `pymor-2023.1.0/docs/source/release_notes/2020.1.rst`

 * *Files 1% similar despite different names*

```diff
@@ -1,9 +1,7 @@
-
-
 pyMOR 2020.1 (July 23, 2020)
 ----------------------------
 We are proud to announce the release of pyMOR 2020.1! Highlights of this release
 are support for non-intrusive model order reduction using artificial neural networks,
 the subspace accelerated dominant pole algorithm (SAMDP) and the implicitly restarted
 Arnoldi method for eigenvalue computation. Parameter handling in pyMOR has been
 simplified, and a new series of hands-on tutorials helps getting started using pyMOR
@@ -34,15 +32,15 @@
 the neural networks. No knowledge of PyTorch or neural networks is required to apply the method.
 
 
 New system analysis and linear algebra algorithms
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 The new :meth:`~pymor.algorithms.eigs.eigs` method
 `[#880] <https://github.com/pymor/pymor/pull/880>`_ computes
-smallest/largest eigenvalues of an arbitary linear real |Operator|
+smallest/largest eigenvalues of an arbitrary linear real |Operator|
 using the implicitly restarted Arnoldi method :cite:`RL95`. It can also
 be used to solve generalized eigenvalue problems.
 
 So far, computing poles of an |LTIModel| was only supported by its
 :meth:`~pymor.models.iosys.LTIModel.poles` method, which uses a dense eigenvalue
 solver and converts the operators to dense matrices.
 The new :meth:`~pymor.algorithms.samdp.samdp` method
@@ -210,11 +208,11 @@
 
 Further notable improvements
 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 - `[#885] Implement VectorArrayOperator.apply_inverse <https://github.com/pymor/pymor/pull/885>`_
 - `[#888] Implement FenicsVectorSpace.from_numpy <https://github.com/pymor/pymor/pull/888>`_
 - `[#895] Implement VectorArray.__deepcopy__ via VectorArray.copy(deep=True) <https://github.com/pymor/pymor/pull/895>`_
 - `[#905] Add from_files method to SecondOrderModel <https://github.com/pymor/pymor/pull/905>`_
-- `[#919] [reductors.coercive] remove unneccessary initialization in SimpleCoerciveReductor <https://github.com/pymor/pymor/pull/919>`_
+- `[#919] [reductors.coercive] remove unnecessary initialization in SimpleCoerciveReductor <https://github.com/pymor/pymor/pull/919>`_
 - `[#926] [Operators] Speed up apply methods for LincombOperator <https://github.com/pymor/pymor/pull/926>`_
 - `[#937] Move NumpyListVectorArrayMatrixOperator out of the playground <https://github.com/pymor/pymor/pull/937>`_
 - `[#943] [logger] adds a ctx manager that restores effective level on exit <https://github.com/pymor/pymor/pull/943>`_
```

### Comparing `pymor-2022.2.1/docs/source/release_notes/2020.2.rst` & `pymor-2023.1.0/docs/source/release_notes/2020.2.rst`

 * *Files 4% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-
 pyMOR 2020.2 (December 10, 2020)
 --------------------------------
 We are proud to announce the release of pyMOR 2020.2! This release extends pyMOR's
 support for non-intrusive model reduction via artificial neural networks to
 non-stationary models. Built-in support for computing parameter sensitivities
 simplifies the use of pyMOR in PDE-constrained optimization applications.
 pyMOR's documentation has been extended by three new tutorials, and all tutorial
@@ -25,15 +24,15 @@
 PDE-constrained parameter optimization were added. These include parameter derivatives
 of the solutions and the output of a |Model|. In particular,
 :meth:`~pymor.models.interface.Model.solve_d_mu` can now be used to compute partial
 parameter derivatives. Moreover, :meth:`~pymor.models.interface.Model.output_d_mu`
 can be used to compute the parameter gradient of the output using the
 derivatives of the solutions. Alternatively, for a |StationaryModel| and a linear output, an
 adjoint variable can be used to speed up the computation of the gradient
-(see :meth:`~pymor.models.basic.StationaryModel._compute_output_d_mu`).
+(see :meth:`!_compute_output_d_mu`).
 
 
 Neural network reductor for non-stationary problems
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 A reductor based on neural networks which deals with non-stationary problems was
 added in `[#1120] <https://github.com/pymor/pymor/pull/1120>`_. The implementation is an
 extension of the already existing approach for stationary problems in pyMOR.
@@ -75,18 +74,18 @@
 
 
 Additional new features
 ^^^^^^^^^^^^^^^^^^^^^^^
 
 Bode plot for input-output systems
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-The :meth:`~pymor.models.iosys.InputOutputModel.bode_plot` method for creating a
+The :meth:`!bode_plot` method for creating a
 Bode plot was added `[#1051] <https://github.com/pymor/pymor/pull/1051>`_,
-complementing the :meth:`~pymor.models.iosys.InputOutputModel.mag_plot` method.
-Additionally, the :meth:`~pymor.models.iosys.InputOutputModel.bode` method can
+complementing the :meth:`!mag_plot` method.
+Additionally, the :meth:`!bode` method can
 be used to compute the magnitudes and phases over the imaginary axis (for
 continuous-time systems).
 
 
 Iterable VectorArrays
 ~~~~~~~~~~~~~~~~~~~~~
 |VectorArrays| became iterable sequences with
@@ -126,24 +125,24 @@
 relevant data that can be gathered from the simulation of a |Model|
 `[#1113] <https://github.com/pymor/pymor/pull/1113>`_.
 Existing interface methods such as :meth:`pymor.models.interface.Model.solve` or
 or :meth:`pymor.models.interface.Model.output` now act as convenience frontends for
 :meth:`~pymor.models.interface.Model.compute`.
 Existing custom |Models| have to be adapted to the new architecture.
 
-The `estimate` method has been renamed to :meth:`~pymor.model.interface.Model.estimate_error`
+The `estimate` method has been renamed to :meth:`~pymor.models.interface.Model.estimate_error`
 `[#1041] <https://github.com/pymor/pymor/pull/1041>`_.
 The old method is deprecated and will be removed in the next release.
 
 Further, to simplify interoperability with third-party packages,
-the model outputs, i.e., the results of :meth:`~pymor.models.interface.output`,
+the model outputs, i.e., the results of :meth:`~pymor.models.interface.Model.output`,
 are no longer generic |VectorArrays|, but NumPy arrays.
 For consistency, `input_space` and `output_space` were removed and
 `input_dim` and `output_dim` were renamed to `dim_input` and `dim_output`
-in :class:`~pymor.models.iosys.InputOutputModel`
+in :class:`!InputOutputModel`
 `[#1089] <https://github.com/pymor/pymor/pull/1089>`_.
 
 
 
 Changes in methods for inner products and norms of VectorArrays
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 At first, |VectorArrays| only had `dot` and `pairwise_dot` methods for computing
```

### Comparing `pymor-2022.2.1/docs/source/release_notes/2021.1.rst` & `pymor-2023.1.0/docs/source/release_notes/2021.1.rst`

 * *Files 0% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-
 pyMOR 2021.1 (September 24, 2021)
 ---------------------------------
 We are proud to announce the release of pyMOR 2021.1! This release includes
 several new reductors for LTI systems. In particular, methods for reducing and
 analyzing unstable systems have been added. ANNs can now be used in order to
 directly approximate output quantities. Furthermore, it is now possible to
 work with time-dependent parameters in pyMOR.
```

### Comparing `pymor-2022.2.1/docs/source/release_notes/2021.2.rst` & `pymor-2023.1.0/docs/source/release_notes/2021.2.rst`

 * *Files 0% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-
 pyMOR 2021.2 (December 22, 2021)
 --------------------------------
 We are proud to announce the release of pyMOR 2021.2! New features in
 this release are the addition of Dynamic Mode Decomposition for data-driven
 model order reduction and the formalization of model inputs. Further,
 general output error bounds for Reduced Basis reductors and experimental
 scikit-fem support as an alternative to the builtin discretizers were
```

### Comparing `pymor-2022.2.1/docs/source/release_notes/2022.1.rst` & `pymor-2023.1.0/docs/source/release_notes/2022.1.rst`

 * *Files 0% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-
 pyMOR 2022.1 (July 21, 2022)
 ----------------------------
 
 We are proud to announce the release of pyMOR 2022.1!
 pyMOR now comes with support for discrete-time systems
 and structure-preserving MOR for symplectic systems.
 The neural network based reductors gained many new features,
```

### Comparing `pymor-2022.2.1/docs/source/release_notes/2022.2.rst` & `pymor-2023.1.0/docs/source/release_notes/2022.2.rst`

 * *Files identical despite different names*

### Comparing `pymor-2022.2.1/docs/source/substitutions.py` & `pymor-2023.1.0/docs/source/substitutions.py`

 * *Files 2% similar despite different names*

```diff
@@ -75,15 +75,15 @@
 
 .. |ExpressionParameterFunctional| replace:: :class:`~pymor.parameters.functionals.ExpressionParameterFunctional`
 .. |ExpressionParameterFunctionals| replace:: :class:`ExpressionParameterFunctionals <pymor.parameters.functionals.ExpressionParameterFunctional>`
 
 .. |OnedGrid| replace:: :class:`~pymor.discretizers.builtin.grids.oned.OnedGrid`
 .. |RectGrid| replace:: :class:`~pymor.discretizers.builtin.grids.rect.RectGrid`
 .. |TriaGrid| replace:: :class:`~pymor.discretizers.builtin.grids.tria.TriaGrid`
-.. |GmshGrid| replace:: :class:`~pymor.discretizers.builtin.grids.gmsh.GmshGrid`
+.. |UnstructuredTriangleGrid| replace:: :class:`~pymor.discretizers.builtin.grids.unstructured.UnstructuredTriangleGrid`
 
 .. |NumpyVectorArray| replace:: :class:`~pymor.vectorarrays.numpy.NumpyVectorArray`
 .. |NumpyVectorArrays| replace:: :class:`NumpyVectorArrays <pymor.vectorarrays.numpy.NumpyVectorArray>`
 .. |ListVectorArray| replace:: :class:`~pymor.vectorarrays.list.ListVectorArray`
 .. |ListVectorArrays| replace:: :class:`ListVectorArrays <pymor.vectorarrays.list.ListVectorArray>`
 
 .. |NumpyHankelOperator| replace:: :class:`~pymor.operators.numpy.NumpyHankelOperator`
@@ -113,15 +113,15 @@
 .. |TransferFunction| replace:: :class:`~pymor.models.transfer_function.TransferFunction`
 .. |TransferFunctions| replace:: :class:`TransferFunctions <pymor.models.transfer_function.TransferFunction>`
 .. |SecondOrderModel| replace:: :class:`~pymor.models.iosys.SecondOrderModel`
 .. |SecondOrderModels| replace:: :class:`SecondOrderModels <pymor.models.iosys.SecondOrderModel>`
 .. |LinearDelayModel| replace:: :class:`~pymor.models.iosys.LinearDelayModel`
 .. |LinearDelayModels| replace:: :class:`LinearDelayModels <pymor.models.iosys.LinearDelayModel>`
 .. |NeuralNetworkModel| replace:: :class:`~pymor.models.neural_network.NeuralNetworkModel`
-.. |QuadraticHamiltonianModel| replace:: :class:`~pymor.model.symplectic.QuadraticHamiltonianModel`
+.. |QuadraticHamiltonianModel| replace:: :class:`~pymor.models.symplectic.QuadraticHamiltonianModel`
 
 .. |MoebiusTransformation| replace:: :class:`~pymor.models.transforms.MoebiusTransformation`
 .. |MoebiusTransformations| replace:: :class:`MoebiusTransformations <pymor.models.transforms.MoebiusTransformation>`
 .. |BilinearTransformation| replace:: :class:`~pymor.models.transforms.BilinearTransformation`
 .. |CayleyTransformation| replace:: :class:`~pymor.models.transforms.CayleyTransformation`
 
 .. |Parameter| replace:: :class:`Parameter <pymor.parameters.base.Parameters>`
```

### Comparing `pymor-2022.2.1/docs/source/technical_overview.rst` & `pymor-2023.1.0/docs/source/technical_overview.rst`

 * *Files 2% similar despite different names*

```diff
@@ -61,21 +61,20 @@
     .. |appended|         replace:: :meth:`appended <pymor.vectorarrays.interface.VectorArray.append>`
     .. |axpy|             replace:: :meth:`~pymor.vectorarrays.interface.VectorArray.axpy`
     .. |dofs|             replace:: :meth:`~pymor.vectorarrays.interface.VectorArray.dofs`
     .. |copied|           replace:: :meth:`copied <pymor.vectorarrays.interface.VectorArray.copy>`
     .. |dimension|        replace:: :attr:`dimension <pymor.vectorarrays.interface.VectorArray.dim>`
     .. |empty|            replace:: :meth:`~pymor.vectorarrays.interface.VectorSpace.empty`
     .. |id|               replace:: :meth:`~pymor.vectorarrays.interface.VectorSpace.id`
-    .. |indexed|          replace:: :meth:`indexed <pymor.vectorarrays.interface.VectorArray.__getitem__>`
+    .. |indexed|          replace:: :meth:`!indexed`
     .. |inner products|   replace:: :meth:`inner products <pymor.vectorarrays.interface.VectorArray.inner>`
     .. |lincomb|          replace:: :meth:`~pymor.vectorarrays.interface.VectorArray.lincomb`
     .. |make_array|       replace:: :meth:`~pymor.vectorarrays.interface.VectorSpace.make_array`
-    .. |removed|          replace:: :meth:`deleted <pymor.vectorarrays.interface.VectorArray.__delitem__>`
+    .. |removed|          replace:: :meth:`!deleted`
     .. |scaled|           replace:: :meth:`scaled <pymor.vectorarrays.interface.VectorArray.scal>`
-    .. |subtype|          replace:: :attr:`~pymor.vectorarrays.interface.VectorSpace.subtype`
     .. |zeros|            replace:: :meth:`~pymor.vectorarrays.interface.VectorSpace.zeros`
 
 |Operators|
     The main property of operators in pyMOR is that they can be |applied| to
     |VectorArrays| resulting in a new |VectorArray|. For this operation to be
     allowed, the operator's |source| |VectorSpace| must be identical with the
     |VectorSpace| of the given array. The result will be a vector array from
@@ -111,19 +110,19 @@
     .. |as_vector|         replace:: :meth:`~pymor.operators.interface.Operator.as_vector`
     .. |linear|            replace:: :attr:`~pymor.operators.interface.Operator.linear`
     .. |range|             replace:: :attr:`~pymor.operators.interface.Operator.range`
     .. |source|            replace:: :attr:`~pymor.operators.interface.Operator.source`
 
 |Models|
     Models in pyMOR encode the mathematical structure of a given
-    discrete problem by acting as container classes for operators. Each
-    model object has |operators|, |products| dictionaries holding the
-    |Operators| which appear in the formulation of the discrete problem. The
-    keys in these dictionaries describe the role of the respective operator
-    in the discrete problem.
+    discrete problem by acting as container classes for |Operators|. Each
+    model object has |Operators| and the |products| dictionary of |Operators|
+    which appear in the formulation of the discrete problem. The keys in the
+    |products| dictionary describe the role of the respective product in the
+    discrete problem.
 
     Apart from describing the discrete problem, models also implement
     algorithms for |solving| the given problem, returning |VectorArrays|
     from the |solution_space|. The solution can be |cached|, s.t.
     subsequent solving of the problem for the same |parameter values| reduces
     to looking up the solution in pyMOR's cache.
 
@@ -138,22 +137,19 @@
 
     Models can also implement |estimate| and |visualize| methods to
     estimate the discretization or model reduction error of a computed solution
     and create graphic representations of |VectorArrays| from the
     |solution_space|.
 
     .. |cached|           replace:: :mod:`cached <pymor.core.cache>`
-    .. |estimate|         replace:: :meth:`~pymor.models.interface.Model.estimate`
-    .. |functionals|      replace:: :attr:`~pymor.models.interface.Model.functionals`
-    .. |operators|        replace:: :attr:`~pymor.models.interface.Model.operators`
+    .. |estimate|         replace:: :meth:`~pymor.models.interface.Model.estimate_error`
     .. |products|         replace:: :attr:`~pymor.models.interface.Model.products`
     .. |solution_space|   replace:: :attr:`~pymor.models.interface.Model.solution_space`
     .. |solve|            replace:: :meth:`~pymor.models.interface.Model.solve`
     .. |solving|          replace:: :meth:`solving <pymor.models.interface.Model.solve>`
-    .. |vector_operators| replace:: :attr:`~pymor.models.interface.Model.vector_operators`
     .. |visualize|        replace:: :meth:`~pymor.models.interface.Model.visualize`
 
 
 Base Classes
 ------------
 
 While |VectorArrays| are mutable objects, both |Operators| and |Models|
@@ -183,15 +179,15 @@
 easily achieved using the
 :meth:`~pymor.core.base.ImmutableObject.with_` method every immutable
 object has: a call of the form ``o.with_(a=x, b=y)`` will return a copy of `o`
 in which the attribute `a` now has the value `x` and the attribute `b` the
 value `y`. It can be generally assumed that calls to
 :meth:`~pymor.core.base.ImmutableObject.with_` are inexpensive. The
 set of allowed arguments can be found in the
-:attr:`~pymor.core.base.ImmutableObject.with_arguments` attribute.
+:attr:`!_init_arguments` attribute.
 
 All immutable classes in pyMOR and most other classes derive from
 |BasicObject| which, through its meta class, provides several convenience
 features for pyMOR. Most notably, every subclass of |BasicObject| obtains its
 own :attr:`~pymor.core.base.BasicObject.logger` instance with a class
 specific prefix.
 
@@ -266,15 +262,15 @@
 In particular, it ensures, that all of its values are one-dimensional |NumPy arrays|.
 
 The |Parameters| of a |ParametricObject| are usually automatically derived
 as the union of all |Parameters| of the objects that are passed to it's `__init__` method.
 For instance, an |Operator| that implements the L2-product with some user-provided
 |Function| will automatically inherit all |Parameters| of that |Function|.
 Additional |Parameters| can be easily added by setting the
-:attr:`~pymor.parameters.ParametricObject.parameters_own` attribute.
+:attr:`!parameters_own` attribute.
 
 
 Defaults
 --------
 
 pyMOR offers a convenient mechanism for handling default values such as solver
 tolerances, cache sizes, log levels, etc. Each default in pyMOR is the default
@@ -359,18 +355,18 @@
 difference lies in the different types of operators, the |Model|
 contains.
 
 This observation is particularly apparent in the case of the classical
 reduced basis method: the operators and functionals of a given discrete problem
 are projected onto the reduced basis space whereas the structure of the problem
 (i.e. the type of |Model| containing the operators) stays the same.
-pyMOR reflects this fact by offering with :class:`~pymor.reductors.basic.GenericRBReductor`
+pyMOR reflects this fact by offering with :class:`!GenericRBReductor`
 a generic algorithm which can be used to RB-project any model available to pyMOR.
 It should be noted however that this reductor is only able to efficiently
 offline/online-decompose affinely |Parameter|-dependent linear problems.
 Non-linear problems or such with no affine |Parameter| dependence require
 additional techniques such as :mod:`empirical interpolation <pymor.algorithms.ei>`.
 
 If you want to further dive into the inner workings of pyMOR, we
-recommend to study the source code of :class:`~pymor.reductors.basic.GenericRBReductor`
+recommend to study the source code of :class:`!GenericRBReductor`
 and to step through calls of it's `reduce` method with a Python debugger, such as
 `ipdb <https://pypi.python.org/pypi/ipdb>`_.
```

### Comparing `pymor-2022.2.1/docs/source/try_on_binder.py` & `pymor-2023.1.0/docs/source/try_on_binder.py`

 * *Files 10% similar despite different names*

```diff
@@ -15,39 +15,43 @@
         app = env.app
         slug = app.config.try_on_binder_slug
         source = Path(self.state.document.attributes['source'])
         generated_nb = f'{source.stem}.ipynb'
         node = binder_link_node()
         # this is somewhat confusing, but the docs repository's branches are named after the
         # directories which are slugs to avoid slashes and such
-        node['target'] = f'https://mybinder.org/v2/gh/pymor/docs/{slug}?filepath={generated_nb}'
-        node['badge'] = 'https://mybinder.org/badge_logo.svg'
+        node['target'] = f'https://binderhub.uni-muenster.de/v2/gh/pymor/docs/{slug}?filepath={generated_nb}'
+        node['badge'] = 'https://binderhub.uni-muenster.de/badge_logo.svg'
+
+        # node['target'] = f'https://mybinder.org/v2/gh/pymor/docs/{slug}?filepath={generated_nb}'
+        # node['badge'] = 'https://mybinder.org/badge_logo.svg'
+
         return [node]
 
 
 def html_visit_binder_link_node(self, node):
-    html = f'''
+    html = f"""
 <div class="admonition">
 <p class="admonition-title">Run this tutorial</p>
-    <a href=\"{node['target']}\">Click here</a> to run this tutorial on mybinder.org: <a href=\"{node['target']}\">
-        <img src=\"{node['badge']}\" alt=\"try on mybinder.org\">
+    <a href=\"{node['target']}\">Click here</a> to run this tutorial on binder: <a href=\"{node['target']}\">
+        <img src=\"{node['badge']}\" alt=\"try on binder\">
     </a><br/>
     <emph>Please note that starting the notebook server may take a couple of minutes.</emph>
 </div>
-    '''
+    """
     self.body.append(html)
     raise nodes.SkipNode
 
 
 def setup(app):
     # since don't want to replicate the slugify rules form gitlab we need to accept two params here
     app.add_config_value('try_on_binder_branch', 'main', 'html')
     app.add_config_value('try_on_binder_slug', 'main', 'html')
     app.add_node(binder_link_node,
                  html=(html_visit_binder_link_node, None))
-    app.add_directive("try_on_binder", TryOnBinder)
+    app.add_directive('try_on_binder', TryOnBinder)
 
     return {
         'version': '0.1',
         'parallel_read_safe': True,
         'parallel_write_safe': True,
     }
```

### Comparing `pymor-2022.2.1/docs/source/tutorial_basis_generation.md` & `pymor-2023.1.0/docs/source/tutorial_basis_generation.md`

 * *Files 3% similar despite different names*

```diff
@@ -23,19 +23,15 @@
 ```{code-cell}
 :load: myst_code_init.py
 :tags: [remove-cell]
 
 
 ```
 
-Tutorial: Building a Reduced Basis
-==================================
-
-
-
+# Tutorial: Building a Reduced Basis
 
 In this tutorial we will learn more about {{ VectorArrays }} and how to
 construct a reduced basis using pyMOR.
 
 A reduced basis spans a low dimensional subspace of a {{ Model }}'s
 {attr}`~pymor.models.interface.Model.solution_space`, in which the
 {meth}`solutions <pymor.models.interface.Model.solve>` of the {{ Model }}
@@ -93,17 +89,15 @@
 ```{math}
 d_N(\mathcal{M}) \leq C \cdot e^{-N^c}.
 ```
 
 In this tutorial we will construct reduced spaces {math}`V_N` for a concrete problem
 with pyMOR and study their error decay.
 
-
-Model setup
------------
+## Model setup
 
 First we need to define a {{ Model }} and a {{ ParameterSpace }} for which we want
 to build a reduced basis. We choose here the standard
 {meth}`thermal block <pymor.analyticalproblems.thermalblock.thermal_block_problem>` benchmark
 problem shipped with pyMOR (see {doc}`getting_started`). However, any pyMOR
 {{ Model }} can be used, except for Section [Weak Greedy Algorithm](#weak-greedy-algorithm) where
 some more assumptions have to be made on the {{ Model }}.
@@ -112,15 +106,15 @@
 
 ```{code-cell}
 import numpy as np
 from pymor.basic import *
 ```
 
 Then we build a 3-by-2 thermalblock problem that we discretize using pyMOR's
-{mod}`builtin discretizers <pymor.discretizers.builtin>` (see
+{mod}`built-in discretizers <pymor.discretizers.builtin>` (see
 {doc}`tutorial_builtin_discretizer` for an introduction to pyMOR's discretization toolkit).
 
 ```{code-cell}
 problem = thermal_block_problem((3,2))
 fom, _ = discretize_stationary_cg(problem, diameter=1/100)
 ```
 
@@ -146,17 +140,15 @@
 of lower and upper bounds per parameter.
 
 The main use of {{ ParameterSpaces }} in pyMOR is that they allow to easily sample
 {{ parameter_values }} from their domain using the methods
 {meth}`~pymor.parameters.base.ParameterSpace.sample_uniformly` and
 {meth}`~pymor.parameters.base.ParameterSpace.sample_randomly`.
 
-
-Computing the snapshot data
----------------------------
+## Computing the snapshot data
 
 Reduced basis methods are snapshot-based, which means that they build
 the reduced space as a linear subspace of the linear span of solutions
 of the `fom` for certain {{ parameter_values }}. The easiest
 approach is to just pick these values randomly, what we will do in the
 following. First we define a training set of 25 parameters:
 
@@ -193,15 +185,15 @@
 
 ```{code-cell}
 fom.solution_space
 ```
 
 which means that the created {{ VectorArrays }} will internally hold
 {{ NumPy_arrays }} for data storage. The number is the dimension of the
-vector. We have here a {{ NumpyVectorSpace }} because pyMOR's builtin
+vector. We have here a {{ NumpyVectorSpace }} because pyMOR's built-in
 discretizations are built around the NumPy/SciPy stack. If `fom` would
 represent a {{ Model }} living in an external PDE solver, we would have
 a different type of {{ VectorSpace }} which, for instance, might hold a
 reference to a discrete functions space object inside the PDE solver
 instead of the dimension.
 
 After appending all solutions vectors to `training_data`, we can verify that
@@ -220,16 +212,15 @@
 A {{ VectorArray }} containing multiple vectors is visualized as a
 time series:
 
 ```{code-cell}
 fom.visualize(training_data)
 ```
 
-A trivial reduced basis
------------------------
+## A trivial reduced basis
 
 Given some snapshot data, the easiest option to get a reduced basis
 is to just use the snapshot vectors as the basis:
 
 ```{code-cell}
 trivial_basis = training_data.copy()
 ```
@@ -285,16 +276,16 @@
 
 ```{code-cell}
 U = fom.solve(parameter_space.sample_randomly())
 ```
 
 The matrix {math}`G` of all inner products between vectors in `trivial_basis`
 is a so called [Gramian matrix](<https://en.wikipedia.org/wiki/Gramian_matrix>).
-Consequently, every {{ VectorArray }} has a {meth}`~pymor.vectorarrays.interface.VectorArray.gramian` method, which computes precisely
-this matrix:
+Consequently, every {{ VectorArray }} has a {meth}`~pymor.vectorarrays.interface.VectorArray.gramian`
+method, which computes precisely this matrix:
 
 ```{code-cell}
 G = trivial_basis.gramian()
 ```
 
 The Gramian is computed w.r.t. the Euclidean inner product. For the
 right-hand side {math}`R`, we need to compute all (Euclidean) inner
@@ -363,15 +354,15 @@
 ```
 
 ```{note}
 The `0` in `h1_0_semi_product` refers to the fact that rows and columns of
 Dirichlet boundary DOFs have been cleared in the matrix of the Operator to
 make it invertible. This is important for being able to compute Riesz
 representatives w.r.t. this inner product (required for a posteriori
-estimation of the ROM error). If you want to compute the H1 semi-norm of a
+estimation of the ROM error). If you want to compute the {math}`H^1` semi-norm of a
 function that does not vanish at the Dirichlet boundary, use
 `fom.h1_semi_product`.
 ```
 
 To use `fom.h1_0_semi_product` as an inner product {{ Operator }} for computing the
 projection error, we can simply pass it as the optional `product` argument to
 {meth}`~pymor.vectorarrays.interface.VectorArray.gramian` and
@@ -440,17 +431,15 @@
 The error drops to zero at the end as the basis contains all vectors it
 needs to approximate.
 
 We can do better, however. If we want to use a smaller basis than we
 have snapshots available, just picking the first of these obviously
 won't be optimal.
 
-
-Strong greedy algorithm
------------------------
+## Strong greedy algorithm
 
 The strong greedy algorithm iteratively builds reduced spaces
 {math}`V_N` with a small worst-case best approximation error on a
 training set of solution snapshots by adding, in each iteration, the
 currently worst-approximated snapshot vector to the basis of {math}`V_N`.
 
 We can easily implement it as follows:
@@ -497,17 +486,15 @@
 Indeed, the strong greedy algorithm constructs better bases than the
 trivial basis construction algorithm. For compact training sets
 contained in a Hilbert space, it can actually be shown that the greedy
 algorithm constructs quasi-optimal spaces in the sense that polynomial
 or exponential decay of the N-widths {math}`d_N` yields similar rates
 for the worst-case best-approximation errors of the constructed {math}`V_N`.
 
-
-Orthonormalization required
----------------------------
+## Orthonormalization required
 
 There is one technical problem with both algorithms however: the
 condition numbers of the Gramians used to compute the projection
 onto {math}`V_N` explode:
 
 ```{code-cell}
 G_trivial = trivial_basis.gramian(fom.h1_0_semi_product)
@@ -577,16 +564,15 @@
 plt.semilogy(trivial_errors, label='trivial')
 plt.semilogy(greedy_errors, label='greedy')
 plt.ylim(1e-5, 1e1)
 plt.legend()
 plt.show()
 ```
 
-Proper Orthogonal Decomposition
--------------------------------
+## Proper Orthogonal Decomposition
 
 Another popular method to create a reduced basis out of snapshot data is the so-called
 Proper Orthogonal Decomposition (POD) which can be seen as a non-centered version of
 Principal Component Analysis (PCA). First we build a snapshot matrix
 
 ```{math}
 A :=
@@ -693,17 +679,15 @@
 fom.visualize(pod_basis)
 ```
 
 As you can see, the first (more important) basis vectors account for the approximation of
 the solutions in the bulk of the subdomains, whereas the higher modes are responsible for
 approximating the solutions at the subdomain interfaces.
 
-
-Weak greedy algorithm
----------------------
+## Weak greedy algorithm
 
 Both POD and the strong greedy algorithm require the computation of all
 {meth}`solutions <pymor.models.interface.Model.solve>` {math}`u(\mu)`
 for all {{ parameter_values }} {math}`\mu` in the `training_set`. So it is
 clear right from the start that we cannot afford very large training sets.
 Otherwise we would not be interested in model order reduction
 in the first place. This is a problem when the number of |parameters|
@@ -833,11 +817,10 @@
 plt.ylim(1e-2, 5e1)
 plt.legend()
 plt.show()
 ```
 
 Indeed we see that the weak-greedy basis generalizes to the validation data much better than all the other bases.
 
-
 Download the code:
 {download}`tutorial_basis_generation.md`
 {nb-download}`tutorial_basis_generation.ipynb`
```

### Comparing `pymor-2022.2.1/docs/source/tutorial_bt.md` & `pymor-2023.1.0/docs/source/tutorial_bt.md`

 * *Files 1% similar despite different names*

```diff
@@ -25,15 +25,14 @@
 :tags: [remove-cell]
 
 
 ```
 
 # Tutorial: Reducing an LTI system using balanced truncation
 
-
 Here we briefly describe the balanced truncation method,
 for asymptotically stable LTI systems with an invertible {math}`E` matrix,
 and demonstrate it on the heat equation example from
 {doc}`tutorial_lti_systems`.
 First, we import necessary packages, including
 {class}`~pymor.reductors.bt.BTReductor`.
```

### Comparing `pymor-2022.2.1/docs/source/tutorial_external_solver.md` & `pymor-2023.1.0/docs/source/tutorial_external_solver.md`

 * *Files 2% similar despite different names*

```diff
@@ -139,18 +139,18 @@
 
 ```{literalinclude} minimal_cpp_demo/model.cc
 :lines: 66-68
 :language: cpp
 
 ```
 
-Again we define a `py:class\_` with appropiate name and docstring, but now we also indicate to pybind11
+Again we define a `py:class\_` with appropriate name and docstring, but now we also indicate to pybind11
 that this class will implement the [buffer protocol](<https://docs.python.org/3/c-api/buffer.html>), which basically
-exposes direct access to the chunk of memory associated with a `Vector` instance to Python. We also see how we can dispatch multiple init functions
-by using `py:init` objects with C++ lambda functions.
+exposes direct access to the chunk of memory associated with a `Vector` instance to Python.
+We also see how we can dispatch multiple init functions by using `py:init` objects with C++ lambda functions.
 Note that direct memory access to the vector data from Python is not required to integrate a solver with pyMOR.
 It is, however, useful for debugging and quickly modifying or extending the solver from within Python. For instance,
 in our toy example we will use the direct memory access to quickly define a visualization of the solutions and to
 construct the right-hand side vector for our problem.
 
 ```{literalinclude} minimal_cpp_demo/model.cc
 :lines: 70-74
@@ -168,24 +168,24 @@
 
 This extension module needs to be compiled to a shared object that the Python interpreter can import.
 We use a minimal [CMake](<https://cmake.org/>) project that generates makefiles for us to achieve this.
 
 First we make sure pybind11 can be used:
 
 ```{literalinclude} minimal_cpp_demo/CMakeLists.txt
-:lines: 1-6
+:lines: 11-13
 :language: cmake
 
 ```
 
 Next, we define a new library with our `model.cc` as the single source file and let pybind11 set the proper compile
 flags.
 
 ```{literalinclude} minimal_cpp_demo/CMakeLists.txt
-:lines: 9-12
+:lines: 16-19
 :language: cmake
 
 ```
 
 That is all that is needed for {download}`CMakeLists.txt <minimal_cpp_demo/CMakeLists.txt>`.
 In the next step, we will switch to a bash terminal and actually compile this module.
 
@@ -213,29 +213,30 @@
 myvector = model.Vector(10, 0)
 mymodel.apply(myvector, myvector)
 dir(model)
 ```
 
 ## Using the exported Python classes with pyMOR
 
-All of pyMOR's algorithms operate on {{ VectorArray }} and {{ Operator }} objects that all share the same programming interface. To be able to use
+All of pyMOR's algorithms operate on {{ VectorArray }} and {{ Operator }} objects that all
+share the same programming interface. To be able to use
 our Python `model.Vector` and `model.DiffusionOperator` in pyMOR, we have to provide implementations of
 {{ VectorArray }}, {{ VectorSpace }} and {{ Operator }} that wrap the classes defined in the extension module
 and translate calls to the interface methods into operations on `model.Vector` and `model.DiffusionOperator`.
 
-Instead of writing a full implementaion of a {{ VectorArray }} that manages multiple `model.Vector`
+Instead of writing a full implementation of a {{ VectorArray }} that manages multiple `model.Vector`
 instances, we can instead implement a wrapper `WrappedVector` for a single `model.Vector` instance based on
 {class}`~pymor.vectorarrays.list.CopyOnWriteVector` which will be used to create
 {{ ListVectorArrays }} via a {class}`~pymor.vectorarrays.list.ListVectorSpace`-based `WrappedVectorSpace`.
 
 The {class}`~pymor.vectorarrays.list.CopyOnWriteVector` base class manages a reference count for
 us and automatically copies data when necessary in methods {meth}`~pymor.vectorarrays.list.CopyOnWriteVector.scal`
 and {meth}`~pymor.vectorarrays.list.CopyOnWriteVector.axpy`. To use this, we need to implement
-{meth}`~pymor.vectorarrays.list.CopyOnWriteVector._scal`
-and {meth}`~pymor.vectorarrays.list.CopyOnWriteVector._axpy` in addition to all the abstract
+{meth}`!_scal`
+and {meth}`!_axpy` in addition to all the abstract
 methods from  {class}`~pymor.vectorarrays.list.CopyOnWriteVector`. We can get away
 with using just a stub that raises an {class}`~NotImplementedError` in some methods that are not actually called in our example.
 
 ```{code-cell}
 from pymor.operators.interface import Operator
 from pymor.vectorarrays.list import CopyOnWriteVector, ListVectorSpace
```

### Comparing `pymor-2022.2.1/docs/source/tutorial_lti_systems.md` & `pymor-2023.1.0/docs/source/tutorial_lti_systems.md`

 * *Files 1% similar despite different names*

```diff
@@ -327,14 +327,25 @@
 is in subplot {math}`(2 i, j)`.
 
 ```{code-cell}
 fig, axs = plt.subplots(6, 2, figsize=(8, 10), sharex=True, constrained_layout=True)
 _ = fom.transfer_function.bode_plot(w, ax=axs)
 ```
 
+To restrict which inputs and outputs are plotted by `bode_plot`,
+its parameters `input_indices` and `output_indices` can be used.
+The following restricts the plot to the second input {math}`u_2` and the first output {math}`y_1`.
+
+```{code-cell}
+fig, axs = plt.subplots(2, 1, figsize=(8, 10), sharex=True, constrained_layout=True)
+_ = fom.transfer_function.bode_plot(w, ax=axs, input_indices=[1], output_indices=[0])
+```
+
+Note the change in the `axs` shape compared to the first call to `bode_plot`.
+
 ## System poles
 
 The poles of an LTI system are the poles of its transfer function.
 From the form of the transfer function
 it follows that the poles are eigenvalues of {math}`E^{-1} A`,
 assuming that {math}`E` is invertible.
 Conversely, the eigenvalues of {math}`E^{-1} A` are the poles of the system
```

### Comparing `pymor-2022.2.1/docs/source/tutorial_mor_with_anns.md` & `pymor-2023.1.0/docs/source/tutorial_mor_with_anns.md`

 * *Files 2% similar despite different names*

```diff
@@ -65,15 +65,15 @@
 other inputs and non-linearly transformed. These steps are repeated in several
 layers.
 
 The following figure shows a simple example of a neural network with two hidden
 layers, an input size of two and an output size of three. Each edge between
 neurons has a corresponding weight that is learnable in the training phase.
 
-```{image} neural_network.png
+```{image} neural_network.svg
 :alt: Feedforward neural network
 :width: 100%
 ```
 
 To train the neural network, one considers a so-called "loss function", that
 measures how the neural network performs on the training set {math}`S`, i.e.
 how accurately the neural network reproduces the output {math}`h(\mu_i)` given
@@ -103,15 +103,15 @@
 {math}`\mu \in (0.1, 1)` denotes the parameter. Further, we apply the
 Dirichlet boundary conditions
 
 ```{math}
 u((x_1, x_2), \mu) = 2x_1\mu + 0.5,\quad x=(x_1, x_2) \in \partial\Omega.
 ```
 
-We discretize the problem using pyMOR's builtin discretization toolkit as
+We discretize the problem using pyMOR's built-in discretization toolkit as
 explained in {doc}`tutorial_builtin_discretizer`:
 
 ```{code-cell}
 from pymor.basic import *
 
 problem = StationaryProblem(
       domain=RectDomain(),
@@ -413,35 +413,37 @@
 So-called *recurrent neural networks* are especially well-suited for capturing time-dependent
 dynamics. These types of neural networks can treat input sequences of variable length (in our case
 sequences with a variable number of time steps) and store internal states that are passed from one
 time step to the next. Therefore, these networks implement an internal memory that keeps
 information over time. Furthermore, for each element of the input sequence, the same neural
 network is applied.
 
-In the {class}`~pymor.models.neural_network.NeuralNetworkLSTMInstationaryModel` and the
-corresponding {class}`~pymor.reductors.neural_network.NeuralNetworkLSTMInstationaryReductor`,
+In the {class}`~pymor.models.neural_network.NeuralNetworkInstationaryModel` obtained by the
+{class}`~pymor.reductors.neural_network.NeuralNetworkLSTMInstationaryReductor`,
 we make use of a specific type of recurrent neural network, namely a so-called
 *long short-term memory neural network (LSTM)*, first introduced in {cite}`HS97`, that tries to
 avoid problems like vanishing or exploding gradients that often occur during training of recurrent
 neural networks.
 
 #### The architecture of an LSTM neural network
+
 In an LSTM neural network, multiple so-called LSTM cells are chained with each other such that the
 cell state {math}`c_k` and the hidden state {math}`h_k` of the {math}`k`-th LSTM cell serve as the
 input hidden states for the {math}`k+1`-th LSTM cell. Therefore, information from former time
 steps can be available later. Each LSTM cell takes an input {math}`\mu(t_k)` and produces an
 output {math}`o(t_k)`. The following figure shows the general structure of an LSTM neural network
 that is also implemented in the same way in pyMOR:
 
 ```{image} lstm.svg
 :alt: Long short-term neural network
 :width: 100%
 ```
 
 #### The LSTM cell
+
 The main building block of an LSTM network is the *LSTM cell*, which is denoted by {math}`\Phi`,
 and sketched in the following figure:
 
 ```{image} lstm_cell.svg
 :alt: LSTM cell
 :align: left
 ```
@@ -463,77 +465,80 @@
 {math}`(c_{k-1},h_{k-1},\mu(t_k))` and transforms them into new hidden states and an output state
 of the form {math}`(c_k,h_k,o(t_k))`.
 
 We will take a closer look at the individual components of an LSTM cell in the subsequent
 paragraphs.
 
 ##### The forget gate
+
 ```{image} lstm_cell_forget_gate.svg
 :alt: Forget gate of an LSTM cell
 :align: right
 ```
+
 As the name already suggests, the *forget gate* determines which part of the cell state
 {math}`c_{k-1}` the network forgets when moving to the next cell state {math}`c_k`. The main
 component of the forget gate is a neural network layer consisting of an affine-linear function
 with adjustable weights and biases followed by a sigmoid nonlinearity. By applying the sigmoid
 activation function, the output of the layer is scaled to lie between 0 and 1. The cell state
 {math}`c_{k-1}` from the previous cell is (point-wise) multiplied by the output of the layer in
 the forget gate. Hence, small values in the output of the layer correspond to parts of the cell
 state that are diminished, while values near 1 mean that the corresponding parts of the cell
 state remain intact. As input of the forget gate serves the pair {math}`(h_{k-1},\mu(t_k))` and
 in the second step also the cell state {math}`c_{k-1}`.
 
 ##### The input gate
+
 ```{image} lstm_cell_input_gate.svg
 :alt: Input gate of an LSTM cell
 :align: right
 ```
+
 To further change the cell state, an LSTM cell contains a so-called *input gate*. This gate mainly
 consists of two layers, a sigmoid layer and an hyperbolic tangent layer, acting on the pair
 {math}`(h_{k-1},\mu(t_k))`. As in the forget gate, the sigmoid layer determines which parts of the
 cell state to adjust. On the other hand, the hyperbolic tangent layer determines how to adjust the
 cell state. Using the hyperbolic tangent as activation function scales the output to be between -1
 and 1, and allows for small updates of the cell state. To finally compute the update, the outputs
 of the sigmoid and the hyperbolic tangent layer are multiplied entry-wise. Afterwards, the update
 is added to the cell state (after the cell state passed the forget gate). The new cell state is
 now prepared to be passed to the subsequent LSTM cell.
 
 ##### The output gate
+
 ```{image} lstm_cell_output_gate.svg
 :alt: Output gate of an LSTM cell
 :align: right
 ```
+
 For computing the output {math}`o(t_k)` (and the new hidden state {math}`h_k`), the updated cell
 state {math}`c_k` is first of all entry-wise transformed using a hyperbolic tangent function such
 that the result again takes values between -1 and 1. Simultaneously, a neural network layer with a
 sigmoid activation function is applied to the concatenated pair {math}`(h_{k-1},\mu(t_k))` of
 hidden state and input. Both results are multiplied entry-wise. This results in a filtered version
 of the (normalized) cell state. Finally, a projection layer is applied such that the result of the
 output gate has the desired size and can take arbitrary real values (before, due to the sigmoid and
 hyperbolic tangent activation functions, the outcome was restricted to the interval from -1 to 1).
 The projection layer applies a linear function without an activation (similar to the last layer of
 a usual feedforward neural network but without bias). Altogether, the *output gate* produces an
 output {math}`o(t_k)` that is returned and a new hidden state {math}`h_k` that can be passed
 (together with the updated cell state {math}`c_k`) to the next LSTM cell.
 
 #### LSTMs for model order reduction
+
 The idea of the approach implemented in pyMOR is the following: Instead of passing the current
 time instance as an additional input of the neural network, we use an LSTM that takes at each time
 instance {math}`t_k` the (potentially) time-dependent input {math}`\mu(t_k)` as an input and uses
 the hidden states of the former time step. The output {math}`o(t_k)` of the LSTM (and therefore
 also the hidden state {math}`h_k`) at time {math}`t_k` are either approximations of the reduced
 basis coefficients (similar to the
 {class}`~pymor.models.neural_network.NeuralNetworkInstationaryModel`) or approximations of the
 output quantities (similar to the
 {class}`~pymor.models.neural_network.NeuralNetworkInstationaryModel`). For state approximations
 using a reduced basis, one can apply the
-{class}`~pymor.reductors.neural_network.NeuralNetworkLSTMInstationaryReductor` and use the
-corresponding
-{class}`~pymor.models.neural_network.NeuralNetworkLSTMInstationaryModel`.
+{class}`~pymor.reductors.neural_network.NeuralNetworkLSTMInstationaryReductor`.
 For a direct approximation of outputs using LSTMs, we provide the
-{class}`~pymor.models.neural_network.NeuralNetworkLSTMInstationaryStatefreeOutputModel` and the
-corresponding
 {class}`~pymor.reductors.neural_network.NeuralNetworkLSTMInstationaryStatefreeOutputReductor`.
 
 Download the code:
 {download}`tutorial_mor_with_anns.md`
 {nb-download}`tutorial_mor_with_anns.ipynb`
```

### Comparing `pymor-2022.2.1/docs/source/tutorial_optimization.md` & `pymor-2023.1.0/docs/source/tutorial_optimization.md`

 * *Files 1% similar despite different names*

```diff
@@ -53,15 +53,15 @@
 The equation {math}`\eqref{eq:primal}` is called the primal
 equation and can be arbitrarily complex. MOR methods in the context of
 PDE-constrained optimization problems thus aim to find a surrogate model
 of {math}`\eqref{eq:primal}` to reduce the computational costs of
 an evaluation of {math}`J(u_{\mu}, \mu)`.
 
 If there exists a unique solution {math}`u_{\mu}` for all
-{math}`\mu \in \mathcal{P}`, we can rewrite (P) by using the so-called
+{math}`\mu \in \mathcal{P}`, we can rewrite ({math}`\textrm{P}`) by using the so-called
 reduced objective functional {math}`\mathcal{J}(\mu):= J(u_{\mu}, \mu)`
 leading to the equivalent problem: Find a solution of
 
 ```{math}
 \min_{\mu \in \mathcal{P}} \mathcal{J}(\mu).  \tag{$\hat{P}$}
 ```
 
@@ -277,15 +277,15 @@
         data['offline_time'] = offline_time
     if enrichments:
         data['enrichments'] = 0
     return data
 
 def record_results(function, data, adaptive_enrichment=False, opt_dict=None, mu=None):
     if adaptive_enrichment:
-        # this is for the adaptive case! rom is shiped via the opt_dict argument.
+        # this is for the adaptive case! rom is shipped via the opt_dict argument.
         assert opt_dict is not None
         QoI, data, rom = function(mu, data, opt_dict)
         opt_dict['opt_rom'] = rom
     else:
         QoI = function(mu)
     data['num_evals'] += 1
     data['evaluation_points'].append(mu)
@@ -542,15 +542,15 @@
 using the solution of the dual problem, we can then derive the gradient of the objective
 functional by
 
 ```{math}
 \begin{align}
 d_{\mu_i} \mathcal{J}(\mu) &= \partial_{\mu_i} J(u_{\mu}, \mu) + \partial_u J(u_{\mu}, \mu)[d_{\mu_i} u_{\mu}] \\
    &=   \partial_{\mu_i} J(u_{\mu}, \mu) + a_\mu(d_{\mu_i} u_{\mu}, p_\mu) \\
-   &=   \partial_{\mu_i} J(u_{\mu}, \mu) + \partial_{\mu_i} r_\mu^{\text{pr}}(d_{\mu_i} u_{\mu})[p_\mu]
+   &=   \partial_{\mu_i} J(u_{\mu}, \mu) + \partial_{\mu_i} r_\mu^{\text{pr}}(u_{\mu})[p_\mu]
 \end{align}
 ```
 
 We conclude that we only need to solve for {math}`u_{\mu}` and
 {math}`p_{\mu}` if we want to compute the gradient with the adjoint
 approach. For more information on this approach we refer to Section 1.6.2 in {cite}`HPUU09`.
 
@@ -764,15 +764,15 @@
 report(opt_along_path_result, opt_along_path_minimization_data, reference_mu)
 
 print('\nAdaptively enrich along the path')
 report(opt_along_path_adaptively_result, opt_along_path_adaptively_minimization_data, reference_mu)
 ```
 
 ```{code-cell}
-:tags: [hide-code, hide-output]
+:tags: [remove-cell]
 
 assert fom_result.nit == 7
 assert opt_along_path_result.nit == 7
 assert opt_along_path_minimization_data['num_evals'] == 9
 assert opt_along_path_minimization_data['enrichments'] == 9
 assert opt_along_path_adaptively_minimization_data['enrichments'] == 4
 ```
@@ -800,13 +800,17 @@
 For faster and more robust optimization algorithms we refer to the textbooks
 [CGT00](<https://epubs.siam.org/doi/book/10.1137/1.9780898719857>) and
 [NW06](<https://link.springer.com/book/10.1007/978-0-387-40065-5>).
 For recent research on combining trust-region methods with model reduction for
 PDE-constrained optimization problems we refer to
 [YM13](<https://epubs.siam.org/doi/abs/10.1137/120869171>),
 [QGVW17](<https://epubs.siam.org/doi/abs/10.1137/16M1081981>) and
-[KMSOV20](<https://arxiv.org/abs/2006.09297>) where for the latter a pyMOR
+[KMSOV20](<https://doi.org/10.1051/m2an/2021019>) where for the latter a pyMOR
 implementation is available as supplementary material.
 
+Update: The trust-region methods are by now implemented in pyMOR which is shown
+in the respective demo {mod}`~pymordemos.trust_region`. An update of this
+tutorial is work in progress.
+
 Download the code:
 {download}`tutorial_optimization.md`
 {nb-download}`tutorial_optimization.ipynb`
```

### Comparing `pymor-2022.2.1/docs/source/tutorial_projection.md` & `pymor-2023.1.0/docs/source/tutorial_projection.md`

 * *Files 2% similar despite different names*

```diff
@@ -115,17 +115,17 @@
 ```{code-cell}
 print_source(fom.compute)
 ```
 
 What we see is a default implementation from {class}`~pymor.models.interface.Model` that
 takes care of checking the input {{ parameter_values }} `mu`, {mod}`caching <pymor.core.cache>` and
 {mod}`logging <pymor.core.logger>`, but defers the actual computations to further private methods.
-Implementors can directly implement {meth}`~pymor.models.interface.Model._compute` to compute
+Implementors can directly implement {meth}`!_compute` to compute
 multiple return values at once in an optimized way. Our given model, however, just implements
-{meth}`~pymor.models.interface.Model._compute_solution` where we can find the
+{meth}`!_compute_solution` where we can find the
 actual code:
 
 ```{code-cell}
 print_source(fom._compute_solution)
 ```
 
 What does this mean? If we look at the type of `fom`,
@@ -139,25 +139,25 @@
 
 ```{math}
 L(u(\mu); \mu) = F(\mu)
 ```
 
 Here, {math}`L` is a linear or non-linear parametric {{ Operator }} and {math}`F` is a
 parametric right-hand side vector. In {{ StationaryModel }}, {math}`L` is represented by
-the {attr}`~pymor.models.basic.StationaryModel.operator` attribute. So
+the {attr}`!operator` attribute. So
 
 ```
 self.operator.apply_inverse(X, mu=mu)
 ```
 
 determines the solution of this equation for the {{ parameter_values }} `mu` and a right-hand
 side given by `X`. As you see above, the right-hand side of the equation is given by the
-{attr}`~pymor.models.basic.StationaryModel.rhs` attribute.
+{attr}`!rhs` attribute.
 However, while {meth}`~pymor.operators.interface.Operator.apply_inverse` expects a
-{{ VectorArray }},  we see that {attr}`~pymor.models.basic.StationaryModel.rhs` is actually
+{{ VectorArray }},  we see that {attr}`!rhs` is actually
 an {{ Operator }}:
 
 ```{code-cell}
 fom.rhs
 ```
 
 This is due to the fact that {{ VectorArrays }} in pyMOR cannot be parametric. So to allow
@@ -422,17 +422,17 @@
 ```{code-cell}
 fom.operator
 ```
 
 We see that `operator` is a {{ LincombOperator }}, a linear combination of {{ Operators }}
 with coefficients that may either be a number or a parameter-dependent number,
 called a {{ ParameterFunctional }} in pyMOR. In our case, all
-{attr}`~pymor.operators.constructions.LincombOperator.operators` are
+{attr}`!operators` are
 {{ NumpyMatrixOperators }}, which themselves don't depend on any parameter. Only the
-{attr}`~pymor.operators.constructions.LincombOperator.coefficients` are
+{attr}`!coefficients` are
 parameter-dependent.  This allows us to easily build a parametric ROM that no longer
 requires any high-dimensional operations for its solution by projecting each
 {{ Operator }} in the sum separately:
 
 ```{code-cell}
 reduced_operators = [NumpyMatrixOperator(op.apply2(basis, basis))
                      for op in fom.operator.operators]
@@ -562,21 +562,21 @@
 ProjectRules
 ```
 
 In the case of `fom.operator`, which is a {{ LincombOperator }}, the rule with index 8 will
 be the first matching rule. We can take a look at it:
 
 ```{code-cell}
-:tags: [hide-code, hide-output]
+:tags: [remove-cell]
 
-assert ProjectRules.rules[8].action_description == 'LincombOperator'
+assert ProjectRules.rules[7].action_description == 'LincombOperator'
 ```
 
 ```{code-cell}
-ProjectRules.rules[8]
+ProjectRules.rules[7]
 ```
 
 The implementation of the action for {{ LincombOperators }} uses the
 {meth}`~pymor.algorithms.rules.RuleTable.replace_children` method of {{ RuleTable }},
 which will recursively apply `ProjectionRules` to all
 {meth}`children <pymor.algorithms.rules.RuleTable.get_children>` of the
 {{ Operator }}, collect the results and then return a new {{ Operator }} where
@@ -586,21 +586,21 @@
 of {{ Operators }}.
 
 In our case, `ProjectRules` will be applied to all {{ NumpyMatrixOperators }} held by
 `fom.operator`. These are linear, non-parametric operators, for which rule 3
 will apply:
 
 ```{code-cell}
-:tags: [hide-code, hide-output]
+:tags: [remove-cell]
 
-assert ProjectRules.rules[3].action_description == 'apply_basis'
+assert ProjectRules.rules[2].action_description == 'apply_basis'
 ```
 
 ```{code-cell}
-ProjectRules.rules[3]
+ProjectRules.rules[2]
 ```
 
 This action has special cases for all possible combinations of given or not-given
 {attr}`~pymor.operators.interface.Operator.range` and {attr}`~pymor.operators.interface.Operator.source`
 bases. In our case, the `else` block of the second `else` block applies,
 where we see our familiar {meth}`~pymor.operators.interface.Operator.apply2` call.
 
@@ -631,20 +631,20 @@
 Again, we get the same ROM as before:
 
 ```{code-cell}
 u_N5 = rom.solve(mu)
 u_N.T - u_N5.to_numpy()
 ```
 
-As an additional feature, {meth}`~pymor.reductors.basic.StationaryRBReductor.reduce`
+As an additional feature, {meth}`!reduce`
 allows to project the model onto a smaller dimensional subspace of {math}`V_N` by
 extracting the ROM from a previously computed ROM for the full {math}`V_N`. This
 is useful, in particular, when assessing the ROM for different basis sizes. The
 actual projection is handled in the
-{meth}`~pymor.reductor.basic.StationaryRBReductor.project_operators` method,
+{meth}`!project_operators` method,
 where we can find some well-known code:
 
 ```{code-cell}
 print_source(reductor.project_operators)
 ```
 
 We see that the reductor also takes care of projecting output functionals and
@@ -657,15 +657,15 @@
 
 More advanced reductors, such as {class}`~pymor.reductors.coercive.CoerciveRBReductor`
 also assemble an a posteriori error estimator for the model order reduction error.
 In the case of {class}`~pymor.reductors.basic.StationaryRBReductor`, however,
 `error_estimator` is always `None`.
 
 Reductors also allow to compute {math}`U_N(\mu)` from {math}`u_N(\mu)` using
-the {meth}`~pymor.reductors.basic.StationaryRBReductor.reconstruct` method:
+the {meth}`!reconstruct` method:
 
 ```{code-cell}
 U_N5 = reductor.reconstruct(u_N5)
 (U_N - U_N5).norm()
 ```
 
 Again, if we look at the source code, we see a familiar expression:
```

### Comparing `pymor-2022.2.1/docs/source/tutorial_unstable_lti_systems.md` & `pymor-2023.1.0/docs/source/tutorial_unstable_lti_systems.md`

 * *Files 2% similar despite different names*

```diff
@@ -168,18 +168,18 @@
 {class}`~pymor.reductors.bt.FDBTReductor` internally calls
 `fom.get_ast_spectrum` using the `ast_pole_data` attribute, which can be a list
 of anti-stable eigenvalues (with or without corresponding eigenvectors) or
 specifying how eigenvalues should be computed (`None` for computing all
 eigenvalues using dense methods or arguments for pyMOR's iterative eigensolver
 like in the code above).
 
-Before we use the {meth}`~pymor.reductors.bt.FDBTReductor.reduce` method to
-obtain a reduced-order model, we take a look at some a priori error bounds for
-the reductor. In particular, we get a {math}`\mathcal{L}_\infty` rather than the
-{math}`\mathcal{H}_\infty` error bound from classic balanced truncation.
+Before we use the `reduce` method to obtain a reduced-order model, we take a
+look at some a priori error bounds for the reductor. In particular, we get a
+{math}`\mathcal{L}_\infty` rather than the {math}`\mathcal{H}_\infty` error
+bound from classic balanced truncation.
 
 ```{code-cell}
 error_bounds = fdbt.error_bounds()
 fig, ax = plt.subplots()
 ax.semilogy(range(1, len(error_bounds) + 1), error_bounds, '.-')
 ax.set_xlabel('Reduced order')
 _ = ax.set_title(r'$\mathcal{L}_\infty$ error bounds')
```

### Comparing `pymor-2022.2.1/docs/test_tutorials.py` & `pymor-2023.1.0/docs/test_tutorials.py`

 * *Files 10% similar despite different names*

```diff
@@ -13,26 +13,26 @@
 TUT_DIR = Path(os.path.dirname(__file__)).resolve().absolute()
 _exclude_files = []
 EXCLUDE = [TUT_DIR / t for t in _exclude_files]
 TUTORIALS = [t for t in TUT_DIR.glob('converted_tutorial_*ipynb') if t not in EXCLUDE]
 
 
 class NBLaxFixture(NBRegressionFixture):
-    """Same functionality as base class, but result comparison for regressions is skipped"""
+    """Same functionality as base class, but result comparison for regressions is skipped."""
 
     def check(self, path):
         return super().check(path=path, raise_errors=False)
 
 
-@pytest.fixture(scope="function")
+@pytest.fixture(scope='function')
 def nb_lax(pytestconfig):
     kwargs, other_args = gather_config_options(pytestconfig)
     return NBLaxFixture(**kwargs)
 
 
-@pytest.mark.parametrize("filename", TUTORIALS, ids=[t.name for t in TUTORIALS])
+@pytest.mark.parametrize('filename', TUTORIALS, ids=[t.name for t in TUTORIALS])
 def test_check(filename, nb_lax):
     nb_lax.check(filename)
 
 
-if __name__ == "__main__":
+if __name__ == '__main__':
     runmodule(filename=__file__)
```

### Comparing `pymor-2022.2.1/src/pymor/__init__.py` & `pymor-2023.1.0/src/pymor/__init__.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,65 +1,60 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
+__version__ = '2023.1.0'
+
 import os
 import platform
 import sys
 
-
 if sys.version_info.major < 3:
     raise RuntimeError('pyMOR requires Python 3.6 or newer')
 elif sys.version_info.major == 3:
     if sys.version_info.minor < 6:
         raise RuntimeError('pyMOR requires Python 3.6 or newer.')
     if sys.version_info.minor == 6 and platform.python_implementation() != 'CPython':
         # dicts are only guaranteed to be insertion ordered for Python 3.7 or newer.
         # For CPython this is already the case for Python 3.6.
         raise RuntimeError('pyMOR requires Python 3.7 or newer for non-CPython interpreters.')
 
 
 def _init_mpi():
-    """provides a way to manually set the thread init mode for MPI if necessary.
-    Needs to happen as early as possible, otherwise mpi4py might auto-init somewhere else.
-
+    """Provides a way to manually set the thread init mode for MPI if necessary.
 
+    Needs to happen as early as possible, otherwise mpi4py might auto-init somewhere else.
     """
-
     try:
         import mpi4py
     except ImportError:
         return
 
     finalize = os.environ.get('PYMOR_MPI_FINALIZE', mpi4py.rc.finalize if mpi4py.rc.finalize is not None else True)
     mpi4py.rc(initialize=False, finalize=finalize)
     from mpi4py import MPI
     if not MPI.Is_initialized():
         required_level = int(os.environ.get('PYMOR_MPI_INIT_THREAD', MPI.THREAD_MULTIPLE))
         supported_lvl = MPI.Init_thread(required_level)
         if supported_lvl < required_level:
-            print(f'MPI does support threading level {required_level}, running with {supported_lvl} instead', flush=True)
+            print(f'MPI does support threading level {required_level},\
+                   running with {supported_lvl} instead', flush=True)
 
     try:
         # this solves sporadic mpi calls happening after finalize
         import petsc4py
         petsc4py.init()
     except ImportError:
         return
 
 _init_mpi()
 
 from pymor.core.config import config
 from pymor.core.defaults import load_defaults_from_file
 
-
-import pymor.version as _version
-revstring = _version.get_versions()['version']
-__version__ = str(revstring)
-
 if 'PYMOR_DEFAULTS' in os.environ:
     filename = os.environ['PYMOR_DEFAULTS']
     if filename in ('', 'NONE'):
         print('Not loading any pyMOR defaults from config file')
     else:
         for fn in filename.split(':'):
             if not os.path.exists(fn):
@@ -72,19 +67,21 @@
         from pymor.tools.io import file_owned_by_current_user
         if not file_owned_by_current_user(filename):
             raise IOError('Cannot load pyMOR defaults from config file ' + filename
                           + ': not owned by user running Python interpreter')
         print('Loading pyMOR defaults from file ' + filename)
         load_defaults_from_file(filename)
 
-from pymor.core.logger import set_log_levels, set_log_format
+from pymor.core.logger import set_log_format, set_log_levels
+
 set_log_levels()
 set_log_format()
 
 from pymor.tools import mpi
+
 if mpi.parallel and mpi.event_loop_settings()['auto_launch']:
     if mpi.rank0:
         import atexit
         @atexit.register
         def quit_event_loop():
             if not mpi.finished:
                 mpi.quit()
```

### Comparing `pymor-2022.2.1/src/pymor/algorithms/adaptivegreedy.py` & `pymor-2023.1.0/src/pymor/algorithms/adaptivegreedy.py`

 * *Ordering differences only*

 * *Files 0% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
+import time
 from fractions import Fraction
 
 import numpy as np
-import time
 
 from pymor.algorithms.greedy import RBSurrogate
 from pymor.core.base import BasicObject
 from pymor.core.exceptions import ExtensionError
 from pymor.core.logger import getLogger
 from pymor.parallel.dummy import dummy_pool
 from pymor.parameters.base import Mu, ParameterSpace
@@ -138,16 +138,16 @@
                 # select elements
                 sorted_indicators_inds = np.argsort(indicators)[::-1]
                 refinement_elements = sorted_indicators_inds[:max(int(len(sorted_indicators_inds) * theta), 1)]
                 logger.info(f'Refining {len(refinement_elements)} elements: {refinement_elements}')
 
                 # visualization
                 if visualize:
-                    from mpl_toolkits.mplot3d import Axes3D  # NOQA
                     import matplotlib.pyplot as plt
+                    from mpl_toolkits.mplot3d import Axes3D  # NOQA
                     plt.figure()
                     plt.subplot(2, 2, 1, projection=None if sample_set.dim == 2 else '3d')
                     plt.title('estimated errors')
                     sample_set.visualize(vertex_data=errors, center_data=center_errors, new_figure=False)
                     plt.subplot(2, 2, 2, projection=None if sample_set.dim == 2 else '3d')
                     plt.title('indicators_error_part')
                     vmax = np.max([indicators_error_part, indicators_age_part, indicators])
@@ -416,16 +416,16 @@
                              [1., 1., 0.],
                              [1., 1., 1.],
                              [0., 1., 1.],
                              [0., 1., 0.],
                              [0., 1., 1.],
                              [0., 0., 1.]])
 
-            from mpl_toolkits.mplot3d import Axes3D  # NOQA
             import matplotlib.pyplot as plt
+            from mpl_toolkits.mplot3d import Axes3D  # NOQA
             if new_figure:
                 plt.figure()
                 plt.gca().add_subplot(111, projection='3d')
             ax = plt.gca()
 
             # draw cells
             for leaf, level in zip(self.vertex_ids, self.levels):
```

### Comparing `pymor-2022.2.1/src/pymor/algorithms/basic.py` & `pymor-2023.1.0/src/pymor/algorithms/basic.py`

 * *Files 6% similar despite different names*

```diff
@@ -55,15 +55,20 @@
     ERR_norm = X.sup_norm() if sup_norm else X.norm(product)
 
     return ERR_norm <= atol + V_norm * rtol
 
 
 def relative_error(U, V, product=None):
     """Compute error between U and V relative to norm of U."""
-    return (U - V).norm(product) / U.norm(product)
+    err = (U - V).norm(product)
+    if np.all(err == 0.):
+        # ensure to return 0 here even when the norm of U is zero
+        return err
+    else:
+        return err / U.norm(product)
 
 
 def project_array(U, basis, product=None, orthonormal=True):
     """Orthogonal projection of |VectorArray| onto subspace.
 
     Parameters
     ----------
```

### Comparing `pymor-2022.2.1/src/pymor/algorithms/bernoulli.py` & `pymor-2023.1.0/src/pymor/algorithms/bernoulli.py`

 * *Files identical despite different names*

### Comparing `pymor-2022.2.1/src/pymor/algorithms/dmd.py` & `pymor-2023.1.0/src/pymor/algorithms/dmd.py`

 * *Files identical despite different names*

### Comparing `pymor-2022.2.1/src/pymor/algorithms/ei.py` & `pymor-2023.1.0/src/pymor/algorithms/ei.py`

 * *Files 0% similar despite different names*

```diff
@@ -12,17 +12,17 @@
 the empirical interpolation of the |Operators| of a given model with
 a single function call.
 """
 
 import numpy as np
 from scipy.linalg import solve
 
-from pymor.core.logger import getLogger
 from pymor.algorithms.pod import pod as pod_alg
-from pymor.analyticalproblems.functions import Function, EmpiricalInterpolatedFunction
+from pymor.analyticalproblems.functions import EmpiricalInterpolatedFunction, Function
+from pymor.core.logger import getLogger
 from pymor.operators.ei import EmpiricalInterpolatedOperator
 from pymor.parallel.dummy import dummy_pool
 from pymor.parallel.interface import RemoteObject
 from pymor.parallel.manager import RemoteObjectManager
 from pymor.vectorarrays.interface import VectorArray
 from pymor.vectorarrays.numpy import NumpyVectorSpace
```

### Comparing `pymor-2022.2.1/src/pymor/algorithms/eigs.py` & `pymor-2023.1.0/src/pymor/algorithms/eigs.py`

 * *Files identical despite different names*

### Comparing `pymor-2022.2.1/src/pymor/algorithms/error.py` & `pymor-2023.1.0/src/pymor/algorithms/error.py`

 * *Ordering differences only*

 * *Files 0% similar despite different names*

```diff
@@ -1,14 +1,14 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
+import time
 from itertools import cycle
 from numbers import Number
-import time
 
 import numpy as np
 
 from pymor.core.logger import getLogger
 from pymor.models.basic import StationaryModel
 from pymor.parallel.dummy import dummy_pool
```

### Comparing `pymor-2022.2.1/src/pymor/algorithms/genericsolvers.py` & `pymor-2023.1.0/src/pymor/algorithms/genericsolvers.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,12 +1,12 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
-"""This module contains some iterative linear solvers which only use the |Operator| interface"""
+"""This module contains some iterative linear solvers which only use the |Operator| interface."""
 
 import numpy as np
 
 from pymor.core.defaults import defaults
 from pymor.core.exceptions import InversionError
 from pymor.core.logger import getLogger
 
@@ -244,16 +244,16 @@
 
         # -- inner LGMRES iteration
         vs0 = -r_outer   # -psolve(r_outer)
         inner_res_0 = vs0.norm()[0]
 
         if inner_res_0 == 0:
             rnorm = r_outer.norm()[0]
-            raise RuntimeError("Preconditioner returned a zero vector; "
-                               "|v| ~ %.1g, |M v| = 0" % rnorm)
+            raise RuntimeError('Preconditioner returned a zero vector; '
+                               '|v| ~ %.1g, |M v| = 0' % rnorm)
 
         vs0.scal(1.0/inner_res_0)
         hs = []
         vs = [vs0]
         ws = []
         y = None
```

### Comparing `pymor-2022.2.1/src/pymor/algorithms/gram_schmidt.py` & `pymor-2023.1.0/src/pymor/algorithms/gram_schmidt.py`

 * *Files 2% similar despite different names*

```diff
@@ -61,15 +61,15 @@
     R = np.eye(len(A))
     remove = []  # indices of to be removed vectors
     for i in range(offset, len(A)):
         # first calculate norm
         initial_norm = A[i].norm(product)[0]
 
         if initial_norm <= atol:
-            logger.info(f"Removing vector {i} of norm {initial_norm}")
+            logger.info(f'Removing vector {i} of norm {initial_norm}')
             remove.append(i)
             continue
 
         if i == 0:
             A[0].scal(1 / initial_norm)
             R[i, i] = initial_norm
         else:
@@ -88,21 +88,21 @@
                     R[j, i] += p
 
                 # calculate new norm
                 old_norm, norm = norm, A[i].norm(product)[0]
 
                 # remove vector if it got too small
                 if norm <= rtol * initial_norm:
-                    logger.info(f"Removing linearly dependent vector {i}")
+                    logger.info(f'Removing linearly dependent vector {i}')
                     remove.append(i)
                     break
 
                 # check if reorthogonalization should be done
                 if reiterate and norm < reiteration_threshold * old_norm:
-                    logger.info(f"Orthonormalizing vector {i} again")
+                    logger.info(f'Orthonormalizing vector {i} again')
                 else:
                     A[i].scal(1 / norm)
                     R[i, i] = norm
                     break
 
     if remove:
         del A[remove]
@@ -110,15 +110,15 @@
 
     if check:
         error_matrix = A[offset:len(A)].inner(A, product)
         error_matrix[:len(A) - offset, offset:len(A)] -= np.eye(len(A) - offset)
         if error_matrix.size > 0:
             err = np.max(np.abs(error_matrix))
             if err >= check_tol:
-                raise AccuracyError(f"result not orthogonal (max err={err})")
+                raise AccuracyError(f'result not orthogonal (max err={err})')
 
     if return_R:
         return A, R
     else:
         return A
 
 
@@ -184,15 +184,15 @@
                     V[i].axpy(-p, V[j])
 
                 # calculate new norm
                 old_norm, norm = norm, V[i].norm(product)[0]
 
                 # check if reorthogonalization should be done
                 if reiterate and norm < reiteration_threshold * old_norm:
-                    logger.info(f"Projecting vector V[{i}] again")
+                    logger.info(f'Projecting vector V[{i}] again')
                 else:
                     V[i].scal(1 / norm)
                     break
 
         # calculate norm of W[i]
         initial_norm = W[i].norm(product)[0]
 
@@ -210,25 +210,25 @@
                     W[i].axpy(-p, W[j])
 
                 # calculate new norm
                 old_norm, norm = norm, W[i].norm(product)[0]
 
                 # check if reorthogonalization should be done
                 if reiterate and norm < reiteration_threshold * old_norm:
-                    logger.info(f"Projecting vector W[{i}] again")
+                    logger.info(f'Projecting vector W[{i}] again')
                 else:
                     W[i].scal(1 / norm)
                     break
 
         # rescale V[i]
         p = W[i].pairwise_inner(V[i], product)[0]
         V[i].scal(1 / p)
 
     if check:
         error_matrix = W.inner(V, product)
         error_matrix -= np.eye(len(V))
         if error_matrix.size > 0:
             err = np.max(np.abs(error_matrix))
             if err >= check_tol:
-                raise AccuracyError(f"result not biorthogonal (max err={err})")
+                raise AccuracyError(f'result not biorthogonal (max err={err})')
 
     return V, W
```

### Comparing `pymor-2022.2.1/src/pymor/algorithms/greedy.py` & `pymor-2023.1.0/src/pymor/algorithms/greedy.py`

 * *Files identical despite different names*

### Comparing `pymor-2022.2.1/src/pymor/algorithms/hapod.py` & `pymor-2023.1.0/src/pymor/algorithms/hapod.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,17 +1,18 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 import asyncio
 from collections import defaultdict
 from math import ceil
-import numpy as np
 from threading import Thread
 
+import numpy as np
+
 from pymor.algorithms.pod import pod
 from pymor.core.logger import getLogger
 from pymor.tools.random import spawn_rng
 
 
 class Node:
 
@@ -136,15 +137,15 @@
     """Compute the Hierarchical Approximate POD.
 
     This is an implementation of the HAPOD algorithm from :cite:`HLR18`.
 
     Parameters
     ----------
     tree
-        A :class:`Tree` defining the worker topology.
+        A :class:`Tree <Node>` defining the worker topology.
     snapshots
         A mapping `snapshots(node)` returning for each leaf node the
         associated snapshot vectors.
     local_eps
         A mapping `local_eps(node, snap_count, num_vecs)` assigning
         to each tree node `node` an l2 truncation error tolerance for the
         local pod based on the number of input vectors `num_vecs` and the
```

### Comparing `pymor-2022.2.1/src/pymor/algorithms/image.py` & `pymor-2023.1.0/src/pymor/algorithms/image.py`

 * *Files identical despite different names*

### Comparing `pymor-2022.2.1/src/pymor/algorithms/krylov.py` & `pymor-2023.1.0/src/pymor/algorithms/krylov.py`

 * *Files identical despite different names*

### Comparing `pymor-2022.2.1/src/pymor/algorithms/lincomb.py` & `pymor-2023.1.0/src/pymor/algorithms/lincomb.py`

 * *Files 6% similar despite different names*

```diff
@@ -3,38 +3,51 @@
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 from itertools import chain
 
 import numpy as np
 import scipy.linalg as spla
 
-from pymor.algorithms.rules import RuleTable, match_generic, match_class_all, match_class_any, match_always
+from pymor.algorithms.rules import RuleTable, match_always, match_class_all, match_class_any, match_generic
 from pymor.core.exceptions import RuleNotMatchingError
-from pymor.operators.block import (BlockOperator, BlockRowOperator, BlockColumnOperator, BlockOperatorBase,
-                                   BlockDiagonalOperator, SecondOrderModelOperator)
-from pymor.operators.constructions import (ZeroOperator, IdentityOperator, VectorArrayOperator, LincombOperator,
-                                           LowRankOperator, LowRankUpdatedOperator)
+from pymor.operators.block import (
+    BlockColumnOperator,
+    BlockDiagonalOperator,
+    BlockOperator,
+    BlockOperatorBase,
+    BlockRowOperator,
+    SecondOrderModelOperator,
+)
+from pymor.operators.constructions import (
+    IdentityOperator,
+    LincombOperator,
+    LowRankOperator,
+    LowRankUpdatedOperator,
+    VectorArrayOperator,
+    ZeroOperator,
+)
 from pymor.vectorarrays.constructions import cat_arrays
 
 
 def assemble_lincomb(operators, coefficients, solver_options=None, name=None):
     """Try to assemble a linear combination of the given operators.
 
     Returns a new |Operator| which represents the sum ::
 
         c_1*O_1 + ... + c_N*O_N
 
     where `O_i` are |Operators| and `c_i` scalar coefficients.
 
-    This function is called in the :meth:`assemble` method of |LincombOperator| and
-    is not intended to be used directly.
+    This function is called in the
+    :meth:`~pymor.operators.constructions.LincombOperator.assemble` method of
+    |LincombOperator| and is not intended to be used directly.
 
     To form the linear combination of backend |Operators| (containing actual matrix data),
-    :meth:`~pymor.operators.interface.Operator._assemble_lincomb` will be called
-    on the first |Operator| in the linear combination.
+    :meth:`~pymor.operators.interface.Operator._assemble_lincomb` will be called on the first
+    |Operator| in the linear combination.
 
     Parameters
     ----------
     operators
         List of |Operators| `O_i` whose linear combination is formed.
     coefficients
         List of the corresponding linear coefficients `c_i`.
@@ -47,14 +60,26 @@
     -------
     The assembled |Operator|.
     """
     return AssembleLincombRules(tuple(coefficients), solver_options, name).apply(tuple(operators))
 
 
 class AssembleLincombRules(RuleTable):
+    """|RuleTable| for the :func:`assemble_lincomb` algorithm.
+
+    Parameters
+    ----------
+    coefficients
+        Tuple of coefficients.
+    solver_options
+        |solver_options| for the assembled operator.
+    name
+        Name of the assembled operator.
+    """
+
     def __init__(self, coefficients, solver_options, name):
         super().__init__(use_caching=False)
         self.__auto_init(locals())
 
     @match_always
     def action_zero_coeff(self, ops):
         if all(coeff != 0 for coeff in self.coefficients):
```

### Comparing `pymor-2022.2.1/src/pymor/algorithms/lradi.py` & `pymor-2023.1.0/src/pymor/algorithms/lradi.py`

 * *Files identical despite different names*

### Comparing `pymor-2022.2.1/src/pymor/algorithms/lrradi.py` & `pymor-2023.1.0/src/pymor/algorithms/lrradi.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,22 +1,22 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
-import scipy.linalg as spla
 import numpy as np
+import scipy.linalg as spla
 
 from pymor.algorithms.genericsolvers import _parse_options
+from pymor.algorithms.gram_schmidt import gram_schmidt
 from pymor.algorithms.riccati import _solve_ricc_check_args
-from pymor.vectorarrays.constructions import cat_arrays
 from pymor.core.defaults import defaults
 from pymor.core.logger import getLogger
 from pymor.operators.constructions import IdentityOperator
-from pymor.algorithms.gram_schmidt import gram_schmidt
 from pymor.tools.random import new_rng
+from pymor.vectorarrays.constructions import cat_arrays
 
 
 @defaults('lrradi_tol', 'lrradi_maxiter', 'lrradi_shifts', 'hamiltonian_shifts_init_maxiter',
           'hamiltonian_shifts_subspace_columns')
 def ricc_lrcf_solver_options(lrradi_tol=1e-10,
                              lrradi_maxiter=500,
                              lrradi_shifts='hamiltonian_shifts',
@@ -47,15 +47,15 @@
                        'shifts': lrradi_shifts,
                        'shift_options':
                        {'hamiltonian_shifts': {'type': 'hamiltonian_shifts',
                                                'init_maxiter': hamiltonian_shifts_init_maxiter,
                                                'subspace_columns': hamiltonian_shifts_subspace_columns}}}}
 
 
-def solve_ricc_lrcf(A, E, B, C, R=None, trans=False, options=None):
+def solve_ricc_lrcf(A, E, B, C, R=None, S=None, trans=False, options=None):
     """Compute an approximate low-rank solution of a Riccati equation.
 
     See :func:`pymor.algorithms.riccati.solve_ricc_lrcf` for a
     general description.
 
     This function is an implementation of Algorithm 2 in :cite:`BBKS18`.
 
@@ -67,28 +67,32 @@
         The |Operator| E or `None`.
     B
         The operator B as a |VectorArray| from `A.source`.
     C
         The operator C as a |VectorArray| from `A.source`.
     R
         The matrix R as a 2D |NumPy array| or `None`.
+    S
+        The operator S as a |VectorArray| from `A.source` or `None`.
     trans
         Whether the first |Operator| in the Riccati equation is
         transposed.
     options
         The solver options to use. (see
         :func:`ricc_lrcf_solver_options`)
 
     Returns
     -------
     Z
         Low-rank Cholesky factor of the Riccati equation solution,
         |VectorArray| from `A.source`.
     """
-    _solve_ricc_check_args(A, E, B, C, R, trans)
+    _solve_ricc_check_args(A, E, B, C, R, S, trans)
+    if S is not None:
+        raise NotImplementedError
     options = _parse_options(options, ricc_lrcf_solver_options(), 'lrradi', None, False)
     logger = getLogger('pymor.algorithms.lrradi.solve_ricc_lrcf')
 
     shift_options = options['shift_options'][options['shifts']]
     if shift_options['type'] == 'hamiltonian_shifts':
         init_shifts = hamiltonian_shifts_init
         iteration_shifts = hamiltonian_shifts
```

### Comparing `pymor-2022.2.1/src/pymor/algorithms/lyapunov.py` & `pymor-2023.1.0/src/pymor/algorithms/lyapunov.py`

 * *Files 1% similar despite different names*

```diff
@@ -3,17 +3,16 @@
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 import numpy as np
 import scipy.linalg as spla
 
 from pymor.core.config import config
 from pymor.core.defaults import defaults
-from pymor.tools.frozendict import FrozenDict
 from pymor.operators.interface import Operator
-
+from pymor.tools.frozendict import FrozenDict
 
 _DEFAULT_LYAP_SOLVER_BACKEND = FrozenDict(
     {
         'cont': FrozenDict(
             {
                 'sparse': 'pymess' if config.HAVE_PYMESS else 'lradi',
                 'dense': 'pymess'
```

### Comparing `pymor-2022.2.1/src/pymor/algorithms/newton.py` & `pymor-2023.1.0/src/pymor/algorithms/newton.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,13 +1,13 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
-from numbers import Number
 import warnings
+from numbers import Number
 
 import numpy as np
 
 from pymor.algorithms.line_search import armijo
 from pymor.core.defaults import defaults
 from pymor.core.exceptions import InversionError, NewtonError
 from pymor.core.logger import getLogger
@@ -175,15 +175,15 @@
                 return residual_vec.norm(range_product)[0]
 
             if range_product is None:
                 grad = - (jacobian.apply(residual) + jacobian.apply_adjoint(residual))
             else:
                 grad = - (jacobian.apply_adjoint(range_product.apply(residual))
                           + jacobian.apply(range_product.apply_adjoint(residual)))
-            step_size = armijo(res, U, update, grad=grad, initial_value=residual_norm, **(line_search_params or {}))
+            step_size, _ = armijo(res, U, update, grad=grad, initial_value=residual_norm, **(line_search_params or {}))
         else:
             raise ValueError('Unknown line search method.')
 
         # update solution and residual
         U.axpy(step_size, update)
         residual = rhs - operator.apply(U, mu=mu)
```

### Comparing `pymor-2022.2.1/src/pymor/algorithms/pod.py` & `pymor-2023.1.0/src/pymor/algorithms/pod.py`

 * *Files identical despite different names*

### Comparing `pymor-2022.2.1/src/pymor/algorithms/preassemble.py` & `pymor-2023.1.0/src/pymor/algorithms/preassemble.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,34 +1,42 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 from pymor.algorithms.rules import RuleTable, match_class, match_generic
 from pymor.models.interface import Model
-from pymor.operators.constructions import (LincombOperator, ConcatenationOperator, ProjectedOperator,
-                                           AffineOperator, AdjointOperator, SelectionOperator)
+from pymor.operators.constructions import (
+    AdjointOperator,
+    AffineOperator,
+    ConcatenationOperator,
+    LincombOperator,
+    ProjectedOperator,
+    QuadraticFunctional,
+    SelectionOperator,
+)
 from pymor.operators.interface import Operator
 
 
 def preassemble(obj):
     """Preassemble non-parametric operators.
 
     If `obj` is a non-parametric |Operator|, return
     `obj.assemble()` otherwise return `obj`. Recursively
     replaces children of `obj`.
     """
     return PreAssembleRules().apply(obj)
 
 
 class PreAssembleRules(RuleTable):
+    """|RuleTable| for the :func:`preassemble` algorithm."""
 
     def __init__(self):
         super().__init__(use_caching=True)
 
-    @match_class(Model, AffineOperator, ConcatenationOperator, SelectionOperator)
+    @match_class(Model, AffineOperator, ConcatenationOperator, SelectionOperator, QuadraticFunctional)
     def action_recurse(self, op):
         return self.replace_children(op)
 
     @match_class(LincombOperator)
     def action_recurse_and_assemble(self, op):
         op = self.replace_children(op)
         if not op.parametric:
```

### Comparing `pymor-2022.2.1/src/pymor/algorithms/projection.py` & `pymor-2023.1.0/src/pymor/algorithms/projection.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,20 +1,30 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 import numpy as np
 
-from pymor.algorithms.rules import RuleTable, match_class, match_generic, match_always
-from pymor.core.exceptions import RuleNotMatchingError, NoMatchingRuleError
-from pymor.operators.block import BlockOperatorBase, BlockRowOperator, BlockColumnOperator
-from pymor.operators.constructions import (LincombOperator, ConcatenationOperator, ConstantOperator, ProjectedOperator,
-                                           ZeroOperator, AffineOperator, AdjointOperator, SelectionOperator,
-                                           IdentityOperator, VectorArrayOperator)
-from pymor.operators.ei import EmpiricalInterpolatedOperator, ProjectedEmpiciralInterpolatedOperator
+from pymor.algorithms.rules import RuleTable, match_class, match_generic
+from pymor.core.exceptions import NoMatchingRuleError, RuleNotMatchingError
+from pymor.operators.block import BlockColumnOperator, BlockOperatorBase, BlockRowOperator
+from pymor.operators.constructions import (
+    AdjointOperator,
+    AffineOperator,
+    ConcatenationOperator,
+    ConstantOperator,
+    IdentityOperator,
+    LincombOperator,
+    ProjectedOperator,
+    QuadraticFunctional,
+    SelectionOperator,
+    VectorArrayOperator,
+    ZeroOperator,
+)
+from pymor.operators.ei import EmpiricalInterpolatedOperator, ProjectedEmpiricalInterpolatedOperator
 from pymor.operators.numpy import NumpyMatrixOperator
 from pymor.vectorarrays.numpy import NumpyVectorSpace
 
 
 def project(op, range_basis, source_basis, product=None):
     """Petrov-Galerkin projection of a given |Operator|.
 
@@ -28,17 +38,18 @@
 
     In particular, if the `c_i` are orthonormal w.r.t. the given product,
     then `op_proj` is the coordinate representation w.r.t. the `b_i/c_i` bases
     of the restriction of `op` to `span(b_i)` concatenated with the
     orthogonal projection onto `span(c_i)`.
 
     From another point of view, if `op` is viewed as a bilinear form
-    (see :meth:`apply2`) and `( ,  )` is the Euclidean inner
-    product, then `op_proj` represents the matrix of the bilinear form restricted
-    to `span(b_i) / span(c_i)` (w.r.t. the `b_i/c_i` bases).
+    (see :meth:`~pymor.operators.interface.Operator.apply2`) and `( ,  )` is
+    the Euclidean inner product, then `op_proj` represents the matrix of the
+    bilinear form restricted to `span(b_i) / span(c_i)` (w.r.t. the `b_i/c_i`
+    bases).
 
     How the projection is realized will depend on the given |Operator|.
     While a projected |NumpyMatrixOperator| will
     again be a |NumpyMatrixOperator|, only a generic
     :class:`~pymor.operators.constructions.ProjectedOperator` can be returned
     in general. The exact algorithm is specified in :class:`ProjectRules`.
 
@@ -58,87 +69,82 @@
     -------
     The projected |Operator| `op_proj`.
     """
     assert source_basis is None or source_basis in op.source
     assert range_basis is None or range_basis in op.range
     assert product is None or product.source == product.range == op.range
 
+    if range_basis is None and source_basis is None:
+        return op  # do not change the name
+
     rb = product.apply(range_basis) if product is not None and range_basis is not None else range_basis
 
     try:
-        return ProjectRules(rb, source_basis).apply(op)
+        return ProjectRules(rb, source_basis).apply(op).with_(name=None)
     except NoMatchingRuleError:
         op.logger.warning('Using inefficient generic projection operator')
         return ProjectedOperator(op, range_basis, source_basis, product)
 
 
 class ProjectRules(RuleTable):
     """|RuleTable| for the :func:`project` algorithm."""
 
     def __init__(self, range_basis, source_basis):
         super().__init__(use_caching=True)
         self.__auto_init(locals())
 
-    @match_always
-    def action_no_bases(self, op):
-        if self.range_basis is None and self.source_basis is None:
-            return op
-        else:
-            raise RuleNotMatchingError
-
     @match_class(ZeroOperator)
     def action_ZeroOperator(self, op):
         range_basis, source_basis = self.range_basis, self.source_basis
         if source_basis is not None and range_basis is not None:
             from pymor.operators.numpy import NumpyMatrixOperator
-            return NumpyMatrixOperator(np.zeros((len(range_basis), len(source_basis))),
-                                       name=op.name)
+            return NumpyMatrixOperator(np.zeros((len(range_basis), len(source_basis))))
         else:
             new_source = NumpyVectorSpace(len(source_basis)) if source_basis is not None else op.source
             new_range = NumpyVectorSpace(len(range_basis)) if range_basis is not None else op.range
-            return ZeroOperator(new_range, new_source, name=op.name)
+            return ZeroOperator(new_range, new_source)
 
     @match_class(ConstantOperator)
     def action_ConstantOperator(self, op):
         range_basis, source_basis = self.range_basis, self.source_basis
         if range_basis is not None:
             projected_value = NumpyVectorSpace.make_array(range_basis.inner(op.value).T)
         else:
             projected_value = op.value
         if source_basis is None:
-            return ConstantOperator(projected_value, op.source, name=op.name)
+            return ConstantOperator(projected_value, op.source)
         else:
-            return ConstantOperator(projected_value, NumpyVectorSpace(len(source_basis)), name=op.name)
+            return ConstantOperator(projected_value, NumpyVectorSpace(len(source_basis)))
 
     @match_generic(lambda op: op.linear and not op.parametric, 'linear and not parametric')
     def action_apply_basis(self, op):
         range_basis, source_basis = self.range_basis, self.source_basis
         if source_basis is None:
             try:
                 V = op.apply_adjoint(range_basis)
             except NotImplementedError as e:
                 raise RuleNotMatchingError('apply_adjoint not implemented') from e
             if isinstance(op.source, NumpyVectorSpace):
                 from pymor.operators.numpy import NumpyMatrixOperator
-                return NumpyMatrixOperator(V.to_numpy(), source_id=op.source.id, name=op.name)
+                return NumpyMatrixOperator(V.to_numpy().conj(), source_id=op.source.id)
             else:
                 from pymor.operators.constructions import VectorArrayOperator
-                return VectorArrayOperator(V, adjoint=True, name=op.name)
+                return VectorArrayOperator(V, adjoint=True)
         else:
             if range_basis is None:
                 V = op.apply(source_basis)
                 if isinstance(op.range, NumpyVectorSpace):
                     from pymor.operators.numpy import NumpyMatrixOperator
-                    return NumpyMatrixOperator(V.to_numpy().T, range_id=op.range.id, name=op.name)
+                    return NumpyMatrixOperator(V.to_numpy().T, range_id=op.range.id)
                 else:
                     from pymor.operators.constructions import VectorArrayOperator
-                    return VectorArrayOperator(V, adjoint=False, name=op.name)
+                    return VectorArrayOperator(V, adjoint=False)
             else:
                 from pymor.operators.numpy import NumpyMatrixOperator
-                return NumpyMatrixOperator(op.apply2(range_basis, source_basis), name=op.name)
+                return NumpyMatrixOperator(op.apply2(range_basis, source_basis))
 
     @match_class(ConcatenationOperator)
     def action_ConcatenationOperator(self, op):
         if len(op.operators) == 1:
             return self.apply(op.operators[0])
 
         range_basis, source_basis = self.range_basis, self.source_basis
@@ -158,15 +164,15 @@
         if not isinstance(expanded_op, ConcatenationOperator):
             # expanding was successful
             return self.apply(expanded_op)
 
         # at least we can try to partially project the outer operators
         projected_first = project(first, None, source_basis)
         projected_last = project(last, range_basis, None)
-        projected_op = ConcatenationOperator((projected_last,) + op.operators[1:-1] + (projected_first,), name=op.name)
+        projected_op = ConcatenationOperator((projected_last,) + op.operators[1:-1] + (projected_first,))
 
         # special handling for concatenations with ConstantOperators
         # probably should be moved elsewhere
         if not projected_op.parametric and any(isinstance(o, ConstantOperator) for o in projected_op.operators):
             projected_op = ConstantOperator(projected_op.apply(projected_op.source.zeros()), projected_op.source)
 
         return projected_op
@@ -180,32 +186,31 @@
 
         if source_basis is not None and op.range_product:
             source_basis = op.range_product.apply(source_basis)
 
         operator = project(op.operator, source_basis, range_basis)
         range_product = op.range_product if source_basis is None else None
         source_product = op.source_product if range_basis is None else None
-        return AdjointOperator(operator, source_product=source_product, range_product=range_product,
-                               name=op.name)
+        return AdjointOperator(operator, source_product=source_product, range_product=range_product)
 
     @match_class(EmpiricalInterpolatedOperator)
     def action_EmpiricalInterpolatedOperator(self, op):
         range_basis, source_basis = self.range_basis, self.source_basis
         if len(op.interpolation_dofs) == 0:
-            return self.apply(ZeroOperator(op.range, op.source, op.name))
+            return self.apply(ZeroOperator(op.range, op.source))
         elif not hasattr(op, 'restricted_operator') or source_basis is None:
             raise RuleNotMatchingError('Has no restricted operator or source_basis is None')
         if range_basis is not None:
             projected_collateral_basis = NumpyVectorSpace.make_array(op.collateral_basis.inner(range_basis))
         else:
             projected_collateral_basis = op.collateral_basis
 
-        return ProjectedEmpiciralInterpolatedOperator(op.restricted_operator, op.interpolation_matrix,
+        return ProjectedEmpiricalInterpolatedOperator(op.restricted_operator, op.interpolation_matrix,
                                                       NumpyVectorSpace.make_array(source_basis.dofs(op.source_dofs)),
-                                                      projected_collateral_basis, op.triangular, None, op.name)
+                                                      projected_collateral_basis, op.triangular, None)
 
     @match_class(AffineOperator)
     def action_AffineOperator(self, op):
         return self.apply(op.affine_shift + op.linear_part)
 
     @match_class(LincombOperator)
     def action_LincombOperator(self, op):
@@ -238,14 +243,18 @@
         if self.range_basis is None and op.blocked_range:
             return BlockColumnOperator(np.sum(projected_ops, axis=1))
         elif self.source_basis is None and op.blocked_source:
             return BlockRowOperator(np.sum(projected_ops, axis=0))
         else:
             return np.sum(projected_ops)
 
+    @match_class(QuadraticFunctional)
+    def action_QuadraticFunctional(self, op):
+        return QuadraticFunctional(project(op.operator, self.source_basis, self.source_basis))
+
 
 def project_to_subbasis(op, dim_range=None, dim_source=None):
     """Project already projected |Operator| to a subbasis.
 
     The purpose of this method is to further project an operator that has been
     obtained through :meth:`project` to subbases of the original projection bases, i.e. ::
 
@@ -273,15 +282,15 @@
     """
     assert dim_source is None or (isinstance(op.source, NumpyVectorSpace) and dim_source <= op.source.dim)
     assert dim_range is None or (isinstance(op.range, NumpyVectorSpace) and dim_range <= op.range.dim)
 
     if dim_range is None and dim_source is None:
         return op
 
-    return ProjectToSubbasisRules(dim_range, dim_source).apply(op)
+    return ProjectToSubbasisRules(dim_range, dim_source).apply(op).with_(name=None)
 
 
 class ProjectToSubbasisRules(RuleTable):
     """|RuleTable| for the :func:`project_to_subbasis` algorithm."""
 
     def __init__(self, dim_range, dim_source):
         super().__init__(use_caching=True)
@@ -291,55 +300,55 @@
     def action_recurse(self, op):
         return self.replace_children(op)
 
     @match_class(NumpyMatrixOperator)
     def action_NumpyMatrixOperator(self, op):
         # copy instead of just slicing the matrix to ensure contiguous memory
         return NumpyMatrixOperator(op.matrix[:self.dim_range, :self.dim_source].copy(),
-                                   solver_options=op.solver_options, name=op.name,
+                                   solver_options=op.solver_options,
                                    source_id=op.source.id, range_id=op.range.id)
 
     @match_class(ConstantOperator)
     def action_ConstantOperator(self, op):
         dim_range, dim_source = self.dim_range, self.dim_source
         source = op.source if dim_source is None else NumpyVectorSpace(dim_source)
         value = op.value if dim_range is None else NumpyVectorSpace.make_array(op.value.to_numpy()[:, :dim_range])
-        return ConstantOperator(value, source, name=op.name)
+        return ConstantOperator(value, source)
 
     @match_class(IdentityOperator)
     def action_IdentityOperator(self, op):
         dim_range, dim_source = self.dim_range, self.dim_source
         if dim_range != dim_source:
             raise RuleNotMatchingError('dim_range and dim_source must be equal.')
         space = op.source if dim_source is None else NumpyVectorSpace(dim_source)
-        return IdentityOperator(space, name=op.name)
+        return IdentityOperator(space)
 
     @match_class(ZeroOperator)
     def action_ZeroOperator(self, op):
         dim_range, dim_source = self.dim_range, self.dim_source
         range_space = op.range if dim_range is None else NumpyVectorSpace(dim_range)
         source_space = op.source if dim_source is None else NumpyVectorSpace(dim_source)
-        return ZeroOperator(range_space, source_space, name=op.name)
+        return ZeroOperator(range_space, source_space)
 
-    @match_class(ProjectedEmpiciralInterpolatedOperator)
-    def action_ProjectedEmpiciralInterpolatedOperator(self, op):
+    @match_class(ProjectedEmpiricalInterpolatedOperator)
+    def action_ProjectedEmpiricalInterpolatedOperator(self, op):
         if not isinstance(op.projected_collateral_basis.space, NumpyVectorSpace):
             raise NotImplementedError
 
         restricted_operator = op.restricted_operator
 
         old_pcb = op.projected_collateral_basis
         projected_collateral_basis = NumpyVectorSpace.make_array(old_pcb.to_numpy()[:, :self.dim_range])
 
         old_sbd = op.source_basis_dofs
         source_basis_dofs = NumpyVectorSpace.make_array(old_sbd.to_numpy()[:self.dim_source])
 
-        return ProjectedEmpiciralInterpolatedOperator(restricted_operator, op.interpolation_matrix,
+        return ProjectedEmpiricalInterpolatedOperator(restricted_operator, op.interpolation_matrix,
                                                       source_basis_dofs, projected_collateral_basis, op.triangular,
-                                                      solver_options=op.solver_options, name=op.name)
+                                                      solver_options=op.solver_options)
 
     @match_class(VectorArrayOperator)
     def action_VectorArrayOperator(self, op):
         dim_range, dim_source = self.dim_range, self.dim_source
         if op.adjoint and dim_source is not None:
             raise RuleNotMatchingError
         if not op.adjoint and dim_range is not None:
@@ -367,7 +376,13 @@
         dim_range, dim_source = self.dim_range, self.dim_source
         source_basis = op.source_basis if dim_source is None \
             else op.source_basis[:dim_source]
         range_basis = op.range_basis if dim_range is None \
             else op.range_basis[:dim_range]
         return ProjectedOperator(op.operator, range_basis, source_basis, product=None,
                                  solver_options=op.solver_options)
+
+    @match_class(QuadraticFunctional)
+    def action_QuadraticFunctional(self, op):
+        _, dim_source = self.dim_range, self.dim_source
+        return QuadraticFunctional(
+            project_to_subbasis(op.operator, dim_range=dim_source, dim_source=dim_source))
```

### Comparing `pymor-2022.2.1/src/pymor/algorithms/rand_la.py` & `pymor-2023.1.0/src/pymor/algorithms/rand_la.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,22 +1,22 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 import numpy as np
 import scipy as sp
-from scipy.sparse.linalg import eigsh, LinearOperator
 from scipy.linalg import lu_factor, lu_solve
+from scipy.sparse.linalg import LinearOperator, eigsh
 from scipy.special import erfinv
 
 from pymor.algorithms.gram_schmidt import gram_schmidt
 from pymor.core.defaults import defaults
-from pymor.operators.interface import Operator
 from pymor.core.logger import getLogger
-from pymor.operators.constructions import InverseOperator, IdentityOperator
+from pymor.operators.constructions import IdentityOperator, InverseOperator
+from pymor.operators.interface import Operator
 
 
 @defaults('tol', 'failure_tolerance', 'num_testvecs')
 def adaptive_rrf(A, source_product=None, range_product=None, tol=1e-4,
                  failure_tolerance=1e-15, num_testvecs=20, lambda_min=None, iscomplex=False):
     r"""Adaptive randomized range approximation of `A`.
 
@@ -73,15 +73,15 @@
         def mv(v):
             return source_product.apply(source_product.source.from_numpy(v)).to_numpy()
 
         def mvinv(v):
             return source_product.apply_inverse(source_product.range.from_numpy(v)).to_numpy()
         L = LinearOperator((source_product.source.dim, source_product.range.dim), matvec=mv)
         Linv = LinearOperator((source_product.range.dim, source_product.source.dim), matvec=mvinv)
-        lambda_min = eigsh(L, sigma=0, which="LM", return_eigenvectors=False, k=1, OPinv=Linv)[0]
+        lambda_min = eigsh(L, sigma=0, which='LM', return_eigenvectors=False, k=1, OPinv=Linv)[0]
 
     testfail = failure_tolerance / min(A.source.dim, A.range.dim)
     testlimit = np.sqrt(2. * lambda_min) * erfinv(testfail**(1. / num_testvecs)) * tol
     maxnorm = np.inf
     M = A.apply(R)
 
     while maxnorm > testlimit:
```

### Comparing `pymor-2022.2.1/src/pymor/algorithms/riccati.py` & `pymor-2023.1.0/src/pymor/algorithms/riccati.py`

 * *Files 6% similar despite different names*

```diff
@@ -17,46 +17,50 @@
                                            'scipy')
 
 _DEFAULT_RICC_DENSE_SOLVER_BACKEND = ('slycot' if config.HAVE_SLYCOT else
                                       'scipy')
 
 
 @defaults('default_sparse_solver_backend', 'default_dense_solver_backend')
-def solve_ricc_lrcf(A, E, B, C, R=None, trans=False, options=None,
+def solve_ricc_lrcf(A, E, B, C, R=None, S=None, trans=False, options=None,
                     default_sparse_solver_backend=_DEFAULT_RICC_LRCF_SPARSE_SOLVER_BACKEND,
                     default_dense_solver_backend=_DEFAULT_RICC_LRCF_DENSE_SOLVER_BACKEND):
     """Compute an approximate low-rank solution of a Riccati equation.
 
     Returns a low-rank Cholesky factor :math:`Z` such that :math:`Z Z^T`
     approximates the solution :math:`X` of a (generalized)
     continuous-time algebraic Riccati equation:
 
     - if trans is `False`
 
       .. math::
           A X E^T + E X A^T
-          - E X C^T R^{-1} C X E^T
+          - (E X C^T + S^T) R^{-1} (C X E^T + S)
           + B B^T = 0.
 
     - if trans is `True`
 
       .. math::
           A^T X E + E^T X A
-          - E^T X B R^{-1} B^T X E
+          - (E^T X B + S) R^{-1} (B^T X E + S^T)
           + C^T C = 0.
 
     If E is None, it is taken to be identity, and similarly for R.
+    If S is None, it is taken to be zero.
 
     We assume:
 
     - A and E are real |Operators|,
-    - B and C are real |VectorArrays| from `A.source`,
+    - B, C and S are real |VectorArrays| from `A.source`,
     - R is a real |NumPy array|,
-    - (E, A, B, C) is stabilizable and detectable, and
-    - R is symmetric positive definite.
+    - E is nonsingular,
+    - (E, A, B, C) is stabilizable and detectable,
+    - R is symmetric positive definite, and
+    - :math:`B B^T - S^T R^{-1} S` (:math:`C^T C - S R^{-1} S^T`) is
+      positive semi-definite if trans is `False` (`True`).
 
     For large-scale problems, we additionally assume that `len(B)` and
     `len(C)` are small.
 
     If the solver is not specified using the options argument, a solver
     backend is chosen based on availability in the following order:
 
@@ -81,14 +85,16 @@
         The non-parametric |Operator| E or `None`.
     B
         The operator B as a |VectorArray| from `A.source`.
     C
         The operator C as a |VectorArray| from `A.source`.
     R
         The matrix R as a 2D |NumPy array| or `None`.
+    S
+        The operator S as a |VectorArray| from `A.source` or `None`.
     trans
         Whether the first |Operator| in the Riccati equation is
         transposed.
     options
         The solver options to use.
         See:
 
@@ -104,15 +110,15 @@
 
     Returns
     -------
     Z
         Low-rank Cholesky factor of the Riccati equation solution,
         |VectorArray| from `A.source`.
     """
-    _solve_ricc_check_args(A, E, B, C, R, trans)
+    _solve_ricc_check_args(A, E, B, C, R, S, trans)
     if options:
         solver = options if isinstance(options, str) else options['type']
         backend = solver.split('_')[0]
     else:
         if A.source.dim >= mat_eqn_sparse_min_size():
             backend = default_sparse_solver_backend
         else:
@@ -123,44 +129,50 @@
         from pymor.bindings.slycot import solve_ricc_lrcf as solve_ricc_impl
     elif backend == 'pymess':
         from pymor.bindings.pymess import solve_ricc_lrcf as solve_ricc_impl
     elif backend == 'lrradi':
         from pymor.algorithms.lrradi import solve_ricc_lrcf as solve_ricc_impl
     else:
         raise ValueError(f'Unknown solver backend ({backend}).')
-    return solve_ricc_impl(A, E, B, C, R, trans=trans, options=options)
+    return solve_ricc_impl(A, E, B, C, R, S, trans=trans, options=options)
 
 
 @defaults('default_solver_backend')
-def solve_ricc_dense(A, E, B, C, R=None, trans=False, options=None,
+def solve_ricc_dense(A, E, B, C, R=None, S=None, trans=False, options=None,
                      default_solver_backend=_DEFAULT_RICC_DENSE_SOLVER_BACKEND):
     """Compute the solution of a Riccati equation.
 
     Returns the solution :math:`X` of a (generalized) continuous-time
     algebraic Riccati equation:
 
     - if trans is `False`
 
       .. math::
           A X E^T + E X A^T
-          - E X C^T R^{-1} C X E^T
+          - (E X C^T + S^T) R^{-1} (C X E^T + S)
           + B B^T = 0.
 
     - if trans is `True`
 
       .. math::
           A^T X E + E^T X A
-          - E^T X B R^{-1} B^T X E
+          - (E^T X B + S) R^{-1} (B^T X E + S^T)
           + C^T C = 0.
 
+    If E is None, it is taken to be identity, and similarly for R.
+    If S is None, it is taken to be zero.
+
     We assume:
 
-    - A, E, B, C, R are real |NumPy arrays|,
-    - (E, A, B, C) is stabilizable and detectable, and
-    - R is symmetric positive definite.
+    - A, E, B, C, R, S are real |NumPy arrays|,
+    - E is nonsingular,
+    - (E, A, B, C) is stabilizable and detectable,
+    - R is symmetric positive definite, and
+    - :math:`B B^T - S^T R^{-1} S` (:math:`C^T C - S R^{-1} S^T`) is
+      positive semi-definite if trans is `False` (`True`).
 
     If the solver is not specified using the options argument, a solver
     backend is chosen based on availability in the following order:
 
     1. `slycot` (see :func:`pymor.bindings.slycot.solve_ricc_dense`)
     2. `scipy` (see :func:`pymor.bindings.scipy.solve_ricc_dense`)
 
@@ -172,14 +184,16 @@
         The matrix E as a 2D |NumPy array| or `None`.
     B
         The matrix B as a 2D |NumPy array|.
     C
         The matrix C as a 2D |NumPy array|.
     R
         The matrix B as a 2D |NumPy array| or `None`.
+    S
+        The matrix S as a 2D |NumPy array| or `None`.
     trans
         Whether the first matrix in the Riccati equation is
         transposed.
     options
         The solver options to use.
         See:
 
@@ -190,30 +204,30 @@
         Default solver backend to use (slycot, scipy).
 
     Returns
     -------
     X
         Riccati equation solution as a |NumPy array|.
     """
-    _solve_ricc_dense_check_args(A, E, B, C, R, trans)
+    _solve_ricc_dense_check_args(A, E, B, C, R, S, trans)
     if options:
         solver = options if isinstance(options, str) else options['type']
         backend = solver.split('_')[0]
     else:
         backend = default_solver_backend
     if backend == 'scipy':
         from pymor.bindings.scipy import solve_ricc_dense as solve_ricc_impl
     elif backend == 'slycot':
         from pymor.bindings.slycot import solve_ricc_dense as solve_ricc_impl
     else:
         raise ValueError(f'Unknown solver backend ({backend}).')
-    return solve_ricc_impl(A, E, B, C, R, trans, options=options)
+    return solve_ricc_impl(A, E, B, C, R, S, trans, options=options)
 
 
-def _solve_ricc_dense_check_args(A, E, B, C, R, trans):
+def _solve_ricc_dense_check_args(A, E, B, C, R, S, trans):
     assert isinstance(A, np.ndarray) and A.ndim == 2
     assert A.shape[0] == A.shape[1]
     if E is not None:
         assert isinstance(E, np.ndarray) and E.ndim == 2
         assert E.shape[0] == E.shape[1]
         assert E.shape[0] == A.shape[0]
     assert isinstance(B, np.ndarray) and isinstance(C, np.ndarray)
@@ -221,45 +235,54 @@
     if R is not None:
         assert isinstance(R, np.ndarray) and R.ndim == 2
         assert R.shape[0] == R.shape[1]
         if not trans:
             assert R.shape[0] == C.shape[0]
         else:
             assert R.shape[0] == B.shape[1]
+    if S is not None:
+        assert isinstance(S, np.ndarray)
+        if not trans:
+            assert S.shape[1] == A.shape[0]
+            assert S.shape[0] == C.shape[0]
+        else:
+            assert S.shape[0] == A.shape[0]
+            assert S.shape[1] == B.shape[1]
 
 
 _DEFAULT_POS_RICC_LRCF_DENSE_SOLVER_BACKEND = ('pymess' if config.HAVE_PYMESS else
                                                'slycot' if config.HAVE_SLYCOT else
                                                'scipy')
 
 
 @defaults('default_dense_solver_backend')
-def solve_pos_ricc_lrcf(A, E, B, C, R=None, trans=False, options=None,
+def solve_pos_ricc_lrcf(A, E, B, C, R=None, S=None, trans=False, options=None,
                         default_dense_solver_backend=_DEFAULT_RICC_LRCF_DENSE_SOLVER_BACKEND):
     """Compute an approximate low-rank solution of a positive Riccati equation.
 
     Returns a low-rank Cholesky factor :math:`Z` such that :math:`Z Z^T`
     approximates the solution :math:`X` of a (generalized) positive
     continuous-time algebraic Riccati equation:
 
     - if trans is `False`
 
       .. math::
           A X E^T + E X A^T
-          + E X C^T R^{-1} C X E^T
+          + (E X C^T + S^T) R^{-1} (C X E^T + S)
           + B B^T = 0.
 
     - if trans is `True`
 
       .. math::
           A^T X E + E^T X A
-          + E^T X B R^{-1} B^T X E
+          + (E^T X B + S) R^{-1} (B^T X E + S^T)
           + C^T C = 0.
 
     If E is None, it is taken to be identity, and similarly for R.
+    If S is None, it is taken to be zero.
 
     If the solver is not specified using the options argument, a solver
     backend is chosen based on availability in the following order:
 
     1. `pymess` (see :func:`pymor.bindings.pymess.solve_pos_ricc_lrcf`),
     2. `slycot` (see :func:`pymor.bindings.slycot.solve_pos_ricc_lrcf`),
     3. `scipy` (see :func:`pymor.bindings.scipy.solve_pos_ricc_lrcf`).
@@ -272,14 +295,16 @@
         The non-parametric |Operator| E or `None`.
     B
         The operator B as a |VectorArray| from `A.source`.
     C
         The operator C as a |VectorArray| from `A.source`.
     R
         The matrix R as a 2D |NumPy array| or `None`.
+    S
+        The operator S as a |VectorArray| from `A.source` or `None`.
     trans
         Whether the first |Operator| in the positive Riccati equation is
         transposed.
     options
         The solver options to use.
         See:
 
@@ -292,32 +317,32 @@
 
     Returns
     -------
     Z
         Low-rank Cholesky factor of the positive Riccati equation
         solution, |VectorArray| from `A.source`.
     """
-    _solve_ricc_check_args(A, E, B, C, R, trans)
+    _solve_ricc_check_args(A, E, B, C, R, S, trans)
     if options:
         solver = options if isinstance(options, str) else options['type']
         backend = solver.split('_')[0]
     else:
         backend = default_dense_solver_backend
     if backend == 'scipy':
         from pymor.bindings.scipy import solve_pos_ricc_lrcf as solve_ricc_impl
     elif backend == 'slycot':
         from pymor.bindings.slycot import solve_pos_ricc_lrcf as solve_ricc_impl
     elif backend == 'pymess':
         from pymor.bindings.pymess import solve_pos_ricc_lrcf as solve_ricc_impl
     else:
         raise ValueError(f'Unknown solver backend ({backend}).')
-    return solve_ricc_impl(A, E, B, C, R, trans=trans, options=options)
+    return solve_ricc_impl(A, E, B, C, R, S, trans=trans, options=options)
 
 
-def _solve_ricc_check_args(A, E, B, C, R, trans):
+def _solve_ricc_check_args(A, E, B, C, R, S, trans):
     assert isinstance(A, Operator) and A.linear
     assert not A.parametric
     assert A.source == A.range
     if E is not None:
         assert isinstance(E, Operator) and E.linear
         assert not E.parametric
         assert E.source == E.range == A.source
@@ -326,7 +351,13 @@
     if R is not None:
         assert isinstance(R, np.ndarray) and R.ndim == 2
         assert R.shape[0] == R.shape[1]
         if not trans:
             assert R.shape[0] == len(C)
         else:
             assert R.shape[0] == len(B)
+    if S is not None:
+        assert S in A.source
+        if not trans:
+            assert len(C) == len(S)
+        else:
+            assert len(B) == len(S)
```

### Comparing `pymor-2022.2.1/src/pymor/algorithms/rules.py` & `pymor-2023.1.0/src/pymor/algorithms/rules.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,13 +1,13 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
-from collections.abc import Iterable, Mapping
 from collections import OrderedDict
+from collections.abc import Iterable, Mapping
 from weakref import WeakValueDictionary
 
 from pymor.core.base import BasicObject, UberMeta, abstractmethod, classinstancemethod
 from pymor.core.exceptions import NoMatchingRuleError, RuleNotMatchingError
 from pymor.operators.interface import Operator
 from pymor.tools.formatsrc import format_source, print_source
 from pymor.tools.table import format_table
@@ -70,14 +70,15 @@
     @property
     def source(self):
         from inspect import getsourcelines
         return ''.join(getsourcelines(self.action)[0])
 
 
 class match_class_base(rule):
+    """Base class for |rules|."""
 
     def __init__(self, *classes):
         super().__init__()
         if not classes:
             raise ValueError('At least one class is required')
         self.classes = classes
         self.condition_description = ', '.join(c.__name__ for c in classes)
@@ -209,26 +210,26 @@
     @classinstancemethod
     def insert_rule(cls, index, rule_):
         assert isinstance(rule_, rule)
         cls.rules.insert(index, rule_)
 
     @insert_rule.instancemethod
     def insert_rule(self, index, rule_):
-        """:noindex:"""
+        """:noindex:"""  # noqa: D400
         assert isinstance(rule_, rule)
         self.rules.insert(index, rule_)
 
     @classinstancemethod
     def append_rule(cls, rule_):
         assert isinstance(rule_, rule)
         cls.rules.append(rule_)
 
     @append_rule.instancemethod
     def append_rule(self, rule_):
-        """:noindex:"""
+        """:noindex:"""  # noqa: D400
         assert isinstance(rule_, rule)
         self.rules.append(rule_)
 
     @classmethod
     def breakpoint_for_obj(cls, obj):
         """Add a conditional breakpoint for given object.
 
@@ -263,19 +264,19 @@
     def apply(self, obj):
         """Sequentially apply rules to given object.
 
         This method iterates over all rules of the given |RuleTable|.
         For each |rule|, it is checked if it :meth:`~rule.matches` the given
         object. If `False`, the next |rule| in the table is considered.
         If `True` the corresponding :attr:`~rule.action` is executed with
-        `obj` as parameter. If execution of :attr:`~action` raises
+        `obj` as parameter. If execution of :attr:`~rule.action` raises
         :class:`~pymor.core.exceptions.RuleNotMatchingError`, the rule is
         considered as not matching, and execution continues with evaluation
         of the next rule. Otherwise, execution is stopped and the return value
-        of :attr:`rule.action` is returned to the caller.
+        of :attr:`~rule.action` is returned to the caller.
 
         If no |rule| matches, a :class:`~pymor.core.exceptions.NoMatchingRuleError`
         is raised.
 
         Parameters
         ----------
         obj
@@ -385,15 +386,15 @@
                         or isinstance(v, (list, tuple)) and all(isinstance(vv, Operator) or vv is None for vv in v)):
                     children.append(k)
             except AttributeError:
                 pass
         return children
 
     def __repr__(self):
-        return super().__repr__() + "\n\n" + format_rules(self.rules)
+        return super().__repr__() + '\n\n' + format_rules(self.rules)
 
 
 def print_children(obj):
     def build_tree(obj):
 
         def process_child(child):
             c = getattr(obj, child)
```

### Comparing `pymor-2022.2.1/src/pymor/algorithms/samdp.py` & `pymor-2023.1.0/src/pymor/algorithms/samdp.py`

 * *Files 0% similar despite different names*

```diff
@@ -205,14 +205,20 @@
                         nres = nrr
                 if nres >= tol:
                     logger.warning('Two-sided RQI did not reach desired tolerance.')
 
             found = nr_converged < nwanted and nres < tol
 
             if found:
+                if np.abs(np.imag(theta)) / np.abs(theta) < imagtol:
+                    schurvec = schurvec.real
+                    lschurvec = lschurvec.real
+                    theta = np.real(theta)
+                    nres = nrr
+
                 poles = np.append(poles, theta)
                 logger.info(f'Pole: {theta:.5e}')
 
                 Q.append(schurvec)
                 Qt.append(lschurvec)
                 Esch = E.apply(schurvec)
                 Qs.append(Esch)
```

### Comparing `pymor-2022.2.1/src/pymor/algorithms/simplify.py` & `pymor-2023.1.0/src/pymor/algorithms/simplify.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,14 +1,14 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 from pymor.algorithms.rules import RuleTable, match_class
 from pymor.models.interface import Model
-from pymor.operators.constructions import LincombOperator, ConcatenationOperator, VectorArrayOperator
+from pymor.operators.constructions import ConcatenationOperator, IdentityOperator, LincombOperator, VectorArrayOperator
 from pymor.operators.interface import Operator, as_array_max_length
 from pymor.operators.numpy import NumpyMatrixOperator
 from pymor.parameters.functionals import ParameterFunctional
 from pymor.vectorarrays.numpy import NumpyVectorSpace
 
 
 def expand(obj):
@@ -70,14 +70,15 @@
     -------
     The transformed object.
     """
     return ContractRules().apply(obj)
 
 
 class ExpandRules(RuleTable):
+    """|RuleTable| for the :func:`expand` algorithm."""
 
     def __init__(self):
         super().__init__(use_caching=True)
 
     @match_class(LincombOperator)
     def action_LincombOperator(self, op):
         # recursively expand all children
@@ -99,20 +100,20 @@
     @match_class(ConcatenationOperator)
     def action_ConcatenationOperator(self, op):
         op = self.replace_children(op)
 
         # merge child ConcatenationOperators
         if any(isinstance(o, ConcatenationOperator) for o in op.operators):
             ops = []
-            for o in ops:
+            for o in op.operators:
                 if isinstance(o, ConcatenationOperator):
                     ops.extend(o.operators)
                 else:
                     ops.append(o)
-            op = op.with_operators(ops)
+            op = op.with_(operators=ops)
 
         # expand concatenations with LincombOperators
         if any(isinstance(o, LincombOperator) for o in op.operators):
             i = next(iter(i for i, o in enumerate(op.operators) if isinstance(o, LincombOperator)))
             left, right = op.operators[:i], op.operators[i+1:]
             ops = [ConcatenationOperator(left + (o,) + right) for o in op.operators[i].operators]
             op = op.operators[i].with_(operators=ops)
@@ -124,14 +125,15 @@
 
     @match_class(Model, Operator)
     def action_recurse(self, op):
         return self.replace_children(op)
 
 
 class ContractRules(RuleTable):
+    """|RuleTable| for the :func:`contract` algorithm."""
 
     def __init__(self):
         super().__init__(use_caching=True)
 
     @match_class(LincombOperator)
     def action_LincombOperator(self, op):
         # recursively contract all children
@@ -166,45 +168,50 @@
             param_ops.append(non_parametric_part)
             param_coeffs.append(1.)
 
         return op.with_(operators=param_ops, coefficients=param_coeffs)
 
     @match_class(ConcatenationOperator)
     def action_ConcatenationOperator(self, op):
+        source_id = op.source.id
+        range_id = op.range.id
+
         op = self.replace_children(op)
 
         ops_rev = list(op.operators[::-1])
         i = 0
         while i + 1 < len(ops_rev):
-            if (ops_rev[i+1].linear and not ops_rev[i+1].parametric):
+            if isinstance(ops_rev[i], IdentityOperator) and len(ops_rev) > 1:
+                del ops_rev[i]
+            elif (ops_rev[i + 1].linear and not ops_rev[i + 1].parametric):
                 if isinstance(ops_rev[i], NumpyMatrixOperator):
                     if not ops_rev[i].sparse:  # do not touch sparse matrices
-                        U = ops_rev[i+1].source.from_numpy(ops_rev[i].matrix.T)
-                        ops_rev[i+1] = VectorArrayOperator(ops_rev[i+1].apply(U))
+                        U = ops_rev[i + 1].source.from_numpy(ops_rev[i].matrix.T)
+                        ops_rev[i + 1] = VectorArrayOperator(ops_rev[i + 1].apply(U), space_id=ops_rev[i].source.id)
                         del ops_rev[i]
                     else:
                         i += 1
                 elif (ops_rev[i].linear and not ops_rev[i].parametric
                       and isinstance(ops_rev[i].source, NumpyVectorSpace)
                       and ops_rev[i].source.dim <= as_array_max_length()):
                     # the following might in fact convert small sparse matrices in external solvers
                     # to dense ...
                     U = ops_rev[i].as_range_array()
-                    ops_rev[i+1] = VectorArrayOperator(ops_rev[i+1].apply(U))
+                    ops_rev[i + 1] = VectorArrayOperator(ops_rev[i + 1].apply(U), space_id=ops_rev[i].source.id)
                     del ops_rev[i]
                 else:
                     i += 1
             else:
                 i += 1
 
         if len(ops_rev) == 1:
             op = ops_rev[0]
             if isinstance(op, VectorArrayOperator) and isinstance(op.array.space, NumpyVectorSpace):
                 array = op.array.to_numpy()
-                op = NumpyMatrixOperator(array if op.adjoint else array.T)
+                op = NumpyMatrixOperator(array if op.adjoint else array.T, source_id=source_id, range_id=range_id)
             return op
 
         op = op.with_(operators=ops_rev[::-1])
 
         return op
 
     @match_class(Model, Operator)
```

### Comparing `pymor-2022.2.1/src/pymor/algorithms/svd_va.py` & `pymor-2023.1.0/src/pymor/algorithms/svd_va.py`

 * *Files identical despite different names*

### Comparing `pymor-2022.2.1/src/pymor/algorithms/sylvester.py` & `pymor-2023.1.0/src/pymor/algorithms/sylvester.py`

 * *Ordering differences only*

 * *Files 0% similar despite different names*

```diff
@@ -1,16 +1,16 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 import scipy.linalg as spla
 
 from pymor.algorithms.to_matrix import to_matrix
-from pymor.operators.interface import Operator
 from pymor.operators.constructions import IdentityOperator
+from pymor.operators.interface import Operator
 
 
 def solve_sylv_schur(A, Ar, E=None, Er=None, B=None, Br=None, C=None, Cr=None):
     r"""Solve Sylvester equation by Schur decomposition.
 
     Solves Sylvester equation
```

### Comparing `pymor-2022.2.1/src/pymor/algorithms/symplectic.py` & `pymor-2023.1.0/src/pymor/algorithms/symplectic.py`

 * *Files 0% similar despite different names*

```diff
@@ -57,15 +57,15 @@
         assert E.space == F.space == phase_space and len(E) == len(F)
         self.__auto_init(locals())
 
         if check_symplecticity and len(E) > 0:
             self._check_symplecticity()
 
     @classmethod
-    def from_array(self, U, check_symplecticity=True):
+    def from_array(cls, U, check_symplecticity=True):
         """Generate |SymplecticBasis| from |VectorArray|.
 
         Parameters
         ----------
         U
             The |VectorArray|.
         check_symplecticity
@@ -158,15 +158,15 @@
         tsi_self = self.transposed_symplectic_inverse()
 
         error_matrix = tsi_self[idx].to_array().inner(self.to_array())
         error_matrix[:, np.hstack([idx, len(self)+idx])] -= np.eye((len(self) - offset)*2)
         if error_matrix.size > 0:
             err = np.max(np.abs(error_matrix))
             if err >= check_tol:
-                raise AccuracyError(f"result not symplectic (max err={err})")
+                raise AccuracyError(f'result not symplectic (max err={err})')
 
     def __getitem__(self, ind):
         assert self.E.check_ind(ind)
         # check_symplecticity = False, otherwise recursion loop
         return type(self)(self.E[ind], self.F[ind], check_symplecticity=False)
 
     def lincomb(self, coefficients):
@@ -189,17 +189,15 @@
             The method used for extension. Available options are
                 ('svd_like', 'complex_svd', 'symplectic_gram_schmidt').
         modes
             Number of modes to extract from U. Has to be even.
         product
             A product to use for the projection error. Default is None.
         """
-        from pymor.algorithms.symplectic import (psd_complex_svd,
-                                                 psd_svd_like_decomp,
-                                                 symplectic_gram_schmidt)
+        from pymor.algorithms.symplectic import psd_complex_svd, psd_svd_like_decomp, symplectic_gram_schmidt
         assert modes % 2 == 0, 'number of modes has to be even'
         assert method in ('svd_like', 'complex_svd', 'symplectic_gram_schmidt')
 
         U_proj_err = U - self.lincomb(U.inner(self.transposed_symplectic_inverse().to_array()))
         proj_error = U_proj_err.norm(product=product)
 
         if method in ('svd_like', 'complex_svd'):
@@ -411,15 +409,15 @@
     Lambda = np.zeros((2*p, 2*p))
     remove = []  # indices of to be removed vectors
     for j in range(offset, p):
         # first calculate symplecticity value
         initial_sympl = abs(J.apply2(E[j], F[j]))
 
         if initial_sympl < atol:
-            logger.info(f"Removing vector pair {j} with symplecticity value {initial_sympl}")
+            logger.info(f'Removing vector pair {j} with symplecticity value {initial_sympl}')
             remove.append(j)
             continue
 
         sympl = initial_sympl
         while True:
             # symplectify to all vectors left
             for i in range(j):
@@ -437,21 +435,21 @@
                 Lambda[np.ix_([i, p+i], [j, p+j])] += P
 
             # calculate new symplectic product
             old_sympl, sympl = sympl, abs(J.apply2(E[j], F[j]))
 
             # remove vector pair if it got a too small symplecticty value
             if sympl < rtol * initial_sympl:
-                logger.info(f"Removing vector pair {j} due to small symplecticty value")
+                logger.info(f'Removing vector pair {j} due to small symplecticty value')
                 remove.append(j)
                 break
 
             # check if reorthogonalization should be done
             if reiterate and sympl < reiteration_threshold * old_sympl:
-                logger.info(f"Symplectifying vector pair {j} again")
+                logger.info(f'Symplectifying vector pair {j} again')
             else:
                 Lambda[np.ix_([j, p+j], [j, p+j])] = esr(E[j], F[j], J)
                 break
 
     if remove:
         del E[remove]
         del F[remove]
@@ -466,15 +464,15 @@
     if return_Lambda:
         return S, Lambda
     else:
         return S
 
 
 def esr(E, F, J=None):
-    """Elemenraty SR factorization. Transforms E and F such that
+    """Elemenraty SR factorization. Transforms E and F such that.
 
         [E, F] = S * diag(r11, r22)
 
     Coefficients are chosen such that ||E|| = ||F||. r12 is set to zero.
 
     Parameters
     ----------
```

### Comparing `pymor-2022.2.1/src/pymor/algorithms/timestepping.py` & `pymor-2023.1.0/src/pymor/algorithms/timestepping.py`

 * *Files 14% similar despite different names*

```diff
@@ -5,47 +5,56 @@
 """Generic time-stepping algorithms for the solution of instationary problems.
 
 The algorithms are generic in the sense that each algorithms operates exclusively
 on |Operators| and |VectorArrays|. In particular, the algorithms
 can also be used to turn an arbitrary stationary |Model| provided
 by an external library into an instationary |Model|.
 
-Currently, implementations of :func:`explicit_euler` and :func:`implicit_euler`
-time-stepping are provided. The :class:`TimeStepper` defines a
-common interface that has to be fulfilled by the time-steppers used
-by |InstationaryModel|. The classes :class:`ExplicitEulerTimeStepper`
-and :class:`ImplicitEulerTimeStepper` encapsulate :func:`explicit_euler` and
-:func:`implicit_euler` to provide this interface.
+The :class:`TimeStepper` defines a common interface that has to be fulfilled by
+the time-steppers used by |InstationaryModel|.
 """
 
 from pymor.core.base import ImmutableObject, abstractmethod
 from pymor.operators.interface import Operator
 from pymor.parameters.base import Mu
 from pymor.vectorarrays.interface import VectorArray
 
 
 class TimeStepper(ImmutableObject):
     """Interface for time-stepping algorithms.
 
-    Algorithms implementing this interface solve time-dependent problems
+    Algorithms implementing this interface solve time-dependent initial value problems
     of the form ::
 
-        M * d_t u + A(u, mu, t) = F(mu, t).
+        M(mu) * d_t u + A(u, mu, t) = F(mu, t),
+                         u(mu, t_0) = u_0(mu).
 
     Time-steppers used by |InstationaryModel| have to fulfill
     this interface.
     """
 
-    @abstractmethod
+    def estimate_time_step_count(self, initial_time, end_time):
+        """Estimate the number of time steps.
+
+        Parameters
+        ----------
+        initial_time
+            The time at which to begin time-stepping.
+        end_time
+            The time until which to perform time-stepping.
+        """
+        raise NotImplementedError
+
     def solve(self, initial_time, end_time, initial_data, operator, rhs=None, mass=None, mu=None, num_values=None):
         """Apply time-stepper to the equation.
 
         The equation is of the form ::
 
-            M * d_t u + A(u, mu, t) = F(mu, t).
+            M(mu) * d_t u + A(u, mu, t) = F(mu, t),
+                             u(mu, t_0) = u_0(mu).
 
         Parameters
         ----------
         initial_time
             The time at which to begin time-stepping.
         end_time
             The time until which to perform time-stepping.
@@ -65,23 +74,72 @@
             The number of returned vectors of the solution trajectory. If `None`, each
             intermediate vector that is calculated is returned.
 
         Returns
         -------
         |VectorArray| containing the solution trajectory.
         """
+        try:
+            num_time_steps = self.estimate_time_step_count(initial_time, end_time)
+        except NotImplementedError:
+            num_time_steps = 0
+        iterator = self.iterate(initial_time, end_time, initial_data, operator, rhs=rhs, mass=mass, mu=mu,
+                                num_values=num_values)
+        U = operator.source.empty(reserve=num_values if num_values else num_time_steps + 1)
+        for U_n, _ in iterator:
+            U.append(U_n)
+        return U
+
+    @abstractmethod
+    def iterate(self, initial_time, end_time, initial_data, operator, rhs=None, mass=None, mu=None, num_values=None):
+        """Iterate time-stepper to the equation.
+
+        The equation is of the form ::
+
+            M(mu) * d_t u + A(u, mu, t) = F(mu, t),
+                             u(mu, t_0) = u_0(mu).
+
+        Parameters
+        ----------
+        initial_time
+            The time at which to begin time-stepping.
+        end_time
+            The time until which to perform time-stepping.
+        initial_data
+            The solution vector at `initial_time`.
+        operator
+            The |Operator| A.
+        rhs
+            The right-hand side F (either |VectorArray| of length 1 or |Operator| with
+            `source.dim == 1`). If `None`, zero right-hand side is assumed.
+        mass
+            The |Operator| M. If `None`, the identity operator is assumed.
+        mu
+            |Parameter values| for which `operator` and `rhs` are evaluated. The current
+            time is added to `mu` with key `t`.
+        num_values
+            The number of returned vectors of the solution trajectory. If `None`, each
+            intermediate vector that is calculated is returned.
+
+        Returns
+        -------
+        Generator yielding tuples (U, t) of snapshots and times.
+        """
         pass
 
 
 class ImplicitEulerTimeStepper(TimeStepper):
     """Implicit Euler time-stepper.
 
     Solves equations of the form ::
 
-        M * d_t u + A(u, mu, t) = F(mu, t).
+        M(mu) * d_t u + A(u, mu, t) = F(mu, t),
+                         u(mu, t_0) = u_0(mu).
+
+    by implicit Euler time integration.
 
     Parameters
     ----------
     nt
         The number of time-steps the time-stepper will perform.
     solver_options
         The |solver_options| used to invert `M + dt*A`.
@@ -89,47 +147,168 @@
         recognized, in which case the solver_options of
         M (resp. A) are used.
     """
 
     def __init__(self, nt, solver_options='operator'):
         self.__auto_init(locals())
 
-    def solve(self, initial_time, end_time, initial_data, operator, rhs=None, mass=None, mu=None, num_values=None):
-        return implicit_euler(operator, rhs, mass, initial_data, initial_time, end_time, self.nt, mu, num_values,
-                              solver_options=self.solver_options)
+    def estimate_time_step_count(self, initial_time, end_time):
+        return self.nt
+
+    def iterate(self, initial_time, end_time, initial_data, operator, rhs=None, mass=None, mu=None, num_values=None):
+        A, F, M, U0, t0, t1, nt = operator, rhs, mass, initial_data, initial_time, end_time, self.nt
+        assert isinstance(A, Operator)
+        assert isinstance(F, (type(None), Operator, VectorArray))
+        assert isinstance(M, (type(None), Operator))
+        assert A.source == A.range
+        num_values = num_values or nt + 1
+        dt = (t1 - t0) / nt
+        DT = (t1 - t0) / (num_values - 1)
+
+        if F is None:
+            F_time_dep = False
+        elif isinstance(F, Operator):
+            assert F.source.dim == 1
+            assert F.range == A.range
+            F_time_dep = _depends_on_time(F, mu)
+            if not F_time_dep:
+                dt_F = F.as_vector(mu) * dt
+        else:
+            assert len(F) == 1
+            assert F in A.range
+            F_time_dep = False
+            dt_F = F * dt
+
+        if M is None:
+            from pymor.operators.constructions import IdentityOperator
+            M = IdentityOperator(A.source)
+
+        assert A.source == M.source == M.range
+        assert not M.parametric
+        assert U0 in A.source
+        assert len(U0) == 1
+
+        num_ret_values = 1
+        yield U0, t0
+
+        options = (A.solver_options if self.solver_options == 'operator' else
+                   M.solver_options if self.solver_options == 'mass' else
+                   self.solver_options)
+        M_dt_A = (M + A * dt).with_(solver_options=options)
+        if not _depends_on_time(M_dt_A, mu):
+            M_dt_A = M_dt_A.assemble(mu)
+
+        t = t0
+        U = U0.copy()
+        if mu is None:
+            mu = Mu()
+
+        for n in range(nt):
+            t += dt
+            mu = mu.with_(t=t)
+            rhs = M.apply(U)
+            if F_time_dep:
+                dt_F = F.as_vector(mu) * dt
+            if F:
+                rhs += dt_F
+            U = M_dt_A.apply_inverse(rhs, mu=mu, initial_guess=U)
+            while t - t0 + (min(dt, DT) * 0.5) >= num_ret_values * DT:
+                num_ret_values += 1
+                yield U, t
 
 
 class ExplicitEulerTimeStepper(TimeStepper):
     """Explicit Euler time-stepper.
 
     Solves equations of the form ::
 
-        M * d_t u + A(u, mu, t) = F(mu, t).
+        M(mu) * d_t u + A(u, mu, t) = F(mu, t),
+                         u(mu, t_0) = u_0(mu).
+
+    by explicit Euler time integration.
 
     Parameters
     ----------
     nt
         The number of time-steps the time-stepper will perform.
     """
 
     def __init__(self, nt):
         self.__auto_init(locals())
 
-    def solve(self, initial_time, end_time, initial_data, operator, rhs=None, mass=None, mu=None, num_values=None):
+    def estimate_time_step_count(self, initial_time, end_time):
+        return self.nt
+
+    def iterate(self, initial_time, end_time, initial_data, operator, rhs=None, mass=None, mu=None, num_values=None):
         if mass is not None:
             raise NotImplementedError
-        return explicit_euler(operator, rhs, initial_data, initial_time, end_time, self.nt, mu, num_values)
+        A, F, U0, t0, t1, nt = operator, rhs, initial_data, initial_time, end_time, self.nt
+        assert isinstance(A, Operator)
+        assert F is None or isinstance(F, (Operator, VectorArray))
+        assert A.source == A.range
+        num_values = num_values or nt + 1
+
+        if isinstance(F, Operator):
+            assert F.source.dim == 1
+            assert F.range == A.range
+            F_time_dep = _depends_on_time(F, mu)
+            if not F_time_dep:
+                F_ass = F.as_vector(mu)
+        elif isinstance(F, VectorArray):
+            assert len(F) == 1
+            assert F in A.range
+            F_time_dep = False
+            F_ass = F
+
+        assert len(U0) == 1
+        assert U0 in A.source
+
+        A_time_dep = _depends_on_time(A, mu)
+        if not A_time_dep:
+            A = A.assemble(mu)
+
+        dt = (t1 - t0) / nt
+        DT = (t1 - t0) / (num_values - 1)
+        num_ret_values = 1
+        yield U0, t0
+
+        t = t0
+        U = U0.copy()
+        if mu is None:
+            mu = Mu()
+
+        if F is None:
+            for n in range(nt):
+                t += dt
+                mu = mu.with_(t=t)
+                U.axpy(-dt, A.apply(U, mu=mu))
+                while t - t0 + (min(dt, DT) * 0.5) >= num_ret_values * DT:
+                    num_ret_values += 1
+                    yield U, t
+        else:
+            for n in range(nt):
+                t += dt
+                mu = mu.with_(t=t)
+                if F_time_dep:
+                    F_ass = F.as_vector(mu)
+                U.axpy(dt, F_ass - A.apply(U, mu=mu))
+                while t - t0 + (min(dt, DT) * 0.5) >= num_ret_values * DT:
+                    num_ret_values += 1
+                    yield U, t
 
 
 class ImplicitMidpointTimeStepper(TimeStepper):
     """Implicit midpoint rule time-stepper. Symplectic integrator + preserves quadratic invariants.
 
     Solves equations of the form ::
 
-        M * d_t u + A(u, mu, t) = F(mu, t).
+        M(mu) * d_t u + A(u, mu, t) = F(mu, t),
+                         u(mu, t_0) = u_0(mu).
+
+    by implicit midpoint time integration.
 
     Parameters
     ----------
     nt
         The number of time-steps the time-stepper will perform.
     solver_options
         The |solver_options| used to invert `M - dt/2*A`.
@@ -137,275 +316,158 @@
         recognized, in which case the solver_options of
         M (resp. A) are used.
     """
 
     def __init__(self, nt, solver_options='operator'):
         self.__auto_init(locals())
 
-    def solve(self, initial_time, end_time, initial_data, operator, rhs=None, mass=None, mu=None, num_values=None):
+    def estimate_time_step_count(self, initial_time, end_time):
+        return self.nt
+
+    def iterate(self, initial_time, end_time, initial_data, operator, rhs=None, mass=None, mu=None, num_values=None):
         if not operator.linear:
             raise NotImplementedError
-        return implicit_midpoint_rule(operator, rhs, mass, initial_data, initial_time, end_time,
-                                      self.nt, mu, num_values, solver_options=self.solver_options)
+        A, F, M, U0, t0, t1, nt = operator, rhs, mass, initial_data, initial_time, end_time, self.nt
+        assert isinstance(A, Operator)
+        assert isinstance(F, (type(None), Operator, VectorArray))
+        assert isinstance(M, (type(None), Operator))
+        assert A.source == A.range
+        num_values = num_values or nt + 1
+        dt = (t1 - t0) / nt
+        DT = (t1 - t0) / (num_values - 1)
+
+        if F is None:
+            F_time_dep = False
+        elif isinstance(F, Operator):
+            assert F.source.dim == 1
+            assert F.range == A.range
+            F_time_dep = _depends_on_time(F, mu)
+            if not F_time_dep:
+                dt_F = F.as_vector(mu) * dt
+        else:
+            assert len(F) == 1
+            assert F in A.range
+            F_time_dep = False
+            dt_F = F * dt
+
+        if M is None:
+            from pymor.operators.constructions import IdentityOperator
+            M = IdentityOperator(A.source)
+
+        assert A.source == M.source == M.range
+        assert not M.parametric
+        assert U0 in A.source
+        assert len(U0) == 1
+
+        num_ret_values = 1
+        yield U0, t0
+
+        if self.solver_options == 'operator':
+            options = A.solver_options
+        elif self.solver_options == 'mass':
+            options = M.solver_options
+        else:
+            options = self.solver_options
+
+        M_dt_A_impl = (M + A * (dt/2)).with_(solver_options=options)
+        if not _depends_on_time(M_dt_A_impl, mu):
+            M_dt_A_impl = M_dt_A_impl.assemble(mu)
+        M_dt_A_expl = (M - A * (dt/2)).with_(solver_options=options)
+        if not _depends_on_time(M_dt_A_expl, mu):
+            M_dt_A_expl = M_dt_A_expl.assemble(mu)
+
+        t = t0
+        U = U0.copy()
+        if mu is None:
+            mu = Mu()
+
+        for n in range(nt):
+            mu = mu.with_(t=t + dt/2)
+            t += dt
+            rhs = M_dt_A_expl.apply(U, mu=mu)
+            if F_time_dep:
+                dt_F = F.as_vector(mu) * dt
+            if F:
+                rhs += dt_F
+            U = M_dt_A_impl.apply_inverse(rhs, mu=mu)
+            while t - t0 + (min(dt, DT) * 0.5) >= num_ret_values * DT:
+                num_ret_values += 1
+                yield U, t
 
 
 class DiscreteTimeStepper(TimeStepper):
     """Discrete time-stepper.
 
     Solves equations of the form ::
 
         M(mu) * u_k+1 + A(u_k, mu, k) = F(mu, k).
+                           u(mu, k_0) = u_0(mu).
+
+    by direct time stepping.
     """
 
     def __init__(self):
         pass
 
-    def solve(self, initial_time, end_time, initial_data, operator, rhs=None, mass=None, mu=None, num_values=None):
-        return discrete(operator, rhs, mass, initial_data, initial_time, end_time, mu, num_values)
-
+    def estimate_time_step_count(self, initial_time, end_time):
+        return end_time - initial_time
 
-def implicit_euler(A, F, M, U0, t0, t1, nt, mu=None, num_values=None, solver_options='operator'):
-    assert isinstance(A, Operator)
-    assert isinstance(F, (type(None), Operator, VectorArray))
-    assert isinstance(M, (type(None), Operator))
-    assert A.source == A.range
-    num_values = num_values or nt + 1
-    dt = (t1 - t0) / nt
-    DT = (t1 - t0) / (num_values - 1)
-
-    if F is None:
-        F_time_dep = False
-    elif isinstance(F, Operator):
-        assert F.source.dim == 1
-        assert F.range == A.range
-        F_time_dep = _depends_on_time(F, mu)
-        if not F_time_dep:
-            dt_F = F.as_vector(mu) * dt
-    else:
-        assert len(F) == 1
-        assert F in A.range
-        F_time_dep = False
-        dt_F = F * dt
-
-    if M is None:
-        from pymor.operators.constructions import IdentityOperator
-        M = IdentityOperator(A.source)
-
-    assert A.source == M.source == M.range
-    assert not M.parametric
-    assert U0 in A.source
-    assert len(U0) == 1
-
-    R = A.source.empty(reserve=num_values)
-    R.append(U0)
-
-    options = (A.solver_options if solver_options == 'operator' else
-               M.solver_options if solver_options == 'mass' else
-               solver_options)
-    M_dt_A = (M + A * dt).with_(solver_options=options)
-    if not _depends_on_time(M_dt_A, mu):
-        M_dt_A = M_dt_A.assemble(mu)
-
-    t = t0
-    U = U0.copy()
-    if mu is None:
-        mu = Mu()
-
-    for n in range(nt):
-        t += dt
-        mu = mu.with_(t=t)
-        rhs = M.apply(U)
-        if F_time_dep:
-            dt_F = F.as_vector(mu) * dt
-        if F:
-            rhs += dt_F
-        U = M_dt_A.apply_inverse(rhs, mu=mu, initial_guess=U)
-        while t - t0 + (min(dt, DT) * 0.5) >= len(R) * DT:
-            R.append(U)
-
-    return R
-
-
-def explicit_euler(A, F, U0, t0, t1, nt, mu=None, num_values=None):
-    assert isinstance(A, Operator)
-    assert F is None or isinstance(F, (Operator, VectorArray))
-    assert A.source == A.range
-    num_values = num_values or nt + 1
-
-    if isinstance(F, Operator):
-        assert F.source.dim == 1
-        assert F.range == A.range
-        F_time_dep = _depends_on_time(F, mu)
-        if not F_time_dep:
-            F_ass = F.as_vector(mu)
-    elif isinstance(F, VectorArray):
-        assert len(F) == 1
-        assert F in A.range
-        F_time_dep = False
-        F_ass = F
-
-    assert len(U0) == 1
-    assert U0 in A.source
-
-    A_time_dep = _depends_on_time(A, mu)
-    if not A_time_dep:
-        A = A.assemble(mu)
-
-    dt = (t1 - t0) / nt
-    DT = (t1 - t0) / (num_values - 1)
-    R = A.source.empty(reserve=num_values)
-    R.append(U0)
-
-    t = t0
-    U = U0.copy()
-    if mu is None:
-        mu = Mu()
-
-    if F is None:
-        for n in range(nt):
-            t += dt
-            mu = mu.with_(t=t)
-            U.axpy(-dt, A.apply(U, mu=mu))
-            while t - t0 + (min(dt, DT) * 0.5) >= len(R) * DT:
-                R.append(U)
-    else:
-        for n in range(nt):
-            t += dt
-            mu = mu.with_(t=t)
+    def iterate(self, initial_time, end_time, initial_data, operator, rhs=None, mass=None, mu=None, num_values=None):
+        A, F, M, U0, k0, k1 = operator, rhs, mass, initial_data, initial_time, end_time
+        assert isinstance(A, Operator)
+        assert isinstance(F, (type(None), Operator, VectorArray))
+        assert isinstance(M, (type(None), Operator))
+        assert A.source == A.range
+        nt = k1 - k0
+        num_values = num_values or nt + 1
+        dt = 1
+        DT = nt / (num_values - 1)
+
+        if F is None:
+            F_time_dep = False
+        elif isinstance(F, Operator):
+            assert F.source.dim == 1
+            assert F.range == A.range
+            F_time_dep = _depends_on_time(F, mu)
+            if not F_time_dep:
+                Fk = F.as_vector(mu)
+        else:
+            assert len(F) == 1
+            assert F in A.range
+            F_time_dep = False
+            Fk = F
+
+        if M is None:
+            from pymor.operators.constructions import IdentityOperator
+            M = IdentityOperator(A.source)
+
+        assert A.source == M.source == M.range
+        assert U0 in A.source
+        assert len(U0) == 1
+
+        num_ret_values = 1
+        yield U0, k0
+
+        if not _depends_on_time(M, mu):
+            M = M.assemble(mu)
+
+        U = U0.copy()
+        if mu is None:
+            mu = Mu()
+
+        for k in range(k0, k0 + nt):
+            mu = mu.with_(t=k)
+            rhs = -A.apply(U, mu=mu)
             if F_time_dep:
-                F_ass = F.as_vector(mu)
-            U.axpy(dt, F_ass - A.apply(U, mu=mu))
-            while t - t0 + (min(dt, DT) * 0.5) >= len(R) * DT:
-                R.append(U)
-
-    return R
-
-
-def implicit_midpoint_rule(A, F, M, U0, t0, t1, nt, mu=None, num_values=None, solver_options='operator'):
-    assert isinstance(A, Operator)
-    assert isinstance(F, (type(None), Operator, VectorArray))
-    assert isinstance(M, (type(None), Operator))
-    assert A.source == A.range
-    num_values = num_values or nt + 1
-    dt = (t1 - t0) / nt
-    DT = (t1 - t0) / (num_values - 1)
-
-    if F is None:
-        F_time_dep = False
-    elif isinstance(F, Operator):
-        assert F.source.dim == 1
-        assert F.range == A.range
-        F_time_dep = _depends_on_time(F, mu)
-        if not F_time_dep:
-            dt_F = F.as_vector(mu) * dt
-    else:
-        assert len(F) == 1
-        assert F in A.range
-        F_time_dep = False
-        dt_F = F * dt
-
-    if M is None:
-        from pymor.operators.constructions import IdentityOperator
-        M = IdentityOperator(A.source)
-
-    assert A.source == M.source == M.range
-    assert not M.parametric
-    assert U0 in A.source
-    assert len(U0) == 1
-
-    R = A.source.empty(reserve=num_values)
-    R.append(U0)
-
-    if solver_options == 'operator':
-        options = A.solver_options
-    elif solver_options == 'mass':
-        options = M.solver_options
-    else:
-        options = solver_options
-
-    M_dt_A_impl = (M + A * (dt/2)).with_(solver_options=options)
-    if not _depends_on_time(M_dt_A_impl, mu):
-        M_dt_A_impl = M_dt_A_impl.assemble(mu)
-    M_dt_A_expl = (M - A * (dt/2)).with_(solver_options=options)
-    if not _depends_on_time(M_dt_A_expl, mu):
-        M_dt_A_expl = M_dt_A_expl.assemble(mu)
-
-    t = t0
-    U = U0.copy()
-    if mu is None:
-        mu = Mu()
-
-    for n in range(nt):
-        mu = mu.with_(t=t + dt/2)
-        t += dt
-        rhs = M_dt_A_expl.apply(U, mu=mu)
-        if F_time_dep:
-            dt_F = F.as_vector(mu) * dt
-        if F:
-            rhs += dt_F
-        U = M_dt_A_impl.apply_inverse(rhs, mu=mu)
-        while t - t0 + (min(dt, DT) * 0.5) >= len(R) * DT:
-            R.append(U)
-
-    return R
-
-
-def discrete(A, F, M, U0, k0, k1, mu=None, num_values=None):
-    assert isinstance(A, Operator)
-    assert isinstance(F, (type(None), Operator, VectorArray))
-    assert isinstance(M, (type(None), Operator))
-    assert A.source == A.range
-    nt = k1 - k0
-    num_values = num_values or nt + 1
-    dt = 1
-    DT = nt / (num_values - 1)
-
-    if F is None:
-        F_time_dep = False
-    elif isinstance(F, Operator):
-        assert F.source.dim == 1
-        assert F.range == A.range
-        F_time_dep = _depends_on_time(F, mu)
-        if not F_time_dep:
-            Fk = F.as_vector(mu)
-    else:
-        assert len(F) == 1
-        assert F in A.range
-        F_time_dep = False
-        Fk = F
-
-    if M is None:
-        from pymor.operators.constructions import IdentityOperator
-        M = IdentityOperator(A.source)
-
-    assert A.source == M.source == M.range
-    assert U0 in A.source
-    assert len(U0) == 1
-
-    R = A.source.empty(reserve=num_values)
-    R.append(U0)
-
-    if not _depends_on_time(M, mu):
-        M = M.assemble(mu)
-
-    U = U0.copy()
-    if mu is None:
-        mu = Mu()
-
-    for k in range(k0, k0 + nt):
-        mu = mu.with_(t=k)
-        rhs = -A.apply(U, mu=mu)
-        if F_time_dep:
-            Fk = F.as_vector(mu)
-        if F:
-            rhs += Fk
-        U = M.apply_inverse(rhs, mu=mu, initial_guess=U)
-        while k - k0 + 1 + (min(dt, DT) * 0.5) >= len(R) * DT:
-            R.append(U)
-
-    return R
+                Fk = F.as_vector(mu)
+            if F:
+                rhs += Fk
+            U = M.apply_inverse(rhs, mu=mu, initial_guess=U)
+            while k - k0 + 1 + (min(dt, DT) * 0.5) >= num_ret_values * DT:
+                num_ret_values += 1
+                yield U, k
 
 
 def _depends_on_time(obj, mu):
     if not mu:
         return False
     return 't' in obj.parameters or any(mu.is_time_dependent(k) for k in obj.parameters)
```

### Comparing `pymor-2022.2.1/src/pymor/algorithms/to_matrix.py` & `pymor-2023.1.0/src/pymor/algorithms/to_matrix.py`

 * *Files 2% similar despite different names*

```diff
@@ -3,21 +3,30 @@
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 import numpy as np
 import scipy.linalg as spla
 import scipy.sparse as sps
 import scipy.sparse.linalg as spsla
 
-from pymor.algorithms.rules import RuleTable, match_class, match_always
+from pymor.algorithms.rules import RuleTable, match_always, match_class
 from pymor.core.config import config
 from pymor.core.exceptions import RuleNotMatchingError
 from pymor.operators.block import BlockOperatorBase
-from pymor.operators.constructions import (AdjointOperator, ComponentProjectionOperator, ConcatenationOperator,
-                                           IdentityOperator, LincombOperator, LowRankOperator, LowRankUpdatedOperator,
-                                           NumpyConversionOperator, VectorArrayOperator, ZeroOperator)
+from pymor.operators.constructions import (
+    AdjointOperator,
+    ComponentProjectionOperator,
+    ConcatenationOperator,
+    IdentityOperator,
+    LincombOperator,
+    LowRankOperator,
+    LowRankUpdatedOperator,
+    NumpyConversionOperator,
+    VectorArrayOperator,
+    ZeroOperator,
+)
 from pymor.operators.interface import as_array_max_length
 from pymor.operators.numpy import NumpyHankelOperator, NumpyMatrixOperator
 from pymor.vectorarrays.numpy import NumpyVectorSpace
 
 
 def to_matrix(op, format=None, mu=None):
     """Convert a linear |Operator| to a matrix.
@@ -42,14 +51,15 @@
     assert format is None or format in ('dense', 'bsr', 'coo', 'csc', 'csr', 'dia', 'dok', 'lil')
     assert op.linear
     op = op.assemble(mu)
     return ToMatrixRules(format, mu).apply(op)
 
 
 class ToMatrixRules(RuleTable):
+    """|RuleTable| for the :func:`to_matrix` algorithm."""
 
     def __init__(self, format, mu):
         super().__init__()
         self.__auto_init(locals())
 
     @match_class(NumpyHankelOperator)
     def action_NumpyHankelOperator(self, op):
```

### Comparing `pymor-2022.2.1/src/pymor/analyticalproblems/burgers.py` & `pymor-2023.1.0/src/pymor/analyticalproblems/burgers.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
+from pymor.analyticalproblems.domaindescriptions import CircleDomain, LineDomain, RectDomain, TorusDomain
 from pymor.analyticalproblems.elliptic import StationaryProblem
-from pymor.analyticalproblems.domaindescriptions import LineDomain, RectDomain, TorusDomain, CircleDomain
-from pymor.analyticalproblems.instationary import InstationaryProblem
 from pymor.analyticalproblems.functions import ConstantFunction, ExpressionFunction
+from pymor.analyticalproblems.instationary import InstationaryProblem
 
 
 def burgers_problem(v=1., circle=True, initial_data_type='sin', parameter_range=(1., 2.)):
     """One-dimensional Burgers-type problem.
 
     The problem is to solve ::
 
@@ -88,33 +88,33 @@
         Type of initial data (`'sin'` or `'bump'`).
     parameter_range
         The interval in which  is allowed to vary.
     """
     assert initial_data_type in ('sin', 'bump')
 
     if initial_data_type == 'sin':
-        initial_data = ExpressionFunction("0.5 * (sin(2 * pi * x[0]) * sin(2 * pi * x[1]) + 1.)", 2)
+        initial_data = ExpressionFunction('0.5 * (sin(2 * pi * x[0]) * sin(2 * pi * x[1]) + 1.)', 2)
         dirichlet_data = ConstantFunction(dim_domain=2, value=0.5)
     else:
-        initial_data = ExpressionFunction("(x[0] >= 0.5) * (x[0] <= 1) * 1", 2)
+        initial_data = ExpressionFunction('(x[0] >= 0.5) * (x[0] <= 1) * 1', 2)
         dirichlet_data = ConstantFunction(dim_domain=2, value=0.)
 
     return InstationaryProblem(
 
         StationaryProblem(
             domain=TorusDomain([[0, 0], [2, 1]]) if torus else RectDomain([[0, 0], [2, 1]], right=None, top=None),
 
             dirichlet_data=dirichlet_data,
 
             rhs=None,
 
-            nonlinear_advection=ExpressionFunction("abs(x[0])**exponent * v",
+            nonlinear_advection=ExpressionFunction('abs(x[0])**exponent * v',
                                                    1, {'exponent': 1}, {'v': [vx, vy]}),
 
-            nonlinear_advection_derivative=ExpressionFunction("exponent * abs(x[0])**(exponent-1) * sign(x[0]) * v",
+            nonlinear_advection_derivative=ExpressionFunction('exponent * abs(x[0])**(exponent-1) * sign(x[0]) * v',
                                                               1, {'exponent': 1}, {'v': [vx, vy]}),
         ),
 
         initial_data=initial_data,
 
         T=0.3,
```

### Comparing `pymor-2022.2.1/src/pymor/analyticalproblems/domaindescriptions.py` & `pymor-2023.1.0/src/pymor/analyticalproblems/domaindescriptions.py`

 * *Files 0% similar despite different names*

```diff
@@ -5,15 +5,14 @@
 from collections import defaultdict
 from itertools import chain
 
 import numpy as np
 
 from pymor.core.base import ImmutableObject
 
-
 KNOWN_BOUNDARY_TYPES = {'dirichlet', 'neumann', 'robin'}
 
 
 class DomainDescription(ImmutableObject):
     """Describes a geometric domain along with its boundary.
 
     Attributes
```

### Comparing `pymor-2022.2.1/src/pymor/analyticalproblems/elliptic.py` & `pymor-2023.1.0/src/pymor/analyticalproblems/elliptic.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,14 +1,14 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 import numpy as np
 
-from pymor.parameters.base import ParametricObject, ParameterSpace
+from pymor.parameters.base import ParameterSpace, ParametricObject
 from pymor.tools.frozendict import FrozenDict
 
 
 class StationaryProblem(ParametricObject):
     """Linear elliptic problem description.
 
     The problem consists in solving ::
@@ -52,14 +52,16 @@
         defining the type of functional to assemble and `data` is a |Function| holding
         the corresponding coefficient function. Currently implemented `functional_types`
         are:
 
             :l2:            Evaluate the l2-product with the given data function.
             :l2_boundary:   Evaluate the l2-product with the given data function
                             on the boundary.
+            :quadratic:     Evaluate the integral of the data function scaled by
+                            the squared solution (u, u).
     parameter_ranges
         Ranges of interest for the |Parameters| of the problem.
     name
         Name of the problem.
 
     Attributes
     ----------
@@ -106,15 +108,16 @@
                 or dirichlet_data.dim_domain == domain.dim and dirichlet_data.shape_range == ())
         assert (neumann_data is None
                 or neumann_data.dim_domain == domain.dim and neumann_data.shape_range == ())
         assert (robin_data is None
                 or (isinstance(robin_data, tuple) and len(robin_data) == 2
                     and np.all([f.dim_domain == domain.dim and f.shape_range == () for f in robin_data])))
         assert (outputs is None
-                or all(isinstance(v, tuple) and len(v) == 2 and v[0] in ('l2', 'l2_boundary')
+                or all(isinstance(v, tuple) and len(v) == 2
+                       and v[0] in ('l2', 'l2_boundary', 'quadratic')
                        and v[1].dim_domain == domain.dim and v[1].shape_range == () for v in outputs))
         assert (parameter_ranges is None
                 or (isinstance(parameter_ranges, (list, tuple))
                     and len(parameter_ranges) == 2
                     and parameter_ranges[0] <= parameter_ranges[1])
                 or (isinstance(parameter_ranges, dict)
                     and all(isinstance(v, (list, tuple)) and len(v) == 2 and v[0] <= v[1]
```

### Comparing `pymor-2022.2.1/src/pymor/analyticalproblems/expressions.py` & `pymor-2023.1.0/src/pymor/analyticalproblems/expressions.py`

 * *Files 2% similar despite different names*

```diff
@@ -15,15 +15,15 @@
 - meaningful error messages are generated at parse time of the `str` expression,
   instead of hard-to-debug errors in lambda functions at evaluation time,
 - expressions are automatically correctly vectorized. In particular, there is no
   longer a need to add `...` to indexing expressions,
 - the shape of the resulting expressions is automatically determined.
 
 In the future, we will also provide support for symbolic differentiation of the
-given :class:`Expressions`.
+given :class:`Expression`.
 
 Every :class:`Expression` is built from the following atoms:
 
 - a :class:`Constant`, which is a fixed value of arbitrary shape,
 - a :class:`Parameter`, which is a variable of a fixed one-dimensional shape.
 
 Note that both |Parameters| and input variables are treated as a :class:`Parameter`
@@ -41,22 +41,23 @@
 
 For binary operations of :class:`Expressions <Expression>` of different shape,
 the usual broadcasting rules apply.
 """
 
 
 import ast
-from numbers import Number
 import operator
+from functools import reduce
 from itertools import zip_longest
+from numbers import Number
+
 import numpy as np
 
-from pymor.parameters.base import ParametricObject
 from pymor.core.config import config
-
+from pymor.parameters.base import ParametricObject
 
 builtin_max = max
 
 
 def parse_expression(expression, parameters={}, values={}):
     if isinstance(expression, Expression):
         return expression
@@ -68,52 +69,63 @@
     def parse_value(val):
         val = np.vectorize(lambda x: x if isinstance(x, Expression) else Constant(x))(val)
         return Array(val) if val.shape else val.item()
 
     values = {name: parse_value(val) for name, val in values.items()}
 
     # parse Expression
-    tree = ast.parse(expression, mode='eval')
+    try:
+        tree = ast.parse(expression, mode='eval')
+    except SyntaxError as e:
+        raise ValueError(f"""
+Expression
+\t{expression}
+is malformed. The following error occurred:
+\t{e}
+""") from e
 
     # check if all names in given Expression are valid
     names = {node.id for node in ast.walk(tree) if isinstance(node, ast.Name)}
     for name in names:
         if not ((name in globals() and isinstance(globals()[name], type) and issubclass(globals()[name], Expression))
                 or (name in globals() and isinstance(globals()[name], Expression))
                 or name in parameters
                 or name in values):
             raise ValueError(f'Unknown name "{name}" in expression "{expression}"')
 
     # wrap all literals as Expressions
     transformed_tree = TransformLiterals().visit(tree)
+    # handle chained comparisons
+    transformed_tree = TransformChainedComparison().visit(transformed_tree)
     ast.fix_missing_locations(transformed_tree)
 
     # evaluate expression
     code = compile(transformed_tree, 'expression', mode='eval')
     try:
         expression = eval(code, dict(globals(), **values), locals_dict)
     except ValueError as e:
-        raise ValueError(f'''
+        raise ValueError(f"""
 While parsing expression
 \t{expression}
-with parameters {parameters} and values {values} the following error occured:
+with parameters {parameters} and values {values} the following error occurred:
 \t{e}
-''') from e
+""") from e
 
     if not isinstance(expression, Expression):
-        raise ValueError(f'''
+        raise ValueError(f"""
 Malformed expression
 \t{expression}
 evaluates to {type(expression).__name__} instead of Expression object.
-''')
+""")
 
     return expression
 
 
 class TransformLiterals(ast.NodeTransformer):
+    """Transformer for literals."""
 
     in_subscript = False
 
     def visit_Constant(self, node):
         if self.in_subscript:
             return node
         return ast.Call(ast.Name('Constant', ast.Load()),
@@ -131,16 +143,32 @@
         return ast.Subscript(base, slice, node.ctx)
 
     def visit_List(self, node):
         return ast.Call(ast.Name('Array', ast.Load()),
                         [self.generic_visit(node)], [])
 
 
+class TransformChainedComparison(ast.NodeTransformer):
+    """Transformer for chained comparisons."""
+
+    def visit_Compare(self, node):
+        comparators = [node.left] + node.comparators
+        operators = node.ops
+        comparisons = []
+        # transform chained comparisons to sequence of simple comparisons
+        for i, op in enumerate(operators):
+            comparisons.append(ast.Compare(self.generic_visit(comparators[i]),
+                                           [self.generic_visit(operators[i])],
+                                           [self.generic_visit(comparators[i+1])]))
+        # join simple comparisons with multiplication
+        return reduce(lambda left, right: ast.BinOp(left, ast.Mult(), right), comparisons)
+
+
 class Expression(ParametricObject):
-    """A symbolic math expression
+    """A symbolic math expression.
 
     Attributes
     ----------
     shape
         The shape of the object this expression evaluates to
         in the sense of |NumPy|.
     """
@@ -660,16 +688,16 @@
             raise ValueError
         self.arg = arg
         self.shape = arg.shape[:-1]
 
     def fenics_expr(self, params):
         if len(self.shape) > 1:
             raise NotImplementedError
-        import ufl
         import dolfin
+        import ufl
         arg = self.arg.fenics_expr(params)
         assert arg.shape == (2,)
         return np.array(
             [ufl.atan_2(arg[1], arg[0]) + ufl.lt(ufl.atan_2(arg[1], arg[0]), 0) * dolfin.Constant(2*np.pi)]
         ).reshape(())
```

### Comparing `pymor-2022.2.1/src/pymor/analyticalproblems/functions.py` & `pymor-2023.1.0/src/pymor/analyticalproblems/functions.py`

 * *Files 2% similar despite different names*

```diff
@@ -6,15 +6,15 @@
 
 import numpy as np
 from scipy.linalg import solve, solve_triangular
 
 from pymor.analyticalproblems.expressions import parse_expression
 from pymor.core.base import abstractmethod
 from pymor.core.config import config
-from pymor.parameters.base import ParametricObject, Mu
+from pymor.parameters.base import Mu, ParametricObject
 from pymor.parameters.functionals import ParameterFunctional
 
 
 class Function(ParametricObject):
     """Interface for |Parameter| dependent analytical functions.
 
     Every |Function| is a map of the form ::
@@ -50,14 +50,33 @@
         """Evaluate the function for given argument `x` and |parameter values| `mu`."""
         pass
 
     def __call__(self, x, mu=None):
         """Shorthand for :meth:`~Function.evaluate`."""
         return self.evaluate(x, mu)
 
+    def to_fenics(self, mesh):
+        """Convert to ufl expression over dolfin mesh.
+
+        Parameters
+        ----------
+        mesh
+            The dolfin mesh object.
+
+        Returns
+        -------
+        coeffs
+            |NumPy array| of shape `self.shape_range` where each entry is an ufl
+            expression.
+        params
+            Dict mapping parameter names to lists of dolfin `Constants` which are
+            used in the ufl expressions for the corresponding parameter values.
+        """
+        raise NotImplementedError(f'Conversion to UFL expression not implemented for {type(self).__name__}')
+
     def _add_sub(self, other, sign):
         if isinstance(other, Number) and other == 0:
             return self
         elif not isinstance(other, Function):
             other = np.array(other)
             assert other.shape == self.shape_range
             if np.all(other == 0.):
@@ -129,15 +148,15 @@
     __rmul__ = __mul__
 
     def __neg__(self):
         return LincombFunction([self], [-1.])
 
 
 class ConstantFunction(Function):
-    """A constant |Function|
+    """A constant |Function|.
 
     Defined as ::
 
         f: R^d -> R^shape(c), f(x) = c
 
     Parameters
     ----------
@@ -164,30 +183,14 @@
         assert x.shape[-1] == self.dim_domain
         if x.ndim == 1:
             return np.array(self.value)
         else:
             return np.tile(self.value, x.shape[:-1] + (1,) * len(self.shape_range))
 
     def to_fenics(self, mesh):
-        """Convert to ufl expression over dolfin mesh.
-
-        Parameters
-        ----------
-        mesh
-            The dolfin mesh object.
-
-        Returns
-        -------
-        coeffs
-            |NumPy array| of shape `self.shape_range` where each entry is an ufl
-            expression.
-        params
-            Dict mapping parameter names to lists of dolfin `Constants` which are
-            used in the ufl expressions for the corresponding parameter values.
-        """
         config.require('FENICS')
         from dolfin import Constant
         return np.vectorize(Constant)(self.value), {}
 
 
 class GenericFunction(Function):
     """Wrapper making an arbitrary Python function between |NumPy arrays| a proper |Function|.
@@ -241,22 +244,54 @@
         if v.shape != x.shape[:-1] + self.shape_range:
             assert v.shape[:len(x.shape) - 1] == x.shape[:-1]
             v = v.reshape(x.shape[:-1] + self.shape_range)
 
         return v
 
 
-class ExpressionFunction(GenericFunction):
+class SymbolicExpressionFunction(GenericFunction):
+    """Turns a sympbolic expression into a |Function|.
+
+    Parameters
+    ----------
+    expression
+        The :class:`pymor.analyticalproblems.expressions.Expression`.
+    dim_domain
+        The dimension of the domain.
+    variable
+        Name of the input variable in the given expression.
+    name
+        The name of the function.
+    """
+
+    def __init__(self, expression_obj, dim_domain=1, variable='x', name=None):
+        assert variable not in expression_obj.parameters or expression_obj.parameters[variable] == dim_domain
+        params = {k: v for k, v in expression_obj.parameters.items() if k != variable}
+        super().__init__(expression_obj.to_numpy([variable]), dim_domain, expression_obj.shape, params, name)
+        self.__auto_init(locals())
+
+    def to_fenics(self, mesh):
+        return self.expression_obj.to_fenics(mesh)
+
+    def __reduce__(self):
+        return (SymbolicExpressionFunction,
+                (self.expression_obj, self.dim_domain, self.variable, getattr(self, '_name', None)))
+
+    def __str__(self):
+        return f'{self.name}: {self.variable} -> {self.expression_obj}'
+
+
+class ExpressionFunction(SymbolicExpressionFunction):
     """Turns a Python expression given as a string into a |Function|.
 
     Some |NumPy| arithmetic functions like 'sin', 'log', 'min' are supported.
     For a full list see the `functions` class attribute.
 
     .. warning::
-       :meth:`eval` is used to evaluate the given expression.
+       :func:`eval` is used to evaluate the given expression.
        Using this class with expression strings from untrusted sources will cause
        mayhem and destruction!
 
     Parameters
     ----------
     expression
         A Python expression of one variable and the `parameters`, given as a `str`.
@@ -272,38 +307,18 @@
     name
         The name of the function.
     """
 
     def __init__(self, expression, dim_domain=1, parameters={}, values={}, variable='x', name=None):
         params = parameters.copy()
         params[variable] = dim_domain
-        self.expression_obj = parse_expression(expression, parameters=params, values=values)
-        super().__init__(self.expression_obj.to_numpy([variable]),
-                         dim_domain, self.expression_obj.shape, parameters, name)
+        expression_obj = parse_expression(expression, parameters=params, values=values)
+        super().__init__(expression_obj, dim_domain, variable, name)
         self.__auto_init(locals())
 
-    def to_fenics(self, mesh):
-        """Convert to ufl expression over dolfin mesh.
-
-        Parameters
-        ----------
-        mesh
-            The dolfin mesh object.
-
-        Returns
-        -------
-        coeffs
-            |NumPy array| of shape `self.shape_range` where each entry is an ufl
-            expression.
-        params
-            Dict mapping parameter names to lists of dolfin `Constants` which are
-            used in the ufl expressions for the corresponding parameter values.
-        """
-        return self.expression_obj.to_fenics(mesh)
-
     def __reduce__(self):
         return (ExpressionFunction,
                 (self.expression, self.dim_domain, self.parameters, self.values, self.variable,
                  getattr(self, '_name', None)))
 
     def __str__(self):
         return f'{self.name}: {self.variable} -> {self.expression}'
@@ -405,16 +420,16 @@
         bounding_box = bounding_box or [[0., 0.], [1., 1.]]
         range = range or [0., 1.]
         try:
             from PIL import Image
         except ImportError as e:
             raise ImportError("PIL is needed for loading images. Try 'pip install pillow'") from e
         img = Image.open(filename)
-        if not img.mode == "L":
-            self.logger.warning("Image " + filename + " not in grayscale mode. Converting to grayscale.")
+        if not img.mode == 'L':
+            self.logger.warning('Image ' + filename + ' not in grayscale mode. Converting to grayscale.')
             img = img.convert('L')
         self.__auto_init(locals())
         self.bitmap = np.array(img).T[:, ::-1]
         self.lower_left = np.array(bounding_box[0])
         self.size = np.array(bounding_box[1] - self.lower_left)
 
     def evaluate(self, x, mu=None):
@@ -425,40 +440,40 @@
              + self.range[0])
         return F
 
 
 class EmpiricalInterpolatedFunction(LincombFunction):
     """Empirically interpolated |Function|.
 
-    Instantiated by :func:`~pymor.algorithm.ei.interpolate_function`.
+    Instantiated by :func:`~pymor.algorithms.ei.interpolate_function`.
 
     Parameters
     ----------
     function
         The |Function| to interpolate.
     interpolation_points
         |NumPy array| containing the coordinates at which the function
         is interpolated. Typically `X[dofs]` where `X` is the array of
         evaluation points used for snapshot data generation and `dofs`
-        is returned by :func:`~pymor.algorithm.ei.ei_greedy`.
+        is returned by :func:`~pymor.algorithms.ei.ei_greedy`.
     interpolation_matrix
         The interpolation matrix corresponding to the selected interpolation
         basis vectors and `interpolation_points` as returned by
         :func:`pymor.algorithms.ei.ei_greedy`.
     triangular
         Whether or not `interpolation_matrix` is lower triangular with unit
         diagonal.
     snapshot_mus
         List of |parameter values| for which the snapshot data for
         :func:`pymor.algorithms.ei.ei_greedy` has been computed.
     snapshot_coefficients
         Matrix of linear coefficients s.t. the i-th interpolation basis vector
         is given by a linear combination of the functions corresponding to
         `snapshot_mus` with the i-th row of `snapshot_coefficients` as
-        coefficients. Returned by :func:`~pymor.algorithm.ei.ei_greedy` as
+        coefficients. Returned by :func:`~pymor.algorithms.ei.ei_greedy` as
         `data['coefficients']`.
     evaluation_points
         Optional |NumPy array| of coordinates at which the function has been
         evaluated to obtain the snapshot data. If the same evaluation points
         are used to evaluate :class:`EmpiricalInterpolatedFunction`, then
         re-evaluation of the snapshot data at the evaluation points can be
         avoided, when this argument is specified together with `basis_evaluations`.
```

### Comparing `pymor-2022.2.1/src/pymor/analyticalproblems/helmholtz.py` & `pymor-2023.1.0/src/pymor/analyticalproblems/helmholtz.py`

 * *Files identical despite different names*

### Comparing `pymor-2022.2.1/src/pymor/analyticalproblems/instationary.py` & `pymor-2023.1.0/src/pymor/analyticalproblems/instationary.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,12 +1,12 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
-from pymor.parameters.base import ParametricObject, ParameterSpace
+from pymor.parameters.base import ParameterSpace, ParametricObject
 from pymor.tools.frozendict import FrozenDict
 
 
 class InstationaryProblem(ParametricObject):
     """Instationary problem description.
 
     This class describes an instationary problem of the form ::
```

### Comparing `pymor-2022.2.1/src/pymor/analyticalproblems/text.py` & `pymor-2023.1.0/src/pymor/analyticalproblems/text.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 import warnings
 
 from pymor.analyticalproblems.domaindescriptions import RectDomain
 from pymor.analyticalproblems.elliptic import StationaryProblem
-from pymor.analyticalproblems.functions import ConstantFunction, LincombFunction, BitmapFunction
+from pymor.analyticalproblems.functions import BitmapFunction, ConstantFunction, LincombFunction
 from pymor.core.defaults import defaults
 from pymor.parameters.functionals import ProjectionParameterFunctional
 from pymor.tools.io import safe_temporary_filename
 
 
 @defaults('font_name')
 def text_problem(text='pyMOR', font_name=None):
```

### Comparing `pymor-2022.2.1/src/pymor/analyticalproblems/thermalblock.py` & `pymor-2023.1.0/src/pymor/analyticalproblems/thermalblock.py`

 * *Files 3% similar despite different names*

```diff
@@ -44,19 +44,19 @@
         return ProjectionParameterFunctional('diffusion',
                                              size=num_blocks[0]*num_blocks[1],
                                              index=ix + iy*num_blocks[0],
                                              name=f'diffusion_{ix}_{iy}')
 
     def diffusion_function_factory(ix, iy):
         if ix + 1 < num_blocks[0]:
-            X = '(x[0] >= ix * dx) * (x[0] < (ix + 1) * dx)'
+            X = '(ix * dx <= x[0] < (ix + 1) * dx)'
         else:
             X = '(x[0] >= ix * dx)'
         if iy + 1 < num_blocks[1]:
-            Y = '(x[1] >= iy * dy) * (x[1] < (iy + 1) * dy)'
+            Y = '(iy * dy <= x[1] < (iy + 1) * dy)'
         else:
             Y = '(x[1] >= iy * dy)'
         return ExpressionFunction(f'{X} * {Y} * 1.',
                                   2, {}, {'ix': ix, 'iy': iy, 'dx': 1. / num_blocks[0], 'dy': 1. / num_blocks[1]},
                                   name=f'diffusion_{ix}_{iy}')
 
     return StationaryProblem(
```

### Comparing `pymor-2022.2.1/src/pymor/basic.py` & `pymor-2023.1.0/src/pymor/basic.py`

 * *Files 20% similar despite different names*

```diff
@@ -6,78 +6,102 @@
 
 You can use ``from pymor.basic import *`` in interactive session
 to have the most important parts of pyMOR directly available.
 """
 
 # flake8: noqa
 
-from pymor.algorithms.basic import almost_equal, relative_error, project_array
+from pymor.algorithms.adaptivegreedy import rb_adaptive_greedy
+from pymor.algorithms.basic import almost_equal, project_array, relative_error
 from pymor.algorithms.dmd import dmd
-from pymor.algorithms.ei import interpolate_operators, interpolate_function, ei_greedy, deim
-from pymor.algorithms.error import plot_reduction_error_analysis, reduction_error_analysis
+from pymor.algorithms.ei import (deim, ei_greedy, interpolate_function,
+                                 interpolate_operators)
+from pymor.algorithms.error import (plot_reduction_error_analysis,
+                                    reduction_error_analysis)
 from pymor.algorithms.gram_schmidt import gram_schmidt, gram_schmidt_biorth
 from pymor.algorithms.greedy import rb_greedy
-from pymor.algorithms.adaptivegreedy import rb_adaptive_greedy
 from pymor.algorithms.newton import newton
 from pymor.algorithms.pod import pod
 from pymor.algorithms.preassemble import preassemble
 from pymor.algorithms.projection import project, project_to_subbasis
 from pymor.algorithms.simplify import expand
-
-from pymor.analyticalproblems.burgers import burgers_problem, burgers_problem_2d
-from pymor.analyticalproblems.domaindescriptions import (RectDomain, CylindricalDomain, TorusDomain, LineDomain,
-                                                         CircleDomain)
-from pymor.analyticalproblems.domaindescriptions import DiscDomain, CircularSectorDomain, PolygonalDomain
+from pymor.analyticalproblems.burgers import (burgers_problem,
+                                              burgers_problem_2d)
+from pymor.analyticalproblems.domaindescriptions import (CircleDomain,
+                                                         CircularSectorDomain,
+                                                         CylindricalDomain,
+                                                         DiscDomain,
+                                                         LineDomain,
+                                                         PolygonalDomain,
+                                                         RectDomain,
+                                                         TorusDomain)
 from pymor.analyticalproblems.elliptic import StationaryProblem
-from pymor.analyticalproblems.functions import (ConstantFunction, GenericFunction, ExpressionFunction, LincombFunction,
-                                                BitmapFunction)
+from pymor.analyticalproblems.functions import (BitmapFunction,
+                                                ConstantFunction,
+                                                ExpressionFunction,
+                                                GenericFunction,
+                                                LincombFunction)
 from pymor.analyticalproblems.helmholtz import helmholtz_problem
 from pymor.analyticalproblems.instationary import InstationaryProblem
-from pymor.analyticalproblems.thermalblock import thermal_block_problem
 from pymor.analyticalproblems.text import text_problem
-
-from pymor.core.cache import clear_caches, enable_caching, disable_caching
-from pymor.core.defaults import print_defaults, write_defaults_to_file, load_defaults_from_file, set_defaults
-from pymor.core.logger import set_log_levels, getLogger
+from pymor.analyticalproblems.thermalblock import thermal_block_problem
+from pymor.core.cache import clear_caches, disable_caching, enable_caching
+from pymor.core.defaults import (load_defaults_from_file, print_defaults,
+                                 set_defaults, write_defaults_to_file)
+from pymor.core.exceptions import DependencyMissingError
+from pymor.core.logger import getLogger, set_log_levels
 from pymor.core.pickle import dump, dumps, load, loads
-
-from pymor.models.basic import StationaryModel, InstationaryModel
+from pymor.discretizers.builtin import (OnedGrid, RectGrid, TriaGrid,
+                                        discretize_instationary_cg,
+                                        discretize_instationary_fv,
+                                        discretize_stationary_cg,
+                                        discretize_stationary_fv, load_gmsh)
+from pymor.discretizers.builtin.domaindiscretizers.default import \
+    discretize_domain_default
+from pymor.discretizers.builtin.grids.boundaryinfos import (
+    AllDirichletBoundaryInfo, EmptyBoundaryInfo, GenericBoundaryInfo)
+from pymor.models.basic import InstationaryModel, StationaryModel
 from pymor.models.iosys import LTIModel, PHLTIModel, SecondOrderModel
 from pymor.models.transfer_function import TransferFunction
-
-from pymor.discretizers.builtin import (discretize_stationary_cg, discretize_instationary_cg,
-                                        discretize_stationary_fv, discretize_instationary_fv,
-                                        OnedGrid, TriaGrid, RectGrid, load_gmsh)
-from pymor.discretizers.builtin.domaindiscretizers.default import discretize_domain_default
-from pymor.discretizers.builtin.grids.boundaryinfos import (EmptyBoundaryInfo, GenericBoundaryInfo,
-                                                            AllDirichletBoundaryInfo)
-
-from pymor.operators.constructions import (LincombOperator, ConcatenationOperator,
-                                           ComponentProjectionOperator, IdentityOperator, ConstantOperator,
-                                           ZeroOperator, VectorArrayOperator, VectorOperator, VectorFunctional,
-                                           FixedParameterOperator, AdjointOperator, SelectionOperator, induced_norm)
+from pymor.operators.constructions import (AdjointOperator,
+                                           ComponentProjectionOperator,
+                                           ConcatenationOperator,
+                                           ConstantOperator,
+                                           FixedParameterOperator,
+                                           IdentityOperator, LincombOperator,
+                                           SelectionOperator,
+                                           VectorArrayOperator,
+                                           VectorFunctional, VectorOperator,
+                                           ZeroOperator, induced_norm)
 from pymor.operators.ei import EmpiricalInterpolatedOperator
 from pymor.operators.numpy import NumpyGenericOperator, NumpyMatrixOperator
-
 from pymor.parallel.default import new_parallel_pool
 from pymor.parallel.manager import RemoteObjectManager
-
-from pymor.parameters.base import Parameters, Mu, ParametricObject, ParameterSpace
-from pymor.parameters.functionals import (ProjectionParameterFunctional, GenericParameterFunctional,
-                                          ExpressionParameterFunctional)
-
-from pymor.reductors.basic import StationaryRBReductor, InstationaryRBReductor, LTIPGReductor, SOLTIPGReductor
-from pymor.reductors.bt import BTReductor, LQGBTReductor, BRBTReductor
-from pymor.reductors.coercive import CoerciveRBReductor, SimpleCoerciveRBReductor
-from pymor.reductors.h2 import IRKAReductor, OneSidedIRKAReductor, TSIAReductor, TFIRKAReductor
-from pymor.reductors.interpolation import LTIBHIReductor, SOBHIReductor, TFBHIReductor
+from pymor.parameters.base import (Mu, Parameters, ParameterSpace,
+                                   ParametricObject)
+from pymor.parameters.functionals import (ExpressionParameterFunctional,
+                                          GenericParameterFunctional,
+                                          ProjectionParameterFunctional)
+from pymor.reductors.basic import (InstationaryRBReductor, LTIPGReductor,
+                                   SOLTIPGReductor, StationaryRBReductor)
+from pymor.reductors.bt import BRBTReductor, BTReductor, LQGBTReductor, PRBTReductor
+from pymor.reductors.coercive import (CoerciveRBReductor,
+                                      SimpleCoerciveRBReductor)
+from pymor.reductors.h2 import (IRKAReductor, OneSidedIRKAReductor,
+                                TFIRKAReductor, TSIAReductor)
+from pymor.reductors.interpolation import (LTIBHIReductor, SOBHIReductor,
+                                           TFBHIReductor)
 from pymor.reductors.mt import MTReductor
 from pymor.reductors.parabolic import ParabolicRBReductor
-from pymor.reductors.sobt import (SOBTpReductor, SOBTvReductor, SOBTpvReductor, SOBTvpReductor, SOBTfvReductor,
-                                  SOBTReductor)
+from pymor.reductors.sobt import (SOBTfvReductor, SOBTpReductor,
+                                  SOBTpvReductor, SOBTReductor, SOBTvpReductor,
+                                  SOBTvReductor)
 from pymor.reductors.sor_irka import SORIRKAReductor
-
 from pymor.tools.random import get_rng, new_rng
-
 from pymor.vectorarrays.constructions import cat_arrays
 from pymor.vectorarrays.list import ListVectorSpace
 from pymor.vectorarrays.numpy import NumpyVectorSpace
+
+try:
+    from pymor.models.interact import interact
+except DependencyMissingError:
+    pass
```

### Comparing `pymor-2022.2.1/src/pymor/bindings/dunegdt.py` & `pymor-2023.1.0/src/pymor/bindings/dunegdt.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,18 +1,19 @@
 # -*- coding: utf-8 -*-
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 from pymor.core.config import config
+
 config.require('DUNEGDT')
 
+from numbers import Integral
 
 import numpy as np
-
 from dune.xt.la import IstlVector
 
 from pymor.operators.list import LinearComplexifiedListVectorArrayOperatorBase
 from pymor.vectorarrays.interface import _create_random_values
 from pymor.vectorarrays.list import ComplexifiedListVectorSpace, CopyOnWriteVector
 
 
@@ -88,29 +89,31 @@
         return self * (-1)
 
     def to_numpy(self, ensure_copy=False):
         return np.array(self.impl, copy=ensure_copy)
 
 
 class DuneXTVectorSpace(ComplexifiedListVectorSpace):
-    """A |VectorSpace| yielding DuneXTVector
+    """A |VectorSpace| yielding DuneXTVector.
 
     Parameters
     ----------
     dim
         Dimension of the |VectorSpace|, i.e., length of the resulting vectors.
     vector_type
         Type of the actual vector from dune.xt.la, usually IstlVector.
     id
         Identifier of the |VectorSpace|.
     """
 
     real_vector_type = DuneXTVector
 
     def __init__(self, dim, dune_vector_type=IstlVector, id='STATE'):
+        assert isinstance(dim, Integral)
+        dim = int(dim)
         self.__auto_init(locals())
 
     def __eq__(self, other):
         return type(other) is DuneXTVectorSpace \
             and self.dune_vector_type == other.dune_vector_type \
             and self.dim == other.dim \
             and self.id == other.id
```

### Comparing `pymor-2022.2.1/src/pymor/bindings/fenics.py` & `pymor-2023.1.0/src/pymor/bindings/fenics.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,30 +1,32 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 from pymor.core.config import config
+
 config.require('FENICS')
 
 
-import dolfin as df
-import ufl
-import numpy as np
 import sys
 from pathlib import Path
 
+import dolfin as df
+import numpy as np
+import ufl
+
 from pymor.core.base import ImmutableObject
 from pymor.core.defaults import defaults
 from pymor.core.pickle import unpicklable
-from pymor.operators.constructions import ZeroOperator, VectorOperator, VectorFunctional
+from pymor.operators.constructions import VectorFunctional, VectorOperator, ZeroOperator
 from pymor.operators.interface import Operator
 from pymor.operators.list import LinearComplexifiedListVectorArrayOperatorBase
 from pymor.operators.numpy import NumpyMatrixOperator
 from pymor.vectorarrays.interface import _create_random_values
-from pymor.vectorarrays.list import CopyOnWriteVector, ComplexifiedVector, ComplexifiedListVectorSpace
+from pymor.vectorarrays.list import ComplexifiedListVectorSpace, ComplexifiedVector, CopyOnWriteVector
 from pymor.vectorarrays.numpy import NumpyVectorSpace
 
 
 @unpicklable
 class FenicsVector(CopyOnWriteVector):
     """Wraps a FEniCS vector to make it usable with ListVectorArray."""
 
@@ -177,15 +179,15 @@
 
     Parameters
     ----------
     form
         The `Form` object which is assembled to a matrix or vector.
     params
         Dict mapping parameters to dolfin `Constants` as returned by
-        :meth:`~pymor.analyticalproblems.functions.ExpressionFunction.to_fenics`.
+        :meth:`~pymor.analyticalproblems.functions.SymbolicExpressionFunction.to_fenics`.
     bc
         dolfin `DirichletBC` object to be applied.
     bc_zero
         If `True` also clear the diagonal entries of Dirichlet dofs.
     functional
         If `True` return a |VectorFunctional| instead of a |VectorOperator| in case
         `form` is a linear form.
@@ -321,21 +323,20 @@
     def _real_apply_inverse_adjoint_one_vector(self, u, mu=None, initial_guess=None,
                                                least_squares=False, prepare_data=None):
         if least_squares:
             raise NotImplementedError
         r = (self.range.real_zero_vector() if initial_guess is None else
              initial_guess.copy(deep=True))
 
-        # since dolfin does not have "apply_inverse_adjoint", we assume
+        # since dolfin does not have 'apply_inverse_adjoint', we assume
         # PETSc is used as backend and transpose the matrix
         if not hasattr(self, '_matrix_transpose'):
             self._matrix_transpose = self.matrix.copy()
-            mat = df.as_backend_type(self.matrix).mat()
             mat_tr = df.as_backend_type(self._matrix_transpose).mat()
-            mat.transpose(mat_tr)
+            mat_tr.transpose()
         self._apply_inverse(r.impl, u.impl, adjoint=True)
         return r
 
     def _assemble_lincomb(self, operators, coefficients, identity_shift=0., solver_options=None, name=None):
         if not all(isinstance(op, FenicsMatrixOperator) for op in operators):
             return None
         if identity_shift != 0:
@@ -520,14 +521,15 @@
             restricted_dofs.append(r_dof[0])
         restricted_dofs = np.array(restricted_dofs, dtype=np.int32)
         assert len(set(restricted_dofs)) == len(set(dofs))
         return restricted_dofs
 
 
 class RestrictedFenicsOperator(Operator):
+    """Restricted :class:`FenicsOperator`."""
 
     linear = False
 
     def __init__(self, op, restricted_range_dofs):
         self.source = NumpyVectorSpace(op.source.dim)
         self.range = NumpyVectorSpace(len(restricted_range_dofs))
         self.op = op
@@ -548,19 +550,19 @@
         assert U in self.source and len(U) == 1
         UU = self.op.source.zeros()
         UU.vectors[0].real_part.impl[:] = np.ascontiguousarray(U.to_numpy()[0])
         JJ = self.op.jacobian(UU, mu=mu)
         return NumpyMatrixOperator(JJ.matrix.array()[self.restricted_range_dofs, :])
 
 
-_DEFAULT_SOVLER = 'mumps' if 'mumps' in df.linear_solver_methods() else 'default'
+_DEFAULT_SOLVER = 'mumps' if 'mumps' in df.linear_solver_methods() else 'default'
 
 
 @defaults('solver', 'preconditioner', 'keep_solver')
-def _solver_options(solver=_DEFAULT_SOVLER,
+def _solver_options(solver=_DEFAULT_SOLVER,
                     preconditioner=None, keep_solver=True):
     return {'solver': solver, 'preconditioner': preconditioner, 'keep_solver': keep_solver}
 
 
 class FenicsVisualizer(ImmutableObject):
     """Visualize a FEniCS grid function.
 
@@ -603,15 +605,15 @@
             If `True`, block execution until the plot window is closed.
         """
         if filename:
             assert not isinstance(U, tuple)
             assert U in self.space
             if block:
                 self.logger.warning('visualize with filename!=None, block=True will not block')
-            supported = (".x3d", ".xml", ".pvd", ".raw")
+            supported = ('.x3d', '.xml', '.pvd', '.raw')
             suffix = Path(filename).suffix
             if suffix not in supported:
                 msg = ('FenicsVisualizer needs a filename with a suffix indicating a supported backend\n'
                        + f'defaulting to .pvd (possible choices: {supported})')
                 self.logger.warning(msg)
                 filename = f'{filename}.pvd'
             f = df.File(str(filename))
@@ -681,15 +683,15 @@
     facet_dim = dim - 1
     submesh.init(facet_dim)
     mesh.init(facet_dim)
 
     # Make sure we have vertex-facet connectivity for parent mesh
     mesh.init(0, facet_dim)
 
-    parent_vertex_indices = submesh.data().array("parent_vertex_indices", 0)
+    parent_vertex_indices = submesh.data().array('parent_vertex_indices', 0)
     # Create the fact map
     parent_facet_indices = np.full(submesh.num_facets(), -1)
 
     # Iterate over the edges and figure out their parent number
     for local_facet in df.facets(submesh):
 
         # Get parent indices for edge vertices
```

### Comparing `pymor-2022.2.1/src/pymor/bindings/ngsolve.py` & `pymor-2023.1.0/src/pymor/bindings/ngsolve.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,28 +1,27 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 from pathlib import Path
 
 from pymor.core.config import config
-config.require('NGSOLVE')
-
 
-from pymor.core.defaults import defaults
-from pymor.tools.io import change_to_directory
+config.require('NGSOLVE')
 
 
 import ngsolve as ngs
 import numpy as np
 
 from pymor.core.base import ImmutableObject
+from pymor.core.defaults import defaults
 from pymor.operators.list import LinearComplexifiedListVectorArrayOperatorBase
+from pymor.tools.io import change_to_directory
 from pymor.vectorarrays.interface import VectorArray
+from pymor.vectorarrays.list import ComplexifiedListVectorSpace, ComplexifiedVector, CopyOnWriteVector
 from pymor.vectorarrays.numpy import NumpyVectorSpace
-from pymor.vectorarrays.list import CopyOnWriteVector, ComplexifiedVector, ComplexifiedListVectorSpace
 
 
 class NGSolveVectorCommon:
     def amax(self):
         A = np.abs(self.to_numpy())
         max_ind = np.argmax(A)
         max_val = A[max_ind]
```

### Comparing `pymor-2022.2.1/src/pymor/bindings/pymess.py` & `pymor-2023.1.0/src/pymor/bindings/pymess.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,23 +1,28 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 from pymor.core.config import config
+
 config.require('PYMESS')
 
 import warnings
 
 import numpy as np
-import scipy.linalg as spla
 import pymess
+import scipy.linalg as spla
 
 from pymor.algorithms.genericsolvers import _parse_options
-from pymor.algorithms.lyapunov import (mat_eqn_sparse_min_size, _solve_lyap_lrcf_check_args,
-                                       _solve_lyap_dense_check_args, _chol)
+from pymor.algorithms.lyapunov import (
+    _chol,
+    _solve_lyap_dense_check_args,
+    _solve_lyap_lrcf_check_args,
+    mat_eqn_sparse_min_size,
+)
 from pymor.algorithms.to_matrix import to_matrix
 from pymor.bindings.scipy import _solve_ricc_check_args
 from pymor.core.defaults import defaults
 from pymor.core.logger import getLogger
 from pymor.operators.constructions import IdentityOperator
 
 
@@ -326,15 +331,15 @@
     return {'pymess_dense_nm_gmpcare': {'type': 'pymess_dense_nm_gmpcare',
                                         'opts': dense_nm_gmpcare_solver_options()},
             'pymess_lrnm':             {'type': 'pymess_lrnm',
                                         'opts': lrnm_solver_options()}}
 
 
 @defaults('default_solver')
-def solve_ricc_lrcf(A, E, B, C, R=None, trans=False, options=None, default_solver=None):
+def solve_ricc_lrcf(A, E, B, C, R=None, S=None, trans=False, options=None, default_solver=None):
     """Compute an approximate low-rank solution of a Riccati equation.
 
     See :func:`pymor.algorithms.riccati.solve_ricc_lrcf` for a
     general description.
 
     This function uses `pymess.dense_nm_gmpcare` and `pymess.lrnm`.
     For both methods,
@@ -360,14 +365,16 @@
         The non-parametric |Operator| E or `None`.
     B
         The operator B as a |VectorArray| from `A.source`.
     C
         The operator C as a |VectorArray| from `A.source`.
     R
         The matrix R as a 2D |NumPy array| or `None`.
+    S
+        The operator S as a |VectorArray| from `A.source` or `None`.
     trans
         Whether the first |Operator| in the Riccati equation is
         transposed.
     options
         The solver options to use (see
         :func:`ricc_lrcf_solver_options`).
     default_solver
@@ -377,15 +384,17 @@
 
     Returns
     -------
     Z
         Low-rank Cholesky factor of the Riccati equation solution,
         |VectorArray| from `A.source`.
     """
-    _solve_ricc_check_args(A, E, B, C, R, trans)
+    _solve_ricc_check_args(A, E, B, C, R, S, trans)
+    if S is not None:
+        raise NotImplementedError
     if default_solver is None:
         default_solver = 'pymess_lrnm' if A.source.dim >= mat_eqn_sparse_min_size() else 'pymess_dense_nm_gmpcare'
     options = _parse_options(options, ricc_lrcf_solver_options(), default_solver, None, False)
 
     if options['type'] == 'pymess_dense_nm_gmpcare':
         X = _call_pymess_dense_nm_gmpare(A, E, B, C, R, trans=trans, options=options['opts'], plus=False,
                                          method_name='solve_ricc_lrcf')
@@ -423,15 +432,15 @@
     -------
     A dict of available solvers with default solver options.
     """
     return {'pymess_dense_nm_gmpcare': {'type': 'pymess_dense_nm_gmpcare',
                                         'opts': dense_nm_gmpcare_solver_options()}}
 
 
-def solve_pos_ricc_lrcf(A, E, B, C, R=None, trans=False, options=None):
+def solve_pos_ricc_lrcf(A, E, B, C, R=None, S=None, trans=False, options=None):
     """Compute an approximate low-rank solution of a positive Riccati equation.
 
     See :func:`pymor.algorithms.riccati.solve_pos_ricc_lrcf` for a
     general description.
 
     This function uses `pymess.dense_nm_gmpcare`.
 
@@ -443,28 +452,32 @@
         The non-parametric |Operator| E or `None`.
     B
         The operator B as a |VectorArray| from `A.source`.
     C
         The operator C as a |VectorArray| from `A.source`.
     R
         The matrix R as a 2D |NumPy array| or `None`.
+    S
+        The operator S as a |VectorArray| from `A.source` or `None`.
     trans
         Whether the first |Operator| in the Riccati equation is
         transposed.
     options
         The solver options to use (see
         :func:`pos_ricc_lrcf_solver_options`).
 
     Returns
     -------
     Z
         Low-rank Cholesky factor of the Riccati equation solution,
         |VectorArray| from `A.source`.
     """
-    _solve_ricc_check_args(A, E, B, C, R, trans)
+    _solve_ricc_check_args(A, E, B, C, R, S, trans)
+    if S is not None:
+        raise NotImplementedError
     options = _parse_options(options, pos_ricc_lrcf_solver_options(), 'pymess_dense_nm_gmpcare', None, False)
 
     if options['type'] == 'pymess_dense_nm_gmpcare':
         X = _call_pymess_dense_nm_gmpare(A, E, B, C, R, trans=trans, options=options['opts'], plus=True,
                                          method_name='solve_pos_ricc_lrcf')
         Z = _chol(X)
     else:
@@ -505,15 +518,15 @@
         logger.warning(f'Desired relative residual tolerance was not achieved '
                        f'({relres:e} > {options["relres_tol"]:e}).')
 
     return X
 
 
 class LyapunovEquation(pymess.Equation):
-    """Lyapunov equation class for pymess
+    """Lyapunov equation class for pymess.
 
     Represents a (generalized) continuous-time algebraic Lyapunov
     equation:
 
     - if opt.type is `pymess.MESS_OP_NONE` and E is `None`:
 
       .. math::
@@ -623,15 +636,15 @@
         return x.to_numpy().T
 
     def parameter(self, arp_p, arp_m, B=None, K=None):
         return None
 
 
 class RiccatiEquation(pymess.Equation):
-    """Riccati equation class for pymess
+    """Riccati equation class for pymess.
 
     Represents a Riccati equation
 
     - if opt.type is `pymess.MESS_OP_NONE` and E is `None`:
 
       .. math::
           A X + X A^T - X C^T C X + B B^T = 0,
```

### Comparing `pymor-2022.2.1/src/pymor/bindings/scipy.py` & `pymor-2023.1.0/src/pymor/bindings/scipy.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,19 +1,19 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 
 import numpy as np
-from scipy.linalg import solve, solve_continuous_lyapunov, solve_discrete_lyapunov, solve_continuous_are
-from scipy.sparse.linalg import bicgstab, spsolve, splu, spilu, lgmres, lsqr, LinearOperator
+from scipy.linalg import solve, solve_continuous_are, solve_continuous_lyapunov, solve_discrete_lyapunov
+from scipy.sparse.linalg import LinearOperator, bicgstab, lgmres, lsqr, spilu, splu, spsolve
 
-from pymor.algorithms.lyapunov import _solve_lyap_lrcf_check_args, _solve_lyap_dense_check_args, _chol
-from pymor.algorithms.riccati import _solve_ricc_check_args, _solve_ricc_dense_check_args
 from pymor.algorithms.genericsolvers import _parse_options
+from pymor.algorithms.lyapunov import _chol, _solve_lyap_dense_check_args, _solve_lyap_lrcf_check_args
+from pymor.algorithms.riccati import _solve_ricc_check_args, _solve_ricc_dense_check_args
 from pymor.algorithms.to_matrix import to_matrix
 from pymor.core.config import config
 from pymor.core.defaults import defaults
 from pymor.core.exceptions import InversionError
 from pymor.operators.numpy import NumpyMatrixOperator
 
 
@@ -433,15 +433,15 @@
     Returns
     -------
     A dict of available solvers with default solver options.
     """
     return {'scipy': {'type': 'scipy'}}
 
 
-def solve_ricc_lrcf(A, E, B, C, R=None, trans=False, options=None):
+def solve_ricc_lrcf(A, E, B, C, R=None, S=None, trans=False, options=None):
     """Compute an approximate low-rank solution of a Riccati equation.
 
     See :func:`pymor.algorithms.riccati.solve_ricc_lrcf` for a general
     description.
 
     This function uses `scipy.linalg.solve_continuous_are`, which
     is a dense solver.
@@ -458,52 +458,56 @@
         The non-parametric |Operator| E or `None`.
     B
         The operator B as a |VectorArray| from `A.source`.
     C
         The operator C as a |VectorArray| from `A.source`.
     R
         The matrix R as a 2D |NumPy array| or `None`.
+    S
+        The operator S as a |VectorArray| from `A.source` or `None`.
     trans
         Whether the first |Operator| in the Riccati equation is
         transposed.
     options
         The solver options to use (see :func:`ricc_lrcf_solver_options`).
 
     Returns
     -------
     Z
         Low-rank Cholesky factor of the Riccati equation solution,
         |VectorArray| from `A.source`.
     """
-    _solve_ricc_check_args(A, E, B, C, R, trans)
+    _solve_ricc_check_args(A, E, B, C, R, S, trans)
     options = _parse_options(options, ricc_lrcf_solver_options(), 'scipy', None, False)
     if options['type'] != 'scipy':
         raise ValueError(f"Unexpected Riccati equation solver ({options['type']}).")
 
     A_source = A.source
     A = to_matrix(A, format='dense')
     E = to_matrix(E, format='dense') if E else None
     B = B.to_numpy().T
     C = C.to_numpy()
-    X = solve_ricc_dense(A, E, B, C, R, trans, options)
+    if S is not None:
+        S = S.to_numpy() if not trans else S.to_numpy().T
+    X = solve_ricc_dense(A, E, B, C, R, S, trans, options)
 
     return A_source.from_numpy(_chol(X).T)
 
 
 def ricc_dense_solver_options():
     """Return available Riccati solvers with default options for the SciPy backend.
 
     Returns
     -------
     A dict of available solvers with default solver options.
     """
     return {'scipy': {'type': 'scipy'}}
 
 
-def solve_ricc_dense(A, E, B, C, R=None, trans=False, options=None):
+def solve_ricc_dense(A, E, B, C, R=None, S=None, trans=False, options=None):
     """Compute the solution of a Riccati equation.
 
     See :func:`pymor.algorithms.riccati.solve_ricc_dense` for a general
     description.
 
     This function uses `scipy.linalg.solve_continuous_are`, which
     is a dense solver.
@@ -516,54 +520,58 @@
         The matrix E as a 2D |NumPy array| or `None`.
     B
         The matrix B as a 2D |NumPy array|.
     C
         The matrix C as a 2D |NumPy array|.
     R
         The matrix R as a 2D |NumPy array| or `None`.
+    S
+        The matrix S as a 2D |NumPy array| or `None`.
     trans
         Whether the first operator in the Riccati equation is
         transposed.
     options
         The solver options to use (see
         :func:`ricc_dense_solver_options`).
 
     Returns
     -------
     X
         Riccati equation solution as a |NumPy array|.
     """
-    _solve_ricc_dense_check_args(A, E, B, C, R, trans)
+    _solve_ricc_dense_check_args(A, E, B, C, R, S, trans)
     options = _parse_options(options, ricc_dense_solver_options(), 'scipy', None, False)
     if options['type'] != 'scipy':
         raise ValueError(f"Unexpected Riccati equation solver ({options['type']}).")
 
     if R is None:
         R = np.eye(C.shape[0] if not trans else B.shape[1])
     if not trans:
         if E is not None:
             E = E.T
-        X = solve_continuous_are(A.T, C.T, B.dot(B.T), R, E)
+        if S is not None:
+            S = S.T
+        X = solve_continuous_are(A.T, C.T, B.dot(B.T), R, e=E, s=S)
     else:
-        X = solve_continuous_are(A, B, C.T.dot(C), R, E)
+        X = solve_continuous_are(A, B, C.T.dot(C), R, e=E, s=S)
 
     return X
 
 
 def pos_ricc_lrcf_solver_options():
     """Return available positive Riccati solvers with default options for the SciPy backend.
 
     Returns
     -------
     A dict of available solvers with default solver options.
     """
     return {'scipy': {'type': 'scipy'}}
 
 
-def solve_pos_ricc_lrcf(A, E, B, C, R=None, trans=False, options=None):
+def solve_pos_ricc_lrcf(A, E, B, C, R=None, S=None, trans=False, options=None):
     """Compute an approximate low-rank solution of a positive Riccati equation.
 
     See :func:`pymor.algorithms.riccati.solve_pos_ricc_lrcf` for a
     general description.
 
     This function uses `scipy.linalg.solve_continuous_are`, which
     is a dense solver.
@@ -580,28 +588,30 @@
         The non-parametric |Operator| E or `None`.
     B
         The operator B as a |VectorArray| from `A.source`.
     C
         The operator C as a |VectorArray| from `A.source`.
     R
         The matrix R as a 2D |NumPy array| or `None`.
+    S
+        The operator S as a |VectorArray| from `A.source` or `None`.
     trans
         Whether the first |Operator| in the positive Riccati equation is
         transposed.
     options
         The solver options to use (see
         :func:`pos_ricc_lrcf_solver_options`).
 
     Returns
     -------
     Z
         Low-rank Cholesky factor of the positive Riccati equation
         solution, |VectorArray| from `A.source`.
     """
-    _solve_ricc_check_args(A, E, B, C, R, trans)
+    _solve_ricc_check_args(A, E, B, C, R, S, trans)
     options = _parse_options(options, pos_ricc_lrcf_solver_options(), 'scipy', None, False)
     if options['type'] != 'scipy':
         raise ValueError(f"Unexpected positive Riccati equation solver ({options['type']}).")
 
     if R is None:
         R = np.eye(len(C) if not trans else len(B))
-    return solve_ricc_lrcf(A, E, B, C, -R, trans, options)
+    return solve_ricc_lrcf(A, E, B, C, -R, S, trans, options)
```

### Comparing `pymor-2022.2.1/src/pymor/bindings/slycot.py` & `pymor-2023.1.0/src/pymor/bindings/slycot.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,21 +1,22 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 from pymor.core.config import config
+
 config.require('SLYCOT')
 
 
 import numpy as np
 import scipy.linalg as spla
 import slycot
 
 from pymor.algorithms.genericsolvers import _parse_options
-from pymor.algorithms.lyapunov import _solve_lyap_lrcf_check_args, _solve_lyap_dense_check_args, _chol
+from pymor.algorithms.lyapunov import _chol, _solve_lyap_dense_check_args, _solve_lyap_lrcf_check_args
 from pymor.algorithms.riccati import _solve_ricc_dense_check_args
 from pymor.algorithms.to_matrix import to_matrix
 from pymor.bindings.scipy import _solve_ricc_check_args
 from pymor.core.logger import getLogger
 
 
 def lyap_lrcf_solver_options():
@@ -127,25 +128,16 @@
     if options['type'] == 'slycot_bartels-stewart':
         n = A.shape[0]
         C = -B.dot(B.T) if not trans else -B.T.dot(B)
         trana = 'T' if not trans else 'N'
         dico = 'C' if cont_time else 'D'
         job = 'B'
         if E is None:
-            from packaging.version import parse
-            # branch off different slycot versions due to changes of sb03md call signature
-            if parse(slycot.version.version) < parse('0.5.0.0'):
-                U = np.zeros((n, n))
-                ldwork = max(2*n*n, 3*n) if cont_time else 2*n*n+2*n
-                # slycot v. 0.4.0 does not set ldwork correctly for dico='D'
-                X, scale, sep, ferr, _ = slycot.sb03md(n, C, A, U, dico, job=job, trana=trana, ldwork=ldwork)
-                _solve_check(A.dtype, 'slycot.sb03md', sep, ferr)
-            else:
-                _, _, X, scale, sep, ferr, _ = slycot.sb03md57(A, C=C, dico=dico, job=job, trana=trana)
-                _solve_check(A.dtype, 'slycot.sb03md57', sep, ferr)
+            _, _, X, scale, sep, ferr, _ = slycot.sb03md57(A, C=C, dico=dico, job=job, trana=trana)
+            _solve_check(A.dtype, 'slycot.sb03md57', sep, ferr)
         else:
             fact = 'N'
             uplo = 'L'
             Q = np.zeros((n, n))
             Z = np.zeros((n, n))
             _, _, _, _, X, scale, sep, ferr, _, _, _ = slycot.sg03ad(dico, job, fact, trana, uplo,
                                                                      n, A, E,
@@ -154,78 +146,95 @@
         X /= scale
     else:
         raise ValueError(f"Unexpected Lyapunov equation solver ({options['type']}).")
 
     return X
 
 
-def solve_ricc_dense(A, E, B, C, R=None, trans=False, options=None):
+def solve_ricc_dense(A, E, B, C, R=None, S=None, trans=False, options=None):
     """Compute the solution of a Riccati equation.
 
     See :func:`pymor.algorithms.riccati.solve_ricc_dense` for a
     general description.
 
-    This function uses `slycot.sb02md` (if `E is None`) which is based on
-    the Schur vector approach and `slycot.sg02ad` (if `E is not None`) which
-    is based on the method of deflating subspaces.
+    This function uses `slycot.sb02md` (if `E is None and S is None`) which is based on
+    the Schur vector approach, and `slycot.sb02od` (if `E is None and S is not None`) or
+    `slycot.sg02ad` (if `E is not None`) which are both based on
+    the method of deflating subspaces.
 
     Parameters
     ----------
     A
         The matrix A as a 2D |NumPy array|.
     E
         The matrix E as a 2D |NumPy array| or `None`.
     B
         The matrix B as a 2D |NumPy array|.
     C
         The matrix C as a 2D |NumPy array|.
     R
         The matrix R as a 2D |NumPy array| or `None`.
+    S
+        The matrix S as a 2D |NumPy array| or `None`.
     trans
         Whether the first matrix in the Riccati equation is
         transposed.
     options
         The solver options to use (see
         :func:`ricc_dense_solver_options`).
 
     Returns
     -------
     X
         Riccati equation solution as a |NumPy array|.
     """
-    _solve_ricc_dense_check_args(A, E, B, C, R, trans)
+    _solve_ricc_dense_check_args(A, E, B, C, R, S, trans)
     options = _parse_options(options, ricc_dense_solver_options(), 'slycot', None, False)
 
     if options['type'] != 'slycot':
         raise ValueError(f"Unexpected Riccati equation solver ({options['type']}).")
 
     dico = 'C'
     n = A.shape[0]
     if E is not None:
         jobb = 'B'
         fact = 'C'
         uplo = 'U'
-        jobl = 'Z'
+        jobl = 'Z' if S is None else 'N'
         scal = 'N'
         sort = 'S'
         acc = 'R'
         m = C.shape[0] if not trans else B.shape[1]
         p = B.shape[1] if not trans else C.shape[0]
         if R is None:
             R = np.eye(m)
-        S = np.empty((n, m))
+        if S is None:
+            S = np.empty((n, m))
+        elif not trans:
+            S = S.T
         if not trans:
             A = A.T
             E = E.T
             B, C = C.T, B.T
         out = slycot.sg02ad(dico, jobb, fact, uplo, jobl, scal, sort, acc,
                             n, m, p,
                             A, E, B, C, R, S)
         X = out[1]
         rcond = out[0]
+        _ricc_rcond_check('slycot.sg02ad', rcond)
+    elif S is not None:
+        m = C.shape[0] if not trans else B.shape[1]
+        p = B.shape[1] if not trans else C.shape[0]
+        if R is None:
+            R = np.eye(m)
+        if trans:
+            X, rcond = slycot.sb02od(n, m, A, B, C, R, dico, p=p, L=S, fact='C')[:2]
+        else:
+            X, rcond = slycot.sb02od(n, m, A.T, C.T, B.T, R, dico, p=p, L=S.T, fact='C')[:2]
+        _ricc_rcond_check('slycot.sb02od', rcond)
     else:
         if trans:
             if R is None:
                 G = B @ B.T
             else:
                 G = B @ spla.solve(R, B.T)
             Q = C.T @ C
@@ -233,15 +242,15 @@
         else:
             if R is None:
                 G = C.T @ C
             else:
                 G = C.T @ spla.solve(R, C)
             Q = B @ B.T
             X, rcond = slycot.sb02md(n, A.T, G, Q, dico)[:2]
-    _ricc_rcond_check('slycot.sb02md', rcond)
+        _ricc_rcond_check('slycot.sb02md', rcond)
 
     return X
 
 
 def ricc_dense_solver_options():
     """Return available Riccati solvers with default options for the slycot backend.
 
@@ -265,15 +274,15 @@
     Returns
     -------
     A dict of available solvers with default solver options.
     """
     return {'slycot': {'type': 'slycot'}}
 
 
-def solve_ricc_lrcf(A, E, B, C, R=None, trans=False, options=None):
+def solve_ricc_lrcf(A, E, B, C, R=None, S=None, trans=False, options=None):
     """Compute an approximate low-rank solution of a Riccati equation.
 
     See :func:`pymor.algorithms.riccati.solve_ricc_lrcf` for a
     general description.
 
     This function uses `slycot.sb02md` (if E is `None`) or
     `slycot.sg03ad` (if E is not `None`), which are dense solvers.
@@ -290,39 +299,43 @@
         The non-parametric |Operator| E or `None`.
     B
         The operator B as a |VectorArray| from `A.source`.
     C
         The operator C as a |VectorArray| from `A.source`.
     R
         The matrix R as a 2D |NumPy array| or `None`.
+    S
+        The operator S as a |VectorArray| from `A.source` or `None`.
     trans
         Whether the first |Operator| in the Riccati equation is
         transposed.
     options
         The solver options to use (see
         :func:`ricc_lrcf_solver_options`).
 
     Returns
     -------
     Z
         Low-rank Cholesky factor of the Riccati equation solution,
         |VectorArray| from `A.source`.
     """
-    _solve_ricc_check_args(A, E, B, C, R, trans)
+    _solve_ricc_check_args(A, E, B, C, R, S, trans)
     options = _parse_options(options, ricc_lrcf_solver_options(), 'slycot', None, False)
     if options['type'] != 'slycot':
         raise ValueError(f"Unexpected Riccati equation solver ({options['type']}).")
 
     A_source = A.source
     A = to_matrix(A, format='dense')
     E = to_matrix(E, format='dense') if E else None
     B = B.to_numpy().T
     C = C.to_numpy()
+    if S is not None:
+        S = S.to_numpy() if not trans else S.to_numpy().T
 
-    X = solve_ricc_dense(A, E, B, C, R, trans, options)
+    X = solve_ricc_dense(A, E, B, C, R, S, trans, options)
 
     return A_source.from_numpy(_chol(X).T)
 
 
 def _ricc_rcond_check(solver, rcond):
     if rcond < np.finfo(np.float64).eps:
         logger = getLogger(solver)
@@ -336,15 +349,15 @@
     Returns
     -------
     A dict of available solvers with default solver options.
     """
     return {'slycot': {'type': 'slycot'}}
 
 
-def solve_pos_ricc_lrcf(A, E, B, C, R=None, trans=False, options=None):
+def solve_pos_ricc_lrcf(A, E, B, C, R=None, S=None, trans=False, options=None):
     """Compute an approximate low-rank solution of a positive Riccati equation.
 
     See :func:`pymor.algorithms.riccati.solve_pos_ricc_lrcf` for a
     general description.
 
     This function uses `slycot.sb02md` (if E is `None`) or
     `slycot.sg03ad` (if E is not `None`), which are dense solvers.
@@ -361,28 +374,30 @@
         The non-parametric |Operator| E or `None`.
     B
         The operator B as a |VectorArray| from `A.source`.
     C
         The operator C as a |VectorArray| from `A.source`.
     R
         The matrix R as a 2D |NumPy array| or `None`.
+    S
+        The operator S as a |VectorArray| from `A.source` or `None`.
     trans
         Whether the first |Operator| in the positive Riccati
         equation is transposed.
     options
         The solver options to use (see
         :func:`pos_ricc_lrcf_solver_options`).
 
     Returns
     -------
     Z
         Low-rank Cholesky factor of the positive Riccati equation
         solution, |VectorArray| from `A.source`.
     """
-    _solve_ricc_check_args(A, E, B, C, R, trans)
+    _solve_ricc_check_args(A, E, B, C, R, S, trans)
     options = _parse_options(options, pos_ricc_lrcf_solver_options(), 'slycot', None, False)
     if options['type'] != 'slycot':
         raise ValueError(f"Unexpected positive Riccati equation solver ({options['type']}).")
 
     if R is None:
         R = np.eye(len(C) if not trans else len(B))
-    return solve_ricc_lrcf(A, E, B, C, -R, trans, options)
+    return solve_ricc_lrcf(A, E, B, C, -R, S, trans, options)
```

### Comparing `pymor-2022.2.1/src/pymor/core/base.py` & `pymor-2023.1.0/src/pymor/core/base.py`

 * *Files 1% similar despite different names*

```diff
@@ -45,23 +45,23 @@
        creates a copy with the `a` and `b` attributes of `obj` set to `x` and `y`.
        `with_` is implemented by creating a new instance, passing the arguments of
        `with_` to `__init__`. The missing `__init__` arguments are taken from instance
        attributes of the same name.
 """
 
 import abc
-from functools import wraps
 import inspect
 import os
-from types import FunctionType
 import uuid
+from functools import wraps
+from types import FunctionType
 
 from pymor.core import logger
 from pymor.core.exceptions import ConstError
-from pymor.tools.formatrepr import format_repr, _format_generic
+from pymor.tools.formatrepr import _format_generic, format_repr
 
 DONT_COPY_DOCSTRINGS = int(os.environ.get('PYMOR_WITH_SPHINX', 0)) == 1
 NoneType = type(None)
 
 
 class UID:
     """Provides unique, quickly computed ids by combining a session UUID4 with a counter."""
@@ -132,15 +132,15 @@
             Only attributes which have not already been set by the user are initialized by
             `__auto_init`.
             """
             for arg in c._init_arguments:
                 if arg not in self.__dict__:
                     setattr(self, arg, locals_[arg])
 
-        auto_init_name = f'_{classname}__auto_init'
+        auto_init_name = f"_{classname.lstrip('_')}__auto_init"
         classdict[auto_init_name] = __auto_init
         c = abc.ABCMeta.__new__(cls, classname, bases, classdict)
         # by updating the qualified name we make filtering in sphinx possible
         getattr(c, auto_init_name).__qualname__ = auto_init_name
 
         init_sig = inspect.signature(c.__init__)
         init_args = []
@@ -227,15 +227,15 @@
 
 abstractmethod = abc.abstractmethod
 abstractproperty = abc.abstractproperty
 abstractclassmethod = abc.abstractclassmethod
 abstractstaticmethod = abc.abstractstaticmethod
 
 
-class classinstancemethod:
+class classinstancemethod: # noqa: N801
 
     def __init__(self, cls_meth):
         self.cls_meth = cls_meth
 
     def __get__(self, instance, cls):
         if cls is None:
             return self
```

### Comparing `pymor-2022.2.1/src/pymor/core/cache.py` & `pymor-2023.1.0/src/pymor/core/cache.py`

 * *Ordering differences only*

 * *Files 1% similar despite different names*

```diff
@@ -58,23 +58,23 @@
 any call to :func:`enable_caching`.
 
 A cache region can be emptied using :meth:`CacheRegion.clear`. The function
 :func:`clear_caches` clears each cache region registered in `cache_regions`.
 """
 
 import atexit
-from collections import OrderedDict
-from copy import deepcopy
 import functools
 import getpass
 import hashlib
 import inspect
-from numbers import Number
 import os
 import tempfile
+from collections import OrderedDict
+from copy import deepcopy
+from numbers import Number
 from types import MethodType
 
 import diskcache
 import numpy as np
 
 from pymor.core.base import ImmutableObject
 from pymor.core.defaults import defaults, defaults_changes
```

### Comparing `pymor-2022.2.1/src/pymor/core/config.py` & `pymor-2023.1.0/src/pymor/core/config.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,18 +1,20 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
-from importlib import import_module
-from packaging.version import parse
+import os
 import platform
 import sys
 import warnings
+from importlib import import_module
 
-from pymor.core.exceptions import DependencyMissing, QtMissing, TorchMissing
+from packaging.version import parse
+
+from pymor.core.exceptions import DependencyMissingError, QtMissingError, TorchMissingError
 
 
 def _can_import(module):
     def _can_import_single(m):
         try:
             import_module(m)
             return True
@@ -22,15 +24,15 @@
     if not isinstance(module, (list, tuple)):
         module = [module]
     return all((_can_import_single(m) for m in module))
 
 
 def _get_fenics_version():
     import sys
-    if "linux" in sys.platform:
+    if 'linux' in sys.platform:
         # In dolfin.__init__ the dlopen flags are set to include RTDL_GLOBAL,
         # which can cause issues with other Python C extensions.
         # In particular, with the manylinux wheels for scipy 1.9.{2,3} this leads
         # to segfaults in the Fortran L-BFGS-B implementatiton.
         #
         # A MWE to trigger the segfault is:
         #     import sys
@@ -46,52 +48,52 @@
         orig_dlopenflags = sys.getdlopenflags()
 
     import dolfin as df
     if parse(df.__version__) < parse('2019.1.0'):
         warnings.warn(f'FEniCS bindings have been tested for version 2019.1.0 and greater '
                       f'(installed: {df.__version__}).')
 
-    if "linux" in sys.platform:
+    if 'linux' in sys.platform:
         sys.setdlopenflags(orig_dlopenflags)
     return df.__version__
 
 
 def _get_dunegdt_version():
     import importlib
-    version_ranges = {"dune-gdt": ('2021.1.2', '2023.2'), "dune-xt": ('2021.1.2', '2023.2')}
+    version_ranges = {'dune-gdt': ('2021.1.2', '2023.2'), 'dune-xt': ('2021.1.2', '2023.2')}
 
     def _get_version(dep_name):
         min_version, max_version = version_ranges[dep_name]
-        module = importlib.import_module(dep_name.replace("-", "."))
+        module = importlib.import_module(dep_name.replace('-', '.'))
         try:
             version = module.__version__
             if parse(version) < parse(min_version) or parse(version) >= parse(max_version):
                 warnings.warn(f'{dep_name} bindings have been tested for versions between '
-                              '{min_version} and {max_version} (installed: {version}).')
+                              f'{min_version} and {max_version} (installed: {version}).')
         except AttributeError:
             warnings.warn(f'{dep_name} bindings have been tested for versions between '
-                          '{min_version} and {max_version} (installed unknown version).')
+                          f'{min_version} and {max_version} (installed unknown version).')
             version = None
         return version
 
-    _get_version("dune-xt")
-    return _get_version("dune-gdt")
+    _get_version('dune-xt')
+    return _get_version('dune-gdt')
 
 
 def is_windows_platform():
     return sys.platform == 'win32' or sys.platform == 'cygwin'
 
 
 def is_macos_platform():
     return 'Darwin' in platform.system()
 
 
 def _get_matplotib_version():
-    import matplotlib
-    return matplotlib.__version__
+    import matplotlib as mpl
+    return mpl.__version__
 
 
 def _get_ipython_version():
     try:
         import ipyparallel
         return ipyparallel.__version__
     except ImportError:
@@ -133,40 +135,30 @@
     force = environ.get('PYMOR_FORCE_JUPYTER', None)
     if force is not None:
         return bool(force)
     ipy = type(get_ipython()).__module__
     return ipy.startswith('ipykernel.') or ipy.startswith('google.colab')
 
 
-def is_nbconvert():
-    """Check if a notebook is executed with `nbconvert`.
-
-    In some visualization cases we need to be able to detect if a notebook
-    is executed with `nbconvert` to disable async loading.
-    """
-    from os import environ
-    return is_jupyter() and bool(environ.get('PYMOR_NBCONVERT', False))
-
-
 _PACKAGES = {
     'DEALII': lambda: import_module('pymor_dealii').__version__,
     'DUNEGDT': _get_dunegdt_version,
     'FENICS': _get_fenics_version,
     'GL': lambda: import_module('OpenGL.GL') and import_module('OpenGL').__version__,
     'IPYTHON': _get_ipython_version,
     'MATPLOTLIB': _get_matplotib_version,
     'VTKIO': lambda: _can_import(('meshio', 'pyevtk', 'lxml', 'xmljson')),
     'MESHIO': lambda: import_module('meshio').__version__,
     'IPYWIDGETS': lambda: import_module('ipywidgets').__version__,
+    'K3D': lambda: import_module('k3d').__version__,
     'MPI': lambda: import_module('mpi4py.MPI') and import_module('mpi4py').__version__,
     'NGSOLVE': lambda: import_module('ngsolve').__version__,
     'NUMPY': lambda: import_module('numpy').__version__,
     'PYMESS': lambda: bool(import_module('pymess')),
     'PYTEST': lambda: import_module('pytest').__version__,
-    'PYTHREEJS': lambda: import_module('pythreejs._version').__version__,
     'QT': _get_qt_version,
     'QTOPENGL': lambda: bool(_get_qt_version() and import_module('qtpy.QtOpenGL')),
     'SCIKIT_FEM': lambda: import_module('skfem').__version__,
     'SCIPY': lambda: import_module('scipy').__version__,
     'SCIPY_LSMR': lambda: hasattr(import_module('scipy.sparse.linalg'), 'lsmr'),
     'SLYCOT': lambda: _get_slycot_version(),
     'SPHINX': lambda: import_module('sphinx').__version__,
@@ -175,43 +167,47 @@
 }
 
 
 class Config:
 
     def __init__(self):
         self.PYTHON_VERSION = f'{sys.version_info.major}.{sys.version_info.minor}.{sys.version_info.micro}'
+        self.disabled = set(os.environ.get('PYMOR_CONFIG_DISABLE', '').upper().split())
 
     @property
     def version(self):
         from pymor import __version__
         return __version__
 
     def require(self, dependency):
         dependency = dependency.upper()
         if not getattr(self, f'HAVE_{dependency}'):
             if dependency == 'QT':
-                raise QtMissing
+                raise QtMissingError
             elif dependency == 'TORCH':
-                raise TorchMissing
+                raise TorchMissingError
             else:
-                raise DependencyMissing(dependency)
+                raise DependencyMissingError(dependency)
 
     def __getattr__(self, name):
         if name.startswith('HAVE_'):
             package = name[len('HAVE_'):]
         elif name.endswith('_VERSION'):
             package = name[:-len('_VERSION')]
         else:
             raise AttributeError
 
         if package in _PACKAGES:
-            try:
-                version = _PACKAGES[package]()
-            except ImportError:
+            if package in self.disabled:
                 version = False
+            else:
+                try:
+                    version = _PACKAGES[package]()
+                except ImportError:
+                    version = False
 
             if version is not None and version is not False:
                 setattr(self, 'HAVE_' + package, True)
                 setattr(self, package + '_VERSION', version)
             else:
                 setattr(self, 'HAVE_' + package, False)
                 setattr(self, package + '_VERSION', None)
@@ -223,30 +219,31 @@
     def __dir__(self, old=False):
         keys = set(super().__dir__())
         keys.update('HAVE_' + package for package in _PACKAGES)
         keys.update(package + '_VERSION' for package in _PACKAGES)
         return list(keys)
 
     def __repr__(self):
-        status = {p: (lambda v: 'missing' if not v else 'present' if v is True else v)(getattr(self, p + '_VERSION'))
+        status = {p: 'disabled' if p in self.disabled else
+                     (lambda v: 'missing' if not v else 'present' if v is True else v)(getattr(self, p + '_VERSION'))
                   for p in _PACKAGES}
         key_width = max(len(p) for p in _PACKAGES) + 2
         package_info = [f"{p+':':{key_width}} {v}" for p, v in sorted(status.items())]
         separator = '-' * max(map(len, package_info))
         package_info = '\n'.join(package_info)
-        info = f'''
+        info = f"""
 pyMOR Version {self.version}
 
 Python {self.PYTHON_VERSION} on {platform.platform()}
 
 External Packages
 {separator}
 {package_info}
 
 Defaults
 --------
 See pymor.core.defaults.print_defaults.
-'''[1:]
+"""[1:]
         return info
 
 
 config = Config()
```

### Comparing `pymor-2022.2.1/src/pymor/core/defaults.py` & `pymor-2023.1.0/src/pymor/core/defaults.py`

 * *Files 1% similar despite different names*

```diff
@@ -42,26 +42,25 @@
 .. warning::
     Note that changing defaults may affect the result of a (cached)
     function call. pyMOR will emit a warning, when a result is retrieved
     from the cache that has been computed using an earlier set of
     |defaults| (see :func:`defaults_changes`).
 """
 
-from collections import defaultdict, OrderedDict
 import functools
 import importlib
 import inspect
 import pkgutil
 import textwrap
 import threading
+from collections import OrderedDict, defaultdict
 
-from pymor.core.exceptions import DependencyMissing
+from pymor.core.exceptions import DependencyMissingError
 from pymor.tools.table import format_table
 
-
 _default_container = None
 
 
 class DefaultContainer:
     """Internal singleton class holding all default values defined in pyMOR.
 
     Not to be used directly.
@@ -80,19 +79,19 @@
         self.changes = 0
         self.changes_lock = threading.Lock()
 
     def _add_defaults_for_function(self, func, args):
 
         if func.__doc__ is not None:
             new_docstring = inspect.cleandoc(func.__doc__)
-            new_docstring += '''
+            new_docstring += """
 
 Defaults
 --------
-'''
+"""
             new_docstring += '\n'.join(textwrap.wrap(', '.join(args), 80)) + '\n(see :mod:`pymor.core.defaults`)'
             func.__doc__ = new_docstring
 
         params = OrderedDict(inspect.signature(func).parameters)
         argnames = tuple(params.keys())
         defaultsdict = {}
         for n in args:
@@ -250,15 +249,15 @@
             from pymor.core.logger import getLogger
             logger = getLogger('pymor.core.defaults._import_all')
             logger.warning('Failed to import ' + name)
 
         for p in pkgutil.walk_packages(package.__path__, package_name + '.', onerror=onerror):
             try:
                 importlib.import_module(p[1])
-            except DependencyMissing:
+            except DependencyMissingError:
                 pass
             except ImportError:
                 from pymor.core.logger import getLogger
                 logger = getLogger('pymor.core.defaults._import_all')
                 logger.warning('Failed to import ' + p[1])
 
 
@@ -326,20 +325,20 @@
         v, c = _default_container.get(k)
         keys.append("'" + k + "'")
         values.append(repr(v))
         as_comment.append(c == 'code')
     key_width = max(max([0] + list(map(len, ks))) for ks in keys)
 
     with open(filename, 'wt') as f:
-        print('''
+        print("""
 # pyMOR defaults config file
 # This file has been automatically created by pymor.core.defaults.write_defaults_to_file'.
 
 d = {}
-'''[1:], file=f)
+"""[1:], file=f)
 
         lks = keys[0].split('.')[:-1] if keys else ''
         for c, k, v in zip(as_comment, keys, values):
             ks = k.split('.')[:-1]
             if lks != ks:
                 print('', file=f)
             lks = ks
```

### Comparing `pymor-2022.2.1/src/pymor/core/exceptions.py` & `pymor-2023.1.0/src/pymor/core/exceptions.py`

 * *Files 8% similar despite different names*

```diff
@@ -31,56 +31,64 @@
     """Is raised if a linear algebra operation fails."""
 
 
 class NewtonError(Exception):
     """Is raised if the Newton algorithm fails to converge."""
 
 
+class BFGSError(Exception):
+    """Is raised if the BFGS algorithm fails to converge."""
+
+
+class TRError(Exception):
+    """Is raised if the TR algorithm fails to converge."""
+
+
 class CacheKeyGenerationError(Exception):
     """Is raised when cache key generation fails due to unsupported arguments."""
 
 
-class GmshMissing(Exception):
+class GmshMissingError(Exception):
     """Is raised when a Gmsh is not found."""
 
 
-class MeshioMissing(Exception):
+class MeshioMissingError(Exception):
     """Is raised when meshio is not available."""
 
 
 class ImageCollectionError(Exception):
     """Is raised when a pymor.algorithms.image.estimate_image fails for given operator."""
 
     def __init__(self, op):
         super().__init__(f'Cannot estimate image for {op}')
         self.op = op
 
 
-class NeuralNetworkTrainingFailed(Exception):
+class NeuralNetworkTrainingError(Exception):
     """Is raised when training of a neural network fails."""
 
 
-class DependencyMissing(ImportError):
+class DependencyMissingError(ImportError):
     """Raised when optional packages are required but are not installed."""
 
     def __init__(self, dependency, msg=None):
         self.dependency = dependency
         super().__init__(msg or f'optional dependency {dependency} required')
 
 
-class QtMissing(DependencyMissing):
-    """Raise me where having importable Qt bindings is non-optional"""
+class QtMissingError(DependencyMissingError):
+    """Raise me where having importable Qt bindings is non-optional."""
 
     def __init__(self, msg=None):
         msg = msg or 'cannot visualize: import of Qt bindings failed'
         super().__init__('QT', msg)
 
 
-class TorchMissing(DependencyMissing):
-    """Raise me where having importable torch version is non-optional"""
+class TorchMissingError(DependencyMissingError):
+    """Raise me where having importable torch version is non-optional."""
 
     def __init__(self, msg=None):
         msg = msg or 'cannot use neural networks: import of torch failed'
         super().__init__('TORCH', msg)
 
 
 class RuleNotMatchingError(NotImplementedError):
@@ -89,19 +97,25 @@
 
 class NoMatchingRuleError(NotImplementedError):
     def __init__(self, obj):
         super().__init__(f'No rule could be applied to {obj}')
         self.obj = obj
 
 
-class IOLibsMissing(ImportError):
+class IOLibsMissingError(ImportError):
     def __init__(self, msg=None):
         msg = msg or 'meshio, pyevtk, xmljson and lxml are needed for full file I/O functionality'
         super().__init__(msg)
 
 
 class UnpicklableError(Exception):
     def __init__(self, cls):
         self.cls = cls
 
     def __str__(self):
         return f'{self.cls} cannot be pickled.'
+
+
+class NoResultDataError(Exception):
+    def __init__(self, msg=None):
+        msg = msg or 'missing testdata, re-run test'
+        super().__init__(msg)
```

### Comparing `pymor-2022.2.1/src/pymor/core/logger.py` & `pymor-2023.1.0/src/pymor/core/logger.py`

 * *Files 1% similar despite different names*

```diff
@@ -29,17 +29,17 @@
 logging.addLevelName(INFO2, 'INFO2')
 logging.addLevelName(INFO3, 'INFO3')
 
 BLACK, RED, GREEN, YELLOW, BLUE, MAGENTA, CYAN, WHITE = range(8)
 
 # The background is set with 40 plus the number of the color, and the foreground with 30
 # These are the sequences needed to get colored output
-RESET_SEQ = "\033[0m"
-COLOR_SEQ = "\033[1;%dm"
-BOLD_SEQ = "\033[1m"
+RESET_SEQ = '\033[0m'
+COLOR_SEQ = '\033[1;%dm'
+BOLD_SEQ = '\033[1m'
 COLORS = {
     'WARNING':  YELLOW,
     'INFO2':    YELLOW,
     'INFO3':    RED,
     'DEBUG':    BLUE,
     'CRITICAL': MAGENTA,
     'ERROR':    RED
@@ -72,15 +72,15 @@
         disable_colors = int(os.environ.get('PYMOR_COLORS_DISABLE', 0)) == 1
         if disable_colors:
             self.use_color = False
         else:
             try:
                 import curses
                 curses.setupterm()
-                self.use_color = curses.tigetnum("colors") > 1
+                self.use_color = curses.tigetnum('colors') > 1
             except Exception:
                 self.use_color = False
 
         super().__init__()
 
     def _format_common(self, record):
         global LAST_TIMESTAMP_LENGTH
@@ -235,15 +235,15 @@
     warn = nop
     warning = nop
     error = nop
     critical = nop
     log = nop
     exception = nop
 
-    def isEnabledFor(sefl, lvl):
+    def isEnabledFor(self, lvl):
         return False
 
     def getEffectiveLevel(self):
         return None
 
     def getChild(self):
         return self
```

### Comparing `pymor-2022.2.1/src/pymor/core/pickle.py` & `pymor-2023.1.0/src/pymor/core/pickle.py`

 * *Files 5% similar despite different names*

```diff
@@ -11,26 +11,28 @@
 function objects which cannot be pickled by Python's standard
 methods. Note, however, pickling such methods should be avoided
 since the implementation of :func:`dumps_function` uses non-portable
 implementation details of CPython to achieve its goals.
 """
 
 import marshal
-import opcode
-from types import CodeType, FunctionType, ModuleType
 import pickle
-from io import BytesIO as IOtype
 import platform
+import sys
+from io import BytesIO as IOtype
+from types import CodeType, FunctionType, ModuleType
 
-from pymor.core.exceptions import UnpicklableError
+import opcode
 
+from pymor.core.exceptions import UnpicklableError
 
 PicklingError = pickle.PicklingError
 UnpicklingError = pickle.UnpicklingError
 PROTOCOL = pickle.HIGHEST_PROTOCOL
+PYTHON_311_OR_NEWER = int(sys.version_info.minor) >= 3.11
 
 
 # on CPython provide pickling methods which use
 # dumps_function in case pickling of a function fails
 if platform.python_implementation() == 'CPython':
 
     def dump(obj, file, protocol=None):
@@ -65,15 +67,15 @@
 
     load = pickle.load
     loads = pickle.loads
 
 
 def unpicklable(cls):
     """Class decorator to mark a class as unpicklable."""
-    def __getstate__(self):
+    def __getstate__(self):  # noqa: N807
         raise UnpicklableError(cls)
 
     cls.__getstate__ = __getstate__
     return cls
 
 
 def _generate_opcode(code_object):
@@ -81,15 +83,19 @@
     for ins in dis.get_instructions(code_object):
         yield (ins.opcode, ins.arg)
 
 
 def _global_names(code_object):
     """Return all names in code_object.co_names which are used in a LOAD_GLOBAL statement."""
     LOAD_GLOBAL = opcode.opmap['LOAD_GLOBAL']
-    indices = {i for o, i in _generate_opcode(code_object) if o == LOAD_GLOBAL}
+    if not PYTHON_311_OR_NEWER:
+        indices = {i for o, i in _generate_opcode(code_object) if o == LOAD_GLOBAL}
+    else:
+        indices = {i>>1 for o, i in _generate_opcode(code_object) if o == LOAD_GLOBAL}
+
     names = code_object.co_names
     result = {names[i] for i in indices}
 
     # On Python 3, comprehensions have their own scope. This is implemented
     # by generating a new code object for the comprehension which is stored
     # as a constant of the enclosing function's code object. If the comprehension
     # refers to global names, these names are listed in co_names of the code
@@ -124,15 +130,15 @@
            object in the function's global namespace is pickled. In case this object
            is a module, the modules __package__ name is pickled.
         3. All default arguments are pickled.
         4. All objects in the function's closure are pickled.
 
     Note that also this is heavily implementation specific and will probably only
     work with CPython. If possible, avoid using this method.
-    """
+    """  # noqa: D400
     closure = None if function.__closure__ is None else [c.cell_contents for c in function.__closure__]
     code = marshal.dumps(function.__code__)
     func_globals = function.__globals__
 
     def wrap_modules(x):
         return Module(x) if isinstance(x, ModuleType) else x
```

### Comparing `pymor-2022.2.1/src/pymor/discretizers/builtin/__init__.py` & `pymor-2023.1.0/src/pymor/discretizers/builtin/__init__.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
-from pymor.discretizers.builtin.cg import discretize_stationary_cg, discretize_instationary_cg
-from pymor.discretizers.builtin.fv import discretize_stationary_fv, discretize_instationary_fv
+from pymor.discretizers.builtin.cg import discretize_instationary_cg, discretize_stationary_cg
+from pymor.discretizers.builtin.fv import discretize_instationary_fv, discretize_stationary_fv
 from pymor.discretizers.builtin.grids.gmsh import load_gmsh
 from pymor.discretizers.builtin.grids.oned import OnedGrid
 from pymor.discretizers.builtin.grids.rect import RectGrid
 from pymor.discretizers.builtin.grids.tria import TriaGrid
```

### Comparing `pymor-2022.2.1/src/pymor/discretizers/builtin/cg.py` & `pymor-2023.1.0/src/pymor/discretizers/builtin/cg.py`

 * *Files 0% similar despite different names*

```diff
@@ -8,26 +8,25 @@
 
 import numpy as np
 from scipy.sparse import coo_matrix, csc_matrix
 
 from pymor.algorithms.preassemble import preassemble as preassemble_
 from pymor.algorithms.timestepping import ExplicitEulerTimeStepper, ImplicitEulerTimeStepper
 from pymor.analyticalproblems.elliptic import StationaryProblem
-from pymor.analyticalproblems.functions import Function, ConstantFunction, LincombFunction
+from pymor.analyticalproblems.functions import ConstantFunction, Function, LincombFunction
 from pymor.analyticalproblems.instationary import InstationaryProblem
 from pymor.discretizers.builtin.domaindiscretizers.default import discretize_domain_default
 from pymor.discretizers.builtin.grids.boundaryinfos import EmptyBoundaryInfo
-from pymor.discretizers.builtin.grids.referenceelements import line, triangle, square
-from pymor.discretizers.builtin.gui.visualizers import PatchVisualizer, OnedVisualizer
-from pymor.models.basic import StationaryModel, InstationaryModel
-from pymor.operators.constructions import LincombOperator
+from pymor.discretizers.builtin.grids.referenceelements import line, square, triangle
+from pymor.discretizers.builtin.gui.visualizers import OnedVisualizer, PatchVisualizer
+from pymor.models.basic import InstationaryModel, StationaryModel
+from pymor.operators.constructions import LincombOperator, QuadraticFunctional
 from pymor.operators.numpy import NumpyMatrixBasedOperator
 from pymor.vectorarrays.numpy import NumpyVectorSpace
 
-
 LagrangeShapeFunctions = {
     line: {1: [lambda X: 1 - X[..., 0],
                lambda X: X[..., 0]]},
     square: {1: [lambda X: (1 - X[..., 0]) * (1 - X[..., 1]),
                  lambda X: (1 - X[..., 1]) * (X[..., 0]),
                  lambda X:     (X[..., 0]) * (X[..., 1]),
                  lambda X:     (X[..., 1]) * (1 - X[..., 0])]},
@@ -144,15 +143,15 @@
     def _assemble(self, mu=None):
         g = self.grid
         bi = self.boundary_info
 
         NI = bi.boundaries(self.boundary_type, 1) if self.boundary_type else g.boundaries(1)
         if g.dim == 1:
             I = np.zeros(self.range.dim)
-            I[NI] = self.function(g.centers(1)[NI])
+            I[NI] = self.function(g.centers(1)[NI], mu=mu)
         else:
             F = self.function(g.centers(1)[NI], mu=mu)
             q, w = line.quadrature(order=1)
             # remove last dimension of q, as line coordinates are one dimensional
             q = q[:, 0]
             SF = np.array([1 - q, q])
             SF_INTS = np.einsum('e,pi,e,i->ep', F, SF, g.integration_elements(1)[NI], w).ravel()
@@ -849,16 +848,16 @@
     Parameters
     ----------
     grid
         The |Grid| over which to assemble the operator.
     boundary_info
         |BoundaryInfo| for the treatment of Dirichlet boundary conditions.
     robin_data
-        Tuple providing two |Functions| that represent the Robin parameter and boundary
-        value function. If `None`, the resulting operator is zero.
+        Tuple (c(x), g(x)) providing two |Functions| that represent the Robin parameter
+        and boundary value function. If `None`, the resulting operator is zero.
     solver_options
         The |solver_options| for the operator.
     name
         Name of the operator.
     """
 
     sparse = True
@@ -988,15 +987,15 @@
     assert grid is None or boundary_info is not None
     assert boundary_info is None or grid is not None
     assert grid is None or domain_discretizer is None
     assert grid_type is None or grid is None
 
     p = analytical_problem
 
-    if not (p.nonlinear_advection
+    if not (p.nonlinear_advection # noqa: E714
             == p.nonlinear_advection_derivative
             == p.nonlinear_reaction
             == p.nonlinear_reaction_derivative
             is None):
         raise NotImplementedError
 
     if grid is None:
@@ -1012,20 +1011,22 @@
 
     if grid.reference_element is square:
         DiffusionOperator = DiffusionOperatorQ1
         AdvectionOperator = AdvectionOperatorQ1
         ReactionOperator  = L2ProductQ1
         L2Functional = L2ProductFunctionalQ1
         BoundaryL2Functional = BoundaryL2ProductFunctional
+        L2Product = L2ProductQ1
     else:
         DiffusionOperator = DiffusionOperatorP1
         AdvectionOperator = AdvectionOperatorP1
         ReactionOperator  = L2ProductP1
         L2Functional = L2ProductFunctionalP1
         BoundaryL2Functional = BoundaryL2ProductFunctional
+        L2Product = L2ProductP1
 
     Li = [DiffusionOperator(grid, boundary_info, diffusion_constant=0, name='boundary_part')]
     if mu_energy_product:
         eLi = [DiffusionOperator(grid, boundary_info, dirichlet_clear_columns=True, diffusion_constant=0)]
     coefficients = [1.]
 
     # diffusion part
@@ -1120,15 +1121,15 @@
         if isinstance(p.robin_data[0], LincombFunction):
             Fi += [BoundaryL2Functional(grid, rob * p.robin_data[1], boundary_info=boundary_info,
                                         boundary_type='robin', dirichlet_clear_dofs=True, name=f'robin_{i}')
                    for i, rob in enumerate(p.robin_data[0].functions)]
             coefficients_F += list(p.robin_data[0].coefficients)
         else:
             Fi += [BoundaryL2Functional(grid, p.robin_data[0] * p.robin_data[1], boundary_info=boundary_info,
-                                        boundary_type='robin', dirichlet_clear_dofs=True)]
+                                        boundary_type='robin', dirichlet_clear_dofs=True, name='robin')]
             coefficients_F.append(1.)
 
     if p.dirichlet_data is not None and boundary_info.has_dirichlet:
         if isinstance(p.dirichlet_data, LincombFunction):
             Fi += [BoundaryDirichletFunctional(grid, di, boundary_info, name=f'dirichlet{i}')
                    for i, di in enumerate(p.dirichlet_data.functions)]
             coefficients_F += list(p.dirichlet_data.coefficients)
@@ -1156,32 +1157,42 @@
                 'l2': l2_product,
                 'h1_0': l2_0_product + h1_0_semi_product,
                 'h1_0_semi': h1_0_semi_product,
                 'l2_0': l2_0_product}
 
     # assemble additional output functionals
     if p.outputs:
-        if any(v[0] not in ('l2', 'l2_boundary') for v in p.outputs):
+        if any(v[0] not in ('l2', 'l2_boundary', 'quadratic') for v in p.outputs):
             raise NotImplementedError
         outputs = []
         for v in p.outputs:
             if v[0] == 'l2':
                 if isinstance(v[1], LincombFunction):
                     ops = [L2Functional(grid, vv, dirichlet_clear_dofs=False).H
                            for vv in v[1].functions]
                     outputs.append(LincombOperator(ops, v[1].coefficients))
                 else:
                     outputs.append(L2Functional(grid, v[1], dirichlet_clear_dofs=False).H)
-            else:
+            elif v[0] == 'l2_boundary':
                 if isinstance(v[1], LincombFunction):
                     ops = [BoundaryL2Functional(grid, vv, dirichlet_clear_dofs=False).H
                            for vv in v[1].functions]
                     outputs.append(LincombOperator(ops, v[1].coefficients))
                 else:
                     outputs.append(BoundaryL2Functional(grid, v[1], dirichlet_clear_dofs=False).H)
+            elif v[0] == 'quadratic':
+                if isinstance(v[1], LincombFunction):
+                    ops = [
+                        QuadraticFunctional(
+                            L2Product(grid, boundary_info, dirichlet_clear_rows=False, coefficient_function=vv)
+                        ) for vv in v[1].functions]
+                    outputs.append(LincombOperator(ops, v[1].coefficients))
+                else:
+                    outputs.append(QuadraticFunctional(
+                        L2Product(grid, boundary_info, dirichlet_clear_rows=False, coefficient_function=v[1])))
         if len(outputs) > 1:
             from pymor.operators.block import BlockColumnOperator
             from pymor.operators.constructions import NumpyConversionOperator
             output_functional = BlockColumnOperator(outputs)
             output_functional = NumpyConversionOperator(output_functional.range) @ output_functional
         else:
             output_functional = outputs[0]
@@ -1246,15 +1257,16 @@
         A |BoundaryInfo| specifying the boundary types of the grid boundary entities.
         Must be provided if `grid` is specified.
     num_values
         The number of returned vectors of the solution trajectory. If `None`, each
         intermediate vector that is calculated is returned.
     time_stepper
         The :class:`time-stepper <pymor.algorithms.timestepping.TimeStepper>`
-        to be used by :class:`~pymor.models.basic.InstationaryModel.solve`.
+        to be used by :meth:`~pymor.models.interface.Model.solve` of
+        |InstationaryModel|.
     nt
         If `time_stepper` is not specified, the number of time steps for implicit
         Euler time stepping.
     preassemble
         If `True`, preassemble all operators in the resulting |Model|.
 
     Returns
@@ -1280,15 +1292,16 @@
 
     if p.stationary_part.dirichlet_data is not None and 't' in p.stationary_part.dirichlet_data.parameters:
         # we choose both mass and operator to be invertible.
         # this leads to wrong results when the dirichlet values depend on time.
         raise NotImplementedError('Time-dependent Dirichlet values not supported.')
 
     m, data = discretize_stationary_cg(p.stationary_part, diameter=diameter, domain_discretizer=domain_discretizer,
-                                       grid_type=grid_type, grid=grid, boundary_info=boundary_info)
+                                       grid_type=grid_type, grid=grid, boundary_info=boundary_info,
+                                       preassemble=preassemble)
 
     if p.initial_data.parametric:
         I = InterpolationOperator(data['grid'], p.initial_data)
     else:
         I = p.initial_data.evaluate(data['grid'].centers(data['grid'].dim))
         I = m.solution_space.make_array(I)
 
@@ -1304,11 +1317,14 @@
                           products=m.products,
                           output_functional=m.output_functional,
                           time_stepper=time_stepper,
                           visualizer=m.visualizer,
                           num_values=num_values, name=f'{p.name}_CG')
 
     if preassemble:
-        data['unassembled_m'] = m
+        # m has preassembled stationary parts, whose unassembled version we get from data
+        ua_m = data['unassembled_m']
+        unassembled_m = m.with_(operator=ua_m.operator, rhs=ua_m.rhs, products=ua_m.products)
+        data['unassembled_m'] = unassembled_m
         m = preassemble_(m)
 
     return m, data
```

### Comparing `pymor-2022.2.1/src/pymor/discretizers/builtin/domaindiscretizers/default.py` & `pymor-2023.1.0/src/pymor/discretizers/builtin/domaindiscretizers/default.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,49 +1,56 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 import math as m
+
 import numpy as np
 
-from pymor.analyticalproblems.domaindescriptions import (RectDomain, CylindricalDomain, TorusDomain, LineDomain,
-                                                         CircleDomain, PolygonalDomain)
-from pymor.discretizers.builtin.grids.boundaryinfos import GenericBoundaryInfo, EmptyBoundaryInfo
+from pymor.analyticalproblems.domaindescriptions import (
+    CircleDomain,
+    CylindricalDomain,
+    LineDomain,
+    PolygonalDomain,
+    RectDomain,
+    TorusDomain,
+)
+from pymor.discretizers.builtin.grids.boundaryinfos import EmptyBoundaryInfo, GenericBoundaryInfo
 from pymor.discretizers.builtin.grids.oned import OnedGrid
 from pymor.discretizers.builtin.grids.rect import RectGrid
 from pymor.discretizers.builtin.grids.tria import TriaGrid
 from pymor.tools.floatcmp import float_cmp
 
 
 def discretize_domain_default(domain_description, diameter=1 / 100, grid_type=None):
     """Mesh a |DomainDescription| using an appropriate default implementation.
 
     This method can discretize the following |DomainDescriptions|:
 
-        +----------------------+-------------+---------+
-        | DomainDescription    | grid_type   | default |
-        +======================+=============+=========+
-        | |RectDomain|         | |TriaGrid|  |    X    |
-        |                      +-------------+---------+
-        |                      | |RectGrid|  |         |
-        +----------------------+-------------+---------+
-        | |CylindricalDomain|  | |TriaGrid|  |    X    |
-        |                      +-------------+---------+
-        |                      | |RectGrid|  |         |
-        +----------------------+-------------+---------+
-        | |TorusDomain|        | |TriaGrid|  |    X    |
-        |                      +-------------+---------+
-        |                      | |RectGrid|  |         |
-        +----------------------+-------------+---------+
-        | |LineDomain|         | |OnedGrid|  |    X    |
-        +----------------------+-------------+---------+
-        | |CircleDomain|       | |OnedGrid|  |    X    |
-        +----------------------+-------------+---------+
-        | |PolygonalDomain|    | |GmshGrid|  |    X    |
-        +----------------------+-------------+---------+
+        +----------------------+-----------------------------+---------+
+        | DomainDescription    | grid_type                   | default |
+        +======================+=============================+=========+
+        | |RectDomain|         | |TriaGrid|                  |    X    |
+        |                      +-----------------------------+---------+
+        |                      | |RectGrid|                  |         |
+        +----------------------+-----------------------------+---------+
+        | |CylindricalDomain|  | |TriaGrid|                  |    X    |
+        |                      +-----------------------------+---------+
+        |                      | |RectGrid|                  |         |
+        +----------------------+-----------------------------+---------+
+        | |TorusDomain|        | |TriaGrid|                  |    X    |
+        |                      +-----------------------------+---------+
+        |                      | |RectGrid|                  |         |
+        +----------------------+-----------------------------+---------+
+        | |LineDomain|         | |OnedGrid|                  |    X    |
+        +----------------------+-----------------------------+---------+
+        | |CircleDomain|       | |OnedGrid|                  |    X    |
+        +----------------------+-----------------------------+---------+
+        | |PolygonalDomain|    | |UnstructuredTriangleGrid|  |    X    |
+        +----------------------+-----------------------------+---------+
 
     Parameters
     ----------
     domain_description
         A |DomainDescription| of the domain to mesh.
     diameter
         Maximal diameter of the codim-0 entities of the generated |Grid|.
@@ -166,16 +173,16 @@
         if grid_type not in (TriaGrid, RectGrid):
             raise NotImplementedError(f'I do not know how to discretize {type(domain_description)} with {grid_type}')
         if isinstance(domain_description, CylindricalDomain):
             return discretize_CylindricalDomain()
         else:
             return discretize_TorusDomain()
     elif isinstance(domain_description, PolygonalDomain):
-        from pymor.discretizers.builtin.grids.unstructured import UnstructuredTriangleGrid
         from pymor.discretizers.builtin.domaindiscretizers.gmsh import discretize_gmsh
+        from pymor.discretizers.builtin.grids.unstructured import UnstructuredTriangleGrid
         assert grid_type is None or grid_type is UnstructuredTriangleGrid
         return discretize_gmsh(domain_description, clscale=diameter)
     else:
         grid_type = grid_type or OnedGrid
         if grid_type is not OnedGrid:
             raise NotImplementedError(f'I do not know hot to discretize {type(domain_description)} with {grid_type}')
         return discretize_LineDomain() if isinstance(domain_description, LineDomain) else discretize_CircleDomain()
```

### Comparing `pymor-2022.2.1/src/pymor/discretizers/builtin/domaindiscretizers/gmsh.py` & `pymor-2023.1.0/src/pymor/discretizers/builtin/domaindiscretizers/gmsh.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,21 +1,21 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
-import tempfile
 import collections
 import os
 import subprocess
+import tempfile
 import time
 
-from pymor.analyticalproblems.domaindescriptions import RectDomain, PolygonalDomain
-from pymor.discretizers.builtin.grids.gmsh import load_gmsh
-from pymor.core.exceptions import GmshMissing
+from pymor.analyticalproblems.domaindescriptions import PolygonalDomain, RectDomain
+from pymor.core.exceptions import GmshMissingError
 from pymor.core.logger import getLogger
+from pymor.discretizers.builtin.grids.gmsh import load_gmsh
 
 
 def discretize_gmsh(domain_description=None, geo_file=None, geo_file_path=None, msh_file_path=None,
                     mesh_algorithm='del2d', clscale=1., options='', refinement_steps=0):
     """Mesh a |DomainDescription| or an already existing Gmsh GEO-file using the Gmsh mesher.
 
     Parameters
@@ -42,32 +42,32 @@
         options.
     refinement_steps
         Number of refinement steps to do after the initial meshing.
 
     Returns
     -------
     grid
-        The generated :class:`~pymor.discretizers.builtin.grids.gmsh.GmshGrid`.
+        The generated |UnstructuredTriangleGrid|.
     boundary_info
-        The generated :class:`~pymor.discretizers.builtin.grids.gmsh.GmshBoundaryInfo`.
+        The generated |BoundaryInfo|.
     """
     assert domain_description is None or geo_file is None
     logger = getLogger('pymor.discretizers.builtin.domaindiscretizers.gmsh.discretize_gmsh')
 
     # run Gmsh; initial meshing
     logger.info('Checking for Gmsh ...')
 
     # when we are running MPI parallel and Gmsh is compiled with MPI support,
     # we have to make sure Gmsh does not notice the MPI environment or it will fail.
     env = {k: v for k, v in os.environ.items()
            if 'MPI' not in k.upper()}
     try:
         version = subprocess.check_output(['gmsh', '--version'], stderr=subprocess.STDOUT, env=env).decode()
     except (subprocess.CalledProcessError, OSError) as e:
-        raise GmshMissing('Could not find Gmsh.'
+        raise GmshMissingError('Could not find Gmsh.'
                           ' Please ensure that the gmsh binary (https://gmsh.info/) is in your PATH.') from e
 
     logger.info('Found version ' + version.strip())
 
     def discretize_PolygonalDomain():
         # combine points and holes, since holes are points, too, and have to be stored as such.
         points = [domain_description.points]
@@ -183,15 +183,15 @@
             logger.info(f'Performing Gmsh refinement step {i+1}')
             subprocess.check_call(cmd, env=env)
 
         toc = time.perf_counter()
         t_gmsh = toc - tic
         logger.info(f'Gmsh took {t_gmsh} s')
 
-        # Create |GmshGrid| and |GmshBoundaryInfo| form the just created MSH-file.
+        # Create |UnstructuredTriangleGrid| and |BoundaryInfo| from the just created MSH-file.
         grid, bi = load_gmsh(msh_file_path)
     finally:
         # delete tempfiles if they were created beforehand.
         if isinstance(geo_file, tempfile._TemporaryFileWrapper):
             os.remove(geo_file_path)
         if isinstance(msh_file, tempfile._TemporaryFileWrapper):
             os.remove(msh_file_path)
```

### Comparing `pymor-2022.2.1/src/pymor/discretizers/builtin/fv.py` & `pymor-2023.1.0/src/pymor/discretizers/builtin/fv.py`

 * *Files 0% similar despite different names*

```diff
@@ -13,19 +13,19 @@
 from pymor.analyticalproblems.elliptic import StationaryProblem
 from pymor.analyticalproblems.functions import Function, LincombFunction
 from pymor.analyticalproblems.instationary import InstationaryProblem
 from pymor.core.base import abstractmethod
 from pymor.core.defaults import defaults
 from pymor.discretizers.builtin.domaindiscretizers.default import discretize_domain_default
 from pymor.discretizers.builtin.grids.interfaces import GridWithOrthogonalCenters
-from pymor.discretizers.builtin.grids.referenceelements import line, triangle, square
+from pymor.discretizers.builtin.grids.referenceelements import line, square, triangle
 from pymor.discretizers.builtin.grids.subgrid import SubGrid, make_sub_grid_boundary_info
-from pymor.discretizers.builtin.gui.visualizers import PatchVisualizer, OnedVisualizer
+from pymor.discretizers.builtin.gui.visualizers import OnedVisualizer, PatchVisualizer
 from pymor.discretizers.builtin.quadratures import GaussQuadratures
-from pymor.models.basic import StationaryModel, InstationaryModel
+from pymor.models.basic import InstationaryModel, StationaryModel
 from pymor.operators.constructions import ComponentProjectionOperator, LincombOperator, ZeroOperator
 from pymor.operators.interface import Operator
 from pymor.operators.numpy import NumpyGenericOperator, NumpyMatrixBasedOperator, NumpyMatrixOperator
 from pymor.parameters.base import ParametricObject
 from pymor.vectorarrays.numpy import NumpyVectorSpace
 
 
@@ -574,14 +574,29 @@
         A = dia_matrix((self.reaction_coefficient.evaluate(self.grid.centers(0), mu=mu), [0]),
                        shape=(self.grid.size(0),) * 2)
 
         return A
 
 
 class NonlinearReactionOperator(Operator):
+    """Finite Volume nonlinear reaction |Operator|.
+
+    Parameters
+    ----------
+    grid
+        The |Grid| for which to assemble the operator.
+    reaction_function
+        The reaction function.
+    reaction_function_derivative
+        The reaction function derivative.
+    space_id
+        Space ID.
+    name
+        The name of the operator.
+    """
 
     linear = False
 
     def __init__(self, grid, reaction_function, reaction_function_derivative=None, space_id='STATE', name=None):
         self.__auto_init(locals())
         self.source = self.range = FVVectorSpace(grid, space_id)
 
@@ -1087,15 +1102,15 @@
     return m, data
 
 
 def discretize_instationary_fv(analytical_problem, diameter=None, domain_discretizer=None, grid_type=None,
                                num_flux='lax_friedrichs', lxf_lambda=1., eo_gausspoints=5, eo_intervals=1,
                                grid=None, boundary_info=None, num_values=None, time_stepper=None, nt=None,
                                preassemble=True):
-    """FV Discretization of an |InstationaryProblem| with a |StationaryProblem| as stationary part
+    """FV Discretization of an |InstationaryProblem| with a |StationaryProblem| as stationary part.
 
     Parameters
     ----------
     analytical_problem
         The |InstationaryProblem| to discretize.
     diameter
         If not `None`, `diameter` is passed to the `domain_discretizer`.
@@ -1127,15 +1142,16 @@
         A |BoundaryInfo| specifying the boundary types of the grid boundary entities.
         Must be provided if `grid` is specified.
     num_values
         The number of returned vectors of the solution trajectory. If `None`, each
         intermediate vector that is calculated is returned.
     time_stepper
         The :class:`time-stepper <pymor.algorithms.timestepping.TimeStepper>`
-        to be used by :class:`~pymor.models.basic.InstationaryModel.solve`.
+        to be used by :meth:`~pymor.models.interface.Model.solve` of
+        |InstationaryModel|.
     nt
         If `time_stepper` is not specified, the number of time steps for implicit
         Euler time stepping.
     preassemble
         If `True`, preassemble all operators in the resulting |Model|.
 
     Returns
```

### Comparing `pymor-2022.2.1/src/pymor/discretizers/builtin/grids/boundaryinfos.py` & `pymor-2023.1.0/src/pymor/discretizers/builtin/grids/boundaryinfos.py`

 * *Files identical despite different names*

### Comparing `pymor-2022.2.1/src/pymor/discretizers/builtin/grids/constructions.py` & `pymor-2023.1.0/src/pymor/discretizers/builtin/grids/constructions.py`

 * *Ordering differences only*

 * *Files 0% similar despite different names*

```diff
@@ -1,17 +1,17 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 import numpy as np
 
-from pymor.tools.floatcmp import float_cmp
 from pymor.discretizers.builtin.grids.rect import RectGrid
 from pymor.discretizers.builtin.grids.tria import TriaGrid
 from pymor.discretizers.builtin.relations import inverse_relation
+from pymor.tools.floatcmp import float_cmp
 
 
 def flatten_grid(grid):
     """Flatten a |Grid|.
 
     This method is used by our visualizers to render n-dimensional grids which cannot
     be embedded into R^n by duplicating vertices which would have to be mapped to multiple
```

### Comparing `pymor-2022.2.1/src/pymor/discretizers/builtin/grids/gmsh.py` & `pymor-2023.1.0/src/pymor/discretizers/builtin/grids/gmsh.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,38 +1,39 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
-import numpy as np
 import time
 
+import numpy as np
+
 from pymor.core.config import config
-from pymor.core.exceptions import MeshioMissing
+from pymor.core.exceptions import MeshioMissingError
 from pymor.core.logger import getLogger
-from pymor.discretizers.builtin.grids.boundaryinfos import GenericBoundaryInfo, EmptyBoundaryInfo
+from pymor.discretizers.builtin.grids.boundaryinfos import EmptyBoundaryInfo, GenericBoundaryInfo
 from pymor.discretizers.builtin.grids.unstructured import UnstructuredTriangleGrid
 
 
 def load_gmsh(filename):
-    """Parse a Gmsh file and create a corresponding :class:`GmshGrid` and :class:`GmshBoundaryInfo`.
+    """Parse a Gmsh file and create a corresponding grid and boundary info.
 
     Parameters
     ----------
     filename
         Path of the Gmsh MSH-file.
 
     Returns
     -------
     grid
-        The generated :class:`GmshGrid`.
+        The generated |UnstructuredTriangleGrid|.
     boundary_info
-        The generated :class:`GmshBoundaryInfo`.
+        The generated |BoundaryInfo|.
     """
     if not config.HAVE_MESHIO:
-        raise MeshioMissing('meshio (>=4) is required for reading Gmsh files.')
+        raise MeshioMissingError('meshio (>=4) is required for reading Gmsh files.')
     import meshio
 
     logger = getLogger('pymor.discretizers.builtin.grids.gmsh.load_gmsh')
 
     logger.info('Parsing Gmsh file ...')
     tic = time.perf_counter()
     data = meshio.read(filename)
@@ -53,15 +54,15 @@
     vertices = data.points[:, :2]
     faces = cells_dict['triangle']
 
     grid = UnstructuredTriangleGrid.from_vertices(vertices, faces)
     toc = time.perf_counter()
     t_grid = toc - tic
 
-    logger.info('Create GmshBoundaryInfo ...')
+    logger.info('Create BoundaryInfo ...')
     tic = time.perf_counter()
 
     boundary_types = {k: v[0] for k, v in data.field_data.items() if v[1] == 1}
 
     cell_data_dict = data.cell_data_dict
     if 'line' in cells_dict and 'gmsh:physical' in cell_data_dict and 'line' in cell_data_dict['gmsh:physical']:
         superentities = grid.superentities(2, 1)
```

### Comparing `pymor-2022.2.1/src/pymor/discretizers/builtin/grids/interfaces.py` & `pymor-2023.1.0/src/pymor/discretizers/builtin/grids/interfaces.py`

 * *Files 0% similar despite different names*

```diff
@@ -237,15 +237,15 @@
     def _superentities_with_indices(self, codim, superentity_codim):
         assert 0 <= codim <= self.dim, f'Invalid codimension (was {codim})'
         assert 0 <= superentity_codim <= codim, f'Invalid codimension (was {superentity_codim})'
         SE = self.subentities(superentity_codim, codim)
         return inverse_relation(SE, size_rhs=self.size(codim), with_indices=True)
 
     def neighbours(self, codim, neighbour_codim, intersection_codim=None):
-        """Maps entity index and local neighbour index to global neighbour index
+        """Maps entity index and local neighbour index to global neighbour index.
 
         `retval[e,n]` is the global index of the `n`-th codim-`neighbour_codim` entity of the
         codim-`codim` entity `e` that shares with `e` a subentity of codimension
         `intersection_codim`.
 
         If `intersection_codim == None`, it is set to `codim + 1` if `codim == neighbour_codim` and
         to `min(codim, neighbour_codim)` otherwise.
@@ -491,15 +491,17 @@
     @cached
     def _diameters(self, codim):
         assert 0 <= codim <= self.dim,\
             f'Invalid Codimension (must be between 0 and {self.dim} but was {codim})'
         return np.reshape(self.reference_element(codim).mapped_diameter(self.embeddings(codim)[0]), (-1,))
 
     def quadrature_points(self, codim, order=None, npoints=None, quadrature_type='default'):
-        """`retval[e]` is an array of quadrature points in global coordinates for the codim-`codim`
+        """Returns the quadrature points.
+
+        `retval[e]` is an array of quadrature points in global coordinates for the codim-`codim`
         entity with global index `e`.
 
         The quadrature is of order `order` or has `npoints` integration points. To integrate a
         function `f` over `e` one has to form ::
 
             np.dot(f(quadrature_points(codim, order)[e]),
                 reference_element(codim).quadrature(order)[1]) *
```

### Comparing `pymor-2022.2.1/src/pymor/discretizers/builtin/grids/io.py` & `pymor-2023.1.0/src/pymor/discretizers/builtin/grids/io.py`

 * *Files 2% similar despite different names*

```diff
@@ -4,15 +4,15 @@
 
 from pymor.core.config import config
 from pymor.discretizers.builtin.grids import referenceelements
 from pymor.discretizers.builtin.grids.constructions import flatten_grid
 
 
 def to_meshio(grid, data, codim=2):
-    """Transform given |Grid| and |VectorArray| data into a sequence of meshio.Mesh objects
+    """Transform given |Grid| and |VectorArray| data into a sequence of meshio.Mesh objects.
 
     Parameters
     ----------
     grid
         A |Grid| with triangular or rectilinear reference element.
     data
         |VectorArray| with either cell (ie one datapoint per codim 0 entity)
@@ -30,20 +30,20 @@
 
     subentities, coordinates, entity_map = flatten_grid(grid)
     data = data.to_numpy() if codim == 0 else data.to_numpy()[:, entity_map].copy()
     is_cell_data = (codim == 0)
 
     ref = grid.reference_element
     if ref is referenceelements.triangle:
-        cells = [("triangle", subentities), ]
+        cells = [('triangle', subentities), ]
     elif ref is referenceelements.square:
-        cells = [("quad", subentities), ]
+        cells = [('quad', subentities), ]
     else:
-        raise NotImplementedError("Meshio conversion restricted to grid with triangle or rectangle reference elements")
+        raise NotImplementedError('Meshio conversion restricted to grid with triangle or rectangle reference elements')
 
     meshes = []
     for i in range(len(data)):
         if is_cell_data:
-            meshes.append(meshio.Mesh(coordinates, cells, cell_data={"Data": [data[i, :]]}))
+            meshes.append(meshio.Mesh(coordinates, cells, cell_data={'Data': [data[i, :]]}))
         else:
-            meshes.append(meshio.Mesh(coordinates, cells, point_data={"Data": data[i, :]}))
+            meshes.append(meshio.Mesh(coordinates, cells, point_data={'Data': data[i, :]}))
     return meshes
```

### Comparing `pymor-2022.2.1/src/pymor/discretizers/builtin/grids/oned.py` & `pymor-2023.1.0/src/pymor/discretizers/builtin/grids/oned.py`

 * *Files identical despite different names*

### Comparing `pymor-2022.2.1/src/pymor/discretizers/builtin/grids/rect.py` & `pymor-2023.1.0/src/pymor/discretizers/builtin/grids/rect.py`

 * *Files identical despite different names*

### Comparing `pymor-2022.2.1/src/pymor/discretizers/builtin/grids/referenceelements.py` & `pymor-2023.1.0/src/pymor/discretizers/builtin/grids/referenceelements.py`

 * *Files identical despite different names*

### Comparing `pymor-2022.2.1/src/pymor/discretizers/builtin/grids/subgrid.py` & `pymor-2023.1.0/src/pymor/discretizers/builtin/grids/subgrid.py`

 * *Files 3% similar despite different names*

```diff
@@ -23,15 +23,15 @@
     parent_entities
         |NumPy array| of global indices of the codim-0 entities which
         are to be contained in the subgrid.
 
     Attributes
     ----------
     parent_grid
-        The |Grid| from which the subgrid was constructed. :class:`Subgrid`
+        The |Grid| from which the subgrid was constructed. :class:`SubGrid`
         only stores a :mod:`weakref` to the grid, so accessing this property
         might return `None` if the original grid has been destroyed.
     """
 
     reference_element = None
 
     def __init__(self, parent_grid, parent_entities):
@@ -114,21 +114,20 @@
     def __getstate__(self):
         d = self.__dict__.copy()
         del d['_SubGrid__parent_grid']
         return d
 
 
 def make_sub_grid_boundary_info(sub_grid, parent_grid, parent_grid_boundary_info, new_boundary_type=None):
-    """Derives a |BoundaryInfo| for a :class:`~pymor.discretizers.builtin.grids.subgrid.SubGrid`.
+    """Derives a |BoundaryInfo| for a :class:`SubGrid`.
 
     Parameters
     ----------
     sub_grid
-        The :class:`~pymor.discretizers.builtin.grids.subgrid.SubGrid` for which a
-        |BoundaryInfo| is created.
+        The :class:`SubGrid` for which a |BoundaryInfo| is created.
     parent_grid
         The parent |Grid|.
     parent_grid_boundary_info
         The |BoundaryInfo| of the parent |Grid| from which to derive the |BoundaryInfo|
     new_boundary_type
         The boundary type which is assigned to the new boundaries of `subgrid`. If
         `None`, no boundary type is assigned.
```

### Comparing `pymor-2022.2.1/src/pymor/discretizers/builtin/grids/tria.py` & `pymor-2023.1.0/src/pymor/discretizers/builtin/grids/tria.py`

 * *Files identical despite different names*

### Comparing `pymor-2022.2.1/src/pymor/discretizers/builtin/grids/unstructured.py` & `pymor-2023.1.0/src/pymor/discretizers/builtin/grids/unstructured.py`

 * *Files identical despite different names*

### Comparing `pymor-2022.2.1/src/pymor/discretizers/builtin/grids/vtkio.py` & `pymor-2023.1.0/src/pymor/discretizers/builtin/grids/vtkio.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,16 +1,17 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 from pymor.core.config import config
+
 config.require('VTKIO')
 
 
 from pymor.discretizers.builtin.grids.io import to_meshio
 from pymor.tools.io.vtk import write_vtk_collection
 
 
 def write_vtk(grid, data, filename_base, codim=2, metadata=None):
-    """Convenience function around write_vtk_collection(to_meshio(...))"""
+    """Convenience function around write_vtk_collection(to_meshio(...))."""
     return write_vtk_collection(meshes=to_meshio(grid, data, codim=codim),
                                 filename_base=filename_base, metadata=metadata)
```

### Comparing `pymor-2022.2.1/src/pymor/discretizers/builtin/gui/jupyter/__init__.py` & `pymor-2023.1.0/src/pymor/discretizers/builtin/gui/jupyter/__init__.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,43 +1,47 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
-"""This module provides plotting support inside the Jupyter notebook.
-
-To use these routines you first have to execute ::
-
-        %matplotlib notebook
-
-inside the given notebook.
-"""
+"""This module provides plotting support inside the Jupyter notebook."""
 import IPython
+from packaging.version import parse as parse_version
 
-from pymor.core.defaults import defaults
 from pymor.core.config import config
+from pymor.core.defaults import defaults
 
 # AFAICT there is no robust way to query for loaded extensions
 # and we have to make sure we do not setup two redirects
 _extension_loaded = False
 
 
 @defaults('backend')
-def get_visualizer(backend='py3js'):
-    if backend not in ('py3js', 'MPL'):
+def get_visualizer(backend='prefer_k3d'):
+    if backend not in ('MPL', 'k3d', 'prefer_k3d'):
         raise ValueError
-    if backend == 'py3js' and config.HAVE_PYTHREEJS:
-        from pymor.discretizers.builtin.gui.jupyter.threejs import visualize_py3js
-        return visualize_py3js
+    if backend == 'prefer_k3d':
+        if config.HAVE_K3D:
+            import k3d
+            if parse_version(k3d.__version__) >= parse_version('2.15.4'):
+                backend = 'k3d'
+            else:
+                backend = 'MPL'
+        else:
+            backend = 'MPL'
+    if backend == 'k3d':
+        from pymor.discretizers.builtin.gui.jupyter.kthreed import visualize_k3d
+        return visualize_k3d
     else:
         from pymor.discretizers.builtin.gui.jupyter.matplotlib import visualize_patch
         return visualize_patch
 
 
 def progress_bar(sequence, every=None, size=None, name='Parameters'):
-    from ipywidgets import IntProgress, HTML, VBox
+    from ipywidgets import HTML, IntProgress, VBox
+
     # c&p from https://github.com/kuk/log-progress
     is_iterator = False
     if size is None:
         try:
             size = len(sequence)
         except TypeError:
             is_iterator = True
```

### Comparing `pymor-2022.2.1/src/pymor/discretizers/builtin/gui/jupyter/logging.py` & `pymor-2023.1.0/src/pymor/discretizers/builtin/gui/jupyter/logging.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,13 +1,14 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
-import ipywidgets
 import logging
+
+import ipywidgets
 from IPython.display import display
 
 from pymor.core import logger
 from pymor.core.logger import ColoredFormatter
 
 
 class LogViewer(logging.Handler):
```

### Comparing `pymor-2022.2.1/src/pymor/discretizers/builtin/gui/jupyter/threejs.py` & `pymor-2023.1.0/src/pymor/reductors/loewner.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,343 +1,344 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
-import asyncio
-from io import BytesIO
 
 import numpy as np
-from ipywidgets import IntSlider, interact, widgets, Play, Layout, Label
-import pythreejs as p3js
-try:
-    from matplotlib import colormaps
-except ImportError:  # matplotlib<3.5
-    from matplotlib.cm import get_cmap as colormaps
-
-from pymor.core import config
-from pymor.discretizers.builtin.grids.referenceelements import triangle, square
-from pymor.discretizers.builtin.grids.constructions import flatten_grid
-from pymor.vectorarrays.interface import VectorArray
-
-# we should try to limit ourselves to webgl 1.0 here since 2.0 (draft) is not as widely supported
-# https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API#Browser_compatibility
-# version directives and such are prepended by threejs
-RENDER_VERTEX_SHADER = """
-    attribute float data;
-    varying float texcoord;
-
-    void main()
-    {
-        texcoord = data;
-        gl_Position =  projectionMatrix * modelViewMatrix * vec4(position,1.0);
-    }
-    """
+import scipy.linalg as spla
+
+from pymor.core.cache import CacheableObject, cached
+from pymor.models.iosys import LTIModel
+from pymor.models.transfer_function import TransferFunction
+from pymor.tools.random import new_rng
+
 
-RENDER_FRAGMENT_SHADER = """
-    uniform sampler2D colormap;
-    varying float texcoord;
-
-    void main()
-    {
-        gl_FragColor = texture2D(colormap, vec2(texcoord, 0.));
-    }
+class LoewnerReductor(CacheableObject):
+    """Reductor based on Loewner interpolation framework.
+
+    The reductor implements interpolation based on the Loewner framework as in :cite:`ALI17`.
+
+    Parameters
+    ----------
+    s
+        |Numpy Array| of shape (n,) containing the frequencies.
+    Hs
+        |Numpy Array| of shape (n, p, m) for MIMO systems with p outputs and m inputs or
+        |Numpy Array| of shape (n,) for SISO systems where the |Numpy Arrays| resemble the transfer
+        function samples. Alternatively, |TransferFunction| or `Model` with `transfer_function`
+        attribute.
+    partitioning
+        `str` or `tuple` of length 2. Strings can either be 'even-odd' or 'half-half' defining
+        the partitioning rule. A user-defined partitioning can be defined by passing a tuple of the
+        left and right indices. Defaults to `even-odd`.
+    ordering
+        The ordering with respect to which the partitioning rule is executed. Can be either
+        'magnitude', 'random' or 'regular'. Defaults to 'regular'.
+    conjugate
+        Whether to guarantee realness of reduced |LTIModel| by keeping complex conjugates in the
+        same partitioning or not. If `True` will automatically generate conjugate data if necessary.
+    mimo_handling
+        Option indicating how to treat MIMO systems. Can be:
+
+        - `'random'` for using random tangential directions.
+        - `'full'` for fully interpolating all input-output pairs.
+        - Tuple `(ltd, rtd)` where `ltd` corresponds to left and `rtd` to right tangential
+          directions.
     """
 
+    cache_region = 'memory'
 
-def _normalize(u, vmin=None, vmax=None):
-    # rescale to be in [max(0,vmin), min(1,vmax)], scale nan to be the smallest value
-    vmin = np.nanmin(u) if vmin is None else vmin
-    vmax = np.nanmax(u) if vmax is None else vmax
-    u -= vmin
-    if (vmax - vmin) > 0:
-        u /= float(vmax - vmin)
-    return np.nan_to_num(u)
-
-
-class Renderer(widgets.VBox):
-    def __init__(self, U, grid, render_size, color_map, title, bounding_box=([0, 0], [1, 1]), codim=2,
-                 vmin=None, vmax=None):
-        assert grid.reference_element in (triangle, square)
-        assert grid.dim == 2
-        assert codim in (0, 2)
-        self.layout = Layout(min_width=str(render_size[0]), min_height=str(render_size[1]), margin='10px')
-        self.grid = grid
-        self.codim = codim
-        self.vmin, self.vmax = vmin, vmax
-
-        subentities, coordinates, self.entity_map = flatten_grid(grid)
-
-        if grid.reference_element == triangle:
-            if codim == 2:
-                vertices = np.zeros((len(coordinates), 3))
-                vertices[:, :-1] = coordinates
-                indices = subentities
-            else:
-                vertices = np.zeros((len(subentities) * 3, 3))
-                VERTEX_POS = coordinates[subentities]
-                vertices[:, 0:2] = VERTEX_POS.reshape((-1, 2))
-                indices = np.arange(len(subentities) * 3, dtype=np.uint32)
+    def __init__(self, s, Hs, partitioning='even-odd', ordering='regular', conjugate=True, mimo_handling='random'):
+        assert isinstance(s, np.ndarray)
+        if hasattr(Hs, 'transfer_function'):
+            Hs = Hs.transfer_function
+        assert isinstance(Hs, (TransferFunction, np.ndarray, list))
+
+        assert partitioning in ('even-odd', 'half-half') \
+            or len(partitioning) == 2 \
+            and len(partitioning[0]) + len(partitioning[1]) == len(s)
+        assert ordering in ('magnitude', 'random', 'regular')
+
+        if isinstance(Hs, TransferFunction):
+            Hss = np.empty((len(s), Hs.dim_output, Hs.dim_input), dtype=s[0].dtype)
+            for i, ss in enumerate(s):
+                Hss[i] = Hs.eval_tf(ss)
+            Hs = Hss
         else:
-            if codim == 2:
-                vertices = np.zeros((len(coordinates), 3))
-                vertices[:, :-1] = coordinates
-                indices = np.vstack((subentities[:, 0:3], subentities[:, [0, 2, 3]]))
+            Hs = Hs
+            assert Hs.shape[0] == len(s)
+
+        # ensure that complex sampling values appear in complex conjugate pairs
+        if conjugate:
+            # if user provides partitioning sizes, make sure they are adjusted
+            if isinstance(partitioning, tuple):
+                p0 = partitioning[0]
+                p1 = partitioning[1]
+                for i, ss in enumerate(s):
+                    if np.conj(ss) not in s:
+                        s = np.append(s, np.conj(ss))
+                        Hs = np.append(Hs, np.conj(Hs[i])[np.newaxis, ...], axis=0)
+                        if i in p0:
+                            p0 = np.append(p0, len(s)-1)
+                        else:
+                            p1 = np.append(p1, len(s)-1)
+                if len(p0) != len(partitioning[0]) or len(p1) != len(partitioning[1]):
+                    self.logger.info('Added complex conjugates to parititionings. '
+                                     f'New partitioning sizes are ({len(p0)}, {len(p1)}).')
+                partitioning = (p0, p1)
             else:
-                num_entities = len(subentities)
-                vertices = np.zeros((num_entities * 6, 3))
-                VERTEX_POS = coordinates[subentities]
-                vertices[0:num_entities * 3, 0:2] = VERTEX_POS[:, 0:3, :].reshape((-1, 2))
-                vertices[num_entities * 3:, 0:2] = VERTEX_POS[:, [0, 2, 3], :].reshape((-1, 2))
-                indices = np.arange(len(subentities) * 6, dtype=np.uint32)
-
-        max_tex_size = 512
-        cm = color_map(np.linspace(0, 1, max_tex_size)).astype(np.float32)
-        cm.resize((max_tex_size, 1, 4))
-        color_map = p3js.DataTexture(cm, format='RGBAFormat',  width=max_tex_size, height=1, type='FloatType')
-        uniforms = dict(
-            colormap={'value': color_map, 'type': 'sampler2D'},
-        )
-        self.material = p3js.ShaderMaterial(vertexShader=RENDER_VERTEX_SHADER, fragmentShader=RENDER_FRAGMENT_SHADER,
-                                            uniforms=uniforms)
-
-        self.buffer_vertices = p3js.BufferAttribute(vertices.astype(np.float32), normalized=False)
-        self.buffer_faces    = p3js.BufferAttribute(indices.astype(np.uint32).ravel(), normalized=False)
-        self.meshes = []
-        self._setup_scene(bounding_box, render_size)
-        if config.is_nbconvert():
-            # need to ensure all data is loaded before cell execution is over
-            class LoadDummy:
-                def done(self):
-                    return True
-            self._load_data(U)
-            self.load = LoadDummy()
+                s_new = s
+                for i, ss in enumerate(s):
+                    if np.conj(ss) not in s:
+                        s_new = np.append(s_new, np.conj(ss))
+                        Hs = np.append(Hs, np.conj(Hs[i])[np.newaxis, ...], axis=0)
+                if len(s) != len(s_new):
+                    self.logger.info(f'Added {len(s_new) - len(s)} complex conjugates to the data.')
+                s = s_new
+
+        if len(Hs.shape) > 1:
+            self.dim_output = Hs.shape[1]
+            self.dim_input = Hs.shape[2]
+            if self.dim_output == self.dim_output == 1:
+                Hs = np.squeeze(Hs)
         else:
-            self.load = asyncio.ensure_future(self._async_load_data(U))
+            self.dim_output = 1
+            self.dim_input = 1
 
-        self._last_idx = None
-        super().__init__(children=[self.renderer, ])
+        self.__auto_init(locals())
 
-    def _get_mesh(self, i, u):
-        if self.codim == 2:
-            u = u[self.entity_map]
-        elif self.grid.reference_element == triangle:
-            u = np.repeat(u, 3)
-        else:
-            u = np.tile(np.repeat(u, 3), 2)
-        data = p3js.BufferAttribute(_normalize(u, self.vmin[i], self.vmax[i]), normalized=True)
-        geo = p3js.BufferGeometry(
-            index=self.buffer_faces,
-            attributes=dict(
-                position=self.buffer_vertices,
-                data=data
-            )
-        )
-        mesh = p3js.Mesh(geometry=geo, material=self.material)
-        mesh.visible = False
-        # translate to origin where the camera is looking by default,
-        # avoids camera not updating in nbconvert run
-        mesh.position = tuple(p-i for p, i in zip(mesh.position, self.mesh_center))
-        return mesh
-
-    async def _async_load_data(self, data):
-        self._load_data(data)
-
-    def _load_data(self, data):
-        for i, u in enumerate(data):
-            m = self._get_mesh(i, u)
-            self.scene.add(m)
-            if len(self.meshes) == 0:
-                m.visible = True
-            self.meshes.append(m)
-
-    def goto(self, idx):
-        if idx != self._last_idx:
-            self.meshes[idx].visible = True
-            if self._last_idx:
-                self.meshes[self._last_idx].visible = False
-            self.renderer.render(self.scene, self.cam)
-            self._last_idx = idx
-
-    def freeze_camera(self, freeze=True):
-        self.controller.enablePan = not freeze
-        self.controller.enableZoom = not freeze
-        self.controller.enableRotate = not freeze
-
-    def _setup_scene(self, bounding_box, render_size):
-        self.min_width = render_size[0]
-        self.min_height = render_size[1]
-        fov_angle = 60
-        if len(bounding_box[0]) == 2:
-            lower = np.array([bounding_box[0][0], bounding_box[0][1], 0])
-            upper = np.array([bounding_box[1][0], bounding_box[1][1], 0])
-            bounding_box = (lower, upper)
-        combined_bounds = np.hstack(bounding_box)
-
-        absx = np.abs(combined_bounds[0] - combined_bounds[3])
-        not_mathematical_distance_scaling = 1.2
-        self.camera_distance = (np.sin((90 - fov_angle / 2) * np.pi / 180) * 0.5
-                                * absx / np.sin(fov_angle / 2 * np.pi / 180))
-        self.camera_distance *= not_mathematical_distance_scaling
-        xhalf = (combined_bounds[0] + combined_bounds[3]) / 2
-        yhalf = (combined_bounds[1] + combined_bounds[4]) / 2
-        zhalf = (combined_bounds[2] + combined_bounds[5]) / 2
-        self.mesh_center = (xhalf, yhalf, zhalf)
-        self.cam = p3js.PerspectiveCamera(aspect=render_size[0] / render_size[1],
-                                          position=[0, 0, 0 + self.camera_distance])
-        self.light = p3js.AmbientLight(color='white', intensity=1.0)
-        self.scene = p3js.Scene(children=[self.cam, self.light], background='white')
-        self.controller = p3js.OrbitControls(controlling=self.cam, position=[0, 0, 0 + self.camera_distance],
-                                             target=[0, 0, 0])
-        self.freeze_camera(True)
-        self.renderer = p3js.Renderer(camera=self.cam, scene=self.scene,
-                                      controls=[self.controller], webgl_version=1,
-                                      width=render_size[0], height=render_size[1])
-        self.renderer.layout.max_height = f'{render_size[1]}px'
-
-
-class ColorBarRenderer(widgets.HBox):
-    def __init__(self, render_size, color_map, vmin=None, vmax=None):
-        self.render_size = render_size
-        self.layout = Layout(min_width=str(render_size[0]), min_height=str(render_size[1]), margin='10px ')
-        self.color_map = color_map
-        self.vmin, self.vmax = vmin, vmax
-        self.image, labels = self._gen_sprite()
-        super().__init__(children=[self.image, labels])
-
-    def freeze_camera(self, freeze=True):
-        pass
-
-    def goto(self, idx):
-        labels = self.labels.children
-        text_fmt = '{:+1.3e}'
-        labels[0].value = text_fmt.format(self.vmax[idx])
-        labels[1].value = text_fmt.format((self.vmax[idx]+self.vmin[idx])/2)
-        labels[2].value = text_fmt.format(self.vmin[idx])
-
-    def _gen_sprite(self):
-        from PIL import Image, ImageDraw
-        # upsacle to pow2
-        bar_width = 25
-        sprite_size = (bar_width, self.render_size[1])
-        image = Image.new('RGBA', sprite_size, color=(255, 255, 255, 255))
-        draw = ImageDraw.Draw(image)
-        bar_height = sprite_size[1]
-        # we have to flip the Y coord cause PIL's coordinate system is different from OGL
-        for i in range(bar_height):
-            cl = tuple((np.array(self.color_map(bar_height-i))*255).astype(np.int_))
-            draw.line([(0, i), (bar_width, i)], cl, width=1)
-
-        label_layout = Layout(margin='0px 2px')
-        self.labels = widgets.VBox([Label('', layout=label_layout),
-                                    Label('', layout=label_layout),
-                                    Label('', layout=label_layout)],
-                                   layout=Layout(justify_content='space-between'))
-        self.goto(0)
-
-        of = BytesIO()
-        image.save(of, format='png')
-        of.seek(0)
-        return [widgets.Image(
-            value=of.read(),
-            format='png',
-            width=bar_width,
-            height=self.render_size[1],
-            layout=Layout(margin='0px'),
-        ), self.labels]
-
-
-class ThreeJSPlot(widgets.VBox):
-    def __init__(self, grid, color_map, title, bounding_box, codim, U, vmins, vmaxs, separate_colorbars, size):
-        render_size = (300, 300)
-        self.renderer = [Renderer(u, grid, render_size, color_map, title, bounding_box=bounding_box, codim=codim,
-                                  vmin=vmin, vmax=vmax)
-                         for u, vmin, vmax in zip(U, vmins, vmaxs)]
-        bar_size = (100, render_size[1])
-        if not separate_colorbars:
-            self.colorbars = [ColorBarRenderer(render_size=bar_size, vmin=vmins[0], vmax=vmaxs[0], color_map=color_map)]
-            # prevent line break between last plot and colorbar
-            self.r_hbox_items = self.renderer[:-1]
-            self.r_hbox_items.append(widgets.HBox([self.renderer[-1], self.colorbars[0]]))
-        else:
-            self.r_hbox_items = []
-            self.colorbars = []
-            for vmin, vmax, renderer in zip(vmins, vmaxs, self.renderer):
-                cr = ColorBarRenderer(render_size=bar_size, vmin=vmin, vmax=vmax, color_map=color_map)
-                self.r_hbox_items.append(widgets.HBox([renderer, cr]))
-                self.colorbars.append(cr)
-        layout = Layout(display='flex', flex_flow='row wrap', align_items='stretch', justify_content='flex-start',)
-        children = [widgets.Box(self.r_hbox_items, layout=layout)]
-        if size > 1:
-            def _goto_idx(idx):
-                for c in self.renderer:
-                    c.goto(idx)
-                for c in self.colorbars:
-                    c.goto(idx)
-            play = Play(min=0, max=size - 1, step=1, value=0, description='Timestep:', layout=Layout(margin='0px'))
-            interact(idx=play).widget(_goto_idx)
-            slider = IntSlider(min=0, max=size - 1, step=1, value=0, description='Timestep:')
-            widgets.jslink((play, 'value'), (slider, 'value'))
-            controls = widgets.HBox([play, slider], layout=Layout(margin='0px 10px'))
-            children.append(controls)
-
-        super().__init__(children=children)
-
-    async def finish_loading(self):
-        while not all(r.load.done() for r in self.renderer):
-            await asyncio.sleep(1)
-
-
-def visualize_py3js(grid, U, bounding_box=([0, 0], [1, 1]), codim=2, title=None, legend=None,
-                    separate_colorbars=False, rescale_colorbars=False, columns=2, color_map=colormaps['viridis']):
-    """Generate a pythreejs plot and associated controls for scalar data associated to a 2D |Grid|.
+    def reduce(self, r=None, tol=1e-12):
+        """Reduce using Loewner framework.
 
-    The grid's |ReferenceElement| must be the triangle or square. The data can either
-    be attached to the faces or vertices of the grid.
+        Parameters
+        ----------
+        r
+            Integer for target order of reduced model. If an interpolant with order less than r
+            exists then the output will have the minimal order of an interpolant. Otherwise, the
+            output will be an |LTIModel| with order r. If `None` the order of the reduced model will
+            be the minimal order of an interpolant.
+        tol
+            Truncation tolerance for rank of Loewner matrices.
+
+        Returns
+        -------
+        rom
+            Reduced |LTIModel|.
+        """
+        L, Ls, V, W = self.loewner_quadruple()
+        Y, S1, S2, Xh = self._loewner_svds(L, Ls)
+
+        r1 = len(S1[S1/S1[0] > tol])
+        r2 = len(S2[S2/S2[0] > tol])
+        if r is None or r > r1 or r > r2:
+            if r1 != r2:
+                self.logger.warning(f'Mismatch in numerical rank of stacked Loewner matrices ({r1} and {r2}).'
+                                    ' Consider increasing tol, specifying r or changing the partitioning.')
+                r = min(r1, r2)
+            else:
+                r = r1
 
-    Parameters
-    ----------
-    grid
-        The underlying |Grid|.
-    U
-        |VectorArray| of the data to visualize. If `len(U) 1`, the data is visualized
-        as a time series of plots. Alternatively, a tuple of |VectorArrays| can be
-        provided, in which case a subplot is created for each entry of the tuple. The
-        lengths of all arrays have to agree.
-    bounding_box
-        A bounding box in which the grid is contained.
-    codim
-        The codimension of the entities the data in `U` is attached to (either 0 or 2).
-    title
-        Title of the plot.
-    legend
-        Description of the data that is plotted. Most useful if `U` is a tuple in which
-        case `legend` has to be a tuple of strings of the same length.
-    separate_colorbars
-        If `True`, use separate colorbars for each subplot.
-    rescale_colorbars
-        If `True`, rescale colorbars to data in each frame.
-    columns
-        The number of columns in the visualizer GUI in case multiple plots are displayed
-        at the same time.
-    color_map
-        a Matplotlib Colormap object
-    """
-    assert isinstance(U, VectorArray) \
-           or (isinstance(U, tuple) and all(isinstance(u, VectorArray) for u in U)
-               and all(len(u) == len(U[0]) for u in U))
-    if isinstance(U, VectorArray):
-        size = len(U)
-        U = (U.to_numpy().astype(np.float32, copy=False),)
-    else:
-        size = len(U[0])
-        U = tuple(u.to_numpy().astype(np.float32, copy=False) for u in U)
-
-    if rescale_colorbars:
-        vmins = tuple(np.min(u, axis=1) for u in U)
-        vmaxs = tuple(np.max(u, axis=1) for u in U)
-    else:
-        vmins = tuple(np.repeat(np.min(u), len(u)) for u in U)
-        vmaxs = tuple(np.repeat(np.max(u), len(u)) for u in U)
-    if not separate_colorbars:
-        vmins = (np.min(np.vstack(vmins), axis=0),) * len(U)
-        vmaxs = (np.max(np.vstack(vmaxs), axis=0),) * len(U)
+        Yhr = Y[:, :r].conj().T
+        Xr = Xh[:r, :].conj().T
+
+        B = Yhr @ V
+        C = W @ Xr
+        E = -Yhr @ L @ Xr
+        A = -Yhr @ Ls @ Xr
+
+        if self.conjugate:
+            A, B, C, E = A.real, B.real, C.real, E.real
+
+        return LTIModel.from_matrices(A, B, C, D=None, E=E)
+
+
+    def _partition_frequencies(self):
+        """Create a frequency partitioning."""
+        # must keep complex conjugate frequencies in the same partioning
+        if self.conjugate:
+            # partition frequencies corresponding to positive imaginary part
+            pimidx = np.where(self.s.imag > 0)[0]
+
+            # treat real-valued samples separately in order to ensure balanced partitioning
+            ridx = np.where(self.s.imag == 0)[0]
+
+            if self.ordering == 'magnitude':
+                pimidx_sort = np.argsort([np.linalg.norm(self.Hs[i]) for i in pimidx])
+                pimidx_ordered = pimidx[pimidx_sort]
+                ridx_sort = np.argsort([np.linalg.norm(self.Hs[i]) for i in ridx])
+                ridx_ordered = ridx[ridx_sort]
+            elif self.ordering == 'random':
+                rng = new_rng(0)
+                rng.shuffle(pimidx)
+                pimidx_ordered = pimidx
+                rng.shuffle(ridx)
+                ridx_ordered = ridx
+            elif self.ordering == 'regular':
+                pimidx_ordered = pimidx
+                ridx_ordered = ridx
+
+            if self.partitioning == 'even-odd':
+                left = np.concatenate((ridx_ordered[::2], pimidx_ordered[::2]))
+                right = np.concatenate((ridx_ordered[1::2], pimidx_ordered[1::2]))
+            elif self.partitioning == 'half-half':
+                pim_split = np.array_split(pimidx_ordered, 2)
+                r_split = np.array_split(ridx_ordered, 2)
+                left = np.concatenate((r_split[0], pim_split[0]))
+                right = np.concatenate((r_split[1], pim_split[1]))
+
+            l_cc = np.array([], dtype=int)
+            for le in left:
+                if self.s[le].imag != 0:
+                    l_cc = np.concatenate((l_cc, np.where(self.s == self.s[le].conj())[0]))
+            left = np.concatenate((left, l_cc))
+
+            r_cc = np.array([], dtype=int)
+            for ri in right:
+                if self.s[ri].imag != 0:
+                    r_cc = np.concatenate((r_cc, np.where(self.s == self.s[ri].conj())[0]))
+            right = np.concatenate((right, r_cc))
+
+            return (left, right)
+        else:
+            if self.ordering == 'magnitude':
+                idx = np.argsort([np.linalg.norm(self.Hs[i]) for i in len(self.Hs[0])])
+            elif self.ordering == 'random':
+                rng = new_rng(0)
+                idx = rng.permutation(self.s.shape[0])
+            elif self.ordering == 'regular':
+                idx = np.arange(self.s.shape[0])
+
+            if self.partitioning == 'even-odd':
+                return (idx[::2], idx[1::2])
+            elif self.partitioning == 'half-half':
+                idx_split = np.array_split(idx, 2)
+                return (idx_split[0], idx_split[1])
+
+    @cached
+    def loewner_quadruple(self):
+        r"""Constructs a Loewner quadruple as |NumPy arrays|.
+
+        The Loewner quadruple :cite:`ALI17`
+
+        .. math::
+            (\mathbb{L},\mathbb{L}_s,V,W)
+
+        consists of the Loewner matrix :math:`\mathbb{L}`, the shifted Loewner matrix
+        :math:`\mathbb{L}_s`, left interpolation data :math:`V` and right interpolation
+        data :math:`W`.
+
+        Returns
+        -------
+        L
+            Loewner matrix as a |NumPy array|.
+        Ls
+            Shifted Loewner matrix as a |NumPy array|.
+        V
+            Left interpolation data as a |NumPy array|.
+        W
+            Right interpolation data as a |NumPy array|.
+        """
+        ip, jp = self._partition_frequencies() if isinstance(self.partitioning, str) else self.partitioning
+
+        if self.dim_input == self.dim_output == 1:
+            L = self.Hs[ip][:, np.newaxis] - self.Hs[jp]
+            L /= self.s[ip][:, np.newaxis] - self.s[jp]
+            Ls = (self.s[ip] * self.Hs[ip])[:, np.newaxis] - self.s[jp] * self.Hs[jp]
+            Ls /= self.s[ip][:, np.newaxis] - self.s[jp]
+            V = self.Hs[ip][:, np.newaxis]
+            W = self.Hs[jp][np.newaxis]
+        else:
+            if self.mimo_handling == 'full':
+                L = self.Hs[ip][:, np.newaxis] - self.Hs[jp][np.newaxis]
+                L /= (self.s[ip][:, np.newaxis] - self.s[jp][np.newaxis])[:, :, np.newaxis, np.newaxis]
+                Ls = (self.s[ip, np.newaxis, np.newaxis] * self.Hs[ip])[:, np.newaxis] \
+                    - (self.s[jp, np.newaxis, np.newaxis] * self.Hs[jp])[np.newaxis]
+                Ls /= (self.s[ip][:, np.newaxis] - self.s[jp][np.newaxis])[:, :, np.newaxis, np.newaxis]
+                V = self.Hs[ip][:, np.newaxis]
+                W = self.Hs[jp][np.newaxis]
+            else:
+                if self.mimo_handling == 'random':
+                    rng = new_rng(0)
+                    ltd = rng.normal(size=(len(ip), self.dim_output))
+                    rtd = rng.normal(size=(self.dim_input, len(jp)))
+                elif len(self.mimo_handling) == 2:
+                    ltd = self.mimo_handling[0]
+                    rtd = self.mimo_handling[1]
+                    assert ltd.shape == (len(ip), self.dim_output)
+                    assert rtd.shape == (self.dim_input, len(jp))
+                L = np.empty((len(ip), len(jp)), dtype=np.complex_)
+                Ls = np.empty((len(ip), len(jp)), dtype=np.complex_)
+                V = np.empty((len(ip), self.dim_input), dtype=np.complex_)
+                W = np.empty((self.dim_output, len(jp)), dtype=np.complex_)
+                for i, si in enumerate(ip):
+                    for j, sj in enumerate(jp):
+                        L[i, j] = ltd[i] @ (self.Hs[si] - self.Hs[sj]) @ rtd[:, j] / (self.s[si] - self.s[sj])
+                        Ls[i, j] = ltd[i] @ (self.s[si] * self.Hs[si] - self.s[sj] * self.Hs[sj]) @ rtd[:, j] \
+                            / (self.s[si] - self.s[sj])
+                    V[i, :] = self.Hs[si].T @ ltd[i]
+                for j, sj in enumerate(jp):
+                    W[:, j] = self.Hs[sj] @ rtd[:, j]
+
+        # transform the system to have real matrices
+        if self.conjugate:
+            TL = np.zeros((len(ip), len(ip)), dtype=np.complex_)
+            for i, si in enumerate(ip):
+                if self.s[si].imag == 0:
+                    TL[i, i] = 1
+                else:
+                    j = np.argmin(np.abs(self.s[ip] - self.s[si].conjugate()))
+                    if i < j:
+                        TL[i, i] = 1
+                        TL[i, j] = 1
+                        TL[j, i] = -1j
+                        TL[j, j] = 1j
+
+            TR = np.zeros((len(jp), len(jp)), dtype=np.complex_)
+            for i, si in enumerate(jp):
+                if self.s[si].imag == 0:
+                    TR[i, i] = 1
+                else:
+                    j = np.argmin(np.abs(self.s[jp] - self.s[si].conjugate()))
+                    if i < j:
+                        TR[i, i] = 1
+                        TR[i, j] = 1
+                        TR[j, i] = -1j
+                        TR[j, j] = 1j
+            TR = TR / np.sqrt(2)
+            TL = TL / np.sqrt(2)
+
+            if self.mimo_handling == 'full' and not self.dim_input == self.dim_output == 1:
+                L = np.tensordot(TL, L, axes=(1, 0))
+                L = np.tensordot(L, TR.conj().T, axes=(1, 0))
+                L = L.real
+                L = np.transpose(L, (0, 3, 1, 2))
+
+                Ls = np.tensordot(TL, Ls, axes=(1, 0))
+                Ls = np.tensordot(Ls, TR.conj().T, axes=(1, 0))
+                Ls = Ls.real
+                Ls = np.transpose(Ls, (0, 3, 1, 2))
+
+                V = np.tensordot(TL, V, axes=(1, 0)).real
+                W = np.tensordot(W, TR.conj().T, axes=(1, 0)).real
+                W = np.transpose(W, (0, 3, 1, 2))
+            else:
+                L = (TL @ L @ TR.conj().T).real
+                Ls = (TL @ Ls @ TR.conj().T).real
+                V = (TL @ V).real
+                W = (W @ TR.conj().T).real
+
+        if self.mimo_handling == 'full' and not self.dim_input == self.dim_output == 1:
+            L = np.concatenate(np.concatenate(L, axis=1), axis=1)
+            Ls = np.concatenate(np.concatenate(Ls, axis=1), axis=1)
+            V = np.concatenate(np.concatenate(V, axis=1), axis=1)
+            W = np.concatenate(np.concatenate(W, axis=0), axis=1)
+
+        return L, Ls, V, W
+
+    @cached
+    def _loewner_svds(self, L, Ls):
+        """Compute SVDs of stacked Loewner matrices."""
+        LhLs = np.hstack([L, Ls])
+        Y, S1, _ = spla.svd(LhLs, full_matrices=False)
+        LvLs = np.vstack([L, Ls])
+        _, S2, Xh = spla.svd(LvLs, full_matrices=False)
 
-    return ThreeJSPlot(grid, color_map, title, bounding_box, codim, U, vmins, vmaxs, separate_colorbars, size)
+        return Y, S1, S2, Xh
```

### Comparing `pymor-2022.2.1/src/pymor/discretizers/builtin/gui/matplotlib_base.py` & `pymor-2023.1.0/src/pymor/discretizers/builtin/gui/matplotlib_base.py`

 * *Files 5% similar despite different names*

```diff
@@ -5,14 +5,15 @@
 """Visualization of grid data using matplotlib.
 
 This module provides widgets for displaying plots of
 scalar data assigned to one- and two-dimensional grids using
 :mod:`matplotlib`. These widgets are not intended to be used directly.
 """
 from pymor.core.config import config
+
 config.require('MATPLOTLIB')
 
 import numpy as np
 
 from pymor.discretizers.builtin.grids.constructions import flatten_grid
 from pymor.discretizers.builtin.grids.referenceelements import square, triangle
 
@@ -45,24 +46,25 @@
                                   triangles=subentities, shading='flat')
 
         # thin plots look ugly with a huge colorbar on the right
         if aspect_ratio < 0.75:
             orientation = 'horizontal'
         else:
             orientation = 'vertical'
-        ax.figure.colorbar(self.p, ax=ax, orientation=orientation)
+        self.cbar = ax.figure.colorbar(self.p, ax=ax, orientation=orientation)
 
     def set(self, U, vmin, vmax):
         if self.codim == 2:
             self.p.set_array(U)
         elif self.reference_element is triangle:
             self.p.set_array(U)
         else:
             self.p.set_array(np.tile(U, 2))
         self.p.set_clim(vmin, vmax)
+        self.cbar.mappable.set_clim(vmin, vmax)
         return (self.p,)
 
 
 class Matplotlib1DAxes:
 
     def __init__(self, figure, grid, count, legend=None, codim=1, separate_plots=False,
                  columns=2):
```

### Comparing `pymor-2022.2.1/src/pymor/discretizers/builtin/gui/qt/__init__.py` & `pymor-2023.1.0/src/pymor/discretizers/builtin/gui/qt/__init__.py`

 * *Files 2% similar despite different names*

```diff
@@ -10,22 +10,34 @@
 """
 from pymor.core.config import config
 from pymor.discretizers.builtin.grids.oned import OnedGrid
 
 config.require('QT')
 
 import math as m
-from tempfile import NamedTemporaryFile
 import subprocess
 import sys
+from tempfile import NamedTemporaryFile
 
 import numpy as np
-from qtpy.QtWidgets import (QWidget, QVBoxLayout, QHBoxLayout, QGridLayout, QSlider, QLCDNumber,
-                            QAction, QStyle, QToolBar, QLabel, QFileDialog, QMessageBox)
 from qtpy.QtCore import Qt, QTimer
+from qtpy.QtWidgets import (
+    QAction,
+    QFileDialog,
+    QGridLayout,
+    QHBoxLayout,
+    QLabel,
+    QLCDNumber,
+    QMessageBox,
+    QSlider,
+    QStyle,
+    QToolBar,
+    QVBoxLayout,
+    QWidget,
+)
 
 from pymor.core.defaults import defaults
 from pymor.core.logger import getLogger
 from pymor.core.pickle import dump
 from pymor.vectorarrays.interface import VectorArray
 from pymor.vectorarrays.numpy import NumpyVectorSpace
 
@@ -229,15 +241,15 @@
         ind = self.slider.value() - 1
         if ind == -1 and self.a_loop.isChecked():
             ind = self.length - 1
         if ind >= 0:
             self.slider.setValue(ind)
 
     def closeEvent(self, event=None):
-        """This is directly called from CI
+        """This is directly called from CI.
 
         Xvfb (sometimes) raises errors on interpreter shutdown
         when there are still 'live' MPL plot objects. This
         happens even if the referencing MainWindow was already destroyed
         """
         try:
             self.plot.p.close()
@@ -311,15 +323,15 @@
             data = dict(dim=2,
                         grid=grid, U=U, bounding_box=bounding_box, codim=codim, title=title, legend=legend,
                         separate_colorbars=separate_colorbars, rescale_colorbars=rescale_colorbars,
                         backend=backend, columns=columns)
             with NamedTemporaryFile(mode='wb', delete=False) as f:
                 dump(data, f)
                 filename = f.name
-            subprocess.Popen(['python', '-m', 'pymor.scripts.pymor_vis', '--delete', filename])
+            subprocess.Popen(['python3', '-m', 'pymor.scripts.pymor_vis', '--delete', filename])
             return
 
     U = (U.to_numpy().astype(np.float64, copy=False),) if isinstance(U, VectorArray) else \
         tuple(u.to_numpy().astype(np.float64, copy=False) for u in U)
 
     if backend == 'gl':
         if not config.HAVE_GL:
```

### Comparing `pymor-2022.2.1/src/pymor/discretizers/builtin/gui/qt/gl.py` & `pymor-2023.1.0/src/pymor/discretizers/builtin/gui/qt/gl.py`

 * *Files 1% similar despite different names*

```diff
@@ -4,33 +4,34 @@
 
 """Visualization of grid data using OpenGL.
 
 This module provides a widget for displaying patch plots of
 scalar data assigned to 2D-grids using OpenGL. This widget is not
 intended to be used directly. Instead, use
 :meth:`~pymor.discretizers.builtin.gui.qt.visualize_patch` or
-:class:`~pymor.discretizers.builtin.gui.qt.PatchVisualizer`.
+:class:`~pymor.discretizers.builtin.gui.visualizers.PatchVisualizer`.
 """
 
 from pymor.core.config import config
+
 config.require('QT')
 config.require('QTOPENGL')
 config.require('GL')
 
 import math as m
+from ctypes import c_void_p
 
 import numpy as np
-import OpenGL.GL as gl
-from qtpy.QtWidgets import QSizePolicy, QOpenGLWidget
-from qtpy.QtGui import QPainter, QFontMetrics
-from ctypes import c_void_p
+import OpenGL.GL as gl  # noqa: N811
+from qtpy.QtGui import QFontMetrics, QPainter
+from qtpy.QtWidgets import QOpenGLWidget, QSizePolicy
 
 from pymor.core.defaults import defaults
 from pymor.discretizers.builtin.grids.constructions import flatten_grid
-from pymor.discretizers.builtin.grids.referenceelements import triangle, square
+from pymor.discretizers.builtin.grids.referenceelements import square, triangle
 
 
 def compile_shader(source, vertex=True):
     """Compile a vertex shader from source."""
     shader_type = gl.GL_VERTEX_SHADER if vertex else gl.GL_FRAGMENT_SHADER
     shader = gl.glCreateShader(shader_type)
     gl.glShaderSource(shader, source)
@@ -94,14 +95,15 @@
     gl.glTexParameteri(gl.GL_TEXTURE_1D, gl.GL_TEXTURE_WRAP_S, gl.GL_CLAMP_TO_EDGE)
     colormap = np.empty((resolution, 4), dtype='f4')
     from matplotlib.pyplot import get_cmap
     try:
         cmap = get_cmap(name)
     except ValueError:
         from pymor.core.logger import getLogger
+
         # this is our default which might not exist for older matplotlib
         # so a warning would be annoying
         if name != 'viridis':
             msg = f'Unknown colormap {name}, using default colormap'
             getLogger('pymor.discretizers.builtin.gui.gl.colormap_texture').warning(msg)
         cmap = get_cmap()
     colormap[:] = cmap(np.linspace(0., 1., resolution))
@@ -300,11 +302,11 @@
         for i in range(steps + 1):
             y = i * (1 / steps)
             # gl.glColor(y, 0, 0)
             gl.glVertex(-0.5, (bar_height*y + bar_start), y)
             gl.glVertex(0.5, (bar_height*y + bar_start), y)
         gl.glEnd()
         p.endNativePainting()
-        p.drawText(int(round((self.width() - self.vmax_width)/2)), int(round(self.text_ascent)), self.vmax_str)
+        p.drawText(int(round((self.width() - self.vmax_width)/2)), int(round(self.text_ascent)), self.vmin_str)
         p.drawText(int(round((self.width() - self.vmin_width)/2)),
-                   int(round(self.height() - self.text_height + self.text_ascent)), self.vmin_str)
+                   int(round(self.height() - self.text_height + self.text_ascent)), self.vmax_str)
         p.end()
```

### Comparing `pymor-2022.2.1/src/pymor/discretizers/builtin/gui/qt/matplotlib.py` & `pymor-2023.1.0/src/pymor/discretizers/builtin/gui/qt/matplotlib.py`

 * *Files identical despite different names*

### Comparing `pymor-2022.2.1/src/pymor/discretizers/builtin/gui/visualizers.py` & `pymor-2023.1.0/src/pymor/discretizers/builtin/gui/visualizers.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,18 +1,18 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 import numpy as np
 
 from pymor.core.base import ImmutableObject
-from pymor.core.defaults import defaults
 from pymor.core.config import is_jupyter
+from pymor.core.defaults import defaults
 from pymor.discretizers.builtin.grids.oned import OnedGrid
-from pymor.discretizers.builtin.grids.referenceelements import triangle, square
+from pymor.discretizers.builtin.grids.referenceelements import square, triangle
 from pymor.vectorarrays.interface import VectorArray
 
 
 class PatchVisualizer(ImmutableObject):
     """Visualize scalar data associated to a two-dimensional |Grid| as a patch plot.
 
     The grid's |ReferenceElement| must be the triangle or square. The data can either
@@ -41,15 +41,16 @@
         if backend == 'jupyter_or_gl':
             backend = 'jupyter' if is_jupyter() else 'gl'
         if bounding_box is None:
             bounding_box = grid.bounding_box()
         self.__auto_init(locals())
 
     def visualize(self, U, title=None, legend=None, separate_colorbars=False,
-                  rescale_colorbars=False, block=None, filename=None, columns=2):
+                  rescale_colorbars=False, block=None, filename=None, columns=2,
+                  return_widget=False, **kwargs):
         """Visualize the provided data.
 
         Parameters
         ----------
         U
             |VectorArray| of the data to visualize. If `len(U) > 1`, the data is visualized
             as a time series of plots. Alternatively, a tuple of |VectorArrays| can be
@@ -63,20 +64,24 @@
         separate_colorbars
             If `True`, use separate colorbars for each subplot.
         rescale_colorbars
             If `True`, rescale colorbars to data in each frame.
         block
             If `True`, block execution until the plot window is closed. If `None`, use the
             default provided during instantiation.
-        filename
-            If specified, write the data to a VTK-file using
-            :func:`~pymor.discretizers.builtin.grids.vtkio.write_vtk` instead of displaying it.
         columns
             The number of columns in the visualizer GUI in case multiple plots are displayed
             at the same time.
+        filename
+            If specified, write the data to a VTK-file using
+            :func:`~pymor.discretizers.builtin.grids.vtkio.write_vtk` instead of displaying it.
+        return_widget
+            If `True`, create an interactive visualization that can be used as a jupyter widget.
+        kwargs
+            Additional backend-specific arguments.
         """
         assert isinstance(U, VectorArray) \
             or (isinstance(U, tuple)
                 and all(isinstance(u, VectorArray) for u in U)
                 and all(len(u) == len(U[0]) for u in U))
         if filename:
             from pymor.discretizers.builtin.grids.vtkio import write_vtk
@@ -86,22 +91,25 @@
                 for i, u in enumerate(U):
                     write_vtk(self.grid, u, f'{filename}-{i}', codim=self.codim)
         else:
             if self.backend == 'jupyter':
                 from pymor.discretizers.builtin.gui.jupyter import get_visualizer
                 return get_visualizer()(self.grid, U, bounding_box=self.bounding_box, codim=self.codim, title=title,
                                         legend=legend, separate_colorbars=separate_colorbars,
-                                        rescale_colorbars=rescale_colorbars, columns=columns)
+                                        rescale_colorbars=rescale_colorbars, columns=columns,
+                                        return_widget=return_widget, **kwargs)
             else:
+                if return_widget:
+                    raise NotImplementedError
                 block = self.block if block is None else block
                 from pymor.discretizers.builtin.gui.qt import visualize_patch
                 return visualize_patch(self.grid, U, bounding_box=self.bounding_box, codim=self.codim, title=title,
                                        legend=legend, separate_colorbars=separate_colorbars,
                                        rescale_colorbars=rescale_colorbars, backend=self.backend, block=block,
-                                       columns=columns)
+                                       columns=columns, **kwargs)
 
 
 class OnedVisualizer(ImmutableObject):
     """Visualize scalar data associated to a one-dimensional |Grid| as a plot.
 
     The grid's |ReferenceElement| must be the line. The data can either
     be attached to the subintervals or vertices of the grid.
@@ -124,15 +132,15 @@
         assert codim in (0, 1)
         assert backend in {'jupyter_or_matplotlib', 'jupyter', 'matplotlib'}
         if backend == 'jupyter_or_matplotlib':
             backend = 'jupyter' if is_jupyter() else 'matplotlib'
         self.__auto_init(locals())
 
     def visualize(self, U, title=None, legend=None, separate_plots=False,
-                  rescale_axes=False, block=None, columns=2):
+                  rescale_axes=False, block=None, columns=2, return_widget=False):
         """Visualize the provided data.
 
         Parameters
         ----------
         U
             |VectorArray| of the data to visualize. If `len(U) > 1`, the data is visualized
             as a time series of plots. Alternatively, a tuple of |VectorArrays| can be
@@ -148,21 +156,25 @@
         rescale_axes
             If `True`, rescale axes to data in each frame.
         block
             If `True`, block execution until the plot window is closed. If `None`, use the
             default provided during instantiation.
         columns
             Number of columns the subplots are organized in.
+        return_widget
+            If `True`, create an interactive visualization that can be used as a jupyter widget.
         """
         if self.backend == 'jupyter':
             from pymor.discretizers.builtin.gui.jupyter.matplotlib import visualize_matplotlib_1d
             return visualize_matplotlib_1d(self.grid, U, codim=self.codim, title=title, legend=legend,
                                            separate_plots=separate_plots, rescale_axes=rescale_axes,
-                                           columns=columns)
+                                           columns=columns, return_widget=return_widget)
         else:
+            if return_widget:
+                raise NotImplementedError
             block = self.block if block is None else block
             from pymor.discretizers.builtin.gui.qt import visualize_matplotlib_1d
             return visualize_matplotlib_1d(self.grid, U, codim=self.codim, title=title, legend=legend,
                                            separate_plots=separate_plots, rescale_axes=rescale_axes,
                                            block=block)
```

### Comparing `pymor-2022.2.1/src/pymor/discretizers/builtin/inverse.py` & `pymor-2023.1.0/src/pymor/discretizers/builtin/inverse.py`

 * *Files 1% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 import numpy as np
 
 
 def inv_two_by_two(A):
-    """Efficiently compute the inverses of a |NumPy array| of 2x2-matrices
+    """Efficiently compute the inverses of a |NumPy array| of 2x2-matrices.
 
     This implements ::
 
     |  retval[i1,...,ik,m,n] = numpy.linalg.inv(A[i1,...,ik,:,:]).
 
     """
     assert A.shape[-1] == A.shape[-2] == 2, 'Wrong shape of argument.'
@@ -25,15 +25,15 @@
     INV[..., 0, 1] = - A[..., 0, 1]
     INV *= D[..., np.newaxis, np.newaxis]
 
     return INV
 
 
 def inv_transposed_two_by_two(A):
-    """Efficiently compute the tranposed inverses of a |Numpy array| of 2x2-matrices
+    """Efficiently compute the tranposed inverses of a |Numpy array| of 2x2-matrices.
 
     This implements ::
 
     |  retval[i1,...,ik,m,n] = numpy.linalg.inv(A[i1,...,ik,:,:]).
 
     """
     assert A.shape[-1] == A.shape[-2] == 2, 'Wrong shape of argument.'
```

### Comparing `pymor-2022.2.1/src/pymor/discretizers/builtin/list.py` & `pymor-2023.1.0/src/pymor/discretizers/builtin/list.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,17 +1,23 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 from pymor.algorithms.preassemble import preassemble
-from pymor.algorithms.rules import RuleTable, RuleNotMatchingError, match_class, match_always
+from pymor.algorithms.rules import RuleNotMatchingError, RuleTable, match_always, match_class
 from pymor.models.interface import Model
-from pymor.operators.constructions import (AdjointOperator, AffineOperator, ConcatenationOperator,
-                                           FixedParameterOperator, LincombOperator,
-                                           SelectionOperator, VectorArrayOperator)
+from pymor.operators.constructions import (
+    AdjointOperator,
+    AffineOperator,
+    ConcatenationOperator,
+    FixedParameterOperator,
+    LincombOperator,
+    SelectionOperator,
+    VectorArrayOperator,
+)
 from pymor.operators.list import NumpyListVectorArrayMatrixOperator
 from pymor.operators.numpy import NumpyMatrixOperator
 from pymor.vectorarrays.list import NumpyListVectorSpace
 
 
 def convert_to_numpy_list_vector_array(obj, space=None):
     """Use NumpyListVectorArrayMatrixOperator instead of NumpyMatrixOperator.
@@ -36,14 +42,15 @@
         space = obj.solution_space
     assert space is not None
     obj = preassemble(obj)
     return ConvertToNumpyListVectorArrayRules(space).apply(obj)
 
 
 class ConvertToNumpyListVectorArrayRules(RuleTable):
+    """|RuleTable| for the :func:`convert_to_numpy_list_vector_array` algorithm."""
 
     def __init__(self, space):
         super().__init__(use_caching=True)
         self.space = space
 
     @match_class(AdjointOperator, AffineOperator, ConcatenationOperator,
                  FixedParameterOperator, LincombOperator, SelectionOperator,
```

### Comparing `pymor-2022.2.1/src/pymor/discretizers/builtin/quadratures.py` & `pymor-2023.1.0/src/pymor/discretizers/builtin/quadratures.py`

 * *Files 0% similar despite different names*

```diff
@@ -4,15 +4,15 @@
 
 from itertools import chain
 
 import numpy as np
 
 
 class GaussQuadratures:
-    """Gauss quadrature on the interval [0, 1]"""
+    """Gauss quadrature on the interval [0, 1]."""
 
     @classmethod
     def maxpoints(cls):
         return len(cls.points)
 
     @classmethod
     def _determine_order(cls, order=None, npoints=None):
```

### Comparing `pymor-2022.2.1/src/pymor/discretizers/builtin/relations.py` & `pymor-2023.1.0/src/pymor/discretizers/builtin/relations.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,14 +1,13 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 import numpy as np
 
-
 DTYPE = np.int32
 
 
 def inverse_relation(SE, size_rhs=None, with_indices=False):
     S, I = np.unravel_index(np.arange(SE.size), SE.shape)
     SE = SE.ravel()
     if size_rhs is None:
```

### Comparing `pymor-2022.2.1/src/pymor/discretizers/fenics/cg.py` & `pymor-2023.1.0/src/pymor/discretizers/fenics/cg.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,25 +1,26 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 from pymor.core.config import config
+
 config.require('FENICS')
 
 
 import dolfin as df
 
 from pymor.algorithms.preassemble import preassemble as preassemble_
 from pymor.analyticalproblems.elliptic import StationaryProblem
 from pymor.analyticalproblems.functions import LincombFunction
-from pymor.bindings.fenics import FenicsVectorSpace, FenicsMatrixBasedOperator, FenicsVisualizer
+from pymor.bindings.fenics import FenicsMatrixBasedOperator, FenicsVectorSpace, FenicsVisualizer
 from pymor.discretizers.fenics.domaindiscretizer import discretize_domain
 from pymor.models.basic import StationaryModel
-from pymor.operators.constructions import LincombOperator, NumpyConversionOperator
 from pymor.operators.block import BlockColumnOperator
+from pymor.operators.constructions import LincombOperator, NumpyConversionOperator
 
 
 def discretize_stationary_cg(analytical_problem, diameter=None, degree=1, preassemble=True):
     """Discretizes a |StationaryProblem| with finite elements using FEniCS.
 
     Parameters
     ----------
@@ -61,15 +62,18 @@
     if p.nonlinear_reaction_derivative is not None:
         raise NotImplementedError
     if not p.domain.boundary_types <= {'dirichlet', 'neumann'}:
         raise NotImplementedError
     if p.dirichlet_data is not None and p.dirichlet_data.parametric:
         raise NotImplementedError
 
-    mesh, (boundary_mask, boundary_ids) = discretize_domain(p.domain, diameter=diameter)
+    if diameter is None:
+        mesh, (boundary_mask, boundary_ids) = discretize_domain(p.domain)
+    else:
+        mesh, (boundary_mask, boundary_ids) = discretize_domain(p.domain, diameter=diameter)
 
     V = df.FunctionSpace(mesh, 'Lagrange', degree)
     bc = df.DirichletBC(V, 0. if p.dirichlet_data is None else p.dirichlet_data.to_fenics(mesh)[0].item(),
                         boundary_mask, boundary_ids['dirichlet'])
     u = df.TrialFunction(V)
     v = df.TestFunction(V)
     dx, ds = df.dx, df.ds
```

### Comparing `pymor-2022.2.1/src/pymor/discretizers/fenics/domaindiscretizer.py` & `pymor-2023.1.0/src/pymor/discretizers/fenics/domaindiscretizer.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,19 +1,26 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 from pymor.core.config import config
+
 config.require('FENICS')
 
-from dolfin import RectangleMesh, Point, SubDomain, MeshFunction, DOLFIN_EPS
 import numpy as np
+from dolfin import DOLFIN_EPS, MeshFunction, Point, RectangleMesh, SubDomain
 
-from pymor.analyticalproblems.domaindescriptions import (RectDomain, CylindricalDomain, TorusDomain, LineDomain,
-                                                         CircleDomain, PolygonalDomain)
+from pymor.analyticalproblems.domaindescriptions import (
+    CircleDomain,
+    CylindricalDomain,
+    LineDomain,
+    PolygonalDomain,
+    RectDomain,
+    TorusDomain,
+)
 
 
 def discretize_domain(domain_description, diameter=1 / 100):
 
     def discretize_RectDomain():
         x0i = int(np.ceil(domain_description.width * np.sqrt(2) / diameter))
         x1i = int(np.ceil(domain_description.height * np.sqrt(2) / diameter))
```

### Comparing `pymor-2022.2.1/src/pymor/discretizers/skfem/cg.py` & `pymor-2023.1.0/src/pymor/discretizers/skfem/cg.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,19 +1,20 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 from pymor.core.config import config
+
 config.require('SCIKIT_FEM')
 
 import warnings
 
 import numpy as np
-from skfem import Basis, BoundaryFacetBasis, BilinearForm, LinearForm, asm, enforce, projection
-from skfem.helpers import grad, dot
+from skfem import Basis, BilinearForm, BoundaryFacetBasis, LinearForm, asm, enforce, projection
+from skfem.helpers import dot, grad
 from skfem.visuals.matplotlib import plot, show
 
 from pymor.algorithms.preassemble import preassemble as preassemble_
 from pymor.analyticalproblems.elliptic import StationaryProblem
 from pymor.analyticalproblems.functions import ConstantFunction, LincombFunction
 from pymor.core.base import ImmutableObject
 from pymor.discretizers.skfem.domaindiscretizer import discretize_domain
@@ -28,15 +29,15 @@
 
     sparse = True
 
     def __init__(self, basis, dirichlet_dofs=None, dirichlet_clear_diag=False, name=None):
         self.source = self.range = NumpyVectorSpace(basis.N)
         self.__auto_init(locals())
 
-    def build_form(mu):
+    def build_form(self, mu):
         pass
 
     def _assemble(self, mu):
         form = BilinearForm(self.build_form(mu))
         A = asm(form, self.basis)
         if self.dirichlet_dofs is not None:
             with warnings.catch_warnings():
```

### Comparing `pymor-2022.2.1/src/pymor/discretizers/skfem/domaindiscretizer.py` & `pymor-2023.1.0/src/pymor/discretizers/skfem/domaindiscretizer.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,20 +1,27 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 from pymor.core.config import config
+
 config.require('SCIKIT_FEM')
 
 
 import numpy as np
 import skfem
 
-from pymor.analyticalproblems.domaindescriptions import (RectDomain, CylindricalDomain, TorusDomain, LineDomain,
-                                                         CircleDomain, PolygonalDomain)
+from pymor.analyticalproblems.domaindescriptions import (
+    CircleDomain,
+    CylindricalDomain,
+    LineDomain,
+    PolygonalDomain,
+    RectDomain,
+    TorusDomain,
+)
 
 
 def discretize_domain(domain_description, diameter=1 / 100, mesh_type=None):
 
     def discretize_RectDomain():
         mt = mesh_type or skfem.MeshQuad
         x0i = int(np.ceil(domain_description.width * np.sqrt(2) / diameter))
```

### Comparing `pymor-2022.2.1/src/pymor/models/basic.py` & `pymor-2023.1.0/src/pymor/models/basic.py`

 * *Files 1% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 import numpy as np
 
 from pymor.algorithms.timestepping import TimeStepper
 from pymor.models.interface import Model
-from pymor.operators.constructions import IdentityOperator, VectorOperator, ZeroOperator, ConstantOperator
+from pymor.operators.constructions import ConstantOperator, IdentityOperator, VectorOperator, ZeroOperator
 from pymor.vectorarrays.interface import VectorArray
 from pymor.vectorarrays.numpy import NumpyVectorSpace
 
 
 class StationaryModel(Model):
     """Generic class for models of stationary problems.
 
@@ -118,18 +118,20 @@
         """
         if use_adjoint is None:
             use_adjoint = True if (self.output_functional.linear and self.operator.linear) else False
         if not use_adjoint:
             return super()._compute_output_d_mu(solution, mu, return_array)
         else:
             assert self.operator.linear
-            assert self.output_functional.linear
+            jacobian = self.output_functional.jacobian(solution, mu)
+            assert jacobian.linear
             dual_solutions = self.operator.range.empty()
             for d in range(self.output_functional.range.dim):
-                dual_problem = self.with_(operator=self.operator.H, rhs=self.output_functional.H.as_range_array(mu)[d])
+                dual_problem = self.with_(operator=self.operator.H,
+                                          rhs=jacobian.H.as_range_array(mu)[d])
                 dual_solutions.append(dual_problem.solve(mu))
             gradients = [] if return_array else {}
             for (parameter, size) in self.parameters.items():
                 result = []
                 for index in range(size):
                     output_partial_dmu = self.output_functional.d_mu(parameter, index).apply(solution,
                                                                                              mu=mu).to_numpy()[0]
@@ -161,23 +163,23 @@
         solution space. This method can be used to obtain such a |Model|.
 
         Given a vector `u_0` from the affine solution space, the returned
         :class:`StationaryModel` is equivalent to solving::
 
             L(u() + u_0, ) = F()
 
-        When :attr:`~StationaryModel.operator` is linear, the affine shift is
+        When :attr:`!operator` is linear, the affine shift is
         moved to the right-hand side to obtain::
 
             L(u(), ) = F() - L(u_0, )
 
         Solutions of the original |Model| can be obtained by adding `u_0` to the
         solutions of the deaffinized |Model|.
 
-        The :attr:`~StationaryModel.output_functional` is adapted accordingly to
+        The :attr:`!output_functional` is adapted accordingly to
         yield the same output for given |parameter values|.
 
         Parameters
         ----------
         arg
             Either a |VectorArray| of length 1 containing the vector `u_0`.
             Alternatively, |parameter values| can be provided, for which the
```

### Comparing `pymor-2022.2.1/src/pymor/models/interface.py` & `pymor-2023.1.0/src/pymor/models/interface.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 import numpy as np
 
 from pymor.core.cache import CacheableObject
 from pymor.operators.constructions import induced_norm
-from pymor.parameters.base import Parameters, ParametricObject, Mu
+from pymor.parameters.base import Mu, Parameters, ParametricObject
 from pymor.tools.frozendict import FrozenDict
 
 
 class Model(CacheableObject, ParametricObject):
     """Interface for model objects.
 
     A model object defines a discrete problem
@@ -84,21 +84,21 @@
 
     def _compute_output(self, solution, mu=None, **kwargs):
         """Compute the model's output for |parameter values| `mu`.
 
         This method is called by the default implementation of :meth:`compute`
         in :class:`pymor.models.interface.Model`. The assumption is made
         that the output is a derived quantity from the model's internal state
-        as returned my :meth:`_compute_solution`. When this is not the case,
-        the computation of the output should be implemented in :meth:`_compute`.
+        as returned by :meth:`!_compute_solution`. When this is not the case,
+        the computation of the output should be implemented in :meth:`!_compute`.
 
         .. note::
 
             The default implementation applies the |Operator| given by the
-            :attr:`output_functional` attribute to the given `solution`
+            :attr:`!output_functional` attribute to the given `solution`
             |VectorArray|.
 
         Parameters
         ----------
         solution
             Internal model state for the given |parameter values|.
         mu
@@ -111,15 +111,15 @@
         -------
         |NumPy array| with the computed output or a dict which at least
         must contain the key `'output'`.
         """
         return self.output_functional.apply(solution, mu=mu).to_numpy()
 
     def _compute_solution_d_mu_single_direction(self, parameter, index, solution, mu=None, **kwargs):
-        """Compute the partial derivative of the solution w.r.t. a parameter index
+        """Compute the partial derivative of the solution w.r.t. a parameter index.
 
         Parameters
         ----------
         parameter
             parameter for which to compute the sensitivity
         index
             parameter index for which to compute the sensitivity
@@ -131,15 +131,15 @@
         Returns
         -------
         The sensitivity of the solution as a |VectorArray|.
         """
         raise NotImplementedError
 
     def _compute_solution_d_mu(self, solution, mu=None, **kwargs):
-        """Compute all partial derivative of the solution w.r.t. a parameter index
+        """Compute all partial derivative of the solution w.r.t. a parameter index.
 
         Parameters
         ----------
         solution
             Internal model state for the given |Parameter value|.
         mu
             |Parameter value| for which to solve
@@ -154,15 +154,15 @@
             for l in range(size):
                 sens_for_param.append(self._compute_solution_d_mu_single_direction(
                     parameter, l, solution, mu))
             sensitivities[parameter] = sens_for_param
         return sensitivities
 
     def _compute_output_d_mu(self, solution, mu=None, return_array=False, **kwargs):
-        """Compute the gradient w.r.t. the parameter of the output functional
+        """Compute the gradient w.r.t. the parameter of the output functional.
 
         Parameters
         ----------
         solution
             Internal model state for the given |Parameter value|.
         mu
             |Parameter value| for which to compute the gradient
@@ -197,16 +197,16 @@
 
     def _compute_solution_error_estimate(self, solution, mu=None, **kwargs):
         """Compute an error estimate for the computed internal state.
 
         This method is called by the default implementation of :meth:`compute`
         in :class:`pymor.models.interface.Model`. The assumption is made
         that the error estimate is a derived quantity from the model's internal state
-        as returned my :meth:`_compute_solution`. When this is not the case,
-        the computation of the error estimate should be implemented in :meth:`_compute`.
+        as returned by :meth:`!_compute_solution`. When this is not the case,
+        the computation of the error estimate should be implemented in :meth:`!_compute`.
 
         .. note::
 
             The default implementation calls the `estimate_error` method of the object
             given by the :attr:`error_estimator` attribute, passing `solution`,
             `mu`, `self` and `**kwargs`.
 
@@ -231,16 +231,16 @@
 
     def _compute_output_error_estimate(self, solution, mu=None, return_vector=False, **kwargs):
         """Compute an error estimate for the computed model output.
 
         This method is called by the default implementation of :meth:`compute`
         in :class:`pymor.models.interface.Model`. The assumption is made
         that the error estimate is a derived quantity from the model's internal state
-        as returned my :meth:`_compute_solution`. When this is not the case,
-        the computation of the error estimate should be implemented in :meth:`_compute`.
+        as returned by :meth:`!_compute_solution`. When this is not the case,
+        the computation of the error estimate should be implemented in :meth:`!_compute`.
 
         .. note::
 
             The default implementation calls the `estimate_output_error` method of the object
             given by the :attr:`error_estimator` attribute, passing `solution`,
             `mu`, `self` and `**kwargs`.
 
@@ -249,15 +249,15 @@
         solution
             Internal model state for the given |parameter values|.
         mu
             |Parameter values| for which to compute the error estimate.
         return_vector
             If `True`, return the output estimate as a |NumPy array|,
             where each component corresponds to the respective component
-            of the :attr:`output_functional`.
+            of the :attr:`!output_functional`.
             Otherwise, return the Euclidean norm of all components.
         kwargs
             Additional keyword arguments to customize how the error estimate is
             computed or to select additional data to be returned.
 
         Returns
         -------
@@ -280,21 +280,21 @@
 
         This method computes the output of the model, its internal state,
         and various associated quantities for given |parameter values| `mu`.
 
         .. note::
 
             The default implementation defers the actual computations to
-            the methods :meth:`_compute_solution`, :meth:`_compute_output`,
-            :meth:`_compute_solution_error_estimate` and :meth:`_compute_output_error_estimate`.
-            The call to :meth:`_compute_solution` is :mod:`cached <pymor.core.cache>`.
-            In addition, |Model| implementors may implement :meth:`_compute` to
+            the methods :meth:`!_compute_solution`, :meth:`!_compute_output`,
+            :meth:`!_compute_solution_error_estimate` and :meth:`!_compute_output_error_estimate`.
+            The call to :meth:`!_compute_solution` is :mod:`cached <pymor.core.cache>`.
+            In addition, |Model| implementors may implement :meth:`!_compute` to
             simultaneously compute multiple values in an optimized way. The corresponding
             `_compute_XXX` methods will not be called for values already returned by
-            :meth:`_compute`.
+            :meth:`!_compute`.
 
         Parameters
         ----------
         solution
             If `True`, return the model's internal state.
         output
             If `True`, return the model output.
@@ -310,15 +310,15 @@
             If `True`, return an error estimate for the computed output.
         output_d_mu_return_array
             If `True`, return the output gradient as a |NumPy array|.
             Otherwise, return a dict of gradients for each |Parameter|.
         output_error_estimate_return_vector
             If `True`, return the output estimate as a |NumPy array|,
             where each component corresponds to the respective component
-            of the :attr:`output_functional`.
+            of the :attr:`!output_functional`.
             Otherwise, return the Euclidean norm of all components.
         mu
             |Parameter values| for which to compute the values.
         input
             The model input. Either a |NumPy array| of shape `(self.dim_input,)`,
             a |Function| with `dim_domain == 1` and `shape_range == (self.dim_input,)`
             mapping time to input, or a `str` expression with `t` as variable that
@@ -483,15 +483,15 @@
             can be used to instantiate an |ExpressionFunction| of this type.
             Can be `None` if `self.dim_input == 0`.
         return_error_estimate
             If `True`, also return an error estimate for the computed output.
         return_error_estimate_vector
             If `True`, return the output estimate as a |NumPy array|,
             where each component corresponds to the respective component
-            of the :attr:`output_functional`.
+            of the :attr:`!output_functional`.
             Otherwise, return the Euclidean norm of all components.
         kwargs
             Additional keyword arguments passed to :meth:`compute` that
             might affect how the solution is computed.
 
         Returns
         -------
@@ -512,15 +512,15 @@
         )
         if return_error_estimate:
             return data['output'], data['output_error_estimate']
         else:
             return data['output']
 
     def solve_d_mu(self, parameter, index, mu=None, input=None, **kwargs):
-        """Solve for the partial derivative of the solution w.r.t. a parameter index
+        """Solve for the partial derivative of the solution w.r.t. a parameter index.
 
         Parameters
         ----------
         parameter
             parameter for which to compute the sensitivity
         index
             parameter index for which to compute the sensitivity
@@ -633,15 +633,15 @@
             a |Function| with `dim_domain == 1` and `shape_range == (self.dim_input,)`
             mapping time to input, or a `str` expression with `t` as variable that
             can be used to instantiate an |ExpressionFunction| of this type.
             Can be `None` if `self.dim_input == 0`.
         return_vector
             If `True`, return the output estimate as a |NumPy array|,
             where each component corresponds to the respective component
-            of the :attr:`output_functional`.
+            of the :attr:`!output_functional`.
             Otherwise, return the Euclidean norm of all components.
         kwargs
             Additional keyword arguments passed to :meth:`compute` that
             might affect how the error estimate (or the output) is computed.
 
         Returns
         -------
```

### Comparing `pymor-2022.2.1/src/pymor/models/iosys.py` & `pymor-2023.1.0/src/pymor/models/iosys.py`

 * *Files 8% similar despite different names*

```diff
@@ -5,32 +5,51 @@
 
 import numpy as np
 import scipy.linalg as spla
 import scipy.sparse as sps
 
 from pymor.algorithms.bernoulli import bernoulli_stabilize
 from pymor.algorithms.eigs import eigs
-from pymor.algorithms.lyapunov import (_chol, solve_cont_lyap_lrcf, solve_disc_lyap_lrcf, solve_cont_lyap_dense,
-                                       solve_disc_lyap_dense)
-from pymor.algorithms.riccati import solve_ricc_lrcf, solve_pos_ricc_lrcf
-from pymor.algorithms.timestepping import TimeStepper, DiscreteTimeStepper
+from pymor.algorithms.lyapunov import (
+    _chol,
+    solve_cont_lyap_dense,
+    solve_cont_lyap_lrcf,
+    solve_disc_lyap_dense,
+    solve_disc_lyap_lrcf,
+)
+from pymor.algorithms.riccati import solve_pos_ricc_lrcf, solve_ricc_lrcf
+from pymor.algorithms.simplify import contract, expand
+from pymor.algorithms.timestepping import DiscreteTimeStepper, TimeStepper
 from pymor.algorithms.to_matrix import to_matrix
 from pymor.analyticalproblems.functions import GenericFunction
 from pymor.core.cache import cached
 from pymor.core.config import config
 from pymor.core.defaults import defaults
 from pymor.models.interface import Model
 from pymor.models.transfer_function import FactorizedTransferFunction
 from pymor.models.transforms import BilinearTransformation, MoebiusTransformation
-from pymor.operators.block import (BlockOperator, BlockRowOperator, BlockColumnOperator, BlockDiagonalOperator,
-                                   SecondOrderModelOperator)
-from pymor.operators.constructions import (IdentityOperator, InverseOperator, LincombOperator, LinearInputOperator,
-                                           LowRankOperator, VectorOperator, ZeroOperator)
+from pymor.operators.block import (
+    BlockColumnOperator,
+    BlockDiagonalOperator,
+    BlockOperator,
+    BlockRowOperator,
+    SecondOrderModelOperator,
+)
+from pymor.operators.constructions import (
+    IdentityOperator,
+    InverseOperator,
+    LincombOperator,
+    LinearInputOperator,
+    LowRankOperator,
+    VectorArrayOperator,
+    VectorOperator,
+    ZeroOperator,
+)
 from pymor.operators.numpy import NumpyMatrixOperator
-from pymor.parameters.base import Parameters, Mu
+from pymor.parameters.base import Mu, Parameters
 from pymor.vectorarrays.block import BlockVectorSpace
 from pymor.vectorarrays.interface import VectorArray
 
 
 @defaults('value')
 def sparse_min_size(value=1000):
     """Return minimal sparse problem size for which to warn about converting to dense."""
@@ -194,15 +213,16 @@
         assert presets is None or presets.keys() <= {'poles', 'c_lrcf', 'o_lrcf', 'c_dense', 'o_dense', 'hsv',
                                                      'h2_norm', 'hinf_norm', 'l2_norm', 'linf_norm', 'fpeak'}
         if presets:
             assert all(not obj.parametric for obj in [A, B, C, D, E])
         else:
             presets = {}
 
-        assert solver_options is None or solver_options.keys() <= {'lyap_lrcf', 'lyap_dense'}
+        assert solver_options is None or solver_options.keys() <= {'lyap_lrcf', 'lyap_dense',
+                                                                   'ricc_lrcf', 'ricc_dense', 'ricc_pos_lrcf'}
 
         super().__init__(dim_input=B.source.dim, error_estimator=error_estimator, visualizer=visualizer, name=name)
         self.__auto_init(locals())
         self.solution_space = A.source
         self.dim_output = C.range.dim
 
         K = lambda s: s * self.E - self.A
@@ -269,15 +289,15 @@
             The :class:`time-stepper <pymor.algorithms.timestepping.TimeStepper>`
             to be used by :meth:`~pymor.models.interface.Model.solve`.
         num_values
             The number of returned vectors of the solution trajectory. If `None`, each
             intermediate vector that is calculated is returned.
         presets
             A `dict` of preset attributes or `None`.
-            See :meth:`~pymor.models.iosys.LTIModel.__init__`.
+            See |LTIModel|.
         state_id
             Id of the state space.
         solver_options
             The solver options to use to solve the Lyapunov equations.
         error_estimator
             An error estimator for the problem. This can be any object with an
             `estimate_error(U, mu, model)` method. If `error_estimator` is not `None`, an
@@ -369,15 +389,15 @@
             The :class:`time-stepper <pymor.algorithms.timestepping.TimeStepper>`
             to be used by :meth:`~pymor.models.interface.Model.solve`.
         num_values
             The number of returned vectors of the solution trajectory. If `None`, each
             intermediate vector that is calculated is returned.
         presets
             A `dict` of preset attributes or `None`.
-            See :meth:`~pymor.models.iosys.LTIModel.__init__`.
+            See |LTIModel|.
         state_id
             Id of the state space.
         solver_options
             The solver options to use to solve the Lyapunov equations.
         error_estimator
             An error estimator for the problem. This can be any object with an
             `estimate_error(U, mu, model)` method. If `error_estimator` is not `None`, an
@@ -461,15 +481,15 @@
             The :class:`time-stepper <pymor.algorithms.timestepping.TimeStepper>`
             to be used by :meth:`~pymor.models.interface.Model.solve`.
         num_values
             The number of returned vectors of the solution trajectory. If `None`, each
             intermediate vector that is calculated is returned.
         presets
             A `dict` of preset attributes or `None`.
-            See :meth:`~pymor.models.iosys.LTIModel.__init__`.
+            See |LTIModel|.
         state_id
             Id of the state space.
         solver_options
             The solver options to use to solve the Lyapunov equations.
         error_estimator
             An error estimator for the problem. This can be any object with an
             `estimate_error(U, mu, model)` method. If `error_estimator` is not `None`, an
@@ -546,15 +566,15 @@
             The :class:`time-stepper <pymor.algorithms.timestepping.TimeStepper>`
             to be used by :meth:`~pymor.models.interface.Model.solve`.
         num_values
             The number of returned vectors of the solution trajectory. If `None`, each
             intermediate vector that is calculated is returned.
         presets
             A `dict` of preset attributes or `None`.
-            See :meth:`~pymor.models.iosys.LTIModel.__init__`.
+            See |LTIModel|.
         state_id
             Id of the state space.
         solver_options
             The solver options to use to solve the Lyapunov equations.
         error_estimator
             An error estimator for the problem. This can be any object with an
             `estimate_error(U, mu, model)` method. If `error_estimator` is not `None`, an
@@ -568,17 +588,18 @@
             Name of the system.
 
         Returns
         -------
         lti
             The |LTIModel| with operators A, B, C, D, and E.
         """
-        from pymor.tools.io import load_matrix
         import os.path
 
+        from pymor.tools.io import load_matrix
+
         A = load_matrix(files_basename + '.A')
         B = load_matrix(files_basename + '.B')
         C = load_matrix(files_basename + '.C')
         D = load_matrix(files_basename + '.D') if os.path.isfile(files_basename + '.D') else None
         E = load_matrix(files_basename + '.E') if os.path.isfile(files_basename + '.E') else None
 
         return cls.from_matrices(A, B, C, D, E, sampling_time=sampling_time, T=T, time_stepper=time_stepper,
@@ -591,14 +612,15 @@
 
         Parameters
         ----------
         files_basename
             The basename of files containing the operators.
         """
         from pathlib import Path
+
         from pymor.tools.io.matrices import _mmwrite
         A, B, C, D, E = self.to_matrices()
         _mmwrite(Path(files_basename + '.A'), A)
         _mmwrite(Path(files_basename + '.B'), B)
         _mmwrite(Path(files_basename + '.C'), C)
         if D is not None:
             _mmwrite(Path(files_basename + '.D'), D)
@@ -653,32 +675,37 @@
         C = BlockRowOperator([self.C, other.C])
         D = self.D + other.D
         if isinstance(self.E, IdentityOperator) and isinstance(other.E, IdentityOperator):
             E = IdentityOperator(BlockVectorSpace([self.solution_space, other.solution_space]))
         else:
             E = BlockDiagonalOperator([self.E, other.E])
         if self.T is not None and other.T is not None:
-            T = self.T
+            if type(self.time_stepper) != type(other.time_stepper):  # noqa
+                raise TypeError('The time-steppers are not of the same type.')
+            T = min(self.T, other.T)
             initial_data = BlockColumnOperator([self.initial_data, other.initial_data])
             time_stepper = self.time_stepper
+            if (hasattr(self.time_stepper, 'nt') and hasattr(other.time_stepper, 'nt')
+                    and self.T / self.time_stepper.nt > other.T / other.time_stepper.nt):
+                time_stepper = other.time_stepper
         else:
             T = None
             initial_data = None
             time_stepper = None
         return LTIModel(A, B, C, D, E, sampling_time=self.sampling_time,
                         T=T, initial_data=initial_data, time_stepper=time_stepper, num_values=self.num_values,
                         solver_options=self.solver_options)
 
     def __sub__(self, other):
         """Subtract an |LTIModel|."""
         return self + (-other)
 
     def __neg__(self):
         """Negate the |LTIModel|."""
-        return self.with_(C=-self.C, D=-self.D)
+        return self.with_(C=-self.C, D=-self.D, new_type=LTIModel)  # ensure that __neg__ works in subclasses
 
     def __mul__(self, other):
         """Postmultiply by an |LTIModel|."""
         if not isinstance(other, LTIModel):
             return NotImplemented
 
         assert self.sampling_time == other.sampling_time
@@ -690,17 +717,22 @@
         C = BlockRowOperator([self.C, self.D @ other.C])
         D = self.D @ other.D
         if isinstance(self.E, IdentityOperator) and isinstance(other.E, IdentityOperator):
             E = IdentityOperator(BlockVectorSpace([self.solution_space, other.solution_space]))
         else:
             E = BlockDiagonalOperator([self.E, other.E])
         if self.T is not None and other.T is not None:
-            T = self.T
+            if type(self.time_stepper) != type(other.time_stepper):  # noqa
+                raise TypeError('The time-steppers are not of the same type.')
+            T = min(self.T, other.T)
             initial_data = BlockColumnOperator([self.initial_data, other.initial_data])
             time_stepper = self.time_stepper
+            if (hasattr(self.time_stepper, 'nt') and hasattr(other.time_stepper, 'nt')
+                    and self.T / self.time_stepper.nt > other.T / other.time_stepper.nt):
+                time_stepper = other.time_stepper
         else:
             T = None
             initial_data = None
             time_stepper = None
         return LTIModel(A, B, C, D, E, sampling_time=self.sampling_time,
                         T=T, initial_data=initial_data, time_stepper=time_stepper, num_values=self.num_values,
                         solver_options=self.solver_options)
@@ -884,14 +916,15 @@
             return self.presets['c_lrcf'].to_numpy().T @ self.presets['c_lrcf'].to_numpy()
         elif typ == 'o_dense' and 'o_lrcf' in self.presets:
             return self.presets['o_lrcf'].to_numpy().T @ self.presets['o_lrcf'].to_numpy()
 
         A = self.A.assemble(mu)
         B = self.B
         C = self.C
+        D = self.D
         E = self.E.assemble(mu) if not isinstance(self.E, IdentityOperator) else None
         options_lrcf = self.solver_options.get('lyap_lrcf') if self.solver_options else None
         options_dense = self.solver_options.get('lyap_dense') if self.solver_options else None
         options_ricc_lrcf = self.solver_options.get('ricc_lrcf') if self.solver_options else None
         options_ricc_pos_lrcf = self.solver_options.get('ricc_pos_lrcf') if self.solver_options else None
         solve_lyap_lrcf = solve_cont_lyap_lrcf if self.sampling_time == 0 else solve_disc_lyap_lrcf
         solve_lyap_dense = solve_cont_lyap_dense if self.sampling_time == 0 else solve_disc_lyap_dense
@@ -920,23 +953,31 @@
                                         trans=True, options=options_lrcf)
         elif typ == 'lqg_c_lrcf':
             return solve_ricc_lrcf(A, E, B.as_range_array(mu=mu), C.as_source_array(mu=mu),
                                    trans=False, options=options_ricc_lrcf)
         elif typ == 'lqg_o_lrcf':
             return solve_ricc_lrcf(A, E, B.as_range_array(mu=mu), C.as_source_array(mu=mu),
                                    trans=True, options=options_ricc_lrcf)
+        elif typ == 'pr_c_lrcf':
+            return solve_pos_ricc_lrcf(A, E, A.source.zeros(), -C.as_source_array(mu=mu),
+                                       R=to_matrix(D + D.H, 'dense'), S=B.as_range_array(mu=mu),
+                                       trans=False, options=options_ricc_pos_lrcf)
+        elif typ == 'pr_o_lrcf':
+            return solve_pos_ricc_lrcf(A, E, -B.as_range_array(mu=mu), A.source.zeros(),
+                                       R=to_matrix(D + D.H, 'dense'), S=C.as_source_array(mu=mu),
+                                       trans=True, options=options_ricc_pos_lrcf)
         elif typ[0] == 'br_c_lrcf':
             return solve_pos_ricc_lrcf(A, E, B.as_range_array(mu=mu), C.as_source_array(mu=mu),
-                                       R=(typ[1]**2 * np.eye(self.dim_output)
+                                       R=(typ[1] ** 2 * np.eye(self.dim_output)
                                           if typ[1] != 1
                                           else None),
                                        trans=False, options=options_ricc_pos_lrcf)
         elif typ[0] == 'br_o_lrcf':
             return solve_pos_ricc_lrcf(A, E, B.as_range_array(mu=mu), C.as_source_array(mu=mu),
-                                       R=(typ[1]**2 * np.eye(self.dim_input)
+                                       R=(typ[1] ** 2 * np.eye(self.dim_input)
                                           if typ[1] != 1
                                           else None),
                                        trans=True, options=options_ricc_pos_lrcf)
 
     def gramian(self, typ, mu=None):
         """Compute a Gramian.
 
@@ -955,30 +996,37 @@
               Gramian,
             - `'lqg_c_lrcf'`: low-rank Cholesky factor of the "controllability" LQG Gramian,
             - `'lqg_o_lrcf'`: low-rank Cholesky factor of the "observability" LQG Gramian,
             - `('br_c_lrcf', gamma)`: low-rank Cholesky factor of the "controllability" bounded real
               Gramian,
             - `('br_o_lrcf', gamma)`: low-rank Cholesky factor of the "observability" bounded real
               Gramian.
+            - `'pr_c_lrcf'`: low-rank Cholesky factor of the "controllability" positive real
+              Gramian,
+            - `'pr_o_lrcf'`: low-rank Cholesky factor of the "observability" positive real
+              Gramian.
 
             .. note::
                 For `'*_lrcf'` types, the method assumes the system is asymptotically stable.
                 For `'*_dense'` types, the method assumes that the underlying Lyapunov equation
                 has a unique solution, i.e. no pair of system poles adds to zero in the
                 continuous-time case and no pair of system poles multiplies to one in the
                 discrete-time case.
+                Additionally, for `'pr_c_lrcf'` and `'pr_o_lrcf'`, it is assumed that `D + D^T` is
+                invertible.
         mu
             |Parameter values|.
 
         Returns
         -------
         If typ ends with `'_lrcf'`, then the Gramian factor as a |VectorArray| from `self.A.source`.
         If typ ends with `'_dense'`, then the Gramian as a |NumPy array|.
         """
-        assert (typ in ('c_lrcf', 'o_lrcf', 'c_dense', 'o_dense', 'bs_c_lrcf', 'bs_o_lrcf', 'lqg_c_lrcf', 'lqg_o_lrcf')
+        assert (typ in ('c_lrcf', 'o_lrcf', 'c_dense', 'o_dense', 'bs_c_lrcf', 'bs_o_lrcf', 'lqg_c_lrcf', 'lqg_o_lrcf',
+                        'pr_c_lrcf', 'pr_o_lrcf')
                 or isinstance(typ, tuple) and len(typ) == 2 and typ[0] in ('br_c_lrcf', 'br_o_lrcf'))
 
         if ((isinstance(typ, str) and (typ.startswith('bs') or typ.startswith('lqg')) or isinstance(typ, tuple))
                 and self.sampling_time > 0):
             raise NotImplementedError
 
         if not isinstance(mu, Mu):
@@ -1006,14 +1054,15 @@
         ----------
         typ
             The type of the Gramians used:
 
             - `'lyap'`: Lyapunov Gramian,
             - `'bs'`: Bernoulli stabilized Gramian,
             - `'lqg'`: LQG Gramian,
+            - `'pr'`: positive real Gramian,
             - `('br', gamma)`: bounded real Gramian,
         mu
             |Parameter values|.
 
         Returns
         -------
         sv
@@ -1031,14 +1080,17 @@
             of = self.gramian('o_lrcf', mu=mu)
         elif typ == 'bs':
             cf = self.gramian('bs_c_lrcf', mu=mu)
             of = self.gramian('bs_o_lrcf', mu=mu)
         elif typ == 'lqg':
             cf = self.gramian('lqg_c_lrcf', mu=mu)
             of = self.gramian('lqg_o_lrcf', mu=mu)
+        elif typ == 'pr':
+            cf = self.gramian('pr_c_lrcf', mu=mu)
+            of = self.gramian('pr_o_lrcf', mu=mu)
         elif isinstance(typ, tuple) and typ[0] == 'br' and typ[1] > 0:
             gamma = typ[1]
             cf = self.gramian(('br_c_lrcf', gamma), mu=mu)
             of = self.gramian(('br_o_lrcf', gamma), mu=mu)
         else:
             raise ValueError(f'Unknown typ ({typ}).')
         U, hsv, Vh = spla.svd(self.E.apply2(of, cf, mu=mu), lapack_driver='gesvd')
@@ -1099,15 +1151,16 @@
         if not isinstance(mu, Mu):
             mu = self.parameters.parse(mu)
         h2_norm = self.presets['h2_norm'] if 'h2_norm' in self.presets else self._h2_norm(mu=mu)
         assert h2_norm >= 0
 
         return h2_norm
 
-    def hinf_norm(self, mu=None, return_fpeak=False, ab13dd_equilibrate=False):
+    @defaults('tol')
+    def hinf_norm(self, mu=None, return_fpeak=False, ab13dd_equilibrate=False, tol=1e-10):
         r"""Compute the :math:`\mathcal{H}_\infty`-norm of the |LTIModel|.
 
         .. note::
             Assumes the system is asymptotically stable. Under this is assumption the
             :math:`\mathcal{H}_\infty`-norm is equal to the :math:`\mathcal{H}_\infty`-norm.
             Accordingly, this method calls :meth:`~pymor.models.iosys.LTIModel.linf_norm`.
 
@@ -1115,26 +1168,28 @@
         ----------
         mu
             |Parameter values|.
         return_fpeak
             Whether to return the frequency at which the maximum is achieved.
         ab13dd_equilibrate
             Whether `slycot.ab13dd` should use equilibration.
+        tol
+            Tolerance in norm computation.
 
         Returns
         -------
         norm
             :math:`\mathcal{H}_\infty`-norm.
         fpeak
             Frequency at which the maximum is achieved (if `return_fpeak` is `True`).
         """
         if 'hinf_norm' in self.presets:
             hinf_norm = self.presets['hinf_norm']
         else:
-            hinf_norm = self.linf_norm(mu=mu, return_fpeak=return_fpeak, ab13dd_equilibrate=ab13dd_equilibrate)
+            hinf_norm = self.linf_norm(mu=mu, return_fpeak=return_fpeak, ab13dd_equilibrate=ab13dd_equilibrate, tol=tol)
         assert hinf_norm >= 0
 
         return hinf_norm
 
     def hankel_norm(self, mu=None):
         """Compute the Hankel-norm of the |LTIModel|.
 
@@ -1212,15 +1267,15 @@
             mu = self.parameters.parse(mu)
         l2_norm = self.presets['l2_norm'] if 'l2_norm' in self.presets else self._l2_norm(mu=mu)
         assert l2_norm >= 0
 
         return l2_norm
 
     @cached
-    def _linf_norm(self, mu=None, ab13dd_equilibrate=False):
+    def _linf_norm(self, mu=None, ab13dd_equilibrate=False, tol=1e-10):
         if 'fpeak' in self.presets:
             return spla.norm(self.transfer_function.eval_tf(self.presets['fpeak']), ord=2), self.presets['fpeak']
         elif not config.HAVE_SLYCOT:
             raise NotImplementedError
 
         if not isinstance(mu, Mu):
             mu = self.parameters.parse(mu)
@@ -1236,17 +1291,18 @@
 
         from slycot import ab13dd
         dico = 'D' if self.sampling_time > 0 else 'C'
         jobe = 'I' if isinstance(self.E, IdentityOperator) else 'G'
         equil = 'S' if ab13dd_equilibrate else 'N'
         jobd = 'Z' if isinstance(self.D, ZeroOperator) else 'D'
         A, B, C, D, E = (to_matrix(op, format='dense') for op in [A, B, C, D, E])
-        return ab13dd(dico, jobe, equil, jobd, self.order, self.dim_input, self.dim_output, A, E, B, C, D)
+        return ab13dd(dico, jobe, equil, jobd, self.order, self.dim_input, self.dim_output, A, E, B, C, D, tol=tol)
 
-    def linf_norm(self, mu=None, return_fpeak=False, ab13dd_equilibrate=False):
+    @defaults('tol')
+    def linf_norm(self, mu=None, return_fpeak=False, ab13dd_equilibrate=False, tol=1e-10):
         r"""Compute the :math:`\mathcal{L}_\infty`-norm of the |LTIModel|.
 
         The :math:`\mathcal{L}_\infty`-norm of an |LTIModel| is defined via
 
         .. math::
 
             \lVert H \rVert_{\mathcal{L}_\infty}
@@ -1257,30 +1313,32 @@
         ----------
         mu
             |Parameter|.
         return_fpeak
             Whether to return the frequency at which the maximum is achieved.
         ab13dd_equilibrate
             Whether `slycot.ab13dd` should use equilibration.
+        tol
+            Tolerance in norm computation.
 
         Returns
         -------
         norm
             :math:`\mathcal{L}_\infty`-norm.
         fpeak
             Frequency at which the maximum is achieved (if `return_fpeak` is `True`).
         """
         if not return_fpeak and 'linf_norm' in self.presets:
             linf_norm = self.presets['linf_norm']
         elif not return_fpeak:
-            linf_norm = self.linf_norm(mu=mu, return_fpeak=True, ab13dd_equilibrate=ab13dd_equilibrate)[0]
+            linf_norm = self.linf_norm(mu=mu, return_fpeak=True, ab13dd_equilibrate=ab13dd_equilibrate, tol=tol)[0]
         elif {'fpeak', 'linf_norm'} <= self.presets.keys():
             linf_norm, fpeak = self.presets['linf_norm'], self.presets['fpeak']
         else:
-            linf_norm, fpeak = self._linf_norm(mu=mu, ab13dd_equilibrate=ab13dd_equilibrate)
+            linf_norm, fpeak = self._linf_norm(mu=mu, ab13dd_equilibrate=ab13dd_equilibrate, tol=tol)
 
         if return_fpeak:
             assert isinstance(fpeak, Number) and linf_norm >= 0
             return linf_norm, fpeak
         else:
             assert linf_norm >= 0
             return linf_norm
@@ -1455,32 +1513,46 @@
         assert self.sampling_time > 0
         assert isinstance(w0, Number)
         x = 2 / self.sampling_time if w0 == 0 else w0 / np.tan(w0 * self.sampling_time / 2)
         d2c = BilinearTransformation(x)
         return self.moebius_substitution(d2c, sampling_time=0)
 
 
-class PHLTIModel(Model):
+class PHLTIModel(LTIModel):
     r"""Class for (continuous) port-Hamiltonian linear time-invariant systems.
 
     This class describes input-state-output systems given by
 
     .. math::
-        E(\mu) \dot{x}(t, \mu) & = (J(\mu) - R(\mu)) x(t, \mu) + (G(\mu) - P(\mu)) u(t), \\
-                     y(t, \mu) & = (G(\mu) + P(\mu))^T x(t, \mu) + (S(\mu) - N(\mu)) u(t),
+        E(\mu) \dot{x}(t, \mu) & = (J(\mu) - R(\mu)) Q(\mu)   x(t, \mu) + (G(\mu) - P(\mu)) u(t), \\
+                     y(t, \mu) & = (G(\mu) + P(\mu))^T Q(\mu) x(t, \mu) + (S(\mu) - N(\mu)) u(t),
 
-    with :math:`E(\mu) \succeq 0`, :math:`J(\mu) = -J(\mu)^T`, :math:`N(\mu) = -N(\mu)^T` and
+    where :math:`H(\mu) = Q(\mu)^T E(\mu)`,
 
     .. math::
-        \mathcal{R}(\mu) =
+        \Gamma(\mu) =
+        \begin{bmatrix}
+            J(\mu) & G(\mu) \\
+            -G(\mu)^T & N(\mu)
+        \end{bmatrix},
+        \text{ and }
+        W(\mu) =
         \begin{bmatrix}
             R(\mu) & P(\mu) \\
             P(\mu)^T & S(\mu)
         \end{bmatrix}
-        \succeq 0.
+
+    satisfy
+    :math:`H(\mu) = H(\mu)^T \succ 0`,
+    :math:`\Gamma(\mu)^T = -\Gamma(\mu)`, and
+    :math:`W(\mu) = W(\mu)^T \succcurlyeq 0`.
+
+    A dynamical system of this form, together with a given quadratic (energy) function
+    :math:`\mathcal{H}(x, \mu) = \tfrac{1}{2} x^T H(\mu) x`, typically called Hamiltonian,
+    is called a port-Hamiltonian system.
 
     All methods related to the transfer function
     (e.g., frequency response calculation and Bode plots)
     are attached to the `transfer_function` attribute.
 
     Parameters
     ----------
@@ -1494,14 +1566,16 @@
         The |Operator| P or `None` (then P is assumed to be zero).
     S
         The |Operator| S or `None` (then S is assumed to be zero).
     N
         The |Operator| N or `None` (then N is assumed to be zero).
     E
         The |Operator| E or `None` (then E is assumed to be identity).
+    Q
+        The |Operator| Q or `None` (then Q is assumed to be identity).
     solver_options
         The solver options to use to solve the Lyapunov equations.
     name
         Name of the system.
 
     Attributes
     ----------
@@ -1521,21 +1595,23 @@
         The |Operator| P.
     S
         The |Operator| S.
     N
         The |Operator| N.
     E
         The |Operator| E.
+    Q
+        The |Operator| Q.
     transfer_function
         The transfer function.
     """
 
     cache_region = 'memory'
 
-    def __init__(self, J, R, G, P=None, S=None, N=None, E=None,
+    def __init__(self, J, R, G, P=None, S=None, N=None, E=None, Q=None,
                  solver_options=None, error_estimator=None, visualizer=None, name=None):
         assert J.linear
         assert J.source == J.range
 
         assert R.linear
         assert R.source == J.source
         assert R.source == R.range
@@ -1559,46 +1635,75 @@
         assert N.range == N.source
 
         E = E or IdentityOperator(J.source)
         assert E.linear
         assert E.source == E.range
         assert E.source == J.source
 
-        assert solver_options is None or solver_options.keys() <= {'lyap_lrcf', 'lyap_dense'}
-
-        super().__init__(dim_input=G.source.dim, error_estimator=error_estimator, visualizer=visualizer, name=name)
+        Q = Q or IdentityOperator(J.source)
+        assert Q.linear
+        assert Q.source == Q.range
+        assert Q.source == J.source
+
+        super().__init__(A=J - R if isinstance(Q, IdentityOperator) else contract((J - R) @ Q),
+                         B=G - P,
+                         C=(G + P).H if isinstance(Q, IdentityOperator) else (G + P).H @ Q,
+                         D=S - N, E=E,
+                         solver_options=solver_options, error_estimator=error_estimator, visualizer=visualizer,
+                         name=name)
         self.__auto_init(locals())
-        self.solution_space = J.source
-        self.dim_output = G.source.dim
-        self.sampling_time = 0
-
-        K = lambda s: s * self.E - (self.J - self.R)
-        B = lambda s: self.G - self.P
-        C = lambda s: (self.G + self.P).H
-        D = lambda s: self.S - self.N
-        dK = lambda s: self.E
-        dB = lambda s: ZeroOperator(self.G.range, self.G.source)
-        dC = lambda s: ZeroOperator(self.G.source, self.G.range)
-        dD = lambda s: ZeroOperator(self.S.range, self.S.source)
-        parameters = Parameters.of(self.J, self.R, self.G, self.P, self.S, self.N, self.E)
 
-        self.transfer_function = FactorizedTransferFunction(
-            self.dim_input, self.dim_output,
-            K, B, C, D, dK, dB, dC, dD,
-            parameters=parameters, name=self.name + '_transfer_function')
+    def to_berlin_form(self):
+        """Convert the |PHLTIModel| into its Berlin form.
 
-        self._lti_model = LTIModel(A=self.J - self.R,
-                                   B=self.G - self.P,
-                                   C=(self.G + self.P).H,
-                                   D=self.S - self.N,
-                                   E=self.E,
-                                   solver_options=self.solver_options,
-                                   error_estimator=self.error_estimator,
-                                   visualizer=self.visualizer,
-                                   name=self.name + '_as_lti')
+        Returns a |PHLTIModel| with :math:`Q=I`, by left multiplication with :math:`Q^T`.
+
+        Returns
+        -------
+        model
+            |PHLTIModel| with :math:`Q=I`.
+        """
+        if isinstance(self.Q, IdentityOperator):
+            return self
+
+        E = contract(expand(self.Q.H @ self.E))
+        J = contract(expand(self.Q.H @ self.J @ self.Q))
+        R = contract(expand(self.Q.H @ self.R @ self.Q))
+        G = contract(expand(self.Q.H @ self.G))
+        P = contract(expand(self.Q.H @ self.P))
+
+        return self.with_(E=E, J=J, R=R, G=G, P=P, Q=None)
+
+    @classmethod
+    def from_passive_LTIModel(cls, model):
+        """
+        Convert a passive |LTIModel| to a |PHLTIModel|.
+
+        Parameters
+        ----------
+        model
+            The passive |LTIModel| to convert.
+        generalized
+            If `True`, the resulting |PHLTIModel| will have :math:`Q=I`.
+        """
+        # Determine solution of KYP inequality
+        L = VectorArrayOperator(model.gramian('pr_o_lrcf'), adjoint=True)
+        X = L.H @ L
+
+        Q = X
+        E = model.E
+        J = 0.5 * (model.A @ InverseOperator(X) - InverseOperator(X) @ model.A.H)
+        R = -0.5 * (model.A @ InverseOperator(X) + InverseOperator(X) @ model.A.H)
+        G = 0.5 * (InverseOperator(X) @ model.C.H + model.B)
+        P = 0.5 * (InverseOperator(X) @ model.C.H - model.B)
+        S = 0.5 * (model.D + model.D.H)
+        N = 0.5 * (model.D - model.D.H)
+
+        return cls(E=E, J=J, R=R, G=G, P=P, S=S, N=N, Q=Q, solver_options=model.solver_options,
+                   error_estimator=model.error_estimator, visualizer=model.visualizer, name=model.name)
 
     def __str__(self):
         string = (
             f'{self.name}\n'
             f'    class: {self.__class__.__name__}\n'
             f'    number of equations: {self.order}\n'
             f'    number of inputs:    {self.dim_input}\n'
@@ -1609,15 +1714,15 @@
             f'    port-Hamiltonian\n'
             f'    linear time-invariant\n'
             f'    solution_space:  {self.solution_space}'
         )
         return string
 
     @classmethod
-    def from_matrices(cls, J, R, G, P=None, S=None, N=None, E=None,
+    def from_matrices(cls, J, R, G, P=None, S=None, N=None, E=None, Q=None,
                       state_id='STATE', solver_options=None, error_estimator=None,
                       visualizer=None, name=None):
         """Create |PHLTIModel| from matrices.
 
         Parameters
         ----------
         J
@@ -1630,14 +1735,16 @@
             The |NumPy array| or |SciPy spmatrix| P or `None` (then P is assumed to be zero).
         S
             The |NumPy array| or |SciPy spmatrix| S or `None` (then S is assumed to be zero).
         N
             The |NumPy array| or |SciPy spmatrix| N or `None` (then N is assumed to be zero).
         E
             The |NumPy array| or |SciPy spmatrix| E or `None` (then E is assumed to be identity).
+        Q
+            The |NumPy array| or |SciPy spmatrix| Q or `None` (then Q is assumed to be identity).
         state_id
             Id of the state space.
         solver_options
             The solver options to use to solve the Lyapunov equations.
         error_estimator
             An error estimator for the problem. This can be any object with an
             `estimate_error(U, mu, model)` method. If `error_estimator` is not `None`, an
@@ -1658,28 +1765,31 @@
         assert isinstance(J, (np.ndarray, sps.spmatrix))
         assert isinstance(R, (np.ndarray, sps.spmatrix))
         assert isinstance(G, (np.ndarray, sps.spmatrix))
         assert P is None or isinstance(P, (np.ndarray, sps.spmatrix))
         assert S is None or isinstance(S, (np.ndarray, sps.spmatrix))
         assert N is None or isinstance(N, (np.ndarray, sps.spmatrix))
         assert E is None or isinstance(E, (np.ndarray, sps.spmatrix))
+        assert Q is None or isinstance(Q, (np.ndarray, sps.spmatrix))
 
         J = NumpyMatrixOperator(J, source_id=state_id, range_id=state_id)
         R = NumpyMatrixOperator(R, source_id=state_id, range_id=state_id)
         G = NumpyMatrixOperator(G, range_id=state_id)
         if P is not None:
             P = NumpyMatrixOperator(P, range_id=state_id)
         if S is not None:
             S = NumpyMatrixOperator(S)
         if N is not None:
             N = NumpyMatrixOperator(N)
         if E is not None:
             E = NumpyMatrixOperator(E, source_id=state_id, range_id=state_id)
+        if Q is not None:
+            Q = NumpyMatrixOperator(Q, source_id=state_id, range_id=state_id)
 
-        return cls(J, R, G, P, S, N, E,
+        return cls(J=J, R=R, G=G, P=P, S=S, N=N, E=E, Q=Q,
                    solver_options=solver_options, error_estimator=error_estimator, visualizer=visualizer,
                    name=name)
 
     def to_matrices(self):
         """Return operators as matrices.
 
         Returns
@@ -1687,263 +1797,57 @@
         J
             The |NumPy array| or |SciPy spmatrix| J.
         R
             The |NumPy array| or |SciPy spmatrix| R.
         G
             The |NumPy array| or |SciPy spmatrix| G.
         P
-            The |NumPy array| or |SciPy spmatrix| P.
+            The |NumPy array| or |SciPy spmatrix| P or `None` (if P is a `ZeroOperator`).
         S
-            The |NumPy array| or |SciPy spmatrix| S or `None` (if Cv is a `ZeroOperator`).
+            The |NumPy array| or |SciPy spmatrix| S or `None` (if S is a `ZeroOperator`).
         N
-            The |NumPy array| or |SciPy spmatrix| N or `None` (if Cv is a `ZeroOperator`).
+            The |NumPy array| or |SciPy spmatrix| N or `None` (if N is a `ZeroOperator`).
         E
-            The |NumPy array| or |SciPy spmatrix| E.
+            The |NumPy array| or |SciPy spmatrix| E or `None` (if E is an `IdentityOperator`).
+        Q
+            The |NumPy array| or |SciPy spmatrix| Q  or `None` (if Q is an `IdentityOperator`).
         """
         J = to_matrix(self.J)
         R = to_matrix(self.R)
         G = to_matrix(self.G)
         P = None if isinstance(self.P, ZeroOperator) else to_matrix(self.P)
         S = None if isinstance(self.S, ZeroOperator) else to_matrix(self.S)
         N = None if isinstance(self.N, ZeroOperator) else to_matrix(self.N)
         E = None if isinstance(self.E, IdentityOperator) else to_matrix(self.E)
+        Q = None if isinstance(self.Q, IdentityOperator) else to_matrix(self.Q)
 
-        return J, R, G, P, S, N, E
-
-    def to_lti(self):
-        r"""Return a standard linear time-invariant system representation.
-
-        The representation
-
-        .. math::
-            A = J - R,\qquad B = G - P,\qquad C = (G + P)^T,\qquad D = S - N,\qquad E = E
-
-        is returned.
-
-        Returns
-        -------
-        lti
-            |LTIModel| equivalent to the port-Hamiltonian model.
-        """
-        return self._lti_model
-
-    def poles(self, mu=None):
-        """Compute system poles.
-
-        .. note::
-            Assumes the systems is small enough to use a dense eigenvalue solver.
-
-        Parameters
-        ----------
-        mu
-            |Parameter values|.
-
-        Returns
-        -------
-        One-dimensional |NumPy array| of system poles.
-        """
-        return self.to_lti().poles(mu=mu)
-
-    def gramian(self, typ, mu=None):
-        """Compute a Gramian.
-
-        Parameters
-        ----------
-        typ
-            The type of the Gramian:
-
-            - `'c_lrcf'`: low-rank Cholesky factor of the controllability Gramian,
-            - `'o_lrcf'`: low-rank Cholesky factor of the observability Gramian,
-            - `'c_dense'`: dense controllability Gramian,
-            - `'o_dense'`: dense observability Gramian.
-
-            .. note::
-                For `'*_lrcf'` types, the method assumes the system is asymptotically stable.
-                For `'*_dense'` types, the method assumes that the underlying Lyapunov equation
-                has a unique solution, i.e. no pair of system poles adds to zero in the
-                continuous-time case and no pair of system poles multiplies to one in the
-                discrete-time case.
-        mu
-            |Parameter values|.
-
-        Returns
-        -------
-        If typ is `'c_lrcf'` or `'o_lrcf'`, then the Gramian factor as a |VectorArray| from
-        `self.A.source`.
-        If typ is `'c_dense'` or `'o_dense'`, then the Gramian as a |NumPy array|.
-        """
-        assert typ in ('c_lrcf', 'o_lrcf', 'c_dense', 'o_dense')
-
-        return self.to_lti().gramian(typ, mu=mu)
-
-    def _sv_U_V(self, typ='lyap', mu=None):
-        """Compute (Hankel) singular values and vectors.
-
-        .. note::
-            Assumes the system is asymptotically stable.
-
-        Parameters
-        ----------
-        typ
-            The type of the Gramians used (see :meth:`LTIModel._sv_U_V`).
-        mu
-            |Parameter values|.
-
-        Returns
-        -------
-        sv
-            One-dimensional |NumPy array| of singular values.
-        Uh
-            |NumPy array| of left singular vectors as rows.
-        Vh
-            |NumPy array| of right singular vectors as rows.
-        """
-        return self.to_lti()._sv_U_V(typ=typ, mu=mu)
-
-    def hsv(self, mu=None):
-        """Hankel singular values.
-
-        .. note::
-            Assumes the system is asymptotically stable.
-
-        Parameters
-        ----------
-        mu
-            |Parameter values|.
-
-        Returns
-        -------
-        sv
-            One-dimensional |NumPy array| of singular values.
-        """
-        return self._sv_U_V(mu=mu)[0]
-
-    def h2_norm(self, mu=None):
-        """Compute the H2-norm.
-
-        .. note::
-            Assumes the system is asymptotically stable.
-
-        Parameters
-        ----------
-        mu
-            |Parameter values|.
-
-        Returns
-        -------
-        norm
-            H_2-norm.
-        """
-        return self.to_lti().h2_norm(mu=mu)
-
-    def hinf_norm(self, mu=None, return_fpeak=False, ab13dd_equilibrate=False):
-        """Compute the H_infinity-norm.
-
-        .. note::
-            Assumes the system is asymptotically stable.
-
-        Parameters
-        ----------
-        mu
-            |Parameter values|.
-        return_fpeak
-            Should the frequency at which the maximum is achieved should be returned.
-        ab13dd_equilibrate
-            Should `slycot.ab13dd` use equilibration.
-
-        Returns
-        -------
-        norm
-            H_infinity-norm.
-        fpeak
-            Frequency at which the maximum is achieved (if `return_fpeak` is `True`).
-        """
-        return self.to_lti().hinf_norm(mu=mu,
-                                       return_fpeak=return_fpeak,
-                                       ab13dd_equilibrate=ab13dd_equilibrate)
-
-    def hankel_norm(self, mu=None):
-        """Compute the Hankel-norm.
-
-        .. note::
-            Assumes the system is asymptotically stable.
-
-        Parameters
-        ----------
-        mu
-            |Parameter values|.
-
-        Returns
-        -------
-        norm
-            Hankel-norm.
-        """
-        return self.hsv(mu=mu)[0]
+        return J, R, G, P, S, N, E, Q
 
     def __add__(self, other):
-        """Add a |PHLTIModel|, an |LTIModel|, or a |SecondOrderModel|."""
-        if isinstance(other, LTIModel):
-            return self.to_lti() + other
-
-        if isinstance(other, SecondOrderModel):
-            return self.to_lti() + other.to_lti()
-
         if not isinstance(other, PHLTIModel):
-            return NotImplemented
+            return super().__add__(other)
 
         assert self.S.source == other.S.source
-        assert self.S.range == other.S.range
-
-        assert self.N.source == other.N.source
-        assert self.N.range == other.N.range
 
         J = BlockDiagonalOperator([self.J, other.J])
         R = BlockDiagonalOperator([self.R, other.R])
         G = BlockColumnOperator([self.G, other.G])
         P = BlockColumnOperator([self.P, other.P])
         S = self.S + other.S
-        N = self.S + other.S
+        N = self.N + other.N
         if isinstance(self.E, IdentityOperator) and isinstance(other.E, IdentityOperator):
             E = IdentityOperator(BlockVectorSpace([self.solution_space, other.solution_space]))
         else:
             E = BlockDiagonalOperator([self.E, other.E])
-
-        return self.with_(J=J, R=R, G=G, P=P, S=S, N=N, E=E)
-
-    def __radd__(self, other):
-        """Add to an |LTIModel| or |SecondOrderModel|."""
-        if isinstance(other, LTIModel):
-            return other + self.to_lti()
-        elif isinstance(other, SecondOrderModel):
-            return other.to_lti() + self.to_lti()
+        if isinstance(self.Q, IdentityOperator) and isinstance(other.Q, IdentityOperator):
+            Q = IdentityOperator(BlockVectorSpace([self.solution_space, other.solution_space]))
         else:
-            return NotImplemented
+            Q = BlockDiagonalOperator([self.Q, other.Q])
 
-    def __sub__(self, other):
-        """Subtract a |PHLTIModel| or an |LTIModel|."""
-        return self + (-other)
-
-    def __rsub__(self, other):
-        """Subtract from an |LTIModel|."""
-        if isinstance(other, LTIModel):
-            return other - self.to_lti()
-        else:
-            return NotImplemented
-
-    def __neg__(self):
-        """Negate the |PHLTIModel|."""
-        return -self.to_lti()
-
-    def __mul__(self, other):
-        """Postmultiply by an |LTIModel|."""
-        return self.to_lti() * other
-
-    def __rmul__(self, other):
-        """Premultiply by an |LTIModel|."""
-        return other * self.to_lti()
+        return self.with_(J=J, R=R, G=G, P=P, S=S, N=N, E=E, Q=Q)
 
 
 class SecondOrderModel(Model):
     r"""Class for linear second order systems.
 
     This class describes input-output systems given by
 
@@ -2580,39 +2484,43 @@
         Returns
         -------
         norm
             :math:`\mathcal{H}_2`-norm.
         """
         return self.to_lti().h2_norm(mu=mu)
 
-    def hinf_norm(self, mu=None, return_fpeak=False, ab13dd_equilibrate=False):
+    @defaults('tol')
+    def hinf_norm(self, mu=None, return_fpeak=False, ab13dd_equilibrate=False, tol=1e-10):
         r"""Compute the :math:`\mathcal{H}_\infty`-norm.
 
         .. note::
             Assumes the system is asymptotically stable.
 
         Parameters
         ----------
         mu
             |Parameter values|.
         return_fpeak
             Should the frequency at which the maximum is achieved should be returned.
         ab13dd_equilibrate
             Should `slycot.ab13dd` use equilibration.
+        tol
+            Tolerance in norm computation.
 
         Returns
         -------
         norm
             :math:`\mathcal{H}_\infty`.
         fpeak
             Frequency at which the maximum is achieved (if `return_fpeak` is `True`).
         """
         return self.to_lti().hinf_norm(mu=mu,
                                        return_fpeak=return_fpeak,
-                                       ab13dd_equilibrate=ab13dd_equilibrate)
+                                       ab13dd_equilibrate=ab13dd_equilibrate,
+                                       tol=tol)
 
     def hankel_norm(self, mu=None):
         """Compute the Hankel-norm.
 
         .. note::
             Assumes the system is asymptotically stable.
 
@@ -2790,15 +2698,15 @@
             f'    linear time-invariant\n'
             f'    solution_space:  {self.solution_space}'
         )
         return string
 
     def __add__(self, other):
         """Add an |LTIModel|, |SecondOrderModel|, |PHLTIModel|, or |LinearDelayModel|."""
-        if isinstance(other, (SecondOrderModel, PHLTIModel)):
+        if isinstance(other, SecondOrderModel):
             other = other.to_lti()
 
         if isinstance(other, LTIModel):
             Ad = tuple(BlockDiagonalOperator([op, ZeroOperator(other.solution_space, other.solution_space)])
                        for op in self.Ad)
             tau = self.tau
         elif isinstance(other, LinearDelayModel):
@@ -3176,40 +3084,42 @@
         string += (
             f'    bilinear time-invariant\n'
             f'    solution_space:  {self.solution_space}'
         )
         return string
 
 
-def _lti_to_poles_b_c(lti):
+def _lti_to_poles_b_c(lti, mu=None):
     """Compute poles and residues.
 
     Parameters
     ----------
     lti
         |LTIModel| consisting of |Operators| that can be converted to |NumPy arrays|.
         The D operator is ignored.
+    mu
+        |Parameter values|.
 
     Returns
     -------
     poles
         1D |NumPy array| of poles.
     b
         |NumPy array| of shape `(lti.order, lti.dim_input)`.
     c
         |NumPy array| of shape `(lti.order, lti.dim_output)`.
     """
-    A = to_matrix(lti.A, format='dense')
-    B = to_matrix(lti.B, format='dense')
-    C = to_matrix(lti.C, format='dense')
+    A = to_matrix(lti.A, format='dense', mu=mu)
+    B = to_matrix(lti.B, format='dense', mu=mu)
+    C = to_matrix(lti.C, format='dense', mu=mu)
     if isinstance(lti.E, IdentityOperator):
         poles, X = spla.eig(A)
         EX = X
     else:
-        E = to_matrix(lti.E, format='dense')
+        E = to_matrix(lti.E, format='dense', mu=mu)
         poles, X = spla.eig(A, E)
         EX = E @ X
     b = spla.solve(EX, B)
     c = (C @ X).T
     return poles, b, c
```

### Comparing `pymor-2022.2.1/src/pymor/models/mpi.py` & `pymor-2023.1.0/src/pymor/models/mpi.py`

 * *Files identical despite different names*

### Comparing `pymor-2022.2.1/src/pymor/models/neural_network.py` & `pymor-2023.1.0/src/pymor/models/neural_network.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,17 +1,17 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 from pymor.core.config import config
+
 config.require('TORCH')
 
 
 import numpy as np
-
 import torch
 import torch.nn as nn
 
 from pymor.core.base import BasicObject
 from pymor.models.interface import Model
 from pymor.operators.constructions import ZeroOperator
 from pymor.vectorarrays.numpy import NumpyVectorSpace
@@ -102,15 +102,15 @@
     def _compute_solution(self, mu=None, **kwargs):
 
         # convert the parameter `mu` into a form that is usable in PyTorch
         converted_input = torch.DoubleTensor(mu.to_numpy())
         converted_input = self._scale_input(converted_input)
         # obtain (reduced) coordinates by forward pass of the parameter values
         # through the neural network
-        U = self.neural_network(converted_input).data.numpy()
+        U = self.neural_network(converted_input).detach().numpy()
         U = self._scale_target(U)
         # convert plain numpy array to element of the actual solution space
         U = self.solution_space.make_array(U)
 
         return U
 
 
@@ -155,15 +155,15 @@
 
     def _compute(self, solution=False, output=False, solution_d_mu=False, output_d_mu=False,
                  solution_error_estimate=False, output_error_estimate=False,
                  output_d_mu_return_array=False, mu=None, **kwargs):
         if output:
             converted_input = torch.from_numpy(mu.to_numpy()).double()
             converted_input = self._scale_input(converted_input)
-            output = self.neural_network(converted_input).data.numpy()
+            output = self.neural_network(converted_input).detach().numpy()
             output = self._scale_target(output)
             if isinstance(output, torch.Tensor):
                 output = output.numpy()
             return {'output': output, 'solution': None}
         return {}
 
 
@@ -231,15 +231,15 @@
         self.dim_output = output_functional.range.dim
 
     def _compute_solution(self, mu=None, **kwargs):
         # collect all inputs in a single tensor
         inputs = self._scale_input(torch.DoubleTensor(np.array([mu.with_(t=t).to_numpy()
                                                                 for t in np.linspace(0., self.T, self.nt)])))
         # pass batch of inputs to neural network
-        result = self.neural_network(inputs).data.numpy()
+        result = self.neural_network(inputs).detach().numpy()
         result = self._scale_target(result)
         # convert result into element from solution space
         return self.solution_space.make_array(result)
 
 
 class NeuralNetworkInstationaryStatefreeOutputModel(BaseNeuralNetworkModel):
     """Class for models of the output of instationary problems that use ANNs.
@@ -287,15 +287,15 @@
     def _compute(self, solution=False, output=False, solution_d_mu=False, output_d_mu=False,
                  solution_error_estimate=False, output_error_estimate=False,
                  output_d_mu_return_array=False, mu=None, **kwargs):
 
         if output:
             inputs = self._scale_input(torch.DoubleTensor(np.array([mu.with_(t=t).to_numpy()
                                                                     for t in np.linspace(0., self.T, self.nt)])))
-            outputs = self.neural_network(inputs).data.numpy()
+            outputs = self.neural_network(inputs).detach().numpy()
             outputs = self._scale_target(outputs)
             if isinstance(outputs, torch.Tensor):
                 outputs = outputs.numpy()
 
             return {'output': outputs, 'solution': None}
         return {}
```

### Comparing `pymor-2022.2.1/src/pymor/models/symplectic.py` & `pymor-2023.1.0/src/pymor/models/symplectic.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 from pymor.algorithms.timestepping import ImplicitMidpointTimeStepper
 from pymor.models.basic import InstationaryModel
-from pymor.operators.constructions import ConcatenationOperator, NumpyConversionOperator, VectorOperator
 from pymor.operators.block import BlockOperator
+from pymor.operators.constructions import ConcatenationOperator, NumpyConversionOperator, VectorOperator
 from pymor.operators.interface import Operator
 from pymor.operators.numpy import NumpyVectorSpace
 from pymor.operators.symplectic import CanonicalSymplecticFormOperator
 from pymor.parameters.base import Mu
 from pymor.vectorarrays.block import BlockVectorSpace
 from pymor.vectorarrays.interface import VectorArray
 
@@ -106,15 +106,15 @@
         (for the |Parameter|-dependent case) a vector-like |Operator|
         (i.e. a linear |Operator| with `source.dim == 1`) which
         applied to `NumpyVectorArray(np.array([1]))` will yield the
         initial data for a given |Parameter|.
     H_op
         The |Operator| H_op.
     h
-        The state-independet part of the Hamiltonian h.
+        The state-independent part of the Hamiltonian h.
     time_stepper
         The :class:`time-stepper <pymor.algorithms.timestepping.TimeStepper>`
         to be used by :meth:`~pymor.models.interface.Model.solve`.
         Alternatively, the parameter nt can be specified to use the
         :class:`implicit midpoint rule <pymor.algorithms.timestepping.ImplicitMidpointTimeStepper>`.
     nt
         If time_stepper is `None` and nt is specified, the
```

### Comparing `pymor-2022.2.1/src/pymor/models/transfer_function.py` & `pymor-2023.1.0/src/pymor/models/transfer_function.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,19 +1,20 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
+from itertools import chain
+
 import numpy as np
 import scipy.linalg as spla
 
 from pymor.algorithms.to_matrix import to_matrix
-from pymor.core.cache import CacheableObject
-from pymor.core.cache import cached
-from pymor.operators.block import BlockOperator, BlockRowOperator, BlockColumnOperator, BlockDiagonalOperator
-from pymor.parameters.base import ParametricObject, Mu
+from pymor.core.cache import CacheableObject, cached
+from pymor.operators.block import BlockColumnOperator, BlockDiagonalOperator, BlockOperator, BlockRowOperator
+from pymor.parameters.base import Mu, Parameters, ParametricObject
 from pymor.tools.plot import adaptive
 
 
 class TransferFunction(CacheableObject, ParametricObject):
     r"""Class for systems represented by a transfer function.
 
     This class describes input-output systems given by a (parametrized) transfer
@@ -216,15 +217,16 @@
         mag = np.abs(tfw)
         phase = np.angle(tfw)
         phase = np.unwrap(phase, axis=0)
         if len(w) != 2:
             return mag, phase
         return w_new, mag, phase
 
-    def bode_plot(self, w, mu=None, ax=None, Hz=False, dB=False, deg=True, adaptive_opts=None, **mpl_kwargs):
+    def bode_plot(self, w, mu=None, ax=None, Hz=False, dB=False, deg=True, adaptive_opts=None, input_indices=None,
+                  output_indices=None, **mpl_kwargs):
         """Draw the Bode plot for all input-output pairs.
 
         Parameters
         ----------
         w
             If `len(w) == 2`, the left and right limits used for the adaptive sampling.
             Otherwise, a sequence of angular frequencies at which to compute the transfer function.
@@ -237,66 +239,90 @@
             Should the frequency be in Hz on the plot.
         dB
             Should the magnitude be in dB on the plot.
         deg
             Should the phase be in degrees (otherwise in radians).
         adaptive_opts
             Optional arguments for :func:`~pymor.tools.plot.adaptive` (ignored if `len(w) != 2`).
+        input_indices
+            Optional argument to select specific inputs to be paired with all outputs
+            or selected ones. If `None`, all inputs are used for plotting, otherwise, an
+            `iterable` containing the indices of the selected inputs has to be passed. The
+            order of the plots depends on the order of the indices in the `iterable`. It is
+            possible to pass negative indices to access the inputs counting backwards.
+        output_indices
+            Optional argument to select specific outputs to be paired  with all inputs
+            or selected ones. If `None`, all outputs are used for plotting, otherwise, an
+            `iterable` containing the indices of the selected outputs has to be passed. The
+            order of the plots depends on the order of the indices in the `iterable`. It is
+            possible to pass negative indices to access the outputs counting backwards.
         mpl_kwargs
             Keyword arguments used in the matplotlib plot function.
 
         Returns
         -------
         artists
             List of matplotlib artists added.
         """
+        if input_indices is None:
+            input_indices = list(range(self.dim_input))
+        if output_indices is None:
+            output_indices = list(range(self.dim_output))
+
+        assert all(isinstance(item, int) for item in chain(input_indices, output_indices))
+        assert all(-self.dim_input <= item < self.dim_input for item in input_indices), \
+            f'input_indices should be any integer value between {-self.dim_input} and {self.dim_input-1}'
+        assert all(-self.dim_output <= item < self.dim_output for item in output_indices), \
+            f'output_indices should be any integer value between {-self.dim_output} and {self.dim_output-1}'
+        num_input, num_output = len(input_indices), len(output_indices)
+
         if ax is None:
             import matplotlib.pyplot as plt
             fig = plt.gcf()
             width, height = plt.rcParams['figure.figsize']
-            fig.set_size_inches(self.dim_input * width, 2 * self.dim_output * height)
+            fig.set_size_inches(num_input * width, 2 * num_output * height)
             fig.set_constrained_layout(True)
-            ax = fig.subplots(2 * self.dim_output, self.dim_input, sharex=True, squeeze=False)
+            ax = fig.subplots(2 * num_output, num_input, sharex=True, squeeze=False)
         else:
+            if num_input == 1:
+                ax = ax.reshape((2 * num_output, 1))
             assert isinstance(ax, np.ndarray)
-            assert ax.shape == (2 * self.dim_output, self.dim_input), \
-                f'ax.shape={ax.shape} should be ({2 * self.dim_output}, {self.dim_input})'
+            assert ax.shape == (2 * num_output, num_input), \
+                f'ax.shape={ax.shape} should be ({2 * num_output}, {num_input})'
             fig = ax[0, 0].get_figure()
 
         if len(w) != 2:
             mag, phase = self.bode(w, mu=mu)
         else:
             w, mag, phase = self.bode(w, mu=mu, adaptive_opts=adaptive_opts)
         w = np.asarray(w)
         freq = w / (2 * np.pi) if Hz else w
         freq = freq / self.sampling_time if self.sampling_time > 0 else freq
         if deg:
             phase *= 180 / np.pi
-
         artists = np.empty_like(ax)
         freq_label = f'Frequency ({"Hz" if Hz else "rad/s"})'
         mag_label = f'Magnitude{" (dB)" if dB else ""}'
         phase_label = f'Phase ({"deg" if deg else "rad"})'
-        for i in range(self.dim_output):
-            for j in range(self.dim_input):
+        for i in range(num_output):
+            for j in range(num_input):
                 if dB:
-                    artists[2 * i, j] = ax[2 * i, j].semilogx(freq, 20 * np.log10(mag[:, i, j]),
-                                                              **mpl_kwargs)
+                    artists[2 * i, j] = ax[2 * i, j].semilogx(freq, 20 * np.log10(mag[:, output_indices[i],
+                                                              input_indices[j]]), **mpl_kwargs)
                 else:
-                    artists[2 * i, j] = ax[2 * i, j].loglog(freq, mag[:, i, j],
-                                                            **mpl_kwargs)
-                artists[2 * i + 1, j] = ax[2 * i + 1, j].semilogx(freq, phase[:, i, j],
-                                                                  **mpl_kwargs)
-        for i in range(self.dim_output):
+                    artists[2 * i, j] = ax[2 * i, j].loglog(freq, mag[:, output_indices[i],
+                                                            input_indices[j]], **mpl_kwargs)
+                artists[2 * i + 1, j] = ax[2 * i + 1, j].semilogx(freq, phase[:, output_indices[i],
+                                                                  input_indices[j]], **mpl_kwargs)
+        for i in range(num_output):
             ax[2 * i, 0].set_ylabel(mag_label)
             ax[2 * i + 1, 0].set_ylabel(phase_label)
-        for j in range(self.dim_input):
+        for j in range(num_input):
             ax[-1, j].set_xlabel(freq_label)
         fig.suptitle('Bode plot')
-
         return artists
 
     def mag_plot(self, w, mu=None, ax=None, ord=None, Hz=False, dB=False, adaptive_opts=None, **mpl_kwargs):
         """Draw the magnitude plot.
 
         Parameters
         ----------
@@ -394,37 +420,43 @@
             return norm
         norm_relerr = quad_out[1] / (2 * quad_out[0])
         if len(quad_out) == 2:
             return norm, norm_relerr
         else:
             return norm, norm_relerr, quad_out[2:]
 
-    def h2_inner(self, lti):
+    def h2_inner(self, lti, mu=None):
         """Compute H2 inner product with an |LTIModel|.
 
         Uses the inner product formula based on the pole-residue form
         (see, e.g., Lemma 1 in :cite:`ABG10`).
         It assumes that `self.tf` is defined on `-lti.poles()`.
 
         Parameters
         ----------
         lti
             |LTIModel| consisting of |Operators| that can be converted to |NumPy arrays|.
             The D operator is ignored.
+        mu
+            |Parameter values|.
 
         Returns
         -------
         inner
             H2 inner product.
         """
         from pymor.models.iosys import LTIModel, _lti_to_poles_b_c
         assert isinstance(lti, LTIModel)
 
-        poles, b, c = _lti_to_poles_b_c(lti)
-        inner = sum(c[i].dot(self.eval_tf(-poles[i]).dot(b[i]))
+        if not isinstance(mu, Mu):
+            mu = self.parameters.parse(mu)
+        assert self.parameters.assert_compatible(mu)
+
+        poles, b, c = _lti_to_poles_b_c(lti, mu=mu)
+        inner = sum(c[i].dot(self.eval_tf(-poles[i], mu=mu).dot(b[i]))
                     for i in range(len(poles)))
         inner = inner.conjugate()
 
         return inner
 
     def __add__(self, other):
         assert isinstance(other, TransferFunction) or hasattr(other, 'transfer_function')
@@ -434,15 +466,15 @@
         assert self.dim_input == other.dim_input
         assert self.dim_output == other.dim_output
 
         tf = lambda s, mu=None: self.eval_tf(s, mu=mu) + other.eval_tf(s, mu=mu)
         dtf = (lambda s, mu=None: self.eval_dtf(s, mu=mu) + other.eval_dtf(s, mu=mu)
                if hasattr(other, 'eval_dtf')
                else None)
-        return self.with_(tf=tf, dtf=dtf)
+        return self.with_(tf=tf, dtf=dtf, parameters=Parameters.of(self, other))
 
     __radd__ = __add__
 
     def __sub__(self, other):
         return self + (-other)
 
     def __rsub__(self, other):
@@ -453,15 +485,15 @@
         assert self.dim_input == other.dim_input
         assert self.dim_output == other.dim_output
 
         tf = lambda s, mu=None: other.eval_tf(s, mu=mu) - self.eval_tf(s, mu=mu)
         dtf = (lambda s, mu=None: other.eval_dtf(s, mu=mu) - self.eval_dtf(s, mu=mu)
                if hasattr(other, 'eval_dtf')
                else None)
-        return self.with_(tf=tf, dtf=dtf)
+        return self.with_(tf=tf, dtf=dtf, parameters=Parameters.of(self, other))
 
     def __neg__(self):
         tf = lambda s, mu=None: -self.eval_tf(s, mu=mu)
         dtf = (lambda s, mu=None: -self.eval_dtf(s, mu=mu)) if self.dtf is not None else None
         return self.with_(tf=tf, dtf=dtf)
 
     def __mul__(self, other):
@@ -472,29 +504,29 @@
         assert self.dim_input == other.dim_output
 
         tf = lambda s, mu=None: self.eval_tf(s, mu=mu) @ other.eval_tf(s, mu=mu)
         dtf = (lambda s, mu=None: (self.eval_dtf(s, mu=mu) @ other.eval_tf(s, mu=mu)
                                    + self.eval_tf(s, mu=mu) @ other.eval_dtf(s, mu=mu))
                if hasattr(other, 'eval_dtf')
                else None)
-        return self.with_(tf=tf, dtf=dtf)
+        return self.with_(tf=tf, dtf=dtf, parameters=Parameters.of(self, other))
 
     def __rmul__(self, other):
         assert isinstance(other, TransferFunction) or hasattr(other, 'transfer_function')
         if not isinstance(other, TransferFunction):
             other = other.transfer_function
         assert self.sampling_time == other.sampling_time
         assert self.dim_output == other.dim_input
 
         tf = lambda s, mu=None: other.eval_tf(s, mu=mu) @ self.eval_tf(s, mu=mu)
         dtf = (lambda s, mu=None: (other.eval_dtf(s, mu=mu) @ self.eval_tf(s, mu=mu)
                                    + other.eval_tf(s, mu=mu) @ self.eval_dtf(s, mu=mu))
                if hasattr(other, 'eval_dtf')
                else None)
-        return self.with_(tf=tf, dtf=dtf)
+        return self.with_(tf=tf, dtf=dtf, parameters=Parameters.of(self, other))
 
 
 class FactorizedTransferFunction(TransferFunction):
     r"""Transfer functions in generalized coprime factor form.
 
     This class describes input-output systems given by a transfer
     function of the form
@@ -579,15 +611,15 @@
                 and not hasattr(other, 'transfer_function')):
             return NotImplemented
 
         assert self.sampling_time == other.sampling_time
         assert self.dim_input == other.dim_input
         assert self.dim_output == other.dim_output
 
-        if not type(other) is FactorizedTransferFunction:
+        if type(other) is not FactorizedTransferFunction:
             other = other.transfer_function
 
         K = lambda s: BlockDiagonalOperator([self.K(s), other.K(s)])
         B = lambda s: BlockColumnOperator([self.B(s), other.B(s)])
         C = lambda s: BlockRowOperator([self.C(s), other.C(s)])
         D = lambda s: self.D(s) + other.D(s)
         dK = (lambda s: BlockDiagonalOperator([self.dK(s), other.dK(s)])
@@ -599,15 +631,15 @@
         dC = (lambda s: BlockRowOperator([self.dC(s), other.dC(s)])
               if self.dC is not None and other.dC is not None
               else None)
         dD = (lambda s: self.dD(s) + other.dD(s)
               if self.dD is not None and other.dD is not None
               else None)
 
-        return self.with_(K=K, B=B, C=C, D=D, dK=dK, dB=dB, dC=dC, dD=dD)
+        return self.with_(K=K, B=B, C=C, D=D, dK=dK, dB=dB, dC=dC, dD=dD, parameters=Parameters.of(self, other))
 
     __radd__ = __add__
 
     def __neg__(self):
         C = lambda s: -self.C(s)
         D = lambda s: -self.D(s)
         dC = lambda s: -self.dC(s) if self.dC is not None else None
@@ -618,15 +650,15 @@
         if (type(other) is not FactorizedTransferFunction
                 and not hasattr(other, 'transfer_function')):
             return NotImplemented
 
         assert self.sampling_time == other.sampling_time
         assert self.dim_input == other.dim_output
 
-        if not type(other) is FactorizedTransferFunction:
+        if type(other) is not FactorizedTransferFunction:
             other = other.transfer_function
 
         K = lambda s: BlockOperator([[self.K(s), -self.B(s) @ other.C(s)],
                                      [None, other.K(s)]])
         B = lambda s: BlockColumnOperator([self.B(s) @ other.D(s), other.B(s)])
         C = lambda s: BlockRowOperator([self.C(s), self.D(s) @ other.C(s)])
         D = lambda s: self.D(s) @ other.D(s)
@@ -640,13 +672,13 @@
         dC = (lambda s: BlockRowOperator([self.dC(s), self.dD(s) @ other.C(s) + self.D(s) @ other.dC(s)])
               if self.dC is not None and other.dC is not None and self.dD is not None
               else None)
         dD = (lambda s: self.dD(s) @ other.D(s) + self.D(s) @ other.dD(s)
               if self.dD is not None and other.dD is not None
               else None)
 
-        return self.with_(K=K, B=B, C=C, D=D, dK=dK, dB=dB, dC=dC, dD=dD)
+        return self.with_(K=K, B=B, C=C, D=D, dK=dK, dB=dB, dC=dC, dD=dD, parameters=Parameters.of(self, other))
 
     def __rmul__(self, other):
         if not hasattr(other, 'transfer_function'):
             return NotImplemented
         return other.transfer_function * self
```

### Comparing `pymor-2022.2.1/src/pymor/models/transforms.py` & `pymor-2023.1.0/src/pymor/models/transforms.py`

 * *Files identical despite different names*

### Comparing `pymor-2022.2.1/src/pymor/operators/block.py` & `pymor-2023.1.0/src/pymor/operators/block.py`

 * *Files 2% similar despite different names*

```diff
@@ -6,21 +6,22 @@
 
 from pymor.operators.constructions import IdentityOperator, ZeroOperator
 from pymor.operators.interface import Operator
 from pymor.vectorarrays.block import BlockVectorSpace
 
 
 class BlockOperatorBase(Operator):
+    """Base block |Operator|."""
 
     def _operators(self):
         """Iterator over operators."""
         for (i, j) in np.ndindex(self.blocks.shape):
             yield self.blocks[i, j]
 
-    def __init__(self, blocks):
+    def __init__(self, blocks, name=None):
         self.blocks = blocks = np.array(blocks)
         assert 1 <= blocks.ndim <= 2
         if self.blocked_source and self.blocked_range:
             assert blocks.ndim == 2
         elif self.blocked_source:
             if blocks.ndim == 1:
                 blocks.shape = (1, len(blocks))
@@ -46,14 +47,15 @@
                 range_spaces[i] = op.range
 
         # turn Nones to ZeroOperators
         for (i, j) in np.ndindex(blocks.shape):
             if blocks[i, j] is None:
                 self.blocks[i, j] = ZeroOperator(range_spaces[i], source_spaces[j])
 
+        self.__auto_init(locals())
         self.source = BlockVectorSpace(source_spaces) if self.blocked_source else source_spaces[0]
         self.range = BlockVectorSpace(range_spaces) if self.blocked_range else range_spaces[0]
         self.num_source_blocks = len(source_spaces)
         self.num_range_blocks = len(range_spaces)
         self.linear = all(op.linear for op in self._operators())
 
     @property
@@ -127,14 +129,21 @@
 
     def d_mu(self, parameter, index=0):
         blocks = np.empty(self.blocks.shape, dtype=object)
         for (i, j) in np.ndindex(self.blocks.shape):
             blocks[i, j] = self.blocks[i, j].d_mu(parameter, index)
         return self.with_(blocks=blocks)
 
+    def jacobian(self, U, mu):
+        assert len(U) == 1
+        jacs = np.empty(self.blocks.shape, dtype=object)
+        for (i, j) in np.ndindex(self.blocks.shape):
+            jacs[i, j] = self.blocks[i, j].jacobian(U.blocks[i] if self.blocked_source else U, mu)
+        return self.with_(blocks=jacs)
+
 
 class BlockOperator(BlockOperatorBase):
     """A matrix of arbitrary |Operators|.
 
     This operator can be :meth:`applied <pymor.operators.interface.Operator.apply>`
     to a compatible :class:`BlockVectorArrays <pymor.vectorarrays.block.BlockVectorArray>`.
 
@@ -165,49 +174,49 @@
 BlockOperator.adjoint_type = BlockOperator
 BlockRowOperator.adjoint_type = BlockColumnOperator
 BlockColumnOperator.adjoint_type = BlockRowOperator
 
 
 class BlockProjectionOperator(BlockRowOperator):
 
-    def __init__(self, block_space, component):
+    def __init__(self, block_space, component, name=None):
         assert isinstance(block_space, BlockVectorSpace)
         assert 0 <= component < len(block_space.subspaces)
         blocks = [ZeroOperator(space, space) if i != component else IdentityOperator(space)
                   for i, space in enumerate(block_space.subspaces)]
-        super().__init__(blocks)
+        super().__init__(blocks, name=name)
 
 
 class BlockEmbeddingOperator(BlockColumnOperator):
 
-    def __init__(self, block_space, component):
+    def __init__(self, block_space, component, name=None):
         assert isinstance(block_space, BlockVectorSpace)
         assert 0 <= component < len(block_space.subspaces)
         blocks = [ZeroOperator(space, space) if i != component else IdentityOperator(space)
                   for i, space in enumerate(block_space.subspaces)]
-        super().__init__(blocks)
+        super().__init__(blocks, name=name)
 
 
 class BlockDiagonalOperator(BlockOperator):
     """Block diagonal |Operator| of arbitrary |Operators|.
 
     This is a specialization of :class:`BlockOperator` for the
     block diagonal case.
     """
 
-    def __init__(self, blocks):
+    def __init__(self, blocks, name=None):
         blocks = np.array(blocks)
         assert 1 <= blocks.ndim <= 2
         if blocks.ndim == 2:
             blocks = np.diag(blocks)
         n = len(blocks)
         blocks2 = np.empty((n, n), dtype=object)
         for i, op in enumerate(blocks):
             blocks2[i, i] = op
-        super().__init__(blocks2)
+        super().__init__(blocks2, name=name)
 
     def apply(self, U, mu=None):
         assert U in self.source
         V_blocks = [self.blocks[i, i].apply(U.blocks[i], mu=mu) for i in range(self.num_range_blocks)]
         return self.range.make_array(V_blocks)
 
     def apply_adjoint(self, V, mu=None):
@@ -292,18 +301,19 @@
         Scalar.
     A
         |Operator|.
     B
         |Operator|.
     """
 
-    def __init__(self, alpha, beta, A, B):
+    def __init__(self, alpha, beta, A, B, name=None):
         eye = IdentityOperator(A.source)
         super().__init__([[alpha * eye, beta * eye],
-                          [B, A]])
+                          [B, A]],
+                          name=name)
         self.__auto_init(locals())
 
     def apply(self, U, mu=None):
         assert U in self.source
         V_blocks = [self.alpha * U.blocks[0] + self.beta * U.blocks[1],
                     self.B.apply(U.blocks[0], mu=mu) + self.A.apply(U.blocks[1], mu=mu)]
         return self.range.make_array(V_blocks)
```

### Comparing `pymor-2022.2.1/src/pymor/operators/constructions.py` & `pymor-2023.1.0/src/pymor/operators/constructions.py`

 * *Files 2% similar despite different names*

```diff
@@ -10,15 +10,15 @@
 import numpy as np
 import scipy.linalg as spla
 
 from pymor.core.defaults import defaults
 from pymor.core.exceptions import InversionError
 from pymor.operators.interface import Operator
 from pymor.parameters.base import ParametricObject
-from pymor.parameters.functionals import ParameterFunctional, ConjugateParameterFunctional
+from pymor.parameters.functionals import ConjugateParameterFunctional, ParameterFunctional
 from pymor.vectorarrays.interface import VectorArray, VectorSpace
 from pymor.vectorarrays.numpy import NumpyVectorSpace
 
 
 class LincombOperator(Operator):
     """Linear combination of arbitrary |Operators|.
 
@@ -352,15 +352,15 @@
         See :func:`pymor.algorithms.projection.project`.
     solver_options
         The |solver_options| for the projected operator.
     """
 
     linear = False
 
-    def __init__(self, operator, range_basis, source_basis, product=None, solver_options=None):
+    def __init__(self, operator, range_basis, source_basis, product=None, solver_options=None, name=None):
         assert isinstance(operator, Operator)
         assert source_basis is None or source_basis in operator.source
         assert range_basis is None or range_basis in operator.range
         assert (product is None
                 or (isinstance(product, Operator)
                     and range_basis is not None
                     and operator.range == product.source
@@ -595,30 +595,30 @@
 class ComponentProjectionOperator(Operator):
     """|Operator| representing the projection of a |VectorArray| onto some of its components.
 
     Parameters
     ----------
     components
         List or 1D |NumPy array| of the indices of the vector
-        :meth:`~pymor.vectorarrays.interface.VectorArray.components` that are
+        :meth:`~pymor.vectorarrays.interface.VectorArray.dofs` that are
         to be extracted by the operator.
     source
         Source |VectorSpace| of the operator.
     name
         Name of the operator.
     """
 
     linear = True
 
-    def __init__(self, components, source, name=None):
+    def __init__(self, components, source, range_id=None, name=None):
         assert all(0 <= c < source.dim for c in components)
         components = np.array(components, dtype=np.int32)
 
         self.__auto_init(locals())
-        self.range = NumpyVectorSpace(len(components))
+        self.range = NumpyVectorSpace(len(components), range_id)
 
     def apply(self, U, mu=None):
         assert U in self.source
         return self.range.make_array(U.dofs(self.components))
 
     def restricted(self, dofs):
         assert all(0 <= c < self.range.dim for c in dofs)
@@ -640,14 +640,15 @@
     name
         Name of the operator.
     """
 
     linear = True
 
     def __init__(self, space, name=None):
+        assert isinstance(space, VectorSpace)
         self.__auto_init(locals())
         self.source = self.range = space
 
     @property
     def H(self):
         return self
 
@@ -691,14 +692,15 @@
         Name of the operator.
     """
 
     linear = False
 
     def __init__(self, value, source, name=None):
         assert isinstance(value, VectorArray)
+        assert isinstance(source, VectorSpace)
         assert len(value) == 1
         value = value.copy()
 
         self.__auto_init(locals())
         self.range = value.space
 
     def apply(self, U, mu=None):
@@ -820,17 +822,18 @@
         else:
             return self.range.make_array(self.array.inner(U).T)
 
     def apply_inverse(self, V, mu=None, initial_guess=None, least_squares=False):
         if not least_squares and len(self.array) != self.array.dim:
             raise InversionError
 
-        from pymor.algorithms.gram_schmidt import gram_schmidt
         from numpy.linalg import lstsq
 
+        from pymor.algorithms.gram_schmidt import gram_schmidt
+
         Q, R = gram_schmidt(self.array, return_R=True, reiterate=False)
         if self.adjoint:
             v = lstsq(R.T.conj(), V.to_numpy().T, rcond=None)[0]
             U = Q.lincomb(v.T)
         else:
             v = Q.inner(V)
             u = lstsq(R, v, rcond=None)[0]
@@ -1450,7 +1453,78 @@
         self.parameters_own = {'input': B.source.dim}
 
     def apply(self, U, mu=None):
         return self.B.as_range_array(mu).lincomb(U.to_numpy() * mu['input'])
 
     def as_range_array(self, mu=None):
         return self.B.as_range_array(mu).lincomb(mu['input'])
+
+
+class QuadraticFunctional(Operator):
+    """An `Operator` representing a quadratic functional.
+
+    Given an operator `A` acting on R^d, this class represents the functional::
+
+        op: R^d ----> R^1
+             u  |---> (A(u), u).
+
+    Parameters
+    ----------
+    operator
+        The |Operator| defining the quadratic functional.
+    """
+
+    linear = False
+    range = NumpyVectorSpace(1)
+
+    def __init__(self, operator, name=None):
+        assert operator.linear
+        assert operator.source == operator.range
+        self.__auto_init(locals())
+        self.source = operator.source
+
+    def apply(self, U, mu=None):
+        assert U in self.source
+        return self.range.from_numpy(self.operator.apply2(U, U, mu))
+
+    def jacobian(self, U, mu=None):
+        inner_vec = self.operator.apply_adjoint(U, mu) + self.operator.apply(U, mu)
+        return VectorFunctional(inner_vec, name=self.name + '_jacobian')
+
+    def d_mu(self, parameter, index=1):
+        # the parameter derivative only takes effect on the inner operator
+        return QuadraticFunctional(self.operator.d_mu(parameter, index), name=self.name + '_d_mu')
+
+
+class QuadraticProductFunctional(QuadraticFunctional):
+    """An `Operator` representing a quadratic functional by multiplying two linear functionals.
+
+    Given linear operators `A`, `B`: R^d ----> R^n, this class represents the functional::
+
+        op: R^d ----> R^1
+             u  |---> (A(u), B(u)).
+
+    Parameters
+    ----------
+    left
+        The |Operator| that defines the left operator of the quadratic functional.
+    right
+        The |Operator| that defines the right operator of the quadratic functional.
+    product
+        The |Operator| that defines the inner product.
+    """
+
+    linear = False
+    range = NumpyVectorSpace(1)
+
+    def __init__(self, left, right, product=None, name=None):
+        assert left.source == right.source
+        assert left.range == right.range
+        assert product is None or (
+            isinstance(product, Operator) and product.source == right.range
+            and product.range == left.range)
+        self.__auto_init(locals())
+        self.source = left.source
+        if product is None:
+            super().__init__(left.H @ right, name=name)
+        else:
+            super().__init__(left.H @ product @ right, name=name)
```

### Comparing `pymor-2022.2.1/src/pymor/operators/ei.py` & `pymor-2023.1.0/src/pymor/operators/ei.py`

 * *Files 1% similar despite different names*

```diff
@@ -3,17 +3,20 @@
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 import weakref
 
 import numpy as np
 from scipy.linalg import solve, solve_triangular
 
-
-from pymor.operators.constructions import (ComponentProjectionOperator, ConcatenationOperator, VectorArrayOperator,
-                                           ZeroOperator)
+from pymor.operators.constructions import (
+    ComponentProjectionOperator,
+    ConcatenationOperator,
+    VectorArrayOperator,
+    ZeroOperator,
+)
 from pymor.operators.interface import Operator
 from pymor.operators.numpy import NumpyMatrixOperator
 from pymor.vectorarrays.interface import VectorArray
 from pymor.vectorarrays.numpy import NumpyVectorSpace
 
 
 class EmpiricalInterpolatedOperator(Operator):
@@ -152,15 +155,15 @@
 
     def __getstate__(self):
         d = self.__dict__.copy()
         del d['_operator']
         return d
 
 
-class ProjectedEmpiciralInterpolatedOperator(Operator):
+class ProjectedEmpiricalInterpolatedOperator(Operator):
     """A projected |EmpiricalInterpolatedOperator|."""
 
     def __init__(self, restricted_operator, interpolation_matrix, source_basis_dofs,
                  projected_collateral_basis, triangular, solver_options=None, name=None):
 
         name = name or f'{restricted_operator.name}_projected'
 
@@ -220,10 +223,10 @@
 
         old_pcb = self.projected_collateral_basis
         projected_collateral_basis = NumpyVectorSpace.make_array(old_pcb.to_numpy()[:dim, :])
 
         old_sbd = self.source_basis_dofs
         source_basis_dofs = NumpyVectorSpace.make_array(old_sbd.to_numpy()[:, source_dofs])
 
-        return ProjectedEmpiciralInterpolatedOperator(restricted_operator, interpolation_matrix,
+        return ProjectedEmpiricalInterpolatedOperator(restricted_operator, interpolation_matrix,
                                                       source_basis_dofs, projected_collateral_basis, self.triangular,
                                                       solver_options=self.solver_options, name=self.name)
```

### Comparing `pymor-2022.2.1/src/pymor/operators/interface.py` & `pymor-2023.1.0/src/pymor/operators/interface.py`

 * *Files 5% similar despite different names*

```diff
@@ -156,16 +156,17 @@
         AU = self.apply(U, mu=mu)
         return V.pairwise_inner(AU)
 
     def apply_adjoint(self, V, mu=None):
         """Apply the adjoint operator.
 
         For any given linear |Operator| `op`, |parameter values| `mu` and
-        |VectorArrays| `U`, `V` in the :attr:`~Operator.source`
-        resp. :attr:`~Operator.range` we have::
+        |VectorArrays| `U`, `V` in the
+        :attr:`~pymor.operators.interface.Operator.source` resp.
+        :attr:`~pymor.operators.interface.Operator.range` we have::
 
             op.apply_adjoint(V, mu).dot(U) == V.inner(op.apply(U, mu))
 
         Thus, when `op` is represented by a matrix `M`, `apply_adjoint` is
         given by left-multiplication of (the complex conjugate of) `M` with `V`.
 
         Parameters
@@ -372,16 +373,17 @@
             from pymor.operators.constructions import ZeroOperator
             return ZeroOperator(self.range, self.source, name=self.name + '_d_mu')
 
     def as_range_array(self, mu=None):
         """Return a |VectorArray| representation of the operator in its range space.
 
         In the case of a linear operator with |NumpyVectorSpace| as
-        :attr:`~Operator.source`, this method returns for given |parameter values|
-        `mu` a |VectorArray| `V` in the operator's :attr:`~Operator.range`,
+        :attr:`~pymor.operators.interface.Operator.source`, this method returns
+        for given |parameter values| `mu` a |VectorArray| `V` in the operator's
+        :attr:`~pymor.operators.interface.Operator.range`,
         such that ::
 
             V.lincomb(U.to_numpy()) == self.apply(U, mu)
 
         for all |VectorArrays| `U`.
 
         Parameters
@@ -399,16 +401,17 @@
         assert self.source.dim <= as_array_max_length()
         return self.apply(self.source.from_numpy(np.eye(self.source.dim)), mu=mu)
 
     def as_source_array(self, mu=None):
         """Return a |VectorArray| representation of the operator in its source space.
 
         In the case of a linear operator with |NumpyVectorSpace| as
-        :attr:`~Operator.range`, this method returns for given |parameter values|
-        `mu` a |VectorArray| `V` in the operator's :attr:`~Operator.source`,
+        :attr:`~pymor.operators.interface.Operator.range`, this method returns
+        for given |parameter values| `mu` a |VectorArray| `V` in the operator's
+        :attr:`~pymor.operators.interface.Operator.source`,
         such that ::
 
             self.range.make_array(V.inner(U).T) == self.apply(U, mu)
 
         for all |VectorArrays| `U`.
 
         Parameters
@@ -425,17 +428,20 @@
         assert isinstance(self.range, NumpyVectorSpace) and self.linear
         assert self.range.dim <= as_array_max_length()
         return self.apply_adjoint(self.range.from_numpy(np.eye(self.range.dim)), mu=mu)
 
     def as_vector(self, mu=None):
         """Return a vector representation of a linear functional or vector operator.
 
-        Depending on the operator's :attr:`~Operator.source` and
-        :attr:`~Operator.range`, this method is equivalent to calling
-        :meth:`~Operator.as_range_array` or :meth:`~Operator.as_source_array`
+        Depending on the operator's
+        :attr:`~pymor.operators.interface.Operator.source` and
+        :attr:`~pymor.operators.interface.Operator.range`, this method is
+        equivalent to calling
+        :meth:`~pymor.operators.interface.Operator.as_range_array` or
+        :meth:`~pymor.operators.interface.Operator.as_source_array`
         respectively. The resulting |VectorArray| is required to have length 1.
 
         Parameters
         ----------
         mu
             The |parameter values| for which to return the vector representation.
 
@@ -532,22 +538,25 @@
         restricted operator which can make its evaluation very fast
         compared to evaluating the original operator.
 
         Parameters
         ----------
         dofs
             One-dimensional |NumPy array| of degrees of freedom in the operator
-            :attr:`~Operator.range` to which to restrict.
+            :attr:`~pymor.operators.interface.Operator.range` to which to
+            restrict.
 
         Returns
         -------
         restricted_op
             The restricted operator as defined above. The operator will have
-            |NumpyVectorSpace| `(len(source_dofs))` as :attr:`~Operator.source`
-            and |NumpyVectorSpace| `(len(dofs))` as :attr:`~Operator.range`.
+            |NumpyVectorSpace| `(len(source_dofs))` as
+            :attr:`~pymor.operators.interface.Operator.source` and
+            |NumpyVectorSpace| `(len(dofs))` as
+            :attr:`~pymor.operators.interface.Operator.range`.
         source_dofs
             One-dimensional |NumPy array| of source degrees of freedom as
             defined above.
         """
         raise NotImplementedError
 
     def _add_sub(self, other, sign):
```

### Comparing `pymor-2022.2.1/src/pymor/operators/list.py` & `pymor-2023.1.0/src/pymor/operators/list.py`

 * *Files 2% similar despite different names*

```diff
@@ -5,14 +5,15 @@
 from pymor.core.base import abstractmethod
 from pymor.operators.interface import Operator
 from pymor.operators.numpy import NumpyMatrixOperator
 from pymor.vectorarrays.list import NumpyListVectorSpace
 
 
 class ListVectorArrayOperatorBase(Operator):
+    """Base |Operator| for |ListVectorArrays|."""
 
     def _prepare_apply(self, U, mu, kind, least_squares=False):
         pass
 
     @abstractmethod
     def _apply_one_vector(self, u, mu=None, prepare_data=None):
         pass
@@ -66,14 +67,15 @@
                  for i, u in enumerate(U.vectors)]
         except NotImplementedError:
             return super().apply_inverse_adjoint(U, mu=mu, least_squares=least_squares)
         return self.range.make_array(V)
 
 
 class LinearComplexifiedListVectorArrayOperatorBase(ListVectorArrayOperatorBase):
+    """Base |Operator| for complexified |ListVectorArrays|."""
 
     linear = True
 
     @abstractmethod
     def _real_apply_one_vector(self, u, mu=None, prepare_data=None):
         pass
```

### Comparing `pymor-2022.2.1/src/pymor/operators/mpi.py` & `pymor-2023.1.0/src/pymor/operators/mpi.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 from pymor.operators.constructions import LincombOperator, VectorArrayOperator
 from pymor.operators.interface import Operator
 from pymor.tools import mpi
-from pymor.vectorarrays.mpi import MPIVectorSpace, _register_local_space, _indexed
+from pymor.vectorarrays.mpi import MPIVectorSpace, _indexed, _register_local_space
 
 
 class MPIOperator(Operator):
     """MPI distributed |Operator|.
 
     Given a single-rank implementation of an |Operator|, this
     wrapper class uses the event loop from :mod:`pymor.tools.mpi`
```

### Comparing `pymor-2022.2.1/src/pymor/operators/numpy.py` & `pymor-2023.1.0/src/pymor/operators/numpy.py`

 * *Files 1% similar despite different names*

```diff
@@ -14,19 +14,19 @@
 - |NumpyHankelOperator| implicitly constructs a Hankel operator from a |NumPy array| of
   Markov parameters.
 """
 
 from functools import reduce
 
 import numpy as np
-from numpy.fft import fft, ifft, rfft, irfft
+import scipy.sparse
+from numpy.fft import fft, ifft, irfft, rfft
 from scipy.io import mmwrite, savemat
 from scipy.linalg import lu_factor, lu_solve
 from scipy.linalg.lapack import get_lapack_funcs
-import scipy.sparse
 from scipy.sparse import issparse
 
 from pymor.core.base import abstractmethod
 from pymor.core.defaults import defaults
 from pymor.core.exceptions import InversionError
 from pymor.core.logger import getLogger
 from pymor.operators.interface import Operator
```

### Comparing `pymor-2022.2.1/src/pymor/operators/symplectic.py` & `pymor-2023.1.0/src/pymor/operators/symplectic.py`

 * *Files identical despite different names*

### Comparing `pymor-2022.2.1/src/pymor/parallel/basic.py` & `pymor-2023.1.0/src/pymor/parallel/basic.py`

 * *Files 2% similar despite different names*

```diff
@@ -3,15 +3,15 @@
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 """This module contains a base class for implementing WorkerPool."""
 
 import weakref
 
 from pymor.core.base import ImmutableObject
-from pymor.parallel.interface import WorkerPool, RemoteObject
+from pymor.parallel.interface import RemoteObject, WorkerPool
 
 
 class WorkerPoolDefaultImplementations:
 
     def scatter_array(self, U, copy=True):
         slice_len = len(U) // len(self) + (1 if len(U) % len(self) else 0)
         if copy:
@@ -35,14 +35,15 @@
         del l
         remote_l = self.push([])
         self.map(_append_list_slice, slices, l=remote_l)
         return remote_l
 
 
 class WorkerPoolBase(WorkerPoolDefaultImplementations, WorkerPool):
+    """Basic |WorkerPool|."""
 
     def __init__(self):
         self._pushed_immutable_objects = {}
 
     def push(self, obj):
         if isinstance(obj, ImmutableObject):
             uid = obj.uid
@@ -92,14 +93,15 @@
         for arg in args:
             assert list(chain(*split_arg(arg))) == arg
         chunks = tuple(list(split_arg(arg)) for arg in args)
         return chunks
 
 
 class GenericRemoteObject(RemoteObject):
+    """Generic |RemoteObject|."""
 
     def __init__(self, pool, remote_id, uid=None):
         self.pool = weakref.ref(pool)
         self.remote_id = remote_id
         self.uid = uid
 
     def _remove(self):
```

### Comparing `pymor-2022.2.1/src/pymor/parallel/default.py` & `pymor-2023.1.0/src/pymor/parallel/default.py`

 * *Files identical despite different names*

### Comparing `pymor-2022.2.1/src/pymor/parallel/dummy.py` & `pymor-2023.1.0/src/pymor/parallel/dummy.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,18 +1,19 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 from copy import deepcopy
 
 from pymor.core.base import ImmutableObject
-from pymor.parallel.interface import WorkerPool, RemoteObject
+from pymor.parallel.interface import RemoteObject, WorkerPool
 
 
 class DummyPool(WorkerPool):
+    """Dummy |WorkerPool|."""
 
     def __len__(self):
         return 1
 
     def push(self, obj):
         if isinstance(obj, ImmutableObject):
             return DummyRemoteObject(obj)
@@ -48,13 +49,14 @@
         return False
 
 
 dummy_pool = DummyPool()
 
 
 class DummyRemoteObject(RemoteObject):
+    """Dummy |RemoteObject|."""
 
     def __init__(self, obj):
         self.obj = obj
 
     def _remove(self):
         del self.obj
```

### Comparing `pymor-2022.2.1/src/pymor/parallel/interface.py` & `pymor-2023.1.0/src/pymor/parallel/interface.py`

 * *Files 1% similar despite different names*

```diff
@@ -29,16 +29,16 @@
         pass
 
     @abstractmethod
     def push(self, obj):
         """Push a copy of `obj` to  all workers of the pool.
 
         A |RemoteObject| is returned as a handle to the pushed object.
-        This object can be used as a keyword argument to :meth:`~WorkerPool.apply`,
-        :meth:`~WorkerPool.apply_only`, :meth:`~WorkerPool.map`
+        This object can be used as a keyword argument to :meth:`apply`,
+        :meth:`apply_only`, :meth:`map`
         and will then be transparently mapped to the respective copy
         of the pushed object on the worker.
 
         |Immutable| objects will be pushed only once. If the same |immutable| object
         is pushed a second time, the returned |RemoteObject| will refer to the
         already transferred copy. It is therefore safe to use `push` to ensure
         that a given |immutable| object is available on the worker. No unnecessary
```

### Comparing `pymor-2022.2.1/src/pymor/parallel/ipython.py` & `pymor-2023.1.0/src/pymor/parallel/ipython.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,32 +1,32 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 from pymor.core.config import config
+
 config.require('IPYTHON')
 
 
-from itertools import chain
 import os
 import time
+from itertools import chain
 
-from pymor.core.base import BasicObject
 from pymor.core import defaults
+from pymor.core.base import BasicObject
 from pymor.parallel.basic import WorkerPoolBase
 from pymor.tools.counter import Counter
 
-
 try:
     from ipyparallel import Client, TimeoutError
 except ImportError:
     from IPython.parallel import Client, TimeoutError
 
 
-class new_ipcluster_pool(BasicObject):
+class new_ipcluster_pool(BasicObject):  # noqa: N801
     """Create a new IPython parallel cluster and connect to it.
 
     This context manager can be used to create an :class:`IPythonPool`
     |WorkerPool|. When entering the context a new IPython cluster is
     created using the `ipcluster` script and an :class:`IPythonPool`
     is instantiated for the newly created cluster. When leaving
     the context the cluster is shut down.
```

### Comparing `pymor-2022.2.1/src/pymor/parallel/manager.py` & `pymor-2023.1.0/src/pymor/parallel/manager.py`

 * *Files identical despite different names*

### Comparing `pymor-2022.2.1/src/pymor/parallel/mpi.py` & `pymor-2023.1.0/src/pymor/parallel/mpi.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,14 +1,13 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
-from itertools import chain
 import os
-
+from itertools import chain
 
 from pymor.parallel.basic import WorkerPoolBase
 from pymor.tools import mpi
 from pymor.tools.random import get_seed_seq
 
 
 class MPIPool(WorkerPoolBase):
```

### Comparing `pymor-2022.2.1/src/pymor/parameters/base.py` & `pymor-2023.1.0/src/pymor/parameters/base.py`

 * *Files 9% similar despite different names*

```diff
@@ -113,15 +113,16 @@
 
         Raises
         ------
         ValueError
             Is raised if `mu` cannot be interpreted as |parameter values| for the
             given |Parameters|.
         """
-        from pymor.analyticalproblems.functions import Function, ExpressionFunction
+        from pymor.analyticalproblems.expressions import Array, Constant
+        from pymor.analyticalproblems.functions import ExpressionFunction, Function, SymbolicExpressionFunction
 
         def fail(msg):
             if isinstance(mu, dict):
                 mu_str = '{' + ', '.join([f'{k}: {v}' for k, v in mu.items()]) + '}'
             else:
                 mu_str = str(mu)
             raise ValueError(f'{mu_str} is incompatible with Parameters {self} ({msg})')
@@ -133,53 +134,104 @@
         if isinstance(mu, Mu):
             mu.parameters == self or fail(self.why_incompatible(mu))
             set(mu) == set(self) or fail(f'additional parameters {set(mu) - set(self)}')
             return mu
 
         # convert mu to dict
         if isinstance(mu, (Number, str, Function)):
-            assert self or fail('too many values')
-            assert len(self) == 1 or fail('not enough values')
-            mu = {next(iter(self.keys())): mu}
+            mu = [mu]
 
-        elif isinstance(mu, (tuple, list, np.ndarray)):
+        def convert_to_function(v):
+            if isinstance(v, Number):
+                return v
+            f = ExpressionFunction(v, dim_domain=1, variable='t') if isinstance(v, str) else v
+            f.dim_domain == 1 or \
+                fail(f'dim_domain of parameter function must be 1 (not {f.dim_domain}):\n'
+                     f'    {v}')
+            len(f.shape_range) <= 1 or \
+                fail(f'parameter function must be scalar- or vector-valued (not {f.shape_range}):\n'
+                     f'    {v}')
+            return f
+
+        if isinstance(mu, (tuple, list, np.ndarray)):
             if isinstance(mu, np.ndarray):
                 mu = mu.ravel()
             all(isinstance(v, (Number, str, Function)) for v in mu) or \
                 fail('not every element a number or function')
+
+            # first convert all strings to functions to get their shape
+            mu = [convert_to_function(v) for v in mu]
+
             parsed_mu = {}
             for k, v in self.items():
-                len(mu) >= v or fail('not enough values')
-                if len(mu) > 0 and isinstance(mu[0], (str, Function)):
+                if len(mu) > 0 and isinstance(mu[0], Function) and \
+                        len(mu[0].shape_range) == 1 and mu[0].shape_range[0] > 1:
                     p, mu = mu[0], mu[1:]
+                    p.shape_range[0] == v or \
+                        fail(f'shape of parameter function for parameter {k} must be {v} (not {p.shape_range[0]}):\n'
+                             f'    {p}')
                 else:
                     len(mu) >= v or fail('not enough values')
                     p, mu = mu[:v], mu[v:]
                 parsed_mu[k] = p
             len(mu) == 0 or fail('too many values')
             mu = parsed_mu
 
         set(mu.keys()) == set(self.keys()) or fail('parameters not matching')
 
         def parse_value(k, v):
-            if isinstance(v, (Number, tuple, list, np.ndarray)):
-                if isinstance(v, Number):
-                    v = np.array([v])
-                elif isinstance(v, (tuple, list)):
-                    v = np.array(v)
+            if isinstance(v, Number):
+                v = np.array([v])
+                v = v.ravel()
+                len(v) == self[k] or fail(f'wrong dimension of parameter value {k}')
+                return v
+            elif isinstance(v, np.ndarray):
                 v = v.ravel()
                 len(v) == self[k] or fail(f'wrong dimension of parameter value {k}')
                 return v
             elif isinstance(v, (str, Function)):
-                if isinstance(v, str):
-                    v = ExpressionFunction(v, dim_domain=1, variable='t')
-                v.dim_domain == 1 or fail(f'wrong domain dimension of parameter function {k}')
+                v = convert_to_function(v)
+
+                # convert scalar-valued functions to functions 1D shape_range
+                if v.shape_range == () and self[k] == 1 and isinstance(v, SymbolicExpressionFunction):
+                    v = SymbolicExpressionFunction(Array([v.expression_obj]), dim_domain=1, variable='t')
+
                 len(v.shape_range) == 1 or fail(f'wrong shape_range of parameter function {k}')
                 v.shape_range[0] == self[k] or fail(f'wrong range dimension of prameter function {k}')
                 return v
+            elif isinstance(v, (tuple, list)):
+                all(isinstance(vv, (Number, str, Function)) for vv in v) or \
+                    fail(f"invalid value type '{type(v)}' for parameter {k}")
+                v = [convert_to_function(vv) for vv in v]
+                if any(isinstance(vv, Function) for vv in v):
+                    len(v) == self[k] or fail(f'wrong dimension of parameter value {k}')
+                    funcs = []
+                    for i, vv in enumerate(v):
+                        if isinstance(vv, Number):
+                            f = SymbolicExpressionFunction(Constant(vv), dim_domain=1, variable='t')
+                        else:
+                            f = vv
+
+                        f.dim_domain == 1 or fail(f'wrong domain dimension of parameter function {k}')
+
+                        # convert functions to scalar-valued functions if possible
+                        if f.shape_range == (1,) and isinstance(f, SymbolicExpressionFunction):
+                            f = SymbolicExpressionFunction(f.expression_obj[0], dim_domain=1, variable='t')
+
+                        f.shape_range == () or \
+                            fail(f'parameter function {k}[{i}] not scalar-valued: {vv}')
+                        funcs.append(f)
+                    v = SymbolicExpressionFunction(Array([f.expression_obj for f in funcs]),
+                                                   dim_domain=1, variable='t')
+                    return v
+                else:
+                    v = np.array(v)
+                    v = v.ravel()
+                    len(v) == self[k] or fail(f'wrong dimension of parameter value {k}')
+                    return v
             else:
                 fail(f"invalid value type '{type(v)}' for parameter {k}")
 
         return Mu({k: parse_value(k, v) for k, v in mu.items()})
 
     def space(self, *ranges):
         """Create a |ParameterSpace| with given ranges.
@@ -273,14 +325,16 @@
     Attributes
     ----------
     parameters
         The |Parameters| to which the mapping assigns values.
     """
 
     __slots__ = ('_raw_values')
+    __array_priority__ = 100.0
+    __array_ufunc__ = None
 
     def __new__(cls, *args, **kwargs):
         raw_values = dict(*args, **kwargs)
         values_for_t = {}
         for k, v in sorted(raw_values.items()):
             assert isinstance(k, str)
             if callable(v):
@@ -370,14 +424,39 @@
         if not isinstance(mu, Mu):
             try:
                 mu = Mu(mu)
             except Exception:
                 return False
         return self.keys() == mu.keys() and all(np.array_equal(v, mu[k]) for k, v in self.items())
 
+    def __neg__(self):
+        return Mu({key: -value for key, value in self.items()})
+
+    def __add__(self, other):
+        if not isinstance(other, Mu):
+            other = self.parameters.parse(other)
+        assert self.keys() == other.keys()
+        return Mu({key: self[key] + other[key] for key in self})
+
+    def __radd__(self, other):
+        return self + other
+
+    def __sub__(self, other):
+        return self + -other
+
+    def __rsub__(self, other):
+        return -self + other
+
+    def __mul__(self, other):
+        assert isinstance(other, Number)
+        return Mu({key: self[key] * other for key in self})
+
+    def __rmul__(self, other):
+        return self * other
+
     def __str__(self):
         def format_value(k, v):
             if self.is_time_dependent(k):
                 return f'{self._raw_values[k]}({self.get("t", 0)}) = {format_array(v)}'
             else:
                 return format_array(v)
 
@@ -536,22 +615,21 @@
             of the parameter. Either a dict of counts per |Parameter|
             or a single count that is taken for each parameter in |Parameters|.
 
         Returns
         -------
         List of |parameter value| dicts.
         """
-        if isinstance(counts, dict):
-            pass
-        else:
+        if not isinstance(counts, dict):
             counts = {k: counts for k in self.parameters}
 
-        linspaces = tuple(np.linspace(self.ranges[k][0], self.ranges[k][1], num=counts[k]) for k in self.parameters)
-        iters = tuple(product(ls, repeat=max(0, np.zeros(sps).size))
-                      for ls, sps in zip(linspaces, self.parameters.values()))
+        linspaces = tuple(np.linspace(self.ranges[k][0], self.ranges[k][1], num=counts[k])
+                          for k in self.parameters)
+        iters = tuple(product(linspace, repeat=size)
+                      for linspace, size in zip(linspaces, self.parameters.values()))
         return [Mu((k, np.array(v)) for k, v in zip(self.parameters, i))
                 for i in product(*iters)]
 
     def sample_randomly(self, count=None):
         """Randomly sample |parameter values| from the space.
 
         Parameters
@@ -561,16 +639,63 @@
             Otherwise, the number of random samples to generate and return as
             a list of |parameter values| dicts.
 
         Returns
         -------
         The sampled |parameter values|.
         """
-        get_param = lambda: Mu(((k, get_rng().uniform(self.ranges[k][0], self.ranges[k][1], size))
-                               for k, size in self.parameters.items()))
+        get_param = lambda: Mu((k, get_rng().uniform(self.ranges[k][0], self.ranges[k][1], size))
+                               for k, size in self.parameters.items())
+        if count is None:
+            return get_param()
+        else:
+            return [get_param() for _ in range(count)]
+
+    def sample_logarithmic_uniformly(self, counts):
+        """Logarithmically uniform sample |parameter values| from the space.
+
+        Parameters
+        ----------
+        counts
+            Number of samples to take per parameter and component
+            of the parameter. Either a dict of counts per |Parameter|
+            or a single count that is taken for each parameter in |Parameters|.
+
+        Returns
+        -------
+        List of |parameter value| dicts.
+        """
+        if not isinstance(counts, dict):
+            counts = {k: counts for k in self.parameters}
+
+        logspaces = tuple(np.geomspace(self.ranges[k][0], self.ranges[k][1], num=counts[k])
+                          for k in self.parameters)
+        iters = tuple(product(logspace, repeat=size)
+                      for logspace, size in zip(logspaces, self.parameters.values()))
+        return [Mu((k, np.array(v)) for k, v in zip(self.parameters, i))
+                for i in product(*iters)]
+
+    def sample_logarithmic_randomly(self, count=None):
+        """Logarithmically scaled random sample |parameter values| from the space.
+
+        Parameters
+        ----------
+        count
+            If `None`, a single dict `mu` of |parameter values| is returned.
+            Otherwise, the number of logarithmically random samples to generate and return as
+            a list of |parameter values| dicts.
+
+        Returns
+        -------
+        The sampled |parameter values|.
+        """
+        get_param = lambda: Mu((k, np.exp(get_rng().uniform(np.log(self.ranges[k][0]),
+                                                            np.log( self.ranges[k][1]),
+                                                            size)))
+                               for k, size in self.parameters.items())
         if count is None:
             return get_param()
         else:
             return [get_param() for _ in range(count)]
 
     def contains(self, mu):
         if not isinstance(mu, Mu):
```

### Comparing `pymor-2022.2.1/src/pymor/parameters/functionals.py` & `pymor-2023.1.0/src/pymor/parameters/functionals.py`

 * *Files 0% similar despite different names*

```diff
@@ -4,15 +4,15 @@
 
 from numbers import Number
 
 import numpy as np
 
 from pymor.analyticalproblems.expressions import parse_expression
 from pymor.core.base import abstractmethod
-from pymor.parameters.base import Mu, ParametricObject, Parameters
+from pymor.parameters.base import Mu, Parameters, ParametricObject
 from pymor.tools.floatcmp import float_cmp
 
 
 class ParameterFunctional(ParametricObject):
     """Interface for |Parameter| functionals.
 
     A parameter functional is simply a function mapping |Parameters| to
@@ -158,15 +158,15 @@
             assert 0 <= index < self.size
             if index == self.index:
                 return ConstantParameterFunctional(1, name=f'{self.name}_d_{parameter}_{index}')
         return ConstantParameterFunctional(0, name=f'{self.name}_d_{parameter}_{index}')
 
 
 class GenericParameterFunctional(ParameterFunctional):
-    """A wrapper making an arbitrary Python function a |ParameterFunctional|
+    """A wrapper making an arbitrary Python function a |ParameterFunctional|.
 
     Note that a GenericParameterFunctional can only be :mod:`pickled <pymor.core.pickle>`
     if the function it is wrapping can be pickled. For this reason, it is usually
     preferable to use :class:`ExpressionParameterFunctional` instead of
     :class:`GenericParameterFunctional`.
 
     Parameters
@@ -233,15 +233,15 @@
 class ExpressionParameterFunctional(GenericParameterFunctional):
     """Turns a Python expression given as a string into a |ParameterFunctional|.
 
     Some |NumPy| arithmetic functions like `sin`, `log`, `min` are supported.
     For a full list see the `functions` class attribute.
 
     .. warning::
-       :meth:`eval` is used to evaluate the given expression.
+       :func:`eval` is used to evaluate the given expression.
        Using this class with expression strings from untrusted sources will cause
        mayhem and destruction!
 
     Parameters
     ----------
     expression
         A Python expression in the parameter components of the given `parameters`.
@@ -338,15 +338,15 @@
         if not summands:
             return ConstantParameterFunctional(0, name=f'{self.name}_d_{parameter}_{index}')
         else:
             return LincombParameterFunctional(summands, [1] * len(summands), name=f'{self.name}_d_{parameter}_{index}')
 
 
 class ConjugateParameterFunctional(ParameterFunctional):
-    """Conjugate of a given |ParameterFunctional|
+    """Conjugate of a given |ParameterFunctional|.
 
     Evaluates a given |ParameterFunctional| and returns the complex
     conjugate of the value.
 
     Parameters
     ----------
     functional
```

### Comparing `pymor-2022.2.1/src/pymor/reductors/aaa.py` & `pymor-2023.1.0/src/pymor/reductors/aaa.py`

 * *Files 2% similar despite different names*

```diff
@@ -29,22 +29,25 @@
         `len(sampling_values[0])*...*len(sampling_values[-1])` rows. This reductor should
         only be used with a low number of variables.
 
     Parameters
     ----------
     sampling_values
         Values where sample data has been evaluated or the full-order model should be evaluated.
-        Sampling values are represented as a nested list such that `sampling_values[i]` corresponds
-        to sampling values of the `i`-th variable. The first variable is the Laplace variable.
+        Sampling values are represented as a list of |NumPy arrays| such that `sampling_values[i]`
+        corresponds to sampling values of the `i`-th variable given as a |NumPy array|. The first
+        variable is the Laplace variable. In the non-parametric case (i.e., the only variable is
+        the Laplace variable) this can also be a |NumPy array| representing the sampling values.
     samples_or_fom
         Can be either a full-order model (|TransferFunction| or |Model| with a `transfer_function`
-        attribute) or data sampled at the values specified in `sampling_values`. Samples are
-        represented as a tensor `S`. E.g., for 3 inputs `S[i,j,k]` corresponds to the sampled
-        value at `(sampling_values[0][i],sampling_values[1][j],sampling_values[2][k])`. In the
-        MIMO case `S[i,j,k]` represents a matrix of dimension `dim_output` times `dim_input`.
+        attribute) or data sampled at the values specified in `sampling_values` as a |NumPy array|.
+        Samples are represented as a tensor `S`. E.g., for 3 inputs `S[i,j,k]` corresponds to the
+        sampled value at `(sampling_values[0][i],sampling_values[1][j],sampling_values[2][k])`.
+        The samples (i.e., `S[i,j,k]`) need to be provided as 2-dimensional |NumPy arrays|. E.g.,
+        in the MIMO case `S[i,j,k]` represents a matrix of dimension `dim_output` times `dim_input`.
     conjugate
         Whether to compute complex conjugates of first sampling variables and enforce
         interpolation in complex conjugate pairs (allows for constructing real system matrices).
     nsp_tol
         Tolerance for null space of higher-dimensional Loewner matrix to check for
         interpolation or convergence.
     post_process
@@ -61,14 +64,18 @@
         A nested list such that `itpl_part[i]` corresponds to indices of interpolated values
         with respect to the `i`-th variable. I.e., `self.sampling_values[i][itpl_part[i]]`
         represents a list of all interpolated samples of the `i`-th variable.
     """
 
     def __init__(self, sampling_values, samples_or_fom, conjugate=True, nsp_tol=1e-16, post_process=True,
                  L_rk_tol=1e-8):
+        if isinstance(sampling_values, np.ndarray):
+            sampling_values = [sampling_values]
+        assert isinstance(sampling_values, list)
+        assert all(isinstance(sv, np.ndarray) for sv in sampling_values)
         if isinstance(samples_or_fom, TransferFunction) or hasattr(samples_or_fom, 'transfer_function'):
             fom = samples_or_fom
             if not isinstance(samples_or_fom, TransferFunction):
                 fom = fom.transfer_function
             self.num_vars = 1 + fom.parameters.dim
 
             assert len(sampling_values) == self.num_vars
@@ -79,28 +86,34 @@
                                  itertools.product(*sampling_values)):
                 params = fom.parameters.parse(vals[1:])
                 self.samples[idx] = fom.eval_tf(vals[0], mu=params)
             if fom.dim_input == fom.dim_output == 1:
                 self.samples = self.samples.reshape(self.samples.shape[:-2])
         else:
             self.samples = samples_or_fom
+            # SISO case requires reshape
+            if self.samples.shape[-2:] == (1, 1):
+                self.samples = self.samples.reshape(self.samples.shape[:-2])
             self.num_vars = len(sampling_values)
             self._parameters = {'p': self.num_vars-1}
 
         # add complex conjugate samples
         if conjugate:
             s_conj_list = []
-            samples_conj_list = []
+            samples_conj_list = None
             for i, s in enumerate(sampling_values[0]):
                 if s.conj() not in sampling_values[0]:
                     s_conj_list.append(s.conj())
-                    samples_conj_list.append(self.samples[i, None].conj())
+                    if samples_conj_list is None:
+                        samples_conj_list = self.samples[i, None].conj()
+                    else:
+                        samples_conj_list = np.concatenate((samples_conj_list, self.samples[i, None].conj()))
             if s_conj_list:
                 sampling_values[0] = np.append(sampling_values[0], s_conj_list)
-                self.samples = np.vstack([self.samples] + samples_conj_list)
+                self.samples = np.concatenate((self.samples, samples_conj_list))
 
         # Transform samples for MIMO case
         if len(self.samples.shape) != len(sampling_values):
             assert len(self.samples.shape) == len(sampling_values) + 2
             self._dim_input = self.samples.shape[-1]
             self._dim_output = self.samples.shape[-2]
             samples_T = np.empty(self.samples.shape[:-2], dtype=self.samples.dtype)
```

### Comparing `pymor-2022.2.1/src/pymor/reductors/basic.py` & `pymor-2023.1.0/src/pymor/reductors/basic.py`

 * *Files 0% similar despite different names*

```diff
@@ -8,19 +8,19 @@
 
 from pymor.algorithms.basic import almost_equal
 from pymor.algorithms.gram_schmidt import gram_schmidt
 from pymor.algorithms.pod import pod
 from pymor.algorithms.projection import project, project_to_subbasis
 from pymor.core.base import BasicObject, abstractmethod
 from pymor.core.defaults import defaults
-from pymor.core.exceptions import ExtensionError, AccuracyError
-from pymor.models.basic import StationaryModel, InstationaryModel
-from pymor.models.iosys import LTIModel, SecondOrderModel, LinearDelayModel
-from pymor.operators.numpy import NumpyMatrixOperator
+from pymor.core.exceptions import AccuracyError, ExtensionError
+from pymor.models.basic import InstationaryModel, StationaryModel
+from pymor.models.iosys import LinearDelayModel, LTIModel, SecondOrderModel
 from pymor.operators.constructions import ConcatenationOperator, IdentityOperator, InverseOperator
+from pymor.operators.numpy import NumpyMatrixOperator
 
 
 class ProjectionBasedReductor(BasicObject):
     """Generic projection based reductor.
 
     Parameters
     ----------
@@ -139,15 +139,15 @@
         U = self.bases[basis]
         product = self.products.get(basis, None)
         error_matrix = U[offset:].inner(U, product)
         error_matrix[:len(U) - offset, offset:] -= np.eye(len(U) - offset)
         if error_matrix.size > 0:
             err = np.max(np.abs(error_matrix))
             if err >= self.check_tol:
-                raise AccuracyError(f"result not orthogonal (max err={err})")
+                raise AccuracyError(f'result not orthogonal (max err={err})')
 
 
 class StationaryRBReductor(ProjectionBasedReductor):
     """Galerkin projection of a |StationaryModel|.
 
     Parameters
     ----------
```

### Comparing `pymor-2022.2.1/src/pymor/reductors/bt.py` & `pymor-2023.1.0/src/pymor/reductors/bt.py`

 * *Files 4% similar despite different names*

```diff
@@ -223,7 +223,37 @@
 
     def _sv_U_V(self):
         return self.fom._sv_U_V(('br', self.gamma), mu=self.mu)
 
     def error_bounds(self):
         sv = self._sv_U_V()[0]
         return 2 * sv[:0:-1].cumsum()[::-1]
+
+
+class PRBTReductor(GenericBTReductor):
+    r"""Positive Real (PR) Balanced Truncation reductor.
+
+    See :cite:`DP84` and :cite:`BU22`.
+
+    Parameters
+    ----------
+    fom
+        The full-order |LTIModel| to reduce.
+    mu
+        |Parameter values|.
+    """
+
+    def __init__(self, fom, mu=None):
+        if fom.sampling_time > 0:
+            raise NotImplementedError
+        super().__init__(fom, mu=mu)
+
+    def _gramians(self):
+        cf = self.fom.gramian('pr_c_lrcf', mu=self.mu)
+        of = self.fom.gramian('pr_o_lrcf', mu=self.mu)
+        return cf, of
+
+    def _sv_U_V(self):
+        return self.fom._sv_U_V('pr', mu=self.mu)
+
+    def error_bounds(self):
+        raise NotImplementedError
```

### Comparing `pymor-2022.2.1/src/pymor/reductors/coercive.py` & `pymor-2023.1.0/src/pymor/reductors/coercive.py`

 * *Files 0% similar despite different names*

```diff
@@ -5,15 +5,15 @@
 import numpy as np
 
 from pymor.algorithms.image import estimate_image
 from pymor.algorithms.projection import project
 from pymor.core.base import ImmutableObject
 from pymor.operators.constructions import LincombOperator, induced_norm
 from pymor.operators.numpy import NumpyMatrixOperator
-from pymor.parameters.functionals import ParameterFunctional, ConstantParameterFunctional
+from pymor.parameters.functionals import ConstantParameterFunctional, ParameterFunctional
 from pymor.reductors.basic import StationaryRBReductor
 from pymor.reductors.residual import ResidualReductor
 from pymor.vectorarrays.numpy import NumpyVectorSpace
 
 
 class CoerciveRBReductor(StationaryRBReductor):
     """Reduced Basis reductor for |StationaryModels| with coercive linear operator.
```

### Comparing `pymor-2022.2.1/src/pymor/reductors/dwr.py` & `pymor-2023.1.0/src/pymor/reductors/dwr.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,42 +1,43 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
-import numpy as np
 from numbers import Number
 
+import numpy as np
+
 from pymor.algorithms.projection import project
-from pymor.core.base import ImmutableObject, BasicObject
+from pymor.core.base import BasicObject, ImmutableObject
 from pymor.operators.block import BlockColumnOperator
 from pymor.operators.constructions import ConcatenationOperator, NumpyConversionOperator, VectorOperator
 from pymor.operators.interface import Operator
 from pymor.reductors.coercive import CoerciveRBReductor
 from pymor.reductors.residual import ResidualOperator
 
 
 class DWRCoerciveRBReductor(BasicObject):
-    """Reduced Basis reductor for |StationaryModels| with coercive linear operator
+    """Reduced Basis reductor for |StationaryModels| with coercive linear operator.
 
     This class can be used as a replacement for
     :class:`~pymor.reductors.coercive.CoerciveRBReductor` to obtain a corrected reduced
     output functional with the DWR approach (see :cite:`Haa17` (Definition 2.31, Proposition 2.32)).
     This also implements a DWR-based error estimator for the corrected output functional.
     The DWR approach requires the reduction of a dual problem for every dimension of the output
     functional. Each dual problem is defined by the dual operator and the corresponding component
-    of the output functional as right-hand side. See also :meth:`~pymor.reductors.dwr.dual_model`.
+    of the output functional as right-hand side. See also :meth:`create_dual_model`.
 
     Parameters
     ----------
     fom
         The |Model| which is to be reduced.
     dual_foms
         List of the dual |Models| that correspond to each dimension of the output_functional.
         If `dual_foms` is `None`, the default dual models are constructed
-        by :meth:`~pymor.reductors.dwr.create_dual_model`, assuming a fully discrete perspective.
+        by :meth:`create_dual_model`, assuming a fully discrete perspective.
     primal_RB
         |VectorArray| containing the reduced basis on which to project the fom.
     dual_RBs
         List of |VectorArrays| containing the reduced bases on which to project the `dual_foms`,
         where each entry of the list corresponds to the dimensions of the output functional.
         If `dual_bases` is `None`, the primal basis are used.
     product
@@ -53,15 +54,15 @@
                  coercivity_estimator=None, check_orthonormality=None, check_tol=None):
         self.__auto_init(locals())
         self._last_rom = None
 
         if dual_RBs is not None:
             assert len(dual_RBs) == fom.dim_output
         assert (fom.output_functional is not None and fom.output_functional.linear), \
-            'DWRCoerciveRBReductor requires a linear ouput functional. ' + \
+            'DWRCoerciveRBReductor requires a linear output functional. ' + \
             'Please use CoerciveRBReductor instead.'
 
         self.primal_reductor = CoerciveRBReductor(fom, RB=primal_RB, product=product,
                                                   coercivity_estimator=coercivity_estimator,
                                                   check_orthonormality=check_orthonormality,
                                                   check_tol=check_tol)
         # construct default dual models if not provided
@@ -230,25 +231,25 @@
         primal_estimator = self.primal_estimator.restricted_to_subbasis(primal_dim, m)
         dual_estimators = [dual_estimator.restricted_to_subbasis(dim, m) for
                            dual_estimator, dim in zip(self.dual_estimators, dual_dims)]
         return DWRCoerciveRBEstimator(primal_estimator, dual_estimators, dual_roms)
 
 
 class CorrectedOutputFunctional(Operator):
-    """|Operator| representing the corrected output functional from :cite:`Haa17` (Definition 2.31)
+    """|Operator| representing the corrected output functional from :cite:`Haa17` (Definition 2.31).
 
     Parameters
     ----------
     output_functional
-        Original output_functional
+        Original output functional.
     dual_models
-        Dual models for the corrected output, see :meth:`~pymor.reductors.dwr.create_dual_model`
+        Dual models for the corrected output, see :meth:`~DWRCoerciveRBReductor.create_dual_model`.
     dual_projected_primal_residuals
         The primal residuals projected on the dual space (in the first argument) and on the
-        primal space (in the second argument)
+        primal space (in the second argument).
     """
 
     linear = False
 
     def __init__(self, output_functional, dual_models, dual_projected_primal_residuals):
         self.__auto_init(locals())
         self.source = output_functional.source
```

### Comparing `pymor-2022.2.1/src/pymor/reductors/era.py` & `pymor-2023.1.0/src/pymor/reductors/era.py`

 * *Files 0% similar despite different names*

```diff
@@ -3,15 +3,15 @@
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 import numpy as np
 import scipy.linalg as spla
 
 from pymor.algorithms.projection import project
 from pymor.algorithms.to_matrix import to_matrix
-from pymor.core.cache import cached, CacheableObject
+from pymor.core.cache import CacheableObject, cached
 from pymor.models.iosys import LTIModel
 from pymor.operators.interface import Operator
 from pymor.operators.numpy import NumpyHankelOperator, NumpyMatrixOperator
 
 
 class ERAReductor(CacheableObject):
     r"""Eigensystem Realization Algorithm reductor.
```

### Comparing `pymor-2022.2.1/src/pymor/reductors/h2.py` & `pymor-2023.1.0/src/pymor/reductors/h2.py`

 * *Files identical despite different names*

### Comparing `pymor-2022.2.1/src/pymor/reductors/interpolation.py` & `pymor-2023.1.0/src/pymor/reductors/interpolation.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,21 +1,22 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
+from abc import abstractmethod
+
 import numpy as np
 
-from pymor.algorithms.krylov import rational_arnoldi
 from pymor.algorithms.gram_schmidt import gram_schmidt, gram_schmidt_biorth
+from pymor.algorithms.krylov import rational_arnoldi
 from pymor.core.base import BasicObject
-from pymor.models.iosys import LTIModel, SecondOrderModel, LinearDelayModel
+from pymor.models.iosys import LinearDelayModel, LTIModel, SecondOrderModel
 from pymor.models.transfer_function import TransferFunction
 from pymor.parameters.base import Mu
-from pymor.reductors.basic import (ProjectionBasedReductor, LTIPGReductor, SOLTIPGReductor,
-                                   DelayLTIPGReductor)
+from pymor.reductors.basic import DelayLTIPGReductor, LTIPGReductor, ProjectionBasedReductor, SOLTIPGReductor
 
 
 class GenericBHIReductor(BasicObject):
     r"""Generic bitangential Hermite interpolation reductor.
 
     This is a generic reductor for reducing any linear `Model` that has a
     transfer function that is a `FactorizedTransferFunction`
@@ -74,16 +75,17 @@
 
     def _K_apply_inverse(self, s, V):
         return self.fom.transfer_function.K(s).apply_inverse(V, mu=self.mu)
 
     def _K_apply_inverse_adjoint(self, s, V):
         return self.fom.transfer_function.K(s).apply_inverse_adjoint(V, mu=self.mu)
 
+    @abstractmethod
     def _fom_assemble(self):
-        raise NotImplementedError
+        pass
 
     def reduce(self, sigma, b, c, projection='orth'):
         """Bitangential Hermite interpolation.
 
         Parameters
         ----------
         sigma
```

### Comparing `pymor-2022.2.1/src/pymor/reductors/mt.py` & `pymor-2023.1.0/src/pymor/reductors/mt.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,13 +1,14 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 import numpy as np
 import scipy.linalg as spla
+
 from pymor.algorithms.gram_schmidt import gram_schmidt, gram_schmidt_biorth
 from pymor.algorithms.samdp import samdp
 from pymor.algorithms.to_matrix import to_matrix
 from pymor.core.base import BasicObject
 from pymor.models.iosys import LTIModel, sparse_min_size
 from pymor.operators.constructions import IdentityOperator
 from pymor.operators.numpy import NumpyMatrixOperator
```

### Comparing `pymor-2022.2.1/src/pymor/reductors/neural_network.py` & `pymor-2023.1.0/src/pymor/reductors/neural_network.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,35 +1,38 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 from pymor.core.config import config
+
 config.require('TORCH')
 
 
-from numbers import Number
 import inspect
+from numbers import Number
 
 import numpy as np
-
 import torch
 import torch.nn as nn
 import torch.optim as optim
 import torch.utils as utils
 
 from pymor.algorithms.pod import pod
 from pymor.algorithms.projection import project
 from pymor.core.base import BasicObject
-from pymor.core.exceptions import NeuralNetworkTrainingFailed
+from pymor.core.exceptions import NeuralNetworkTrainingError
 from pymor.core.logger import getLogger
-from pymor.models.neural_network import (FullyConnectedNN, LongShortTermMemoryNN,
-                                         NeuralNetworkModel,
-                                         NeuralNetworkStatefreeOutputModel,
-                                         NeuralNetworkInstationaryModel,
-                                         NeuralNetworkInstationaryStatefreeOutputModel)
+from pymor.models.neural_network import (
+    FullyConnectedNN,
+    LongShortTermMemoryNN,
+    NeuralNetworkInstationaryModel,
+    NeuralNetworkInstationaryStatefreeOutputModel,
+    NeuralNetworkModel,
+    NeuralNetworkStatefreeOutputModel,
+)
 from pymor.tools.random import get_rng, get_seed_seq
 
 
 class NeuralNetworkReductor(BasicObject):
     """Reduced Basis reductor relying on artificial neural networks.
 
     This is a reductor that constructs a reduced basis using proper
@@ -347,19 +350,19 @@
 
     def _check_tolerances(self):
         """Check if trained neural network is sufficient to guarantee certain error bounds."""
         with self.logger.block('Checking tolerances for error of neural network ...'):
 
             if isinstance(self.ann_mse, Number):
                 if self.losses['full'] > self.ann_mse:
-                    raise NeuralNetworkTrainingFailed('Could not train a neural network that '
+                    raise NeuralNetworkTrainingError('Could not train a neural network that '
                                                       'guarantees prescribed tolerance!')
             elif self.ann_mse == 'like_basis':
                 if self.losses['full'] > self.mse_basis:
-                    raise NeuralNetworkTrainingFailed('Could not train a neural network with an error as small as '
+                    raise NeuralNetworkTrainingError('Could not train a neural network with an error as small as '
                                                       'the reduced basis error! Maybe you can try a different '
                                                       'neural network architecture or change the value of '
                                                       '`ann_mse`.')
             elif self.ann_mse is None:
                 self.logger.info('Using neural network with smallest validation error ...')
                 self.logger.info(f'Finished training with a validation loss of {self.losses["val"]} ...')
             else:
@@ -612,15 +615,15 @@
 
         samples = [(mu, self.reduced_basis.inner(u_t, product=product)[:, 0])
                    for mu, u_t in zip(parameters_with_time, u)]
 
         return samples
 
     def _compute_layer_sizes(self, hidden_layers):
-        """Compute the number of neurons in the layers of the neural network
+        """Compute the number of neurons in the layers of the neural network.
 
         (make sure to increase the input dimension to account for the time).
         """
         # determine the numbers of neurons in the hidden layers
         if isinstance(hidden_layers, str):
             hidden_layers = eval(hidden_layers, {'N': len(self.reduced_basis), 'P': self.parameters_dim})
         # input and output size of the neural network are prescribed by the
@@ -1018,15 +1021,15 @@
         (a loss function from PyTorch; if not provided, the MSE loss is taken
         as default), `'lr_scheduler'` (a learning rate scheduler from the
         PyTorch `optim.lr_scheduler` package; if not provided or `None`,
         no learning rate scheduler is used), `'lr_scheduler_params'`
         (a dictionary of additional parameters for the learning rate
         scheduler), `'es_scheduler_params'` (a dictionary of additional
         parameters for the early stopping scheduler), and `'weight_decay'`
-        (non-negative real number that determines the strenght of the
+        (non-negative real number that determines the strength of the
         l2-regularization; if not provided or 0., no regularization is applied).
     scaling_parameters
         Dict of tensors that determine how to scale inputs before passing them
         through the neural network and outputs after obtaining them from the
         neural network. If not provided or each entry is `None`, no scaling is
         applied. Required keys are `'min_inputs'`, `'max_inputs'`, `'min_targets'`,
         and `'max_targets'`.
@@ -1076,16 +1079,16 @@
         batch_size = max(len(training_data), len(validation_data))
 
     # initialize optimizer, early stopping scheduler and learning rate scheduler
     weight_decay = training_parameters.get('weight_decay', 0.)
     assert weight_decay >= 0.
     if weight_decay > 0. and 'weight_decay' not in inspect.getfullargspec(optimizer).args:
         optimizer = optimizer(neural_network.parameters(), lr=learning_rate)
-        logger.warning(f"Optimizer {optimizer.__class__.__name__} does not support weight decay! "
-                       "Continuing without regularization!")
+        logger.warning(f'Optimizer {optimizer.__class__.__name__} does not support weight decay! '
+                       'Continuing without regularization!')
     elif 'weight_decay' in inspect.getfullargspec(optimizer).args:
         optimizer = optimizer(neural_network.parameters(), lr=learning_rate,
                               weight_decay=weight_decay)
     else:
         optimizer = optimizer(neural_network.parameters(), lr=learning_rate)
 
     if 'es_scheduler_params' in training_parameters:
@@ -1166,15 +1169,18 @@
                     # compute loss of current batch
                     loss = closure()
 
                 # update overall absolute loss
                 running_loss += loss.item() * len(batch[0])
 
             # compute average loss
-            epoch_loss = running_loss / len(dataloaders[phase].dataset)
+            if len(dataloaders[phase].dataset) > 0:
+                epoch_loss = running_loss / len(dataloaders[phase].dataset)
+            else:
+                epoch_loss = np.inf
 
             losses[phase] = epoch_loss
 
             losses['full'] += running_loss
 
             if log_loss_frequency > 0 and epoch % log_loss_frequency == 0:
                 logger.info(f'Epoch {epoch}: Current {phase} loss of {losses[phase]:.3e}')
@@ -1231,15 +1237,15 @@
     best_neural_network
         The best trained neural network.
     losses
         The corresponding losses.
 
     Raises
     ------
-    NeuralNetworkTrainingFailed
+    NeuralNetworkTrainingError
         Raised if prescribed loss can not be reached within the given number
         of restarts.
     """
     assert isinstance(training_parameters, dict)
     assert isinstance(max_restarts, int) and max_restarts >= 0
 
     logger = getLogger('pymor.algorithms.neural_network.multiple_restarts_training')
@@ -1302,11 +1308,11 @@
             best_neural_network = current_nn
             losses = current_losses
         else:
             logger.info(f'Rejecting neural network with loss of {current_losses["full"]:.3e} '
                         f'(instead of {losses["full"]:.3e}) ...')
 
     if target_loss:
-        raise NeuralNetworkTrainingFailed(f'Could not find neural network with prescribed loss of '
+        raise NeuralNetworkTrainingError(f'Could not find neural network with prescribed loss of '
                                           f'{target_loss:.3e} (best one found was {losses["full"]:.3e})!')
     logger.info(f'Found neural network with error of {losses["full"]:.3e} ...')
     return best_neural_network, losses
```

### Comparing `pymor-2022.2.1/src/pymor/reductors/parabolic.py` & `pymor-2023.1.0/src/pymor/reductors/parabolic.py`

 * *Files 1% similar despite different names*

```diff
@@ -6,15 +6,15 @@
 
 from pymor.algorithms.image import estimate_image
 from pymor.algorithms.projection import project
 from pymor.algorithms.timestepping import ImplicitEulerTimeStepper
 from pymor.core.base import ImmutableObject
 from pymor.operators.constructions import IdentityOperator
 from pymor.reductors.basic import InstationaryRBReductor
-from pymor.reductors.residual import ResidualReductor, ImplicitEulerResidualReductor
+from pymor.reductors.residual import ImplicitEulerResidualReductor, ResidualReductor
 
 
 class ParabolicRBReductor(InstationaryRBReductor):
     r"""Reduced Basis Reductor for parabolic equations.
 
     This reductor uses :class:`~pymor.reductors.basic.InstationaryRBReductor` for the actual
     RB-projection. The only addition is the assembly of an error estimator which
```

### Comparing `pymor-2022.2.1/src/pymor/reductors/residual.py` & `pymor-2023.1.0/src/pymor/reductors/residual.py`

 * *Files identical despite different names*

### Comparing `pymor-2022.2.1/src/pymor/reductors/sobt.py` & `pymor-2023.1.0/src/pymor/reductors/sobt.py`

 * *Files identical despite different names*

### Comparing `pymor-2022.2.1/src/pymor/reductors/sor_irka.py` & `pymor-2023.1.0/src/pymor/reductors/sor_irka.py`

 * *Files identical despite different names*

### Comparing `pymor-2022.2.1/src/pymor/reductors/symplectic.py` & `pymor-2023.1.0/src/pymor/reductors/symplectic.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,20 +1,20 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 from numbers import Number
 
 import numpy as np
+
 from pymor.algorithms.projection import project
 from pymor.algorithms.simplify import contract, expand
 from pymor.algorithms.symplectic import SymplecticBasis
 from pymor.core.base import BasicObject
-from pymor.models.symplectic import (BaseQuadraticHamiltonianModel,
-                                     QuadraticHamiltonianModel)
+from pymor.models.symplectic import BaseQuadraticHamiltonianModel, QuadraticHamiltonianModel
 from pymor.operators.constructions import IdentityOperator
 from pymor.operators.numpy import NumpyMatrixOperator
 
 
 class QuadraticHamiltonianRBReductor(BasicObject):
     """Symplectic Galerkin projection of a |QuadraticHamiltonianModel|.
```

### Comparing `pymor-2022.2.1/src/pymor/scripts/pymor_demo.py` & `pymor-2023.1.0/src/pymor/scripts/pymor_demo.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,19 +1,19 @@
 #!/usr/bin/env python
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
-from __future__ import absolute_import, division, print_function
 
 import importlib
 import pkgutil
-import pymordemos
-import sys
 import runpy
+import sys
+
+import pymordemos
 
 
 def run():
     def _run(module):
         # only need to remove the modname from args, rest is automatic
         del sys.argv[1]
         runpy.run_module(module, init_globals=None, run_name='__main__', alter_sys=True)
@@ -28,22 +28,22 @@
         shorts.append(short)
         try:
             importlib.import_module(module_name)
         except (ImportError, ModuleNotFoundError) as e:
             fails[short] = e
 
     def usage():
-        msg = f'''Usage:
+        msg = f"""Usage:
     {sys.argv[0]} DEMO_NAME | -h [DEMO_OPTIONS]
 
 Arguments:
     -h           this message
     DEMO_NAME    select one from these: {",".join(shorts)}
     DEMO_OPTIONS any arguments for the demo, including -h for detailed help
-'''
+"""
         print(msg)
         if len(fails):
             print('\nThere are some pyMOR demos for which additional packages need to be installed:')
             print('\t'+'\n\t'.join(fails))
             print('\nYou can try to `pip install pymor[full]` to install optional dependencies.\n')
         sys.exit(0)
```

### Comparing `pymor-2022.2.1/src/pymor/scripts/pymor_vis.py` & `pymor-2023.1.0/src/pymor/scripts/pymor_vis.py`

 * *Files identical despite different names*

### Comparing `pymor-2022.2.1/src/pymor/tools/deprecated.py` & `pymor-2023.1.0/src/pymor/tools/deprecated.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,14 +1,14 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 import functools
-import types
 import inspect
+import types
 import warnings
 
 
 class Deprecated:
     """Decorator for marking functions as deprecated.
 
     It will result in a warning being emitted when the function is used.
@@ -30,10 +30,10 @@
                   f'{frame.f_code.co_filename}:{frame.f_code.co_firstlineno}\n' \
                   f'Use {self._alt} instead'
             warnings.warn(msg, DeprecationWarning, stacklevel=2)
             return func(*args, **kwargs)
         return new_func
 
     def __get__(self, obj, ownerClass=None):
-        """Return a wrapper that binds self as a method of obj (!)"""
+        """Return a wrapper that binds self as a method of obj (!)."""
         self.obj = obj
         return types.MethodType(self, obj)
```

### Comparing `pymor-2022.2.1/src/pymor/tools/floatcmp.py` & `pymor-2023.1.0/src/pymor/tools/floatcmp.py`

 * *Files 2% similar despite different names*

```diff
@@ -12,15 +12,15 @@
     """Compare x and y component-wise for almost equality.
 
     For scalars we define almost equality as ::
 
        float_cmp(x,y) <=> |x - y| <= atol + |y|*rtol
 
     .. note::
-       Numpy's :meth:`~numpy.allclose` method uses the same definition but
+       Numpy's :func:`~numpy.allclose` method uses the same definition but
        treats arrays containing infinities as close if the infinities are
        at the same places and all other entries are close.
        In our definition, arrays containing infinities can never be close
        which seems more appropriate in most cases.
 
     Parameters
     ----------
```

### Comparing `pymor-2022.2.1/src/pymor/tools/formatrepr.py` & `pymor-2023.1.0/src/pymor/tools/formatrepr.py`

 * *Files 2% similar despite different names*

```diff
@@ -39,17 +39,17 @@
                 pass
             vals.append(_recurse(val, max_width - len(key) - 4, verbosity))
         keys.append(key)
 
     if verbosity > 0 and (sum(len(k) + len(v) + 2 for k, v in zip(keys, vals)) + len(type(obj).__name__) > max_width
                           or any('\n' in v for v in vals)):
         args = [f'    {k}{indent_value(v, len(k) + 4)}' for k, v in zip(keys, vals)]
-        args = ",\n".join(args)
-        return f'''{type(obj).__name__}(
-{args})'''
+        args = ',\n'.join(args)
+        return f"""{type(obj).__name__}(
+{args})"""
     else:
         args = [f'{k}{v}' for k, v in zip(keys, vals)]
         return f'{type(obj).__name__}({", ".join(args)})'
 
 
 def _format_list_tuple(val, max_width, verbosity):
     brackets = '()' if type(val) is tuple else '[]'
```

### Comparing `pymor-2022.2.1/src/pymor/tools/formatsrc.py` & `pymor-2023.1.0/src/pymor/tools/formatsrc.py`

 * *Ordering differences only*

 * *Files 0% similar despite different names*

```diff
@@ -22,16 +22,16 @@
         terminal.
     """
     source = getsource(obj)
     if is_jupyter():
         return source
     try:
         from pygments import highlight
-        from pygments.lexers import PythonLexer
         from pygments.formatters import Terminal256Formatter
+        from pygments.lexers import PythonLexer
         return highlight(source, PythonLexer(), Terminal256Formatter())
     except ImportError:
         return source
 
 
 def print_source(obj):
     """Print source code of an object.
```

### Comparing `pymor-2022.2.1/src/pymor/tools/frozendict.py` & `pymor-2023.1.0/src/pymor/tools/frozendict.py`

 * *Files identical despite different names*

### Comparing `pymor-2022.2.1/src/pymor/tools/io/__init__.py` & `pymor-2023.1.0/src/pymor/tools/io/__init__.py`

 * *Files 1% similar despite different names*

```diff
@@ -3,17 +3,18 @@
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 import os
 import shutil
 import tempfile
 from contextlib import contextmanager
 
-from .matrices import load_matrix, save_matrix
 from pymor.tools.deprecated import Deprecated
 
+from .matrices import load_matrix, save_matrix
+
 
 @contextmanager
 def safe_temporary_filename(name=None, parent_dir=None):
     """Cross~platform safe equivalent of re-opening a NamedTemporaryFile.
 
     Creates an automatically cleaned up temporary directory with a single file therein.
 
@@ -46,11 +47,12 @@
 def file_owned_by_current_user(filename):
     try:
         return os.stat(filename).st_uid == os.getuid()
     except AttributeError:
         # this is actually less secure than above since getuser looks in env for username
         # a portable way to getuid might be in psutil
         from getpass import getuser
+
         import win32security
         f = win32security.GetFileSecurity(filename, win32security.OWNER_SECURITY_INFORMATION)
         username, _, _ = win32security.LookupAccountSid(None, f.GetSecurityDescriptorOwner())
         return username == getuser()
```

### Comparing `pymor-2022.2.1/src/pymor/tools/io/matrices.py` & `pymor-2023.1.0/src/pymor/tools/io/matrices.py`

 * *Files identical despite different names*

### Comparing `pymor-2022.2.1/src/pymor/tools/io/vtk.py` & `pymor-2023.1.0/src/pymor/tools/io/vtk.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,24 +1,25 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 from pymor.core.config import config
+
 config.require('VTKIO')
 
 
+from collections import OrderedDict
 from pathlib import Path
+from xml.etree.ElementTree import fromstring
 
 import meshio
-from xml.etree.ElementTree import fromstring
-from collections import OrderedDict
-from xmljson import BadgerFish
 from lxml import etree
+from xmljson import BadgerFish
 
-from pymor.core.exceptions import IOLibsMissing
+from pymor.core.exceptions import IOLibsMissingError
 
 
 def _read_collection(xml, metadata_key):
     collection = xml['VTKFile']['Collection']
     files = collection['DataSet']
     data = [(fl[f'@{metadata_key}'], _read_single(fl['@file'])) for fl in files]
     data.sort(key=lambda t: t[0])
@@ -60,15 +61,15 @@
             for action, element in parser.read_events():
                 if element.tag == 'VTKFile':
                     return element.get('type')
     return None
 
 
 def read_vtkfile(filename, metadata_key='timestep'):
-    """Try to read a given file into a Sequence of meshio.Mesh instances
+    """Try to read a given file into a Sequence of meshio.Mesh instances.
 
     Parameters
     ----------
     metadata_key
         Which metadata to extract and return alongside the meshio.Mesh instances.
 
     Returns
@@ -83,15 +84,15 @@
         path, xml = _get_collection_data(filename)
         with change_to_directory(path.parent):
             return _read_collection(xml, metadata_key=metadata_key)
     return [(None, _read_single(filename, vtk_type))]
 
 
 def write_vtk_collection(filename_base, meshes, metadata=None):
-    """Output grid-associated data in vtk format
+    """Output grid-associated data in vtk format.
 
     filename_base
         common component for output files in collection
     meshes
         Sequence of meshio.Mesh objects
     metadata
         dict of {key1: sequence1, key2: sequence2} where sequence must be of len(meshes) or len == 1
@@ -100,15 +101,15 @@
         defaults to { 'timestep': list(range(len(meshes))) }
 
     Returns
     -------
     full filename of saved file
     """
     if not config.HAVE_VTKIO:
-        raise IOLibsMissing()
+        raise IOLibsMissingError()
     from pyevtk.vtk import VtkGroup
 
     fn_tpl = '{}_{:08d}.vtu'
     metadata = metadata or {'timestep': list(range(len(meshes)))}
 
     def _meta(key, i):
         if key in metadata.keys():
```

### Comparing `pymor-2022.2.1/src/pymor/tools/mpi.py` & `pymor-2023.1.0/src/pymor/tools/mpi.py`

 * *Files 1% similar despite different names*

```diff
@@ -55,16 +55,17 @@
 
 from packaging.version import Version
 
 from pymor.core.config import config
 from pymor.core.defaults import defaults
 
 if config.HAVE_MPI:
-    import pymor.core.pickle
     from mpi4py import MPI
+
+    import pymor.core.pickle
     comm = MPI.COMM_WORLD
     rank = comm.Get_rank()
     size = comm.Get_size()
     finished = False
     MPI.pickle.__init__(pymor.core.pickle.dumps, pymor.core.pickle.loads, pymor.core.pickle.PROTOCOL)
 else:
     mpi4py_version = Version('0.0')
@@ -121,15 +122,15 @@
             if method == 'QUIT':
                 assert not _managed_objects
                 break
             else:
                 method(*args, **kwargs)
         except BaseException:
             import traceback
-            print(f"Caught exception on MPI rank {rank}:")
+            print(f'Caught exception on MPI rank {rank}:')
             traceback.print_exception(*sys.exc_info())
 
 
 def call(method, *args, **kwargs):
     """Execute method on all MPI ranks.
 
     Assuming :func:`event_loop` is running on all MPI ranks
```

### Comparing `pymor-2022.2.1/src/pymor/tools/plot.py` & `pymor-2023.1.0/src/pymor/tools/plot.py`

 * *Files 1% similar despite different names*

```diff
@@ -47,21 +47,21 @@
     Returns
     -------
     points
         A 1D |NumPy array| of sampled points.
     fvals
         A |NumPy array| of function values.
     """
-    plot = Adaptive(f, a, b, initial_num=initial_num, max_num=max_num,
-                    angle_tol=angle_tol, min_rel_dist=min_rel_dist,
-                    aspect_ratio=aspect_ratio, xscale=xscale, yscale=yscale)
+    plot = _Adaptive(f, a, b, initial_num=initial_num, max_num=max_num,
+                     angle_tol=angle_tol, min_rel_dist=min_rel_dist,
+                     aspect_ratio=aspect_ratio, xscale=xscale, yscale=yscale)
     return plot.compute()
 
 
-class Adaptive(BasicObject):
+class _Adaptive(BasicObject):
 
     def __init__(self, f, a, b, initial_num, max_num, angle_tol, min_rel_dist,
                  aspect_ratio, xscale, yscale):
         assert a < b
         assert initial_num >= 3
         assert max_num > initial_num
         assert 0 < angle_tol < 90
```

### Comparing `pymor-2022.2.1/src/pymor/tools/pprint.py` & `pymor-2023.1.0/src/pymor/tools/pprint.py`

 * *Ordering differences only*

 * *Files 15% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
-from pymor.core.defaults import defaults
-
 import numpy as np
 
+from pymor.core.defaults import defaults
+
 
 @defaults('compact_print')
 def format_array(array, compact_print=False):
     """Creates a formatted string representation of a |NumPy array|.
 
     Parameters
     ----------
```

### Comparing `pymor-2022.2.1/src/pymor/tools/random.py` & `pymor-2023.1.0/src/pymor/tools/random.py`

 * *Files 2% similar despite different names*

```diff
@@ -27,21 +27,21 @@
 correlated behavior in parallel or asynchronous code. :func:`get_rng` takes
 provisions to detect such situations and issue a warning. In such cases
 :func:`spawn_rng` needs to be called on the entry points of concurrent code
 paths to ensure the desired behavior. For an advanced example, see
 :mod:`pymor.algorithms.hapod`.
 """
 
-from contextvars import ContextVar
 import inspect
-
-from pymor.core.defaults import defaults
+from contextvars import ContextVar
 
 import numpy as np
 
+from pymor.core.defaults import defaults
+
 
 def get_rng():
     """Returns the current globally installed :class:`random number generator <RNG>`."""
     rng_state = _get_rng_state()
     rng_state[0] = True
     _rng_state.set([False] + rng_state[1:])
     return rng_state[1]
@@ -66,21 +66,21 @@
         seed_seq = np.random.SeedSequence(seed_seq)
     return RNG(seed_seq)
 
 
 class RNG(np.random.Generator):
     """Random number generator.
 
-    This class inherits from :class:`np.random.Generator` and inherits all its sampling
+    This class inherits from :class:`numpy.random.Generator` and inherits all its sampling
     methods. Further, the class can be used as a context manager, which upon entry
     installs the RNG as pyMOR's global RNG that is returned from :func:`get_rng`.
     When the context is left, the previous global RNG is installed again.
 
     When using a context manager is not feasible, i.e. in an interactive workflow, this
-    functionality can be accessed via the :meth:`~RNG.install` and :meth:`~RNG:uninstall`
+    functionality can be accessed via the :meth:`~RNG.install` and :meth:`~RNG.uninstall`
     methods.
 
     A new instance of this class should be obtained using :func:`new_rng`.
 
     Parameters
     ----------
     seed_seq
@@ -110,20 +110,20 @@
         return self
 
     def __exit__(self, exc_type, exc_value, exc_tb):
         self.uninstall()
 
 
 def get_seed_seq():
-    """Returns :class:`~np.random.SeedSequence` of the current global |RNG|.
+    """Returns :class:`~numpy.random.SeedSequence` of the current global |RNG|.
 
-    This function returns the :class:`~np.random.SeedSequence` with which pyMOR's
+    This function returns the :class:`~numpy.random.SeedSequence` with which pyMOR's
     currently installed global |RNG| has been initialized. The returned instance can
-    be used to deterministically create a new :class:`~np.random.SeedSequence` via
-    the :meth:`~np.random.SeedSequence.spawn` method, which then can be used to
+    be used to deterministically create a new :class:`~numpy.random.SeedSequence` via
+    the :meth:`~numpy.random.SeedSequence.spawn` method, which then can be used to
     initialize a new random generator in external library code or concurrent code
     paths.
     """
     return _get_rng_state()[2]
 
 
 def spawn_rng(f):
```

### Comparing `pymor-2022.2.1/src/pymor/tools/table.py` & `pymor-2023.1.0/src/pymor/tools/table.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,13 +1,14 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 from itertools import zip_longest
 from textwrap import wrap
+
 import numpy as np
 
 
 def format_table(rows, width='AUTO', title=None):
     rows = [[str(c) for c in r] for r in rows]
     if width == 'AUTO':
         try:
@@ -23,15 +24,15 @@
         min_width = max(column_widths)
         column_widths[largest_column] = max(min_width, width  - 2*(len(column_widths) - 1) - sum(column_widths))
     total_width = sum(column_widths) + 2*(len(column_widths) - 1)
 
     wrapped_rows = []
     for row in rows:
         cols = [wrap(c, width=cw) for c, cw in zip(row, column_widths)]
-        for r in zip_longest(*cols, fillvalue=""):
+        for r in zip_longest(*cols, fillvalue=''):
             wrapped_rows.append(r)
     rows = wrapped_rows
 
     rows.insert(1, ['-' * cw for cw in column_widths])
 
     if title is not None:
         separator = '=' * len(title)
```

### Comparing `pymor-2022.2.1/src/pymor/tools/timing.py` & `pymor-2023.1.0/src/pymor/tools/timing.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,14 +1,15 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
+import functools
 import time
+
 import numpy as np
-import functools
 
 from pymor.core.logger import getLogger
 
 
 class Timer:
     """Class for finding code runtime.
```

### Comparing `pymor-2022.2.1/src/pymor/tools/typer.py` & `pymor-2023.1.0/src/pymor/tools/typer.py`

 * *Files 1% similar despite different names*

```diff
@@ -3,15 +3,15 @@
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 from enum import Enum
 
 
 def Choices(choices):
-    """Multipe-choice options for typer.
+    """Multiple-choice options for typer.
 
     This is a convenicence function that creates string Enums to be
     used as the type of command-line arguments that can take a fixed set
     of values. For example, the command::
 
         @app.command()
         def main(arg: Choices('value1 value2')):
```

### Comparing `pymor-2022.2.1/src/pymor/vectorarrays/block.py` & `pymor-2023.1.0/src/pymor/vectorarrays/block.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,13 +1,14 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 from functools import reduce
 from numbers import Number
+
 import numpy as np
 
 from pymor.core.base import classinstancemethod
 from pymor.vectorarrays.interface import VectorArray, VectorArrayImpl, VectorSpace
 
 
 class BlockVectorArrayImpl(VectorArrayImpl):
@@ -228,21 +229,21 @@
         assert reserve >= 0
         return BlockVectorArray(
             self,
             BlockVectorArrayImpl([subspace.zeros(count=count, reserve=reserve) for subspace in self.subspaces], self)
         )
 
     @classinstancemethod
-    def make_array(cls, obj):
+    def make_array(cls, obj):  # noqa: N805
         assert len(obj) > 0
         return cls(tuple(o.space for o in obj)).make_array(obj)
 
     @make_array.instancemethod
     def make_array(self, obj):
-        """:noindex:"""
+        """:noindex:"""  # noqa: D400
         assert len(obj) == len(self.subspaces)
         assert all(block in subspace for block, subspace in zip(obj, self.subspaces))
         return BlockVectorArray(self, BlockVectorArrayImpl(obj, self))
 
     def make_block_diagonal_array(self, obj):
         assert len(obj) == len(self.subspaces)
         assert all(block in subspace for block, subspace in zip(obj, self.subspaces))
```

### Comparing `pymor-2022.2.1/src/pymor/vectorarrays/constructions.py` & `pymor-2023.1.0/src/pymor/vectorarrays/constructions.py`

 * *Files identical despite different names*

### Comparing `pymor-2022.2.1/src/pymor/vectorarrays/interface.py` & `pymor-2023.1.0/src/pymor/vectorarrays/interface.py`

 * *Files 1% similar despite different names*

```diff
@@ -845,15 +845,15 @@
         The exact signature of this method depends on the wrapped
         solver backend.
         """
         pass
 
     @abstractmethod
     def zeros(self, count=1, reserve=0):
-        """Create a |VectorArray| of null vectors
+        """Create a |VectorArray| of null vectors.
 
         Parameters
         ----------
         count
             The number of vectors.
         reserve
             Hint for the backend to which length the array will grow.
@@ -930,15 +930,15 @@
         reserve
             Hint for the backend to which length the array will grow.
         """
         values = _create_random_values((count, self.dim), distribution, **kwargs)
         return self.from_numpy(values)
 
     def empty(self, reserve=0):
-        """Create an empty |VectorArray|
+        """Create an empty |VectorArray|.
 
         This is a shorthand for `self.zeros(0, reserve)`.
 
         Parameters
         ----------
         reserve
             Hint for the backend to which length the array will grow.
@@ -946,15 +946,15 @@
         Returns
         -------
         An empty |VectorArray|.
         """
         return self.zeros(0, reserve=reserve)
 
     def from_numpy(self, data, ensure_copy=False):
-        """Create a |VectorArray| from a |NumPy array|
+        """Create a |VectorArray| from a |NumPy array|.
 
         Note that this method will not be supported by all vector
         space implementations.
 
         Parameters
         ----------
         data
@@ -1009,17 +1009,18 @@
 
 class VectorArrayImpl(BasicObject):
     """Implementation of a |VectorArray|.
 
     The |VectorArray| base class defers all calls to interface methods to an
     internal `impl` object of this type. Indexing, error checking or non-standard
     inner products are handled by |VectorArray|. Possible indices are passed
-    to the methods of :class:`VectorArrayImpl` as `ind`, `oind` or `xind`
-    parameters. These can either be `None`, in case the array has not been indexed,
-    a `slice` object, or a Python list of non-negative numbers.
+    to the methods of :class:`~pymor.vectorarrays.interface.VectorArrayImpl` as
+    `ind`, `oind` or `xind` parameters. These can either be `None`, in case the
+    array has not been indexed, a `slice` object, or a Python list of
+    non-negative numbers.
     """
 
     @abstractmethod
     def __len__(self):
         pass
 
     @abstractmethod
```

### Comparing `pymor-2022.2.1/src/pymor/vectorarrays/list.py` & `pymor-2023.1.0/src/pymor/vectorarrays/list.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,14 +1,14 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 import numpy as np
 
-from pymor.core.base import BasicObject, abstractmethod, abstractclassmethod, classinstancemethod
+from pymor.core.base import BasicObject, abstractclassmethod, abstractmethod, classinstancemethod
 from pymor.vectorarrays.interface import VectorArray, VectorArrayImpl, VectorSpace, _create_random_values
 
 
 class Vector(BasicObject):
     """Interface for vectors used in conjunction with |ListVectorArray|.
 
     This interface must be satisfied by the individual entries of the
@@ -96,15 +96,15 @@
     def conj(self):
         return self.copy()
 
 
 class CopyOnWriteVector(Vector):
 
     @abstractclassmethod
-    def from_instance(cls, instance):
+    def from_instance(cls, instance):  # noqa: N805
         pass
 
     @abstractmethod
     def _copy_data(self):
         pass
 
     @abstractmethod
@@ -430,14 +430,16 @@
 
     def pairwise_inner(self, other, ind, oind):
         return np.array([a.inner(b) for a, b in zip(self._indexed(ind), other._indexed(oind))])
 
     def gramian(self, ind):
         self_list = self._indexed(ind)
         l = len(self_list)
+        if l == 0:
+            return np.zeros((0,0))
         R = [[0.] * l for _ in range(l)]
         for i in range(l):
             for j in range(i, l):
                 R[i][j] = self_list[i].inner(self_list[j])
                 if i == j:
                     R[i][j] = R[i][j].real
                 else:
@@ -571,34 +573,34 @@
         return ListVectorArray(
             self,
             ListVectorArrayImpl([self.random_vector(distribution=distribution, **kwargs)
                                  for _ in range(count)], self)
         )
 
     @classinstancemethod
-    def make_array(cls, obj, id=None):
+    def make_array(cls, obj, id=None):  # noqa: N805
         if len(obj) == 0:
             raise NotImplementedError
         return cls.space_from_vector_obj(obj[0], id=id).make_array(obj)
 
     @make_array.instancemethod
     def make_array(self, obj):
-        """:noindex:"""
+        """:noindex:"""  # noqa: D400
         return ListVectorArray(
             self,
             ListVectorArrayImpl([v if isinstance(v, self.vector_type) else self.make_vector(v) for v in obj], self)
         )
 
     @classinstancemethod
-    def from_numpy(cls, data, id=None, ensure_copy=False):
+    def from_numpy(cls, data, id=None, ensure_copy=False):  # noqa: N805
         return cls.space_from_dim(data.shape[1], id=id).from_numpy(data, ensure_copy=ensure_copy)
 
     @from_numpy.instancemethod
     def from_numpy(self, data, ensure_copy=False):
-        """:noindex:"""
+        """:noindex:"""  # noqa: D400
         return ListVectorArray(
             self, ListVectorArrayImpl([self.vector_from_numpy(v, ensure_copy=ensure_copy) for v in data], self)
         )
 
 
 class ComplexifiedListVectorSpace(ListVectorSpace):
```

### Comparing `pymor-2022.2.1/src/pymor/vectorarrays/mpi.py` & `pymor-2023.1.0/src/pymor/vectorarrays/mpi.py`

 * *Files identical despite different names*

### Comparing `pymor-2022.2.1/src/pymor/vectorarrays/numpy.py` & `pymor-2023.1.0/src/pymor/vectorarrays/numpy.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,12 +1,12 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
-from numbers import Number
+from numbers import Integral, Number
 
 import numpy as np
 from scipy.sparse import issparse
 
 from pymor.core.base import classinstancemethod
 from pymor.vectorarrays.interface import VectorArray, VectorArrayImpl, VectorSpace, _create_random_values
 
@@ -213,15 +213,16 @@
     dim
         The dimension of the vectors contained in the space.
     id
         See :attr:`~pymor.vectorarrays.interface.VectorSpace.id`.
     """
 
     def __init__(self, dim, id=None):
-        self.dim = dim
+        assert isinstance(dim, Integral)
+        self.dim = int(dim)
         self.id = id
 
     def __eq__(self, other):
         return type(other) is type(self) and self.dim == other.dim and self.id == other.id
 
     def __hash__(self):
         return hash(self.dim) + hash(self.id)
@@ -240,33 +241,33 @@
         assert count >= 0
         assert reserve >= 0
         va = self.zeros(count, reserve)
         va.impl._array[:count] = _create_random_values((count, self.dim), distribution, **kwargs)
         return va
 
     @classinstancemethod
-    def make_array(cls, obj, id=None):
+    def make_array(cls, obj, id=None):  # noqa N805
         return cls._array_factory(obj, id=id)
 
     @make_array.instancemethod
     def make_array(self, obj):
-        """:noindex:"""
+        """:noindex:"""  # noqa: D400
         return self._array_factory(obj, space=self)
 
     @classinstancemethod
-    def from_numpy(cls, data, id=None, ensure_copy=False):
+    def from_numpy(cls, data, id=None, ensure_copy=False):  # noqa N805
         return cls._array_factory(data.copy() if ensure_copy else data, id=id)
 
     @from_numpy.instancemethod
     def from_numpy(self, data, ensure_copy=False):
-        """:noindex:"""
+        """:noindex:"""  # noqa: D400
         return self._array_factory(data.copy() if ensure_copy else data, space=self)
 
     @classinstancemethod
-    def from_file(cls, path, key=None, single_vector=False, transpose=False, id=None):
+    def from_file(cls, path, key=None, single_vector=False, transpose=False, id=None):  # noqa N805
         assert not (single_vector and transpose)
         from pymor.tools.io import load_matrix
         array = load_matrix(path, key=key)
         assert isinstance(array, np.ndarray)
         assert array.ndim <= 2
         if array.ndim == 1:
             array = array.reshape((1, -1))
@@ -275,15 +276,15 @@
             array = array.reshape((1, -1))
         if transpose:
             array = array.T
         return cls.make_array(array, id=id)
 
     @from_file.instancemethod
     def from_file(self, path, key=None, single_vector=False, transpose=False):
-        """:noindex:"""
+        """:noindex:"""  # noqa: D400
         return type(self).from_file(path, key=key, single_vector=single_vector, transpose=transpose, id=self.id)
 
     @classmethod
     def _array_factory(cls, array, space=None, id=None):
         if type(array) is np.ndarray:
             pass
         elif issparse(array):
```

### Comparing `pymor-2022.2.1/src/pymordemos/analyze_pickle.py` & `pymor-2023.1.0/src/pymordemos/analyze_pickle.py`

 * *Files 1% similar despite different names*

```diff
@@ -2,30 +2,30 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 import sys
 import time
 
-import numpy as np
 import matplotlib.pyplot as plt
+import numpy as np
 from typer import Argument, Option, Typer
 
 from pymor.core.pickle import load
 
-app = Typer(help='''
+app = Typer(help="""
 This demo loads a pickled reduced model, solves for random
 parameters, estimates the reduction errors and then visualizes these
 estimates. If the detailed model and the reductor are
 also provided, the estimated error is visualized in comparison to
 the real reduction error.
 
 The needed data files are created by the thermal block demo, by
 setting the '--pickle' option.
-'''[1:])
+"""[1:])
 
 REDUCED_DATA = Argument(..., help='File containing the pickled reduced model.')
 SAMPLES = Argument(..., min=1, help='Number of parameter samples to test with. ')
 ERROR_NORM = Option(None, help='Name of norm in which to compute the errors.')
 
 
 @app.command()
```

### Comparing `pymor-2022.2.1/src/pymordemos/burgers.py` & `pymor-2023.1.0/src/pymordemos/burgers.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,22 +1,22 @@
 #!/usr/bin/env python
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 """Burgers demo."""
 
-import sys
 import math
+import sys
 import time
 
 from typer import Argument, Option, run
 
 from pymor.analyticalproblems.burgers import burgers_problem_2d
-from pymor.discretizers.builtin import discretize_instationary_fv, RectGrid, TriaGrid
+from pymor.discretizers.builtin import RectGrid, TriaGrid, discretize_instationary_fv
 from pymor.tools.typer import Choices
 
 
 def main(
     exp: float = Argument(..., help='Exponent'),
 
     grid: int = Option(60, help='Use grid with (2*NI)*NI elements.'),
```

### Comparing `pymor-2022.2.1/src/pymordemos/burgers_dmd.py` & `pymor-2023.1.0/src/pymordemos/burgers_dmd.py`

 * *Files 2% similar despite different names*

```diff
@@ -6,27 +6,27 @@
 """Burgers demo with different applications of Dynamic Mode Decomposition."""
 
 import sys
 import time
 
 import matplotlib.pyplot as plt
 import numpy as np
+from typer import Argument, Option, run
 
 from pymor.algorithms.dmd import dmd
 from pymor.analyticalproblems.burgers import burgers_problem
 from pymor.discretizers.builtin import discretize_instationary_fv
 from pymor.tools.typer import Choices
-from typer import Argument, Option, run
 
 
 def main(
         exp: float = Argument(..., help='Exponent'),
 
         atol: float = Option(None, help='Absolute tolerance'),
-        continuous_time: bool = Option(False, help='Show continous time system eigenvalues.'),
+        continuous_time: bool = Option(False, help='Show continuous time system eigenvalues.'),
         grid: int = Option(100, help='Use grid with this number of elements.'),
         initial_data: Choices('sin bump') = Option('sin', help='Select the initial data.'),
         modes: int = Option(None, help='Number of DMD modes'),
         nt: int = Option(1000, help='Number of time steps.'),
         periodic: bool = Option(True,
                                 help='If not, solve with dirichlet boundary conditions on left and bottom boundary.'),
         rtol: float = Option(None, help='Relative tolerance'),
```

### Comparing `pymor-2022.2.1/src/pymordemos/burgers_ei.py` & `pymor-2023.1.0/src/pymordemos/burgers_ei.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,23 +1,23 @@
 #!/usr/bin/env python
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
-import sys
 import math
+import sys
 import time
 
 import numpy as np
 from typer import Argument, Option, run
 
-from pymor.algorithms.greedy import rb_greedy
 from pymor.algorithms.ei import interpolate_operators
+from pymor.algorithms.greedy import rb_greedy
 from pymor.analyticalproblems.burgers import burgers_problem_2d
-from pymor.discretizers.builtin import discretize_instationary_fv, RectGrid, TriaGrid
+from pymor.discretizers.builtin import RectGrid, TriaGrid, discretize_instationary_fv
 from pymor.parallel.default import new_parallel_pool
 from pymor.reductors.basic import InstationaryRBReductor
 from pymor.tools.typer import Choices
 
 
 def main(
     exp_min: float = Argument(..., help='Minimal exponent'),
@@ -69,16 +69,16 @@
         num_flux=num_flux.value,
         lxf_lambda=lxf_lambda,
         nt=nt
     )
 
     if cache_region != 'none':
         # building a cache_id is only needed for persistent CacheRegions
-        cache_id = (f"pymordemos.burgers_ei {vx} {vy} {initial_data}"
-                    f"{periodic} {grid} {grid_type} {num_flux} {lxf_lambda} {nt}")
+        cache_id = (f'pymordemos.burgers_ei {vx} {vy} {initial_data}'
+                    f'{periodic} {grid} {grid_type} {num_flux} {lxf_lambda} {nt}')
         fom.enable_caching(cache_region.value, cache_id)
 
     print(fom.operator.grid)
 
     print(f'The parameters are {fom.parameters}')
 
     if plot_solutions:
@@ -178,15 +178,15 @@
     errs = errs.astype(np.float64)
 
     l2_err_max = errs[-1, -1]
     mumax = err_mus[-1, -1]
     toc = time.perf_counter()
     t_est = toc - tic
 
-    print('''
+    print("""
     *** RESULTS ***
 
     Problem:
        parameter range:                    ({exp_min}, {exp_max})
        h:                                  sqrt(2)/{grid}
        grid-type:                          {grid_type}
        initial-data:                       {initial_data}
@@ -205,20 +205,20 @@
        actual basis size:                  {real_rb_size}
        elapsed time:                       {greedy_data[time]}
 
     Stochastic error estimation:
        number of samples:                  {test}
        maximal L2-error:                   {l2_err_max}  (mu = {mumax})
        elapsed time:                       {t_est}
-    '''.format(**locals()))
+    """.format(**locals()))
 
     sys.stdout.flush()
     if plot_error_landscape:
         import matplotlib.pyplot as plt
-        import mpl_toolkits.mplot3d             # NOQA
+        import mpl_toolkits.mplot3d  # NOQA
         fig = plt.figure()
         ax = fig.add_subplot(111, projection='3d')
         # rescale the errors since matplotlib does not support logarithmic scales on 3d plots
         # https://github.com/matplotlib/matplotlib/issues/209
         surf = ax.plot_surface(M_grid, N_grid, np.log(np.minimum(errs, 1)) / np.log(10),
                                rstride=1, cstride=1, cmap='jet')
         plt.show()
```

### Comparing `pymor-2022.2.1/src/pymordemos/dd_parametric_heat.py` & `pymor-2023.1.0/src/pymordemos/dd_parametric_heat.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,16 +1,16 @@
 #!/usr/bin/env python
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
-import numpy as np
-import scipy.linalg as spla
 import matplotlib.colors as cm
 import matplotlib.pyplot as plt
+import numpy as np
+import scipy.linalg as spla
 from typer import Argument, run
 
 from pymor.analyticalproblems.domaindescriptions import LineDomain
 from pymor.analyticalproblems.elliptic import StationaryProblem
 from pymor.analyticalproblems.functions import ConstantFunction, ExpressionFunction, LincombFunction
 from pymor.analyticalproblems.instationary import InstationaryProblem
 from pymor.core.logger import set_log_levels
@@ -103,9 +103,9 @@
 
     ss = np.logspace(-1, 4, n)
     pp = np.linspace(10, 100, m)
 
     run_mor_method_dd_param(lti, ss, pp, PAAAReductor, 'p-AAA')
 
 
-if __name__ == "__main__":
+if __name__ == '__main__':
     run(main)
```

### Comparing `pymor-2022.2.1/src/pymordemos/delay.py` & `pymor-2023.1.0/src/pymordemos/delay.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,14 +1,14 @@
 #!/usr/bin/env python
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
-import numpy as np
 import matplotlib.pyplot as plt
+import numpy as np
 from typer import Argument, run
 
 from pymor.models.transfer_function import TransferFunction
 from pymor.reductors.h2 import TFIRKAReductor
 from pymordemos.heat import fom_properties, run_mor_method
 
 
@@ -28,18 +28,16 @@
 
     def dH(s):
         return np.array([[-(tau * s + tau + 1) * np.exp(-s) / (tau * s + 1) ** 2]])
 
     tf = TransferFunction(1, 1, H, dH)
 
     # Bode plot
-    fig = plt.figure(constrained_layout=True)
     w = (1e-1, 1e3)
-    fom_properties(tf, w, fig_bode=fig)
-    plt.show()
+    fom_properties(tf, w)
 
     # Transfer function IRKA (TF-IRKA)
     run_mor_method(tf, w, TFIRKAReductor(tf), 'TF-IRKA', r, maxit=1000)
 
 
 if __name__ == '__main__':
     run(main)
```

### Comparing `pymor-2022.2.1/src/pymordemos/dmd_identification.py` & `pymor-2023.1.0/src/pymordemos/dmd_identification.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,15 +1,14 @@
 #!/usr/bin/env python
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 import numpy as np
-
-from typer import run, Option
+from typer import Option, run
 
 from pymor.algorithms.to_matrix import to_matrix
 from pymor.basic import *
 
 
 def main(
         n: int = Option(4, help='Dimension of the state.'),
```

### Comparing `pymor-2022.2.1/src/pymordemos/elliptic.py` & `pymor-2023.1.0/src/pymordemos/elliptic.py`

 * *Files 2% similar despite different names*

```diff
@@ -4,16 +4,16 @@
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 import numpy as np
 from typer import Argument, Option, run
 
 from pymor.analyticalproblems.domaindescriptions import RectDomain
 from pymor.analyticalproblems.elliptic import StationaryProblem
-from pymor.analyticalproblems.functions import ExpressionFunction, ConstantFunction
-from pymor.discretizers.builtin import discretize_stationary_cg, discretize_stationary_fv, RectGrid, TriaGrid
+from pymor.analyticalproblems.functions import ConstantFunction, ExpressionFunction
+from pymor.discretizers.builtin import RectGrid, TriaGrid, discretize_stationary_cg, discretize_stationary_fv
 
 
 def main(
     problem_number: int = Argument(..., min=0, max=1, help='Selects the problem to solve [0 or 1].'),
     dirichlet_number: int = Argument(..., min=0, max=2, help='Selects the Dirichlet data function [0 to 2].'),
     neumann_number: int = Argument(..., min=0, max=2, help='Selects the Neumann data function.'),
     neumann_count: int = Argument(
@@ -33,16 +33,16 @@
     rhss = [ExpressionFunction('10', 2),
             ExpressionFunction('(x[0] - 0.5) ** 2 * 1000', 2)]
     dirichlets = [ExpressionFunction('0', 2),
                   ExpressionFunction('1', 2),
                   ExpressionFunction('x[0]', 2)]
     neumanns = [None,
                 ConstantFunction(3., dim_domain=2),
-                ExpressionFunction('50*(0.1 <= x[1]) * (x[1] <= 0.2)'
-                                   '+50*(0.8 <= x[1]) * (x[1] <= 0.9)', 2)]
+                ExpressionFunction('50*(0.1 <= x[1] <= 0.2)'
+                                   '+50*(0.8 <= x[1] <= 0.9)', 2)]
     domains = [RectDomain(),
                RectDomain(right='neumann'),
                RectDomain(right='neumann', top='neumann'),
                RectDomain(right='neumann', top='neumann', bottom='neumann')]
 
     rhs = rhss[problem_number]
     dirichlet = dirichlets[dirichlet_number]
```

### Comparing `pymor-2022.2.1/src/pymordemos/elliptic2.py` & `pymor-2023.1.0/src/pymordemos/elliptic2.py`

 * *Files 2% similar despite different names*

```diff
@@ -4,34 +4,34 @@
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 import numpy as np
 from typer import Argument, Option, run
 
 from pymor.analyticalproblems.domaindescriptions import RectDomain
 from pymor.analyticalproblems.elliptic import StationaryProblem
-from pymor.analyticalproblems.functions import ExpressionFunction, LincombFunction, ConstantFunction
+from pymor.analyticalproblems.functions import ConstantFunction, ExpressionFunction, LincombFunction
 from pymor.discretizers.builtin import discretize_stationary_cg, discretize_stationary_fv
 from pymor.parameters.functionals import ProjectionParameterFunctional
 
 
 def main(
     problem_number: int = Argument(..., min=0, max=1, help='Selects the problem to solve [0 or 1].'),
     n: int = Argument(..., help='Triangle count per direction'),
     norm: str = Argument(
         ...,
-        help="h1: compute the h1-norm of the last snapshot.\n\n"
-             "l2: compute the l2-norm of the last snapshot.\n\n"
-             "k: compute the energy norm of the last snapshot, where the energy-product"
+        help='h1: compute the h1-norm of the last snapshot.\n\n'
+             'l2: compute the l2-norm of the last snapshot.\n\n'
+             'k: compute the energy norm of the last snapshot, where the energy-product'
              "is constructed with a parameter {'mu': k}."
     ),
 
     fv: bool = Option(False, help='Use finite volume discretization instead of finite elements.'),
 ):
     """Solves the Poisson equation in 2D using pyMOR's builtin discreization toolkit."""
-    norm = float(norm) if not norm.lower() in ('h1', 'l2') else norm.lower()
+    norm = float(norm) if norm.lower() not in ('h1', 'l2') else norm.lower()
 
     rhss = [ExpressionFunction('10', 2),
             LincombFunction(
                 [ExpressionFunction('10', 2), ConstantFunction(1., 2)],
                 [ProjectionParameterFunctional('mu'), 0.1])]
 
     dirichlets = [ExpressionFunction('0', 2),
```

### Comparing `pymor-2022.2.1/src/pymordemos/elliptic_oned.py` & `pymor-2023.1.0/src/pymordemos/elliptic_oned.py`

 * *Files 0% similar despite different names*

```diff
@@ -3,15 +3,15 @@
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 from typer import Argument, Option, run
 
 from pymor.analyticalproblems.domaindescriptions import LineDomain
 from pymor.analyticalproblems.elliptic import StationaryProblem
-from pymor.analyticalproblems.functions import ExpressionFunction, ConstantFunction, LincombFunction
+from pymor.analyticalproblems.functions import ConstantFunction, ExpressionFunction, LincombFunction
 from pymor.discretizers.builtin import discretize_stationary_cg, discretize_stationary_fv
 from pymor.parameters.functionals import ProjectionParameterFunctional
 
 
 def main(
     problem_number: int = Argument(..., min=0, max=1, help='Selects the problem to solve [0 or 1].'),
     n: int = Argument(..., help='Grid interval count.'),
```

### Comparing `pymor-2022.2.1/src/pymordemos/elliptic_unstructured.py` & `pymor-2023.1.0/src/pymordemos/elliptic_unstructured.py`

 * *Files identical despite different names*

### Comparing `pymor-2022.2.1/src/pymordemos/era.py` & `pymor-2023.1.0/src/pymordemos/era.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 #!/usr/bin/env python
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
-import numpy as np
 import matplotlib.pyplot as plt
-from typer import run
+import numpy as np
+from typer import Argument, run
 
 from pymor.core.logger import set_log_levels
 from pymor.models.iosys import LTIModel
 from pymor.reductors.bt import BTReductor
 from pymor.reductors.era import ERAReductor
 from pymor.tools.random import get_rng, new_rng
 
@@ -53,32 +53,34 @@
         The |LTIModel| for which the Markov parameters are computed.
     n
         The number of Markov parameters that are calculated.
 
     Returns
     -------
     mp
-        |NumpyArray| of shape (n, sys.dim_ouputs, sys.dim_inputs).
+        |NumPy array| of shape `(n, sys.dim_output, sys.dim_input)`.
     """
     mp = np.zeros((n, sys.dim_output, sys.dim_input))
     A, B, C, *_ = sys.to_matrices()
     x = B
     for i in range(n):
         mp[i] = np.squeeze(C @ x)
         x = A @ x
     return mp
 
 
-def main():
+def main(
+        n: int = Argument(10, help='Order of the full model.')
+):
     set_log_levels({'pymor.algorithms.gram_schmidt.gram_schmidt': 'WARNING'})
 
     sampling_time = 0.1
     w = np.geomspace(1e-2, 1, 100) * np.pi
     with new_rng(0):
-        fom = example_system(10, sampling_time=sampling_time)
+        fom = example_system(n, sampling_time=sampling_time)
 
     mp = compute_markov_parameters(fom, n=100)
 
     era = ERAReductor(mp, sampling_time=sampling_time, feedthrough=fom.D)
     bt = BTReductor(fom)
 
     era_rom = era.reduce(4)
```

### Comparing `pymor-2022.2.1/src/pymordemos/fenics_nonlinear.py` & `pymor-2023.1.0/src/pymordemos/fenics_nonlinear.py`

 * *Files 3% similar despite different names*

```diff
@@ -11,15 +11,15 @@
 def main(
     dim: int = Argument(..., help='Spatial dimension of the problem.'),
     n: int = Argument(..., help='Number of mesh intervals per spatial dimension.'),
     order: int = Argument(..., help='Finite element order.'),
 ):
     """Reduces a FEniCS-based nonlinear diffusion problem using POD/DEIM."""
     from pymor.tools import mpi
-    config.require("FENICS")
+    config.require('FENICS')
 
     if mpi.parallel:
         from pymor.models.mpi import mpi_wrap_model
         local_models = mpi.call(mpi.function_call_manage, discretize, dim, n, order)
         fom = mpi_wrap_model(local_models, use_with=True, pickle_local_spaces=False)
     else:
         fom = discretize(dim, n, order)
@@ -48,14 +48,15 @@
     reductor = StationaryRBReductor(fom_ei, rb)
     rom = reductor.reduce()
     # the reductor currently removes all solver_options so we need to add them again
     rom = rom.with_(operator=rom.operator.with_(solver_options=fom.operator.solver_options))
 
     # ### ROM validation
     import time
+
     import numpy as np
 
     # ensure that FFC is not called during runtime measurements
     rom.solve(1)
 
     errs = []
     speedups = []
@@ -82,35 +83,35 @@
     if dim == 2:
         mesh = df.UnitSquareMesh(n, n)
     elif dim == 3:
         mesh = df.UnitCubeMesh(n, n, n)
     else:
         raise NotImplementedError
 
-    V = df.FunctionSpace(mesh, "CG", order)
+    V = df.FunctionSpace(mesh, 'CG', order)
 
     g = df.Constant(1.0)
     c = df.Constant(1.)
 
     class DirichletBoundary(df.SubDomain):
         def inside(self, x, on_boundary):
             return abs(x[0] - 1.0) < df.DOLFIN_EPS and on_boundary
     db = DirichletBoundary()
     bc = df.DirichletBC(V, g, db)
 
     u = df.Function(V)
     v = df.TestFunction(V)
-    f = df.Expression("x[0]*sin(x[1])", degree=2)
+    f = df.Expression('x[0]*sin(x[1])', degree=2)
     F = df.inner((1 + c*u**2)*df.grad(u), df.grad(v))*df.dx - f*v*df.dx
 
     df.solve(F == 0, u, bc,
-             solver_parameters={"newton_solver": {"relative_tolerance": 1e-6}})
+             solver_parameters={'newton_solver': {'relative_tolerance': 1e-6}})
 
     # ### pyMOR wrapping
-    from pymor.bindings.fenics import FenicsVectorSpace, FenicsOperator, FenicsVisualizer
+    from pymor.bindings.fenics import FenicsOperator, FenicsVectorSpace, FenicsVisualizer
     from pymor.models.basic import StationaryModel
     from pymor.operators.constructions import VectorOperator
 
     space = FenicsVectorSpace(V)
     op = FenicsOperator(F, space, space, u, (bc,),
                         parameter_setter=lambda mu: c.assign(mu['c'].item()),
                         parameters={'c': 1},
```

### Comparing `pymor-2022.2.1/src/pymordemos/function_ei.py` & `pymor-2023.1.0/src/pymordemos/function_ei.py`

 * *Files 4% similar despite different names*

```diff
@@ -4,17 +4,17 @@
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 import sys
 
 import numpy as np
 from typer import Argument, Option, run
 
-from pymor.algorithms.greedy import rb_greedy
 from pymor.algorithms.ei import interpolate_function
 from pymor.algorithms.error import reduction_error_analysis
+from pymor.algorithms.greedy import rb_greedy
 from pymor.analyticalproblems.domaindescriptions import RectDomain
 from pymor.analyticalproblems.elliptic import StationaryProblem
 from pymor.analyticalproblems.functions import ConstantFunction, ExpressionFunction
 from pymor.discretizers.builtin import discretize_stationary_cg
 from pymor.parameters.functionals import ExpressionParameterFunctional
 from pymor.reductors.coercive import CoerciveRBReductor
 
@@ -94,16 +94,16 @@
     rom = greedy_data['rom']
 
     results = reduction_error_analysis(rom, fom=fom, reductor=reductor, error_estimator=True,
                                        error_norms=[fom.h1_0_semi_norm], condition=True,
                                        test_mus=problem.parameter_space.sample_randomly(test),
                                        plot=True)
     print(results['summary'])
-    import matplotlib.pyplot
-    matplotlib.pyplot.show()
+    import matplotlib.pyplot as plt
+    plt.show()
 
     mumax = results['max_error_mus'][0, -1]
     U = fom.solve(mumax)
     U_RB = reductor.reconstruct(rom.solve(mumax))
     fom.visualize((U, U_RB, U - U_RB), legend=('Detailed Solution', 'Reduced Solution', 'Error'),
                   separate_colorbars=True, block=True)
```

### Comparing `pymor-2022.2.1/src/pymordemos/hapod.py` & `pymor-2023.1.0/src/pymordemos/hapod.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,22 +1,22 @@
 #!/usr/bin/env python
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
-from concurrent.futures import ThreadPoolExecutor, ProcessPoolExecutor
 import time
+from concurrent.futures import ProcessPoolExecutor, ThreadPoolExecutor
 
 import numpy as np
 from typer import Argument, Option, run
 
-from pymor.analyticalproblems.burgers import burgers_problem_2d
-from pymor.discretizers.builtin import discretize_instationary_fv, RectGrid
 from pymor.algorithms.hapod import dist_vectorarray_hapod, inc_vectorarray_hapod
 from pymor.algorithms.pod import pod
+from pymor.analyticalproblems.burgers import burgers_problem_2d
+from pymor.discretizers.builtin import RectGrid, discretize_instationary_fv
 from pymor.tools.table import format_table
 
 
 def main(
     tol: float = Argument(..., help='Prescribed mean l2 approximation error.'),
     dist: int = Argument(..., help='Number of slices for distributed HAPOD.'),
     inc: int = Argument(..., help='Number of steps for incremental HAPOD.'),
```

### Comparing `pymor-2022.2.1/src/pymordemos/heat.py` & `pymor-2023.1.0/src/pymordemos/heat.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,92 +1,161 @@
 #!/usr/bin/env python
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
-import numpy as np
 import matplotlib.pyplot as plt
+import numpy as np
 from typer import Argument, run
 
-
 from pymor.algorithms.lradi import lyap_lrcf_solver_options
+from pymor.algorithms.timestepping import ImplicitEulerTimeStepper
 from pymor.analyticalproblems.domaindescriptions import RectDomain
 from pymor.analyticalproblems.elliptic import StationaryProblem
 from pymor.analyticalproblems.functions import ConstantFunction, ExpressionFunction
 from pymor.analyticalproblems.instationary import InstationaryProblem
 from pymor.core.config import config
 from pymor.core.logger import set_log_levels
 from pymor.discretizers.builtin import discretize_instationary_cg
-from pymor.models.iosys import LTIModel
-from pymor.reductors.bt import BTReductor, LQGBTReductor, BRBTReductor
-from pymor.reductors.h2 import IRKAReductor, TSIAReductor, OneSidedIRKAReductor
+from pymor.models.iosys import LTIModel, SecondOrderModel
+from pymor.reductors.bt import BRBTReductor, BTReductor, LQGBTReductor
+from pymor.reductors.h2 import IRKAReductor, OneSidedIRKAReductor, TSIAReductor
 from pymor.reductors.mt import MTReductor
 
 
-def fom_properties(fom, w, stable=True, fig_poles=None, fig_bode=None):
+def fom_properties(fom, w, stable_lti=True):
     """Show properties of the full-order model.
 
     Parameters
     ----------
     fom
         The full-order `Model` from :mod:`~pymor.models.iosys` or a |TransferFunction|.
     w
         Array of frequencies.
-    stable
-        Whether the FOM is stable.
-    fig_poles
-        Matplotlib figure for system poles.
-    fig_bode
-        Matplotlib figure for Bode plot.
+    stable_lti
+        Whether the FOM is stable (assuming it is an |LTIModel|).
     """
     from pymor.models.transfer_function import TransferFunction
     if not isinstance(fom, TransferFunction):
         print(f'order of the model = {fom.order}')
     print(f'number of inputs   = {fom.dim_input}')
     print(f'number of outputs  = {fom.dim_output}')
 
     # System norms
-    if stable:
+    if stable_lti:
         print(f'FOM H_2-norm:    {fom.h2_norm():e}')
         if not isinstance(fom, TransferFunction):
             if config.HAVE_SLYCOT:
                 print(f'FOM H_inf-norm:  {fom.hinf_norm():e}')
             else:
                 print('Skipped H_inf-norm calculation due to missing slycot.')
             print(f'FOM Hankel-norm: {fom.hankel_norm():e}')
     else:
         print(f'FOM L_2-norm:    {fom.l2_norm():e}')
         if config.HAVE_SLYCOT:
             print(f'FOM L_inf-norm:  {fom.linf_norm():e}')
         else:
             print('Skipped L_inf-norm calculation due to missing slycot.')
 
+    # Figure
+    if isinstance(fom, LTIModel) and fom.T is not None:
+        fig = plt.figure(figsize=(15, 8), constrained_layout=True)
+        fig.suptitle('Full-order model')
+        subfigs = fig.subfigures(1, 3)
+        subfigs1 = subfigs[1].subfigures(2, 1)
+        fig_bode = subfigs[0]
+        fig_poles = subfigs1[0]
+        fig_sv = subfigs1[1]
+        fig_time = subfigs[2]
+    elif isinstance(fom, (LTIModel, SecondOrderModel)):
+        fig = plt.figure(figsize=(10, 8), constrained_layout=True)
+        fig.suptitle('Full-order model')
+        subfigs = fig.subfigures(1, 2)
+        subfigs1 = subfigs[1].subfigures(2, 1)
+        fig_bode = subfigs[0]
+        fig_poles = subfigs1[0]
+        fig_sv = subfigs1[1]
+        fig_time = None
+    else:  # TransferFunction
+        fig_bode = plt.figure(figsize=(5, 8), constrained_layout=True)
+        fig_poles = None
+        fig_sv = None
+        fig_time = None
+
+    # Bode plot
+    if fig_bode is not None:
+        ax = fig_bode.subplots(2 * fom.dim_output, fom.dim_input, squeeze=False)
+        if isinstance(fom, TransferFunction):
+            fom.bode_plot(w, ax=ax)
+        else:
+            fom.transfer_function.bode_plot(w, ax=ax)
+
     # System poles
-    if not isinstance(fom, TransferFunction):
+    if fig_poles is not None:
         poles = fom.poles()
-        if fig_poles is None:
-            fig_poles = plt.figure()
         ax = fig_poles.subplots()
         ax.plot(poles.real, poles.imag, '.')
         ax.set_title('System poles')
         ax.set_xlabel('Real')
         ax.set_ylabel('Imag')
 
-        if not stable:
+        if not stable_lti:
             ast_spectrum = fom.get_ast_spectrum()
             print(f'Anti-stable system poles:  {ast_spectrum[1]}')
 
-    # Bode plot of the full model
-    if fig_bode is None:
-        fig_bode = plt.figure()
-    ax = fig_bode.subplots(2 * fom.dim_output, fom.dim_input, squeeze=False)
-    if isinstance(fom, TransferFunction):
-        fom.bode_plot(w, ax=ax)
-    else:
-        fom.transfer_function.bode_plot(w, ax=ax)
+    # Hankel singular values
+    if fig_sv is not None:
+        if isinstance(fom, LTIModel):
+            if stable_lti:
+                hsv = fom.hsv()
+            else:
+                hsv = fom._sv_U_V(typ='bs')[0]
+            ax = fig_sv.subplots()
+            ax.semilogy(range(1, len(hsv) + 1), hsv, '.-')
+            if stable_lti:
+                ax.set_title('Hankel singular values')
+            else:
+                ax.set_title('Bernoulli stabilized singular values')
+            ax.set_xlabel('Index')
+        else:  # SecondOrderModel
+            psv = fom.psv()
+            vsv = fom.vsv()
+            pvsv = fom.pvsv()
+            vpsv = fom.vpsv()
+            axs = fig_sv.subplots(2, 2, sharex=True, sharey=True)
+            axs[0, 0].semilogy(range(1, len(psv) + 1), psv, '.-')
+            axs[0, 0].set_title('Position s.v.')
+            axs[0, 1].semilogy(range(1, len(vsv) + 1), vsv, '.-')
+            axs[0, 1].set_title('Velocity s.v.')
+            axs[1, 0].semilogy(range(1, len(pvsv) + 1), pvsv, '.-')
+            axs[1, 0].set_title('Position-velocity s.v.')
+            axs[1, 0].set_xlabel('Index')
+            axs[1, 1].semilogy(range(1, len(vpsv) + 1), vpsv, '.-')
+            axs[1, 1].set_title('Velocity-position s.v.')
+            axs[1, 1].set_xlabel('Index')
+
+    # Time response
+    if fig_time is not None:
+        fig_i, fig_s = fig_time.subfigures(2, 1)
+        fig_i.suptitle('Impulse response')
+        fig_s.suptitle('Step response')
+        axs_i = fig_i.subplots(fom.dim_output, fom.dim_input, sharex=True, sharey=True, squeeze=False)
+        axs_s = fig_s.subplots(fom.dim_output, fom.dim_input, sharex=True, sharey=True, squeeze=False)
+        y_i = fom.impulse_resp()
+        y_s = fom.step_resp()
+        times = np.linspace(0, fom.T, fom.time_stepper.nt + 1)
+        for i in range(fom.dim_output):
+            for j in range(fom.dim_input):
+                axs_i[i, j].plot(times, y_i[:, i, j])
+                axs_s[i, j].plot(times, y_s[:, i, j])
+        for j in range(fom.dim_input):
+            axs_i[-1, j].set_xlabel('Time (s)')
+            axs_s[-1, j].set_xlabel('Time (s)')
+
+    plt.show()
 
 
 def run_mor_method(fom, w, reductor, reductor_short_name, r, stable=True, **reduce_kwargs):
     """Run a model order reduction method.
 
     Parameters
     ----------
@@ -130,44 +199,84 @@
     elif isinstance(rom, LTIModel):
         error = np.sqrt(fom.h2_norm()**2 - 2 * fom.h2_inner(rom).real + rom.h2_norm()**2)
         print(f'{reductor_short_name} relative H_2-error:    {error / fom.h2_norm():e}')
     else:
         print(f'{reductor_short_name} relative H_2-error:    {err.h2_norm() / fom.h2_norm():e}')
 
     # Figure and subfigures
-    fig = plt.figure(figsize=(10, 8), constrained_layout=True)
-    subfigs = fig.subfigures(1, 2)
-    subfigs1 = subfigs[1].subfigures(2, 1)
+    if isinstance(fom, LTIModel) and fom.T is not None:
+        fig = plt.figure(figsize=(15, 8), constrained_layout=True)
+        subfigs = fig.subfigures(1, 3)
+        subfigs1 = subfigs[1].subfigures(2, 1)
+        fig_bode = subfigs[0]
+        fig_poles = subfigs1[0]
+        fig_err = subfigs1[1]
+        fig_time = subfigs[2]
+    else:
+        fig = plt.figure(figsize=(10, 8), constrained_layout=True)
+        subfigs = fig.subfigures(1, 2)
+        subfigs1 = subfigs[1].subfigures(2, 1)
+        fig_bode = subfigs[0]
+        fig_poles = subfigs1[0]
+        fig_err = subfigs1[1]
+        fig_time = None
     fig.suptitle(f'{reductor_short_name} reduced-order model')
 
     # Bode plot of the full and reduced model
-    axs = subfigs[0].subplots(2 * fom.dim_output, fom.dim_input, squeeze=False)
+    axs = fig_bode.subplots(2 * fom.dim_output, fom.dim_input, squeeze=False)
     if isinstance(fom, TransferFunction):
         fom.bode_plot(w, ax=axs, label='FOM')
     else:
         fom.transfer_function.bode_plot(w, ax=axs, label='FOM')
     rom.transfer_function.bode_plot(w, ax=axs, linestyle='dashed', label='ROM')
     for ax in axs.flat:
         ax.legend()
 
     # Poles of the reduced-order model
     poles_rom = rom.poles()
-    ax = subfigs1[0].subplots()
+    ax = fig_poles.subplots()
     ax.plot(poles_rom.real, poles_rom.imag, '.')
     ax.set_title("ROM's poles")
     ax.set_xlabel('Real')
     ax.set_ylabel('Imag')
 
     # Magnitude plot of the error system
-    ax = subfigs1[1].subplots()
+    ax = fig_err.subplots()
     if isinstance(err, TransferFunction):
         err.mag_plot(w, ax=ax)
     else:
         err.transfer_function.mag_plot(w, ax=ax)
     ax.set_title('Magnitude plot of the error system')
+
+    # Time response of the (full and) reduced model
+    if fig_time is not None:
+        fig_i, fig_s = fig_time.subfigures(2, 1)
+        fig_i.suptitle('Impulse response')
+        fig_s.suptitle('Step response')
+        axs_i = fig_i.subplots(fom.dim_output, fom.dim_input, sharex=True, sharey=True, squeeze=False)
+        axs_s = fig_s.subplots(fom.dim_output, fom.dim_input, sharex=True, sharey=True, squeeze=False)
+        y_i = fom.impulse_resp()
+        y_s = fom.step_resp()
+        yr_i = rom.impulse_resp()
+        yr_s = rom.step_resp()
+        times = np.linspace(0, fom.T, fom.time_stepper.nt + 1)
+        for i in range(fom.dim_output):
+            for j in range(fom.dim_input):
+                axs_i[i, j].plot(times, y_i[:, i, j], label='FOM')
+                axs_s[i, j].plot(times, y_s[:, i, j], label='FOM')
+                axs_i[i, j].plot(times, yr_i[:, i, j], '--', label='ROM')
+                axs_s[i, j].plot(times, yr_s[:, i, j], '--', label='ROM')
+        for j in range(fom.dim_input):
+            axs_i[-1, j].set_xlabel('Time (s)')
+            axs_s[-1, j].set_xlabel('Time (s)')
+        for ax in axs_i.flat:
+            ax.legend()
+        for ax in axs_s.flat:
+            ax.legend()
+
     plt.show()
 
 
 def main(
         diameter: float = Argument(0.1, help='Diameter option for the domain discretizer.'),
         r: int = Argument(5, help='Order of the ROMs.'),
 ):
@@ -176,16 +285,16 @@
     Discretization of the PDE:
 
     .. math::
         \begin{align*}
             \partial_t z(x, y, t) &= \Delta z(x, y, t),      & 0 < x, y < 1,\ t > 0 \\
             -\nabla z(0, y, t) \cdot n &= z(0, y, t) - u(t), & 0 < y < 1, t > 0 \\
             -\nabla z(1, y, t) \cdot n &= z(1, y, t),        & 0 < y < 1, t > 0 \\
-            -\nabla z(0, x, t) \cdot n &= z(0, x, t),        & 0 < x < 1, t > 0 \\
-            -\nabla z(1, x, t) \cdot n &= z(1, x, t),        & 0 < x < 1, t > 0 \\
+            -\nabla z(x, 0, t) \cdot n &= z(x, 0, t),        & 0 < x < 1, t > 0 \\
+            -\nabla z(x, 1, t) \cdot n &= z(x, 1, t),        & 0 < x < 1, t > 0 \\
             z(x, y, 0) &= 0                                  & 0 < x, y < 1 \\
             y(t) &= \int_0^1 z(1, y, t) dy,                  & t > 0
         \end{align*}
 
     where :math:`u(t)` is the input and :math:`y(t)` is the output.
     """
     set_log_levels({
@@ -208,33 +317,19 @@
 
     fom, _ = discretize_instationary_cg(p, diameter=diameter, nt=100)
 
     fom.visualize(fom.solve())
 
     # LTI system
     solver_options = {'lyap_lrcf': lyap_lrcf_solver_options(lradi_shifts='wachspress_shifts')['lradi']}
-    lti = fom.to_lti().with_(solver_options=solver_options)
-
-    # Figure
-    fig = plt.figure(figsize=(10, 8), constrained_layout=True)
-    subfigs = fig.subfigures(1, 2)
-    subfigs1 = subfigs[1].subfigures(2, 1)
-    fig.suptitle('Full-order model')
+    lti = fom.to_lti().with_(solver_options=solver_options, T=1, time_stepper=ImplicitEulerTimeStepper(100))
 
     # System properties
     w = (1e-1, 1e3)
-    fom_properties(lti, w, fig_poles=subfigs1[0], fig_bode=subfigs[0])
-
-    # Hankel singular values
-    hsv = lti.hsv()
-    ax = subfigs1[1].subplots()
-    ax.semilogy(range(1, len(hsv) + 1), hsv, '.-')
-    ax.set_title('Hankel singular values')
-    ax.set_xlabel('Index')
-    plt.show()
+    fom_properties(lti, w)
 
     # Model order reduction
     run_mor_method(lti, w, BTReductor(lti), 'BT', r, tol=1e-5)
     run_mor_method(lti, w, LQGBTReductor(lti), 'LQGBT', r, tol=1e-5)
     run_mor_method(lti, w, BRBTReductor(lti, gamma=0.2), 'BRBT', r, tol=1e-5)
     run_mor_method(lti, w, IRKAReductor(lti), 'IRKA', r)
     run_mor_method(lti, w, IRKAReductor(lti), 'IRKA (with Arnoldi)', r, projection='arnoldi')
```

### Comparing `pymor-2022.2.1/src/pymordemos/linear_optimization.py` & `pymor-2023.1.0/src/pymordemos/linear_optimization.py`

 * *Files 2% similar despite different names*

```diff
@@ -10,32 +10,33 @@
 from pymor.basic import *
 
 
 def main(
     grid_intervals: int = Argument(..., help='Grid interval count.'),
     training_samples: int = Argument(..., help='Number of samples used for training the reduced basis.')
 ):
-    """Example script for solving linear PDE-constrained parameter optimization problems"""
+    """Example script for solving linear PDE-constrained parameter optimization problems."""
     fom, mu_bar = create_fom(grid_intervals)
 
     parameter_space = fom.parameters.space(0, np.pi)
     ranges = parameter_space.ranges['diffusion']
 
     initial_guess = fom.parameters.parse([0.25, 0.5])
 
     def fom_objective_functional(mu):
         return fom.output(mu)[0, 0]
 
     def fom_gradient_of_functional(mu):
         return fom.output_d_mu(fom.parameters.parse(mu), return_array=True, use_adjoint=True)
 
     from functools import partial
-    from scipy.optimize import minimize
     from time import perf_counter
 
+    from scipy.optimize import minimize
+
     opt_fom_minimization_data = {'num_evals': 0,
                                  'evaluations': [],
                                  'evaluation_points': [],
                                  'time': np.inf}
     tic = perf_counter()
     opt_fom_result = minimize(partial(record_results, fom_objective_functional,
                                       fom.parameters.parse, opt_fom_minimization_data),
@@ -45,16 +46,16 @@
                               bounds=(ranges, ranges),
                               options={'ftol': 1e-15})
     opt_fom_minimization_data['time'] = perf_counter()-tic
 
     reference_mu = opt_fom_result.x
 
     from pymor.algorithms.greedy import rb_greedy
-    from pymor.reductors.coercive import CoerciveRBReductor
     from pymor.parameters.functionals import MinThetaParameterFunctional
+    from pymor.reductors.coercive import CoerciveRBReductor
 
     coercivity_estimator = MinThetaParameterFunctional(fom.operator.coefficients, mu_bar)
 
     training_set = parameter_space.sample_uniformly(training_samples)
 
     RB_reductor = CoerciveRBReductor(fom, product=fom.energy_product, coercivity_estimator=coercivity_estimator)
     RB_greedy_data = rb_greedy(fom, RB_reductor, training_set, atol=1e-2)
@@ -78,25 +79,25 @@
                               initial_guess.to_numpy(),
                               method='L-BFGS-B',
                               jac=rom_gradient_of_functional,
                               bounds=(ranges, ranges),
                               options={'ftol': 1e-15})
     opt_rom_minimization_data['time'] = perf_counter()-tic
 
-    print("\nResult of optimization with FOM model and adjoint gradient")
+    print('\nResult of optimization with FOM model and adjoint gradient')
     report(opt_fom_result, fom.parameters.parse, opt_fom_minimization_data, reference_mu)
-    print("Result of optimization with ROM model and adjoint gradient")
+    print('Result of optimization with ROM model and adjoint gradient')
     report(opt_rom_result, fom.parameters.parse, opt_rom_minimization_data, reference_mu)
 
 
-def create_fom(grid_intervals, vector_valued_output=False):
+def create_fom(grid_intervals, output_type='l2', vector_valued_output=False):
     domain = RectDomain(([-1, -1], [1, 1]))
     indicator_domain = ExpressionFunction(
-        '(-2/3. <= x[0]) * (x[0] <= -1/3.) * (-2/3. <= x[1]) * (x[1] <= -1/3.) * 1. \
-       + (-2/3. <= x[0]) * (x[0] <= -1/3.) *  (1/3. <= x[1]) * (x[1] <=  2/3.) * 1.',
+        '(-2/3. <= x[0] <= -1/3.) * (-2/3. <= x[1] <= -1/3.) * 1. \
+       + (-2/3. <= x[0] <= -1/3.) *  (1/3. <= x[1] <=  2/3.) * 1.',
         dim_domain=2)
     rest_of_domain = ConstantFunction(1, 2) - indicator_domain
 
     f = ExpressionFunction('0.5*pi*pi*cos(0.5*pi*x[0])*cos(0.5*pi*x[1])', dim_domain=2)
 
     parameters = {'diffusion': 2}
     thetas = [
@@ -114,17 +115,19 @@
     ]
     diffusion = LincombFunction([rest_of_domain, indicator_domain], thetas)
 
     theta_J = ExpressionParameterFunctional('1 + 1/5 * diffusion[0] + 1/5 * diffusion[1]', parameters,
                                             derivative_expressions={'diffusion': ['1/5', '1/5']})
 
     if vector_valued_output:
-        problem = StationaryProblem(domain, f, diffusion, outputs=[('l2', f * theta_J), ('l2', f * 0.5 * theta_J)])
+        problem = StationaryProblem(
+            domain, f, diffusion, outputs=[(output_type, f * theta_J), (output_type, f * 0.5 * theta_J)]
+        )
     else:
-        problem = StationaryProblem(domain, f, diffusion, outputs=[('l2', f * theta_J)])
+        problem = StationaryProblem(domain, f, diffusion, outputs=[(output_type, f * theta_J)])
 
     print('Discretize ...')
     mu_bar = problem.parameters.parse([np.pi/2, np.pi/2])
     fom, _ = discretize_stationary_cg(problem, diameter=1. / grid_intervals, mu_energy_product=mu_bar)
     return fom, mu_bar
```

### Comparing `pymor-2022.2.1/src/pymordemos/minimal_cpp_demo/CMakeLists.txt` & `pymor-2023.1.0/src/pymordemos/minimal_cpp_demo/CMakeLists.txt`

 * *Files identical despite different names*

### Comparing `pymor-2022.2.1/src/pymordemos/minimal_cpp_demo/demo.py` & `pymor-2023.1.0/src/pymordemos/minimal_cpp_demo/demo.py`

 * *Files 0% similar despite different names*

```diff
@@ -2,18 +2,18 @@
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 import numpy as np
 
 from pymor.algorithms.pod import pod
 from pymor.algorithms.timestepping import ExplicitEulerTimeStepper
+from pymor.discretizers.builtin import OnedGrid
 from pymor.discretizers.builtin.gui.visualizers import OnedVisualizer
 from pymor.models.basic import InstationaryModel
-from pymor.discretizers.builtin import OnedGrid
-from pymor.operators.constructions import VectorOperator, LincombOperator
+from pymor.operators.constructions import LincombOperator, VectorOperator
 from pymor.parameters.functionals import ProjectionParameterFunctional
 from pymor.reductors.basic import InstationaryRBReductor
 
 # import wrapped classes
 from pymordemos.minimal_cpp_demo.wrapper import WrappedDiffusionOperator
```

### Comparing `pymor-2022.2.1/src/pymordemos/minimal_cpp_demo/model.cc` & `pymor-2023.1.0/src/pymordemos/minimal_cpp_demo/model.cc`

 * *Files identical despite different names*

### Comparing `pymor-2022.2.1/src/pymordemos/minimal_cpp_demo/model.hh` & `pymor-2023.1.0/src/pymordemos/minimal_cpp_demo/model.hh`

 * *Files identical despite different names*

### Comparing `pymor-2022.2.1/src/pymordemos/minimal_cpp_demo/wrapper.py` & `pymor-2023.1.0/src/pymordemos/minimal_cpp_demo/wrapper.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,17 +1,18 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
-from pymor.operators.interface import Operator
-from pymor.vectorarrays.list import CopyOnWriteVector, ListVectorSpace
+import math
 
 import numpy as np
-import math
-from model import Vector, DiffusionOperator
+from model import DiffusionOperator, Vector
+
+from pymor.operators.interface import Operator
+from pymor.vectorarrays.list import CopyOnWriteVector, ListVectorSpace
 
 
 class WrappedVector(CopyOnWriteVector):
 
     def __init__(self, vector):
         assert isinstance(vector, Vector)
         self._impl = vector
```

### Comparing `pymor-2022.2.1/src/pymordemos/neural_networks.py` & `pymor-2023.1.0/src/pymordemos/neural_networks.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,34 +1,35 @@
 #!/usr/bin/env python
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
-import time
 import sys
+import time
+
 import numpy as np
 from typer import Argument, Option, run
 
 from pymor.basic import *
 from pymor.core.config import config
-from pymor.core.exceptions import TorchMissing
+from pymor.core.exceptions import TorchMissingError
 from pymor.reductors.neural_network import NeuralNetworkReductor, NeuralNetworkStatefreeOutputReductor
 
 
 def main(
     grid_intervals: int = Argument(..., help='Grid interval count.'),
     training_samples: int = Argument(..., help='Number of samples used for training the neural network.'),
     validation_samples: int = Argument(..., help='Number of samples used for validation during the training phase.'),
 
     fv: bool = Option(False, help='Use finite volume discretization instead of finite elements.'),
     vis: bool = Option(False, help='Visualize full order solution and reduced solution for a test set.'),
 ):
     """Model oder reduction with neural networks (approach by Hesthaven and Ubbiali)."""
     if not config.HAVE_TORCH:
-        raise TorchMissing()
+        raise TorchMissingError()
 
     fom = create_fom(fv, grid_intervals)
 
     parameter_space = fom.parameters.space((0.1, 1))
 
     training_set = parameter_space.sample_uniformly(training_samples)
     validation_set = parameter_space.sample_randomly(validation_samples)
```

### Comparing `pymor-2022.2.1/src/pymordemos/neural_networks_fenics.py` & `pymor-2023.1.0/src/pymordemos/neural_networks_fenics.py`

 * *Files 4% similar despite different names*

```diff
@@ -4,29 +4,28 @@
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 import numpy as np
 from typer import Argument, run
 
 from pymor.basic import *
 from pymor.core.config import config
-from pymor.core.exceptions import TorchMissing
-
+from pymor.core.exceptions import TorchMissingError
 
 DIM = 2
 GRID_INTERVALS = 50
 FENICS_ORDER = 1
 
 
 def main(
     training_samples: int = Argument(..., help='Number of samples used for training the neural network.'),
     validation_samples: int = Argument(..., help='Number of samples used for validation during the training phase.'),
 ):
     """Reduction of a FEniCS model using neural networks (approach by Hesthaven and Ubbiali)."""
     if not config.HAVE_TORCH:
-        raise TorchMissing()
+        raise TorchMissingError()
 
     fom, parameter_space = discretize_fenics()
 
     from pymor.reductors.neural_network import NeuralNetworkReductor
 
     training_set = parameter_space.sample_uniformly(training_samples)
     validation_set = parameter_space.sample_randomly(validation_samples)
@@ -83,34 +82,34 @@
     if DIM == 2:
         mesh = df.UnitSquareMesh(GRID_INTERVALS, GRID_INTERVALS)
     elif DIM == 3:
         mesh = df.UnitCubeMesh(GRID_INTERVALS, GRID_INTERVALS, GRID_INTERVALS)
     else:
         raise NotImplementedError
 
-    V = df.FunctionSpace(mesh, "CG", FENICS_ORDER)
+    V = df.FunctionSpace(mesh, 'CG', FENICS_ORDER)
 
     g = df.Constant(1.0)
     c = df.Constant(1.)
 
     class DirichletBoundary(df.SubDomain):
         def inside(self, x, on_boundary):
             return abs(x[0] - 1.0) < df.DOLFIN_EPS and on_boundary
     db = DirichletBoundary()
     bc = df.DirichletBC(V, g, db)
 
     u = df.Function(V)
     v = df.TestFunction(V)
-    f = df.Expression("x[0]*sin(x[1])", degree=2)
+    f = df.Expression('x[0]*sin(x[1])', degree=2)
     F = df.inner((1 + c*u**2)*df.grad(u), df.grad(v))*df.dx - f*v*df.dx
 
     df.solve(F == 0, u, bc,
-             solver_parameters={"newton_solver": {"relative_tolerance": 1e-6}})
+             solver_parameters={'newton_solver': {'relative_tolerance': 1e-6}})
 
-    from pymor.bindings.fenics import FenicsVectorSpace, FenicsOperator
+    from pymor.bindings.fenics import FenicsOperator, FenicsVectorSpace
 
     space = FenicsVectorSpace(V)
     op = FenicsOperator(F, space, space, u, (bc,),
                         parameter_setter=lambda mu: c.assign(mu['c'].item()),
                         parameters={'c': 1},
                         solver_options={'inverse': {'type': 'newton', 'rtol': 1e-6}})
     rhs = VectorOperator(op.range.zeros())
```

### Comparing `pymor-2022.2.1/src/pymordemos/neural_networks_instationary.py` & `pymor-2023.1.0/src/pymordemos/neural_networks_instationary.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,22 +1,25 @@
 #!/usr/bin/env python
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 import time
+
 import numpy as np
 from typer import Argument, Option, run
 
 from pymor.basic import *
 from pymor.core.config import config
-from pymor.reductors.neural_network import (NeuralNetworkInstationaryReductor,
-                                            NeuralNetworkInstationaryStatefreeOutputReductor,
-                                            NeuralNetworkLSTMInstationaryReductor,
-                                            NeuralNetworkLSTMInstationaryStatefreeOutputReductor)
+from pymor.reductors.neural_network import (
+    NeuralNetworkInstationaryReductor,
+    NeuralNetworkInstationaryStatefreeOutputReductor,
+    NeuralNetworkLSTMInstationaryReductor,
+    NeuralNetworkLSTMInstationaryStatefreeOutputReductor,
+)
 from pymor.tools import mpi
 
 
 def main(
     problem_number: int = Argument(..., min=0, max=1, help='Selects the problem to solve [0 or 1].'),
     grid_intervals: int = Argument(..., help='Grid interval count.'),
     time_steps: int = Argument(..., help='Number of time steps used for discretization.'),
@@ -30,15 +33,15 @@
     a two-dimensional cavity with the Reynolds number as parameter.
     The discretization is based on FEniCS.
 
     Problem number 1 considers a parametrized Burgers equation on a
     one-dimensional domain. The discretization is based on pyMOR's built-in
     functionality.
     """
-    config.require("TORCH")
+    config.require('TORCH')
 
     fom, plot_function = create_fom(problem_number, grid_intervals, time_steps)
 
     if problem_number == 0:
         parameter_space = fom.parameters.space(1., 50.)
     else:
         parameter_space = fom.parameters.space(1., 2.)
@@ -159,27 +162,27 @@
     print(f'Average relative error: {np.average(outputs_rel_errors_lstm)}')
     print(f'Median of speedup: {np.median(outputs_speedups_lstm)}')
 
 
 def create_fom(problem_number, grid_intervals, time_steps):
     print('Discretize ...')
     if problem_number == 0:
-        config.require("FENICS")
+        config.require('FENICS')
         fom, plot_function = discretize_navier_stokes(grid_intervals, time_steps)
     elif problem_number == 1:
         problem = burgers_problem()
         f = LincombFunction(
             [ExpressionFunction('1.', 1), ConstantFunction(1., 1)],
             [ProjectionParameterFunctional('exponent'), 0.1])
         problem = problem.with_stationary_part(outputs=[('l2', f)])
 
         fom, _ = discretize_instationary_fv(problem, diameter=1. / grid_intervals, nt=time_steps)
         plot_function = fom.visualize
     else:
-        assert False
+        raise ValueError(f'Unknown problem number {problem_number}')
 
     return fom, plot_function
 
 
 def discretize_navier_stokes(n, nt):
     if mpi.parallel:
         from pymor.models.mpi import mpi_wrap_model
@@ -188,20 +191,20 @@
         plot_function = None
     else:
         fom, plot_function = _discretize_navier_stokes(n, nt)
     return fom, plot_function
 
 
 def _discretize_navier_stokes(n, nt):
-    from pymor.bindings.fenics import FenicsVectorSpace, FenicsOperator, FenicsVisualizer, FenicsMatrixOperator
-    from pymor.algorithms.timestepping import ImplicitEulerTimeStepper
-
     import dolfin as df
     import matplotlib.pyplot as plt
 
+    from pymor.algorithms.timestepping import ImplicitEulerTimeStepper
+    from pymor.bindings.fenics import FenicsMatrixOperator, FenicsOperator, FenicsVectorSpace, FenicsVisualizer
+
     # create square mesh
     mesh = df.UnitSquareMesh(n, n)
 
     # create Finite Elements for the pressure and the velocity
     P = df.FiniteElement('P', mesh.ufl_cell(), 1)
     V = df.VectorElement('P', mesh.ufl_cell(), 2, dim=2)
     # create mixed element and function space
@@ -224,26 +227,26 @@
     w = df.Function(W)
     p, u = df.split(w)
 
     # set Reynolds number, which will serve as parameter
     Re = df.Constant(1.)
 
     # define walls
-    top_wall = "near(x[1], 1.)"
-    walls = "near(x[0], 0.) | near(x[0], 1.) | near(x[1], 0.)"
+    top_wall = 'near(x[1], 1.)'
+    walls = 'near(x[0], 0.) | near(x[0], 1.) | near(x[1], 0.)'
 
     # define no slip boundary conditions on all but the top wall
     bcu_noslip_const = df.Constant((0., 0.))
     bcu_noslip  = df.DirichletBC(W_u, bcu_noslip_const, walls)
     # define Dirichlet boundary condition for the velocity on the top wall
     bcu_lid_const = df.Constant((1., 0.))
     bcu_lid = df.DirichletBC(W_u, bcu_lid_const, top_wall)
 
     # fix pressure at a single point of the domain to obtain unique solutions
-    pressure_point = "near(x[0],  0.) & (x[1] <= " + str(2./n) + ")"
+    pressure_point = 'near(x[0],  0.) & (x[1] <= ' + str(2./n) + ')'
     bcp_const = df.Constant(0.)
     bcp = df.DirichletBC(W_p, bcp_const, pressure_point)
 
     # collect boundary conditions
     bc = [bcu_noslip, bcu_lid, bcp]
 
     mass = -psi_p * df.div(u)
@@ -283,24 +286,24 @@
 
     def plot_fenics(w, title=''):
         v = df.Function(W)
         v.leaf_node().vector()[:] = (w.to_numpy()[-1, :]).squeeze()
         p, u  = v.split()
 
         fig_u = df.plot(u)
-        plt.title("Velocity vector field " + title)
-        plt.xlabel("$x$")
-        plt.ylabel("$y$")
+        plt.title('Velocity vector field ' + title)
+        plt.xlabel('$x$')
+        plt.ylabel('$y$')
         plt.colorbar(fig_u)
         plt.show()
 
         fig_p = df.plot(p)
-        plt.title("Pressure field " + title)
-        plt.xlabel("$x$")
-        plt.ylabel("$y$")
+        plt.title('Pressure field ' + title)
+        plt.xlabel('$x$')
+        plt.ylabel('$y$')
         plt.colorbar(fig_p)
         plt.show()
 
     if mpi.parallel:
         return fom
     else:
         return fom, plot_fenics
```

### Comparing `pymor-2022.2.1/src/pymordemos/output_error_estimation.py` & `pymor-2023.1.0/src/pymordemos/output_error_estimation.py`

 * *Ordering differences only*

 * *Files 1% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 #!/usr/bin/env python
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 
-import numpy as np
 import matplotlib.pyplot as plt
+import numpy as np
 from typer import Argument, run
 
 from pymor.basic import *
 
 
 def main(
     fom_number: int = Argument(..., help='Selects FOMs [0, 1, 2] for elliptic problems and [3, 4] for '
```

### Comparing `pymor-2022.2.1/src/pymordemos/output_error_estimation_with_dwr.py` & `pymor-2023.1.0/src/pymordemos/output_error_estimation_with_dwr.py`

 * *Ordering differences only*

 * *Files 0% similar despite different names*

```diff
@@ -1,14 +1,14 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 
-import numpy as np
 import matplotlib.pyplot as plt
+import numpy as np
 from typer import Argument, run
 
 from pymor.basic import *
 from pymor.reductors.dwr import DWRCoerciveRBReductor
 
 
 def main(
```

### Comparing `pymor-2022.2.1/src/pymordemos/parabolic.py` & `pymor-2023.1.0/src/pymordemos/parabolic.py`

 * *Files 15% similar despite different names*

```diff
@@ -4,15 +4,14 @@
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 import numpy as np
 from typer import Argument, Option, Typer
 
 from pymor.basic import *
 
-
 app = Typer(help="Solve parabolic equations using pyMOR's builtin discretization toolkit.")
 FV = Option(False, help='Use finite volume discretization instead of finite elements.')
 GRID = Option(100, help='Use grid with NIxNI intervals.')
 NT = Option(100, help='Number of time steps.')
 RECT = Option(False, help='Use RectGrid instead of TriaGrid.')
 
 
@@ -28,35 +27,35 @@
     problem = InstationaryProblem(
 
         StationaryProblem(
             domain=RectDomain(top='dirichlet', bottom='neumann'),
 
             diffusion=LincombFunction(
                 [ConstantFunction(1., dim_domain=2),
-                 ExpressionFunction('(x[0] > 0.45) * (x[0] < 0.55) * (x[1] < 0.7) * 1.',
+                 ExpressionFunction('(0.45 < x[0] < 0.55) * (x[1] < 0.7) * 1.',
                                     dim_domain=2),
-                 ExpressionFunction('(x[0] > 0.35) * (x[0] < 0.40) * (x[1] > 0.3) * 1. + '
-                                    '(x[0] > 0.60) * (x[0] < 0.65) * (x[1] > 0.3) * 1.',
+                 ExpressionFunction('(0.35 < x[0] < 0.40) * (x[1] > 0.3) * 1. + '
+                                    '(0.60 < x[0] < 0.65) * (x[1] > 0.3) * 1.',
                                     dim_domain=2)],
                 [1.,
                  100. - 1.,
                  ExpressionParameterFunctional('top - 1.', {'top': 1})]
             ),
 
             rhs=ConstantFunction(value=0., dim_domain=2),
 
             dirichlet_data=ConstantFunction(value=0., dim_domain=2),
 
-            neumann_data=ExpressionFunction('(x[0] > 0.45) * (x[0] < 0.55) * -1000.',
+            neumann_data=ExpressionFunction('(0.45 < x[0] < 0.55) * -1000.',
                                             dim_domain=2),
         ),
 
         T=1.,
 
-        initial_data=ExpressionFunction('(x[0] > 0.45) * (x[0] < 0.55) * (x[1] < 0.7) * 10.',
+        initial_data=ExpressionFunction('(0.45 < x[0] < 0.55) * (x[1] < 0.7) * 10.',
                                         dim_domain=2)
     )
     mu = {'top': top}
     solve(problem, mu, fv, rect, grid, nt)
 
 
 @app.command()
@@ -76,24 +75,24 @@
             diffusion=ConstantFunction(0.01, dim_domain=2),
 
             advection=LincombFunction([ConstantFunction(np.array([-1., 0]), dim_domain=2)],
                                       [ProjectionParameterFunctional('speed')]),
 
             reaction=ConstantFunction(0.5, dim_domain=2),
 
-            rhs=ExpressionFunction('(x[0] > 0.3) * (x[0] < 0.7) * (x[1] > 0.3)*(x[1]<0.7) * 0.',
+            rhs=ExpressionFunction('(0.3 < x[0] < 0.7) * (0.3 < x[1] < 0.7) * 0.',
                                    dim_domain=2),
 
             dirichlet_data=ConstantFunction(value=0., dim_domain=2),
         ),
 
         T=1.,
 
         initial_data=ExpressionFunction(
-            '(x[0] > 0.3) * (x[0] < 0.7) * (x[1]>0.3) * (x[1] < 0.7) * 10.',
+            '(0.3 < x[0] < 0.7) * (0.3 < x[1] < 0.7) * 10.',
             dim_domain=2),
     )
     mu = {'speed': speed}
     solve(problem, mu, fv, rect, grid, nt)
 
 
 def solve(problem, mu, fv, rect, grid, nt):
```

### Comparing `pymor-2022.2.1/src/pymordemos/parabolic_mor.py` & `pymor-2023.1.0/src/pymordemos/parabolic_mor.py`

 * *Files 14% similar despite different names*

```diff
@@ -2,19 +2,18 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 import numpy as np
 from typer import Argument, run
 
-from pymor.basic import *
 from pymor.algorithms.timestepping import ImplicitEulerTimeStepper
+from pymor.basic import *
 from pymor.tools.typer import Choices
 
-
 # parameters for high-dimensional models
 GRID_INTERVALS = 50
 FENICS_ORDER = 2
 NT = 50
 DT = 1. / NT
 
 
@@ -105,34 +104,34 @@
     problem = InstationaryProblem(
 
         StationaryProblem(
             domain=RectDomain(top='dirichlet', bottom='neumann'),
 
             diffusion=LincombFunction(
                 [ConstantFunction(1., dim_domain=2),
-                 ExpressionFunction('(x[0] > 0.45) * (x[0] < 0.55) * (x[1] < 0.7) * 1.',
+                 ExpressionFunction('(0.45 < x[0] < 0.55) * (x[1] < 0.7) * 1.',
                                     dim_domain=2),
-                 ExpressionFunction('(x[0] > 0.35) * (x[0] < 0.40) * (x[1] > 0.3) * 1. + '
-                                    '(x[0] > 0.60) * (x[0] < 0.65) * (x[1] > 0.3) * 1.',
+                 ExpressionFunction('(0.35 < x[0] < 0.40) * (x[1] > 0.3) * 1. + '
+                                    '(0.60 < x[0] < 0.65) * (x[1] > 0.3) * 1.',
                                     dim_domain=2)],
                 [1.,
                  100. - 1.,
                  ExpressionParameterFunctional('top[0] - 1.', {'top': 1})]
             ),
 
             rhs=ConstantFunction(value=100., dim_domain=2) * ExpressionParameterFunctional('sin(10*pi*t[0])', {'t': 1}),
 
             dirichlet_data=ConstantFunction(value=0., dim_domain=2),
 
-            neumann_data=ExpressionFunction('(x[0] > 0.45) * (x[0] < 0.55) * -1000.', dim_domain=2),
+            neumann_data=ExpressionFunction('(0.45 < x[0] < 0.55) * -1000.', dim_domain=2),
         ),
 
         T=1.,
 
-        initial_data=ExpressionFunction('(x[0] > 0.45) * (x[0] < 0.55) * (x[1] < 0.7) * 10.', dim_domain=2)
+        initial_data=ExpressionFunction('(0.45 < x[0] < 0.55) * (x[1] < 0.7) * 10.', dim_domain=2)
     )
 
     # discretize using continuous finite elements
     fom, _ = discretize_instationary_cg(analytical_problem=problem, diameter=1./GRID_INTERVALS, nt=NT)
     fom.enable_caching('disk')
 
     return fom
@@ -196,15 +195,15 @@
     bc.zero(top_mat)
     bc.apply(f)
     bc.apply(u0)
 
     # wrap everything as a pyMOR model
     ##################################
 
-    from pymor.bindings.fenics import FenicsVectorSpace, FenicsMatrixOperator, FenicsVisualizer
+    from pymor.bindings.fenics import FenicsMatrixOperator, FenicsVectorSpace, FenicsVisualizer
 
     fom = InstationaryModel(
         T=1.,
 
         initial_data=FenicsVectorSpace(V).make_array([u0]),
 
         operator=LincombOperator([FenicsMatrixOperator(h1_0_mat, V, V),
```

### Comparing `pymor-2022.2.1/src/pymordemos/parametric_delay.py` & `pymor-2023.1.0/src/pymordemos/parametric_delay.py`

 * *Files 16% similar despite different names*

```diff
@@ -39,9 +39,9 @@
     w = (1e-2, 1e4)
     fom_properties_param(fom, w, mus)
 
     # TF-IRKA
     run_mor_method_param(fom, r, w, mus, TFIRKAReductor, 'TF-IRKA')
 
 
-if __name__ == "__main__":
+if __name__ == '__main__':
     run(main)
```

### Comparing `pymor-2022.2.1/src/pymordemos/parametric_heat.py` & `pymor-2023.1.0/src/pymordemos/parametric_heat.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,27 +1,29 @@
 #!/usr/bin/env python
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 import matplotlib.pyplot as plt
+import numpy as np
 from typer import Argument, run
 
+from pymor.algorithms.timestepping import ImplicitEulerTimeStepper
 from pymor.analyticalproblems.domaindescriptions import LineDomain
 from pymor.analyticalproblems.elliptic import StationaryProblem
 from pymor.analyticalproblems.functions import ConstantFunction, ExpressionFunction, LincombFunction
 from pymor.analyticalproblems.instationary import InstationaryProblem
 from pymor.core.config import config
 from pymor.core.logger import set_log_levels
 from pymor.discretizers.builtin import discretize_instationary_cg
 from pymor.models.iosys import LTIModel, SecondOrderModel
 from pymor.models.transfer_function import TransferFunction
 from pymor.parameters.functionals import ProjectionParameterFunctional
-from pymor.reductors.bt import BTReductor, LQGBTReductor, BRBTReductor
-from pymor.reductors.h2 import IRKAReductor, TSIAReductor, OneSidedIRKAReductor
+from pymor.reductors.bt import BRBTReductor, BTReductor, LQGBTReductor
+from pymor.reductors.h2 import IRKAReductor, OneSidedIRKAReductor, TSIAReductor
 from pymor.reductors.mt import MTReductor
 
 
 def fom_properties_param(fom, w, mus):
     """Show properties of the full-order model.
 
     Parameters
@@ -33,47 +35,60 @@
     mus
         List of parameter values.
     """
     # Model info
     print(fom)
 
     # System norms
-    if not isinstance(fom, TransferFunction):
-        for mu in mus:
-            print(f'mu = {mu}:')
-            print(f'    H_2-norm of the full model:    {fom.h2_norm(mu=mu):e}')
+    for mu in mus:
+        print(f'mu = {mu}:')
+        print(f'    H_2-norm of the full model:    {fom.h2_norm(mu=mu):e}')
+        if not isinstance(fom, TransferFunction):
             if config.HAVE_SLYCOT:
                 print(f'    H_inf-norm of the full model:  {fom.hinf_norm(mu=mu):e}')
             print(f'    Hankel-norm of the full model: {fom.hankel_norm(mu=mu):e}')
 
     # Figure
-    if isinstance(fom, (LTIModel, SecondOrderModel)):
+    if isinstance(fom, LTIModel) and fom.T is not None:
+        fig = plt.figure(figsize=(15, 8), constrained_layout=True)
+        fig.suptitle('Full-order model')
+        subfigs = fig.subfigures(1, 3)
+        subfigs1 = subfigs[1].subfigures(2, 1)
+        fig_bode = subfigs[0]
+        fig_poles = subfigs1[0]
+        fig_sv = subfigs1[1]
+        fig_time = subfigs[2]
+    elif isinstance(fom, (LTIModel, SecondOrderModel)):
         fig = plt.figure(figsize=(10, 8), constrained_layout=True)
         fig.suptitle('Full-order model')
         subfigs = fig.subfigures(1, 2)
         subfigs1 = subfigs[1].subfigures(2, 1)
         fig_bode = subfigs[0]
         fig_poles = subfigs1[0]
         fig_sv = subfigs1[1]
+        fig_time = None
     else:  # TransferFunction
         fig_bode = plt.figure(figsize=(5, 8), constrained_layout=True)
+        fig_poles = None
+        fig_sv = None
+        fig_time = None
     markers = 'ox+1234'
 
     # Bode plots
     axs = fig_bode.subplots(2, 1, squeeze=False)
     for mu in mus:
         if isinstance(fom, TransferFunction):
             fom.bode_plot(w, ax=axs, mu=mu, label=fr'$\mu = {mu}$')
         else:
             fom.transfer_function.bode_plot(w, ax=axs, mu=mu, label=fr'$\mu = {mu}$')
     for ax in axs.flat:
         ax.legend()
 
     # System poles
-    if not isinstance(fom, TransferFunction):
+    if fig_poles is not None:
         ax = fig_poles.subplots()
         for mu, marker in zip(mus, markers):
             poles = fom.poles(mu=mu)
             ax.plot(poles.real, poles.imag, marker, fillstyle='none', label=fr'$\mu = {mu}$')
         ax.set_title('System poles')
         ax.set_xlabel('Real')
         ax.set_ylabel('Imag')
@@ -102,14 +117,38 @@
         axs[0, 0].set_title('Position s.v.')
         axs[0, 1].set_title('Velocity s.v.')
         axs[1, 0].set_title('Position-velocity s.v.')
         axs[1, 0].set_xlabel('Index')
         axs[1, 1].set_title('Velocity-position s.v.')
         axs[1, 1].set_xlabel('Index')
         axs[0, 1].legend()
+
+    # Time response
+    if fig_time is not None:
+        fig_i, fig_s = fig_time.subfigures(2, 1)
+        fig_i.suptitle('Impulse response')
+        fig_s.suptitle('Step response')
+        axs_i = fig_i.subplots(fom.dim_output, fom.dim_input, sharex=True, sharey=True, squeeze=False)
+        axs_s = fig_s.subplots(fom.dim_output, fom.dim_input, sharex=True, sharey=True, squeeze=False)
+        times = np.linspace(0, fom.T, fom.time_stepper.nt + 1)
+        for mu, marker in zip(mus, markers):
+            y_i = fom.impulse_resp(mu=mu)
+            y_s = fom.step_resp(mu=mu)
+            for i in range(fom.dim_output):
+                for j in range(fom.dim_input):
+                    axs_i[i, j].plot(times, y_i[:, i, j], f'{marker}-', fillstyle='none', label=fr'$\mu = {mu}$')
+                    axs_s[i, j].plot(times, y_s[:, i, j], f'{marker}-', fillstyle='none', label=fr'$\mu = {mu}$')
+        for j in range(fom.dim_input):
+            axs_i[-1, j].set_xlabel('Time (s)')
+            axs_s[-1, j].set_xlabel('Time (s)')
+        for ax in axs_i.flat:
+            ax.legend()
+        for ax in axs_s.flat:
+            ax.legend()
+
     plt.show()
 
 
 def run_mor_method_param(fom, r, w, mus, reductor_cls, reductor_short_name, **reductor_kwargs):
     """Plot reductor errors for different parameter values.
 
     Parameters
@@ -132,45 +171,59 @@
     # Reduction
     roms = []
     for mu in mus:
         rom = reductor_cls(fom, mu=mu, **reductor_kwargs).reduce(r)
         roms.append(rom)
 
     # Errors
-    if not isinstance(fom, TransferFunction):
-        for mu, rom in zip(mus, roms):
-            err = fom - rom
-            print(f'mu = {mu}')
-            print(f'    {reductor_short_name} relative H_2-error:'
-                  f'    {err.h2_norm(mu=mu) / fom.h2_norm(mu=mu):e}')
+    for mu, rom in zip(mus, roms):
+        err = fom - rom
+        print(f'mu = {mu}')
+        if not isinstance(fom, TransferFunction):
+            error = err.h2_norm(mu=mu)
+        else:
+            fom_norm = fom.h2_norm(mu=mu)
+            rom_norm = rom.h2_norm()
+            inner = fom.h2_inner(rom, mu=mu).real
+            error = np.sqrt(fom_norm**2 - 2 * inner + rom_norm**2)
+        print(f'    {reductor_short_name} relative H_2-error:'
+              f'    {error / fom.h2_norm(mu=mu):e}')
+        if not isinstance(fom, TransferFunction):
             if config.HAVE_SLYCOT:
                 print(f'    {reductor_short_name} relative H_inf-error:'
                       f'  {err.hinf_norm(mu=mu) / fom.hinf_norm(mu=mu):e}')
             print(f'    {reductor_short_name} relative Hankel-error:'
                   f' {err.hankel_norm(mu=mu) / fom.hankel_norm(mu=mu):e}')
 
     # Figure and subfigures
-    fig = plt.figure(figsize=(10, 8), constrained_layout=True)
+    if isinstance(fom, LTIModel) and fom.T is not None:
+        fig = plt.figure(figsize=(15, 8), constrained_layout=True)
+        subfigs = fig.subfigures(1, 3)
+        fig_time = subfigs[2]
+    else:
+        fig = plt.figure(figsize=(10, 8), constrained_layout=True)
+        subfigs = fig.subfigures(1, 2)
+        fig_time = None
     fig.suptitle(f'{reductor_short_name} reduced-order model')
-    subfigs = fig.subfigures(1, 2)
     subfigs1 = subfigs[1].subfigures(2, 1)
     fig_bode = subfigs[0]
     fig_poles = subfigs1[0]
     fig_mag = subfigs1[1]
+    markers = 'ox+1234'
 
     # Bode plots of reduced-order models
     axs = fig_bode.subplots(2 * fom.dim_output, fom.dim_input, squeeze=False)
     for mu, rom in zip(mus, roms):
         rom.transfer_function.bode_plot(w, ax=axs, label=fr'$\mu = {mu}$')
     for ax in axs.flat:
         ax.legend()
 
     # Poles
     ax = fig_poles.subplots()
-    for mu, rom, marker in zip(mus, roms, 'ox+1234'):
+    for mu, rom, marker in zip(mus, roms, markers):
         poles_rom = rom.poles()
         ax.plot(poles_rom.real, poles_rom.imag, marker, fillstyle='none', label=fr'$\mu = {mu}$')
     ax.set_title("ROM's poles")
     ax.set_xlabel('Real')
     ax.set_ylabel('Imag')
     ax.legend()
 
@@ -179,14 +232,38 @@
     for mu, rom in zip(mus, roms):
         if isinstance(fom, TransferFunction):
             (fom - rom).mag_plot(w, ax=ax, mu=mu, label=fr'$\mu = {mu}$')
         else:
             (fom - rom).transfer_function.mag_plot(w, ax=ax, mu=mu, label=fr'$\mu = {mu}$')
     ax.set_title('Magnitude plot of the error system')
     ax.legend()
+
+    # Time response
+    if fig_time is not None:
+        fig_i, fig_s = fig_time.subfigures(2, 1)
+        fig_i.suptitle('Impulse response')
+        fig_s.suptitle('Step response')
+        axs_i = fig_i.subplots(fom.dim_output, fom.dim_input, sharex=True, sharey=True, squeeze=False)
+        axs_s = fig_s.subplots(fom.dim_output, fom.dim_input, sharex=True, sharey=True, squeeze=False)
+        times = np.linspace(0, fom.T, fom.time_stepper.nt + 1)
+        for mu, rom, marker in zip(mus, roms, markers):
+            y_i = rom.impulse_resp()
+            y_s = rom.step_resp()
+            for i in range(fom.dim_output):
+                for j in range(fom.dim_input):
+                    axs_i[i, j].plot(times, y_i[:, i, j], f'{marker}-', fillstyle='none', label=fr'$\mu = {mu}$')
+                    axs_s[i, j].plot(times, y_s[:, i, j], f'{marker}-', fillstyle='none', label=fr'$\mu = {mu}$')
+        for j in range(fom.dim_input):
+            axs_i[-1, j].set_xlabel('Time (s)')
+            axs_s[-1, j].set_xlabel('Time (s)')
+        for ax in axs_i.flat:
+            ax.legend()
+        for ax in axs_s.flat:
+            ax.legend()
+
     plt.show()
 
 
 def main(
         diameter: float = Argument(0.01, help='Diameter option for the domain discretizer.'),
         r: int = Argument(5, help='Order of the ROMs.'),
 ):
@@ -215,15 +292,15 @@
 
     fom, _ = discretize_instationary_cg(p, diameter=diameter, nt=100)
 
     fom.visualize(fom.solve(mu=0.1))
     fom.visualize(fom.solve(mu=1))
     fom.visualize(fom.solve(mu=10))
 
-    lti = fom.to_lti()
+    lti = fom.to_lti().with_(T=1, time_stepper=ImplicitEulerTimeStepper(100))
 
     mus = [0.1, 1, 10]
     w = (1e-1, 1e3)
     fom_properties_param(lti, w, mus)
 
     # Model order reduction
     run_mor_method_param(lti, r, w, mus, BTReductor, 'BT')
@@ -231,9 +308,9 @@
     run_mor_method_param(lti, r, w, mus, BRBTReductor, 'BRBT')
     run_mor_method_param(lti, r, w, mus, IRKAReductor, 'IRKA')
     run_mor_method_param(lti, r, w, mus, TSIAReductor, 'TSIA')
     run_mor_method_param(lti, r, w, mus, OneSidedIRKAReductor, 'OS-IRKA', version='V')
     run_mor_method_param(lti, r, w, mus, MTReductor, 'MT')
 
 
-if __name__ == "__main__":
+if __name__ == '__main__':
     run(main)
```

### Comparing `pymor-2022.2.1/src/pymordemos/parametric_string.py` & `pymor-2023.1.0/src/pymordemos/parametric_string.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,26 +1,32 @@
 #!/usr/bin/env python
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
+import matplotlib.pyplot as plt
 import numpy as np
 import scipy.sparse as sps
-import matplotlib.pyplot as plt
 from typer import Argument, run
 
 from pymor.core.logger import set_log_levels
 from pymor.models.iosys import SecondOrderModel
 from pymor.operators.numpy import NumpyMatrixOperator
 from pymor.parameters.functionals import ProjectionParameterFunctional
 from pymor.reductors.bt import BTReductor
 from pymor.reductors.h2 import IRKAReductor
 from pymor.reductors.mt import MTReductor
-from pymor.reductors.sobt import (SOBTpReductor, SOBTvReductor, SOBTpvReductor, SOBTvpReductor,
-                                  SOBTfvReductor, SOBTReductor)
+from pymor.reductors.sobt import (
+    SOBTfvReductor,
+    SOBTpReductor,
+    SOBTpvReductor,
+    SOBTReductor,
+    SOBTvpReductor,
+    SOBTvReductor,
+)
 from pymor.reductors.sor_irka import SORIRKAReductor
 from pymordemos.parametric_heat import fom_properties_param, run_mor_method_param
 
 
 def main(
         n: int = Argument(101, help='Order of the full second-order model (odd number).'),
         r: int = Argument(5, help='Order of the ROMs.'),
@@ -74,9 +80,9 @@
     run_mor_method_param(so_sys, r, w, mus, SOBTReductor, 'SOBT')
     run_mor_method_param(so_sys, r, w, mus, SORIRKAReductor, 'SOR-IRKA')
     run_mor_method_param(so_sys.to_lti(), r, w, mus, BTReductor, 'BT')
     run_mor_method_param(so_sys.to_lti(), r, w, mus, IRKAReductor, 'IRKA')
     run_mor_method_param(so_sys.to_lti(), r, w, mus, MTReductor, 'MT')
 
 
-if __name__ == "__main__":
+if __name__ == '__main__':
     run(main)
```

### Comparing `pymor-2022.2.1/src/pymordemos/parametric_synthetic.py` & `pymor-2023.1.0/src/pymordemos/parametric_synthetic.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 #!/usr/bin/env python
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
+import matplotlib.pyplot as plt
 import numpy as np
 import scipy.sparse as sps
-import matplotlib.pyplot as plt
 from typer import Argument, run
 
 from pymor.core.logger import set_log_levels
 from pymor.models.iosys import LTIModel
 from pymor.operators.numpy import NumpyMatrixOperator
 from pymor.parameters.functionals import ProjectionParameterFunctional
 from pymor.reductors.bt import BTReductor
@@ -70,9 +70,9 @@
     fom_properties_param(lti, w, mus)
 
     # Model order reduction
     run_mor_method_param(lti, r, w, mus, BTReductor, 'BT')
     run_mor_method_param(lti, r, w, mus, IRKAReductor, 'IRKA')
 
 
-if __name__ == "__main__":
+if __name__ == '__main__':
     run(main)
```

### Comparing `pymor-2022.2.1/src/pymordemos/symplectic_wave_equation.py` & `pymor-2023.1.0/src/pymordemos/symplectic_wave_equation.py`

 * *Ordering differences only*

 * *Files 1% similar despite different names*

```diff
@@ -1,26 +1,26 @@
 #!/usr/bin/env python
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 import numpy as np
+from scipy.sparse import diags
 from typer import Argument, run
 
 from pymor.algorithms.pod import pod
 from pymor.algorithms.symplectic import psd_complex_svd, psd_cotengent_lift, psd_svd_like_decomp
 from pymor.models.symplectic import QuadraticHamiltonianModel
 from pymor.operators.block import BlockDiagonalOperator
 from pymor.operators.constructions import IdentityOperator, LincombOperator
 from pymor.operators.numpy import NumpyMatrixOperator
 from pymor.reductors.basic import InstationaryRBReductor
 from pymor.reductors.symplectic import QuadraticHamiltonianRBReductor
 from pymor.vectorarrays.interface import VectorArray
 from pymor.vectorarrays.numpy import NumpyVectorSpace
-from scipy.sparse import diags
 
 SYMPLECTIC_METHODS = ['cotangent_lift', 'complex_svd', 'svd_like']
 METHODS = ['pod'] + SYMPLECTIC_METHODS
 
 
 def main(
     final_time: float = Argument(10., help='Final time of the simulation'),
```

### Comparing `pymor-2022.2.1/src/pymordemos/thermalblock.py` & `pymor-2023.1.0/src/pymordemos/thermalblock.py`

 * *Files 2% similar despite different names*

```diff
@@ -83,24 +83,24 @@
     else:
         fom, fom_summary = discretize_pymor(xblocks, yblocks, grid, list_vector_array)
 
     parameter_space = fom.parameters.space(0.1, 1.)
 
     if cache_region != 'none':
         # building a cache_id is only needed for persistent CacheRegions
-        cache_id = (f"pymordemos.thermalblock {fenics} {xblocks} {yblocks}"
-                    f"{grid} {order}")
+        cache_id = (f'pymordemos.thermalblock {fenics} {xblocks} {yblocks}'
+                    f'{grid} {order}')
         fom.enable_caching(cache_region.value, cache_id)
 
     if plot_solutions:
         print('Showing some solutions')
         Us = ()
         legend = ()
         for mu in parameter_space.sample_randomly(2):
-            print(f"Solving for diffusion = \n{mu['diffusion']} ... ")
+            print(f'Solving for diffusion = \n{mu["diffusion"]} ... ')
             sys.stdout.flush()
             Us = Us + (fom.solve(mu),)
             legend = legend + (str(mu['diffusion']),)
         fom.visualize(Us, legend=legend, title='Detailed Solutions for different parameters',
                       separate_colorbars=False, block=True)
 
     print('RB generation ...')
@@ -149,19 +149,19 @@
         rom, red_summary = reduce_pod(fom=fom, reductor=reductor, parameter_space=parameter_space,
                                       snapshots_per_block=snapshots,
                                       basis_size=rbsize)
     else:
         assert False  # this should never happen
 
     if pickle:
-        print(f"\nWriting reduced model to file {pickle}_reduced ...")
+        print(f'\nWriting reduced model to file {pickle}_reduced ...')
         with open(pickle + '_reduced', 'wb') as f:
             dump((rom, parameter_space), f)
         if not fenics:  # FEniCS data structures do not support serialization
-            print(f"Writing detailed model and reductor to file {pickle}_detailed ...")
+            print(f'Writing detailed model and reductor to file {pickle}_detailed ...')
             with open(pickle + '_detailed', 'wb') as f:
                 dump((fom, reductor), f)
 
     print('\nSearching for maximum error on random snapshots ...')
 
     results = reduction_error_analysis(rom,
                                        fom=fom,
@@ -204,38 +204,38 @@
 
     # discretize using continuous finite elements
     fom, _ = discretize_stationary_cg(problem, diameter=1. / grid_num_intervals)
 
     if use_list_vector_array:
         fom = convert_to_numpy_list_vector_array(fom)
 
-    summary = f'''pyMOR model:
+    summary = f"""pyMOR model:
    number of blocks: {xblocks}x{yblocks}
    grid intervals:   {grid_num_intervals}
    ListVectorArray:  {use_list_vector_array}
-'''
+"""
 
     return fom, summary
 
 
 def discretize_fenics(xblocks, yblocks, grid_num_intervals, element_order):
     from pymor.tools import mpi
 
     if mpi.parallel:
         from pymor.models.mpi import mpi_wrap_model
         fom = mpi_wrap_model(lambda: _discretize_fenics(xblocks, yblocks, grid_num_intervals, element_order),
                              use_with=True, pickle_local_spaces=False)
     else:
         fom = _discretize_fenics(xblocks, yblocks, grid_num_intervals, element_order)
 
-    summary = f'''FEniCS model:
+    summary = f"""FEniCS model:
    number of blocks:      {xblocks}x{yblocks}
    grid intervals:        {grid_num_intervals}
    finite element order:  {element_order}
-'''
+"""
 
     return fom, summary
 
 
 def _discretize_fenics(xblocks, yblocks, grid_num_intervals, element_order):
 
     from pymor.analyticalproblems.thermalblock import thermal_block_problem
@@ -260,18 +260,18 @@
     for mu in training_set:
         reductor.extend_basis(fom.solve(mu), method='trivial')
 
     rom = reductor.reduce()
 
     elapsed_time = time.perf_counter() - tic
 
-    summary = f'''Naive basis generation:
+    summary = f"""Naive basis generation:
    basis size set: {basis_size}
    elapsed time:   {elapsed_time}
-'''
+"""
 
     return rom, summary
 
 
 def reduce_greedy(fom, reductor, parameter_space, snapshots_per_block,
                   extension_alg_name, max_extensions, use_error_estimator, pool):
 
@@ -284,22 +284,22 @@
                             extension_params={'method': extension_alg_name}, max_extensions=max_extensions,
                             pool=pool)
     rom = greedy_data['rom']
 
     # generate summary
     real_rb_size = rom.solution_space.dim
     training_set_size = len(training_set)
-    summary = f'''Greedy basis generation:
+    summary = f"""Greedy basis generation:
    size of training set:   {training_set_size}
    error estimator used:   {use_error_estimator}
    extension method:       {extension_alg_name}
    prescribed basis size:  {max_extensions}
    actual basis size:      {real_rb_size}
-   elapsed time:           {greedy_data["time"]}
-'''
+   elapsed time:           {greedy_data['time']}
+"""
 
     return rom, summary
 
 
 def reduce_adaptive_greedy(fom, reductor, parameter_space, validation_mus,
                            extension_alg_name, max_extensions, use_error_estimator,
                            rho, gamma, theta, pool):
@@ -314,22 +314,22 @@
     rom = greedy_data['rom']
 
     # generate summary
     real_rb_size = rom.solution_space.dim
     # the validation set consists of `validation_mus` random parameters plus the centers of the
     # adaptive sample set cells
     validation_mus += 1
-    summary = f'''Adaptive greedy basis generation:
+    summary = f"""Adaptive greedy basis generation:
    initial size of validation set:  {validation_mus}
    error estimator used:            {use_error_estimator}
    extension method:                {extension_alg_name}
    prescribed basis size:           {max_extensions}
    actual basis size:               {real_rb_size}
-   elapsed time:                    {greedy_data["time"]}
-'''
+   elapsed time:                    {greedy_data['time']}
+"""
 
     return rom, summary
 
 
 def reduce_pod(fom, reductor, parameter_space, snapshots_per_block, basis_size):
     from pymor.algorithms.pod import pod
 
@@ -350,19 +350,19 @@
     rom = reductor.reduce()
 
     elapsed_time = time.perf_counter() - tic
 
     # generate summary
     real_rb_size = rom.solution_space.dim
     training_set_size = len(training_set)
-    summary = f'''POD basis generation:
+    summary = f"""POD basis generation:
    size of training set:   {training_set_size}
    prescribed basis size:  {basis_size}
    actual basis size:      {real_rb_size}
    elapsed time:           {elapsed_time}
-'''
+"""
 
     return rom, summary
 
 
 if __name__ == '__main__':
     run(main)
```

### Comparing `pymor-2022.2.1/src/pymordemos/thermalblock_adaptive.py` & `pymor-2023.1.0/src/pymordemos/thermalblock_adaptive.py`

 * *Files 2% similar despite different names*

```diff
@@ -8,16 +8,16 @@
 from typer import Argument, Option, run
 
 from pymor.algorithms.adaptivegreedy import rb_adaptive_greedy
 from pymor.algorithms.error import plot_reduction_error_analysis, reduction_error_analysis
 from pymor.analyticalproblems.thermalblock import thermal_block_problem
 from pymor.core.pickle import dump
 from pymor.discretizers.builtin import discretize_stationary_cg
-from pymor.parameters.functionals import ExpressionParameterFunctional
 from pymor.parallel.default import new_parallel_pool
+from pymor.parameters.functionals import ExpressionParameterFunctional
 from pymor.reductors.coercive import CoerciveRBReductor, SimpleCoerciveRBReductor
 from pymor.tools.typer import Choices
 
 
 def main(
     rbsize: int = Argument(..., help='Size of the reduced basis.'),
 
@@ -74,23 +74,23 @@
 
     if list_vector_array:
         from pymor.discretizers.builtin.list import convert_to_numpy_list_vector_array
         fom = convert_to_numpy_list_vector_array(fom)
 
     if cache_region != 'none':
         # building a cache_id is only needed for persistent CacheRegions
-        cache_id = f"pymordemos.thermalblock_adaptive {grid}"
+        cache_id = f'pymordemos.thermalblock_adaptive {grid}'
         fom.enable_caching(cache_region.value, cache_id)
 
     if plot_solutions:
         print('Showing some solutions')
         Us = ()
         legend = ()
         for mu in problem.parameter_space.sample_randomly(2):
-            print(f"Solving for diffusion = \n{mu['diffusion']} ... ")
+            print(f'Solving for diffusion = \n{mu["diffusion"]} ... ')
             sys.stdout.flush()
             Us = Us + (fom.solve(mu),)
             legend = legend + (str(mu['diffusion']),)
         fom.visualize(Us, legend=legend, title='Detailed Solutions for different parameters', block=True)
 
     print('RB generation ...')
 
@@ -115,18 +115,18 @@
         max_extensions=rbsize,
         visualize=visualize_refinement
     )
 
     rom = greedy_data['rom']
 
     if pickle:
-        print(f"\nWriting reduced model to file {pickle}_reduced ...")
+        print(f'\nWriting reduced model to file {pickle}_reduced ...')
         with open(pickle + '_reduced', 'wb') as f:
             dump((rom, problem.parameter_space), f)
-        print(f"Writing detailed model and reductor to file {pickle}_detailed ...")
+        print(f'Writing detailed model and reductor to file {pickle}_detailed ...')
         with open(pickle + '_detailed', 'wb') as f:
             dump((fom, reductor), f)
 
     print('\nSearching for maximum error on random snapshots ...')
 
     results = reduction_error_analysis(rom,
                                        fom=fom,
@@ -136,28 +136,28 @@
                                        condition=True,
                                        test_mus=problem.parameter_space.sample_randomly(test),
                                        basis_sizes=25 if plot_error_sequence else 1,
                                        pool=pool)
 
     real_rb_size = rom.solution_space.dim
 
-    print('''
+    print("""
 *** RESULTS ***
 
 Problem:
    number of blocks:                   2x2
    h:                                  sqrt(2)/{grid}
 
 Greedy basis generation:
    error estimator enabled:            {error_estimator}
    product:                            {product}
    prescribed basis size:              {rbsize}
    actual basis size:                  {real_rb_size}
    elapsed time:                       {greedy_data[time]}
-'''.format(**locals()))
+""".format(**locals()))
     print(results['summary'])
 
     sys.stdout.flush()
 
     if plot_error_sequence:
         plot_reduction_error_analysis(results)
     if plot_err:
```

### Comparing `pymor-2022.2.1/src/pymordemos/thermalblock_simple.py` & `pymor-2023.1.0/src/pymordemos/thermalblock_simple.py`

 * *Files 9% similar despite different names*

```diff
@@ -10,17 +10,16 @@
 
 Arguments:
 """
 
 from typer import Argument, run
 
 from pymor.basic import *
-from pymor.tools.typer import Choices
 from pymor.core.config import config
-
+from pymor.tools.typer import Choices
 
 # parameters for high-dimensional models
 XBLOCKS = 2             # pyMOR/FEniCS
 YBLOCKS = 2             # pyMOR/FEniCS
 GRID_INTERVALS = 100    # pyMOR/FEniCS
 FENICS_ORDER = 2
 NGS_ORDER = 4
@@ -47,15 +46,15 @@
     # discretize
     ############
     if model == 'pymor':
         fom, parameter_space = discretize_pymor()
     elif model == 'fenics':
         fom, parameter_space = discretize_fenics()
     elif model == 'ngsolve':
-        config.require("NGSOLVE")
+        config.require('NGSOLVE')
         fom, parameter_space = discretize_ngsolve()
     elif model == 'pymor_text':
         fom, parameter_space = discretize_pymor_text()
     else:
         raise NotImplementedError
 
     # select reduction algorithm with error estimator
@@ -173,15 +172,15 @@
     bc.apply(h1_mat)
     bc.apply(F)
 
     # wrap everything as a pyMOR model
     ##################################
 
     # FEniCS wrappers
-    from pymor.bindings.fenics import FenicsVectorSpace, FenicsMatrixOperator, FenicsVisualizer
+    from pymor.bindings.fenics import FenicsMatrixOperator, FenicsVectorSpace, FenicsVisualizer
 
     # define parameter functionals (same as in pymor.analyticalproblems.thermalblock)
     parameter_functionals = [ProjectionParameterFunctional('diffusion',
                                                            size=YBLOCKS*XBLOCKS,
                                                            index=YBLOCKS - y - 1 + x*YBLOCKS)
                              for x in range(XBLOCKS) for y in range(YBLOCKS)]
 
@@ -196,44 +195,54 @@
     fom = StationaryModel(op, rhs, products={'h1_0_semi': h1_product},
                           visualizer=visualizer)
 
     return fom
 
 
 def discretize_ngsolve():
-    from ngsolve import (ngsglobals, Mesh, H1, CoefficientFunction, LinearForm, SymbolicLFI,
-                         BilinearForm, SymbolicBFI, grad, TaskManager)
-    from netgen.csg import CSGeometry, OrthoBrick, Pnt
     import numpy as np
+    from netgen.csg import CSGeometry, OrthoBrick, Pnt
+    from ngsolve import (
+        H1,
+        BilinearForm,
+        CoefficientFunction,
+        LinearForm,
+        Mesh,
+        SymbolicBFI,
+        SymbolicLFI,
+        TaskManager,
+        grad,
+        ngsglobals,
+    )
 
     ngsglobals.msg_level = 1
 
     geo = CSGeometry()
-    obox = OrthoBrick(Pnt(-1, -1, -1), Pnt(1, 1, 1)).bc("outer")
+    obox = OrthoBrick(Pnt(-1, -1, -1), Pnt(1, 1, 1)).bc('outer')
 
     b = []
-    b.append(OrthoBrick(Pnt(-1, -1, -1), Pnt(0.0, 0.0, 0.0)).mat("mat1").bc("inner"))
-    b.append(OrthoBrick(Pnt(-1,  0, -1), Pnt(0.0, 1.0, 0.0)).mat("mat2").bc("inner"))
-    b.append(OrthoBrick(Pnt(0,  -1, -1), Pnt(1.0, 0.0, 0.0)).mat("mat3").bc("inner"))
-    b.append(OrthoBrick(Pnt(0,   0, -1), Pnt(1.0, 1.0, 0.0)).mat("mat4").bc("inner"))
-    b.append(OrthoBrick(Pnt(-1, -1,  0), Pnt(0.0, 0.0, 1.0)).mat("mat5").bc("inner"))
-    b.append(OrthoBrick(Pnt(-1,  0,  0), Pnt(0.0, 1.0, 1.0)).mat("mat6").bc("inner"))
-    b.append(OrthoBrick(Pnt(0,  -1,  0), Pnt(1.0, 0.0, 1.0)).mat("mat7").bc("inner"))
-    b.append(OrthoBrick(Pnt(0,   0,  0), Pnt(1.0, 1.0, 1.0)).mat("mat8").bc("inner"))
+    b.append(OrthoBrick(Pnt(-1, -1, -1), Pnt(0.0, 0.0, 0.0)).mat('mat1').bc('inner'))
+    b.append(OrthoBrick(Pnt(-1,  0, -1), Pnt(0.0, 1.0, 0.0)).mat('mat2').bc('inner'))
+    b.append(OrthoBrick(Pnt(0,  -1, -1), Pnt(1.0, 0.0, 0.0)).mat('mat3').bc('inner'))
+    b.append(OrthoBrick(Pnt(0,   0, -1), Pnt(1.0, 1.0, 0.0)).mat('mat4').bc('inner'))
+    b.append(OrthoBrick(Pnt(-1, -1,  0), Pnt(0.0, 0.0, 1.0)).mat('mat5').bc('inner'))
+    b.append(OrthoBrick(Pnt(-1,  0,  0), Pnt(0.0, 1.0, 1.0)).mat('mat6').bc('inner'))
+    b.append(OrthoBrick(Pnt(0,  -1,  0), Pnt(1.0, 0.0, 1.0)).mat('mat7').bc('inner'))
+    b.append(OrthoBrick(Pnt(0,   0,  0), Pnt(1.0, 1.0, 1.0)).mat('mat8').bc('inner'))
     box = (obox - b[0] - b[1] - b[2] - b[3] - b[4] - b[5] - b[6] - b[7])
 
     geo.Add(box)
     for bi in b:
         geo.Add(bi)
     # domain 0 is empty!
 
     mesh = Mesh(geo.GenerateMesh(maxh=0.3))
 
     # H1-conforming finite element space
-    V = H1(mesh, order=NGS_ORDER, dirichlet="outer")
+    V = H1(mesh, order=NGS_ORDER, dirichlet='outer')
     v = V.TestFunction()
     u = V.TrialFunction()
 
     # Coeff as array: variable coefficient function (one CoefFct. per domain):
     sourcefct = CoefficientFunction([1 for i in range(9)])
 
     with TaskManager():
@@ -251,15 +260,15 @@
         for c in coeffs:
             diffusion = CoefficientFunction(c)
             a = BilinearForm(V, symmetric=False)
             a += SymbolicBFI(diffusion * grad(u) * grad(v), definedon=(np.where(np.array(c) == 1)[0] + 1).tolist())
             a.Assemble()
             mats.append(a.mat)
 
-    from pymor.bindings.ngsolve import NGSolveVectorSpace, NGSolveMatrixOperator, NGSolveVisualizer
+    from pymor.bindings.ngsolve import NGSolveMatrixOperator, NGSolveVectorSpace, NGSolveVisualizer
 
     space = NGSolveVectorSpace(V)
     op = LincombOperator([NGSolveMatrixOperator(m, space, space) for m in mats],
                          [ProjectionParameterFunctional('diffusion', len(coeffs), i) for i in range(len(coeffs))])
 
     h1_0_op = op.assemble(Mu(diffusion=[1] * len(coeffs))).with_(name='h1_0_semi')
```

### Comparing `pymor-2022.2.1/src/pymordemos/unstable_heat.py` & `pymor-2023.1.0/src/pymordemos/unstable_heat.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,18 +1,18 @@
 #!/usr/bin/env python
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
+import matplotlib.pyplot as plt
 import numpy as np
 import scipy.sparse as sps
-import matplotlib.pyplot as plt
 from typer import Argument, run
 
-
+from pymor.algorithms.timestepping import ImplicitEulerTimeStepper
 from pymor.core.logger import set_log_levels
 from pymor.models.iosys import LTIModel
 from pymor.reductors.bt import FDBTReductor
 from pymor.reductors.h2 import GapIRKAReductor
 from pymordemos.heat import fom_properties, run_mor_method
 
 
@@ -61,26 +61,20 @@
     B = np.zeros((n, 1))
     B[0, 0] = n - 1
 
     C = np.zeros((1, n))
     C[0, -1] = 1
 
     # LTI system
-    lti = LTIModel.from_matrices(A, B, C, E=E)
-
-    # Figure
-    fig = plt.figure(figsize=(12, 5), constrained_layout=True)
-    subfigs = fig.subfigures(1, 2)
-    fig.suptitle('Full-order model')
+    lti = LTIModel.from_matrices(A, B, C, E=E,
+                                 T=0.1, time_stepper=ImplicitEulerTimeStepper(100))
 
     # System properties
-    w = np.logspace(-1, 3, 100)
     w = (1e-1, 1e3)
-    fom_properties(lti, w, stable=False, fig_bode=subfigs[0], fig_poles=subfigs[1])
-    plt.show()
+    fom_properties(lti, w, stable_lti=False)
 
     # Model order reduction
     run_mor_method(lti, w, FDBTReductor(lti), 'FDBT', r, stable=False, tol=1e-5)
     run_mor_method(lti, w, GapIRKAReductor(lti), 'GapIRKA', r, stable=False, tol=1e-5)
 
 
 if __name__ == '__main__':
```

### Comparing `pymor-2022.2.1/src/pymortests/algorithms/basic.py` & `pymor-2023.1.0/src/pymortests/algorithms/basic.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,29 +1,30 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
-import pytest
 import numpy as np
-from hypothesis import given, assume, settings
+import pytest
+from hypothesis import assume, settings
 from hypothesis import strategies as hyst
 
 import pymor
 from pymor.algorithms.basic import almost_equal, project_array, relative_error
 from pymor.algorithms.gram_schmidt import gram_schmidt
+
 if pymor.config.HAVE_NGSOLVE:
     from pymor.bindings.ngsolve import NGSolveVectorSpace
 else:
     class NGSolveVectorSpace:
         pass
+import pymortests.strategies as pyst
 from pymor.operators.numpy import NumpyMatrixOperator
 from pymor.vectorarrays.numpy import NumpyVectorSpace
 from pymortests.strategies import valid_inds, valid_inds_of_same_length
 from pymortests.vectorarray import indexed
-import pymortests.strategies as pyst
 
 
 @pyst.given_vector_arrays(
     count=2,
     tolerances=hyst.sampled_from([(1e-5, 1e-8), (1e-10, 1e-12), (0., 1e-8), (1e-5, 1e-8)]),
     sup_norm=hyst.booleans(),
 )
@@ -165,26 +166,29 @@
     for ind1, ind2 in valid_inds_of_same_length(v1, v2):
         for sup_norm in (False, True):
             c1, c2 = v1.copy(), v2.copy()
             with pytest.raises(Exception):
                 almost_equal(c1[ind1], c2[ind2], sup_norm=sup_norm)
 
 
-@given(pyst.base_vector_arrays(count=2))
 @settings(deadline=None)
-def test_project_array(arrays):
-    U, basis = arrays
-    U_p = project_array(U, basis, orthonormal=False)
+@pyst.given_vector_arrays(count=2)
+def test_project_array(vector_arrays):
+    U, basis = vector_arrays
     onb = gram_schmidt(basis)
+    if len(onb) < len(basis):
+        return
+    U_p = project_array(U, basis, orthonormal=False)
     U_p2 = project_array(U, onb, orthonormal=True)
     err = relative_error(U_p, U_p2)
-    tol = np.finfo(np.float64).eps * np.linalg.cond(basis.gramian()) * 100.
-    assert np.all(err < tol)
+    tol = 0 if len(basis) == 0 else np.finfo(np.float64).eps * np.linalg.cond(basis.gramian()) * 100.
+    assert np.all(err <= tol)
 
 
+@pytest.mark.builtin
 def test_project_array_with_product():
     U = NumpyVectorSpace.from_numpy(np.random.random((1, 10)))
     basis = NumpyVectorSpace.from_numpy(np.random.random((3, 10)))
     product = np.random.random((10, 10))
     product = NumpyMatrixOperator(product.T.dot(product))
     U_p = project_array(U, basis, product=product, orthonormal=False)
     onb = gram_schmidt(basis, product=product)
```

### Comparing `pymor-2022.2.1/src/pymortests/algorithms/bernoulli.py` & `pymor-2023.1.0/src/pymortests/algorithms/bernoulli.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,23 +1,23 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 import numpy as np
+import pytest
 import scipy.linalg as spla
 import scipy.sparse as sps
 from scipy.stats import ortho_group
 
 from pymor.algorithms.bernoulli import bernoulli_stabilize, solve_bernoulli
 from pymor.algorithms.to_matrix import to_matrix
 from pymor.operators.constructions import LowRankOperator
 from pymor.operators.numpy import NumpyMatrixOperator
 
-import pytest
-
+pytestmark = pytest.mark.builtin
 
 n_list = [10, 20, 30]
 
 
 @pytest.mark.parametrize('n', n_list)
 @pytest.mark.parametrize('with_E', [False, True])
 @pytest.mark.parametrize('trans', [False, True])
```

### Comparing `pymor-2022.2.1/src/pymortests/algorithms/ei.py` & `pymor-2023.1.0/src/pymortests/algorithms/ei.py`

 * *Files 2% similar despite different names*

```diff
@@ -3,15 +3,15 @@
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 import numpy as np
 
 from pymor.algorithms.pod import pod
 from pymor.operators.ei import EmpiricalInterpolatedOperator
 from pymor.reductors.basic import StationaryRBReductor
-from pymortests.base import runmodule, assert_all_almost_equal
+from pymortests.base import assert_all_almost_equal, runmodule
 
 
 def test_ei_restricted_to_full(stationary_models):
     model = stationary_models
     op = model.operator
     cb = op.range.from_numpy(np.eye(op.range.dim))
     dofs = list(range(cb.dim))
@@ -53,9 +53,9 @@
     rom = reductor.reduce()
     for mu, u in zip(base_mus, U):
         ru = rom.solve(mu)
         ru_rec = reductor.reconstruct(ru)
         assert_all_almost_equal(u, ru_rec, rtol=1e-10)
 
 
-if __name__ == "__main__":
+if __name__ == '__main__':
     runmodule(filename=__file__)
```

### Comparing `pymor-2022.2.1/src/pymortests/algorithms/eigs.py` & `pymor-2023.1.0/src/pymortests/algorithms/eigs.py`

 * *Files 8% similar despite different names*

```diff
@@ -5,14 +5,16 @@
 import numpy as np
 import pytest
 import scipy.sparse as sps
 
 from pymor.algorithms.eigs import eigs
 from pymor.operators.numpy import NumpyMatrixOperator
 
+pytestmark = pytest.mark.builtin
+
 n_list = [100, 200]
 k_list = [1, 7]
 sigma_list = [None, 0]
 
 
 @pytest.mark.parametrize('n', n_list)
 @pytest.mark.parametrize('k', k_list)
```

### Comparing `pymor-2022.2.1/src/pymortests/algorithms/gram_schmidt.py` & `pymor-2023.1.0/src/pymortests/algorithms/gram_schmidt.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,24 +1,23 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 import numpy as np
-from hypothesis import settings, assume, given
+import pytest
+from hypothesis import assume, settings
 
-from pymor.algorithms.basic import almost_equal
+import pymortests.strategies as pyst
+from pymor.algorithms.basic import almost_equal, contains_zero_vector
 from pymor.algorithms.gram_schmidt import gram_schmidt, gram_schmidt_biorth
 from pymor.core.logger import log_levels
-from pymor.algorithms.basic import contains_zero_vector
 from pymortests.base import runmodule
-import pymortests.strategies as pyst
 
 
 @pyst.given_vector_arrays()
-@settings(deadline=20000)
 def test_gram_schmidt(vector_array):
     U = vector_array
     # TODO assumption here masks a potential issue with the algorithm
     #      where it fails in del instead of a proper error
     assume(len(U) > 1 or not contains_zero_vector(U))
 
     V = U.copy()
@@ -82,30 +81,43 @@
 
     onb2, R2 = gram_schmidt(U, product=p, return_R=True, copy=False)
     assert np.all(almost_equal(onb, onb2))
     assert np.all(R == R2)
     assert np.all(almost_equal(onb, U))
 
 
-@given(pyst.base_vector_arrays(count=2))
 @settings(deadline=None)
+@pyst.given_vector_arrays(count=2)
 def test_gram_schmidt_biorth(vector_arrays):
     U1, U2 = vector_arrays
 
+    if len(U1) != len(U2):
+        with pytest.raises(Exception):
+            A1, A2 = gram_schmidt_biorth(U1, U2, copy=True)
+        return
+
+    onb1 = gram_schmidt(U1)
+    if len(onb1) < len(U1):
+        return
+    onb2 = gram_schmidt(U2)
+    if len(onb2) < len(U2):
+        return
+
     V1 = U1.copy()
     V2 = U2.copy()
 
     # this is the default used in gram_schmidt_biorth
     check_tol = 1e-3
     with log_levels({'pymor.algorithms.gram_schmidt.gram_schmidt_biorth': 'ERROR'}):
         A1, A2 = gram_schmidt_biorth(U1, U2, copy=True, check_tol=check_tol)
     assert np.all(almost_equal(U1, V1))
     assert np.all(almost_equal(U2, V2))
     assert np.allclose(A2.inner(A1), np.eye(len(A1)), atol=check_tol)
-    c = np.linalg.cond(A1.to_numpy()) * np.linalg.cond(A2.to_numpy())
+    c = (1 if len(A1) == 0 else np.linalg.cond(A1.to_numpy())) \
+        * (1 if len(A2) == 0 else np.linalg.cond(A2.to_numpy()))
     assert np.all(almost_equal(U1, A1.lincomb(A2.inner(U1).T), rtol=c * 1e-14))
     assert np.all(almost_equal(U2, A2.lincomb(A1.inner(U2).T), rtol=c * 1e-14))
 
     with log_levels({'pymor.algorithms.gram_schmidt.gram_schmidt_biorth': 'ERROR'}):
         B1, B2 = gram_schmidt_biorth(U1, U2, copy=False)
     assert np.all(almost_equal(A1, B1))
     assert np.all(almost_equal(A2, B2))
@@ -137,9 +149,9 @@
     B1, B2 = gram_schmidt_biorth(U1, U2, product=p, copy=False)
     assert np.all(almost_equal(A1, B1))
     assert np.all(almost_equal(A2, B2))
     assert np.all(almost_equal(A1, U1))
     assert np.all(almost_equal(A2, U2))
 
 
-if __name__ == "__main__":
+if __name__ == '__main__':
     runmodule(filename=__file__)
```

### Comparing `pymor-2022.2.1/src/pymortests/algorithms/lyapunov.py` & `pymor-2023.1.0/src/pymortests/algorithms/lyapunov.py`

 * *Files 13% similar despite different names*

```diff
@@ -7,20 +7,22 @@
 import numpy as np
 import pytest
 import scipy.linalg as spla
 import scipy.sparse as sps
 
 from pymor.algorithms.lyapunov import (
     solve_cont_lyap_dense,
-    solve_disc_lyap_dense,
     solve_cont_lyap_lrcf,
+    solve_disc_lyap_dense,
     solve_disc_lyap_lrcf,
 )
+from pymor.core.config import config
 from pymor.operators.numpy import NumpyMatrixOperator
-from pymortests.base import skip_if_missing
+
+pytestmark = pytest.mark.builtin
 
 n_list_small = [10, 20]
 n_list_big = [300]
 m_list = [1, 2]
 cont_lyap_lrcf_solver_list = [
     'pymess_lradi',
     'lradi',
@@ -32,14 +34,21 @@
 ]
 disc_lyap_dense_solver_list = [
     'scipy',
     'slycot_bartels-stewart',
 ]
 
 
+def skip_if_missing_solver(solver):
+    if solver.startswith('slycot') and not config.HAVE_SLYCOT:
+        pytest.skip('slycot unavailable')
+    if solver.startswith('pymess') and not config.HAVE_PYMESS:
+        pytest.skip('pymess unavailable')
+
+
 def fro_norm(A):
     if not sps.issparse(A):
         return spla.norm(A)
     else:
         return sps.linalg.norm(A)
 
 
@@ -116,99 +125,99 @@
                 rhs = fro_norm(CTC)
     return res / rhs
 
 
 @pytest.mark.parametrize('m', m_list)
 @pytest.mark.parametrize('with_E', [False, True])
 @pytest.mark.parametrize('trans', [False, True])
-@pytest.mark.parametrize('n,lyap_solver', chain(product(n_list_small, cont_lyap_dense_solver_list),
-                                                product(n_list_big, cont_lyap_lrcf_solver_list)))
-@skip_if_missing('SLYCOT')
-@skip_if_missing('PYMESS')
-def test_cont_lrcf(n, m, with_E, trans, lyap_solver):
+@pytest.mark.parametrize('n,solver', chain(product(n_list_small, cont_lyap_dense_solver_list),
+                                           product(n_list_big, cont_lyap_lrcf_solver_list)))
+def test_cont_lrcf(n, m, with_E, trans, solver):
+    skip_if_missing_solver(solver)
+
     if not with_E:
         A = conv_diff_1d_fd(n, 1, 0.1, cont_time=True)
         E = None
     else:
         A, E = conv_diff_1d_fem(n, 1, 0.1, cont_time=True)
     B = np.random.randn(n, m)
     if trans:
         B = B.T
 
     Aop = NumpyMatrixOperator(A)
     Eop = NumpyMatrixOperator(E) if with_E else None
     Bva = Aop.source.from_numpy(B.T if not trans else B)
 
-    Zva = solve_cont_lyap_lrcf(Aop, Eop, Bva, trans=trans, options=lyap_solver)
+    Zva = solve_cont_lyap_lrcf(Aop, Eop, Bva, trans=trans, options=solver)
     assert len(Zva) <= n
 
     Z = Zva.to_numpy().T
     assert relative_residual(A, E, B, Z @ Z.T, trans=trans, cont_time=True) < 1e-10
 
 
 @pytest.mark.parametrize('n', n_list_small)
 @pytest.mark.parametrize('m', m_list)
 @pytest.mark.parametrize('with_E', [False, True])
 @pytest.mark.parametrize('trans', [False, True])
-@pytest.mark.parametrize('lyap_solver', disc_lyap_dense_solver_list)
-@skip_if_missing('SLYCOT')
-@skip_if_missing('PYMESS')
-def test_disc_lrcf(n, m, with_E, trans, lyap_solver):
+@pytest.mark.parametrize('solver', disc_lyap_dense_solver_list)
+def test_disc_lrcf(n, m, with_E, trans, solver):
+    skip_if_missing_solver(solver)
+
     if not with_E:
         A = conv_diff_1d_fd(n, 1, 0.1, cont_time=False)
         E = None
     else:
         A, E = conv_diff_1d_fem(n, 1, 0.1, cont_time=False)
 
     B = np.random.randn(n, m)
     if trans:
         B = B.T
 
     Aop = NumpyMatrixOperator(A)
     Eop = NumpyMatrixOperator(E) if with_E else None
     Bva = Aop.source.from_numpy(B.T if not trans else B)
 
-    Zva = solve_disc_lyap_lrcf(Aop, Eop, Bva, trans=trans, options=lyap_solver)
+    Zva = solve_disc_lyap_lrcf(Aop, Eop, Bva, trans=trans, options=solver)
     assert len(Zva) <= n
 
     Z = Zva.to_numpy().T
     assert relative_residual(A, E, B, Z @ Z.T, trans=trans, cont_time=False) < 1e-10
 
 
 @pytest.mark.parametrize('n', n_list_small)
 @pytest.mark.parametrize('m', m_list)
 @pytest.mark.parametrize('with_E', [False, True])
 @pytest.mark.parametrize('trans', [False, True])
-@pytest.mark.parametrize('lyap_solver', cont_lyap_dense_solver_list)
-@skip_if_missing('SLYCOT')
-@skip_if_missing('PYMESS')
-def test_cont_dense(n, m, with_E, trans, lyap_solver):
+@pytest.mark.parametrize('solver', cont_lyap_dense_solver_list)
+def test_cont_dense(n, m, with_E, trans, solver):
+    skip_if_missing_solver(solver)
+
     A = np.random.randn(n, n)
     E = np.eye(n) + np.random.randn(n, n) / n if with_E else None
     B = np.random.randn(n, m)
     if trans:
         B = B.T
 
-    X = solve_cont_lyap_dense(A, E, B, trans=trans, options=lyap_solver)
+    X = solve_cont_lyap_dense(A, E, B, trans=trans, options=solver)
     assert type(X) is np.ndarray
 
     assert relative_residual(A, E, B, X, trans=trans, cont_time=True) < 1e-10
 
 
 @pytest.mark.parametrize('n', n_list_small)
 @pytest.mark.parametrize('m', m_list)
 @pytest.mark.parametrize('with_E', [False, True])
 @pytest.mark.parametrize('trans', [False, True])
-@pytest.mark.parametrize('lyap_solver', disc_lyap_dense_solver_list)
-@skip_if_missing('SLYCOT')
-@skip_if_missing('PYMESS')
-def test_disc_dense(n, m, with_E, trans, lyap_solver):
+@pytest.mark.parametrize('solver', disc_lyap_dense_solver_list)
+def test_disc_dense(n, m, with_E, trans, solver):
+    skip_if_missing_solver(solver)
+
     A = np.random.randn(n, n)
     E = np.eye(n) + np.random.randn(n, n) / n if with_E else None
     B = np.random.randn(n, m)
     if trans:
         B = B.T
 
-    X = solve_disc_lyap_dense(A, E, B, trans=trans, options=lyap_solver)
+    X = solve_disc_lyap_dense(A, E, B, trans=trans, options=solver)
     assert type(X) is np.ndarray
 
     assert relative_residual(A, E, B, X, trans=trans, cont_time=False) < 1e-10
```

### Comparing `pymor-2022.2.1/src/pymortests/algorithms/pod.py` & `pymor-2023.1.0/src/pymortests/algorithms/pod.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,19 +1,18 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 import numpy as np
 import pytest
-from hypothesis import assume, settings, HealthCheck
+from hypothesis import HealthCheck, assume, settings
 from hypothesis.strategies import sampled_from
 
-from pymor.algorithms.basic import almost_equal
+from pymor.algorithms.basic import almost_equal, contains_zero_vector
 from pymor.algorithms.pod import pod
-from pymor.algorithms.basic import contains_zero_vector
 from pymor.core.logger import log_levels
 from pymortests.strategies import given_vector_arrays
 
 methods = ['method_of_snapshots', 'qr_svd']
 
 
 @settings(deadline=None, suppress_health_check=[HealthCheck.filter_too_much,
@@ -36,12 +35,12 @@
 
 
 @pytest.mark.parametrize('method', methods)
 def test_pod_with_product(operator_with_arrays_and_products, method):
     _, _, A, _, p, _ = operator_with_arrays_and_products
 
     B = A.copy()
-    with log_levels({"pymor.algorithms": "ERROR"}):
+    with log_levels({'pymor.algorithms': 'ERROR'}):
         U, s = pod(A, product=p, method=method)
     assert np.all(almost_equal(A, B))
     assert len(U) == len(s)
     assert np.allclose(U.gramian(p), np.eye(len(s)))
```

### Comparing `pymor-2022.2.1/src/pymortests/algorithms/projection.py` & `pymor-2023.1.0/src/pymortests/algorithms/projection.py`

 * *Files 18% similar despite different names*

```diff
@@ -7,50 +7,66 @@
 from pymor.algorithms.basic import almost_equal
 from pymor.algorithms.projection import project, project_to_subbasis
 
 
 def test_project(operator_with_arrays):
     op, mu, U, V = operator_with_arrays
     op_UV = project(op, V, U)
+    assert op_UV.name == op_UV.__class__.__name__
     coeffs = np.random.random(len(U))
     X = op_UV.apply(op_UV.source.make_array(coeffs), mu=mu)
     Y = op_UV.range.make_array(V.inner(op.apply(U.lincomb(coeffs), mu=mu)).T)
     assert np.all(almost_equal(X, Y))
 
 
+def test_project_no_bases(operator):
+    op, _ = operator
+    op_proj = project(op, None, None)
+    assert op_proj is op
+
+
 def test_project_2(operator_with_arrays):
     op, mu, U, V = operator_with_arrays
     op_U = project(op, None, U)
+    assert op_U.name == op_U.__class__.__name__
     op_V = project(op, V, None)
+    assert op_V.name == op_V.__class__.__name__
     op_U_V = project(op_U, V, None)
+    assert op_U_V.name == op_U_V.__class__.__name__
     op_V_U = project(op_V, None, U)
+    assert op_V_U.name == op_V_U.__class__.__name__
     op_UV = project(op, V, U)
     W = op_UV.source.make_array(np.random.random(len(U)))
     Y0 = op_UV.apply(W, mu=mu)
     Y1 = op_U_V.apply(W, mu=mu)
     Y2 = op_V_U.apply(W, mu=mu)
     assert np.all(almost_equal(Y0, Y1))
     assert np.all(almost_equal(Y0, Y2))
 
 
 def test_project_with_product(operator_with_arrays_and_products):
     op, mu, U, V, sp, rp = operator_with_arrays_and_products
     op_UV = project(op, V, U, product=rp)
+    assert op_UV.name == op_UV.__class__.__name__
     coeffs = np.random.random(len(U))
     X = op_UV.apply(op_UV.source.make_array(coeffs), mu=mu)
     Y = op_UV.range.make_array(rp.apply2(op.apply(U.lincomb(coeffs), mu=mu), V))
     assert np.all(almost_equal(X, Y))
 
 
 def test_project_with_product_2(operator_with_arrays_and_products):
     op, mu, U, V, sp, rp = operator_with_arrays_and_products
     op_U = project(op, None, U)
+    assert op_U.name == op_U.__class__.__name__
     op_V = project(op, V, None, product=rp)
+    assert op_V.name == op_V.__class__.__name__
     op_U_V = project(op_U, V, None, product=rp)
+    assert op_U_V.name == op_U_V.__class__.__name__
     op_V_U = project(op_V, None, U)
+    assert op_V_U.name == op_V_U.__class__.__name__
     op_UV = project(op, V, U, product=rp)
     W = op_UV.source.make_array(np.random.random(len(U)))
     Y0 = op_UV.apply(W, mu=mu)
     Y1 = op_U_V.apply(W, mu=mu)
     Y2 = op_V_U.apply(W, mu=mu)
     assert np.all(almost_equal(Y0, Y1))
     assert np.all(almost_equal(Y0, Y2))
@@ -59,14 +75,15 @@
 def test_project_to_subbasis(operator_with_arrays):
     op, mu, U, V = operator_with_arrays
     op_UV = project(op, V, U)
 
     for dim_range in {None, 0, len(V)//2, len(V)}:
         for dim_source in {None, 0, len(U)//2, len(U)}:
             op_UV_sb = project_to_subbasis(op_UV, dim_range, dim_source)
+            assert op_UV_sb.name == op_UV.name
 
             assert op_UV_sb.range.dim == (op_UV.range.dim if dim_range is None else dim_range)
             assert op_UV_sb.source.dim == (op_UV.source.dim if dim_source is None else dim_source)
 
             range_basis = V if dim_range is None else V[:dim_range]
             source_basis = U if dim_source is None else U[:dim_source]
 
@@ -80,14 +97,15 @@
 
 def test_project_to_subbasis_no_range_basis(operator_with_arrays):
     op, mu, U, V = operator_with_arrays
     op_U = project(op, None, U)
 
     for dim_source in {None, 0, len(U)//2, len(U)}:
         op_U_sb = project_to_subbasis(op_U, None, dim_source)
+        assert op_U_sb.name == op_U.name
 
         assert op_U_sb.range == op_U.range
         assert op_U_sb.source.dim == (op_U.source.dim if dim_source is None else dim_source)
 
         source_basis = U if dim_source is None else U[:dim_source]
 
         op_U_sb2 = project(op, None, source_basis)
@@ -100,14 +118,15 @@
 
 def test_project_to_subbasis_no_source_basis(operator_with_arrays):
     op, mu, U, V = operator_with_arrays
     op_V = project(op, V, None)
 
     for dim_range in {None, 0, len(V)//2, len(V)}:
         op_V_sb = project_to_subbasis(op_V, dim_range, None)
+        assert op_V_sb.name == op_V.name
 
         assert op_V_sb.range.dim == (op_V.range.dim if dim_range is None else dim_range)
         assert op_V_sb.source == op_V.source
 
         range_basis = V if dim_range is None else V[:dim_range]
 
         op_V_sb2 = project(op, range_basis, None)
```

### Comparing `pymor-2022.2.1/src/pymortests/algorithms/rand_la.py` & `pymor-2023.1.0/src/pymortests/algorithms/rand_la.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,18 +1,21 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 import numpy as np
+import pytest
 import scipy as sp
 from numpy.random import uniform
 
-from pymor.algorithms.rand_la import rrf, adaptive_rrf, random_ghep, random_generalized_svd
-from pymor.operators.numpy import NumpyMatrixOperator
+from pymor.algorithms.rand_la import adaptive_rrf, random_generalized_svd, random_ghep, rrf
 from pymor.operators.constructions import VectorArrayOperator
+from pymor.operators.numpy import NumpyMatrixOperator
+
+pytestmark = pytest.mark.builtin
 
 
 def test_adaptive_rrf():
     A = uniform(low=-1.0, high=1.0, size=(100, 100))
     A = A @ A.T
     range_product = NumpyMatrixOperator(A)
```

### Comparing `pymor-2022.2.1/src/pymortests/algorithms/riccati.py` & `pymor-2023.1.0/src/pymortests/algorithms/riccati.py`

 * *Files 26% similar despite different names*

```diff
@@ -7,16 +7,18 @@
 import numpy as np
 import pytest
 import scipy.linalg as spla
 
 from pymor.algorithms.lyapunov import _chol
 from pymor.algorithms.riccati import solve_pos_ricc_lrcf, solve_ricc_dense, solve_ricc_lrcf
 from pymor.operators.numpy import NumpyMatrixOperator
-from pymortests.algorithms.lyapunov import conv_diff_1d_fd, conv_diff_1d_fem, fro_norm
-from pymortests.base import skip_if_missing
+from pymortests.algorithms.lyapunov import conv_diff_1d_fd, conv_diff_1d_fem, fro_norm, skip_if_missing_solver
+
+pytestmark = pytest.mark.builtin
+
 
 n_list_small = [10, 20]
 n_list_big = [250]
 m_list = [1, 2]
 p_list = [1, 2]
 ricc_lrcf_solver_list_small = [
     'scipy',
@@ -29,32 +31,36 @@
 ]
 ricc_dense_solver_list = [
     'scipy',
     'slycot'
 ]
 
 
-def relative_residual(A, E, B, C, R, Z, trans):
+def relative_residual(A, E, B, C, R, S, Z, trans):
     if not trans:
         if E is None:
             linear = A @ Z @ Z.T
             quadratic = Z
         else:
             linear = A @ Z @ (Z.T @ E.T)
             quadratic = E @ Z
         quadratic = quadratic @ (Z.T @ C.T)
+        if S is not None:
+            quadratic = quadratic + S.T
         RHS = B @ B.T
     else:
         if E is None:
             linear = A.T @ Z @ Z.T
             quadratic = Z
         else:
             linear = A.T @ Z @ (Z.T @ E)
             quadratic = E.T @ Z
         quadratic = quadratic @ (Z.T @ B)
+        if S is not None:
+            quadratic = quadratic + S
         RHS = C.T @ C
     linear += linear.T
     if R is None:
         quadratic = quadratic @ quadratic.T
     else:
         quadratic = quadratic @ spla.solve(R, quadratic.T)
     res = fro_norm(linear - quadratic + RHS)
@@ -62,114 +68,127 @@
     return res / rhs
 
 
 @pytest.mark.parametrize('m', m_list)
 @pytest.mark.parametrize('p', p_list)
 @pytest.mark.parametrize('with_E', [False, True])
 @pytest.mark.parametrize('with_R', [False, True])
+@pytest.mark.parametrize('with_S', [False, True])
 @pytest.mark.parametrize('trans', [False, True])
 @pytest.mark.parametrize('n', n_list_small)
 @pytest.mark.parametrize('solver', ricc_dense_solver_list)
-@skip_if_missing('SLYCOT')
-@skip_if_missing('PYMESS')
-def test_ricc_dense(n, m, p, with_E, with_R, trans, solver):
+def test_ricc_dense(n, m, p, with_E, with_R, with_S, trans, solver):
+    skip_if_missing_solver(solver)
+
     if not with_E:
         A = conv_diff_1d_fd(n, 1, 1)
         A = A.todense()
         E = None
     else:
         A, E = conv_diff_1d_fem(n, 1, 1)
         A = A.todense()
         E = E.todense()
     B = np.random.randn(n, m)
     C = np.random.randn(p, n)
     D = np.random.randn(p, m)
     if not trans:
         R0 = np.random.randn(p, p)
         R = D.dot(D.T) + R0.dot(R0.T) if with_R else None
+        S = 1e-1 * D @ B.T if with_S else None
     else:
         R0 = np.random.randn(m, m)
         R = D.T.dot(D) + R0.dot(R0.T) if with_R else None
+        S = 1e-1 * C.T @ D if with_S else None
 
-    X = solve_ricc_dense(A, E, B, C, R, trans=trans, options=solver)
+    X = solve_ricc_dense(A, E, B, C, R, S, trans=trans, options=solver)
 
-    assert relative_residual(A, E, B, C, R, _chol(X), trans) < 1e-8
+    assert relative_residual(A, E, B, C, R, S, _chol(X), trans) < 1e-8
 
 
 @pytest.mark.parametrize('m', m_list)
 @pytest.mark.parametrize('p', p_list)
 @pytest.mark.parametrize('with_E', [False, True])
 @pytest.mark.parametrize('with_R', [False, True])
+@pytest.mark.parametrize('with_S', [False, True])
 @pytest.mark.parametrize('trans', [False, True])
 @pytest.mark.parametrize('n,solver', chain(product(n_list_small, ricc_lrcf_solver_list_small),
                                            product(n_list_big, ricc_lrcf_solver_list_big)))
-@skip_if_missing('SLYCOT')
-@skip_if_missing('PYMESS')
-def test_ricc_lrcf(n, m, p, with_E, with_R, trans, solver):
+def test_ricc_lrcf(n, m, p, with_E, with_R, with_S, trans, solver):
+    skip_if_missing_solver(solver)
+    if with_S and (solver.startswith('pymess') or solver == 'lrradi'):
+        pytest.xfail('solver not implemented')
+
     if not with_E:
         A = conv_diff_1d_fd(n, 1, 1)
         E = None
     else:
         A, E = conv_diff_1d_fem(n, 1, 1)
     B = np.random.randn(n, m)
     C = np.random.randn(p, n)
     D = np.random.randn(p, m)
     if not trans:
         R0 = np.random.randn(p, p)
         R = D.dot(D.T) + R0.dot(R0.T) if with_R else None
+        S = 1e-1 * D @ B.T if with_S else None
     else:
         R0 = np.random.randn(m, m)
         R = D.T.dot(D) + R0.dot(R0.T) if with_R else None
+        S = 1e-1 * C.T @ D if with_S else None
 
     Aop = NumpyMatrixOperator(A)
     Eop = NumpyMatrixOperator(E) if with_E else None
     Bva = Aop.source.from_numpy(B.T)
     Cva = Aop.source.from_numpy(C)
+    Sva = Aop.source.from_numpy((S if not trans else S.T)) if with_S else None
 
-    try:
-        Zva = solve_ricc_lrcf(Aop, Eop, Bva, Cva, R, trans=trans, options=solver)
-    except NotImplementedError:
-        return
+    Zva = solve_ricc_lrcf(Aop, Eop, Bva, Cva, R, Sva, trans=trans, options=solver)
 
     assert len(Zva) <= n
 
     Z = Zva.to_numpy().T
-    assert relative_residual(A, E, B, C, R, Z, trans) < 1e-8
+    assert relative_residual(A, E, B, C, R, S, Z, trans) < 1e-8
 
 
 @pytest.mark.parametrize('n', n_list_small)
 @pytest.mark.parametrize('m', m_list)
 @pytest.mark.parametrize('p', p_list)
 @pytest.mark.parametrize('with_E', [False, True])
 @pytest.mark.parametrize('with_R', [False, True])
+@pytest.mark.parametrize('with_S', [False, True])
 @pytest.mark.parametrize('trans', [False, True])
 @pytest.mark.parametrize('solver', ricc_lrcf_solver_list_small)
-@skip_if_missing('SLYCOT')
-@skip_if_missing('PYMESS')
-def test_pos_ricc_lrcf(n, m, p, with_E, with_R, trans, solver):
+def test_pos_ricc_lrcf(n, m, p, with_E, with_R, with_S, trans, solver):
+    skip_if_missing_solver(solver)
+    if with_S and solver.startswith('pymess'):
+        pytest.xfail('solver not implemented')
+
     if not with_E:
         A = conv_diff_1d_fd(n, 1, 1)
         E = None
     else:
         A, E = conv_diff_1d_fem(n, 1, 1)
     B = np.random.randn(n, m)
     C = np.random.randn(p, n)
     D = np.random.randn(p, m)
     if not trans:
         R0 = np.random.randn(p, p)
         R = D.dot(D.T) + 10 * R0.dot(R0.T) if with_R else None
+        S = np.random.randn(p,n) if with_S else None
     else:
         R0 = np.random.randn(m, m)
         R = D.T.dot(D) + 10 * R0.dot(R0.T) if with_R else None
+        S = np.random.randn(n,m) if with_S else None
 
     Aop = NumpyMatrixOperator(A)
     Eop = NumpyMatrixOperator(E) if with_E else None
     Bva = Aop.source.from_numpy(B.T)
     Cva = Aop.source.from_numpy(C)
+    Sva = Aop.source.from_numpy((S if not trans else S.T)) if with_S else None
+
+    Zva = solve_pos_ricc_lrcf(Aop, Eop, Bva, Cva, R, Sva, trans=trans, options=solver)
 
-    Zva = solve_pos_ricc_lrcf(Aop, Eop, Bva, Cva, R, trans=trans, options=solver)
     assert len(Zva) <= n
 
     Z = Zva.to_numpy().T
     if not with_R:
         R = np.eye(p if not trans else m)
-    assert relative_residual(A, E, B, C, -R, Z, trans) < 1e-8
+    assert relative_residual(A, E, B, C, -R, S, Z, trans) < 1e-8
```

### Comparing `pymor-2022.2.1/src/pymortests/algorithms/samdp.py` & `pymor-2023.1.0/src/pymortests/algorithms/samdp.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,18 +1,20 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 import numpy as np
+import pytest
 import scipy.sparse as sps
 
 from pymor.algorithms.samdp import samdp
 from pymor.operators.numpy import NumpyMatrixOperator
 
-import pytest
+pytestmark = pytest.mark.builtin
+
 
 n_list = [50, 100]
 m_list = [1, 2]
 k_list = [2, 3]
 wanted_list = [15, 20]
 which_list = ['NR', 'NS', 'NM']
 
@@ -59,12 +61,13 @@
     Bva = Aop.source.from_numpy(B.T)
     Cva = Aop.source.from_numpy(C)
 
     dom_poles, dom_res, dom_rev, dom_lev = samdp(Aop, Eop, Bva, Cva, wanted, which=which)
 
     # check if we computed correct eigenvalues
     if not with_E:
-        assert np.sum((Aop.apply(dom_rev) - dom_poles * dom_rev).norm()) < 1e-4
-        assert np.sum((Aop.apply_adjoint(dom_lev) - dom_poles * dom_lev).norm()) < 1e-4
+        assert np.sum((Aop.apply(dom_rev) - dom_poles * dom_rev).norm() / dom_rev.norm()) < 1e-3
+        assert np.sum((Aop.apply_adjoint(dom_lev) - dom_poles * dom_lev).norm() / dom_lev.norm()) < 1e-3
     else:
-        assert np.sum((Aop.apply(dom_rev) - dom_poles * Eop.apply(dom_rev)).norm()) < 1e-4
-        assert np.sum((Aop.apply_adjoint(dom_lev) - dom_poles * Eop.apply_adjoint(dom_lev)).norm()) < 1e-4
+        assert np.sum((Aop.apply(dom_rev) - dom_poles * Eop.apply(dom_rev)).norm() / dom_rev.norm()) < 1e-3
+        assert np.sum((Aop.apply_adjoint(dom_lev)
+               - dom_poles * Eop.apply_adjoint(dom_lev)).norm() / dom_lev.norm()) < 1e-3
```

### Comparing `pymor-2022.2.1/src/pymortests/algorithms/simplify.py` & `pymor-2023.1.0/src/pymortests/algorithms/simplify.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,25 +1,28 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 from itertools import product
 
 import numpy as np
+import pytest
 
 from pymor.algorithms.basic import almost_equal
+from pymor.algorithms.simplify import contract, expand
 from pymor.algorithms.to_matrix import to_matrix
-from pymor.algorithms.simplify import expand, contract
-from pymor.operators.constructions import LincombOperator, ConcatenationOperator
+from pymor.operators.constructions import ConcatenationOperator, LincombOperator
 from pymor.operators.numpy import NumpyMatrixOperator
 from pymor.parameters.functionals import ProjectionParameterFunctional
 
+pytestmark = pytest.mark.builtin
+
 
 def test_expand():
-    ops = [NumpyMatrixOperator(np.eye(1) * i) for i in range(8)]
+    ops = [NumpyMatrixOperator(np.eye(1) * i, source_id='id', range_id='id') for i in range(8)]
     pfs = [ProjectionParameterFunctional('p', 9, i) for i in range(8)]
     prods = [o * p for o, p in zip(ops, pfs)]
 
     op = ((prods[0] + prods[1] + prods[2]) @ (prods[3] + prods[4] + prods[5]) @
           (prods[6] + prods[7]))
 
     eop = expand(op)
@@ -37,15 +40,15 @@
 def test_expand_matrix_operator():
     # MWE from #1656
     op = expand(NumpyMatrixOperator(np.zeros((0, 0))))
     assert isinstance(op, NumpyMatrixOperator)
 
 
 def test_contract():
-    ops = [NumpyMatrixOperator(np.eye(1) * i) for i in range(1, 6)]
+    ops = [NumpyMatrixOperator(np.eye(1) * i, source_id='id', range_id='id') for i in range(1, 6)]
     pf = ProjectionParameterFunctional('p', 1, 0)
 
     op = (ops[0] * pf) @ (ops[1] + ops[2]) @ ops[3] @ (ops[4] * pf)
 
     U = op.source.ones(1)
     mu = op.parameters.parse(1)
```

### Comparing `pymor-2022.2.1/src/pymortests/algorithms/solver.py` & `pymor-2023.1.0/src/pymortests/algorithms/solver.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,21 +1,23 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 import numpy as np
-from scipy.sparse import diags
 import pytest
+from scipy.sparse import diags
 
 import pymor.algorithms.genericsolvers
 from pymor.bindings.scipy import solver_options as scipy_solver_options
 from pymor.operators.interface import Operator
 from pymor.operators.numpy import NumpyMatrixOperator
 from pymor.vectorarrays.numpy import NumpyVectorSpace
 
+pytestmark = pytest.mark.builtin
+
 
 class GenericOperator(Operator):
 
     source = range = NumpyVectorSpace(10)
     op = NumpyMatrixOperator(np.eye(10) * np.arange(1, 11))
     linear = True
```

### Comparing `pymor-2022.2.1/src/pymortests/algorithms/stuff.py` & `pymor-2023.1.0/src/pymortests/algorithms/newton.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,30 +1,31 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 import numpy as np
 import pytest
 
-from pymor.algorithms.newton import newton, NewtonError
+from pymor.algorithms.newton import NewtonError, newton
 from pymor.tools.floatcmp import float_cmp
 from pymor.vectorarrays.numpy import NumpyVectorSpace
-
 from pymortests.base import runmodule
 from pymortests.fixtures.operator import MonomOperator
 
+pytestmark = pytest.mark.builtin
+
 
 def _newton(mop, initial_value=1.0, **kwargs):
     rhs = NumpyVectorSpace.from_numpy([0.0])
     guess = NumpyVectorSpace.from_numpy([initial_value])
     return newton(mop, rhs, initial_guess=guess, **kwargs)
 
 
-@pytest.mark.parametrize("order", list(range(1, 8)))
-@pytest.mark.parametrize("error_measure", ['update', 'residual'])
+@pytest.mark.parametrize('order', list(range(1, 8)))
+@pytest.mark.parametrize('error_measure', ['update', 'residual'])
 def test_newton(order, error_measure):
     mop = MonomOperator(order)
     U, _ = _newton(mop,
                    atol=1e-15 if error_measure == 'residual' else 1e-7,
                    rtol=0.,
                    error_measure=error_measure)
     assert float_cmp(mop.apply(U).to_numpy(), 0.0)
@@ -56,9 +57,9 @@
 
 def test_newton_residual_is_zero(order=5):
     mop = MonomOperator(order)
     U, _ = _newton(mop, initial_value=0.0)
     assert float_cmp(mop.apply(U).to_numpy(), 0.0)
 
 
-if __name__ == "__main__":
+if __name__ == '__main__':
     runmodule(filename=__file__)
```

### Comparing `pymor-2022.2.1/src/pymortests/algorithms/svd_va.py` & `pymor-2023.1.0/src/pymortests/algorithms/svd_va.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,19 +1,18 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 import numpy as np
 import pytest
-from hypothesis import assume, settings, HealthCheck
+from hypothesis import HealthCheck, assume, settings
 from hypothesis.strategies import sampled_from
 
-from pymor.algorithms.basic import almost_equal
+from pymor.algorithms.basic import almost_equal, contains_zero_vector
 from pymor.algorithms.svd_va import method_of_snapshots, qr_svd
-from pymor.algorithms.basic import contains_zero_vector
 from pymor.core.logger import log_levels
 from pymor.vectorarrays.numpy import NumpyVectorSpace
 from pymortests.base import runmodule
 from pymortests.strategies import given_vector_arrays
 
 methods = [method_of_snapshots, qr_svd]
 
@@ -25,15 +24,15 @@
 
     # TODO assumption here masks a potential issue with the algorithm
     #      where it fails in internal lapack instead of a proper error
     assume(len(A) > 1 or A.dim > 1)
     assume(not contains_zero_vector(A, rtol=1e-13, atol=1e-13))
 
     B = A.copy()
-    with log_levels({"pymor.algorithms": "ERROR"}):
+    with log_levels({'pymor.algorithms': 'ERROR'}):
         U, s, Vh = method(A, rtol=4e-8)  # default tolerance
     assert np.all(almost_equal(A, B))
     assert len(U) == len(s) == Vh.shape[0]
     assert Vh.shape[1] == len(A)
     assert np.allclose(Vh @ Vh.T.conj(), np.eye(len(s)))
     if len(s) > 0:
         U.scal(s)
@@ -42,27 +41,28 @@
 
 
 @pytest.mark.parametrize('method', methods)
 def test_method_of_snapshots_with_product(operator_with_arrays_and_products, method):
     _, _, A, _, p, _ = operator_with_arrays_and_products
 
     B = A.copy()
-    with log_levels({"pymor.algorithms": "ERROR"}):
+    with log_levels({'pymor.algorithms': 'ERROR'}):
         U, s, Vh = method(A, product=p)
     assert np.all(almost_equal(A, B))
     assert len(U) == len(s) == Vh.shape[0]
     assert Vh.shape[1] == len(A)
     assert np.allclose(Vh @ Vh.T.conj(), np.eye(len(s)))
     U.scal(s)
     UsVh = U.lincomb(Vh.T)
     assert np.all(almost_equal(A, UsVh, rtol=4e-8))
 
 
+@pytest.mark.builtin
 @pytest.mark.parametrize('method', methods)
 def test_not_too_many_modes(method):
     vec_array = NumpyVectorSpace.from_numpy(np.logspace(-5, 0, 10).reshape((-1, 1)))
     U, s, V = method(vec_array, atol=0, rtol=0)
     assert len(U) == len(s) == len(V) == 1
 
 
-if __name__ == "__main__":
+if __name__ == '__main__':
     runmodule(filename=__file__)
```

### Comparing `pymor-2022.2.1/src/pymortests/algorithms/sylvester.py` & `pymor-2023.1.0/src/pymortests/algorithms/sylvester.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,19 +1,20 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 import numpy as np
+import pytest
 import scipy.linalg as spla
 import scipy.sparse as sps
 
 from pymor.algorithms.sylvester import solve_sylv_schur
 from pymor.operators.numpy import NumpyMatrixOperator
 
-import pytest
+pytestmark = pytest.mark.builtin
 
 
 n_list = [100, 1000]
 r_list = [1, 10, 20]
 m_list = [1, 2]
 p_list = [1, 2]
```

### Comparing `pymor-2022.2.1/src/pymortests/algorithms/symplectic.py` & `pymor-2023.1.0/src/pymortests/algorithms/symplectic.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,17 +1,27 @@
+# This file is part of the pyMOR project (https://www.pymor.org).
+# Copyright pyMOR developers and contributors. All rights reserved.
+# License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 import numpy as np
 import pytest
-from pymor.algorithms.symplectic import (psd_complex_svd, psd_cotengent_lift,
-                                         psd_svd_like_decomp,
-                                         symplectic_gram_schmidt)
+
+from pymor.algorithms.symplectic import (
+    psd_complex_svd,
+    psd_cotengent_lift,
+    psd_svd_like_decomp,
+    symplectic_gram_schmidt,
+)
 from pymor.operators.symplectic import CanonicalSymplecticFormOperator
 from pymor.vectorarrays.block import BlockVectorSpace
 from pymor.vectorarrays.numpy import NumpyVectorSpace
 
+pytestmark = pytest.mark.builtin
+
+
 METHODS_DICT = {
     'psd_cotengent_lift': psd_cotengent_lift,
     'psd_complex_svd': psd_complex_svd,
     'psd_svd_like_decomp': psd_svd_like_decomp,
 }
 KEYS_ORTHOSYMPL_METHOD = ['psd_cotengent_lift', 'psd_complex_svd']
```

### Comparing `pymor-2022.2.1/src/pymortests/algorithms/to_matrix.py` & `pymor-2023.1.0/src/pymortests/algorithms/to_matrix.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,20 +1,28 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 import numpy as np
+import pytest
 import scipy.linalg as spla
 import scipy.sparse as sps
 
 from pymor.algorithms.to_matrix import to_matrix
 from pymor.core.config import config
-from pymor.operators.block import BlockOperator, BlockDiagonalOperator
-from pymor.operators.constructions import (AdjointOperator, ComponentProjectionOperator, IdentityOperator,
-                                           LowRankOperator, LowRankUpdatedOperator, VectorArrayOperator, ZeroOperator)
+from pymor.operators.block import BlockDiagonalOperator, BlockOperator
+from pymor.operators.constructions import (
+    AdjointOperator,
+    ComponentProjectionOperator,
+    IdentityOperator,
+    LowRankOperator,
+    LowRankUpdatedOperator,
+    VectorArrayOperator,
+    ZeroOperator,
+)
 from pymor.operators.numpy import NumpyMatrixOperator
 from pymor.vectorarrays.numpy import NumpyVectorSpace
 
 
 def assert_type_and_allclose(A, Aop, default_format):
     if default_format == 'dense':
         assert isinstance(to_matrix(Aop), np.ndarray)
@@ -29,24 +37,26 @@
     assert isinstance(to_matrix(Aop, format='dense'), np.ndarray)
     assert np.allclose(A, to_matrix(Aop, format='dense'))
 
     assert sps.isspmatrix_csr(to_matrix(Aop, format='csr'))
     assert np.allclose(A, to_matrix(Aop, format='csr').toarray())
 
 
+@pytest.mark.builtin
 def test_to_matrix_NumpyMatrixOperator():
     A = np.random.randn(2, 2)
 
     Aop = NumpyMatrixOperator(A)
     assert_type_and_allclose(A, Aop, 'dense')
 
     Aop = NumpyMatrixOperator(sps.csc_matrix(A))
     assert_type_and_allclose(A, Aop, 'csc')
 
 
+@pytest.mark.builtin
 def test_to_matrix_BlockOperator():
     A11 = np.random.randn(2, 2)
     A12 = np.random.randn(2, 3)
     A21 = np.random.randn(3, 2)
     A22 = np.random.randn(3, 3)
     B = np.block([[A11, A12], [A21, A22]])
 
@@ -61,14 +71,15 @@
     A12op = NumpyMatrixOperator(A12)
     A21op = NumpyMatrixOperator(A21)
     A22op = NumpyMatrixOperator(A22)
     Bop = BlockOperator([[A11op, A12op], [A21op, A22op]])
     assert_type_and_allclose(B, Bop, 'sparse')
 
 
+@pytest.mark.builtin
 def test_to_matrix_BlockDiagonalOperator():
     A1 = np.random.randn(2, 2)
     A2 = np.random.randn(3, 3)
     B = np.block([[A1, np.zeros((2, 3))],
                   [np.zeros((3, 2)), A2]])
 
     A1op = NumpyMatrixOperator(A1)
@@ -78,14 +89,15 @@
 
     A1op = NumpyMatrixOperator(sps.csc_matrix(A1))
     A2op = NumpyMatrixOperator(A2)
     Bop = BlockDiagonalOperator([A1op, A2op])
     assert_type_and_allclose(B, Bop, 'sparse')
 
 
+@pytest.mark.builtin
 def test_to_matrix_AdjointOperator():
     A = np.random.randn(2, 2)
     S = np.random.randn(2, 2)
     S = S.dot(S.T)
     R = np.random.randn(2, 2)
     R = R.dot(R.T)
 
@@ -118,25 +130,27 @@
     Aop = NumpyMatrixOperator(sps.csc_matrix(A))
     Sop = NumpyMatrixOperator(sps.csc_matrix(S))
     Rop = NumpyMatrixOperator(sps.csc_matrix(R))
     Aadj = AdjointOperator(Aop, source_product=Sop, range_product=Rop)
     assert_type_and_allclose(spla.solve(S, A.T.dot(R)), Aadj, 'sparse')
 
 
+@pytest.mark.builtin
 def test_to_matrix_ComponentProjectionOperator():
     dofs = np.array([0, 1, 2, 4, 8])
     n = 10
     A = np.zeros((len(dofs), n))
     A[range(len(dofs)), dofs] = 1
 
     source = NumpyVectorSpace(n)
     Aop = ComponentProjectionOperator(dofs, source)
     assert_type_and_allclose(A, Aop, 'sparse')
 
 
+@pytest.mark.builtin
 def test_to_matrix_ConcatenationOperator():
     A = np.random.randn(2, 3)
     B = np.random.randn(3, 4)
     C = A.dot(B)
 
     Aop = NumpyMatrixOperator(A)
     Bop = NumpyMatrixOperator(B)
@@ -155,22 +169,24 @@
 
     Aop = NumpyMatrixOperator(sps.csc_matrix(A))
     Bop = NumpyMatrixOperator(sps.csc_matrix(B))
     Cop = Aop @ Bop
     assert_type_and_allclose(A, Aop, 'sparse')
 
 
+@pytest.mark.builtin
 def test_to_matrix_IdentityOperator():
     n = 3
     I = np.eye(n)
 
     Iop = IdentityOperator(NumpyVectorSpace(n))
     assert_type_and_allclose(I, Iop, 'sparse')
 
 
+@pytest.mark.builtin
 def test_to_matrix_LincombOperator():
     A = np.random.randn(3, 3)
     B = np.random.randn(3, 2)
     a = np.random.randn()
     b = np.random.randn()
     C = a * A + b * B.dot(B.T)
 
@@ -191,14 +207,15 @@
 
     Aop = NumpyMatrixOperator(sps.csc_matrix(A))
     Bop = NumpyMatrixOperator(sps.csc_matrix(B))
     Cop = Aop * a + (Bop @ Bop.H) * b
     assert_type_and_allclose(C, Cop, 'sparse')
 
 
+@pytest.mark.builtin
 def test_to_matrix_LowRankOperator():
     m = 6
     n = 5
     r = 2
     L = np.random.randn(m, r)
     Lva = NumpyVectorSpace.make_array(L.T)
     C = np.random.randn(r, r)
@@ -208,14 +225,15 @@
     LR = LowRankOperator(Lva, C, Rva)
     assert_type_and_allclose(L @ C @ R.T, LR, 'dense')
 
     LR = LowRankOperator(Lva, C, Rva, inverted=True)
     assert_type_and_allclose(L @ spla.solve(C, R.T), LR, 'dense')
 
 
+@pytest.mark.builtin
 def test_to_matrix_LowRankUpdatedOperator():
     m = 6
     n = 5
     r = 2
     A = np.random.randn(m, n)
     Aop = NumpyMatrixOperator(A)
     L = np.random.randn(m, r)
@@ -225,36 +243,39 @@
     Rva = NumpyVectorSpace.make_array(R.T)
     LR = LowRankOperator(Lva, C, Rva)
 
     op = LowRankUpdatedOperator(Aop, LR, 1, 1)
     assert_type_and_allclose(A + L @ C @ R.T, op, 'dense')
 
 
+@pytest.mark.builtin
 def test_to_matrix_VectorArrayOperator():
     V = np.random.randn(10, 2)
 
     Vva = NumpyVectorSpace.make_array(V.T)
     Vop = VectorArrayOperator(Vva)
     assert_type_and_allclose(V, Vop, 'dense')
 
     Vop = VectorArrayOperator(Vva, adjoint=True)
     assert_type_and_allclose(V.T, Vop, 'dense')
 
 
+@pytest.mark.builtin
 def test_to_matrix_ZeroOperator():
     n = 3
     m = 4
     Z = np.zeros((n, m))
 
     Zop = ZeroOperator(NumpyVectorSpace(n), NumpyVectorSpace(m))
     assert_type_and_allclose(Z, Zop, 'sparse')
 
 
 if config.HAVE_DUNEGDT:
     from dune.xt.la import IstlSparseMatrix, SparsityPatternDefault
+
     from pymor.bindings.dunegdt import DuneXTMatrixOperator
 
     def test_to_matrix_DuneXTMatrixOperator():
         A = np.random.randn(2, 2)
 
         pattern = SparsityPatternDefault(2)
         for ii in range(2):
```

### Comparing `pymor-2022.2.1/src/pymortests/analyticalproblems/analyticalproblem.py` & `pymor-2023.1.0/src/pymortests/analyticalproblems/analyticalproblem.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,30 +1,34 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 import warnings
 
+import pytest
+
 from pymor.analyticalproblems.text import text_problem
 from pymortests.base import runmodule
 from pymortests.core.pickling import assert_picklable, assert_picklable_without_dumps_function
 
+pytestmark = pytest.mark.builtin
+
 
 def test_pickle(analytical_problem):
     assert_picklable(analytical_problem)
 
 
 def test_pickle_without_dumps_function(picklable_analytical_problem):
     assert_picklable_without_dumps_function(picklable_analytical_problem)
 
 
 def test_missing_font():
     name = 'ThisFontIsMissing'
     with warnings.catch_warnings(record=True) as w:
-        warnings.simplefilter("always")
+        warnings.simplefilter('always')
         text_problem(text='pyMOR', font_name=name)
         assert len(w) == 1
         assert issubclass(w[-1].category, ResourceWarning)
         assert name in str(w[-1].message)
 
 
-if __name__ == "__main__":
+if __name__ == '__main__':
     runmodule(filename=__file__)
```

### Comparing `pymor-2022.2.1/src/pymortests/analyticalproblems/function.py` & `pymor-2023.1.0/src/pymortests/analyticalproblems/function.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,19 +1,21 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 import numpy as np
 import pytest
 
-from pymor.analyticalproblems.functions import ConstantFunction, GenericFunction, ExpressionFunction
+from pymor.analyticalproblems.functions import ConstantFunction, ExpressionFunction, GenericFunction
 from pymor.core.pickle import dumps, loads
+from pymortests.core.pickling import assert_picklable, assert_picklable_without_dumps_function
 from pymortests.fixtures.function import function_argument
 from pymortests.fixtures.parameter import mu_of_type
-from pymortests.core.pickling import assert_picklable, assert_picklable_without_dumps_function
+
+pytestmark = pytest.mark.builtin
 
 
 def test_evaluate(function):
     f = function
     mus = mu_of_type(f.parameters)
     for count in [0, 1, 5, (0, 1), (2, 2, 2)]:
         arg = function_argument(f, count)
@@ -63,10 +65,8 @@
     for arg in function_argument(f, 10):
         mu = next(mus)
         assert np.all(f.evaluate(arg, mu) == f2.evaluate(arg, mu))
 
 
 def test_invalid_expressions():
     with pytest.raises(TypeError):
-        ExpressionFunction('-1 < x[0] < 1', 1)
-    with pytest.raises(TypeError):
         ExpressionFunction('(-1 < x[0]) and (x[0] < 1)', 1)
```

### Comparing `pymor-2022.2.1/src/pymortests/base.py` & `pymor-2023.1.0/src/pymortests/base.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,26 +1,27 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 import hashlib
 import os
 import sys
-from pprint import pformat
 from functools import wraps
+from pickle import dump, load
+from pprint import pformat
 
-import hypothesis
 import numpy as np
-from pickle import dump, load
 from pkg_resources import resource_filename, resource_stream
 from pytest import skip
 
 from pymor.algorithms.basic import almost_equal, relative_error
 from pymor.core import config
-from pymor.core.exceptions import DependencyMissing
+from pymor.core.exceptions import DependencyMissingError, NoResultDataError
+
+BUILTIN_DISABLED = bool(os.environ.get('PYMOR_FIXTURES_DISABLE_BUILTIN', False))
 
 
 def runmodule(filename):
     import pytest
 
     sys.exit(pytest.main(sys.argv[1:] + [filename]))
 
@@ -57,16 +58,16 @@
         with resource_stream('pymortests', f'testdata/check_results/{test_name}/{arg_id}') as f:
             f.readline()
             old_results = load(f)
     except FileNotFoundError:
         if not os.path.exists(testname_dir):
             os.mkdir(testname_dir)
         _dump_results(filename, results)
-        assert False, \
-            f'No results found for test {test_name} ({params}), saved current results. Remember to check in {filename}.'
+        raise NoResultDataError(msg=f'No results found for test {test_name} ({params}), saved current results.'
+                                        f'Remember to check in {filename}.')
 
     for k, (atol, rtol) in keys.items():
         if not np.all(np.allclose(old_results[k], results[k], atol=atol, rtol=rtol)):
             abs_errs = np.abs(results[k] - old_results[k])
             rel_errs = abs_errs / np.abs(old_results[k])
             _dump_results(filename + '_changed', results)
             assert False, (f'Results for test {test_name}({params}, key: {k}) have changed.\n'
@@ -76,31 +77,14 @@
 
 def assert_all_almost_equal(U, V, product=None, sup_norm=False, rtol=1e-14, atol=1e-14):
     cmp_array = almost_equal(U, V, product=product, sup_norm=sup_norm, rtol=rtol, atol=atol)
     too_large_relative_errors = dict((i, relative_error(u, v, product=product))
                                      for i, (u, v, f) in enumerate(zip(U, V, cmp_array)) if not f)
     assert np.all(cmp_array), f'Relative errors for not-equal elements:{pformat(too_large_relative_errors)}'
 
-
-def might_exceed_deadline(deadline=-1):
-    """For hypothesis magic to work properly this must be the topmost decorator on test function"""
-    def _outer_wrapper(func):
-        @wraps(func)
-        def _inner_wrapper(*args, **kwargs):
-            dl = deadline
-            if os.environ.get('PYMOR_ALLOW_DEADLINE_EXCESS', False):
-                dl = None
-            elif dl == -1:
-                dl = hypothesis.settings.default.deadline.total_seconds() * 1e3
-            assert dl is None or dl > 1
-            return hypothesis.settings(deadline=dl)(func)(*args, **kwargs)
-        return _inner_wrapper
-    return _outer_wrapper
-
-
 def skip_if_missing(config_name):
     """Wrapper for requiring certain module dependencies on tests.
 
     This will explicitly call :meth:`pymor.core.config.Config.require` with
     given `config_name`, so it's usable even in places where a pyMOR module
     that requires that package is not imported (yet).
 
@@ -111,16 +95,16 @@
         Docker CI environment, the test is skipped.
     """
     def _outer_wrapper(func):
         @wraps(func)
         def _inner_wrapper(*args, **kwargs):
             try:
                 config.config.require(config_name)
-            except DependencyMissing as dm:
+            except DependencyMissingError as dm:
                 # skip does not return
-                if config_name in str(dm.dependency) and not os.environ.get('DOCKER_PYMOR', False):
+                if config_name in str(dm.dependency):
                     skip_string = 'skipped test due to missing dependency ' + config_name
                     skip(skip_string)
                 raise dm
             func(*args, **kwargs)
         return _inner_wrapper
     return _outer_wrapper
```

### Comparing `pymor-2022.2.1/src/pymortests/bindings/fenics_expressions.py` & `pymor-2023.1.0/src/pymortests/bindings/fenics_expressions.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,11 +1,11 @@
-from pymortests.base import runmodule
 import numpy as np
+
 from pymor.analyticalproblems.expressions import parse_expression
-from pymortests.base import skip_if_missing
+from pymortests.base import runmodule, skip_if_missing
 
 
 @skip_if_missing('FENICS')
 def test_fenics_expression_vectorized():
     from dolfin import UnitSquareMesh
     e = parse_expression('[1., 2.] + [x[0], x[1]]', {'x': 2})
     mesh = UnitSquareMesh(10, 10)
@@ -36,9 +36,9 @@
     f_fenics, f_fenics_params = e.to_fenics(mesh)
     eval = f_fenics.item()([5., 2.])
     val = 5. + np.sin(2.)
 
     assert np.allclose(eval, val)
 
 
-if __name__ == "__main__":
+if __name__ == '__main__':
     runmodule(filename=__file__)
```

### Comparing `pymor-2022.2.1/src/pymortests/bindings/skfem.py` & `pymor-2023.1.0/src/pymortests/bindings/skfem.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,23 +1,20 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
-import pytest
 import numpy as np
 
-from pymor.basic import ExpressionFunction, StationaryProblem, ConstantFunction, RectDomain, LineDomain
-from pymor.core.config import config
+from pymor.basic import ConstantFunction, ExpressionFunction, LineDomain, RectDomain, StationaryProblem
 from pymor.discretizers.builtin.cg import discretize_stationary_cg as discretize_stationary_cg_builtin
+from pymortests.base import skip_if_missing
 
 
+@skip_if_missing('SCIKIT_FEM')
 def test_skfem1d():
-    if not config.HAVE_SCIKIT_FEM:
-        pytest.xfail('scikit-fem missing')
-
     from pymor.discretizers.skfem.cg import discretize_stationary_cg
 
     p = StationaryProblem(
         domain=LineDomain([-1, 1], left='dirichlet', right='neumann'),
         diffusion=ConstantFunction(1., 1),
         advection=ConstantFunction(np.array([-10.]), 1),
         rhs=ExpressionFunction('((x[0] - 0.75)**2 < 0.01) * 10', 1),
@@ -31,18 +28,16 @@
 
     o_skfem = m_skfem.output()
     o_builtin = m_builtin.output()
 
     assert np.linalg.norm((o_builtin - o_skfem) / o_builtin) < 0.01
 
 
+@skip_if_missing('SCIKIT_FEM')
 def test_skfem2d():
-    if not config.HAVE_SCIKIT_FEM:
-        pytest.xfail('scikit-fem missing')
-
     from pymor.discretizers.skfem.cg import discretize_stationary_cg
 
     p = StationaryProblem(
         domain=RectDomain([[-1, -1], [1, 1]], bottom='neumann', right='neumann'),
         diffusion=ConstantFunction(1., 2),
         advection=ExpressionFunction('[x[1]*100, -x[0]*100]', 2),
         rhs=ExpressionFunction('(((x[0] - 0.75)**2 + x[1]**2) < 0.01) * 10', 2),
```

### Comparing `pymor-2022.2.1/src/pymortests/complex_values.py` & `pymor-2023.1.0/src/pymortests/complex_values.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,16 +1,19 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 import numpy as np
+import pytest
 
 from pymor.operators.numpy import NumpyMatrixOperator
 from pymor.vectorarrays.numpy import NumpyVectorSpace
 
+pytestmark = pytest.mark.builtin
+
 
 def test_complex():
     I = np.eye(5)
     A = np.random.randn(5, 5)
     B = np.random.randn(5, 5)
     C = np.random.randn(3, 5)
```

### Comparing `pymor-2022.2.1/src/pymortests/core/cache.py` & `pymor-2023.1.0/src/pymortests/core/cache.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,24 +1,27 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 import contextlib
+import os
 import tempfile
 import time
-import os
-from uuid import uuid4
 from datetime import datetime, timedelta
+from uuid import uuid4
+
 import numpy as np
 import pytest
 
 from pymor.core import cache
 from pymor.models.basic import StationaryModel
 from pymor.operators.numpy import NumpyMatrixOperator
 from pymortests.base import runmodule
 
+pytestmark = pytest.mark.builtin
+
 
 SLEEP_DELTA = timedelta(milliseconds=200)
 
 
 class IamMemoryCached(cache.CacheableObject):
 
     def __init__(self):
@@ -76,15 +79,15 @@
     assert delta1 >= SLEEP_DELTA, r
     assert delta2 < delta1, r
     assert delta2 < 0.5 * SLEEP_DELTA, r
 
 
 @contextlib.contextmanager
 def _close_cache(backend):
-    """This avoids the tmp dir trying to rm still open files with the disk backend"""
+    """This avoids the tmp dir trying to rm still open files with the disk backend."""
     yield
     try:
         backend._cache.close()
     except AttributeError:
         pass
 
 
@@ -118,9 +121,9 @@
     U = m.solve()
     assert len(U) == 1
     del U[:]
     U = m.solve()
     assert len(U) == 1
 
 
-if __name__ == "__main__":
+if __name__ == '__main__':
     runmodule(filename=__file__)
```

### Comparing `pymor-2022.2.1/src/pymortests/core/config.py` & `pymor-2023.1.0/src/pymortests/core/config.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,15 +1,18 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 import pytest
 
-from pymor.core.config import config, _PACKAGES
-from pymor.core.exceptions import DependencyMissing
+from pymor.core.config import _PACKAGES, config
+from pymor.core.exceptions import DependencyMissingError
+
+pytestmark = pytest.mark.builtin
+
 
 
 def test_repr():
     repr(config)
 
 
 def test_entries():
@@ -34,9 +37,9 @@
 def test_require_fail_foo():
     with pytest.raises(AttributeError):
         config.require('FOO')
 
 
 def test_require_fail_missing_dependency(monkeypatch):
     monkeypatch.setitem(_PACKAGES, 'THISISNOTAPACKAGENAMETHATEXISTS', lambda: False)
-    with pytest.raises(DependencyMissing):
+    with pytest.raises(DependencyMissingError):
         config.require('THISISNOTAPACKAGENAMETHATEXISTS')
```

### Comparing `pymor-2022.2.1/src/pymortests/core/defaults.py` & `pymor-2023.1.0/src/pymortests/core/defaults.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,15 +1,17 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 import pytest
 
-from pymor.core.defaults import defaults, set_defaults, print_defaults, load_defaults_from_file, write_defaults_to_file
+from pymor.core.defaults import defaults, load_defaults_from_file, print_defaults, set_defaults, write_defaults_to_file
 from pymor.tools.io import safe_temporary_filename
 
+pytestmark = pytest.mark.builtin
+
 
 @defaults('c', 'd')
 def func(a, b, c=2, d=3, e=4):
     return a, b, c, d, e
 
 
 def test_defaults():
```

### Comparing `pymor-2022.2.1/src/pymortests/core/logger.py` & `pymor-2023.1.0/src/pymortests/core/logger.py`

 * *Files 6% similar despite different names*

```diff
@@ -5,15 +5,17 @@
 import logging
 
 import pytest
 
 import pymor.core as core
 from pymor.core.logger import log_levels
 from pymor.operators.numpy import NumpyMatrixOperator
-from pymortests.base import (runmodule,)
+from pymortests.base import runmodule
+
+pytestmark = pytest.mark.builtin
 
 
 def test_logger():
     logger = NumpyMatrixOperator._logger
     for lvl in [getattr(logging, lvl) for lvl in ['WARN', 'ERROR', 'DEBUG', 'INFO']]:
         logger.setLevel(lvl)
         assert logger.isEnabledFor(lvl)
@@ -48,9 +50,9 @@
     capsys.readouterr()
     func(msg)
     second = capsys.readouterr()
     # same log call must result in no output
     assert second.out == second.err == ''
 
 
-if __name__ == "__main__":
+if __name__ == '__main__':
     runmodule(filename=__file__)
```

### Comparing `pymor-2022.2.1/src/pymortests/core/pickling.py` & `pymor-2023.1.0/src/pymortests/core/pickling.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,18 +1,19 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
+from types import FunctionType, MethodType
+
 import numpy as np
 from scipy.sparse import issparse
-from types import FunctionType, MethodType
 
 from pymor.core.base import BasicObject
 from pymor.core.config import config
-from pymor.core.pickle import dumps, loads, dumps_function, PicklingError
+from pymor.core.pickle import PicklingError, dumps, dumps_function, loads
 from pymor.discretizers.builtin.grids.subgrid import SubGrid
 from pymor.operators.numpy import NumpyMatrixBasedOperator
 from pymor.parameters.base import ParametricObject
 
 is_equal_ignored_attributes = \
     ((SubGrid, {'_uid', '_CacheableObject__cache_region', '_SubGrid__parent_grid'}),
      (NumpyMatrixBasedOperator, {'_uid', '_CacheableObject__cache_region', '_parameters', '_assembled_operator'}),
```

### Comparing `pymor-2022.2.1/src/pymortests/demos.py` & `pymor-2023.1.0/src/pymortests/demos.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,26 +1,30 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
-
+import math
 import os
-import pymordemos  # noqa: F401
+import shutil
 from importlib import import_module
-import pytest
 from tempfile import mkdtemp
-import shutil
 
+import pytest
 from typer import Typer
 from typer.testing import CliRunner
 
-from pymortests.base import runmodule, check_results
-from pymor.core.exceptions import QtMissing, GmshMissing, MeshioMissing, TorchMissing
-from pymor.core.config import is_windows_platform, is_macos_platform
+import pymordemos  # noqa: F401
+from pymor.core.config import is_macos_platform, is_windows_platform
+from pymor.core.exceptions import (
+    DependencyMissingError,
+    GmshMissingError,
+    MeshioMissingError,
+    NoResultDataError,
+)
 from pymor.tools.mpi import parallel
-
+from pymortests.base import BUILTIN_DISABLED, check_results, runmodule
 
 runner = CliRunner()
 
 
 DISCRETIZATION_ARGS = (
     ('elliptic', [0, 0, 0, 0]),
     ('elliptic', [1, 2, 0, 3]),
@@ -81,16 +85,16 @@
     ('thermalblock_simple', ['pymor', 'naive', 2, 5, 5]),
     ('thermalblock_simple', ['fenics', 'greedy', 2, 5, 5]),
     ('thermalblock_simple', ['ngsolve', 'pod', 2, 5, 5]),
     ('thermalblock_simple', ['--', 'pymor_text', 'adaptive_greedy', -1, 3, 3]),
 )
 
 BURGERS_EI_ARGS = (
-    ('burgers_ei', [1, 2, 2, 5, 2, 5, '--plot-ei-err', '--plot-err', '--plot-solutions']),
-    ('burgers_ei', [1, 2, 2, 5, 2, 5, '--ei-alg=deim', '--plot-error-landscape']),
+    ('burgers_ei', [1, 2, 2, 5, 2, 5, '--grid=20', '--plot-ei-err', '--plot-err', '--plot-solutions']),
+    ('burgers_ei', [1, 2, 2, 5, 2, 5, '--grid=20', '--ei-alg=deim', '--plot-error-landscape']),
 )
 
 PARABOLIC_MOR_ARGS = (
     ('parabolic_mor', ['pymor', 'greedy', 2, 3, 1]),
     ('parabolic_mor', ['pymor', 'pod', 2, 3, 1]),
     ('parabolic_mor', ['fenics', 'adaptive_greedy', 2, 3, 1]),
 )
@@ -102,14 +106,20 @@
     ('parametric_heat', [0.02, 2]),
     ('parametric_delay', [2]),
     ('parametric_string', [5, 2]),
     ('parametric_synthetic', [10, 2]),
     ('unstable_heat', [50, 10]),
 )
 
+DD_MOR_ARGS = (
+    ('dd_parametric_heat', [0.01, 50, 10]),
+    ('dd_heat', [0.1, 10]),
+    ('era', [10]),
+)
+
 HAPOD_ARGS = (
     ('hapod', ['--snap=3', 1e-2, 10, 100]),
     ('hapod', ['--snap=3', '--threads=2', 1e-2, 10, 100]),
     ('hapod', ['--snap=3', '--procs=2', '--arity=2', 1e-2, 10, 100]),
 )
 
 FENICS_NONLINEAR_ARGS = (
@@ -128,37 +138,40 @@
     ('output_error_estimation', [1, 10, 4, 10, 1]),
     ('output_error_estimation', [2, 10, 4, 10, 0]),
     ('output_error_estimation', [2, 10, 4, 10, 1]),
     ('output_error_estimation', [3, 10, 10, 10, 1]),
     ('output_error_estimation', [4, 10, 10, 10, 1]),
     ('output_error_estimation_with_dwr', [0, 10, 4, 12]),
     ('output_error_estimation_with_dwr', [1, 10, 4, 8]),
+    ('trust_region', [0, 40, 20]),
+    ('trust_region', [1, 20, 20])
 )
 
 DMD_ARGS = (
     ('burgers_dmd', [1.5, '--grid=10', '--nt=100']),
     ('dmd_identification', ['--n=4', '--m=10']),
 )
 
 PHLTI_ARGS = (
-    ('phlti', ['--n=10']),
+    ('phlti', [10, 2, 4]),
 )
 
 SYMPLECTIC_WAVE_ARGS = (
     ('symplectic_wave_equation', [1., 10]),
 )
 
 DEMO_ARGS = (
     DISCRETIZATION_ARGS
     + NEURAL_NETWORK_ARGS
     + THERMALBLOCK_ARGS
     + THERMALBLOCK_ADAPTIVE_ARGS
     + THERMALBLOCK_SIMPLE_ARGS
     + BURGERS_EI_ARGS
     + PARABOLIC_MOR_ARGS
+    + DD_MOR_ARGS
     + SYS_MOR_ARGS
     + HAPOD_ARGS
     + FENICS_NONLINEAR_ARGS
     + FUNCTION_EI_ARGS
     + OUTPUT_FUNCTIONAL_ARGS
     + DMD_ARGS
     + PHLTI_ARGS
@@ -166,29 +179,32 @@
 )
 
 DEMO_ARGS = [(f'pymordemos.{a}', b) for (a, b) in DEMO_ARGS]
 
 
 def _skip_if_no_solver(param):
     demo, args = param
+    builtin = True
     from pymor.core.config import config
     for solver, package in [('fenics', None), ('ngsolve', None), ('neural_', 'TORCH'),
                             ('neural_networks_instationary', 'FENICS')]:
         package = package or solver.upper()
         needs_solver = len([f for f in args if solver in str(f)]) > 0 or demo.find(solver) >= 0
         has_solver = getattr(config, f'HAVE_{package}')
+        builtin = builtin and (not needs_solver or package == 'TORCH')
         if needs_solver and not has_solver:
-            if not os.environ.get('DOCKER_PYMOR', False):
-                pytest.skip('skipped test due to missing ' + solver)
+            pytest.skip('skipped test due to missing ' + package)
+    if builtin and BUILTIN_DISABLED:
+        pytest.skip('builtin discretizations disabled')
 
 
 def _demo_ids(demo_args):
     def _key(b):
         return ' '.join((str(s) for s in b))
-    return [f"{a}:'{_key(b)}'".replace('pymordemos.', '') for a, b in demo_args]
+    return [f'{a}:"{_key(b)}"'.replace('pymordemos.', '') for a, b in demo_args]
 
 
 @pytest.fixture(params=DEMO_ARGS, ids=_demo_ids(DEMO_ARGS))
 def demo_args(request):
     _skip_if_no_solver(request.param)
     return request.param
 
@@ -203,48 +219,52 @@
     import sys
     sys._called_from_test = True
 
     def nop(*args, **kwargs):
         pass
 
     try:
-        from matplotlib import pyplot
+        from matplotlib import pyplot as plt
         if sys.version_info[:2] > (3, 7) or (
                 sys.version_info[0] == 3 and sys.version_info[1] == 6):
-            pyplot.ion()
+            plt.ion()
         else:
             # the ion switch results in interpreter segfaults during multiple
             # demo tests on 3.7 -> fall back on old monkeying solution
-            pyplot.show = nop
+            plt.show = nop
     except ImportError:
         pass
     try:
         import petsc4py
+
         # the default X handlers can interfere with process termination
         petsc4py.PETSc.Sys.popSignalHandler()
         petsc4py.PETSc.Sys.popErrorHandler()
     except ImportError:
         pass
 
     result = None
     try:
         result = demo()
-    except (QtMissing, GmshMissing, MeshioMissing, TorchMissing) as e:
+    except (DependencyMissingError, GmshMissingError, MeshioMissingError) as e:
         if os.environ.get('DOCKER_PYMOR', False):
             # these are all installed in our CI env so them missing is a grave error
             raise e
         else:
-            miss = str(type(e)).replace('Missing', '')
+            if isinstance(e, DependencyMissingError):
+                miss = e.dependency
+            else:
+                miss = str(type(e)).replace('MissingError', '')
             pytest.xfail(f'{miss} not installed')
     finally:
         from pymor.parallel.default import _cleanup
         _cleanup()
         try:
-            from matplotlib import pyplot
-            pyplot.close('all')
+            from matplotlib import pyplot as plt
+            plt.close('all')
         except ImportError:
             pass
 
     return result
 
 
 def test_demos(demo_args):
@@ -259,46 +279,50 @@
         app = Typer()
         app.command()(module.main)
     args = [str(arg) for arg in args]
     result = _test_demo(lambda: runner.invoke(app, args, catch_exceptions=False))
     assert result.exit_code == 0
 
 
+@pytest.mark.builtin
 def test_analyze_pickle1():
     d = mkdtemp()
     try:
         test_demos(('pymordemos.thermalblock', ['--pickle=' + os.path.join(d, 'data'), 2, 2, 2, 10]))
         test_demos(('pymordemos.analyze_pickle',
                    ['histogram', '--error-norm=h1_0_semi', os.path.join(d, 'data_reduced'), 10]))
     finally:
         shutil.rmtree(d)
 
 
+@pytest.mark.builtin
 def test_analyze_pickle2():
     d = mkdtemp()
     try:
         test_demos(('pymordemos.thermalblock_adaptive', ['--pickle=' + os.path.join(d, 'data'), 10]))
         test_demos(('pymordemos.analyze_pickle',
                    ['histogram', '--detailed-data=' + os.path.join(d, 'data_detailed'), os.path.join(d, 'data_reduced'),
                     10]))
     finally:
         shutil.rmtree(d)
 
 
+@pytest.mark.builtin
 def test_analyze_pickle3():
     d = mkdtemp()
     try:
         test_demos(('pymordemos.thermalblock', ['--pickle=' + os.path.join(d, 'data'), 2, 2, 2, 10]))
         test_demos(('pymordemos.analyze_pickle',
                    ['convergence', '--error-norm=h1_0_semi', os.path.join(d, 'data_reduced'),
                     os.path.join(d, 'data_detailed'), 10]))
     finally:
         shutil.rmtree(d)
 
 
+@pytest.mark.builtin
 def test_analyze_pickle4():
     d = mkdtemp()
     try:
         test_demos(('pymordemos.thermalblock', ['--pickle=' + os.path.join(d, 'data'), 2, 2, 2, 10]))
         test_demos(('pymordemos.analyze_pickle',
                    ['convergence', os.path.join(d, 'data_reduced'),
                     os.path.join(d, 'data_detailed'), 10]))
@@ -313,19 +337,20 @@
     _skip_if_no_solver(ipy_args)
     from pymor.tools import mpi
     if mpi.parallel:  # simply running 'ipcluster start' (without any profile) does not seem to work
         return        # when running under mpirun, so we do not test this combination for now
     try:
         test_demos((f'pymordemos.{ipy_args[0]}', ['--ipython-engines=2'] + ipy_args[1]))
     finally:
-        import time     # there seems to be no way to shutdown the IPython cluster s.t. a new
+        import time  # there seems to be no way to shutdown the IPython cluster s.t. a new
         time.sleep(10)  # cluster can be started directly afterwards, so we have to wait ...
 
 
 def test_thermalblock_results(thermalblock_args):
+    _skip_if_no_solver(thermalblock_args)
     from pymordemos import thermalblock
     app = Typer()
     app.command()(thermalblock.main)
     args = [str(arg) for arg in thermalblock_args[1]]
     _test_demo(lambda: runner.invoke(app, args, catch_exceptions=False))
     results = thermalblock.test_results
     # due to the symmetry of the problem and the random test parameters, the estimated
@@ -335,32 +360,48 @@
     check_results('test_thermalblock_results', thermalblock_args[1], results,
                   first_tolerance, 'basis_sizes', 'norms', 'max_norms',
                   (1e-13, 4.), 'errors', 'max_errors', 'rel_errors', 'max_rel_errors',
                   'error_estimates', 'max_error_estimates', 'effectivities',
                   'min_effectivities', 'max_effectivities', 'errors')
 
 
+@pytest.mark.builtin
 def test_burgers_ei_results():
     from pymordemos import burgers_ei
     app = Typer()
     app.command()(burgers_ei.main)
-    args = list(map(str, [1, 2, 10, 100, 10, 30]))
+    args = list(map(str, [1, 2, 2, 5, 2, 5])) + ['--grid=20']
     _test_demo(lambda: runner.invoke(app, args, catch_exceptions=False))
     ei_results, greedy_results = burgers_ei.test_results
     ei_results['greedy_max_errs'] = greedy_results['max_errs']
     check_results('test_burgers_ei_results', args, ei_results,
                   (1e-13, 1e-7), 'errors', 'triangularity_errors', 'greedy_max_errs')
 
 
+@pytest.mark.builtin
 def test_parabolic_mor_results():
     from pymordemos import parabolic_mor
     args = ['pymor', 'greedy', 5, 20, 3]
     results = _test_demo(lambda: parabolic_mor.main(*args))
     check_results('test_parabolic_mor_results', args, results,
                   (1e-13, 1e-7), 'basis_sizes', 'norms', 'max_norms',
                   (1e-13, 4.), 'errors', 'max_errors', 'rel_errors', 'max_rel_errors',
                   'error_estimates', 'max_error_estimates', 'effectivities',
                   'min_effectivities', 'max_effectivities', 'errors')
 
 
-if __name__ == "__main__":
+@pytest.mark.builtin
+def test_check_check_results_missing(tmp_path):
+    test_name = tmp_path.name
+    args = ['NONE', tmp_path]
+    results = {'error': math.pi}
+    with pytest.raises(NoResultDataError):
+        check_results(test_name, args, results, 'error')
+    # running same check again against now recored data must be fine
+    check_results(test_name, args, results, 'error')
+    with pytest.raises(AssertionError):
+        results['error'] += 1
+        check_results(test_name, args, results, 'error')
+
+
+if __name__ == '__main__':
     runmodule(filename=__file__)
```

### Comparing `pymor-2022.2.1/src/pymortests/discretizers/affine_grid.py` & `pymor-2023.1.0/src/pymortests/discretizers/affine_grid.py`

 * *Files 2% similar despite different names*

```diff
@@ -5,16 +5,21 @@
 import numpy as np
 import pytest
 from hypothesis import given, settings
 
 from pymor.discretizers.builtin.grids.interfaces import ReferenceElement
 from pymor.tools.floatcmp import almost_less
 from pymortests.base import runmodule
-from pymortests.fixtures.grid import hy_grid, hy_grid_with_orthogonal_centers, \
-    hy_grid_and_codim_product_and_entity_index
+from pymortests.fixtures.grid import (
+    hy_grid,
+    hy_grid_and_codim_product_and_entity_index,
+    hy_grid_with_orthogonal_centers,
+)
+
+pytestmark = pytest.mark.builtin
 
 
 def _scale_tols_if_domain_bad(g, atol=1e-05, rtol=1e-08):
     # "badly" shaped domains produce excessive errors
     # same for large differences in absolute coord values
     bbox = g.bounding_box()
     scale = 1.0
@@ -372,9 +377,9 @@
         if -1 in SUE[s]:
             continue
         SEGMENT = C[SUE[s, 0]] - C[SUE[s, 1]]
         SPROD = EMB[s].dot(SEGMENT)
         np.testing.assert_allclose(SPROD, 0)
 
 
-if __name__ == "__main__":
+if __name__ == '__main__':
     runmodule(filename=__file__)
```

### Comparing `pymor-2022.2.1/src/pymortests/discretizers/grid.py` & `pymor-2023.1.0/src/pymortests/discretizers/grid.py`

 * *Files 2% similar despite different names*

```diff
@@ -4,20 +4,26 @@
 
 from itertools import product
 
 import numpy as np
 import pytest
 from hypothesis import given, settings
 
-from pymor.core.exceptions import QtMissing
-from pymortests.base import might_exceed_deadline
-from pymortests.fixtures.grid import hy_grids_with_visualize, hy_grid, hy_grid_and_dim_range_product, \
-    hy_grid_and_dim_range_product_and_s_max_en, hy_grid_and_dim_range_product_and_s, \
-    hy_grid_and_dim_range_product_and_s_to_e
+from pymor.core.exceptions import QtMissingError
 from pymortests.core.pickling import assert_picklable_without_dumps_function
+from pymortests.fixtures.grid import (
+    hy_grid,
+    hy_grid_and_dim_range_product,
+    hy_grid_and_dim_range_product_and_s,
+    hy_grid_and_dim_range_product_and_s_max_en,
+    hy_grid_and_dim_range_product_and_s_to_e,
+    hy_grids_with_visualize,
+)
+
+pytestmark = pytest.mark.builtin
 
 
 @given(hy_grid)
 def test_dim(grid):
     g = grid
     assert isinstance(g.dim, int)
     assert g.dim >= 0
@@ -237,47 +243,42 @@
         g.neighbours(e, -1, g.dim)
     with pytest.raises(AssertionError):
         g.neighbours(g.dim + 1, g.dim, g.dim)
     with pytest.raises(AssertionError):
         g.neighbours(-1, 0, g.dim)
 
 
-@might_exceed_deadline(2000)
 @given(hy_grid_and_dim_range_product_and_s_max_en())
 def test_neighbours_shape(grid_and_dims):
     g, e, n, s = grid_and_dims
     assert g.neighbours(e, n, s).ndim == 2
     assert g.neighbours(e, n, s).shape[0] == g.size(e)
 
 
-@might_exceed_deadline(2000)
 @given(hy_grid_and_dim_range_product_and_s_max_en())
 def test_neighbours_dtype(grid_and_dims):
     g, e, n, s = grid_and_dims
     assert g.neighbours(e, n, s).dtype == np.dtype('int32')
 
 
-@might_exceed_deadline(2000)
 @given(hy_grid_and_dim_range_product_and_s_max_en())
 def test_neighbours_entry_value_range(grid_and_dims):
     g, e, n, s = grid_and_dims
     np.testing.assert_array_less(g.neighbours(e, n, s), g.size(n))
     np.testing.assert_array_less(-2, g.neighbours(e, n, s))
 
 
-@might_exceed_deadline(2000)
 @given(hy_grid_and_dim_range_product_and_s_max_en())
 def test_neighbours_entry_values_unique(grid_and_dims):
     g, e, n, s = grid_and_dims
     for S in g.neighbours(e, n, s):
         S = S[S >= 0]
         assert S.size == np.unique(S).size
 
 
-@might_exceed_deadline(5000)
 @given(hy_grid_and_dim_range_product_and_s_max_en())
 def test_neighbours_each_entry_neighbour(grid_and_dims):
     g, e, n, s = grid_and_dims
     N = g.neighbours(e, n, s)
     ESE = g.subentities(e, s)
     NSE = g.subentities(n, s)
     for index, neigh in np.ndenumerate(N):
@@ -285,15 +286,14 @@
             inter = set(ESE[index[0]]).intersection(set(NSE[neigh]))
             if -1 in inter:
                 assert len(inter) > 1
             else:
                 assert len(inter) > 0
 
 
-@might_exceed_deadline(4000)
 @given(hy_grid_and_dim_range_product_and_s_max_en())
 def test_neighbours_each_neighbour_has_entry(grid_and_dims):
     g, e, n, s = grid_and_dims
     N = g.neighbours(e, n, s)
     SUE = g.superentities(s, e)
     SUN = g.superentities(s, n)
     if e != n:
@@ -306,15 +306,14 @@
         for si in range(SUE.shape[0]):
             for ei, ni in product(SUE[si], SUN[si]):
                 if ei != ni and ei != -1 and ni != -1:
                     assert ni in N[ei],\
                         f'Failed for\n{g}\ne={e}, n={n}, s={s}, ei={ei}, ni={ni}'
 
 
-@might_exceed_deadline(2000)
 @given(hy_grid_and_dim_range_product_and_s_max_en())
 def test_neighbours_not_neighbour_of_itself(grid_and_dims):
     g, e, _, s = grid_and_dims
     N = g.neighbours(e, e, s)
     for ei, E in enumerate(N):
         assert ei not in E,\
             f'Failed for\n{g}\ne={e}, s={s}, ei={ei}, E={E}'
@@ -395,15 +394,14 @@
 @given(hy_grid)
 def test_boundaries_dtype(grid):
     g = grid
     for d in range(g.dim + 1):
         assert g.boundaries(d).dtype == np.dtype('int32')
 
 
-@might_exceed_deadline(2000)
 @given(hy_grid)
 def test_boundaries_entry_value_range(grid):
     g = grid
     for d in range(g.dim + 1):
         np.testing.assert_array_less(g.boundaries(d), g.size(d))
         np.testing.assert_array_less(-1, g.boundaries(d))
 
@@ -425,24 +423,24 @@
 def test_visualize(grids_with_visualize):
     import sys
     sys._called_from_test = True
 
     def nop(*args, **kwargs):
         pass
     try:
-        from matplotlib import pyplot
+        from matplotlib import pyplot as plt
         if sys.version_info[:2] > (3, 7) or (
                 sys.version_info[0] == 3 and sys.version_info[1] == 6):
-            pyplot.ion()
+            plt.ion()
         else:
             # the ion switch results in interpreter segfaults during multiple
             # demo tests on 3.7 -> fall back on old monkeying solution
-            pyplot.show = nop
+            plt.show = nop
     except ImportError:
         pass
 
     try:
         g = grids_with_visualize
         U = np.ones(g.size(g.dim))
         g.visualize(U, g.dim)
-    except QtMissing:
-        pytest.xfail("Qt missing")
+    except QtMissingError:
+        pytest.xfail('Qt missing')
```

### Comparing `pymor-2022.2.1/src/pymortests/discretizers/gui.py` & `pymor-2023.1.0/src/pymortests/discretizers/gui.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,24 +1,25 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
-from pymor.discretizers.builtin.grids.oned import OnedGrid
-
-import pytest
 import numpy as np
-from pymor.analyticalproblems.domaindescriptions import RectDomain, LineDomain
+import pytest
+
+from pymor.analyticalproblems.domaindescriptions import LineDomain, RectDomain
 from pymor.analyticalproblems.elliptic import StationaryProblem
 from pymor.analyticalproblems.functions import GenericFunction
-from pymor.core.exceptions import QtMissing
-from pymor.discretizers.builtin import discretize_stationary_cg, RectGrid
+from pymor.core.exceptions import QtMissingError
+from pymor.discretizers.builtin import RectGrid, discretize_stationary_cg
 from pymor.discretizers.builtin.domaindiscretizers.default import discretize_domain_default
-
+from pymor.discretizers.builtin.grids.oned import OnedGrid
 from pymortests.base import runmodule
 
+pytestmark = pytest.mark.builtin
+
 
 @pytest.fixture(params=(('matplotlib', RectGrid), ('gl', RectGrid), ('matplotlib', OnedGrid)))
 def backend_gridtype(request):
     return request.param
 
 
 def test_visualize_patch(backend_gridtype):
@@ -35,13 +36,13 @@
     try:
         if dim == 1:
             from pymor.discretizers.builtin.gui.qt import visualize_matplotlib_1d
             visualize_matplotlib_1d(data['grid'], U=U)
         else:
             from pymor.discretizers.builtin.gui.qt import visualize_patch
             visualize_patch(data['grid'], U=U, backend=backend)
-    except QtMissing:
+    except QtMissingError:
         pytest.xfail('Qt missing')
 
 
-if __name__ == "__main__":
+if __name__ == '__main__':
     runmodule(filename=__file__)
```

### Comparing `pymor-2022.2.1/src/pymortests/fixtures/analyticalproblem.py` & `pymor-2023.1.0/src/pymortests/fixtures/analyticalproblem.py`

 * *Files 7% similar despite different names*

```diff
@@ -3,20 +3,19 @@
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 import pytest
 
 from pymor.analyticalproblems.burgers import burgers_problem, burgers_problem_2d
 from pymor.analyticalproblems.domaindescriptions import RectDomain
 from pymor.analyticalproblems.elliptic import StationaryProblem
-from pymor.analyticalproblems.functions import GenericFunction, ConstantFunction, LincombFunction
+from pymor.analyticalproblems.functions import ConstantFunction, GenericFunction, LincombFunction
 from pymor.analyticalproblems.helmholtz import helmholtz_problem
 from pymor.analyticalproblems.thermalblock import thermal_block_problem
 from pymor.parameters.functionals import ExpressionParameterFunctional
 
-
 picklable_thermalblock_problems = [
     thermal_block_problem(),
     thermal_block_problem(num_blocks=(3, 2)),
     thermal_block_problem(num_blocks=(1, 1)),
     thermal_block_problem(num_blocks=(2, 2), parameter_range=(1., 100.)),
 ]
```

### Comparing `pymor-2022.2.1/src/pymortests/fixtures/function.py` & `pymor-2023.1.0/src/pymortests/fixtures/function.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,17 +1,15 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 import numpy as np
-
 import pytest
 
-from pymor.analyticalproblems.functions import ConstantFunction, GenericFunction, ExpressionFunction
-
+from pymor.analyticalproblems.functions import ConstantFunction, ExpressionFunction, GenericFunction
 
 constant_functions = [
     ConstantFunction(),
     ConstantFunction(np.array([1., 2., 3.]), dim_domain=7),
     ConstantFunction(np.eye(27), dim_domain=2),
     ConstantFunction(np.array(3), dim_domain=1),
 ]
@@ -46,16 +44,17 @@
 
 picklable_generic_functions = [
     GenericFunction(importable_function, dim_domain=3, shape_range=(1,)),
 ]
 
 expression_functions = [
     ExpressionFunction('x', dim_domain=2),
-    ExpressionFunction("c[0]*x", dim_domain=1, parameters={'c': 1}),
-    ExpressionFunction("c[2]*sin(x)", dim_domain=1, parameters={'c': 3}),
+    ExpressionFunction('c[0]*x', dim_domain=1, parameters={'c': 1}),
+    ExpressionFunction('c[2]*sin(x)', dim_domain=1, parameters={'c': 3}),
+    ExpressionFunction('(0<x<=1)*c[0]*x', dim_domain=1, parameters={'c': 1}),
 ]
 
 
 @pytest.fixture(params=constant_functions + generic_functions + picklable_generic_functions + expression_functions)
 def function(request):
     return request.param
```

### Comparing `pymor-2022.2.1/src/pymortests/fixtures/grid.py` & `pymor-2023.1.0/src/pymortests/fixtures/grid.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 import math as m
 
-from hypothesis import strategies as hyst
 import numpy as np
+from hypothesis import strategies as hyst
 
 from pymor.discretizers.builtin.grids.oned import OnedGrid
 from pymor.discretizers.builtin.grids.rect import RectGrid
 from pymor.discretizers.builtin.grids.subgrid import SubGrid
 from pymor.discretizers.builtin.grids.tria import TriaGrid
 from pymor.discretizers.builtin.grids.unstructured import UnstructuredTriangleGrid
 
@@ -39,16 +39,16 @@
     interval_i = hyst.integers(min_value=1, max_value=42)
 
     lambda x: (not identify_left_right) or x > 1
     num_intervals = draw(hyst.tuples(interval_i.map(lambda x: x if not identify_left_right else max(2, x)),
                                      interval_i.map(lambda y: y if not identify_bottom_top else max(2, y))))
 
     domain = _hy_domain_bounds(draw, grid_type=grid_type)
-    return {"num_intervals": num_intervals, "domain": domain, "identify_left_right": identify_left_right,
-            "identify_bottom_top": identify_bottom_top}
+    return {'num_intervals': num_intervals, 'domain': domain, 'identify_left_right': identify_left_right,
+            'identify_bottom_top': identify_bottom_top}
 
 
 @hyst.composite
 def hy_rect_grid(draw):
     return RectGrid(**_hy_rect_tria_kwargs(draw, RectGrid))
```

### Comparing `pymor-2022.2.1/src/pymortests/fixtures/model.py` & `pymor-2023.1.0/src/pymortests/fixtures/model.py`

 * *Files 27% similar despite different names*

```diff
@@ -2,18 +2,21 @@
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 from itertools import product
 
 import pytest
 
-from pymor.discretizers.builtin import discretize_stationary_cg, discretize_instationary_fv
-from pymortests.fixtures.analyticalproblem import (picklable_thermalblock_problems, non_picklable_thermalblock_problems,
-                                                   burgers_problems)
-
+from pymor.discretizers.builtin import discretize_instationary_fv, discretize_stationary_cg
+from pymortests.base import BUILTIN_DISABLED
+from pymortests.fixtures.analyticalproblem import (
+    burgers_problems,
+    non_picklable_thermalblock_problems,
+    picklable_thermalblock_problems,
+)
 
 stationary_cg_generators = \
     [lambda p=p, d=d: discretize_stationary_cg(p, diameter=d)[0]
      for p, d in product(picklable_thermalblock_problems, [1./50., 1./100.])]
 
 picklable_model_generators = stationary_cg_generators \
     + [lambda p=p, d=d: discretize_instationary_fv(p, diameter=d, nt=100)[0]
@@ -24,21 +27,22 @@
     [lambda p=p, d=d: discretize_stationary_cg(p, diameter=d)[0]
      for p, d in product(non_picklable_thermalblock_problems, [1./20., 1./30.])]
 
 
 model_generators = picklable_model_generators + non_picklable_model_generators
 
 
-@pytest.fixture(params=model_generators)
+@pytest.fixture(params=[] if BUILTIN_DISABLED else model_generators)
 def model(request):
     return request.param()
 
 
-@pytest.fixture(params=[lambda p=p, d=d: discretize_stationary_cg(p, diameter=d)[0]
-                        for p, d in product(non_picklable_thermalblock_problems, [1./20., 1./30.])])
+@pytest.fixture(params=[] if BUILTIN_DISABLED else
+                       ([lambda p=p, d=d: discretize_stationary_cg(p, diameter=d)[0]
+                        for p, d in product(non_picklable_thermalblock_problems, [1./20., 1./30.])]))
 def stationary_models(request):
     return request.param()
 
 
-@pytest.fixture(params=picklable_model_generators)
+@pytest.fixture(params=[] if BUILTIN_DISABLED else picklable_model_generators)
 def picklable_model(request):
     return request.param()
```

### Comparing `pymor-2022.2.1/src/pymortests/fixtures/operator.py` & `pymor-2023.1.0/src/pymortests/fixtures/operator.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,21 +1,22 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 import numpy as np
-from numpy.polynomial.polynomial import Polynomial
 import pytest
+from numpy.polynomial.polynomial import Polynomial
 
 from pymor.core.config import config
 from pymor.operators.constructions import IdentityOperator
 from pymor.operators.interface import Operator
 from pymor.operators.list import NumpyListVectorArrayMatrixOperator
 from pymor.operators.numpy import NumpyMatrixOperator
 from pymor.vectorarrays.numpy import NumpyVectorSpace
+from pymortests.base import BUILTIN_DISABLED
 
 
 class MonomOperator(Operator):
     source = range = NumpyVectorSpace(1)
 
     def __init__(self, order, monom=None):
         self.monom = monom if monom else Polynomial(np.identity(order + 1)[order])
@@ -401,15 +402,15 @@
         mu = op.parameters.parse({'p': [1, 2, 3], 'q': 4})
         sp = BlockDiagonalOperator([sp0, sp1])
         rp = BlockDiagonalOperator([rp0, rp1])
         U = op.source.make_array([U0, U1])
         V = op.range.make_array([V0, V1])
         return op, mu, U, V, sp, rp
     elif n == 10:
-        from pymor.operators.block import BlockDiagonalOperator, BlockColumnOperator
+        from pymor.operators.block import BlockColumnOperator, BlockDiagonalOperator
         from pymor.parameters.functionals import ProjectionParameterFunctional
         op0, _, U0, V0, sp0, rp0 = numpy_matrix_operator_with_arrays_and_products_factory(10, 10, 4, 3)
         op1, _, U1, V1, sp1, rp1 = numpy_matrix_operator_with_arrays_and_products_factory(20, 20, 4, 3)
         op2a, _, _, _, _, _       = numpy_matrix_operator_with_arrays_and_products_factory(20, 10, 4, 3)
         op2b, _, _, _, _, _       = numpy_matrix_operator_with_arrays_and_products_factory(20, 10, 4, 3)
         op2 = (op2a * ProjectionParameterFunctional('p', 3, 0)
                + op2b * ProjectionParameterFunctional('q', 1))
@@ -493,50 +494,52 @@
     [lambda n=n: unpicklable_misc_operator_with_arrays_and_products_factory(n)
      for n in range(num_unpicklable_misc_operators)]
 
 
 if config.HAVE_FENICS:
     def fenics_matrix_operator_factory():
         import dolfin as df
+
         from pymor.bindings.fenics import FenicsMatrixOperator
 
         mesh = df.UnitSquareMesh(10, 10)
-        V = df.FunctionSpace(mesh, "CG", 2)
+        V = df.FunctionSpace(mesh, 'CG', 2)
 
         u = df.TrialFunction(V)
         v = df.TestFunction(V)
         c = df.Constant([1, 1])
 
         op = FenicsMatrixOperator(
             df.assemble(u * v * df.dx + df.inner(c, df.grad(u)) * v * df.dx),
             V, V)
 
         prod = FenicsMatrixOperator(df.assemble(u*v*df.dx), V, V)
         return op, None, op.source.random(), op.range.random(), prod, prod
 
     def fenics_nonlinear_operator_factory():
         import dolfin as df
-        from pymor.bindings.fenics import FenicsVectorSpace, FenicsOperator, FenicsMatrixOperator
+
+        from pymor.bindings.fenics import FenicsMatrixOperator, FenicsOperator, FenicsVectorSpace
 
         class DirichletBoundary(df.SubDomain):
             def inside(self, x, on_boundary):
                 return abs(x[0] - 1.0) < df.DOLFIN_EPS and on_boundary
 
         mesh = df.UnitSquareMesh(10, 10)
-        V = df.FunctionSpace(mesh, "CG", 2)
+        V = df.FunctionSpace(mesh, 'CG', 2)
 
         g = df.Constant(1.)
         c = df.Constant(1.)
         db = DirichletBoundary()
         bc = df.DirichletBC(V, g, db)
 
         u = df.TrialFunction(V)
         v = df.TestFunction(V)
         w = df.Function(V)
-        f = df.Expression("x[0]*sin(x[1])", degree=2)
+        f = df.Expression('x[0]*sin(x[1])', degree=2)
         F = df.inner((1 + c*w**2)*df.grad(w), df.grad(v))*df.dx - f*v*df.dx
 
         space = FenicsVectorSpace(V)
         op = FenicsOperator(F, space, space, w, (bc,),
                             parameter_setter=lambda mu: c.assign(mu['c'].item()),
                             parameters={'c': 1},
                             solver_options={'inverse': {'type': 'newton', 'rtol': 1e-6}})
@@ -553,89 +556,110 @@
         lambda: fenics_nonlinear_operator_factory()[:4],
     ]
 else:
     fenics_with_arrays_and_products_generators = []
     fenics_with_arrays_generators = []
 
 
-@pytest.fixture(params=(
+builtin_operator_with_arrays_and_products_generators = (
+    [] if BUILTIN_DISABLED else
     thermalblock_operator_with_arrays_and_products_generators
     + thermalblock_assemble_operator_with_arrays_and_products_generators
     + thermalblock_concatenation_operator_with_arrays_and_products_generators
     + thermalblock_identity_operator_with_arrays_and_products_generators
     + thermalblock_zero_operator_with_arrays_and_products_generators
     + thermalblock_constant_operator_with_arrays_and_products_generators
     + thermalblock_vectorarray_operator_with_arrays_and_products_generators
     + thermalblock_vector_operator_with_arrays_and_products_generators
     + thermalblock_vectorfunc_operator_with_arrays_and_products_generators
     + thermalblock_fixedparam_operator_with_arrays_and_products_generators
     + misc_operator_with_arrays_and_products_generators
     + unpicklable_misc_operator_with_arrays_and_products_generators
+)
+
+
+@pytest.fixture(params=(
+    builtin_operator_with_arrays_and_products_generators
     + fenics_with_arrays_and_products_generators
 ))
 def operator_with_arrays_and_products(reset_rng, request):
     return request.param()
 
 
-@pytest.fixture(params=(
+builtin_operator_with_arrays_generators = (
+    [] if BUILTIN_DISABLED else
     numpy_matrix_operator_with_arrays_generators
     + numpy_list_vector_array_matrix_operator_with_arrays_generators
     + thermalblock_operator_with_arrays_generators
     + thermalblock_assemble_operator_with_arrays_generators
     + thermalblock_concatenation_operator_with_arrays_generators
     + thermalblock_identity_operator_with_arrays_generators
     + thermalblock_zero_operator_with_arrays_generators
     + thermalblock_constant_operator_with_arrays_generators
     + thermalblock_vectorarray_operator_with_arrays_generators
     + thermalblock_vector_operator_with_arrays_generators
     + thermalblock_vectorfunc_operator_with_arrays_generators
     + thermalblock_fixedparam_operator_with_arrays_generators
     + misc_operator_with_arrays_generators
     + unpicklable_misc_operator_with_arrays_generators
+)
+
+@pytest.fixture(params=(
+    builtin_operator_with_arrays_generators
     + fenics_with_arrays_generators
 ))
 def operator_with_arrays(reset_rng, request):
     return request.param()
 
 
-@pytest.fixture(params=(
+builtin_operator_generators = (
+    [] if BUILTIN_DISABLED else
     numpy_matrix_operator_generators
     + numpy_list_vector_array_matrix_operator_generators
     + thermalblock_operator_generators
     + thermalblock_assemble_operator_generators
     + thermalblock_concatenation_operator_generators
     + thermalblock_identity_operator_generators
     + thermalblock_zero_operator_generators
     + thermalblock_constant_operator_generators
     + thermalblock_vectorarray_operator_generators
     + thermalblock_vector_operator_generators
     + thermalblock_vectorfunc_operator_generators
     + thermalblock_fixedparam_operator_generators
     + misc_operator_generators
     + unpicklable_misc_operator_generators
+)
+
+@pytest.fixture(params=(
+    builtin_operator_generators
 ))
 def operator(reset_rng, request):
     return request.param()
 
 
-@pytest.fixture(params=(
+builtin_picklable_operator_generators = (
+    [] if BUILTIN_DISABLED else
     numpy_matrix_operator_generators
     + numpy_list_vector_array_matrix_operator_generators
     + thermalblock_operator_generators
     + thermalblock_assemble_operator_generators
     + thermalblock_concatenation_operator_generators
     + thermalblock_identity_operator_generators
     + thermalblock_zero_operator_generators
     + thermalblock_constant_operator_generators
     + thermalblock_vectorarray_operator_generators
     + thermalblock_vector_operator_generators
     + thermalblock_vectorfunc_operator_generators
     + thermalblock_fixedparam_operator_generators
     + misc_operator_generators
+)
+
+@pytest.fixture(params=(
+    builtin_picklable_operator_generators
 ))
 def picklable_operator(reset_rng, request):
     return request.param()
 
 
 @pytest.fixture
 def loadable_matrices(shared_datadir):
-    return (shared_datadir / "matrices").glob('*')
+    return (shared_datadir / 'matrices').glob('*')
```

### Comparing `pymor-2022.2.1/src/pymortests/models/iosys_save_load.py` & `pymor-2023.1.0/src/pymortests/models/iosys_save_load.py`

 * *Files 15% similar despite different names*

```diff
@@ -6,15 +6,17 @@
 import tempfile
 
 import numpy as np
 import pytest
 import scipy.io as spio
 import scipy.sparse as sps
 
-from pymor.models.iosys import LTIModel, SecondOrderModel
+from pymor.models.iosys import LTIModel, PHLTIModel, SecondOrderModel
+
+pytestmark = pytest.mark.builtin
 
 
 def _build_matrices_lti(with_D, with_E):
     A = sps.csc_matrix([[1, 2], [3, 4]])
     B = np.array([[1], [2]])
     C = np.array([[1, 2]])
     D = np.array([[1]]) if with_D else None
@@ -34,14 +36,55 @@
         assert D2 is None
     if with_E:
         assert np.allclose(E, E2)
     else:
         assert E2 is None
 
 
+def _build_matrices_phlti(with_P, with_S, with_N, with_E, with_Q):
+    J = sps.csc_matrix([[0, -1], [1, 0]])
+    R = sps.csc_matrix([[1, 0], [0, 1]])
+    G = np.array([[1], [0]])
+    P = np.array([[2], [0]]) if with_P else None
+    S = np.array([[1]]) if with_S else None
+    N = np.array([[0]]) if with_N else None
+    E = np.array([[1, 0], [0, 2]]) if with_E else None
+    Q = np.array([[2, 0], [0, 1]]) if with_Q else None
+    return J, R, G, P, S, N, E, Q
+
+
+def _test_matrices_phlti(J, R, G, P, S, N, E, Q,
+                         J2, R2, G2, P2, S2, N2, E2, Q2,
+                         with_P, with_S, with_N, with_E, with_Q):
+    assert np.allclose(J.toarray(), J2.toarray())
+    assert np.allclose(R.toarray(), R2.toarray())
+    assert np.allclose(G, G2)
+
+    if with_P:
+        assert np.allclose(P, P2)
+    else:
+        assert P2 is None
+    if with_S:
+        assert np.allclose(S, S2)
+    else:
+        assert S2 is None
+    if with_N:
+        assert np.allclose(N, N2)
+    else:
+        assert N2 is None
+    if with_E:
+        assert np.allclose(E, E2)
+    else:
+        assert E2 is None
+    if with_Q:
+        assert np.allclose(Q, Q2)
+    else:
+        assert Q2 is None
+
+
 def _build_matrices_so(with_Cv, with_D):
     M = sps.csc_matrix([[1, 2], [3, 4]])
     E = np.array([[5, 6], [7, 8]])
     K = np.array([[9, 10], [11, 12]])
     B = np.array([[1], [2]])
     Cp = np.array([[1, 2]])
     Cv = np.array([[3, 4]]) if with_Cv else None
@@ -139,14 +182,28 @@
         lti.to_abcde_files(files_basename)
         lti2 = LTIModel.from_abcde_files(files_basename)
     matrices2 = lti2.to_matrices()
 
     _test_matrices_lti(*matrices, *matrices2, with_D, with_E)
 
 
+@pytest.mark.parametrize('with_P', [False, True])
+@pytest.mark.parametrize('with_S', [False, True])
+@pytest.mark.parametrize('with_N', [False, True])
+@pytest.mark.parametrize('with_E', [False, True])
+@pytest.mark.parametrize('with_Q', [False, True])
+def test_matrices_phlti(with_P, with_S, with_N, with_E, with_Q):
+    matrices = _build_matrices_phlti(with_P, with_S, with_N, with_E, with_Q)
+
+    phlti = PHLTIModel.from_matrices(*matrices)
+    matrices2 = phlti.to_matrices()
+
+    _test_matrices_phlti(*matrices, *matrices2, with_P, with_S, with_N, with_E, with_Q)
+
+
 @pytest.mark.parametrize('with_Cv', [False, True])
 @pytest.mark.parametrize('with_D', [False, True])
 def test_matrices_so(with_Cv, with_D):
     matrices = _build_matrices_so(with_Cv, with_D)
 
     som = SecondOrderModel.from_matrices(*matrices)
     matrices2 = som.to_matrices()
```

### Comparing `pymor-2022.2.1/src/pymortests/models/model.py` & `pymor-2023.1.0/src/pymortests/models/model.py`

 * *Files 4% similar despite different names*

```diff
@@ -3,26 +3,28 @@
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 import numpy as np
 import pytest
 
 from pymor.algorithms.basic import almost_equal
 from pymor.algorithms.timestepping import ExplicitEulerTimeStepper, ImplicitMidpointTimeStepper
-from pymor.analyticalproblems.functions import ExpressionFunction, ConstantFunction
+from pymor.analyticalproblems.functions import ConstantFunction, ExpressionFunction
 from pymor.analyticalproblems.thermalblock import thermal_block_problem
 from pymor.core.pickle import dumps, loads
 from pymor.discretizers.builtin import discretize_stationary_cg
 from pymor.models.iosys import LTIModel
 from pymor.models.symplectic import QuadraticHamiltonianModel
 from pymor.operators.block import BlockDiagonalOperator
 from pymor.operators.constructions import IdentityOperator
 from pymor.vectorarrays.numpy import NumpyVectorSpace
 from pymortests.base import runmodule
 from pymortests.core.pickling import assert_picklable, assert_picklable_without_dumps_function
 
+pytestmark = pytest.mark.builtin
+
 
 def test_pickle(model):
     assert_picklable(model)
 
 
 def test_pickle_without_dumps_function(picklable_model):
     assert_picklable_without_dumps_function(picklable_model)
@@ -129,9 +131,9 @@
     y_step2, X_step = lti.step_resp(return_solution=True)
     assert np.all(y_step == y_step2)
     assert isinstance(X_step, tuple)
     assert all(Xi.dim == 2 for Xi in X_step)
     assert all(len(Xi) == len(X) for Xi in X_step)
 
 
-if __name__ == "__main__":
+if __name__ == '__main__':
     runmodule(filename=__file__)
```

### Comparing `pymor-2022.2.1/src/pymortests/models/transforms.py` & `pymor-2023.1.0/src/pymortests/models/transforms.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,23 +1,25 @@
 # This file is part of the pyMOR project (http://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (http://opensource.org/licenses/BSD-2-Clause)
 
+from itertools import combinations
+
 import numpy as np
 import pytest
-from itertools import combinations
 
 from pymor.models.iosys import LTIModel
 from pymor.models.transforms import BilinearTransformation, CayleyTransformation, MoebiusTransformation
 
-
 type_list = ['BilinearTransformation', 'CayleyTransformation', 'MoebiusTransformation']
 points_list = list(combinations([0, 1, -1, 1j, -1j, np.inf], 3))
 sampling_time_list = [0, 1/100, 2]
 
+pytestmark = pytest.mark.builtin
+
 
 def get_transformation(name):
     if name == 'BilinearTransformation':
         return BilinearTransformation(2)
     elif name == 'CayleyTransformation':
         return CayleyTransformation()
     elif name == 'MoebiusTransformation':
```

### Comparing `pymor-2022.2.1/src/pymortests/mpi_run_demo_tests.py` & `pymor-2023.1.0/src/pymortests/mpi_run_demo_tests.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,17 +1,19 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 if __name__ == '__main__':
-    from pymor.tools import mpi
-    import pytest
     import os
     from pathlib import Path
 
+    import pytest
+
+    from pymor.tools import mpi
+
     this_dir = Path(__file__).resolve().parent
     pymor_root_dir = (this_dir / '..' / '..').resolve()
 
     result_file_fn = pymor_root_dir / f'.mpirun_{mpi.rank}' / 'pytest.mpirun.success'
     try:
         os.unlink(result_file_fn)
     except FileNotFoundError:
@@ -22,39 +24,39 @@
         def nop(*args, **kwargs):
             pass
 
         try:
             # for MPI runs we need to import qtgui before pyplot
             # otherwise, if both pyside and pyqt5 are installed we'll get an error later
             from qtpy import QtGui  # noqa F401
-        except ImportError:
+        except RuntimeError:
             pass
 
         try:
-            from matplotlib import pyplot
-            pyplot.show = nop
+            from matplotlib import pyplot as plt
+            plt.show = nop
         except ImportError:
             pass
 
         from pymor.core.config import config
         if config.HAVE_FENICS:  # use config.HAVE_FENICS to ensure that dlopen fix is applied
-            import dolfin
-            dolfin.plot = nop
-
-        # completely disable FEniCS visualization in containers
-        import os
-        if 'DOCKER_PYMOR' in os.environ:
-            from pymor.bindings.fenics import FenicsVisualizer
-
-            FenicsVisualizer.visualize = nop
+            # completely disable FEniCS visualization in containers
+            import os
+            if 'DOCKER_PYMOR' in os.environ:
+                from pymor.bindings.fenics import FenicsVisualizer
+
+                FenicsVisualizer.visualize = nop
+            else:
+                import dolfin
+                dolfin.plot = nop
 
     mpi.call(monkey_plot)
 
     demo = str(pymor_root_dir / 'src' / 'pymortests' / 'demos.py')
-    args = ['-svx', '-k', 'test_demo', demo]
+    args = ['-svx', '-r', 'fEsx', '-k', 'test_demo', demo]
     extra = os.environ.get('PYMOR_PYTEST_EXTRA', None)
     if extra:
         args.append(extra)
     success = pytest.main(args) == pytest.ExitCode.OK
     result_file_fn.parent.resolve().mkdir(parents=True, exist_ok=True)
     with open(result_file_fn, 'wt') as result_file:
         result_file.write(f'{success}')
```

### Comparing `pymor-2022.2.1/src/pymortests/neural_network.py` & `pymor-2023.1.0/src/pymortests/neural_network.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,23 +1,26 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 import numpy as np
+import pytest
 
 from pymortests.base import skip_if_missing
 
+pytestmark = pytest.mark.builtin
+
 
 @skip_if_missing('TORCH')
 def test_linear_function_fitting():
-    from pymor.reductors.neural_network import multiple_restarts_training
-    from pymor.models.neural_network import FullyConnectedNN
-
     import torch.optim as optim
 
+    from pymor.models.neural_network import FullyConnectedNN
+    from pymor.reductors.neural_network import multiple_restarts_training
+
     n = 100
     d_in = 3
     d_out = 2
 
     a = np.random.rand(d_in, d_out)
     b = np.random.rand(d_out)
 
@@ -58,30 +61,29 @@
                                                 max_restarts=max_restarts)
     assert all(loss < tol for loss in best_losses.values())
 
 
 @skip_if_missing('TORCH')
 def test_no_training_data():
 
-    from pymor.reductors.neural_network import multiple_restarts_training
-    from pymor.models.neural_network import FullyConnectedNN
-
     import torch
 
+    from pymor.models.neural_network import FullyConnectedNN
+    from pymor.reductors.neural_network import multiple_restarts_training
+
     n = 1000
     d_in = 3
     d_out = 2
     training_data = []
     validation_data = []
     neural_network = FullyConnectedNN([d_in, 3 * (d_in + d_out), 3 * (d_in + d_out), d_out]).double()
     best_neural_network, _ = multiple_restarts_training(training_data, validation_data, neural_network)
     assert np.allclose(best_neural_network(torch.DoubleTensor(np.random.rand(n, d_in))).detach(), np.zeros(d_out))
 
 
 @skip_if_missing('TORCH')
 def test_issue_1649():
-    from pymor.models.neural_network import FullyConnectedNN
-    from pymor.models.neural_network import NeuralNetworkModel
+    from pymor.models.neural_network import FullyConnectedNN, NeuralNetworkModel
     from pymor.parameters.base import Parameters
     neural_network = FullyConnectedNN([3, 3, 3, 3]).double()
     nn_model = NeuralNetworkModel(neural_network, Parameters(mu=1))
     assert nn_model.output_functional
```

### Comparing `pymor-2022.2.1/src/pymortests/operators/block.py` & `pymor-2023.1.0/src/pymortests/operators/block.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,19 +1,22 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 import numpy as np
+import pytest
 import scipy.linalg as spla
 
+from pymor.operators.block import BlockDiagonalOperator, BlockOperator
 from pymor.operators.numpy import NumpyMatrixOperator
-from pymor.operators.block import BlockOperator, BlockDiagonalOperator
 from pymor.vectorarrays.block import BlockVectorSpace
 from pymor.vectorarrays.numpy import NumpyVectorSpace
 
+pytestmark = pytest.mark.builtin
+
 
 def test_apply():
     A11 = np.random.randn(2, 3)
     A12 = np.random.randn(2, 4)
     A21 = np.zeros((5, 3))
     A22 = np.random.randn(5, 4)
     A = np.vstack((np.hstack((A11, A12)),
@@ -103,7 +106,37 @@
     v1va = NumpyVectorSpace.from_numpy(v1)
     v2va = NumpyVectorSpace.from_numpy(v2)
     vva = BlockVectorSpace.make_array((v1va, v2va))
 
     wva = Cop.apply_inverse_adjoint(vva)
     w = np.hstack((wva.blocks[0].to_numpy(), wva.blocks[1].to_numpy()))
     assert np.allclose(spla.solve(C.T, v), w)
+
+
+def test_block_jacobian():
+    from pymor.operators.constructions import QuadraticFunctional
+
+    A = np.random.randn(2, 2)
+    B = np.random.randn(3, 3)
+    C = np.random.randn(4, 4)
+    Aop = QuadraticFunctional(NumpyMatrixOperator(A))
+    Bop = QuadraticFunctional(NumpyMatrixOperator(B))
+    Cop = NumpyMatrixOperator(C)
+    Dop = BlockDiagonalOperator((Aop, Bop, Cop))
+    Dop_single_block = BlockDiagonalOperator(np.array([[Aop]]))
+    assert not Dop.linear and not Dop_single_block.linear
+
+    v1 = np.random.randn(2)
+    v2 = np.random.randn(3)
+    v3 = np.random.randn(4)
+    v1va = NumpyVectorSpace.from_numpy(v1)
+    v2va = NumpyVectorSpace.from_numpy(v2)
+    v3va = NumpyVectorSpace.from_numpy(v3)
+    vva = BlockVectorSpace.make_array((v1va, v2va, v3va))
+    vva_single_block = BlockVectorSpace.make_array(v1va)
+
+    jac = Dop.jacobian(vva, mu=None)
+    jac_single_block = Dop_single_block.jacobian(vva_single_block, mu=None)
+    assert jac.linear and jac_single_block.linear
+    assert np.all(jac.blocks[0, 0].vector.to_numpy()[0] == np.dot(A.T, v1) + np.dot(A, v1))
+    assert np.all(jac.blocks[1, 1].vector.to_numpy()[0] == np.dot(B.T, v2) + np.dot(B, v2))
+    assert np.all(jac.blocks[2, 2].matrix == C)
```

### Comparing `pymor-2022.2.1/src/pymortests/operators/la.py` & `pymor-2023.1.0/src/pymortests/operators/la.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,25 +1,28 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 import numpy as np
+import pytest
 
+from pymor.discretizers.builtin.cg import L2ProductP1
 from pymor.discretizers.builtin.grids.boundaryinfos import AllDirichletBoundaryInfo
 from pymor.discretizers.builtin.grids.tria import TriaGrid
-from pymor.discretizers.builtin.cg import L2ProductP1
 from pymor.operators.constructions import induced_norm
 from pymortests.base import runmodule
 
+pytestmark = pytest.mark.builtin
+
 
 def test_induced():
     grid = TriaGrid(num_intervals=(10, 10))
     boundary_info = AllDirichletBoundaryInfo(grid)
     product = L2ProductP1(grid, boundary_info)
     zero = product.source.zeros()
     norm = induced_norm(product)
     value = norm(zero)
     np.testing.assert_almost_equal(value, 0.0)
 
 
-if __name__ == "__main__":
+if __name__ == '__main__':
     runmodule(filename=__file__)
```

### Comparing `pymor-2022.2.1/src/pymortests/operators/low_rank_op.py` & `pymor-2023.1.0/src/pymortests/operators/low_rank_op.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,20 +1,23 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 import numpy as np
+import pytest
 import scipy.linalg as spla
 
 from pymor.algorithms.lincomb import assemble_lincomb
 from pymor.operators.constructions import LowRankOperator, LowRankUpdatedOperator
 from pymor.operators.numpy import NumpyMatrixOperator
 from pymor.tools.random import get_rng
 from pymor.vectorarrays.numpy import NumpyVectorSpace
 
+pytestmark = pytest.mark.builtin
+
 
 def construct_operators_and_vectorarrays(m, n, r, k):
     space_m = NumpyVectorSpace(m)
     space_n = NumpyVectorSpace(n)
     A = NumpyMatrixOperator(get_rng().normal(size=(m, n)))
     L = space_m.random(r, distribution='normal')
     C = get_rng().normal(size=(r, r))
```

### Comparing `pymor-2022.2.1/src/pymortests/operators/operators.py` & `pymor-2023.1.0/src/pymortests/operators/operators.py`

 * *Files 6% similar despite different names*

```diff
@@ -4,63 +4,73 @@
 
 import numpy as np
 import pytest
 
 from pymor.algorithms.basic import almost_equal
 from pymor.algorithms.projection import project
 from pymor.algorithms.to_matrix import to_matrix
-from pymor.core.exceptions import InversionError, LinAlgError
 from pymor.core.config import config
+from pymor.core.exceptions import InversionError, LinAlgError
 from pymor.operators.block import BlockDiagonalOperator
-from pymor.operators.constructions import (SelectionOperator, InverseOperator, InverseAdjointOperator, IdentityOperator,
-                                           LincombOperator, VectorArrayOperator)
-from pymor.operators.numpy import NumpyHankelOperator, NumpyMatrixOperator
+from pymor.operators.constructions import (
+    IdentityOperator,
+    InverseAdjointOperator,
+    InverseOperator,
+    LincombOperator,
+    QuadraticFunctional,
+    QuadraticProductFunctional,
+    SelectionOperator,
+    VectorArrayOperator,
+)
 from pymor.operators.interface import as_array_max_length
-from pymor.parameters.functionals import GenericParameterFunctional, ExpressionParameterFunctional
+from pymor.operators.numpy import NumpyHankelOperator, NumpyMatrixOperator
+from pymor.parameters.functionals import ExpressionParameterFunctional, GenericParameterFunctional
 from pymor.vectorarrays.block import BlockVectorSpace
 from pymor.vectorarrays.numpy import NumpyVectorSpace
 from pymortests.base import assert_all_almost_equal
-from pymortests.fixtures.operator import MonomOperator
 from pymortests.core.pickling import assert_picklable, assert_picklable_without_dumps_function
+from pymortests.fixtures.operator import MonomOperator
 from pymortests.strategies import valid_inds, valid_inds_of_same_length
 
 
+@pytest.mark.builtin
 def test_selection_op():
     p1 = MonomOperator(1)
     select_rhs_functional = GenericParameterFunctional(
-        lambda x: round(x["nrrhs"].item()),
-        {"nrrhs": 1}
+        lambda x: round(x['nrrhs'].item()),
+        {'nrrhs': 1}
     )
     s1 = SelectionOperator(
         operators=[p1],
         boundaries=[],
         parameter_functional=select_rhs_functional,
-        name="foo"
+        name='foo'
     )
     x = np.linspace(-1., 1., num=3)
     vx = p1.source.make_array(x[:, np.newaxis])
     assert np.allclose(p1.apply(vx).to_numpy(),
                        s1.apply(vx, mu=s1.parameters.parse(0)).to_numpy())
 
     s2 = SelectionOperator(
         operators=[p1, p1, p1, p1],
         boundaries=[-3, 3, 7],
         parameter_functional=select_rhs_functional,
-        name="Bar"
+        name='Bar'
     )
 
-    assert s2._get_operator_number(s2.parameters.parse({"nrrhs": -4})) == 0
-    assert s2._get_operator_number(s2.parameters.parse({"nrrhs": -3})) == 0
-    assert s2._get_operator_number(s2.parameters.parse({"nrrhs": -2})) == 1
-    assert s2._get_operator_number(s2.parameters.parse({"nrrhs": 3})) == 1
-    assert s2._get_operator_number(s2.parameters.parse({"nrrhs": 4})) == 2
-    assert s2._get_operator_number(s2.parameters.parse({"nrrhs": 7})) == 2
-    assert s2._get_operator_number(s2.parameters.parse({"nrrhs": 9})) == 3
+    assert s2._get_operator_number(s2.parameters.parse({'nrrhs': -4})) == 0
+    assert s2._get_operator_number(s2.parameters.parse({'nrrhs': -3})) == 0
+    assert s2._get_operator_number(s2.parameters.parse({'nrrhs': -2})) == 1
+    assert s2._get_operator_number(s2.parameters.parse({'nrrhs': 3})) == 1
+    assert s2._get_operator_number(s2.parameters.parse({'nrrhs': 4})) == 2
+    assert s2._get_operator_number(s2.parameters.parse({'nrrhs': 7})) == 2
+    assert s2._get_operator_number(s2.parameters.parse({'nrrhs': 9})) == 3
 
 
+@pytest.mark.builtin
 def test_lincomb_op():
     p1 = MonomOperator(1)
     p2 = MonomOperator(2)
     p12 = p1 + p2
     p0 = p1 - p1
     x = np.linspace(-1., 1., num=3)
     vx = p1.source.make_array((x[:, np.newaxis]))
@@ -81,14 +91,15 @@
     basis = p1.source.make_array([1.])
     for p in (p1, p2, p12):
         projected = project(p, basis, basis)
         pa = projected.apply(vx)
         assert almost_equal(pa, p.apply(vx)).all()
 
 
+@pytest.mark.builtin
 def test_lincomb_op_with_zero_coefficients():
     p1 = MonomOperator(1)
     p2 = MonomOperator(2)
     p10 = p1 + 0 * p2
     p0 = 0 * p1 + 0 * p1
     x = np.linspace(-1., 1., num=3)
     vx = p1.source.make_array((x[:, np.newaxis]))
@@ -111,67 +122,125 @@
     assert np.allclose(p10.pairwise_apply2(vx, vx), p1.pairwise_apply2(vx, vx))
 
     assert np.allclose(pc0.apply_adjoint(vx).to_numpy(), [0.])
     assert len(pc0.apply_adjoint(vx)) == len(vx)
     assert almost_equal(pc10.apply_adjoint(vx), pc1.apply_adjoint(vx)).all()
 
 
+@pytest.mark.builtin
 def test_lincomb_adjoint():
     op = LincombOperator([NumpyMatrixOperator(np.eye(10)), NumpyMatrixOperator(np.eye(10))],
                          [1+3j, ExpressionParameterFunctional('c[0] + 3', {'c': 1})])
     mu = op.parameters.parse(1j)
     U = op.range.random()
     V = op.apply_adjoint(U, mu=mu)
     VV = op.H.apply(U, mu=mu)
     assert np.all(almost_equal(V, VV))
     VVV = op.apply(U, mu=mu).conj()
     assert np.all(almost_equal(V, VVV))
 
 
+@pytest.mark.builtin
 def test_identity_lincomb():
     space = NumpyVectorSpace(10)
     identity = IdentityOperator(space)
     ones = space.ones()
     idid = (identity + identity)
     idid_ = ExpressionParameterFunctional('2', {}) * identity
     assert almost_equal(ones * 2, idid.apply(ones))
     assert almost_equal(ones * 2, idid.apply_adjoint(ones))
     assert almost_equal(ones * 0.5, idid.apply_inverse(ones))
     assert almost_equal(ones * 0.5, idid.apply_inverse_adjoint(ones))
     assert almost_equal(ones * 0.5, idid_.apply_inverse(ones))
     assert almost_equal(ones * 0.5, idid_.apply_inverse_adjoint(ones))
 
 
+@pytest.mark.builtin
 def test_identity_numpy_lincomb():
     n = 2
     space = NumpyVectorSpace(n)
     identity = IdentityOperator(space)
     numpy_operator = NumpyMatrixOperator(np.ones((n, n)))
     for alpha in [-1, 0, 1]:
         for beta in [-1, 0, 1]:
             idop = alpha * identity + beta * numpy_operator
             mat1 = alpha * np.eye(n) + beta * np.ones((n, n))
             mat2 = to_matrix(idop.assemble(), format='dense')
             assert np.array_equal(mat1, mat2)
 
 
+@pytest.mark.builtin
 def test_block_identity_lincomb():
     space = NumpyVectorSpace(10)
     space2 = BlockVectorSpace([space, space])
     identity = BlockDiagonalOperator([IdentityOperator(space), IdentityOperator(space)])
     identity2 = IdentityOperator(space2)
     ones = space.ones()
     ones2 = space2.make_array([ones, ones])
     idid = identity + identity2
     assert almost_equal(ones2 * 2, idid.apply(ones2))
     assert almost_equal(ones2 * 2, idid.apply_adjoint(ones2))
     assert almost_equal(ones2 * 0.5, idid.apply_inverse(ones2))
     assert almost_equal(ones2 * 0.5, idid.apply_inverse_adjoint(ones2))
 
 
+@pytest.mark.builtin
+def test_bilin_functional():
+    space = NumpyVectorSpace(10)
+    scalar = NumpyVectorSpace(1)
+    bilin_matrix = np.eye(space.dim)
+    bilin_op = NumpyMatrixOperator(bilin_matrix)
+    bilin_op = QuadraticFunctional(bilin_op)
+
+    one_vec = np.zeros(space.dim)
+    two_vec = np.zeros(space.dim)
+    one_vec[0] = 1.
+    two_vec[0] = 2.
+    one_v = space.from_numpy(one_vec)
+    two_v = space.from_numpy(two_vec)
+    one_s = scalar.from_numpy([1.])
+    four_s = scalar.from_numpy([4.])
+
+    assert bilin_op.source == space
+    assert bilin_op.range == scalar
+    assert almost_equal(one_s, bilin_op.apply(one_v))
+    assert almost_equal(four_s, bilin_op.apply(two_v))
+
+
+@pytest.mark.builtin
+def test_bilin_prod_functional():
+    from pymor.operators.constructions import VectorFunctional
+    space = NumpyVectorSpace(10)
+    scalar = NumpyVectorSpace(1)
+    mat = 6. * np.identity(scalar.dim)
+    prod = NumpyMatrixOperator(mat)
+    lin_vec = space.ones()
+    lin_op = VectorFunctional(lin_vec)
+    bilin_op = QuadraticProductFunctional(lin_op, lin_op)
+    bilin_op_with_prod = QuadraticProductFunctional(lin_op, lin_op, product=prod)
+
+    one_vec = np.zeros(space.dim)
+    two_vec = np.zeros(space.dim)
+    one_vec[0] = 1.
+    two_vec[0] = 2.
+    one_v = space.from_numpy(one_vec)
+    two_v = space.from_numpy(two_vec)
+    one_s = scalar.from_numpy([1.])
+    four_s = scalar.from_numpy([4.])
+    six_s = scalar.from_numpy([6.])
+    twn_four_s = scalar.from_numpy([24.])
+
+    assert bilin_op.source == space and bilin_op_with_prod.source == space
+    assert bilin_op.range == scalar and bilin_op_with_prod.range == scalar
+    assert almost_equal(one_s, bilin_op.apply(one_v))
+    assert almost_equal(four_s, bilin_op.apply(two_v))
+    assert almost_equal(six_s, bilin_op_with_prod.apply(one_v))
+    assert almost_equal(twn_four_s, bilin_op_with_prod.apply(two_v))
+
+
 def test_pickle(operator):
     assert_picklable(operator)
 
 
 def test_pickle_without_dumps_function(picklable_operator):
     assert_picklable_without_dumps_function(picklable_operator)
 
@@ -420,34 +489,37 @@
     try:
         assert np.all(almost_equal(inv.apply_inverse_adjoint(U, mu=mu), op.apply(U, mu=mu),
                                    rtol=rtol, atol=atol))
     except (InversionError, LinAlgError, NotImplementedError):
         pass
 
 
+@pytest.mark.builtin
 def test_vectorarray_op_apply_inverse():
     O = np.random.random((5, 5))
     op = VectorArrayOperator(NumpyVectorSpace.make_array(O))
     V = op.range.random()
     U = op.apply_inverse(V)
     v = V.to_numpy()
     u = np.linalg.solve(O.T, v.ravel())
     assert np.all(almost_equal(U, U.space.from_numpy(u), rtol=1e-10))
 
 
+@pytest.mark.builtin
 def test_vectorarray_op_apply_inverse_lstsq():
     O = np.random.random((3, 5))
     op = VectorArrayOperator(NumpyVectorSpace.make_array(O))
     V = op.range.random()
     U = op.apply_inverse(V, least_squares=True)
     v = V.to_numpy()
     u = np.linalg.lstsq(O.T, v.ravel(), rcond=None)[0]
     assert np.all(almost_equal(U, U.space.from_numpy(u)))
 
 
+@pytest.mark.builtin
 def test_adjoint_vectorarray_op_apply_inverse_lstsq():
     O = np.random.random((3, 5))
     op = VectorArrayOperator(NumpyVectorSpace.make_array(O), adjoint=True)
     V = op.range.random()
     U = op.apply_inverse(V, least_squares=True)
     v = V.to_numpy()
     u = np.linalg.lstsq(O, v.ravel(), rcond=None)[0]
@@ -460,26 +532,28 @@
             or not isinstance(op.source, NumpyVectorSpace)
             or op.source.dim > as_array_max_length()):
         return
     array = op.as_range_array(mu)
     assert np.all(almost_equal(array.lincomb(U.to_numpy()), op.apply(U, mu=mu)))
 
 
+@pytest.mark.builtin
 def test_issue_1276():
     from pymor.operators.block import BlockOperator
     from pymor.operators.constructions import IdentityOperator
     from pymor.vectorarrays.numpy import NumpyVectorSpace
 
     I = IdentityOperator(NumpyVectorSpace(1))
     B = BlockOperator([[I * (-1)]])
     v = B.source.ones()
 
     B.apply_inverse(v)
 
 
+@pytest.mark.builtin
 @pytest.mark.parametrize('iscomplex', [False, True])
 def test_hankel_operator(iscomplex):
     s, p, m = 4, 2, 3
     if iscomplex:
         mp = np.random.rand(s, p, m) + 1j * np.random.rand(s, p, m)
     else:
         mp = np.random.rand(s, p, m)
@@ -494,14 +568,15 @@
     V += 1j * op.range.random(1)
     np.testing.assert_array_almost_equal(op.apply(U).to_numpy().T, to_matrix(op) @ U.to_numpy().T)
     np.testing.assert_array_almost_equal(op.apply_adjoint(V).to_numpy().T, to_matrix(op).conj().T @ V.to_numpy().T)
 
 
 if config.HAVE_DUNEGDT:
     from dune.xt.la import IstlSparseMatrix, SparsityPatternDefault
+
     from pymor.bindings.dunegdt import DuneXTMatrixOperator
 
     def make_dunegdt_identity(N):
         pattern = SparsityPatternDefault(N)
         for n in range(N):
             pattern.insert(n, n)
         pattern.sort()
```

### Comparing `pymor-2022.2.1/src/pymortests/parameters/min_max_theta_functionals.py` & `pymor-2023.1.0/src/pymortests/parameters/min_max_theta_functionals.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,18 +1,26 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 import numpy as np
 import pytest
-from pymor.parameters.functionals import (ConstantParameterFunctional, ExpressionParameterFunctional,
-                                          MinThetaParameterFunctional, BaseMaxThetaParameterFunctional,
-                                          MaxThetaParameterFunctional, ParameterFunctional)
+
+from pymor.parameters.functionals import (
+    BaseMaxThetaParameterFunctional,
+    ConstantParameterFunctional,
+    ExpressionParameterFunctional,
+    MaxThetaParameterFunctional,
+    MinThetaParameterFunctional,
+    ParameterFunctional,
+)
 from pymortests.base import runmodule
 
+pytestmark = pytest.mark.builtin
+
 
 def test_min_theta_parameter_functional():
     thetas = (ExpressionParameterFunctional('2*mu[0]', {'mu': 1}),
               ConstantParameterFunctional(1),
               1)
     mu_bar = 3
     alpha_mu_bar = 10
@@ -71,9 +79,9 @@
     mu_bar = theta.parameters.parse(mu_bar)
     expected_value = gamma_mu_bar * np.abs(np.max(np.array([t(mu) for t in thetas_prime])
                                                   / np.array([np.abs(t(mu_bar)) for t in thetas])))
     actual_value = theta.evaluate(mu)
     assert expected_value == actual_value
 
 
-if __name__ == "__main__":
+if __name__ == '__main__':
     runmodule(filename=__file__)
```

### Comparing `pymor-2022.2.1/src/pymortests/parameters/mu_derivatives.py` & `pymor-2023.1.0/src/pymortests/parameters/mu_derivatives.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,16 +1,19 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 import numpy as np
+import pytest
 
-from pymor.parameters.functionals import ProjectionParameterFunctional, ExpressionParameterFunctional
+from pymor.basic import Mu, NumpyVectorSpace
 from pymor.operators.constructions import LincombOperator, ZeroOperator
-from pymor.basic import NumpyVectorSpace, Mu
+from pymor.parameters.functionals import ExpressionParameterFunctional, ProjectionParameterFunctional
+
+pytestmark = pytest.mark.builtin
 
 
 def test_ProjectionParameterFunctional():
     pf = ProjectionParameterFunctional('mu', 2, 0)
     mu = Mu({'mu': (10, 2)})
 
     derivative_to_first_index = pf.d_mu('mu', 0)
@@ -272,52 +275,52 @@
     assert hes_mu_2_mu_2 == [0., 0., 0]
     assert hes_mu_2_nu == [0., 0., 0]
     assert hes_nu_mu_1 == [0., 0., 0]
     assert hes_nu_mu_2 == [0., 0., 0]
     assert hes_nu_nu == [0., 0., -0]
 
 
+def run_test_on_model(model, mu, parameter_name=None):
+    gradient_with_adjoint_approach = model.output_d_mu(mu, return_array=True, use_adjoint=True)
+    gradient_with_sensitivities = model.output_d_mu(mu, return_array=True, use_adjoint=False)
+    assert np.allclose(gradient_with_adjoint_approach, gradient_with_sensitivities)
+    if parameter_name is not None:
+        u_d_mu = model.solve_d_mu(parameter_name, 1, mu=mu).to_numpy()
+        u_d_mu_ = model.compute(solution_d_mu=True, mu=mu)['solution_d_mu'][parameter_name][1].to_numpy()
+        assert np.allclose(u_d_mu, u_d_mu_)
+
+
 def test_output_d_mu():
     from pymordemos.linear_optimization import create_fom
 
     grid_intervals = 10
     training_samples = 3
 
-    fom, mu_bar = create_fom(grid_intervals, vector_valued_output=True)
+    # creating multiple foms to test
+    fom, _ = create_fom(grid_intervals, vector_valued_output=True)
     easy_fom, _ = create_fom(grid_intervals, vector_valued_output=False)
+    complex_op_fom = easy_fom.with_(operator=easy_fom.operator.with_(
+        operators=[op * (1+2j) for op in easy_fom.operator.operators]))
+    complex_out_fom = easy_fom.with_(output_functional=easy_fom.output_functional.with_(
+        operators=[op * (1+2j) for op in easy_fom.output_functional.operators]))
+    quad_fom, _ = create_fom(grid_intervals, output_type='quadratic')
+
+    test_foms = [complex_op_fom, complex_out_fom, quad_fom]
 
     parameter_space = fom.parameters.space(0, np.pi)
     training_set = parameter_space.sample_uniformly(training_samples)
 
     # verifying that the adjoint and sensitivity gradients are the same and that solve_d_mu works
     for mu in training_set:
-        gradient_with_adjoint_approach = fom.output_d_mu(mu, return_array=True, use_adjoint=True)
-        gradient_with_sensitivities = fom.output_d_mu(mu, return_array=True, use_adjoint=False)
-        assert np.allclose(gradient_with_adjoint_approach, gradient_with_sensitivities)
-        u_d_mu = fom.solve_d_mu('diffusion', 1, mu=mu).to_numpy()
-        u_d_mu_ = fom.compute(solution_d_mu=True, mu=mu)['solution_d_mu']['diffusion'][1].to_numpy()
-        assert np.allclose(u_d_mu, u_d_mu_)
-
-        # test the complex case
-        complex_fom = easy_fom.with_(operator=easy_fom.operator.with_(
-            operators=[op * (1+2j) for op in easy_fom.operator.operators]))
-        complex_gradient_adjoint = complex_fom.output_d_mu(mu, return_array=True, use_adjoint=True)
-        complex_gradient = complex_fom.output_d_mu(mu, return_array=True, use_adjoint=False)
-        assert np.allclose(complex_gradient_adjoint, complex_gradient)
-
-        complex_fom = easy_fom.with_(output_functional=easy_fom.output_functional.with_(
-            operators=[op * (1+2j) for op in easy_fom.output_functional.operators]))
-        complex_gradient_adjoint = complex_fom.output_d_mu(mu, return_array=True, use_adjoint=True)
-        complex_gradient = complex_fom.output_d_mu(mu, return_array=True, use_adjoint=False)
-        assert np.allclose(complex_gradient_adjoint, complex_gradient)
+        run_test_on_model(fom, mu, 'diffusion')
+        for model in test_foms:
+            run_test_on_model(model, mu)
 
     # another fom to test the 3d case
     ops, coefs = fom.operator.operators, fom.operator.coefficients
     ops += (fom.operator.operators[1],)
     coefs += (ProjectionParameterFunctional('nu', 1, 0),)
     fom_ = fom.with_(operator=LincombOperator(ops, coefs))
     parameter_space = fom_.parameters.space(0, np.pi)
     training_set = parameter_space.sample_uniformly(training_samples)
     for mu in training_set:
-        gradient_with_adjoint_approach = fom_.output_d_mu(mu, return_array=True, use_adjoint=True)
-        gradient_with_sensitivities = fom_.output_d_mu(mu, return_array=True, use_adjoint=False)
-        assert np.allclose(gradient_with_adjoint_approach, gradient_with_sensitivities)
+        run_test_on_model(fom_, mu)
```

### Comparing `pymor-2022.2.1/src/pymortests/parameters/parameter_functionals.py` & `pymor-2023.1.0/src/pymortests/parameters/parameter_functionals.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,13 +1,17 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
-from pymor.parameters.functionals import ProjectionParameterFunctional, ExpressionParameterFunctional
+import pytest
+
 from pymor.basic import Mu
+from pymor.parameters.functionals import ExpressionParameterFunctional, ProjectionParameterFunctional
+
+pytestmark = pytest.mark.builtin
 
 
 def test_LincombParameterFunctional():
     dict_of_d_mus = {'mu': ['200 * mu[0]', '2 * mu[0]'], 'nu': ['cos(nu[0])']}
 
     epf = ExpressionParameterFunctional('100 * mu[0]**2 + 2 * mu[1] * mu[0] + sin(nu[0])',
                                         {'mu': 2, 'nu': 1},
```

### Comparing `pymor-2022.2.1/src/pymortests/parameters/parameters.py` & `pymor-2023.1.0/src/pymortests/parameters/parameters.py`

 * *Files 16% similar despite different names*

```diff
@@ -2,18 +2,20 @@
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 import numpy as np
 import pytest
 from hypothesis import given
 
+import pymortests.strategies as pyst
 from pymor.analyticalproblems.functions import ConstantFunction
-from pymor.parameters.base import Parameters, Mu
+from pymor.parameters.base import Mu, Parameters
 from pymortests.base import runmodule
-import pymortests.strategies as pyst
+
+pytestmark = pytest.mark.builtin
 
 
 num_samples = 100
 
 
 @pytest.fixture(scope='module', params=([1], [2], [1, 1]))
 def space(request):
@@ -33,14 +35,29 @@
 def test_randomly(space):
     values = space.sample_randomly(num_samples)
     assert len(values) == num_samples
     for value in values:
         assert space.contains(value)
 
 
+def test_logarithmic_uniformly(space):
+    values = space.sample_logarithmic_uniformly(num_samples)
+    total_num_parameters = sum([space.parameters[k] for k in space.parameters])
+    assert len(values) == num_samples**total_num_parameters
+    for value in values:
+        assert space.contains(value)
+
+
+def test_logarithmic_randomly(space):
+    values = space.sample_logarithmic_randomly(num_samples)
+    assert len(values) == num_samples
+    for value in values:
+        assert space.contains(value)
+
+
 def test_randomly_without_count(space):
     mu = space.sample_randomly()
     assert isinstance(mu, Mu)
 
 
 def test_clip(space):
     from copy import deepcopy
@@ -69,14 +86,21 @@
 def test_parse_parameter():
     parameters = Parameters(b=2, a=1)
     mu_as_list = [1, 2, 3]
     mu_as_parameter_and_back = list(parameters.parse(mu_as_list).to_numpy())
     assert mu_as_list == mu_as_parameter_and_back
 
 
+def test_parse_parameter_time_dep():
+    parameters = Parameters(b=2, a=1)
+    mu = parameters.parse([7, 't**2', 't[0]'])
+    assert list(mu.with_(t=3)['a']) == [7]
+    assert list(mu.with_(t=3)['b']) == [9, 3]
+
+
 @given(pyst.mus)
 def test_parse_mu(mu):
     parameters = mu.parameters
     assert parameters.parse(mu) == mu
 
 
 @given(pyst.mus)
@@ -121,17 +145,33 @@
 
 @given(pyst.mus)
 def test_mu_to_numpy(mu):
     mu_array = mu.to_numpy()
     mu2 = mu.parameters.parse(mu_array)
     assert mu == mu2
 
+@given(pyst.mus)
+def test_mu_algebra(mu):
+    mu_np = mu.to_numpy()
+    other_np = np.ones(len(mu_np))
+    other = mu.parameters.parse(other_np)
+
+    assert mu + other == other + mu
+    assert other_np + mu == other + mu_np
+    assert all((mu + other).to_numpy() == (mu_np + other_np))
+    assert all((mu - other).to_numpy() == (mu_np - other_np))
+    assert all((other + mu).to_numpy() == (other_np + mu_np))
+    assert all((other - mu).to_numpy() == (other_np - mu_np))
+    assert all((-mu).to_numpy() == -mu_np)
+    assert all((2. * mu).to_numpy() == 2. * mu_np)
+    assert 2. * mu == mu * 2.
+
 
 def test_mu_t_wrong_value():
     with pytest.raises(Exception):
         Mu(t=ConstantFunction(np.array([3])))
     with pytest.raises(Exception):
         Mu(t=np.array([1, 2]))
 
 
-if __name__ == "__main__":
+if __name__ == '__main__':
     runmodule(filename=__file__)
```

### Comparing `pymor-2022.2.1/src/pymortests/reductors/h2.py` & `pymor-2023.1.0/src/pymortests/reductors/h2.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,16 +1,19 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 import numpy as np
+import pytest
 
 from pymor.models.iosys import LTIModel
 from pymor.reductors.h2 import IRKAReductor
 
+pytestmark = pytest.mark.builtin
+
 
 def test_irka():
     A = np.array([[-1, 0], [0, -2]])
     B = np.array([[1], [2]])
     C = np.array([[2, 1]])
     fom = LTIModel.from_matrices(A, B, C)
     irka = IRKAReductor(fom)
```

### Comparing `pymor-2022.2.1/src/pymortests/strategies.py` & `pymor-2023.1.0/src/pymortests/strategies.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,63 +1,58 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 import functools
 
-from hypothesis import strategies as hyst
+import numpy as np
 from hypothesis import assume, given
+from hypothesis import strategies as hyst
 from hypothesis.extra import numpy as hynp
-import numpy as np
-import os
 from scipy.stats._multivariate import random_correlation_gen
 
-from pymor.analyticalproblems.functions import Function, ExpressionFunction, ConstantFunction
+from pymor.analyticalproblems.functions import ConstantFunction, ExpressionFunction, Function
 from pymor.core.config import config
-from pymor.parameters.base import Mu
-from pymor.tools.deprecated import Deprecated
-from pymor.vectorarrays.list import NumpyListVectorSpace
+from pymor.parameters.base import Mu, Parameters
 from pymor.vectorarrays.block import BlockVectorSpace
+from pymor.vectorarrays.list import NumpyListVectorSpace
 from pymor.vectorarrays.numpy import NumpyVectorSpace
+from pymortests.base import BUILTIN_DISABLED
 
 if config.HAVE_FENICS:
     import dolfin as df
+
     from pymor.bindings.fenics import FenicsVectorSpace
 
 if config.HAVE_DEALII:
     from pymor_dealii.pymor.vectorarray import DealIIVectorSpace
 
 if config.HAVE_DUNEGDT:
     from pymor.bindings.dunegdt import DuneXTVectorSpace
 
 if config.HAVE_NGSOLVE:
-    import ngsolve as ngs
     import netgen.meshing as ngmsh
+    import ngsolve as ngs
+
     from pymor.bindings.ngsolve import NGSolveVectorSpace
 
 
 # hypothesis will gladly fill all our RAM with vector arrays if it's not restricted.
 MAX_VECTORARRAY_LENGTH = 102
 hy_lengths = hyst.integers(min_value=0, max_value=MAX_VECTORARRAY_LENGTH)
 # this is a legacy restriction, some tests will not work as expected when this is changed/unset
 MAX_ARRAY_ELEMENT_ABSVALUE = 1
 MIN_ARRAY_ELEMENT_ABSVALUE = 1e-34
 
 
 hy_dtypes = hyst.sampled_from([np.float64, np.complex128])
 hy_float_array_elements = hyst.floats(allow_nan=False, allow_infinity=False, allow_subnormal=False,
                                       min_value=-MAX_ARRAY_ELEMENT_ABSVALUE, max_value=MAX_ARRAY_ELEMENT_ABSVALUE)
-
-
-@Deprecated("hypothesis.strategies.complex_numbers(allow_subnormal=False)")
-@hyst.composite
-def hy_complex_array_elements(draw):
-    # This is a crutch in place for https://github.com/HypothesisWorks/hypothesis/issues/3390
-    parts = hyst.floats(allow_nan=False, allow_infinity=False, allow_subnormal=False,
-                        min_value=-MAX_ARRAY_ELEMENT_ABSVALUE, max_value=MAX_ARRAY_ELEMENT_ABSVALUE)
-    return complex(draw(parts), draw(parts))
+hy_complex_array_elements = hyst.complex_numbers(allow_subnormal=False, min_magnitude=MIN_ARRAY_ELEMENT_ABSVALUE,
+                                                 max_magnitude=MAX_ARRAY_ELEMENT_ABSVALUE,
+                                                 allow_nan=False, allow_infinity=False)
 
 
 @hyst.composite
 def _hy_dims(draw, count, compatible):
     dims = hyst.integers(min_value=0, max_value=34)
     if compatible:
         return draw(equal_tuples(dims, count))
@@ -70,17 +65,17 @@
 def nothing(*args, **kwargs):
     return hyst.nothing()
 
 
 def _np_arrays(length, dim, dtype=None):
     if dtype is None:
         return hynp.arrays(dtype=np.float64, shape=(length, dim), elements=hy_float_array_elements) | \
-            hynp.arrays(dtype=np.complex128, shape=(length, dim), elements=hy_complex_array_elements())
+            hynp.arrays(dtype=np.complex128, shape=(length, dim), elements=hy_complex_array_elements)
     if dtype is np.complex128:
-        return hynp.arrays(dtype=dtype, shape=(length, dim), elements=hy_complex_array_elements())
+        return hynp.arrays(dtype=dtype, shape=(length, dim), elements=hy_complex_array_elements)
     if dtype is np.float64:
         return hynp.arrays(dtype=dtype, shape=(length, dim), elements=hy_float_array_elements)
     raise RuntimeError(f'unsupported dtype={dtype}')
 
 
 def _numpy_vector_spaces(draw, np_data_list, compatible, count, dims):
     return [(NumpyVectorSpace(d), ar) for d, ar in zip(dims, np_data_list)]
@@ -125,16 +120,14 @@
         for d, ar in zip(dims, np_data_list):
             assume(d > 1)
             if d not in _FENICS_spaces:
                 _FENICS_spaces[d] = FenicsVectorSpace(df.FunctionSpace(df.UnitIntervalMesh(d - 1), 'Lagrange', 1))
             ret.append((_FENICS_spaces[d], ar))
         return ret
     _other_vector_space_types.append('fenics')
-else:
-    assert not os.environ.get('DOCKER_PYMOR', False)
 
 if config.HAVE_NGSOLVE:
     _NGSOLVE_spaces = {}
 
     def _create_ngsolve_space(dim):
         if dim not in _NGSOLVE_spaces:
             mesh = ngmsh.Mesh(dim=1)
@@ -146,33 +139,27 @@
                     mesh.Add(ngmsh.Element1D([pids[i], pids[i + 1]], index=1))
             _NGSOLVE_spaces[dim] = NGSolveVectorSpace(ngs.L2(ngs.Mesh(mesh), order=0))
         return _NGSOLVE_spaces[dim]
 
     def _ngsolve_vector_spaces(draw, np_data_list, compatible, count, dims):
         return [(_create_ngsolve_space(d), ar) for d, ar in zip(dims, np_data_list)]
     _other_vector_space_types.append('ngsolve')
-else:
-    assert not os.environ.get('DOCKER_PYMOR', False)
 
 if config.HAVE_DEALII:
     def _dealii_vector_spaces(draw, np_data_list, compatible, count, dims):
         return [(DealIIVectorSpace(d), ar) for d, ar in zip(dims, np_data_list)]
     _other_vector_space_types.append('dealii')
-else:
-    assert not os.environ.get('DOCKER_PYMOR', False)
 
 if config.HAVE_DUNEGDT:
     def _dunegdt_vector_spaces(draw, np_data_list, compatible, count, dims):
         return [(DuneXTVectorSpace(d), ar) for d, ar in zip(dims, np_data_list)]
     _other_vector_space_types.append('dunegdt')
-else:
-    assert not os.environ.get('DOCKER_PYMOR', False)
 
 
-_picklable_vector_space_types = ['numpy', 'numpy_list', 'block']
+_picklable_vector_space_types = [] if BUILTIN_DISABLED else ['numpy', 'numpy_list', 'block']
 
 
 @hyst.composite
 def vector_arrays(draw, space_types, count=1, dtype=None, length=None, compatible=True):
     dims = draw(_hy_dims(count, compatible))
     dtype = dtype or draw(hy_dtypes)
     lngs = draw(length or hyst.tuples(*[hy_lengths for _ in range(count)]))
@@ -187,25 +174,25 @@
         # element
         return ret[0]
     assert count > 1
     return ret
 
 
 def given_vector_arrays(which='all', count=1, dtype=None, length=None, compatible=True, index_strategy=None, **kwargs):
-    """This decorator hides the combination details of given
+    """This decorator hides the combination details of given.
 
     the decorated function will be first wrapped in a |hypothesis.given| (with expanded `given_args`
     and then in |pytest.mark.parametrize| with selected implementation names. The decorated test
     function must still draw (which a vector_arrays or similar strategy) from the `data` argument in
     the default case.
 
     Parameters
     ----------
     which
-        A list of implementation shortnames, or either of the special values "all" and "picklable".
+        A list of implementation shortnames, or either of the special values 'all' and 'picklable'.
 
     kwargs
         passed to `given` decorator as is, use for additional strategies
 
     count
         how many vector arrays to return (in a list), count=1 is special cased to just return the
         array
@@ -220,14 +207,17 @@
     @functools.wraps(given)
     def inner_backend_decorator(func):
         try:
             use_imps = {'all': _picklable_vector_space_types  + _other_vector_space_types,
                         'picklable': _picklable_vector_space_types}[which]
         except KeyError:
             use_imps = which
+        if not use_imps:
+            import pytest
+            return pytest.mark.skip('no backend')(func)
         first_args = {}
         if index_strategy:
             arr_ind_strategy = index_strategy(vector_arrays(
                 count=count, dtype=dtype, length=length, compatible=compatible, space_types=use_imps))
             first_args['vectors_and_indices'] = arr_ind_strategy
         else:
             arr_strategy = vector_arrays(count=count, dtype=dtype, length=length, compatible=compatible,
@@ -325,22 +315,22 @@
     len1, len2 = len(v1), len(v2)
     ret = hyst.just(([], []))
     # TODO we should include integer arrays here by chaining
     # `| hynp.integer_array_indices(shape=(LEN_X,))`
     if len1 == len2:
         ints = hyst.integers(min_value=-len1, max_value=max(len1 - 1, 0))
         slicer = hyst.slices(len1) | hyst.lists(ints, max_size=len1)
-        ret = ret | hyst.tuples(hyst.shared(slicer, key="st_valid_inds_of_same_length"),
-                                hyst.shared(slicer, key="st_valid_inds_of_same_length"))
+        ret = ret | hyst.tuples(hyst.shared(slicer, key='st_valid_inds_of_same_length'),
+                                hyst.shared(slicer, key='st_valid_inds_of_same_length'))
     if len1 > 0 and len2 > 0:
         mlen = min(len1, len2)
         ints = hyst.integers(min_value=-mlen, max_value=max(mlen - 1, 0))
         slicer = hyst.slices(mlen) | ints | hyst.lists(ints, max_size=mlen)
-        ret = ret | hyst.tuples(hyst.shared(slicer, key="st_valid_inds_of_same_length_uneven"),
-                                hyst.shared(slicer, key="st_valid_inds_of_same_length_uneven"))
+        ret = ret | hyst.tuples(hyst.shared(slicer, key='st_valid_inds_of_same_length_uneven'),
+                                hyst.shared(slicer, key='st_valid_inds_of_same_length_uneven'))
     return draw(ret)
 
 
 @hyst.composite
 def st_scaling_value(draw, v1, v2=None):
     v1 = draw(v1)
     ints = hyst.integers(min_value=-1, max_value=23)
@@ -442,15 +432,15 @@
     invalid_inds = (None, len(v), [len(v)], -len(v) - 1, [-len(v) - 1], [0, len(v)],
                     [-len(v) - 1] + [0, ] * (length - 1), list(range(length - 1)) + [len(v)])
     return v, draw(hyst.sampled_from(invalid_inds))
 
 
 @hyst.composite
 def base_vector_arrays(draw, count=1, dtype=None, max_dim=100):
-    """Strategy to generate linear independent |VectorArray| inputs for test functions
+    """Strategy to generate linear independent |VectorArray| inputs for test functions.
 
     Parameters
     ----------
     draw hypothesis control function object
     count how many bases do you want
     dtype dtype for the generated bases, defaults to `np.float_`
     max_dim size limit for the generated
@@ -469,15 +459,15 @@
     # this lets hypothesis control np's random state too
     random = draw(hyst.random_module())
     # scipy performs this check although technically numpy accepts a different range
     assume(0 <= random.seed < 2**32 - 1)
     random_correlation = random_correlation_gen(random.seed)
 
     def _eigs():
-        """Sum must equal to `length` for the scipy construct method"""
+        """Sum must equal to `length` for the scipy construct method."""
         min_eig, max_eig = 0.001, 1.
         eigs = np.asarray((max_eig-min_eig)*np.random.random(length-1) + min_eig, dtype=float)
         return np.append(eigs, [length - np.sum(eigs)])
 
     if length > 1:
         mat = [random_correlation.rvs(_eigs(), tol=1e-12) for _ in range(count)]
         return [space.from_numpy(m) for m in mat]
@@ -488,14 +478,44 @@
 
 @hyst.composite
 def equal_tuples(draw, strategy, count):
     val = draw(strategy)
     return draw(hyst.tuples(*[hyst.just(val) for _ in range(count)]))
 
 
+@hyst.composite
+def active_mu_data(draw, min_num=1, max_num=3, min_dim=1, max_dim=5, num_mus=10):
+    from random import randint, sample
+
+    sizes = draw(hyst.lists(hyst.integers(min_value=min_dim, max_value=max_dim), min_size=min_num, max_size=max_num))
+    param_dict = {'foo_' + str(ind): size for ind, size in enumerate(sizes)}
+    space = Parameters(param_dict).space((0.1, 1))
+    dim = space.parameters.dim
+    mus = []
+    active_indices = []
+
+    for _ in range(num_mus):
+        num_indices = randint(0, dim)
+        num_low = randint(0, num_indices)
+        active_inds = sample(range(dim), num_indices)
+        low_active_indices = sample(active_inds, num_low)
+        high_active_indices = list(set(active_inds) - set(low_active_indices))
+
+        mu_range = list(space.ranges.values())[0]
+        val = .5 * (mu_range[0] + mu_range[1])
+        mu = val * np.ones(dim)
+        mu[low_active_indices] = mu_range[0]
+        mu[high_active_indices] = mu_range[1]
+
+        mus.append(mu)
+        active_indices.append(active_inds)
+
+    return space, mus, active_indices
+
+
 # stick to a few representative examples to avoid only seeing degenerate cases
 # in the selected examples
 mus = hyst.dictionaries(
     keys=hyst.sampled_from(['t', 'foo', 'bar']),
     values=hyst.sampled_from([
         np.array([1.]),
         np.array([1., 32., 3]),
```

### Comparing `pymor-2022.2.1/src/pymortests/testdata/check_results/test_parabolic_mor_results/ca3b1109e5bd10d21b0b9bc432d6ac101cf1fa4d` & `pymor-2023.1.0/src/pymortests/testdata/check_results/test_parabolic_mor_results/ca3b1109e5bd10d21b0b9bc432d6ac101cf1fa4d`

 * *Files identical despite different names*

### Comparing `pymor-2022.2.1/src/pymortests/testdata/check_results/test_thermalblock_results/105686ef68a9b4b3655c790d395526c623efd162` & `pymor-2023.1.0/src/pymortests/testdata/check_results/test_thermalblock_results/105686ef68a9b4b3655c790d395526c623efd162`

 * *Files identical despite different names*

### Comparing `pymor-2022.2.1/src/pymortests/testdata/check_results/test_thermalblock_results/29e5f263a02a275f4d29b7e5bdf32ad20c1e6346` & `pymor-2023.1.0/src/pymortests/testdata/check_results/test_thermalblock_results/29e5f263a02a275f4d29b7e5bdf32ad20c1e6346`

 * *Files identical despite different names*

### Comparing `pymor-2022.2.1/src/pymortests/testdata/check_results/test_thermalblock_results/2f2da29c16865fb149a8025deb79bf849d6631db` & `pymor-2023.1.0/src/pymortests/testdata/check_results/test_thermalblock_results/2f2da29c16865fb149a8025deb79bf849d6631db`

 * *Files identical despite different names*

### Comparing `pymor-2022.2.1/src/pymortests/testdata/check_results/test_thermalblock_results/38a8bfe939551df7383a6058a2862fb9d2eea5a4` & `pymor-2023.1.0/src/pymortests/testdata/check_results/test_thermalblock_results/38a8bfe939551df7383a6058a2862fb9d2eea5a4`

 * *Files identical despite different names*

### Comparing `pymor-2022.2.1/src/pymortests/testdata/check_results/test_thermalblock_results/60f38cd8ac4c21f2c30fafbec18e36e74a42a0be` & `pymor-2023.1.0/src/pymortests/testdata/check_results/test_thermalblock_results/60f38cd8ac4c21f2c30fafbec18e36e74a42a0be`

 * *Files identical despite different names*

### Comparing `pymor-2022.2.1/src/pymortests/testdata/check_results/test_thermalblock_results/a92ec4631a6f0edc2eae1cc3b0fa17af6c467cef` & `pymor-2023.1.0/src/pymortests/testdata/check_results/test_thermalblock_results/a92ec4631a6f0edc2eae1cc3b0fa17af6c467cef`

 * *Files identical despite different names*

### Comparing `pymor-2022.2.1/src/pymortests/testdata/check_results/test_thermalblock_results/c8a460e412d9170f12508ab3608fd7e1e1750603` & `pymor-2023.1.0/src/pymortests/testdata/check_results/test_thermalblock_results/c8a460e412d9170f12508ab3608fd7e1e1750603`

 * *Files identical despite different names*

### Comparing `pymor-2022.2.1/src/pymortests/testdata/check_results/test_thermalblock_results/ce0770de067386276c9e89afa2d63daeb512a9f5` & `pymor-2023.1.0/src/pymortests/testdata/check_results/test_thermalblock_results/ce0770de067386276c9e89afa2d63daeb512a9f5`

 * *Files identical despite different names*

### Comparing `pymor-2022.2.1/src/pymortests/testdata/check_results/test_thermalblock_results/ea8f66e263715fd0185d0dd23ab6d57feb6ee898` & `pymor-2023.1.0/src/pymortests/testdata/check_results/test_thermalblock_results/ea8f66e263715fd0185d0dd23ab6d57feb6ee898`

 * *Files identical despite different names*

### Comparing `pymor-2022.2.1/src/pymortests/tools.py` & `pymor-2023.1.0/src/pymortests/tools.py`

 * *Files 2% similar despite different names*

```diff
@@ -15,21 +15,24 @@
 from pymor.core.config import config
 from pymor.core.logger import getLogger
 from pymor.discretizers.builtin.quadratures import GaussQuadratures
 from pymor.tools import formatsrc, timing
 from pymor.tools.deprecated import Deprecated
 from pymor.tools.floatcmp import almost_less, float_cmp, float_cmp_all
 from pymor.tools.formatsrc import print_source
-from pymor.tools.io import safe_temporary_filename, change_to_directory
+from pymor.tools.io import change_to_directory, safe_temporary_filename
 from pymor.tools.plot import adaptive
 from pymor.tools.random import get_rng
 from pymor.vectorarrays.numpy import NumpyVectorSpace
 from pymortests.base import runmodule
 from pymortests.fixtures.grid import hy_rect_or_tria_grid
 
+pytestmark = pytest.mark.builtin
+
+
 logger = getLogger('pymortests.tools')
 
 
 FUNCTIONS = (('sin(2x pi)', lambda x: sin(2 * x * pi), 0),
              ('e^x', lambda x: exp(x), exp(1) - exp(0)))
 
 
@@ -182,21 +185,21 @@
 def testDeprecated():
     @Deprecated('use other stuff instead')
     def deprecated_function():
         pass
     # Cause all warnings to always be triggered.
     import warnings
     with warnings.catch_warnings(record=True) as w:
-        warnings.simplefilter("always")
+        warnings.simplefilter('always')
         # Trigger a warning.
         deprecated_function()
         # Verify some things
         assert len(w) == 1
         assert issubclass(w[-1].category, DeprecationWarning)
-        assert "DeprecationWarning" in str(w[-1].message)
+        assert 'DeprecationWarning' in str(w[-1].message)
 
 
 def test_formatsrc():
     obj = formatsrc.format_source
     formatsrc.format_source(obj)
     print_source(obj)
 
@@ -218,14 +221,15 @@
         else:
             load_matrix(m)
 
 
 @pytest.mark.parametrize('ext', ['.mat', '.mtx', '.mtz.gz', '.npy', '.npz', '.txt'])
 def test_save_load_matrix(ext):
     import filecmp
+
     from pymor.tools.io import load_matrix, save_matrix
     A = np.eye(2)
     with tempfile.TemporaryDirectory() as tmpdirname:
         path = os.path.join(tmpdirname, 'matrix' + ext)
         key = None
         if ext == '.mat':
             key = 'A'
@@ -316,9 +320,9 @@
     assert 10 <= len(points) <= 2000
 
     assert isinstance(fvals, np.ndarray)
     assert fvals.ndim == 1
     assert fvals.shape[0] == len(points)
 
 
-if __name__ == "__main__":
+if __name__ == '__main__':
     runmodule(filename=__file__)
```

### Comparing `pymor-2022.2.1/src/pymortests/vectorarray.py` & `pymor-2023.1.0/src/pymortests/vectorarray.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,26 +1,25 @@
 # This file is part of the pyMOR project (https://www.pymor.org).
 # Copyright pyMOR developers and contributors. All rights reserved.
 # License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)
 
 from numbers import Number
 
-import pytest
 import numpy as np
-from hypothesis import assume, settings, example
+import pytest
+from hypothesis import assume, example, settings
 from hypothesis import strategies as hyst
 
+import pymortests.strategies as pyst
 from pymor.algorithms.basic import almost_equal
 from pymor.core.config import config
+from pymor.tools.floatcmp import bounded, float_cmp
 from pymor.vectorarrays.interface import VectorSpace
 from pymor.vectorarrays.numpy import NumpyVectorSpace
-from pymor.tools.floatcmp import float_cmp, bounded
-from pymortests.base import might_exceed_deadline
 from pymortests.core.pickling import assert_picklable_without_dumps_function
-import pymortests.strategies as pyst
 
 MAX_RNG_REALIZATIONS = 30
 
 
 def ind_complement(v, ind):
     if isinstance(ind, Number):
         ind = [ind]
@@ -135,15 +134,16 @@
                           high=hyst.floats(allow_infinity=False, allow_nan=False))
 @example(vector_array=NumpyVectorSpace(1).empty(), realizations=2,
          low=-5e-324, high=0.0)
 def test_random_uniform_all(vector_array, realizations, low, high):
     if config.HAVE_DUNEGDT:
         # atm needs special casing due to norm implementation handling of large vector elements
         from pymor.bindings.dunegdt import DuneXTVectorSpace
-        assume(not isinstance(vector_array.space, DuneXTVectorSpace))
+        if isinstance(vector_array.space, DuneXTVectorSpace):
+            return
     _test_random_uniform(vector_array, realizations, low, high)
 
 
 if config.HAVE_DUNEGDT:
     @pyst.given_vector_arrays(realizations=hyst.integers(min_value=0, max_value=MAX_RNG_REALIZATIONS),
                               low=hyst.floats(allow_infinity=False, allow_nan=False,
                                               max_value=10e100, min_value=-10e100),
@@ -938,15 +938,14 @@
     with pytest.raises(Exception):
         c1.append(c2, remove_from_other=False)
     c1, c2 = v1.copy(), v2.copy()
     with pytest.raises(Exception):
         c1.append(c2, remove_from_other=True)
 
 
-@might_exceed_deadline(2000)
 @pyst.given_vector_arrays(count=2, compatible=False)
 def test_axpy_incompatible(vector_arrays):
     v1, v2 = vector_arrays
     for ind1, ind2 in pyst.valid_inds_of_same_length(v1, v2):
         c1, c2 = v1.copy(), v2.copy()
         with pytest.raises(Exception):
             c1[ind1].axpy(0., c2[ind2])
@@ -1036,7 +1035,12 @@
         with pytest.raises(Exception):
             v1[ind1].axpy(alpha, v2[ind2])
 
 
 @pyst.given_vector_arrays(which='picklable')
 def test_pickle(vector_array):
     assert_picklable_without_dumps_function(vector_array)
+
+
+def test_numpyvectorspace_dim_must_be_int():
+    with pytest.raises(AssertionError):
+        _ = NumpyVectorSpace(5.)
```

