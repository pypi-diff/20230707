# Comparing `tmp/pixano-0.2.1.tar.gz` & `tmp/pixano-0.3.0.tar.gz`

## Comparing `pixano-0.2.1.tar` & `pixano-0.3.0.tar`

### file list

```diff
@@ -1,42 +1,67 @@
--rw-r--r--   0        0        0      575 2020-02-02 00:00:00.000000 pixano-0.2.1/pixano/__init__.py
--rw-r--r--   0        0        0      599 2020-02-02 00:00:00.000000 pixano-0.2.1/pixano/__version__.py
--rw-r--r--   0        0        0      575 2020-02-02 00:00:00.000000 pixano-0.2.1/pixano/analytics/__init__.py
--rw-r--r--   0        0        0     3102 2020-02-02 00:00:00.000000 pixano-0.2.1/pixano/analytics/feature_statistics.py
--rw-r--r--   0        0        0     1238 2020-02-02 00:00:00.000000 pixano-0.2.1/pixano/apps/explorer/README.md
--rw-r--r--   0        0        0      575 2020-02-02 00:00:00.000000 pixano-0.2.1/pixano/apps/explorer/__init__.py
--rw-r--r--   0        0        0     6736 2020-02-02 00:00:00.000000 pixano-0.2.1/pixano/apps/explorer/db_utils.py
--rw-r--r--   0        0        0     5672 2020-02-02 00:00:00.000000 pixano-0.2.1/pixano/apps/explorer/main.py
--rw-r--r--   0        0        0     3042 2020-02-02 00:00:00.000000 pixano-0.2.1/pixano/apps/explorer/serve.py
--rw-r--r--   0        0        0      567 2020-02-02 00:00:00.000000 pixano-0.2.1/pixano/apps/explorer/dist/index.html
--rw-r--r--   0        0        0  1043651 2020-02-02 00:00:00.000000 pixano-0.2.1/pixano/apps/explorer/dist/assets/index-6d50d613.js
--rw-r--r--   0        0        0    14024 2020-02-02 00:00:00.000000 pixano-0.2.1/pixano/apps/explorer/dist/assets/index-f2b8d192.css
--rw-r--r--   0        0        0    13031 2020-02-02 00:00:00.000000 pixano-0.2.1/pixano/apps/explorer/dist/assets/pixano-354ac9df.png
--rw-r--r--   0        0        0      575 2020-02-02 00:00:00.000000 pixano-0.2.1/pixano/core/__init__.py
--rw-r--r--   0        0        0     3555 2020-02-02 00:00:00.000000 pixano-0.2.1/pixano/core/dataset.py
--rw-r--r--   0        0        0     1262 2020-02-02 00:00:00.000000 pixano-0.2.1/pixano/core/dataset_test.py
--rw-r--r--   0        0        0     3429 2020-02-02 00:00:00.000000 pixano-0.2.1/pixano/core/arrow_types/__init__.py
--rw-r--r--   0        0        0     4218 2020-02-02 00:00:00.000000 pixano-0.2.1/pixano/core/arrow_types/features.py
--rw-r--r--   0        0        0     4477 2020-02-02 00:00:00.000000 pixano-0.2.1/pixano/core/arrow_types/image.py
--rw-r--r--   0        0        0     1861 2020-02-02 00:00:00.000000 pixano-0.2.1/pixano/core/arrow_types/image_test.py
--rw-r--r--   0        0        0      760 2020-02-02 00:00:00.000000 pixano-0.2.1/pixano/data/__init__.py
--rw-r--r--   0        0        0     4049 2020-02-02 00:00:00.000000 pixano-0.2.1/pixano/data/coco_loader.py
--rw-r--r--   0        0        0      934 2020-02-02 00:00:00.000000 pixano-0.2.1/pixano/data/data_loader.py
--rw-r--r--   0        0        0     4208 2020-02-02 00:00:00.000000 pixano-0.2.1/pixano/data/models.py
--rw-r--r--   0        0        0    10221 2020-02-02 00:00:00.000000 pixano-0.2.1/pixano/data/pixano_loader.py
--rw-r--r--   0        0        0      775 2020-02-02 00:00:00.000000 pixano-0.2.1/pixano/inference/__init__.py
--rw-r--r--   0        0        0     3688 2020-02-02 00:00:00.000000 pixano-0.2.1/pixano/inference/inference_model.py
--rw-r--r--   0        0        0     5751 2020-02-02 00:00:00.000000 pixano-0.2.1/pixano/inference/offline_model.py
--rw-r--r--   0        0        0     7942 2020-02-02 00:00:00.000000 pixano-0.2.1/pixano/inference/online_model.py
--rw-r--r--   0        0        0      636 2020-02-02 00:00:00.000000 pixano-0.2.1/pixano/notebook/__init__.py
--rw-r--r--   0        0        0     4443 2020-02-02 00:00:00.000000 pixano-0.2.1/pixano/notebook/display.py
--rw-r--r--   0        0        0      644 2020-02-02 00:00:00.000000 pixano-0.2.1/pixano/tools/converter/__init__.py
--rw-r--r--   0        0        0    10184 2020-02-02 00:00:00.000000 pixano-0.2.1/pixano/tools/converter/convert2parquet.py
--rw-r--r--   0        0        0     1308 2020-02-02 00:00:00.000000 pixano-0.2.1/pixano/transforms/__init__.py
--rw-r--r--   0        0        0     3077 2020-02-02 00:00:00.000000 pixano-0.2.1/pixano/transforms/boxes.py
--rw-r--r--   0        0        0     5675 2020-02-02 00:00:00.000000 pixano-0.2.1/pixano/transforms/image.py
--rw-r--r--   0        0        0     5594 2020-02-02 00:00:00.000000 pixano-0.2.1/pixano/transforms/labels.py
--rw-r--r--   0        0        0      401 2020-02-02 00:00:00.000000 pixano-0.2.1/.gitignore
--rw-r--r--   0        0        0    21864 2020-02-02 00:00:00.000000 pixano-0.2.1/LICENSE
--rw-r--r--   0        0        0     1751 2020-02-02 00:00:00.000000 pixano-0.2.1/README.md
--rw-r--r--   0        0        0     1599 2020-02-02 00:00:00.000000 pixano-0.2.1/pyproject.toml
--rw-r--r--   0        0        0    29190 2020-02-02 00:00:00.000000 pixano-0.2.1/PKG-INFO
+-rw-r--r--   0        0        0      575 2020-02-02 00:00:00.000000 pixano-0.3.0/pixano/__init__.py
+-rw-r--r--   0        0        0      599 2020-02-02 00:00:00.000000 pixano-0.3.0/pixano/__version__.py
+-rw-r--r--   0        0        0      715 2020-02-02 00:00:00.000000 pixano-0.3.0/pixano/analytics/__init__.py
+-rw-r--r--   0        0        0     3935 2020-02-02 00:00:00.000000 pixano-0.3.0/pixano/analytics/feature_statistics.py
+-rw-r--r--   0        0        0      764 2020-02-02 00:00:00.000000 pixano-0.3.0/pixano/apps/__init__.py
+-rw-r--r--   0        0        0     1094 2020-02-02 00:00:00.000000 pixano-0.3.0/pixano/apps/annotator/README.md
+-rw-r--r--   0        0        0      576 2020-02-02 00:00:00.000000 pixano-0.3.0/pixano/apps/annotator/__init__.py
+-rw-r--r--   0        0        0     3426 2020-02-02 00:00:00.000000 pixano-0.3.0/pixano/apps/annotator/serve.py
+-rw-r--r--   0        0        0      492 2020-02-02 00:00:00.000000 pixano-0.3.0/pixano/apps/annotator/dist/index.html
+-rw-r--r--   0        0        0      497 2020-02-02 00:00:00.000000 pixano-0.3.0/pixano/apps/annotator/dist/assets/box-86375780.svg
+-rw-r--r--   0        0        0      203 2020-02-02 00:00:00.000000 pixano-0.3.0/pixano/apps/annotator/dist/assets/close-adf8672f.svg
+-rw-r--r--   0        0        0      302 2020-02-02 00:00:00.000000 pixano-0.3.0/pixano/apps/annotator/dist/assets/delete-01fa86d0.svg
+-rw-r--r--   0        0        0      159 2020-02-02 00:00:00.000000 pixano-0.3.0/pixano/apps/annotator/dist/assets/expand-8c4ba5cb.svg
+-rw-r--r--   0        0        0   871872 2020-02-02 00:00:00.000000 pixano-0.3.0/pixano/apps/annotator/dist/assets/index-85719dfb.js
+-rw-r--r--   0        0        0    19283 2020-02-02 00:00:00.000000 pixano-0.3.0/pixano/apps/annotator/dist/assets/index-a26c83a0.css
+-rw-r--r--   0        0        0      652 2020-02-02 00:00:00.000000 pixano-0.3.0/pixano/apps/annotator/dist/assets/invisible-343b84fa.svg
+-rw-r--r--   0        0        0      130 2020-02-02 00:00:00.000000 pixano-0.3.0/pixano/apps/annotator/dist/assets/minus-327ad03c.svg
+-rw-r--r--   0        0        0      159 2020-02-02 00:00:00.000000 pixano-0.3.0/pixano/apps/annotator/dist/assets/next-66a71219.svg
+-rw-r--r--   0        0        0      173 2020-02-02 00:00:00.000000 pixano-0.3.0/pixano/apps/annotator/dist/assets/ok-d2337529.svg
+-rw-r--r--   0        0        0      308 2020-02-02 00:00:00.000000 pixano-0.3.0/pixano/apps/annotator/dist/assets/pan-8dc436ff.svg
+-rw-r--r--   0        0        0    22811 2020-02-02 00:00:00.000000 pixano-0.3.0/pixano/apps/annotator/dist/assets/pixano-6dabc25a.png
+-rw-r--r--   0        0        0      163 2020-02-02 00:00:00.000000 pixano-0.3.0/pixano/apps/annotator/dist/assets/plus-a5295245.svg
+-rw-r--r--   0        0        0      585 2020-02-02 00:00:00.000000 pixano-0.3.0/pixano/apps/annotator/dist/assets/point-23ee9036.svg
+-rw-r--r--   0        0        0      464 2020-02-02 00:00:00.000000 pixano-0.3.0/pixano/apps/annotator/dist/assets/save-ec75b2a2.svg
+-rw-r--r--   0        0        0      767 2020-02-02 00:00:00.000000 pixano-0.3.0/pixano/apps/annotator/dist/assets/visible-304bce00.svg
+-rw-r--r--   0        0        0      625 2020-02-02 00:00:00.000000 pixano-0.3.0/pixano/apps/core/__init__.py
+-rw-r--r--   0        0        0     9726 2020-02-02 00:00:00.000000 pixano-0.3.0/pixano/apps/core/db_utils.py
+-rw-r--r--   0        0        0     7025 2020-02-02 00:00:00.000000 pixano-0.3.0/pixano/apps/core/main.py
+-rw-r--r--   0        0        0     6470 2020-02-02 00:00:00.000000 pixano-0.3.0/pixano/apps/core/serve.py
+-rw-r--r--   0        0        0     1082 2020-02-02 00:00:00.000000 pixano-0.3.0/pixano/apps/explorer/README.md
+-rw-r--r--   0        0        0      576 2020-02-02 00:00:00.000000 pixano-0.3.0/pixano/apps/explorer/__init__.py
+-rw-r--r--   0        0        0     3419 2020-02-02 00:00:00.000000 pixano-0.3.0/pixano/apps/explorer/serve.py
+-rw-r--r--   0        0        0      491 2020-02-02 00:00:00.000000 pixano-0.3.0/pixano/apps/explorer/dist/index.html
+-rw-r--r--   0        0        0      497 2020-02-02 00:00:00.000000 pixano-0.3.0/pixano/apps/explorer/dist/assets/box-86375780.svg
+-rw-r--r--   0        0        0      203 2020-02-02 00:00:00.000000 pixano-0.3.0/pixano/apps/explorer/dist/assets/close-adf8672f.svg
+-rw-r--r--   0        0        0    14428 2020-02-02 00:00:00.000000 pixano-0.3.0/pixano/apps/explorer/dist/assets/index-c03d4dec.css
+-rw-r--r--   0        0        0  1076371 2020-02-02 00:00:00.000000 pixano-0.3.0/pixano/apps/explorer/dist/assets/index-f136c254.js
+-rw-r--r--   0        0        0      130 2020-02-02 00:00:00.000000 pixano-0.3.0/pixano/apps/explorer/dist/assets/minus-327ad03c.svg
+-rw-r--r--   0        0        0      159 2020-02-02 00:00:00.000000 pixano-0.3.0/pixano/apps/explorer/dist/assets/next-66a71219.svg
+-rw-r--r--   0        0        0      308 2020-02-02 00:00:00.000000 pixano-0.3.0/pixano/apps/explorer/dist/assets/pan-8dc436ff.svg
+-rw-r--r--   0        0        0    22811 2020-02-02 00:00:00.000000 pixano-0.3.0/pixano/apps/explorer/dist/assets/pixano-6dabc25a.png
+-rw-r--r--   0        0        0      163 2020-02-02 00:00:00.000000 pixano-0.3.0/pixano/apps/explorer/dist/assets/plus-a5295245.svg
+-rw-r--r--   0        0        0      585 2020-02-02 00:00:00.000000 pixano-0.3.0/pixano/apps/explorer/dist/assets/point-23ee9036.svg
+-rw-r--r--   0        0        0      752 2020-02-02 00:00:00.000000 pixano-0.3.0/pixano/core/__init__.py
+-rw-r--r--   0        0        0     3050 2020-02-02 00:00:00.000000 pixano-0.3.0/pixano/core/dataset.py
+-rw-r--r--   0        0        0     1254 2020-02-02 00:00:00.000000 pixano-0.3.0/pixano/core/dataset_test.py
+-rw-r--r--   0        0        0     3591 2020-02-02 00:00:00.000000 pixano-0.3.0/pixano/core/arrow_types/__init__.py
+-rw-r--r--   0        0        0     4975 2020-02-02 00:00:00.000000 pixano-0.3.0/pixano/core/arrow_types/features.py
+-rw-r--r--   0        0        0     6940 2020-02-02 00:00:00.000000 pixano-0.3.0/pixano/core/arrow_types/image.py
+-rw-r--r--   0        0        0     1861 2020-02-02 00:00:00.000000 pixano-0.3.0/pixano/core/arrow_types/image_test.py
+-rw-r--r--   0        0        0      871 2020-02-02 00:00:00.000000 pixano-0.3.0/pixano/data/__init__.py
+-rw-r--r--   0        0        0    12642 2020-02-02 00:00:00.000000 pixano-0.3.0/pixano/data/coco_loader.py
+-rw-r--r--   0        0        0    15752 2020-02-02 00:00:00.000000 pixano-0.3.0/pixano/data/data_loader.py
+-rw-r--r--   0        0        0     4665 2020-02-02 00:00:00.000000 pixano-0.3.0/pixano/data/dota_loader.py
+-rw-r--r--   0        0        0     3301 2020-02-02 00:00:00.000000 pixano-0.3.0/pixano/data/image_loader.py
+-rw-r--r--   0        0        0     9020 2020-02-02 00:00:00.000000 pixano-0.3.0/pixano/data/legacy_loader.py
+-rw-r--r--   0        0        0      658 2020-02-02 00:00:00.000000 pixano-0.3.0/pixano/models/__init__.py
+-rw-r--r--   0        0        0    10684 2020-02-02 00:00:00.000000 pixano-0.3.0/pixano/models/inference_model.py
+-rw-r--r--   0        0        0     1914 2020-02-02 00:00:00.000000 pixano-0.3.0/pixano/transforms/__init__.py
+-rw-r--r--   0        0        0     4112 2020-02-02 00:00:00.000000 pixano-0.3.0/pixano/transforms/boxes.py
+-rw-r--r--   0        0        0     7712 2020-02-02 00:00:00.000000 pixano-0.3.0/pixano/transforms/image.py
+-rw-r--r--   0        0        0     7806 2020-02-02 00:00:00.000000 pixano-0.3.0/pixano/transforms/labels.py
+-rw-r--r--   0        0        0      409 2020-02-02 00:00:00.000000 pixano-0.3.0/.gitignore
+-rw-r--r--   0        0        0    21864 2020-02-02 00:00:00.000000 pixano-0.3.0/LICENSE
+-rw-r--r--   0        0        0     2410 2020-02-02 00:00:00.000000 pixano-0.3.0/README.md
+-rw-r--r--   0        0        0     1680 2020-02-02 00:00:00.000000 pixano-0.3.0/pyproject.toml
+-rw-r--r--   0        0        0     3885 2020-02-02 00:00:00.000000 pixano-0.3.0/PKG-INFO
```

### Comparing `pixano-0.2.1/pixano/__init__.py` & `pixano-0.3.0/pixano/__init__.py`

 * *Files identical despite different names*

### Comparing `pixano-0.2.1/pixano/__version__.py` & `pixano-0.3.0/pixano/models/__init__.py`

 * *Files 19% similar despite different names*

```diff
@@ -7,8 +7,12 @@
 # This software is governed by the CeCILL-C license under French law and
 # abiding by the rules of distribution of free software. You can use,
 # modify and/ or redistribute the software under the terms of the CeCILL-C
 # license as circulated by CEA, CNRS and INRIA at the following URL
 #
 # http://www.cecill.info
 
-__version__ = "0.2.1"
+from .inference_model import InferenceModel
+
+__all__ = [
+    "InferenceModel",
+]
```

### Comparing `pixano-0.2.1/pixano/analytics/__init__.py` & `pixano-0.3.0/pixano/apps/annotator/__init__.py`

 * *Ordering differences only*

 * *Files 0% similar despite different names*

```diff
@@ -5,8 +5,8 @@
 # This software is a collaborative computer program whose purpose is to
 # generate and explore labeled data for computer vision applications.
 # This software is governed by the CeCILL-C license under French law and
 # abiding by the rules of distribution of free software. You can use,
 # modify and/ or redistribute the software under the terms of the CeCILL-C
 # license as circulated by CEA, CNRS and INRIA at the following URL
 #
-# http://www.cecill.info
+# http://www.cecill.info
```

### Comparing `pixano-0.2.1/pixano/apps/explorer/__init__.py` & `pixano-0.3.0/pixano/apps/explorer/__init__.py`

 * *Ordering differences only*

 * *Files 0% similar despite different names*

```diff
@@ -5,8 +5,8 @@
 # This software is a collaborative computer program whose purpose is to
 # generate and explore labeled data for computer vision applications.
 # This software is governed by the CeCILL-C license under French law and
 # abiding by the rules of distribution of free software. You can use,
 # modify and/ or redistribute the software under the terms of the CeCILL-C
 # license as circulated by CEA, CNRS and INRIA at the following URL
 #
-# http://www.cecill.info
+# http://www.cecill.info
```

### Comparing `pixano-0.2.1/pixano/apps/explorer/dist/assets/index-6d50d613.js` & `pixano-0.3.0/pixano/apps/explorer/dist/assets/index-f136c254.js`

 * *Files 2% similar despite different names*

#### js-beautify {}

```diff
@@ -1,11 +1,11 @@
-var L8 = (e, t) => () => (t || e((t = {
+var S7 = (e, t) => () => (t || e((t = {
     exports: {}
 }).exports, t), t.exports);
-var Ube = L8((F2e, jC) => {
+var A_e = S7((vwe, OC) => {
     (function() {
         const t = document.createElement("link").relList;
         if (t && t.supports && t.supports("modulepreload")) return;
         for (const r of document.querySelectorAll('link[rel="modulepreload"]')) i(r);
         new MutationObserver(r => {
             for (const s of r)
                 if (s.type === "childList")
@@ -24,558 +24,816 @@
             if (r.ep) return;
             r.ep = !0;
             const s = n(r);
             fetch(r.href, s)
         }
     })();
 
-    function Ve() {}
+    function Ue() {}
 
-    function SM(e) {
+    function Kp(e, t) {
+        for (const n in t) e[n] = t[n];
+        return e
+    }
+
+    function PO(e) {
         return e()
     }
 
-    function XC() {
+    function HC() {
         return Object.create(null)
     }
 
-    function js(e) {
-        e.forEach(SM)
+    function po(e) {
+        e.forEach(PO)
     }
 
-    function EM(e) {
+    function r_(e) {
         return typeof e == "function"
     }
 
-    function tn(e, t) {
+    function Tt(e, t) {
         return e != e ? t == t : e !== t || e && typeof e == "object" || typeof e == "function"
     }
-    let Bd;
+    let yg;
 
-    function fh(e, t) {
-        return Bd || (Bd = document.createElement("a")), Bd.href = t, e === Bd.href
+    function Ka(e, t) {
+        return yg || (yg = document.createElement("a")), yg.href = t, e === yg.href
     }
 
-    function I8(e) {
+    function E7(e) {
         return Object.keys(e).length === 0
     }
 
-    function G(e, t) {
+    function k7(e, ...t) {
+        if (e == null) return Ue;
+        const n = e.subscribe(...t);
+        return n.unsubscribe ? () => n.unsubscribe() : n
+    }
+
+    function s_(e, t, n) {
+        e.$$.on_destroy.push(k7(t, n))
+    }
+
+    function a_(e, t, n, i) {
+        if (e) {
+            const r = LO(e, t, n, i);
+            return e[0](r)
+        }
+    }
+
+    function LO(e, t, n, i) {
+        return e[1] && i ? Kp(n.ctx.slice(), e[1](i(t))) : n.ctx
+    }
+
+    function o_(e, t, n, i) {
+        if (e[2] && i) {
+            const r = e[2](i(n));
+            if (t.dirty === void 0) return r;
+            if (typeof r == "object") {
+                const s = [],
+                    a = Math.max(t.dirty.length, r.length);
+                for (let o = 0; o < a; o += 1) s[o] = t.dirty[o] | r[o];
+                return s
+            }
+            return t.dirty | r
+        }
+        return t.dirty
+    }
+
+    function l_(e, t, n, i, r, s) {
+        if (r) {
+            const a = LO(t, n, i, s);
+            e.p(a, r)
+        }
+    }
+
+    function u_(e) {
+        if (e.ctx.length > 32) {
+            const t = [],
+                n = e.ctx.length / 32;
+            for (let i = 0; i < n; i++) t[i] = -1;
+            return t
+        }
+        return -1
+    }
+
+    function C7(e) {
+        const t = {};
+        for (const n in e) n[0] !== "$" && (t[n] = e[n]);
+        return t
+    }
+
+    function YC(e, t) {
+        const n = {};
+        t = new Set(t);
+        for (const i in e) !t.has(i) && i[0] !== "$" && (n[i] = e[i]);
+        return n
+    }
+
+    function B(e, t) {
         e.appendChild(t)
     }
 
-    function we(e, t, n) {
+    function de(e, t, n) {
         e.insertBefore(t, n || null)
     }
 
-    function _e(e) {
+    function he(e) {
         e.parentNode && e.parentNode.removeChild(e)
     }
 
-    function Vo(e, t) {
+    function Ja(e, t) {
         for (let n = 0; n < e.length; n += 1) e[n] && e[n].d(t)
     }
 
-    function J(e) {
+    function V(e) {
         return document.createElement(e)
     }
 
-    function Je(e) {
+    function Xe(e) {
         return document.createTextNode(e)
     }
 
-    function Ee() {
-        return Je(" ")
+    function we() {
+        return Xe(" ")
     }
 
-    function bl() {
-        return Je("")
+    function Zi() {
+        return Xe("")
     }
 
-    function wt(e, t, n, i) {
+    function jt(e, t, n, i) {
         return e.addEventListener(t, n, i), () => e.removeEventListener(t, n, i)
     }
 
-    function j(e, t, n) {
+    function z(e, t, n) {
         n == null ? e.removeAttribute(t) : e.getAttribute(t) !== n && e.setAttribute(t, n)
     }
+    const A7 = ["width", "height"];
+
+    function XC(e, t) {
+        const n = Object.getOwnPropertyDescriptors(e.__proto__);
+        for (const i in t) t[i] == null ? e.removeAttribute(i) : i === "style" ? e.style.cssText = t[i] : i === "__value" ? e.value = e[i] = t[i] : n[i] && n[i].set && A7.indexOf(i) === -1 ? e[i] = t[i] : z(e, i, t[i])
+    }
 
     function VC(e) {
         return e === "" ? null : +e
     }
 
-    function z8(e) {
+    function $7(e) {
         return Array.from(e.childNodes)
     }
 
-    function Ot(e, t) {
+    function At(e, t) {
         t = "" + t, e.data !== t && (e.data = t)
     }
 
-    function jd(e, t) {
+    function vg(e, t) {
         e.value = t ?? ""
     }
 
     function KC(e, t, n, i) {
         n == null ? e.style.removeProperty(t) : e.style.setProperty(t, n, i ? "important" : "")
     }
 
-    function B8(e, t, {
+    function T7(e, t, {
         bubbles: n = !1,
         cancelable: i = !1
     } = {}) {
         const r = document.createEvent("CustomEvent");
         return r.initCustomEvent(e, n, i, t), r
     }
 
     function JC(e, t) {
         return new e(t)
     }
-    let hh;
+    let Gh;
 
-    function Hf(e) {
-        hh = e
+    function Sh(e) {
+        Gh = e
     }
 
-    function Xh() {
-        if (!hh) throw new Error("Function called outside component initialization");
-        return hh
+    function Wl() {
+        if (!Gh) throw new Error("Function called outside component initialization");
+        return Gh
     }
 
-    function j8(e) {
-        Xh().$$.before_update.push(e)
+    function M7(e) {
+        Wl().$$.before_update.push(e)
     }
 
-    function Z0(e) {
-        Xh().$$.on_mount.push(e)
+    function ra(e) {
+        Wl().$$.on_mount.push(e)
     }
 
-    function U8(e) {
-        Xh().$$.after_update.push(e)
+    function IO(e) {
+        Wl().$$.after_update.push(e)
     }
 
-    function G8(e) {
-        Xh().$$.on_destroy.push(e)
+    function Sd(e) {
+        Wl().$$.on_destroy.push(e)
     }
 
-    function fc() {
-        const e = Xh();
+    function er() {
+        const e = Wl();
         return (t, n, {
             cancelable: i = !1
         } = {}) => {
             const r = e.$$.callbacks[t];
             if (r) {
-                const s = B8(t, n, {
+                const s = T7(t, n, {
                     cancelable: i
                 });
                 return r.slice().forEach(a => {
                     a.call(e, s)
                 }), !s.defaultPrevented
             }
             return !0
         }
     }
 
     function QC(e, t) {
+        return Wl().$$.context.set(e, t), t
+    }
+
+    function zO(e) {
+        return Wl().$$.context.get(e)
+    }
+
+    function ZC(e, t) {
         const n = e.$$.callbacks[t.type];
         n && n.slice().forEach(i => i.call(this, t))
     }
-    const su = [],
-        pp = [];
-    let mu = [];
-    const Wv = [],
-        W8 = Promise.resolve();
-    let qv = !1;
+    const Fu = [],
+        Hi = [];
+    let Uu = [];
+    const Ob = [],
+        O7 = Promise.resolve();
+    let Fb = !1;
 
-    function q8() {
-        qv || (qv = !0, W8.then(CM))
+    function F7() {
+        Fb || (Fb = !0, O7.then(BO))
     }
 
-    function Hv(e) {
-        mu.push(e)
+    function Rb(e) {
+        Uu.push(e)
     }
 
-    function H8(e) {
-        Wv.push(e)
+    function bl(e) {
+        Ob.push(e)
     }
-    const oy = new Set;
-    let jl = 0;
+    const qy = new Set;
+    let gu = 0;
 
-    function CM() {
-        if (jl !== 0) return;
-        const e = hh;
+    function BO() {
+        if (gu !== 0) return;
+        const e = Gh;
         do {
             try {
-                for (; jl < su.length;) {
-                    const t = su[jl];
-                    jl++, Hf(t), Y8(t.$$)
+                for (; gu < Fu.length;) {
+                    const t = Fu[gu];
+                    gu++, Sh(t), R7(t.$$)
                 }
             } catch (t) {
-                throw su.length = 0, jl = 0, t
+                throw Fu.length = 0, gu = 0, t
             }
-            for (Hf(null), su.length = 0, jl = 0; pp.length;) pp.pop()();
-            for (let t = 0; t < mu.length; t += 1) {
-                const n = mu[t];
-                oy.has(n) || (oy.add(n), n())
-            }
-            mu.length = 0
-        } while (su.length);
-        for (; Wv.length;) Wv.pop()();
-        qv = !1, oy.clear(), Hf(e)
+            for (Sh(null), Fu.length = 0, gu = 0; Hi.length;) Hi.pop()();
+            for (let t = 0; t < Uu.length; t += 1) {
+                const n = Uu[t];
+                qy.has(n) || (qy.add(n), n())
+            }
+            Uu.length = 0
+        } while (Fu.length);
+        for (; Ob.length;) Ob.pop()();
+        Fb = !1, qy.clear(), Sh(e)
     }
 
-    function Y8(e) {
+    function R7(e) {
         if (e.fragment !== null) {
-            e.update(), js(e.before_update);
+            e.update(), po(e.before_update);
             const t = e.dirty;
-            e.dirty = [-1], e.fragment && e.fragment.p(e.ctx, t), e.after_update.forEach(Hv)
+            e.dirty = [-1], e.fragment && e.fragment.p(e.ctx, t), e.after_update.forEach(Rb)
         }
     }
 
-    function X8(e) {
+    function D7(e) {
         const t = [],
             n = [];
-        mu.forEach(i => e.indexOf(i) === -1 ? t.push(i) : n.push(i)), n.forEach(i => i()), mu = t
+        Uu.forEach(i => e.indexOf(i) === -1 ? t.push(i) : n.push(i)), n.forEach(i => i()), Uu = t
     }
-    const Bg = new Set;
-    let Ro;
+    const xp = new Set;
+    let il;
 
-    function ur() {
-        Ro = {
+    function on() {
+        il = {
             r: 0,
             c: [],
-            p: Ro
+            p: il
         }
     }
 
-    function cr() {
-        Ro.r || js(Ro.c), Ro = Ro.p
+    function ln() {
+        il.r || po(il.c), il = il.p
     }
 
-    function Te(e, t) {
-        e && e.i && (Bg.delete(e), e.i(t))
+    function fe(e, t) {
+        e && e.i && (xp.delete(e), e.i(t))
     }
 
-    function Ie(e, t, n, i) {
+    function ve(e, t, n, i) {
         if (e && e.o) {
-            if (Bg.has(e)) return;
-            Bg.add(e), Ro.c.push(() => {
-                Bg.delete(e), i && (n && e.d(1), i())
+            if (xp.has(e)) return;
+            xp.add(e), il.c.push(() => {
+                xp.delete(e), i && (n && e.d(1), i())
             }), e.o(t)
         } else i && i()
     }
 
-    function V8(e, t, n) {
+    function N7(e, t) {
+        const n = {},
+            i = {},
+            r = {
+                $$scope: 1
+            };
+        let s = e.length;
+        for (; s--;) {
+            const a = e[s],
+                o = t[s];
+            if (o) {
+                for (const l in a) l in o || (i[l] = 1);
+                for (const l in o) r[l] || (n[l] = o[l], r[l] = 1);
+                e[s] = o
+            } else
+                for (const l in a) r[l] = 1
+        }
+        for (const a in i) a in n || (n[a] = void 0);
+        return n
+    }
+
+    function xl(e, t, n) {
         const i = e.$$.props[t];
         i !== void 0 && (e.$$.bound[i] = n, n(e.$$.ctx[i]))
     }
 
-    function ei(e) {
+    function St(e) {
         e && e.c()
     }
 
-    function Nn(e, t, n, i) {
+    function xt(e, t, n, i) {
         const {
             fragment: r,
             after_update: s
         } = e.$$;
-        r && r.m(t, n), i || Hv(() => {
-            const a = e.$$.on_mount.map(SM).filter(EM);
-            e.$$.on_destroy ? e.$$.on_destroy.push(...a) : js(a), e.$$.on_mount = []
-        }), s.forEach(Hv)
+        r && r.m(t, n), i || Rb(() => {
+            const a = e.$$.on_mount.map(PO).filter(r_);
+            e.$$.on_destroy ? e.$$.on_destroy.push(...a) : po(a), e.$$.on_mount = []
+        }), s.forEach(Rb)
     }
 
-    function Pn(e, t) {
+    function _t(e, t) {
         const n = e.$$;
-        n.fragment !== null && (X8(n.after_update), js(n.on_destroy), n.fragment && n.fragment.d(t), n.on_destroy = n.fragment = null, n.ctx = [])
+        n.fragment !== null && (D7(n.after_update), po(n.on_destroy), n.fragment && n.fragment.d(t), n.on_destroy = n.fragment = null, n.ctx = [])
     }
 
-    function K8(e, t) {
-        e.$$.dirty[0] === -1 && (su.push(e), q8(), e.$$.dirty.fill(0)), e.$$.dirty[t / 31 | 0] |= 1 << t % 31
+    function P7(e, t) {
+        e.$$.dirty[0] === -1 && (Fu.push(e), F7(), e.$$.dirty.fill(0)), e.$$.dirty[t / 31 | 0] |= 1 << t % 31
     }
 
-    function _n(e, t, n, i, r, s, a, o = [-1]) {
-        const l = hh;
-        Hf(e);
+    function Lt(e, t, n, i, r, s, a, o = [-1]) {
+        const l = Gh;
+        Sh(e);
         const u = e.$$ = {
             fragment: null,
             ctx: [],
             props: s,
-            update: Ve,
+            update: Ue,
             not_equal: r,
-            bound: XC(),
+            bound: HC(),
             on_mount: [],
             on_destroy: [],
             on_disconnect: [],
             before_update: [],
             after_update: [],
             context: new Map(t.context || (l ? l.$$.context : [])),
-            callbacks: XC(),
+            callbacks: HC(),
             dirty: o,
             skip_bound: !1,
             root: t.target || l.$$.root
         };
         a && a(u.root);
         let c = !1;
         if (u.ctx = n ? n(e, t.props || {}, (f, h, ...d) => {
                 const g = d.length ? d[0] : h;
-                return u.ctx && r(u.ctx[f], u.ctx[f] = g) && (!u.skip_bound && u.bound[f] && u.bound[f](g), c && K8(e, f)), h
-            }) : [], u.update(), c = !0, js(u.before_update), u.fragment = i ? i(u.ctx) : !1, t.target) {
+                return u.ctx && r(u.ctx[f], u.ctx[f] = g) && (!u.skip_bound && u.bound[f] && u.bound[f](g), c && P7(e, f)), h
+            }) : [], u.update(), c = !0, po(u.before_update), u.fragment = i ? i(u.ctx) : !1, t.target) {
             if (t.hydrate) {
-                const f = z8(t.target);
-                u.fragment && u.fragment.l(f), f.forEach(_e)
+                const f = $7(t.target);
+                u.fragment && u.fragment.l(f), f.forEach(he)
             } else u.fragment && u.fragment.c();
-            t.intro && Te(e.$$.fragment), Nn(e, t.target, t.anchor, t.customElement), CM()
+            t.intro && fe(e.$$.fragment), xt(e, t.target, t.anchor, t.customElement), BO()
         }
-        Hf(l)
+        Sh(l)
     }
-    class wn {
+    class It {
         $destroy() {
-            Pn(this, 1), this.$destroy = Ve
+            _t(this, 1), this.$destroy = Ue
         }
         $on(t, n) {
-            if (!EM(n)) return Ve;
+            if (!r_(n)) return Ue;
             const i = this.$$.callbacks[t] || (this.$$.callbacks[t] = []);
             return i.push(n), () => {
                 const r = i.indexOf(n);
                 r !== -1 && i.splice(r, 1)
             }
         }
         $set(t) {
-            this.$$set && !I8(t) && (this.$$.skip_bound = !0, this.$$set(t), this.$$.skip_bound = !1)
+            this.$$set && !E7(t) && (this.$$.skip_bound = !0, this.$$set(t), this.$$.skip_bound = !1)
         }
     }
-    const Ul = [];
-
-    function J8(e, t = Ve) {
-        let n;
-        const i = new Set;
-
-        function r(o) {
-            if (tn(e, o) && (e = o, n)) {
-                const l = !Ul.length;
-                for (const u of i) u[1](), Ul.push(u, e);
-                if (l) {
-                    for (let u = 0; u < Ul.length; u += 2) Ul[u][0](Ul[u + 1]);
-                    Ul.length = 0
-                }
-            }
-        }
-
-        function s(o) {
-            r(o(e))
-        }
 
-        function a(o, l = Ve) {
-            const u = [o, l];
-            return i.add(u), i.size === 1 && (n = t(r) || Ve), o(e), () => {
-                i.delete(u), i.size === 0 && n && (n(), n = null)
+    function L7(e) {
+        let t, n, i;
+        return {
+            c() {
+                t = V("div"), t.textContent = "Loading datasets...", n = we(), i = V("div"), i.innerHTML = `<div class="animate-pulse flex space-x-4"><div class="rounded-full bg-slate-200 h-10 w-10"></div> 
+    <div class="flex-1 space-y-6 py-1"><div class="h-2 bg-slate-200 rounded"></div> 
+      <div class="space-y-3"><div class="grid grid-cols-3 gap-4"><div class="h-2 bg-slate-200 rounded col-span-2"></div> 
+          <div class="h-2 bg-slate-200 rounded col-span-1"></div></div> 
+        <div class="h-2 bg-slate-200 rounded"></div></div></div></div>`, z(t, "class", "mt-4 py-8 flex w-full justify-center font-bold text-lg italic text-zinc-500"), z(i, "class", "mt-8 mx-auto border border-zinc-100 shadow rounded-md p-4 max-w-sm w-full dark:border-zinc-700")
+            },
+            m(r, s) {
+                de(r, t, s), de(r, n, s), de(r, i, s)
+            },
+            p: Ue,
+            i: Ue,
+            o: Ue,
+            d(r) {
+                r && he(t), r && he(n), r && he(i)
             }
         }
-        return {
-            set: r,
-            update: s,
-            subscribe: a
+    }
+    class I7 extends It {
+        constructor(t) {
+            super(), Lt(this, t, null, L7, Tt, {})
         }
     }
-    /**
-    @copyright CEA-LIST/DIASI/SIALV/LVA (2023)
-    @author CEA-LIST/DIASI/SIALV/LVA <pixano@cea.fr>
-    @license CECILL-C
-
-    This software is a collaborative computer program whose purpose is to
-    generate and explore labeled data for computer vision applications.
-    This software is governed by the CeCILL-C license under French law and
-    abiding by the rules of distribution of free software. You can use, 
-    modify and/ or redistribute the software under the terms of the CeCILL-C
-    license as circulated by CEA, CNRS and INRIA at the following URL
-
-    http://www.cecill.info
-    */
-    const jg = J8(1),
-        Q8 = "/assets/pixano-354ac9df.png";
 
-    function Z8(e) {
-        let t, n, i, r = e[0].name + "",
-            s, a, o, l = e[0].num_elements + "",
-            u, c, f, h, d, g, p, m, y, v, b, x;
+    function z7(e) {
+        let t, n, i, r, s = e[0].name + "",
+            a, o, l, u, c, f = e[0].name + "",
+            h, d, g, p, m, y = e[0].description + "",
+            v, b, x, _ = e[0].num_elements + "",
+            S, w, E, C, k, A, F, $, T, M, R, N, L;
         return {
             c() {
-                t = J("div"), n = J("div"), i = J("h3"), s = Je(r), a = Ee(), o = J("p"), u = Je(l), c = Je(" elements"), f = Ee(), h = J("div"), d = J("img"), m = Ee(), y = J("div"), v = J("button"), v.textContent = "Explore", j(i, "class", "text-lg font-medium text-zinc-900 dark:text-zinc-300"), j(o, "class", "text-sm text-zinc-500"), j(n, "class", "h-1/5 px-4 flex flex-col justify-center"), fh(d.src, g = e[0].preview) || j(d, "src", g), j(d, "alt", p = e[0].name), j(d, "class", "h-full w-full object-cover object-center"), j(h, "class", "h-3/5 border-t border-b border-zinc-200 dark:border-zinc-700"), j(v, "class", "py-2 px-3 bg-rose-500 text-zinc-50 font-medium rounded-md border-2 border-rose-500 transition-all hover:text-rose-600 hover:bg-zinc-50 dark:bg-rose-800 dark:border-rose-800 dark:hover:text-rose-700 dark:hover:bg-zinc-800"), j(y, "class", "h-1/5 px-4 flex flex-col justify-center items-end text-sm"), j(t, "class", "w-64 h-80 m-4 flex flex-col bg-zinc-50 text-zinc-900 border border-zinc-300 rounded-md cursor-pointer transition-all hover:scale-[102.5%] dark:bg-zinc-800 dark:text-zinc-50 dark:border-zinc-700")
+                t = V("div"), n = V("div"), i = V("div"), r = V("h3"), a = Xe(s), o = we(), l = V("div"), u = V("div"), c = V("p"), h = Xe(f), d = we(), g = V("br"), p = we(), m = V("i"), v = Xe(y), b = we(), x = V("p"), S = Xe(_), w = Xe(" elements"), E = we(), C = V("div"), k = V("img"), $ = we(), T = V("div"), M = V("button"), R = Xe(e[1]), z(r, "class", "text-lg font-heavy truncate text-zinc-900 dark:text-zinc-300"), z(u, "class", "px-2 py-1 text-zinc-700 text-sm rounded bg-zinc-50 border"), z(l, "class", "absolute h-1/5 px-4 py-0 flex flex-col justify-center hidden group-hover:block"), z(i, "class", "group"), z(x, "class", "text-sm text-zinc-500"), z(n, "class", "h-1/5 px-4 flex flex-col justify-center"), Ka(k.src, A = e[0].preview) || z(k, "src", A), z(k, "alt", F = e[0].name), z(k, "class", "h-full w-full object-cover object-center"), z(C, "class", "h-3/5 border-t border-b border-zinc-200 dark:border-zinc-700"), z(M, "class", "py-2 px-3 bg-rose-500 text-zinc-50 font-heavy rounded-md border-2 border-rose-500 transition-all hover:text-rose-600 hover:bg-zinc-50 dark:bg-rose-800 dark:border-rose-800 dark:hover:text-rose-700 dark:hover:bg-zinc-800"), z(T, "class", "h-1/5 px-4 flex flex-col justify-center items-end text-sm"), z(t, "class", "w-64 h-80 m-4 flex flex-col bg-zinc-50 text-zinc-900 border border-zinc-300 rounded-md cursor-pointer transition-all hover:scale-110 dark:bg-zinc-800 dark:text-zinc-50 dark:border-zinc-700")
             },
-            m(_, S) {
-                we(_, t, S), G(t, n), G(n, i), G(i, s), G(n, a), G(n, o), G(o, u), G(o, c), G(t, f), G(t, h), G(h, d), G(t, m), G(t, y), G(y, v), b || (x = [wt(v, "click", e[1]), wt(t, "click", e[1])], b = !0)
+            m(I, G) {
+                de(I, t, G), B(t, n), B(n, i), B(i, r), B(r, a), B(i, o), B(i, l), B(l, u), B(u, c), B(c, h), B(u, d), B(u, g), B(u, p), B(u, m), B(m, v), B(n, b), B(n, x), B(x, S), B(x, w), B(t, E), B(t, C), B(C, k), B(t, $), B(t, T), B(T, M), B(M, R), N || (L = [jt(M, "click", e[2]), jt(t, "click", e[2])], N = !0)
             },
-            p(_, [S]) {
-                S & 1 && r !== (r = _[0].name + "") && Ot(s, r), S & 1 && l !== (l = _[0].num_elements + "") && Ot(u, l), S & 1 && !fh(d.src, g = _[0].preview) && j(d, "src", g), S & 1 && p !== (p = _[0].name) && j(d, "alt", p)
+            p(I, [G]) {
+                G & 1 && s !== (s = I[0].name + "") && At(a, s), G & 1 && f !== (f = I[0].name + "") && At(h, f), G & 1 && y !== (y = I[0].description + "") && At(v, y), G & 1 && _ !== (_ = I[0].num_elements + "") && At(S, _), G & 1 && !Ka(k.src, A = I[0].preview) && z(k, "src", A), G & 1 && F !== (F = I[0].name) && z(k, "alt", F), G & 2 && At(R, I[1])
             },
-            i: Ve,
-            o: Ve,
-            d(_) {
-                _ && _e(t), b = !1, js(x)
+            i: Ue,
+            o: Ue,
+            d(I) {
+                I && he(t), N = !1, po(L)
             }
         }
     }
 
-    function e9(e, t, n) {
+    function B7(e, t, n) {
         let {
             dataset: i
+        } = t, {
+            btn_label: r
         } = t;
-        const r = fc();
+        const s = er();
 
-        function s() {
-            r("click")
+        function a() {
+            s("click")
         }
-        return e.$$set = a => {
-            "dataset" in a && n(0, i = a.dataset)
-        }, [i, s]
+        return e.$$set = o => {
+            "dataset" in o && n(0, i = o.dataset), "btn_label" in o && n(1, r = o.btn_label)
+        }, [i, r, a]
     }
-    class t9 extends wn {
+    class j7 extends It {
         constructor(t) {
-            super(), _n(this, t, e9, Z8, tn, {
-                dataset: 0
+            super(), Lt(this, t, B7, z7, Tt, {
+                dataset: 0,
+                btn_label: 1
             })
         }
     }
 
-    function ZC(e, t, n) {
+    function eA(e, t, n) {
         const i = e.slice();
-        return i[4] = t[n], i
+        return i[5] = t[n], i
     }
 
-    function ek(e) {
-        let t, n;
-
-        function i() {
-            return e[2](e[4])
-        }
-        return t = new t9({
-            props: {
-                dataset: e[4]
-            }
-        }), t.$on("click", i), {
+    function G7(e) {
+        let t;
+        return {
             c() {
-                ei(t.$$.fragment)
-            },
-            m(r, s) {
-                Nn(t, r, s), n = !0
-            },
-            p(r, s) {
-                e = r;
-                const a = {};
-                s & 1 && (a.dataset = e[4]), t.$set(a)
-            },
-            i(r) {
-                n || (Te(t.$$.fragment, r), n = !0)
+                t = V("div"), t.textContent = "No datasets found...", z(t, "class", "mt-4 py-8 flex w-full justify-center font-bold text-lg italic text-zinc-500")
             },
-            o(r) {
-                Ie(t.$$.fragment, r), n = !1
+            m(n, i) {
+                de(n, t, i)
             },
-            d(r) {
-                Pn(t, r)
+            p: Ue,
+            i: Ue,
+            o: Ue,
+            d(n) {
+                n && he(t)
             }
         }
     }
 
-    function n9(e) {
+    function U7(e) {
         let t, n, i, r = e[0],
             s = [];
-        for (let o = 0; o < r.length; o += 1) s[o] = ek(ZC(e, r, o));
-        const a = o => Ie(s[o], 1, 1, () => {
+        for (let o = 0; o < r.length; o += 1) s[o] = tA(eA(e, r, o));
+        const a = o => ve(s[o], 1, 1, () => {
             s[o] = null
         });
         return {
             c() {
-                t = J("div"), n = J("div");
+                t = V("div"), n = V("div");
                 for (let o = 0; o < s.length; o += 1) s[o].c();
-                j(n, "class", "grid grid-cols-6 gap-4"), j(t, "class", "mx-auto px-8")
+                z(n, "class", "grid sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 2xl:grid-cols-5 gap-4"), z(t, "class", "mx-auto px-8")
             },
             m(o, l) {
-                we(o, t, l), G(t, n);
+                de(o, t, l), B(t, n);
                 for (let u = 0; u < s.length; u += 1) s[u] && s[u].m(n, null);
                 i = !0
             },
-            p(o, [l]) {
-                if (l & 3) {
+            p(o, l) {
+                if (l & 7) {
                     r = o[0];
                     let u;
                     for (u = 0; u < r.length; u += 1) {
-                        const c = ZC(o, r, u);
-                        s[u] ? (s[u].p(c, l), Te(s[u], 1)) : (s[u] = ek(c), s[u].c(), Te(s[u], 1), s[u].m(n, null))
+                        const c = eA(o, r, u);
+                        s[u] ? (s[u].p(c, l), fe(s[u], 1)) : (s[u] = tA(c), s[u].c(), fe(s[u], 1), s[u].m(n, null))
                     }
-                    for (ur(), u = r.length; u < s.length; u += 1) a(u);
-                    cr()
+                    for (on(), u = r.length; u < s.length; u += 1) a(u);
+                    ln()
                 }
             },
             i(o) {
                 if (!i) {
-                    for (let l = 0; l < r.length; l += 1) Te(s[l]);
+                    for (let l = 0; l < r.length; l += 1) fe(s[l]);
                     i = !0
                 }
             },
             o(o) {
                 s = s.filter(Boolean);
-                for (let l = 0; l < s.length; l += 1) Ie(s[l]);
+                for (let l = 0; l < s.length; l += 1) ve(s[l]);
                 i = !1
             },
             d(o) {
-                o && _e(t), Vo(s, o)
+                o && he(t), Ja(s, o)
+            }
+        }
+    }
+
+    function tA(e) {
+        let t, n;
+
+        function i() {
+            return e[3](e[5])
+        }
+        return t = new j7({
+            props: {
+                dataset: e[5],
+                btn_label: e[1]
+            }
+        }), t.$on("click", i), {
+            c() {
+                St(t.$$.fragment)
+            },
+            m(r, s) {
+                xt(t, r, s), n = !0
+            },
+            p(r, s) {
+                e = r;
+                const a = {};
+                s & 1 && (a.dataset = e[5]), s & 2 && (a.btn_label = e[1]), t.$set(a)
+            },
+            i(r) {
+                n || (fe(t.$$.fragment, r), n = !0)
+            },
+            o(r) {
+                ve(t.$$.fragment, r), n = !1
+            },
+            d(r) {
+                _t(t, r)
+            }
+        }
+    }
+
+    function W7(e) {
+        let t, n, i, r;
+        const s = [U7, G7],
+            a = [];
+
+        function o(l, u) {
+            return l[0].length != 0 ? 0 : 1
+        }
+        return t = o(e), n = a[t] = s[t](e), {
+            c() {
+                n.c(), i = Zi()
+            },
+            m(l, u) {
+                a[t].m(l, u), de(l, i, u), r = !0
+            },
+            p(l, [u]) {
+                let c = t;
+                t = o(l), t === c ? a[t].p(l, u) : (on(), ve(a[c], 1, 1, () => {
+                    a[c] = null
+                }), ln(), n = a[t], n ? n.p(l, u) : (n = a[t] = s[t](l), n.c()), fe(n, 1), n.m(i.parentNode, i))
+            },
+            i(l) {
+                r || (fe(n), r = !0)
+            },
+            o(l) {
+                ve(n), r = !1
+            },
+            d(l) {
+                a[t].d(l), l && he(i)
             }
         }
     }
 
-    function i9(e, t, n) {
+    function q7(e, t, n) {
         let {
             datasets: i
+        } = t, {
+            btn_label: r
         } = t;
-        const r = fc();
+        const s = er();
 
-        function s(o) {
-            r("datasetclick", {
-                dataset: o
+        function a(l) {
+            s("datasetclick", {
+                dataset: l
             })
         }
-        const a = o => s(o);
-        return e.$$set = o => {
-            "datasets" in o && n(0, i = o.datasets)
-        }, [i, s, a]
+        const o = l => a(l);
+        return e.$$set = l => {
+            "datasets" in l && n(0, i = l.datasets), "btn_label" in l && n(1, r = l.btn_label)
+        }, [i, r, a, o]
     }
-    class r9 extends wn {
+    class H7 extends It {
         constructor(t) {
-            super(), _n(this, t, i9, n9, tn, {
-                datasets: 0
+            super(), Lt(this, t, q7, W7, Tt, {
+                datasets: 0,
+                btn_label: 1
             })
         }
     }
 
-    function s9(e) {
-        let t, n, i;
-        return {
-            c() {
-                t = J("div"), t.textContent = "Loading datasets...", n = Ee(), i = J("div"), i.innerHTML = `<div class="animate-pulse flex space-x-4"><div class="rounded-full bg-slate-200 h-10 w-10"></div> 
-    <div class="flex-1 space-y-6 py-1"><div class="h-2 bg-slate-200 rounded"></div> 
-      <div class="space-y-3"><div class="grid grid-cols-3 gap-4"><div class="h-2 bg-slate-200 rounded col-span-2"></div> 
-          <div class="h-2 bg-slate-200 rounded col-span-1"></div></div> 
-        <div class="h-2 bg-slate-200 rounded"></div></div></div></div>`, j(t, "class", "mt-4 flex w-full justify-center font-bold italic text-zinc-500"), j(i, "class", "mt-8 mx-auto border border-zinc-100 shadow rounded-md p-4 max-w-sm w-full dark:border-zinc-700")
-            },
-            m(r, s) {
-                we(r, t, s), we(r, n, s), we(r, i, s)
-            },
-            p: Ve,
-            i: Ve,
-            o: Ve,
-            d(r) {
-                r && _e(t), r && _e(n), r && _e(i)
+    function Jp(e) {
+        return e.split(" ").map(t => parseInt(t))
+    }
+
+    function Y7(e, t) {
+        const n = [],
+            i = {
+                line: -1,
+                points: []
+            };
+        let r = 0;
+        const s = () => {
+            i.points.length > 0 && (n.push({
+                line: i.line,
+                points: i.points
+            }), i.points = [])
+        };
+        for (let a = 1; a < e.length; a += 2) {
+            r += e[a - 1];
+            const o = r % t,
+                l = Math.floor(r / t);
+            r += e[a];
+            const u = r % t,
+                c = Math.floor(r / t);
+            if (i.line !== l && (s(), i.line = l), l === c) {
+                i.points.push(o, u);
+                continue
             }
+            i.points.push(o, t), s(), i.line = c;
+            for (let f = l + 1; f < c; f++) n.push({
+                line: f,
+                points: [0, t]
+            });
+            u > 0 && i.points.push(0, u)
         }
+        return s(), n
     }
-    class a9 extends wn {
-        constructor(t) {
-            super(), _n(this, t, null, s9, tn, {})
+
+    function X7(e, t) {
+        const n = Y7(e, t);
+        if (n.length === 0) return new Map;
+        const i = new Map;
+        let r = -1,
+            s = [];
+        const a = new Map,
+            o = (h, d) => {
+                const g = `${h.x} ${h.y}`,
+                    p = `${d.x} ${d.y}`;
+                i.has(g) || i.set(g, new Set), i.get(g).add(p), i.has(p) || i.set(p, new Set), i.get(p).add(g)
+            },
+            l = (h, d) => {
+                d !== a.get(h) && (o({
+                    x: a.get(h),
+                    y: h
+                }, {
+                    x: d,
+                    y: h
+                }), a.delete(h))
+            },
+            u = (h, d, g, p) => {
+                if (d === p) {
+                    a.has(d) || a.set(d, h);
+                    return
+                }
+                let m = !1;
+                const y = Math.max(h, g);
+                a.has(d) && (l(d, y), m = !0), a.has(p) && (l(p, y), m = !0), m ? o({
+                    x: y,
+                    y: d
+                }, {
+                    x: y,
+                    y: p
+                }) : o({
+                    x: h,
+                    y: d
+                }, {
+                    x: g,
+                    y: p
+                })
+            },
+            c = (h, d) => {
+                for (const g of d) u(h, g, h + 1, g);
+                for (let g = 1; g < d.length; g += 2) u(h + 1, d[g - 1], h + 1, d[g])
+            };
+        for (const {
+                line: h,
+                points: d
+            }
+            of n) {
+            h !== r + 1 && (c(r, s), r = h - 1, s = []);
+            let g = s.length && s[0] <= d[0] ? r : h,
+                p = g === r ? s[0] : d[0],
+                m = g === r ? 1 : 0,
+                y = g === r ? 0 : 1,
+                v = !0;
+            for (; m < s.length || y < d.length;) {
+                let b, x;
+                m === s.length || d[y] < s[m] ? (b = h, x = d[y], y++) : (b = r, x = s[m], m++), v && (g === r && b === r ? (u(r, p, h, p), u(r, x, h, x), u(h, p, h, x)) : u(g, p, b, x)), v = !v, g = b, p = x
+            }
+            r = h, s = d
+        }
+        return c(r, s), new Map([...i].sort((h, d) => {
+            const [g, p] = Jp(h[0]), [m, y] = Jp(d[0]);
+            return g === m ? p - y : g - m
+        }))
+    }
+
+    function V7(e) {
+        const t = [];
+        for (; e.size;) {
+            let [a, o] = e.entries().next().value;
+            const l = a,
+                u = [Jp(l)];
+            let c = null;
+            for (; c !== l;) {
+                c = o.values().next().value, u.push(Jp(c)), o.delete(c), o.size === 0 && e.delete(a);
+                const f = e.get(c);
+                if (f.delete(a), f.size === 0) {
+                    e.delete(c);
+                    break
+                } else a = c, o = f
+            }
+            t.push(u)
+        }
+        const n = [],
+            i = [],
+            s = document.createElement("canvas").getContext("2d");
+        for (const a of t) {
+            let o = !1;
+            const [l, u] = a[0];
+            for (const d of n) s.isPointInPath(d, l + .5, u + .5) && (o = !o);
+            o && a.reverse();
+            const c = a.slice(1).map(([d, g]) => `${d} ${g}`).join(" "),
+                f = `M${a[0][0]} ${a[0][1]} L` + c;
+            i.push(f);
+            const h = new Path2D(f);
+            s.fill(h), n.push(h)
         }
+        return i
     }
     /**
     @copyright CEA-LIST/DIASI/SIALV/LVA (2023)
     @author CEA-LIST/DIASI/SIALV/LVA <pixano@cea.fr>
     @license CECILL-C
 
     This software is a collaborative computer program whose purpose is to
@@ -583,13008 +841,9850 @@
     This software is governed by the CeCILL-C license under French law and
     abiding by the rules of distribution of free software. You can use, 
     modify and/ or redistribute the software under the terms of the CeCILL-C
     license as circulated by CEA, CNRS and INRIA at the following URL
 
     http://www.cecill.info
     */
-    async function o9() {
+    async function K7() {
         let e = null;
         try {
             e = await (await fetch("/datasets")).json()
         } catch (t) {
             console.log(t)
         }
         return e
     }
-    async function ly(e, t = 1, n = 100) {
+    async function Hy(e, t = 1, n = 100) {
         let i = null;
         try {
             i = await (await fetch(`/datasets/${e}/items?page=${t}&size=${n}`)).json()
         } catch (r) {
             console.log(r)
         }
         return i
     }
-    async function l9(e) {
+    async function J7(e) {
         let t = null;
         try {
-            t = await (await fetch(`/datasets/${e}/stats`)).json()
+            const n = await fetch(`/datasets/${e}/stats`);
+            if (!n.ok) return console.log("No stats"), [];
+            t = await n.json()
         } catch (n) {
             console.log(n)
         }
         return t
     }
-    async function u9(e, t) {
+    async function Q7(e, t) {
         let n = null;
         try {
             n = await (await fetch(`/datasets/${e}/items/${t}`)).json()
         } catch (i) {
             console.log(i)
         }
         return n
     }
-    var c9 = Math.PI / 180;
 
-    function f9() {
-        return typeof window < "u" && ({}.toString.call(window) === "[object Window]" || {}.toString.call(window) === "[object global]")
-    }
-    const yu = typeof global < "u" ? global : typeof window < "u" ? window : typeof WorkerGlobalScope < "u" ? self : {},
-        le = {
-            _global: yu,
-            version: "8.4.3",
-            isBrowser: f9(),
-            isUnminified: /param/.test(function(e) {}.toString()),
-            dblClickWindow: 400,
-            getAngle(e) {
-                return le.angleDeg ? e * c9 : e
+    function Z7(e) {
+        let t, n;
+        return {
+            c() {
+                t = V("div"), n = Xe(e[0]), z(t, "class", "pl-2 text-zinc-900")
             },
-            enableTrace: !1,
-            pointerEventsEnabled: !0,
-            autoDrawEnabled: !0,
-            hitOnDragEnabled: !1,
-            capturePointerEventsEnabled: !1,
-            _mouseListenClick: !1,
-            _touchListenClick: !1,
-            _pointerListenClick: !1,
-            _mouseInDblClickWindow: !1,
-            _touchInDblClickWindow: !1,
-            _pointerInDblClickWindow: !1,
-            _mouseDblClickPointerId: null,
-            _touchDblClickPointerId: null,
-            _pointerDblClickPointerId: null,
-            pixelRatio: typeof window < "u" && window.devicePixelRatio || 1,
-            dragDistance: 3,
-            angleDeg: !0,
-            showWarnings: !0,
-            dragButtons: [0, 1],
-            isDragging() {
-                return le.DD.isDragging
+            m(i, r) {
+                de(i, t, r), B(t, n)
             },
-            isDragReady() {
-                return !!le.DD.node
+            p(i, [r]) {
+                r & 1 && At(n, i[0])
             },
-            releaseCanvasOnDestroy: !0,
-            document: yu.document,
-            _injectGlobal(e) {
-                yu.Konva = e
+            i: Ue,
+            o: Ue,
+            d(i) {
+                i && he(t)
             }
-        },
-        pt = e => {
-            le[e.prototype.getClassName()] = e
-        };
-    le._injectGlobal(le);
-    let Ki = class kM {
-        constructor(t = [1, 0, 0, 1, 0, 0]) {
-            this.dirty = !1, this.m = t && t.slice() || [1, 0, 0, 1, 0, 0]
-        }
-        reset() {
-            this.m[0] = 1, this.m[1] = 0, this.m[2] = 0, this.m[3] = 1, this.m[4] = 0, this.m[5] = 0
         }
-        copy() {
-            return new kM(this.m)
-        }
-        copyInto(t) {
-            t.m[0] = this.m[0], t.m[1] = this.m[1], t.m[2] = this.m[2], t.m[3] = this.m[3], t.m[4] = this.m[4], t.m[5] = this.m[5]
+    }
+
+    function eB(e, t, n) {
+        let {
+            value: i
+        } = t;
+        return e.$$set = r => {
+            "value" in r && n(0, i = r.value)
+        }, [i]
+    }
+    class tB extends It {
+        constructor(t) {
+            super(), Lt(this, t, eB, Z7, Tt, {
+                value: 0
+            })
         }
-        point(t) {
-            var n = this.m;
-            return {
-                x: n[0] * t.x + n[2] * t.y + n[4],
-                y: n[1] * t.x + n[3] * t.y + n[5]
+    }
+
+    function nB(e) {
+        let t, n;
+        return {
+            c() {
+                t = V("div"), n = Xe(e[0]), z(t, "class", "pl-2 text-zinc-900")
+            },
+            m(i, r) {
+                de(i, t, r), B(t, n)
+            },
+            p(i, [r]) {
+                r & 1 && At(n, i[0])
+            },
+            i: Ue,
+            o: Ue,
+            d(i) {
+                i && he(t)
             }
         }
-        translate(t, n) {
-            return this.m[4] += this.m[0] * t + this.m[2] * n, this.m[5] += this.m[1] * t + this.m[3] * n, this
+    }
+
+    function iB(e, t, n) {
+        let {
+            value: i
+        } = t;
+        return e.$$set = r => {
+            "value" in r && n(0, i = r.value)
+        }, [i]
+    }
+    class rB extends It {
+        constructor(t) {
+            super(), Lt(this, t, iB, nB, Tt, {
+                value: 0
+            })
         }
-        scale(t, n) {
-            return this.m[0] *= t, this.m[1] *= t, this.m[2] *= n, this.m[3] *= n, this
+    }
+
+    function sB(e) {
+        let t, n;
+        return {
+            c() {
+                t = V("img"), z(t, "class", "px-2 h-56 w-56 min-w-[14rem] object-cover"), Ka(t.src, n = e[0]) || z(t, "src", n), z(t, "alt", e[0])
+            },
+            m(i, r) {
+                de(i, t, r)
+            },
+            p(i, [r]) {
+                r & 1 && !Ka(t.src, n = i[0]) && z(t, "src", n), r & 1 && z(t, "alt", i[0])
+            },
+            i: Ue,
+            o: Ue,
+            d(i) {
+                i && he(t)
+            }
         }
-        rotate(t) {
-            var n = Math.cos(t),
-                i = Math.sin(t),
-                r = this.m[0] * n + this.m[2] * i,
-                s = this.m[1] * n + this.m[3] * i,
-                a = this.m[0] * -i + this.m[2] * n,
-                o = this.m[1] * -i + this.m[3] * n;
-            return this.m[0] = r, this.m[1] = s, this.m[2] = a, this.m[3] = o, this
+    }
+
+    function aB(e, t, n) {
+        let {
+            value: i
+        } = t;
+        return e.$$set = r => {
+            "value" in r && n(0, i = r.value)
+        }, [i]
+    }
+    class oB extends It {
+        constructor(t) {
+            super(), Lt(this, t, aB, sB, Tt, {
+                value: 0
+            })
         }
-        getTranslation() {
-            return {
-                x: this.m[4],
-                y: this.m[5]
+    }
+    /*!
+     * https://github.com/Starcounter-Jack/JSON-Patch
+     * (c) 2017-2022 Joachim Wester
+     * MIT licensed
+     */
+    var lB = globalThis && globalThis.__extends || function() {
+            var e = function(t, n) {
+                return e = Object.setPrototypeOf || {
+                    __proto__: []
+                }
+                instanceof Array && function(i, r) {
+                    i.__proto__ = r
+                } || function(i, r) {
+                    for (var s in r) r.hasOwnProperty(s) && (i[s] = r[s])
+                }, e(t, n)
+            };
+            return function(t, n) {
+                e(t, n);
+
+                function i() {
+                    this.constructor = t
+                }
+                t.prototype = n === null ? Object.create(n) : (i.prototype = n.prototype, new i)
             }
+        }(),
+        uB = Object.prototype.hasOwnProperty;
+
+    function Db(e, t) {
+        return uB.call(e, t)
+    }
+
+    function Nb(e) {
+        if (Array.isArray(e)) {
+            for (var t = new Array(e.length), n = 0; n < t.length; n++) t[n] = "" + n;
+            return t
         }
-        skew(t, n) {
-            var i = this.m[0] + this.m[2] * n,
-                r = this.m[1] + this.m[3] * n,
-                s = this.m[2] + this.m[0] * t,
-                a = this.m[3] + this.m[1] * t;
-            return this.m[0] = i, this.m[1] = r, this.m[2] = s, this.m[3] = a, this
+        if (Object.keys) return Object.keys(e);
+        var i = [];
+        for (var r in e) Db(e, r) && i.push(r);
+        return i
+    }
+
+    function Ai(e) {
+        switch (typeof e) {
+            case "object":
+                return JSON.parse(JSON.stringify(e));
+            case "undefined":
+                return null;
+            default:
+                return e
         }
-        multiply(t) {
-            var n = this.m[0] * t.m[0] + this.m[2] * t.m[1],
-                i = this.m[1] * t.m[0] + this.m[3] * t.m[1],
-                r = this.m[0] * t.m[2] + this.m[2] * t.m[3],
-                s = this.m[1] * t.m[2] + this.m[3] * t.m[3],
-                a = this.m[0] * t.m[4] + this.m[2] * t.m[5] + this.m[4],
-                o = this.m[1] * t.m[4] + this.m[3] * t.m[5] + this.m[5];
-            return this.m[0] = n, this.m[1] = i, this.m[2] = r, this.m[3] = s, this.m[4] = a, this.m[5] = o, this
+    }
+
+    function Pb(e) {
+        for (var t = 0, n = e.length, i; t < n;) {
+            if (i = e.charCodeAt(t), i >= 48 && i <= 57) {
+                t++;
+                continue
+            }
+            return !1
         }
-        invert() {
-            var t = 1 / (this.m[0] * this.m[3] - this.m[1] * this.m[2]),
-                n = this.m[3] * t,
-                i = -this.m[1] * t,
-                r = -this.m[2] * t,
-                s = this.m[0] * t,
-                a = t * (this.m[2] * this.m[5] - this.m[3] * this.m[4]),
-                o = t * (this.m[1] * this.m[4] - this.m[0] * this.m[5]);
-            return this.m[0] = n, this.m[1] = i, this.m[2] = r, this.m[3] = s, this.m[4] = a, this.m[5] = o, this
+        return !0
+    }
+
+    function Yo(e) {
+        return e.indexOf("/") === -1 && e.indexOf("~") === -1 ? e : e.replace(/~/g, "~0").replace(/\//g, "~1")
+    }
+
+    function jO(e) {
+        return e.replace(/~1/g, "/").replace(/~0/g, "~")
+    }
+
+    function Lb(e) {
+        if (e === void 0) return !0;
+        if (e) {
+            if (Array.isArray(e)) {
+                for (var t = 0, n = e.length; t < n; t++)
+                    if (Lb(e[t])) return !0
+            } else if (typeof e == "object") {
+                for (var i = Nb(e), r = i.length, s = 0; s < r; s++)
+                    if (Lb(e[i[s]])) return !0
+            }
         }
-        getMatrix() {
-            return this.m
+        return !1
+    }
+
+    function nA(e, t) {
+        var n = [e];
+        for (var i in t) {
+            var r = typeof t[i] == "object" ? JSON.stringify(t[i], null, 2) : t[i];
+            typeof r < "u" && n.push(i + ": " + r)
         }
-        decompose() {
-            var t = this.m[0],
-                n = this.m[1],
-                i = this.m[2],
-                r = this.m[3],
-                s = this.m[4],
-                a = this.m[5],
-                o = t * r - n * i;
-            let l = {
-                x: s,
-                y: a,
-                rotation: 0,
-                scaleX: 0,
-                scaleY: 0,
-                skewX: 0,
-                skewY: 0
-            };
-            if (t != 0 || n != 0) {
-                var u = Math.sqrt(t * t + n * n);
-                l.rotation = n > 0 ? Math.acos(t / u) : -Math.acos(t / u), l.scaleX = u, l.scaleY = o / u, l.skewX = (t * i + n * r) / o, l.skewY = 0
-            } else if (i != 0 || r != 0) {
-                var c = Math.sqrt(i * i + r * r);
-                l.rotation = Math.PI / 2 - (r > 0 ? Math.acos(-i / c) : -Math.acos(i / c)), l.scaleX = o / c, l.scaleY = c, l.skewX = 0, l.skewY = (t * i + n * r) / o
+        return n.join(`
+`)
+    }
+    var GO = function(e) {
+            lB(t, e);
+
+            function t(n, i, r, s, a) {
+                var o = this.constructor,
+                    l = e.call(this, nA(n, {
+                        name: i,
+                        index: r,
+                        operation: s,
+                        tree: a
+                    })) || this;
+                return l.name = i, l.index = r, l.operation = s, l.tree = a, Object.setPrototypeOf(l, o.prototype), l.message = nA(n, {
+                    name: i,
+                    index: r,
+                    operation: s,
+                    tree: a
+                }), l
             }
-            return l.rotation = D._getRotation(l.rotation), l
-        }
-    };
-    var h9 = "[object Array]",
-        d9 = "[object Number]",
-        g9 = "[object String]",
-        p9 = "[object Boolean]",
-        m9 = Math.PI / 180,
-        y9 = 180 / Math.PI,
-        uy = "#",
-        v9 = "",
-        b9 = "0",
-        x9 = "Konva warning: ",
-        tk = "Konva error: ",
-        _9 = "rgb(",
-        cy = {
-            aliceblue: [240, 248, 255],
-            antiquewhite: [250, 235, 215],
-            aqua: [0, 255, 255],
-            aquamarine: [127, 255, 212],
-            azure: [240, 255, 255],
-            beige: [245, 245, 220],
-            bisque: [255, 228, 196],
-            black: [0, 0, 0],
-            blanchedalmond: [255, 235, 205],
-            blue: [0, 0, 255],
-            blueviolet: [138, 43, 226],
-            brown: [165, 42, 42],
-            burlywood: [222, 184, 135],
-            cadetblue: [95, 158, 160],
-            chartreuse: [127, 255, 0],
-            chocolate: [210, 105, 30],
-            coral: [255, 127, 80],
-            cornflowerblue: [100, 149, 237],
-            cornsilk: [255, 248, 220],
-            crimson: [220, 20, 60],
-            cyan: [0, 255, 255],
-            darkblue: [0, 0, 139],
-            darkcyan: [0, 139, 139],
-            darkgoldenrod: [184, 132, 11],
-            darkgray: [169, 169, 169],
-            darkgreen: [0, 100, 0],
-            darkgrey: [169, 169, 169],
-            darkkhaki: [189, 183, 107],
-            darkmagenta: [139, 0, 139],
-            darkolivegreen: [85, 107, 47],
-            darkorange: [255, 140, 0],
-            darkorchid: [153, 50, 204],
-            darkred: [139, 0, 0],
-            darksalmon: [233, 150, 122],
-            darkseagreen: [143, 188, 143],
-            darkslateblue: [72, 61, 139],
-            darkslategray: [47, 79, 79],
-            darkslategrey: [47, 79, 79],
-            darkturquoise: [0, 206, 209],
-            darkviolet: [148, 0, 211],
-            deeppink: [255, 20, 147],
-            deepskyblue: [0, 191, 255],
-            dimgray: [105, 105, 105],
-            dimgrey: [105, 105, 105],
-            dodgerblue: [30, 144, 255],
-            firebrick: [178, 34, 34],
-            floralwhite: [255, 255, 240],
-            forestgreen: [34, 139, 34],
-            fuchsia: [255, 0, 255],
-            gainsboro: [220, 220, 220],
-            ghostwhite: [248, 248, 255],
-            gold: [255, 215, 0],
-            goldenrod: [218, 165, 32],
-            gray: [128, 128, 128],
-            green: [0, 128, 0],
-            greenyellow: [173, 255, 47],
-            grey: [128, 128, 128],
-            honeydew: [240, 255, 240],
-            hotpink: [255, 105, 180],
-            indianred: [205, 92, 92],
-            indigo: [75, 0, 130],
-            ivory: [255, 255, 240],
-            khaki: [240, 230, 140],
-            lavender: [230, 230, 250],
-            lavenderblush: [255, 240, 245],
-            lawngreen: [124, 252, 0],
-            lemonchiffon: [255, 250, 205],
-            lightblue: [173, 216, 230],
-            lightcoral: [240, 128, 128],
-            lightcyan: [224, 255, 255],
-            lightgoldenrodyellow: [250, 250, 210],
-            lightgray: [211, 211, 211],
-            lightgreen: [144, 238, 144],
-            lightgrey: [211, 211, 211],
-            lightpink: [255, 182, 193],
-            lightsalmon: [255, 160, 122],
-            lightseagreen: [32, 178, 170],
-            lightskyblue: [135, 206, 250],
-            lightslategray: [119, 136, 153],
-            lightslategrey: [119, 136, 153],
-            lightsteelblue: [176, 196, 222],
-            lightyellow: [255, 255, 224],
-            lime: [0, 255, 0],
-            limegreen: [50, 205, 50],
-            linen: [250, 240, 230],
-            magenta: [255, 0, 255],
-            maroon: [128, 0, 0],
-            mediumaquamarine: [102, 205, 170],
-            mediumblue: [0, 0, 205],
-            mediumorchid: [186, 85, 211],
-            mediumpurple: [147, 112, 219],
-            mediumseagreen: [60, 179, 113],
-            mediumslateblue: [123, 104, 238],
-            mediumspringgreen: [0, 250, 154],
-            mediumturquoise: [72, 209, 204],
-            mediumvioletred: [199, 21, 133],
-            midnightblue: [25, 25, 112],
-            mintcream: [245, 255, 250],
-            mistyrose: [255, 228, 225],
-            moccasin: [255, 228, 181],
-            navajowhite: [255, 222, 173],
-            navy: [0, 0, 128],
-            oldlace: [253, 245, 230],
-            olive: [128, 128, 0],
-            olivedrab: [107, 142, 35],
-            orange: [255, 165, 0],
-            orangered: [255, 69, 0],
-            orchid: [218, 112, 214],
-            palegoldenrod: [238, 232, 170],
-            palegreen: [152, 251, 152],
-            paleturquoise: [175, 238, 238],
-            palevioletred: [219, 112, 147],
-            papayawhip: [255, 239, 213],
-            peachpuff: [255, 218, 185],
-            peru: [205, 133, 63],
-            pink: [255, 192, 203],
-            plum: [221, 160, 203],
-            powderblue: [176, 224, 230],
-            purple: [128, 0, 128],
-            rebeccapurple: [102, 51, 153],
-            red: [255, 0, 0],
-            rosybrown: [188, 143, 143],
-            royalblue: [65, 105, 225],
-            saddlebrown: [139, 69, 19],
-            salmon: [250, 128, 114],
-            sandybrown: [244, 164, 96],
-            seagreen: [46, 139, 87],
-            seashell: [255, 245, 238],
-            sienna: [160, 82, 45],
-            silver: [192, 192, 192],
-            skyblue: [135, 206, 235],
-            slateblue: [106, 90, 205],
-            slategray: [119, 128, 144],
-            slategrey: [119, 128, 144],
-            snow: [255, 255, 250],
-            springgreen: [0, 255, 127],
-            steelblue: [70, 130, 180],
-            tan: [210, 180, 140],
-            teal: [0, 128, 128],
-            thistle: [216, 191, 216],
-            transparent: [255, 255, 255, 0],
-            tomato: [255, 99, 71],
-            turquoise: [64, 224, 208],
-            violet: [238, 130, 238],
-            wheat: [245, 222, 179],
-            white: [255, 255, 255],
-            whitesmoke: [245, 245, 245],
-            yellow: [255, 255, 0],
-            yellowgreen: [154, 205, 5]
-        },
-        w9 = /rgb\((\d{1,3}),(\d{1,3}),(\d{1,3})\)/,
-        Ud = [];
-    const S9 = typeof requestAnimationFrame < "u" && requestAnimationFrame || function(e) {
-            setTimeout(e, 60)
-        },
-        D = {
-            _isElement(e) {
-                return !!(e && e.nodeType == 1)
-            },
-            _isFunction(e) {
-                return !!(e && e.constructor && e.call && e.apply)
-            },
-            _isPlainObject(e) {
-                return !!e && e.constructor === Object
-            },
-            _isArray(e) {
-                return Object.prototype.toString.call(e) === h9
-            },
-            _isNumber(e) {
-                return Object.prototype.toString.call(e) === d9 && !isNaN(e) && isFinite(e)
-            },
-            _isString(e) {
-                return Object.prototype.toString.call(e) === g9
-            },
-            _isBoolean(e) {
-                return Object.prototype.toString.call(e) === p9
-            },
-            isObject(e) {
-                return e instanceof Object
-            },
-            isValidSelector(e) {
-                if (typeof e != "string") return !1;
-                var t = e[0];
-                return t === "#" || t === "." || t === t.toUpperCase()
-            },
-            _sign(e) {
-                return e === 0 || e > 0 ? 1 : -1
-            },
-            requestAnimFrame(e) {
-                Ud.push(e), Ud.length === 1 && S9(function() {
-                    const t = Ud;
-                    Ud = [], t.forEach(function(n) {
-                        n()
-                    })
-                })
-            },
-            createCanvasElement() {
-                var e = document.createElement("canvas");
-                try {
-                    e.style = e.style || {}
-                } catch {}
-                return e
-            },
-            createImageElement() {
-                return document.createElement("img")
-            },
-            _isInDocument(e) {
-                for (; e = e.parentNode;)
-                    if (e == document) return !0;
-                return !1
-            },
-            _urlToImage(e, t) {
-                var n = D.createImageElement();
-                n.onload = function() {
-                    t(n)
-                }, n.src = e
-            },
-            _rgbToHex(e, t, n) {
-                return ((1 << 24) + (e << 16) + (t << 8) + n).toString(16).slice(1)
-            },
-            _hexToRgb(e) {
-                e = e.replace(uy, v9);
-                var t = parseInt(e, 16);
-                return {
-                    r: t >> 16 & 255,
-                    g: t >> 8 & 255,
-                    b: t & 255
+            return t
+        }(Error),
+        Rt = GO,
+        cB = Ai,
+        Nu = {
+            add: function(e, t, n) {
+                return e[t] = this.value, {
+                    newDocument: n
                 }
             },
-            getRandomColor() {
-                for (var e = (Math.random() * 16777215 << 0).toString(16); e.length < 6;) e = b9 + e;
-                return uy + e
-            },
-            getRGB(e) {
-                var t;
-                return e in cy ? (t = cy[e], {
-                    r: t[0],
-                    g: t[1],
-                    b: t[2]
-                }) : e[0] === uy ? this._hexToRgb(e.substring(1)) : e.substr(0, 4) === _9 ? (t = w9.exec(e.replace(/ /g, "")), {
-                    r: parseInt(t[1], 10),
-                    g: parseInt(t[2], 10),
-                    b: parseInt(t[3], 10)
-                }) : {
-                    r: 0,
-                    g: 0,
-                    b: 0
+            remove: function(e, t, n) {
+                var i = e[t];
+                return delete e[t], {
+                    newDocument: n,
+                    removed: i
                 }
             },
-            colorToRGBA(e) {
-                return e = e || "black", D._namedColorToRBA(e) || D._hex3ColorToRGBA(e) || D._hex4ColorToRGBA(e) || D._hex6ColorToRGBA(e) || D._hex8ColorToRGBA(e) || D._rgbColorToRGBA(e) || D._rgbaColorToRGBA(e) || D._hslColorToRGBA(e)
-            },
-            _namedColorToRBA(e) {
-                var t = cy[e.toLowerCase()];
-                return t ? {
-                    r: t[0],
-                    g: t[1],
-                    b: t[2],
-                    a: 1
-                } : null
-            },
-            _rgbColorToRGBA(e) {
-                if (e.indexOf("rgb(") === 0) {
-                    e = e.match(/rgb\(([^)]+)\)/)[1];
-                    var t = e.split(/ *, */).map(Number);
-                    return {
-                        r: t[0],
-                        g: t[1],
-                        b: t[2],
-                        a: 1
-                    }
+            replace: function(e, t, n) {
+                var i = e[t];
+                return e[t] = this.value, {
+                    newDocument: n,
+                    removed: i
                 }
             },
-            _rgbaColorToRGBA(e) {
-                if (e.indexOf("rgba(") === 0) {
-                    e = e.match(/rgba\(([^)]+)\)/)[1];
-                    var t = e.split(/ *, */).map((n, i) => n.slice(-1) === "%" ? i === 3 ? parseInt(n) / 100 : parseInt(n) / 100 * 255 : Number(n));
-                    return {
-                        r: t[0],
-                        g: t[1],
-                        b: t[2],
-                        a: t[3]
-                    }
+            move: function(e, t, n) {
+                var i = Qp(n, this.path);
+                i && (i = Ai(i));
+                var r = ul(n, {
+                    op: "remove",
+                    path: this.from
+                }).removed;
+                return ul(n, {
+                    op: "add",
+                    path: this.path,
+                    value: r
+                }), {
+                    newDocument: n,
+                    removed: i
                 }
             },
-            _hex8ColorToRGBA(e) {
-                if (e[0] === "#" && e.length === 9) return {
-                    r: parseInt(e.slice(1, 3), 16),
-                    g: parseInt(e.slice(3, 5), 16),
-                    b: parseInt(e.slice(5, 7), 16),
-                    a: parseInt(e.slice(7, 9), 16) / 255
+            copy: function(e, t, n) {
+                var i = Qp(n, this.from);
+                return ul(n, {
+                    op: "add",
+                    path: this.path,
+                    value: Ai(i)
+                }), {
+                    newDocument: n
                 }
             },
-            _hex6ColorToRGBA(e) {
-                if (e[0] === "#" && e.length === 7) return {
-                    r: parseInt(e.slice(1, 3), 16),
-                    g: parseInt(e.slice(3, 5), 16),
-                    b: parseInt(e.slice(5, 7), 16),
-                    a: 1
+            test: function(e, t, n) {
+                return {
+                    newDocument: n,
+                    test: Uh(e[t], this.value)
                 }
             },
-            _hex4ColorToRGBA(e) {
-                if (e[0] === "#" && e.length === 5) return {
-                    r: parseInt(e[1] + e[1], 16),
-                    g: parseInt(e[2] + e[2], 16),
-                    b: parseInt(e[3] + e[3], 16),
-                    a: parseInt(e[4] + e[4], 16) / 255
+            _get: function(e, t, n) {
+                return this.value = e[t], {
+                    newDocument: n
                 }
-            },
-            _hex3ColorToRGBA(e) {
-                if (e[0] === "#" && e.length === 4) return {
-                    r: parseInt(e[1] + e[1], 16),
-                    g: parseInt(e[2] + e[2], 16),
-                    b: parseInt(e[3] + e[3], 16),
-                    a: 1
+            }
+        },
+        fB = {
+            add: function(e, t, n) {
+                return Pb(t) ? e.splice(t, 0, this.value) : e[t] = this.value, {
+                    newDocument: n,
+                    index: t
                 }
             },
-            _hslColorToRGBA(e) {
-                if (/hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.test(e)) {
-                    const [t, ...n] = /hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.exec(e), i = Number(n[0]) / 360, r = Number(n[1]) / 100, s = Number(n[2]) / 100;
-                    let a, o, l;
-                    if (r === 0) return l = s * 255, {
-                        r: Math.round(l),
-                        g: Math.round(l),
-                        b: Math.round(l),
-                        a: 1
-                    };
-                    s < .5 ? a = s * (1 + r) : a = s + r - s * r;
-                    const u = 2 * s - a,
-                        c = [0, 0, 0];
-                    for (let f = 0; f < 3; f++) o = i + 1 / 3 * -(f - 1), o < 0 && o++, o > 1 && o--, 6 * o < 1 ? l = u + (a - u) * 6 * o : 2 * o < 1 ? l = a : 3 * o < 2 ? l = u + (a - u) * (2 / 3 - o) * 6 : l = u, c[f] = l * 255;
-                    return {
-                        r: Math.round(c[0]),
-                        g: Math.round(c[1]),
-                        b: Math.round(c[2]),
-                        a: 1
-                    }
+            remove: function(e, t, n) {
+                var i = e.splice(t, 1);
+                return {
+                    newDocument: n,
+                    removed: i[0]
                 }
             },
-            haveIntersection(e, t) {
-                return !(t.x > e.x + e.width || t.x + t.width < e.x || t.y > e.y + e.height || t.y + t.height < e.y)
-            },
-            cloneObject(e) {
-                var t = {};
-                for (var n in e) this._isPlainObject(e[n]) ? t[n] = this.cloneObject(e[n]) : this._isArray(e[n]) ? t[n] = this.cloneArray(e[n]) : t[n] = e[n];
-                return t
-            },
-            cloneArray(e) {
-                return e.slice(0)
-            },
-            degToRad(e) {
-                return e * m9
-            },
-            radToDeg(e) {
-                return e * y9
-            },
-            _degToRad(e) {
-                return D.warn("Util._degToRad is removed. Please use public Util.degToRad instead."), D.degToRad(e)
-            },
-            _radToDeg(e) {
-                return D.warn("Util._radToDeg is removed. Please use public Util.radToDeg instead."), D.radToDeg(e)
-            },
-            _getRotation(e) {
-                return le.angleDeg ? D.radToDeg(e) : e
-            },
-            _capitalize(e) {
-                return e.charAt(0).toUpperCase() + e.slice(1)
-            },
-            throw (e) {
-                throw new Error(tk + e)
-            },
-            error(e) {
-                console.error(tk + e)
-            },
-            warn(e) {
-                le.showWarnings && console.warn(x9 + e)
-            },
-            each(e, t) {
-                for (var n in e) t(n, e[n])
-            },
-            _inRange(e, t, n) {
-                return t <= e && e < n
-            },
-            _getProjectionToSegment(e, t, n, i, r, s) {
-                var a, o, l, u = (e - n) * (e - n) + (t - i) * (t - i);
-                if (u == 0) a = e, o = t, l = (r - n) * (r - n) + (s - i) * (s - i);
-                else {
-                    var c = ((r - e) * (n - e) + (s - t) * (i - t)) / u;
-                    c < 0 ? (a = e, o = t, l = (e - r) * (e - r) + (t - s) * (t - s)) : c > 1 ? (a = n, o = i, l = (n - r) * (n - r) + (i - s) * (i - s)) : (a = e + c * (n - e), o = t + c * (i - t), l = (a - r) * (a - r) + (o - s) * (o - s))
+            replace: function(e, t, n) {
+                var i = e[t];
+                return e[t] = this.value, {
+                    newDocument: n,
+                    removed: i
                 }
-                return [a, o, l]
             },
-            _getProjectionToLine(e, t, n) {
-                var i = D.cloneObject(e),
-                    r = Number.MAX_VALUE;
-                return t.forEach(function(s, a) {
-                    if (!(!n && a === t.length - 1)) {
-                        var o = t[(a + 1) % t.length],
-                            l = D._getProjectionToSegment(s.x, s.y, o.x, o.y, e.x, e.y),
-                            u = l[0],
-                            c = l[1],
-                            f = l[2];
-                        f < r && (i.x = u, i.y = c, r = f)
+            move: Nu.move,
+            copy: Nu.copy,
+            test: Nu.test,
+            _get: Nu._get
+        };
+
+    function Qp(e, t) {
+        if (t == "") return e;
+        var n = {
+            op: "_get",
+            path: t
+        };
+        return ul(e, n), n.value
+    }
+
+    function ul(e, t, n, i, r, s) {
+        if (n === void 0 && (n = !1), i === void 0 && (i = !0), r === void 0 && (r = !0), s === void 0 && (s = 0), n && (typeof n == "function" ? n(t, 0, e, t.path) : Zp(t, 0)), t.path === "") {
+            var a = {
+                newDocument: e
+            };
+            if (t.op === "add") return a.newDocument = t.value, a;
+            if (t.op === "replace") return a.newDocument = t.value, a.removed = e, a;
+            if (t.op === "move" || t.op === "copy") return a.newDocument = Qp(e, t.from), t.op === "move" && (a.removed = e), a;
+            if (t.op === "test") {
+                if (a.test = Uh(e, t.value), a.test === !1) throw new Rt("Test operation failed", "TEST_OPERATION_FAILED", s, t, e);
+                return a.newDocument = e, a
+            } else {
+                if (t.op === "remove") return a.removed = e, a.newDocument = null, a;
+                if (t.op === "_get") return t.value = e, a;
+                if (n) throw new Rt("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", s, t, e);
+                return a
+            }
+        } else {
+            i || (e = Ai(e));
+            var o = t.path || "",
+                l = o.split("/"),
+                u = e,
+                c = 1,
+                f = l.length,
+                h = void 0,
+                d = void 0,
+                g = void 0;
+            for (typeof n == "function" ? g = n : g = Zp;;) {
+                if (d = l[c], d && d.indexOf("~") != -1 && (d = jO(d)), r && (d == "__proto__" || d == "prototype" && c > 0 && l[c - 1] == "constructor")) throw new TypeError("JSON-Patch: modifying `__proto__` or `constructor/prototype` prop is banned for security reasons, if this was on purpose, please set `banPrototypeModifications` flag false and pass it to this function. More info in fast-json-patch README");
+                if (n && h === void 0 && (u[d] === void 0 ? h = l.slice(0, c).join("/") : c == f - 1 && (h = t.path), h !== void 0 && g(t, 0, e, h)), c++, Array.isArray(u)) {
+                    if (d === "-") d = u.length;
+                    else {
+                        if (n && !Pb(d)) throw new Rt("Expected an unsigned base-10 integer value, making the new referenced value the array element with the zero-based index", "OPERATION_PATH_ILLEGAL_ARRAY_INDEX", s, t, e);
+                        Pb(d) && (d = ~~d)
                     }
-                }), i
-            },
-            _prepareArrayForTween(e, t, n) {
-                var i, r = [],
-                    s = [];
-                if (e.length > t.length) {
-                    var a = t;
-                    t = e, e = a
+                    if (c >= f) {
+                        if (n && t.op === "add" && d > u.length) throw new Rt("The specified index MUST NOT be greater than the number of elements in the array", "OPERATION_VALUE_OUT_OF_BOUNDS", s, t, e);
+                        var a = fB[t.op].call(t, u, d, e);
+                        if (a.test === !1) throw new Rt("Test operation failed", "TEST_OPERATION_FAILED", s, t, e);
+                        return a
+                    }
+                } else if (c >= f) {
+                    var a = Nu[t.op].call(t, u, d, e);
+                    if (a.test === !1) throw new Rt("Test operation failed", "TEST_OPERATION_FAILED", s, t, e);
+                    return a
                 }
-                for (i = 0; i < e.length; i += 2) r.push({
-                    x: e[i],
-                    y: e[i + 1]
-                });
-                for (i = 0; i < t.length; i += 2) s.push({
-                    x: t[i],
-                    y: t[i + 1]
-                });
-                var o = [];
-                return s.forEach(function(l) {
-                    var u = D._getProjectionToLine(l, r, n);
-                    o.push(u.x), o.push(u.y)
-                }), o
-            },
-            _prepareToStringify(e) {
-                var t;
-                e.visitedByCircularReferenceRemoval = !0;
-                for (var n in e)
-                    if (e.hasOwnProperty(n) && e[n] && typeof e[n] == "object") {
-                        if (t = Object.getOwnPropertyDescriptor(e, n), e[n].visitedByCircularReferenceRemoval || D._isElement(e[n]))
-                            if (t.configurable) delete e[n];
-                            else return null;
-                        else if (D._prepareToStringify(e[n]) === null)
-                            if (t.configurable) delete e[n];
-                            else return null
-                    } return delete e.visitedByCircularReferenceRemoval, e
-            },
-            _assign(e, t) {
-                for (var n in t) e[n] = t[n];
-                return e
-            },
-            _getFirstPointerId(e) {
-                return e.touches ? e.changedTouches[0].identifier : e.pointerId || 999
-            },
-            releaseCanvas(...e) {
-                le.releaseCanvasOnDestroy && e.forEach(t => {
-                    t.width = 0, t.height = 0
-                })
-            },
-            drawRoundedRectPath(e, t, n, i) {
-                let r = 0,
-                    s = 0,
-                    a = 0,
-                    o = 0;
-                typeof i == "number" ? r = s = a = o = Math.min(i, t / 2, n / 2) : (r = Math.min(i[0] || 0, t / 2, n / 2), s = Math.min(i[1] || 0, t / 2, n / 2), o = Math.min(i[2] || 0, t / 2, n / 2), a = Math.min(i[3] || 0, t / 2, n / 2)), e.moveTo(r, 0), e.lineTo(t - s, 0), e.arc(t - s, s, s, Math.PI * 3 / 2, 0, !1), e.lineTo(t, n - o), e.arc(t - o, n - o, o, 0, Math.PI / 2, !1), e.lineTo(a, n), e.arc(a, n - a, a, Math.PI / 2, Math.PI, !1), e.lineTo(0, r), e.arc(r, r, r, Math.PI, Math.PI * 3 / 2, !1)
+                if (u = u[d], n && c < f && (!u || typeof u != "object")) throw new Rt("Cannot perform operation at the desired path", "OPERATION_PATH_UNRESOLVABLE", s, t, e)
             }
-        };
+        }
+    }
 
-    function Ha(e) {
-        return D._isString(e) ? '"' + e + '"' : Object.prototype.toString.call(e) === "[object Number]" || D._isBoolean(e) ? e : Object.prototype.toString.call(e)
+    function P0(e, t, n, i, r) {
+        if (i === void 0 && (i = !0), r === void 0 && (r = !0), n && !Array.isArray(t)) throw new Rt("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
+        i || (e = Ai(e));
+        for (var s = new Array(t.length), a = 0, o = t.length; a < o; a++) s[a] = ul(e, t[a], n, !0, r, a), e = s[a].newDocument;
+        return s.newDocument = e, s
     }
 
-    function AM(e) {
-        return e > 255 ? 255 : e < 0 ? 0 : Math.round(e)
+    function hB(e, t, n) {
+        var i = ul(e, t);
+        if (i.test === !1) throw new Rt("Test operation failed", "TEST_OPERATION_FAILED", n, t, e);
+        return i.newDocument
     }
 
-    function te() {
-        if (le.isUnminified) return function(e, t) {
-            return D._isNumber(e) || D.warn(Ha(e) + ' is a not valid value for "' + t + '" attribute. The value should be a number.'), e
-        }
+    function Zp(e, t, n, i) {
+        if (typeof e != "object" || e === null || Array.isArray(e)) throw new Rt("Operation is not an object", "OPERATION_NOT_AN_OBJECT", t, e, n);
+        if (Nu[e.op]) {
+            if (typeof e.path != "string") throw new Rt("Operation `path` property is not a string", "OPERATION_PATH_INVALID", t, e, n);
+            if (e.path.indexOf("/") !== 0 && e.path.length > 0) throw new Rt('Operation `path` property must start with "/"', "OPERATION_PATH_INVALID", t, e, n);
+            if ((e.op === "move" || e.op === "copy") && typeof e.from != "string") throw new Rt("Operation `from` property is not present (applicable in `move` and `copy` operations)", "OPERATION_FROM_REQUIRED", t, e, n);
+            if ((e.op === "add" || e.op === "replace" || e.op === "test") && e.value === void 0) throw new Rt("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_REQUIRED", t, e, n);
+            if ((e.op === "add" || e.op === "replace" || e.op === "test") && Lb(e.value)) throw new Rt("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_CANNOT_CONTAIN_UNDEFINED", t, e, n);
+            if (n) {
+                if (e.op == "add") {
+                    var r = e.path.split("/").length,
+                        s = i.split("/").length;
+                    if (r !== s + 1 && r !== s) throw new Rt("Cannot perform an `add` operation at the desired path", "OPERATION_PATH_CANNOT_ADD", t, e, n)
+                } else if (e.op === "replace" || e.op === "remove" || e.op === "_get") {
+                    if (e.path !== i) throw new Rt("Cannot perform the operation at a path that does not exist", "OPERATION_PATH_UNRESOLVABLE", t, e, n)
+                } else if (e.op === "move" || e.op === "copy") {
+                    var a = {
+                            op: "_get",
+                            path: e.from,
+                            value: void 0
+                        },
+                        o = UO([a], n);
+                    if (o && o.name === "OPERATION_PATH_UNRESOLVABLE") throw new Rt("Cannot perform the operation from a path that does not exist", "OPERATION_FROM_UNRESOLVABLE", t, e, n)
+                }
+            }
+        } else throw new Rt("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", t, e, n)
     }
 
-    function px(e) {
-        if (le.isUnminified) return function(t, n) {
-            let i = D._isNumber(t),
-                r = D._isArray(t) && t.length == e;
-            return !i && !r && D.warn(Ha(t) + ' is a not valid value for "' + n + '" attribute. The value should be a number or Array<number>(' + e + ")"), t
+    function UO(e, t, n) {
+        try {
+            if (!Array.isArray(e)) throw new Rt("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
+            if (t) P0(Ai(t), Ai(e), n || !0);
+            else {
+                n = n || Zp;
+                for (var i = 0; i < e.length; i++) n(e[i], i, t, void 0)
+            }
+        } catch (r) {
+            if (r instanceof Rt) return r;
+            throw r
         }
     }
 
-    function mx() {
-        if (le.isUnminified) return function(e, t) {
-            var n = D._isNumber(e),
-                i = e === "auto";
-            return n || i || D.warn(Ha(e) + ' is a not valid value for "' + t + '" attribute. The value should be a number or "auto".'), e
+    function Uh(e, t) {
+        if (e === t) return !0;
+        if (e && t && typeof e == "object" && typeof t == "object") {
+            var n = Array.isArray(e),
+                i = Array.isArray(t),
+                r, s, a;
+            if (n && i) {
+                if (s = e.length, s != t.length) return !1;
+                for (r = s; r-- !== 0;)
+                    if (!Uh(e[r], t[r])) return !1;
+                return !0
+            }
+            if (n != i) return !1;
+            var o = Object.keys(e);
+            if (s = o.length, s !== Object.keys(t).length) return !1;
+            for (r = s; r-- !== 0;)
+                if (!t.hasOwnProperty(o[r])) return !1;
+            for (r = s; r-- !== 0;)
+                if (a = o[r], !Uh(e[a], t[a])) return !1;
+            return !0
         }
+        return e !== e && t !== t
     }
+    const dB = Object.freeze(Object.defineProperty({
+        __proto__: null,
+        JsonPatchError: Rt,
+        _areEquals: Uh,
+        applyOperation: ul,
+        applyPatch: P0,
+        applyReducer: hB,
+        deepClone: cB,
+        getValueByPointer: Qp,
+        validate: UO,
+        validator: Zp
+    }, Symbol.toStringTag, {
+        value: "Module"
+    }));
+    /*!
+     * https://github.com/Starcounter-Jack/JSON-Patch
+     * (c) 2017-2021 Joachim Wester
+     * MIT license
+     */
+    var c_ = new WeakMap,
+        gB = function() {
+            function e(t) {
+                this.observers = new Map, this.obj = t
+            }
+            return e
+        }(),
+        pB = function() {
+            function e(t, n) {
+                this.callback = t, this.observer = n
+            }
+            return e
+        }();
 
-    function hc() {
-        if (le.isUnminified) return function(e, t) {
-            return D._isString(e) || D.warn(Ha(e) + ' is a not valid value for "' + t + '" attribute. The value should be a string.'), e
-        }
+    function mB(e) {
+        return c_.get(e)
     }
 
-    function $M() {
-        if (le.isUnminified) return function(e, t) {
-            const n = D._isString(e),
-                i = Object.prototype.toString.call(e) === "[object CanvasGradient]" || e && e.addColorStop;
-            return n || i || D.warn(Ha(e) + ' is a not valid value for "' + t + '" attribute. The value should be a string or a native gradient.'), e
-        }
+    function yB(e, t) {
+        return e.observers.get(t)
     }
 
-    function E9() {
-        if (le.isUnminified) return function(e, t) {
-            const n = Int8Array ? Object.getPrototypeOf(Int8Array) : null;
-            return n && e instanceof n || (D._isArray(e) ? e.forEach(function(i) {
-                D._isNumber(i) || D.warn('"' + t + '" attribute has non numeric element ' + i + ". Make sure that all elements are numbers.")
-            }) : D.warn(Ha(e) + ' is a not valid value for "' + t + '" attribute. The value should be a array of numbers.')), e
-        }
+    function vB(e, t) {
+        e.observers.delete(t.callback)
     }
 
-    function mr() {
-        if (le.isUnminified) return function(e, t) {
-            var n = e === !0 || e === !1;
-            return n || D.warn(Ha(e) + ' is a not valid value for "' + t + '" attribute. The value should be a boolean.'), e
-        }
+    function bB(e, t) {
+        t.unobserve()
     }
 
-    function C9(e) {
-        if (le.isUnminified) return function(t, n) {
-            return t == null || D.isObject(t) || D.warn(Ha(t) + ' is a not valid value for "' + n + '" attribute. The value should be an object with properties ' + e), t
+    function xB(e, t) {
+        var n = [],
+            i, r = mB(e);
+        if (!r) r = new gB(e), c_.set(e, r);
+        else {
+            var s = yB(r, t);
+            i = s && s.observer
+        }
+        if (i) return i;
+        if (i = {}, r.value = Ai(e), t) {
+            i.callback = t, i.next = null;
+            var a = function() {
+                    Ib(i)
+                },
+                o = function() {
+                    clearTimeout(i.next), i.next = setTimeout(a)
+                };
+            typeof window < "u" && (window.addEventListener("mouseup", o), window.addEventListener("keyup", o), window.addEventListener("mousedown", o), window.addEventListener("keydown", o), window.addEventListener("change", o))
         }
+        return i.patches = n, i.object = e, i.unobserve = function() {
+            Ib(i), clearTimeout(i.next), vB(r, i), typeof window < "u" && (window.removeEventListener("mouseup", o), window.removeEventListener("keyup", o), window.removeEventListener("mousedown", o), window.removeEventListener("keydown", o), window.removeEventListener("change", o))
+        }, r.observers.set(t, new pB(t, i)), i
     }
-    var Bc = "get",
-        jc = "set";
-    const O = {
-        addGetterSetter(e, t, n, i, r) {
-            O.addGetter(e, t, n), O.addSetter(e, t, i, r), O.addOverloadedGetterSetter(e, t)
-        },
-        addGetter(e, t, n) {
-            var i = Bc + D._capitalize(t);
-            e.prototype[i] = e.prototype[i] || function() {
-                var r = this.attrs[t];
-                return r === void 0 ? n : r
-            }
-        },
-        addSetter(e, t, n, i) {
-            var r = jc + D._capitalize(t);
-            e.prototype[r] || O.overWriteSetter(e, t, n, i)
-        },
-        overWriteSetter(e, t, n, i) {
-            var r = jc + D._capitalize(t);
-            e.prototype[r] = function(s) {
-                return n && s !== void 0 && s !== null && (s = n.call(this, s, t)), this._setAttr(t, s), i && i.call(this), this
-            }
-        },
-        addComponentsGetterSetter(e, t, n, i, r) {
-            var s = n.length,
-                a = D._capitalize,
-                o = Bc + a(t),
-                l = jc + a(t),
-                u, c;
-            e.prototype[o] = function() {
-                var h = {};
-                for (u = 0; u < s; u++) c = n[u], h[c] = this.getAttr(t + a(c));
-                return h
-            };
-            var f = C9(n);
-            e.prototype[l] = function(h) {
-                var d = this.attrs[t],
-                    g;
-                i && (h = i.call(this, h)), f && f.call(this, h, t);
-                for (g in h) h.hasOwnProperty(g) && this._setAttr(t + a(g), h[g]);
-                return h || n.forEach(p => {
-                    this._setAttr(t + a(p), void 0)
-                }), this._fireChangeEvent(t, d, h), r && r.call(this), this
-            }, O.addOverloadedGetterSetter(e, t)
-        },
-        addOverloadedGetterSetter(e, t) {
-            var n = D._capitalize(t),
-                i = jc + n,
-                r = Bc + n;
-            e.prototype[t] = function() {
-                return arguments.length ? (this[i](arguments[0]), this) : this[r]()
-            }
-        },
-        addDeprecatedGetterSetter(e, t, n, i) {
-            D.error("Adding deprecated " + t);
-            var r = Bc + D._capitalize(t),
-                s = t + " property is deprecated and will be removed soon. Look at Konva change log for more information.";
-            e.prototype[r] = function() {
-                D.error(s);
-                var a = this.attrs[t];
-                return a === void 0 ? n : a
-            }, O.addSetter(e, t, i, function() {
-                D.error(s)
-            }), O.addOverloadedGetterSetter(e, t)
-        },
-        backCompat(e, t) {
-            D.each(t, function(n, i) {
-                var r = e.prototype[i],
-                    s = Bc + D._capitalize(n),
-                    a = jc + D._capitalize(n);
 
-                function o() {
-                    r.apply(this, arguments), D.error('"' + n + '" method is deprecated and will be removed soon. Use ""' + i + '" instead.')
+    function Ib(e, t) {
+        t === void 0 && (t = !1);
+        var n = c_.get(e.object);
+        f_(n.value, e.object, e.patches, "", t), e.patches.length && P0(n.value, e.patches);
+        var i = e.patches;
+        return i.length > 0 && (e.patches = [], e.callback && e.callback(i)), i
+    }
+
+    function f_(e, t, n, i, r) {
+        if (t !== e) {
+            typeof t.toJSON == "function" && (t = t.toJSON());
+            for (var s = Nb(t), a = Nb(e), o = !1, l = a.length - 1; l >= 0; l--) {
+                var u = a[l],
+                    c = e[u];
+                if (Db(t, u) && !(t[u] === void 0 && c !== void 0 && Array.isArray(t) === !1)) {
+                    var f = t[u];
+                    typeof c == "object" && c != null && typeof f == "object" && f != null && Array.isArray(c) === Array.isArray(f) ? f_(c, f, n, i + "/" + Yo(u), r) : c !== f && (r && n.push({
+                        op: "test",
+                        path: i + "/" + Yo(u),
+                        value: Ai(c)
+                    }), n.push({
+                        op: "replace",
+                        path: i + "/" + Yo(u),
+                        value: Ai(f)
+                    }))
+                } else Array.isArray(e) === Array.isArray(t) ? (r && n.push({
+                    op: "test",
+                    path: i + "/" + Yo(u),
+                    value: Ai(c)
+                }), n.push({
+                    op: "remove",
+                    path: i + "/" + Yo(u)
+                }), o = !0) : (r && n.push({
+                    op: "test",
+                    path: i,
+                    value: e
+                }), n.push({
+                    op: "replace",
+                    path: i,
+                    value: t
+                }))
+            }
+            if (!(!o && s.length == a.length))
+                for (var l = 0; l < s.length; l++) {
+                    var u = s[l];
+                    !Db(e, u) && t[u] !== void 0 && n.push({
+                        op: "add",
+                        path: i + "/" + Yo(u),
+                        value: Ai(t[u])
+                    })
                 }
-                e.prototype[n] = o, e.prototype[s] = o, e.prototype[a] = o
-            })
-        },
-        afterSetFilter() {
-            this._filterUpToDate = !1
         }
-    };
+    }
 
-    function k9(e) {
-        var t = [],
-            n = e.length,
-            i = D,
-            r, s;
-        for (r = 0; r < n; r++) s = e[r], i._isNumber(s) ? s = Math.round(s * 1e3) / 1e3 : i._isString(s) || (s = s + ""), t.push(s);
-        return t
+    function _B(e, t, n) {
+        n === void 0 && (n = !1);
+        var i = [];
+        return f_(e, t, i, "", n), i
     }
-    var nk = ",",
-        A9 = "(",
-        $9 = ")",
-        T9 = "([",
-        M9 = "])",
-        O9 = ";",
-        F9 = "()",
-        R9 = "=",
-        ik = ["arc", "arcTo", "beginPath", "bezierCurveTo", "clearRect", "clip", "closePath", "createLinearGradient", "createPattern", "createRadialGradient", "drawImage", "ellipse", "fill", "fillText", "getImageData", "createImageData", "lineTo", "moveTo", "putImageData", "quadraticCurveTo", "rect", "restore", "rotate", "save", "scale", "setLineDash", "setTransform", "stroke", "strokeText", "transform", "translate"],
-        D9 = ["fillStyle", "strokeStyle", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY", "lineCap", "lineDashOffset", "lineJoin", "lineWidth", "miterLimit", "font", "textAlign", "textBaseline", "globalAlpha", "globalCompositeOperation", "imageSmoothingEnabled"];
-    const N9 = 100;
-    let em = class {
-        constructor(t) {
-            this.canvas = t, le.enableTrace && (this.traceArr = [], this._enableTrace())
-        }
-        fillShape(t) {
-            t.fillEnabled() && this._fill(t)
-        }
-        _fill(t) {}
-        strokeShape(t) {
-            t.hasStroke() && this._stroke(t)
-        }
-        _stroke(t) {}
-        fillStrokeShape(t) {
-            t.attrs.fillAfterStrokeEnabled ? (this.strokeShape(t), this.fillShape(t)) : (this.fillShape(t), this.strokeShape(t))
-        }
-        getTrace(t, n) {
-            var i = this.traceArr,
-                r = i.length,
-                s = "",
-                a, o, l, u;
-            for (a = 0; a < r; a++) o = i[a], l = o.method, l ? (u = o.args, s += l, t ? s += F9 : D._isArray(u[0]) ? s += T9 + u.join(nk) + M9 : (n && (u = u.map(c => typeof c == "number" ? Math.floor(c) : c)), s += A9 + u.join(nk) + $9)) : (s += o.property, t || (s += R9 + o.val)), s += O9;
-            return s
-        }
-        clearTrace() {
-            this.traceArr = []
-        }
-        _trace(t) {
-            var n = this.traceArr,
-                i;
-            n.push(t), i = n.length, i >= N9 && n.shift()
-        }
-        reset() {
-            var t = this.getCanvas().getPixelRatio();
-            this.setTransform(1 * t, 0, 0, 1 * t, 0, 0)
-        }
-        getCanvas() {
-            return this.canvas
-        }
-        clear(t) {
-            var n = this.getCanvas();
-            t ? this.clearRect(t.x || 0, t.y || 0, t.width || 0, t.height || 0) : this.clearRect(0, 0, n.getWidth() / n.pixelRatio, n.getHeight() / n.pixelRatio)
-        }
-        _applyLineCap(t) {
-            const n = t.attrs.lineCap;
-            n && this.setAttr("lineCap", n)
-        }
-        _applyOpacity(t) {
-            var n = t.getAbsoluteOpacity();
-            n !== 1 && this.setAttr("globalAlpha", n)
-        }
-        _applyLineJoin(t) {
-            const n = t.attrs.lineJoin;
-            n && this.setAttr("lineJoin", n)
-        }
-        setAttr(t, n) {
-            this._context[t] = n
-        }
-        arc(t, n, i, r, s, a) {
-            this._context.arc(t, n, i, r, s, a)
-        }
-        arcTo(t, n, i, r, s) {
-            this._context.arcTo(t, n, i, r, s)
-        }
-        beginPath() {
-            this._context.beginPath()
-        }
-        bezierCurveTo(t, n, i, r, s, a) {
-            this._context.bezierCurveTo(t, n, i, r, s, a)
-        }
-        clearRect(t, n, i, r) {
-            this._context.clearRect(t, n, i, r)
-        }
-        clip() {
-            this._context.clip()
-        }
-        closePath() {
-            this._context.closePath()
-        }
-        createImageData(t, n) {
-            var i = arguments;
-            if (i.length === 2) return this._context.createImageData(t, n);
-            if (i.length === 1) return this._context.createImageData(t)
-        }
-        createLinearGradient(t, n, i, r) {
-            return this._context.createLinearGradient(t, n, i, r)
-        }
-        createPattern(t, n) {
-            return this._context.createPattern(t, n)
-        }
-        createRadialGradient(t, n, i, r, s, a) {
-            return this._context.createRadialGradient(t, n, i, r, s, a)
-        }
-        drawImage(t, n, i, r, s, a, o, l, u) {
-            var c = arguments,
-                f = this._context;
-            c.length === 3 ? f.drawImage(t, n, i) : c.length === 5 ? f.drawImage(t, n, i, r, s) : c.length === 9 && f.drawImage(t, n, i, r, s, a, o, l, u)
-        }
-        ellipse(t, n, i, r, s, a, o, l) {
-            this._context.ellipse(t, n, i, r, s, a, o, l)
-        }
-        isPointInPath(t, n, i, r) {
-            return i ? this._context.isPointInPath(i, t, n, r) : this._context.isPointInPath(t, n, r)
-        }
-        fill(t) {
-            t ? this._context.fill(t) : this._context.fill()
-        }
-        fillRect(t, n, i, r) {
-            this._context.fillRect(t, n, i, r)
-        }
-        strokeRect(t, n, i, r) {
-            this._context.strokeRect(t, n, i, r)
-        }
-        fillText(t, n, i, r) {
-            r ? this._context.fillText(t, n, i, r) : this._context.fillText(t, n, i)
-        }
-        measureText(t) {
-            return this._context.measureText(t)
-        }
-        getImageData(t, n, i, r) {
-            return this._context.getImageData(t, n, i, r)
-        }
-        lineTo(t, n) {
-            this._context.lineTo(t, n)
-        }
-        moveTo(t, n) {
-            this._context.moveTo(t, n)
-        }
-        rect(t, n, i, r) {
-            this._context.rect(t, n, i, r)
-        }
-        putImageData(t, n, i) {
-            this._context.putImageData(t, n, i)
-        }
-        quadraticCurveTo(t, n, i, r) {
-            this._context.quadraticCurveTo(t, n, i, r)
-        }
-        restore() {
-            this._context.restore()
-        }
-        rotate(t) {
-            this._context.rotate(t)
-        }
-        save() {
-            this._context.save()
-        }
-        scale(t, n) {
-            this._context.scale(t, n)
-        }
-        setLineDash(t) {
-            this._context.setLineDash ? this._context.setLineDash(t) : "mozDash" in this._context ? this._context.mozDash = t : "webkitLineDash" in this._context && (this._context.webkitLineDash = t)
-        }
-        getLineDash() {
-            return this._context.getLineDash()
-        }
-        setTransform(t, n, i, r, s, a) {
-            this._context.setTransform(t, n, i, r, s, a)
-        }
-        stroke(t) {
-            t ? this._context.stroke(t) : this._context.stroke()
-        }
-        strokeText(t, n, i, r) {
-            this._context.strokeText(t, n, i, r)
-        }
-        transform(t, n, i, r, s, a) {
-            this._context.transform(t, n, i, r, s, a)
-        }
-        translate(t, n) {
-            this._context.translate(t, n)
-        }
-        _enableTrace() {
-            var t = this,
-                n = ik.length,
-                i = this.setAttr,
-                r, s, a = function(o) {
-                    var l = t[o],
-                        u;
-                    t[o] = function() {
-                        return s = k9(Array.prototype.slice.call(arguments, 0)), u = l.apply(t, arguments), t._trace({
-                            method: o,
-                            args: s
-                        }), u
+    const wB = Object.freeze(Object.defineProperty({
+        __proto__: null,
+        compare: _B,
+        generate: Ib,
+        observe: xB,
+        unobserve: bB
+    }, Symbol.toStringTag, {
+        value: "Module"
+    }));
+    Object.assign({}, dB, wB, {
+        JsonPatchError: GO,
+        deepClone: Ai,
+        escapePathComponent: Yo,
+        unescapePathComponent: jO
+    });
+
+    function Ed(e) {
+        return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e
+    }
+    var SB = /("(?:[^\\"]|\\.)*")|[:,]/g,
+        EB = function(t, n) {
+            var i, r, s;
+            return n = n || {}, i = JSON.stringify([1], void 0, n.indent === void 0 ? 2 : n.indent).slice(2, -3), r = i === "" ? 1 / 0 : n.maxLength === void 0 ? 80 : n.maxLength, s = n.replacer,
+                function a(o, l, u) {
+                    var c, f, h, d, g, p, m, y, v, b, x, _;
+                    if (o && typeof o.toJSON == "function" && (o = o.toJSON()), x = JSON.stringify(o, s), x === void 0) return x;
+                    if (m = r - l.length - u, x.length <= m && (v = x.replace(SB, function(S, w) {
+                            return w || S + " "
+                        }), v.length <= m)) return v;
+                    if (s != null && (o = JSON.parse(x), s = void 0), typeof o == "object" && o !== null) {
+                        if (y = l + i, h = [], f = 0, Array.isArray(o))
+                            for (b = "[", c = "]", m = o.length; f < m; f++) h.push(a(o[f], y, f === m - 1 ? 0 : 1) || "null");
+                        else
+                            for (b = "{", c = "}", p = Object.keys(o), m = p.length; f < m; f++) d = p[f], g = JSON.stringify(d) + ": ", _ = a(o[d], y, g.length + (f === m - 1 ? 0 : 1)), _ !== void 0 && h.push(g + _);
+                        if (h.length > 0) return [b, i + h.join(`,
+` + y), c].join(`
+` + l)
                     }
-                };
-            for (r = 0; r < n; r++) a(ik[r]);
-            t.setAttr = function() {
-                i.apply(t, arguments);
-                var o = arguments[0],
-                    l = arguments[1];
-                (o === "shadowOffsetX" || o === "shadowOffsetY" || o === "shadowBlur") && (l = l / this.canvas.getPixelRatio()), t._trace({
-                    property: o,
-                    val: l
-                })
+                    return x
+                }(t, "", 0)
+        };
+    const Yy = Ed(EB);
+
+    function vi(e, t, n) {
+        return e.fields = t || [], e.fname = n, e
+    }
+
+    function Pt(e) {
+        return e == null ? null : e.fname
+    }
+
+    function Fn(e) {
+        return e == null ? null : e.fields
+    }
+
+    function WO(e) {
+        return e.length === 1 ? kB(e[0]) : CB(e)
+    }
+    const kB = e => function(t) {
+            return t[e]
+        },
+        CB = e => {
+            const t = e.length;
+            return function(n) {
+                for (let i = 0; i < t; ++i) n = n[e[i]];
+                return n
             }
+        };
+
+    function q(e) {
+        throw Error(e)
+    }
+
+    function gs(e) {
+        const t = [],
+            n = e.length;
+        let i = null,
+            r = 0,
+            s = "",
+            a, o, l;
+        e = e + "";
+
+        function u() {
+            t.push(s + e.substring(a, o)), s = "", a = o + 1
         }
-        _applyGlobalCompositeOperation(t) {
-            const n = t.attrs.globalCompositeOperation;
-            var i = !n || n === "source-over";
-            i || this.setAttr("globalCompositeOperation", n)
+        for (a = o = 0; o < n; ++o)
+            if (l = e[o], l === "\\") s += e.substring(a, o++), a = o;
+            else if (l === i) u(), i = null, r = -1;
+        else {
+            if (i) continue;
+            a === r && l === '"' || a === r && l === "'" ? (a = o + 1, i = l) : l === "." && !r ? o > a ? u() : a = o + 1 : l === "[" ? (o > a && u(), r = a = o + 1) : l === "]" && (r || q("Access path missing open bracket: " + e), r > 0 && u(), r = 0, a = o + 1)
         }
-    };
-    D9.forEach(function(e) {
-        Object.defineProperty(em.prototype, e, {
-            get() {
-                return this._context[e]
+        return r && q("Access path missing closing bracket: " + e), i && q("Access path missing closing quote: " + e), o > a && (o++, u()), t
+    }
+
+    function fi(e, t, n) {
+        const i = gs(e);
+        return e = i.length === 1 ? i[0] : e, vi((n && n.get || WO)(i), [e], t || e)
+    }
+    const kd = fi("id"),
+        Pn = vi(e => e, [], "identity"),
+        Ma = vi(() => 0, [], "zero"),
+        Bc = vi(() => 1, [], "one"),
+        Yi = vi(() => !0, [], "true"),
+        _a = vi(() => !1, [], "false");
+
+    function AB(e, t, n) {
+        const i = [t].concat([].slice.call(n));
+        console[e].apply(console, i)
+    }
+    const qO = 0,
+        h_ = 1,
+        d_ = 2,
+        HO = 3,
+        YO = 4;
+
+    function g_(e, t) {
+        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : AB,
+            i = e || qO;
+        return {
+            level(r) {
+                return arguments.length ? (i = +r, this) : i
             },
-            set(t) {
-                this._context[e] = t
+            error() {
+                return i >= h_ && n(t || "error", "ERROR", arguments), this
+            },
+            warn() {
+                return i >= d_ && n(t || "warn", "WARN", arguments), this
+            },
+            info() {
+                return i >= HO && n(t || "log", "INFO", arguments), this
+            },
+            debug() {
+                return i >= YO && n(t || "log", "DEBUG", arguments), this
             }
-        })
-    });
-    class P9 extends em {
-        constructor(t) {
-            super(t), this._context = t._canvas.getContext("2d")
-        }
-        _fillColor(t) {
-            var n = t.fill();
-            this.setAttr("fillStyle", n), t._fillFunc(this)
         }
-        _fillPattern(t) {
-            this.setAttr("fillStyle", t._getFillPattern()), t._fillFunc(this)
+    }
+    var H = Array.isArray;
+
+    function ce(e) {
+        return e === Object(e)
+    }
+    const iA = e => e !== "__proto__";
+
+    function jc() {
+        for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
+        return t.reduce((i, r) => {
+            for (const s in r)
+                if (s === "signals") i.signals = $B(i.signals, r.signals);
+                else {
+                    const a = s === "legend" ? {
+                        layout: 1
+                    } : s === "style" ? !0 : null;
+                    Gc(i, s, r[s], a)
+                } return i
+        }, {})
+    }
+
+    function Gc(e, t, n, i) {
+        if (!iA(t)) return;
+        let r, s;
+        if (ce(n) && !H(n)) {
+            s = ce(e[t]) ? e[t] : e[t] = {};
+            for (r in n) i && (i === !0 || i[r]) ? Gc(s, r, n[r]) : iA(r) && (s[r] = n[r])
+        } else e[t] = n
+    }
+
+    function $B(e, t) {
+        if (e == null) return t;
+        const n = {},
+            i = [];
+
+        function r(s) {
+            n[s.name] || (n[s.name] = 1, i.push(s))
         }
-        _fillLinearGradient(t) {
-            var n = t._getLinearGradient();
-            n && (this.setAttr("fillStyle", n), t._fillFunc(this))
+        return t.forEach(r), e.forEach(r), i
+    }
+
+    function We(e) {
+        return e[e.length - 1]
+    }
+
+    function Tn(e) {
+        return e == null || e === "" ? null : +e
+    }
+    const XO = e => t => e * Math.exp(t),
+        VO = e => t => Math.log(e * t),
+        KO = e => t => Math.sign(t) * Math.log1p(Math.abs(t / e)),
+        JO = e => t => Math.sign(t) * Math.expm1(Math.abs(t)) * e,
+        em = e => t => t < 0 ? -Math.pow(-t, e) : Math.pow(t, e);
+
+    function L0(e, t, n, i) {
+        const r = n(e[0]),
+            s = n(We(e)),
+            a = (s - r) * t;
+        return [i(r - a), i(s - a)]
+    }
+
+    function QO(e, t) {
+        return L0(e, t, Tn, Pn)
+    }
+
+    function ZO(e, t) {
+        var n = Math.sign(e[0]);
+        return L0(e, t, VO(n), XO(n))
+    }
+
+    function eF(e, t, n) {
+        return L0(e, t, em(n), em(1 / n))
+    }
+
+    function tF(e, t, n) {
+        return L0(e, t, KO(n), JO(n))
+    }
+
+    function I0(e, t, n, i, r) {
+        const s = i(e[0]),
+            a = i(We(e)),
+            o = t != null ? i(t) : (s + a) / 2;
+        return [r(o + (s - o) * n), r(o + (a - o) * n)]
+    }
+
+    function p_(e, t, n) {
+        return I0(e, t, n, Tn, Pn)
+    }
+
+    function m_(e, t, n) {
+        const i = Math.sign(e[0]);
+        return I0(e, t, n, VO(i), XO(i))
+    }
+
+    function tm(e, t, n, i) {
+        return I0(e, t, n, em(i), em(1 / i))
+    }
+
+    function y_(e, t, n, i) {
+        return I0(e, t, n, KO(i), JO(i))
+    }
+
+    function nF(e) {
+        return 1 + ~~(new Date(e).getMonth() / 3)
+    }
+
+    function iF(e) {
+        return 1 + ~~(new Date(e).getUTCMonth() / 3)
+    }
+
+    function ue(e) {
+        return e != null ? H(e) ? e : [e] : []
+    }
+
+    function rF(e, t, n) {
+        let i = e[0],
+            r = e[1],
+            s;
+        return r < i && (s = r, r = i, i = s), s = r - i, s >= n - t ? [t, n] : [i = Math.min(Math.max(i, t), n - s), i + s]
+    }
+
+    function Pe(e) {
+        return typeof e == "function"
+    }
+    const TB = "descending";
+
+    function v_(e, t, n) {
+        n = n || {}, t = ue(t) || [];
+        const i = [],
+            r = [],
+            s = {},
+            a = n.comparator || MB;
+        return ue(e).forEach((o, l) => {
+            o != null && (i.push(t[l] === TB ? -1 : 1), r.push(o = Pe(o) ? o : fi(o, null, n)), (Fn(o) || []).forEach(u => s[u] = 1))
+        }), r.length === 0 ? null : vi(a(r, i), Object.keys(s))
+    }
+    const z0 = (e, t) => (e < t || e == null) && t != null ? -1 : (e > t || t == null) && e != null ? 1 : (t = t instanceof Date ? +t : t, (e = e instanceof Date ? +e : e) !== e && t === t ? -1 : t !== t && e === e ? 1 : 0),
+        MB = (e, t) => e.length === 1 ? OB(e[0], t[0]) : FB(e, t, e.length),
+        OB = (e, t) => function(n, i) {
+            return z0(e(n), e(i)) * t
+        },
+        FB = (e, t, n) => (t.push(0), function(i, r) {
+            let s, a = 0,
+                o = -1;
+            for (; a === 0 && ++o < n;) s = e[o], a = z0(s(i), s(r));
+            return a * t[o]
+        });
+
+    function Ln(e) {
+        return Pe(e) ? e : () => e
+    }
+
+    function b_(e, t) {
+        let n;
+        return i => {
+            n && clearTimeout(n), n = setTimeout(() => (t(i), n = null), e)
         }
-        _fillRadialGradient(t) {
-            const n = t._getRadialGradient();
-            n && (this.setAttr("fillStyle", n), t._fillFunc(this))
+    }
+
+    function Ne(e) {
+        for (let t, n, i = 1, r = arguments.length; i < r; ++i) {
+            t = arguments[i];
+            for (n in t) e[n] = t[n]
         }
-        _fill(t) {
-            const n = t.fill(),
-                i = t.getFillPriority();
-            if (n && i === "color") {
-                this._fillColor(t);
-                return
-            }
-            const r = t.getFillPatternImage();
-            if (r && i === "pattern") {
-                this._fillPattern(t);
-                return
-            }
-            const s = t.getFillLinearGradientColorStops();
-            if (s && i === "linear-gradient") {
-                this._fillLinearGradient(t);
-                return
-            }
-            const a = t.getFillRadialGradientColorStops();
-            if (a && i === "radial-gradient") {
-                this._fillRadialGradient(t);
-                return
-            }
-            n ? this._fillColor(t) : r ? this._fillPattern(t) : s ? this._fillLinearGradient(t) : a && this._fillRadialGradient(t)
+        return e
+    }
+
+    function ss(e, t) {
+        let n = 0,
+            i, r, s, a;
+        if (e && (i = e.length))
+            if (t == null) {
+                for (r = e[n]; n < i && (r == null || r !== r); r = e[++n]);
+                for (s = a = r; n < i; ++n) r = e[n], r != null && (r < s && (s = r), r > a && (a = r))
+            } else {
+                for (r = t(e[n]); n < i && (r == null || r !== r); r = t(e[++n]));
+                for (s = a = r; n < i; ++n) r = t(e[n]), r != null && (r < s && (s = r), r > a && (a = r))
+            } return [s, a]
+    }
+
+    function sF(e, t) {
+        const n = e.length;
+        let i = -1,
+            r, s, a, o, l;
+        if (t == null) {
+            for (; ++i < n;)
+                if (s = e[i], s != null && s >= s) {
+                    r = a = s;
+                    break
+                } if (i === n) return [-1, -1];
+            for (o = l = i; ++i < n;) s = e[i], s != null && (r > s && (r = s, o = i), a < s && (a = s, l = i))
+        } else {
+            for (; ++i < n;)
+                if (s = t(e[i], i, e), s != null && s >= s) {
+                    r = a = s;
+                    break
+                } if (i === n) return [-1, -1];
+            for (o = l = i; ++i < n;) s = t(e[i], i, e), s != null && (r > s && (r = s, o = i), a < s && (a = s, l = i))
         }
-        _strokeLinearGradient(t) {
-            const n = t.getStrokeLinearGradientStartPoint(),
-                i = t.getStrokeLinearGradientEndPoint(),
-                r = t.getStrokeLinearGradientColorStops(),
-                s = this.createLinearGradient(n.x, n.y, i.x, i.y);
-            if (r) {
-                for (var a = 0; a < r.length; a += 2) s.addColorStop(r[a], r[a + 1]);
-                this.setAttr("strokeStyle", s)
-            }
+        return [o, l]
+    }
+    const RB = Object.prototype.hasOwnProperty;
+
+    function Ce(e, t) {
+        return RB.call(e, t)
+    }
+    const bg = {};
+
+    function Uc(e) {
+        let t = {},
+            n;
+
+        function i(s) {
+            return Ce(t, s) && t[s] !== bg
         }
-        _stroke(t) {
-            var n = t.dash(),
-                i = t.getStrokeScaleEnabled();
-            if (t.hasStroke()) {
-                if (!i) {
-                    this.save();
-                    var r = this.getCanvas().getPixelRatio();
-                    this.setTransform(r, 0, 0, r, 0, 0)
+        const r = {
+            size: 0,
+            empty: 0,
+            object: t,
+            has: i,
+            get(s) {
+                return i(s) ? t[s] : void 0
+            },
+            set(s, a) {
+                return i(s) || (++r.size, t[s] === bg && --r.empty), t[s] = a, this
+            },
+            delete(s) {
+                return i(s) && (--r.size, ++r.empty, t[s] = bg), this
+            },
+            clear() {
+                r.size = r.empty = 0, r.object = t = {}
+            },
+            test(s) {
+                return arguments.length ? (n = s, r) : n
+            },
+            clean() {
+                const s = {};
+                let a = 0;
+                for (const o in t) {
+                    const l = t[o];
+                    l !== bg && (!n || !n(l)) && (s[o] = l, ++a)
                 }
-                this._applyLineCap(t), n && t.dashEnabled() && (this.setLineDash(n), this.setAttr("lineDashOffset", t.dashOffset())), this.setAttr("lineWidth", t.strokeWidth()), t.getShadowForStrokeEnabled() || this.setAttr("shadowColor", "rgba(0,0,0,0)");
-                var s = t.getStrokeLinearGradientColorStops();
-                s ? this._strokeLinearGradient(t) : this.setAttr("strokeStyle", t.stroke()), t._strokeFunc(this), i || this.restore()
+                r.size = a, r.empty = 0, r.object = t = s
             }
-        }
-        _applyShadow(t) {
-            var n, i, r, s = (n = t.getShadowRGBA()) !== null && n !== void 0 ? n : "black",
-                a = (i = t.getShadowBlur()) !== null && i !== void 0 ? i : 5,
-                o = (r = t.getShadowOffset()) !== null && r !== void 0 ? r : {
-                    x: 0,
-                    y: 0
-                },
-                l = t.getAbsoluteScale(),
-                u = this.canvas.getPixelRatio(),
-                c = l.x * u,
-                f = l.y * u;
-            this.setAttr("shadowColor", s), this.setAttr("shadowBlur", a * Math.min(Math.abs(c), Math.abs(f))), this.setAttr("shadowOffsetX", o.x * c), this.setAttr("shadowOffsetY", o.y * f)
-        }
+        };
+        return e && Object.keys(e).forEach(s => {
+            r.set(s, e[s])
+        }), r
     }
-    class L9 extends em {
-        constructor(t) {
-            super(t), this._context = t._canvas.getContext("2d", {
-                willReadFrequently: !0
-            })
-        }
-        _fill(t) {
-            this.save(), this.setAttr("fillStyle", t.colorKey), t._fillFuncHit(this), this.restore()
-        }
-        strokeShape(t) {
-            t.hasHitStroke() && this._stroke(t)
-        }
-        _stroke(t) {
-            if (t.hasHitStroke()) {
-                const s = t.getStrokeScaleEnabled();
-                if (!s) {
-                    this.save();
-                    var n = this.getCanvas().getPixelRatio();
-                    this.setTransform(n, 0, 0, n, 0, 0)
-                }
-                this._applyLineCap(t);
-                var i = t.hitStrokeWidth(),
-                    r = i === "auto" ? t.strokeWidth() : i;
-                this.setAttr("lineWidth", r), this.setAttr("strokeStyle", t.colorKey), t._strokeFuncHit(this), s || this.restore()
+
+    function aF(e, t, n, i, r, s) {
+        if (!n && n !== 0) return s;
+        const a = +n;
+        let o = e[0],
+            l = We(e),
+            u;
+        l < o && (u = o, o = l, l = u), u = Math.abs(t - o);
+        const c = Math.abs(l - t);
+        return u < c && u <= a ? i : c <= a ? r : s
+    }
+
+    function ne(e, t, n) {
+        const i = e.prototype = Object.create(t.prototype);
+        return Object.defineProperty(i, "constructor", {
+            value: e,
+            writable: !0,
+            enumerable: !0,
+            configurable: !0
+        }), Ne(i, n)
+    }
+
+    function Pu(e, t, n, i) {
+        let r = t[0],
+            s = t[t.length - 1],
+            a;
+        return r > s && (a = r, r = s, s = a), n = n === void 0 || n, i = i === void 0 || i, (n ? r <= e : r < e) && (i ? e <= s : e < s)
+    }
+
+    function mo(e) {
+        return typeof e == "boolean"
+    }
+
+    function Ua(e) {
+        return Object.prototype.toString.call(e) === "[object Date]"
+    }
+
+    function oF(e) {
+        return e && Pe(e[Symbol.iterator])
+    }
+
+    function lt(e) {
+        return typeof e == "number"
+    }
+
+    function lF(e) {
+        return Object.prototype.toString.call(e) === "[object RegExp]"
+    }
+
+    function le(e) {
+        return typeof e == "string"
+    }
+
+    function x_(e, t, n) {
+        e && (e = t ? ue(e).map(o => o.replace(/\\(.)/g, "$1")) : ue(e));
+        const i = e && e.length,
+            r = n && n.get || WO,
+            s = o => r(t ? [o] : gs(o));
+        let a;
+        if (!i) a = function() {
+            return ""
+        };
+        else if (i === 1) {
+            const o = s(e[0]);
+            a = function(l) {
+                return "" + o(l)
+            }
+        } else {
+            const o = e.map(s);
+            a = function(l) {
+                let u = "" + o[0](l),
+                    c = 0;
+                for (; ++c < i;) u += "|" + o[c](l);
+                return u
             }
         }
+        return vi(a, e, "key")
     }
-    var Gd;
 
-    function I9() {
-        if (Gd) return Gd;
-        var e = D.createCanvasElement(),
-            t = e.getContext("2d");
-        return Gd = function() {
-            var n = le._global.devicePixelRatio || 1,
-                i = t.webkitBackingStorePixelRatio || t.mozBackingStorePixelRatio || t.msBackingStorePixelRatio || t.oBackingStorePixelRatio || t.backingStorePixelRatio || 1;
-            return n / i
-        }(), D.releaseCanvas(e), Gd
+    function uF(e, t) {
+        const n = e[0],
+            i = We(e),
+            r = +t;
+        return r ? r === 1 ? i : n + r * (i - n) : n
     }
-    let tm = class {
-        constructor(t) {
-            this.pixelRatio = 1, this.width = 0, this.height = 0, this.isCache = !1;
-            var n = t || {},
-                i = n.pixelRatio || le.pixelRatio || I9();
-            this.pixelRatio = i, this._canvas = D.createCanvasElement(), this._canvas.style.padding = "0", this._canvas.style.margin = "0", this._canvas.style.border = "0", this._canvas.style.background = "transparent", this._canvas.style.position = "absolute", this._canvas.style.top = "0", this._canvas.style.left = "0"
-        }
-        getContext() {
-            return this.context
-        }
-        getPixelRatio() {
-            return this.pixelRatio
-        }
-        setPixelRatio(t) {
-            var n = this.pixelRatio;
-            this.pixelRatio = t, this.setSize(this.getWidth() / n, this.getHeight() / n)
-        }
-        setWidth(t) {
-            this.width = this._canvas.width = t * this.pixelRatio, this._canvas.style.width = t + "px";
-            var n = this.pixelRatio,
-                i = this.getContext()._context;
-            i.scale(n, n)
-        }
-        setHeight(t) {
-            this.height = this._canvas.height = t * this.pixelRatio, this._canvas.style.height = t + "px";
-            var n = this.pixelRatio,
-                i = this.getContext()._context;
-            i.scale(n, n)
-        }
-        getWidth() {
-            return this.width
-        }
-        getHeight() {
-            return this.height
-        }
-        setSize(t, n) {
-            this.setWidth(t || 0), this.setHeight(n || 0)
+    const DB = 1e4;
+
+    function cF(e) {
+        e = +e || DB;
+        let t, n, i;
+        const r = () => {
+                t = {}, n = {}, i = 0
+            },
+            s = (a, o) => (++i > e && (n = t, t = {}, i = 1), t[a] = o);
+        return r(), {
+            clear: r,
+            has: a => Ce(t, a) || Ce(n, a),
+            get: a => Ce(t, a) ? t[a] : Ce(n, a) ? s(a, n[a]) : void 0,
+            set: (a, o) => Ce(t, a) ? t[a] = o : s(a, o)
         }
-        toDataURL(t, n) {
-            try {
-                return this._canvas.toDataURL(t, n)
-            } catch {
-                try {
-                    return this._canvas.toDataURL()
-                } catch (r) {
-                    return D.error("Unable to get data URL. " + r.message + " For more info read https://konvajs.org/docs/posts/Tainted_Canvas.html."), ""
+    }
+
+    function fF(e, t, n, i) {
+        const r = t.length,
+            s = n.length;
+        if (!s) return t;
+        if (!r) return n;
+        const a = i || new t.constructor(r + s);
+        let o = 0,
+            l = 0,
+            u = 0;
+        for (; o < r && l < s; ++u) a[u] = e(t[o], n[l]) > 0 ? n[l++] : t[o++];
+        for (; o < r; ++o, ++u) a[u] = t[o];
+        for (; l < s; ++l, ++u) a[u] = n[l];
+        return a
+    }
+
+    function Xf(e, t) {
+        let n = "";
+        for (; --t >= 0;) n += e;
+        return n
+    }
+
+    function hF(e, t, n, i) {
+        const r = n || " ",
+            s = e + "",
+            a = t - s.length;
+        return a <= 0 ? s : i === "left" ? Xf(r, a) + s : i === "center" ? Xf(r, ~~(a / 2)) + s + Xf(r, Math.ceil(a / 2)) : s + Xf(r, a)
+    }
+
+    function Cd(e) {
+        return e && We(e) - e[0] || 0
+    }
+
+    function te(e) {
+        return H(e) ? "[" + e.map(te) + "]" : ce(e) || le(e) ? JSON.stringify(e).replace("\u2028", "\\u2028").replace("\u2029", "\\u2029") : e
+    }
+
+    function __(e) {
+        return e == null || e === "" ? null : !e || e === "false" || e === "0" ? !1 : !!e
+    }
+    const NB = e => lt(e) || Ua(e) ? e : Date.parse(e);
+
+    function w_(e, t) {
+        return t = t || NB, e == null || e === "" ? null : t(e)
+    }
+
+    function S_(e) {
+        return e == null || e === "" ? null : e + ""
+    }
+
+    function Cr(e) {
+        const t = {},
+            n = e.length;
+        for (let i = 0; i < n; ++i) t[e[i]] = !0;
+        return t
+    }
+
+    function dF(e, t, n, i) {
+        const r = i ?? "…",
+            s = e + "",
+            a = s.length,
+            o = Math.max(0, t - r.length);
+        return a <= t ? s : n === "left" ? r + s.slice(a - o) : n === "center" ? s.slice(0, Math.ceil(o / 2)) + r + s.slice(a - ~~(o / 2)) : s.slice(0, o) + r
+    }
+
+    function ka(e, t, n) {
+        if (e)
+            if (t) {
+                const i = e.length;
+                for (let r = 0; r < i; ++r) {
+                    const s = t(e[r]);
+                    s && n(s, r, e)
                 }
-            }
-        }
-    };
-    O.addGetterSetter(tm, "pixelRatio", void 0, te());
-    class vu extends tm {
-        constructor(t = {
-            width: 0,
-            height: 0
-        }) {
-            super(t), this.context = new P9(this), this.setSize(t.width, t.height)
-        }
+            } else e.forEach(n)
     }
-    class yx extends tm {
-        constructor(t = {
-            width: 0,
-            height: 0
-        }) {
-            super(t), this.hitCanvas = !0, this.context = new L9(this), this.setSize(t.width, t.height)
+    var rA = {},
+        Xy = {},
+        Vy = 34,
+        yf = 10,
+        Ky = 13;
+
+    function gF(e) {
+        return new Function("d", "return {" + e.map(function(t, n) {
+            return JSON.stringify(t) + ": d[" + n + '] || ""'
+        }).join(",") + "}")
+    }
+
+    function PB(e, t) {
+        var n = gF(e);
+        return function(i, r) {
+            return t(n(i), r, e)
         }
     }
-    const je = {
-        get isDragging() {
-            var e = !1;
-            return je._dragElements.forEach(t => {
-                t.dragStatus === "dragging" && (e = !0)
-            }), e
-        },
-        justDragged: !1,
-        get node() {
-            var e;
-            return je._dragElements.forEach(t => {
-                e = t.node
-            }), e
-        },
-        _dragElements: new Map,
-        _drag(e) {
-            const t = [];
-            je._dragElements.forEach((n, i) => {
-                const {
-                    node: r
-                } = n, s = r.getStage();
-                s.setPointersPositions(e), n.pointerId === void 0 && (n.pointerId = D._getFirstPointerId(e));
-                const a = s._changedPointerPositions.find(u => u.id === n.pointerId);
-                if (a) {
-                    if (n.dragStatus !== "dragging") {
-                        var o = r.dragDistance(),
-                            l = Math.max(Math.abs(a.x - n.startPointerPos.x), Math.abs(a.y - n.startPointerPos.y));
-                        if (l < o || (r.startDrag({
-                                evt: e
-                            }), !r.isDragging())) return
-                    }
-                    r._setDragPosition(e, n), t.push(r)
-                }
-            }), t.forEach(n => {
-                n.fire("dragmove", {
-                    type: "dragmove",
-                    target: n,
-                    evt: e
-                }, !0)
-            })
-        },
-        _endDragBefore(e) {
-            const t = [];
-            je._dragElements.forEach(n => {
-                const {
-                    node: i
-                } = n, r = i.getStage();
-                if (e && r.setPointersPositions(e), !r._changedPointerPositions.find(o => o.id === n.pointerId)) return;
-                (n.dragStatus === "dragging" || n.dragStatus === "stopped") && (je.justDragged = !0, le._mouseListenClick = !1, le._touchListenClick = !1, le._pointerListenClick = !1, n.dragStatus = "stopped");
-                const a = n.node.getLayer() || n.node instanceof le.Stage && n.node;
-                a && t.indexOf(a) === -1 && t.push(a)
-            }), t.forEach(n => {
-                n.draw()
-            })
-        },
-        _endDragAfter(e) {
-            je._dragElements.forEach((t, n) => {
-                t.dragStatus === "stopped" && t.node.fire("dragend", {
-                    type: "dragend",
-                    target: t.node,
-                    evt: e
-                }, !0), t.dragStatus !== "dragging" && je._dragElements.delete(n)
-            })
+
+    function sA(e) {
+        var t = Object.create(null),
+            n = [];
+        return e.forEach(function(i) {
+            for (var r in i) r in t || n.push(t[r] = r)
+        }), n
+    }
+
+    function ei(e, t) {
+        var n = e + "",
+            i = n.length;
+        return i < t ? new Array(t - i + 1).join(0) + n : n
+    }
+
+    function LB(e) {
+        return e < 0 ? "-" + ei(-e, 6) : e > 9999 ? "+" + ei(e, 6) : ei(e, 4)
+    }
+
+    function IB(e) {
+        var t = e.getUTCHours(),
+            n = e.getUTCMinutes(),
+            i = e.getUTCSeconds(),
+            r = e.getUTCMilliseconds();
+        return isNaN(e) ? "Invalid Date" : LB(e.getUTCFullYear()) + "-" + ei(e.getUTCMonth() + 1, 2) + "-" + ei(e.getUTCDate(), 2) + (r ? "T" + ei(t, 2) + ":" + ei(n, 2) + ":" + ei(i, 2) + "." + ei(r, 3) + "Z" : i ? "T" + ei(t, 2) + ":" + ei(n, 2) + ":" + ei(i, 2) + "Z" : n || t ? "T" + ei(t, 2) + ":" + ei(n, 2) + "Z" : "")
+    }
+
+    function zB(e) {
+        var t = new RegExp('["' + e + `
+\r]`),
+            n = e.charCodeAt(0);
+
+        function i(f, h) {
+            var d, g, p = r(f, function(m, y) {
+                if (d) return d(m, y - 1);
+                g = m, d = h ? PB(m, h) : gF(m)
+            });
+            return p.columns = g || [], p
         }
-    };
-    le.isBrowser && (window.addEventListener("mouseup", je._endDragBefore, !0), window.addEventListener("touchend", je._endDragBefore, !0), window.addEventListener("mousemove", je._drag), window.addEventListener("touchmove", je._drag), window.addEventListener("mouseup", je._endDragAfter, !1), window.addEventListener("touchend", je._endDragAfter, !1));
-    var Ug = "absoluteOpacity",
-        Wd = "allEventListeners",
-        ms = "absoluteTransform",
-        rk = "absoluteScale",
-        fo = "canvas",
-        z9 = "Change",
-        B9 = "children",
-        j9 = "konva",
-        Yv = "listening",
-        sk = "mouseenter",
-        ak = "mouseleave",
-        ok = "set",
-        lk = "Shape",
-        Gg = " ",
-        uk = "stage",
-        na = "transform",
-        U9 = "Stage",
-        Xv = "visible",
-        G9 = ["xChange.konva", "yChange.konva", "scaleXChange.konva", "scaleYChange.konva", "skewXChange.konva", "skewYChange.konva", "rotationChange.konva", "offsetXChange.konva", "offsetYChange.konva", "transformsEnabledChange.konva"].join(Gg);
-    let W9 = 1,
-        ne = class Vv {
-            constructor(t) {
-                this._id = W9++, this.eventListeners = {}, this.attrs = {}, this.index = 0, this._allEventListeners = null, this.parent = null, this._cache = new Map, this._attachedDepsListeners = new Map, this._lastPos = null, this._batchingTransformChange = !1, this._needClearTransformCache = !1, this._filterUpToDate = !1, this._isUnderCache = !1, this._dragEventId = null, this._shouldFireChangeEvents = !1, this.setAttrs(t), this._shouldFireChangeEvents = !0
-            }
-            hasChildren() {
-                return !1
-            }
-            _clearCache(t) {
-                (t === na || t === ms) && this._cache.get(t) ? this._cache.get(t).dirty = !0 : t ? this._cache.delete(t) : this._cache.clear()
-            }
-            _getCache(t, n) {
-                var i = this._cache.get(t),
-                    r = t === na || t === ms,
-                    s = i === void 0 || r && i.dirty === !0;
-                return s && (i = n.call(this), this._cache.set(t, i)), i
-            }
-            _calculate(t, n, i) {
-                if (!this._attachedDepsListeners.get(t)) {
-                    const r = n.map(s => s + "Change.konva").join(Gg);
-                    this.on(r, () => {
-                        this._clearCache(t)
-                    }), this._attachedDepsListeners.set(t, !0)
-                }
-                return this._getCache(t, i)
-            }
-            _getCanvasCache() {
-                return this._cache.get(fo)
-            }
-            _clearSelfAndDescendantCache(t) {
-                this._clearCache(t), t === ms && this.fire("absoluteTransformChange")
-            }
-            clearCache() {
-                if (this._cache.has(fo)) {
-                    const {
-                        scene: t,
-                        filter: n,
-                        hit: i
-                    } = this._cache.get(fo);
-                    D.releaseCanvas(t, n, i), this._cache.delete(fo)
-                }
-                return this._clearSelfAndDescendantCache(), this._requestDraw(), this
-            }
-            cache(t) {
-                var n = t || {},
-                    i = {};
-                (n.x === void 0 || n.y === void 0 || n.width === void 0 || n.height === void 0) && (i = this.getClientRect({
-                    skipTransform: !0,
-                    relativeTo: this.getParent()
-                }));
-                var r = Math.ceil(n.width || i.width),
-                    s = Math.ceil(n.height || i.height),
-                    a = n.pixelRatio,
-                    o = n.x === void 0 ? Math.floor(i.x) : n.x,
-                    l = n.y === void 0 ? Math.floor(i.y) : n.y,
-                    u = n.offset || 0,
-                    c = n.drawBorder || !1,
-                    f = n.hitCanvasPixelRatio || 1;
-                if (!r || !s) {
-                    D.error("Can not cache the node. Width or height of the node equals 0. Caching is skipped.");
-                    return
-                }
-                r += u * 2 + 1, s += u * 2 + 1, o -= u, l -= u;
-                var h = new vu({
-                        pixelRatio: a,
-                        width: r,
-                        height: s
-                    }),
-                    d = new vu({
-                        pixelRatio: a,
-                        width: 0,
-                        height: 0
-                    }),
-                    g = new yx({
-                        pixelRatio: f,
-                        width: r,
-                        height: s
-                    }),
-                    p = h.getContext(),
-                    m = g.getContext();
-                return g.isCache = !0, h.isCache = !0, this._cache.delete(fo), this._filterUpToDate = !1, n.imageSmoothingEnabled === !1 && (h.getContext()._context.imageSmoothingEnabled = !1, d.getContext()._context.imageSmoothingEnabled = !1), p.save(), m.save(), p.translate(-o, -l), m.translate(-o, -l), this._isUnderCache = !0, this._clearSelfAndDescendantCache(Ug), this._clearSelfAndDescendantCache(rk), this.drawScene(h, this), this.drawHit(g, this), this._isUnderCache = !1, p.restore(), m.restore(), c && (p.save(), p.beginPath(), p.rect(0, 0, r, s), p.closePath(), p.setAttr("strokeStyle", "red"), p.setAttr("lineWidth", 5), p.stroke(), p.restore()), this._cache.set(fo, {
-                    scene: h,
-                    filter: d,
-                    hit: g,
-                    x: o,
-                    y: l
-                }), this._requestDraw(), this
-            }
-            isCached() {
-                return this._cache.has(fo)
-            }
-            getClientRect(t) {
-                throw new Error('abstract "getClientRect" method call')
-            }
-            _transformedRect(t, n) {
-                var i = [{
-                        x: t.x,
-                        y: t.y
-                    }, {
-                        x: t.x + t.width,
-                        y: t.y
-                    }, {
-                        x: t.x + t.width,
-                        y: t.y + t.height
-                    }, {
-                        x: t.x,
-                        y: t.y + t.height
-                    }],
-                    r, s, a, o, l = this.getAbsoluteTransform(n);
-                return i.forEach(function(u) {
-                    var c = l.point(u);
-                    r === void 0 && (r = a = c.x, s = o = c.y), r = Math.min(r, c.x), s = Math.min(s, c.y), a = Math.max(a, c.x), o = Math.max(o, c.y)
-                }), {
-                    x: r,
-                    y: s,
-                    width: a - r,
-                    height: o - s
-                }
-            }
-            _drawCachedSceneCanvas(t) {
-                t.save(), t._applyOpacity(this), t._applyGlobalCompositeOperation(this);
-                const n = this._getCanvasCache();
-                t.translate(n.x, n.y);
-                var i = this._getCachedSceneCanvas(),
-                    r = i.pixelRatio;
-                t.drawImage(i._canvas, 0, 0, i.width / r, i.height / r), t.restore()
-            }
-            _drawCachedHitCanvas(t) {
-                var n = this._getCanvasCache(),
-                    i = n.hit;
-                t.save(), t.translate(n.x, n.y), t.drawImage(i._canvas, 0, 0, i.width / i.pixelRatio, i.height / i.pixelRatio), t.restore()
-            }
-            _getCachedSceneCanvas() {
-                var t = this.filters(),
-                    n = this._getCanvasCache(),
-                    i = n.scene,
-                    r = n.filter,
-                    s = r.getContext(),
-                    a, o, l, u;
-                if (t) {
-                    if (!this._filterUpToDate) {
-                        var c = i.pixelRatio;
-                        r.setSize(i.width / i.pixelRatio, i.height / i.pixelRatio);
-                        try {
-                            for (a = t.length, s.clear(), s.drawImage(i._canvas, 0, 0, i.getWidth() / c, i.getHeight() / c), o = s.getImageData(0, 0, r.getWidth(), r.getHeight()), l = 0; l < a; l++) {
-                                if (u = t[l], typeof u != "function") {
-                                    D.error("Filter should be type of function, but got " + typeof u + " instead. Please check correct filters");
-                                    continue
-                                }
-                                u.call(this, o), s.putImageData(o, 0, 0)
-                            }
-                        } catch (f) {
-                            D.error("Unable to apply filter. " + f.message + " This post my help you https://konvajs.org/docs/posts/Tainted_Canvas.html.")
-                        }
-                        this._filterUpToDate = !0
-                    }
-                    return r
-                }
-                return i
-            }
-            on(t, n) {
-                if (this._cache && this._cache.delete(Wd), arguments.length === 3) return this._delegate.apply(this, arguments);
-                var i = t.split(Gg),
-                    r = i.length,
-                    s, a, o, l, u;
-                for (s = 0; s < r; s++) a = i[s], o = a.split("."), l = o[0], u = o[1] || "", this.eventListeners[l] || (this.eventListeners[l] = []), this.eventListeners[l].push({
-                    name: u,
-                    handler: n
-                });
-                return this
-            }
-            off(t, n) {
-                var i = (t || "").split(Gg),
-                    r = i.length,
-                    s, a, o, l, u, c;
-                if (this._cache && this._cache.delete(Wd), !t)
-                    for (a in this.eventListeners) this._off(a);
-                for (s = 0; s < r; s++)
-                    if (o = i[s], l = o.split("."), u = l[0], c = l[1], u) this.eventListeners[u] && this._off(u, c, n);
-                    else
-                        for (a in this.eventListeners) this._off(a, c, n);
-                return this
-            }
-            dispatchEvent(t) {
-                var n = {
-                    target: this,
-                    type: t.type,
-                    evt: t
-                };
-                return this.fire(t.type, n), this
-            }
-            addEventListener(t, n) {
-                return this.on(t, function(i) {
-                    n.call(this, i.evt)
-                }), this
-            }
-            removeEventListener(t) {
-                return this.off(t), this
-            }
-            _delegate(t, n, i) {
-                var r = this;
-                this.on(t, function(s) {
-                    for (var a = s.target.findAncestors(n, !0, r), o = 0; o < a.length; o++) s = D.cloneObject(s), s.currentTarget = a[o], i.call(a[o], s)
-                })
-            }
-            remove() {
-                return this.isDragging() && this.stopDrag(), je._dragElements.delete(this._id), this._remove(), this
-            }
-            _clearCaches() {
-                this._clearSelfAndDescendantCache(ms), this._clearSelfAndDescendantCache(Ug), this._clearSelfAndDescendantCache(rk), this._clearSelfAndDescendantCache(uk), this._clearSelfAndDescendantCache(Xv), this._clearSelfAndDescendantCache(Yv)
-            }
-            _remove() {
-                this._clearCaches();
-                var t = this.getParent();
-                t && t.children && (t.children.splice(this.index, 1), t._setChildrenIndices(), this.parent = null)
-            }
-            destroy() {
-                return this.remove(), this.clearCache(), this
-            }
-            getAttr(t) {
-                var n = "get" + D._capitalize(t);
-                return D._isFunction(this[n]) ? this[n]() : this.attrs[t]
-            }
-            getAncestors() {
-                for (var t = this.getParent(), n = []; t;) n.push(t), t = t.getParent();
-                return n
-            }
-            getAttrs() {
-                return this.attrs || {}
-            }
-            setAttrs(t) {
-                return this._batchTransformChanges(() => {
-                    var n, i;
-                    if (!t) return this;
-                    for (n in t) n !== B9 && (i = ok + D._capitalize(n), D._isFunction(this[i]) ? this[i](t[n]) : this._setAttr(n, t[n]))
-                }), this
-            }
-            isListening() {
-                return this._getCache(Yv, this._isListening)
-            }
-            _isListening(t) {
-                if (!this.listening()) return !1;
-                const i = this.getParent();
-                return i && i !== t && this !== t ? i._isListening(t) : !0
-            }
-            isVisible() {
-                return this._getCache(Xv, this._isVisible)
-            }
-            _isVisible(t) {
-                if (!this.visible()) return !1;
-                const i = this.getParent();
-                return i && i !== t && this !== t ? i._isVisible(t) : !0
-            }
-            shouldDrawHit(t, n = !1) {
-                if (t) return this._isVisible(t) && this._isListening(t);
-                var i = this.getLayer(),
-                    r = !1;
-                je._dragElements.forEach(a => {
-                    a.dragStatus === "dragging" && (a.node.nodeType === "Stage" || a.node.getLayer() === i) && (r = !0)
-                });
-                var s = !n && !le.hitOnDragEnabled && r;
-                return this.isListening() && this.isVisible() && !s
-            }
-            show() {
-                return this.visible(!0), this
-            }
-            hide() {
-                return this.visible(!1), this
-            }
-            getZIndex() {
-                return this.index || 0
-            }
-            getAbsoluteZIndex() {
-                var t = this.getDepth(),
-                    n = this,
-                    i = 0,
-                    r, s, a, o;
 
-                function l(u) {
-                    for (r = [], s = u.length, a = 0; a < s; a++) o = u[a], i++, o.nodeType !== lk && (r = r.concat(o.getChildren().slice())), o._id === n._id && (a = s);
-                    r.length > 0 && r[0].getDepth() <= t && l(r)
-                }
-                return n.nodeType !== U9 && l(n.getStage().getChildren()), i
-            }
-            getDepth() {
-                for (var t = 0, n = this.parent; n;) t++, n = n.parent;
-                return t
-            }
-            _batchTransformChanges(t) {
-                this._batchingTransformChange = !0, t(), this._batchingTransformChange = !1, this._needClearTransformCache && (this._clearCache(na), this._clearSelfAndDescendantCache(ms)), this._needClearTransformCache = !1
-            }
-            setPosition(t) {
-                return this._batchTransformChanges(() => {
-                    this.x(t.x), this.y(t.y)
-                }), this
-            }
-            getPosition() {
-                return {
-                    x: this.x(),
-                    y: this.y()
-                }
-            }
-            getRelativePointerPosition() {
-                if (!this.getStage()) return null;
-                var t = this.getStage().getPointerPosition();
-                if (!t) return null;
-                var n = this.getAbsoluteTransform().copy();
-                return n.invert(), n.point(t)
-            }
-            getAbsolutePosition(t) {
-                let n = !1,
-                    i = this.parent;
-                for (; i;) {
-                    if (i.isCached()) {
-                        n = !0;
-                        break
-                    }
-                    i = i.parent
-                }
-                n && !t && (t = !0);
-                var r = this.getAbsoluteTransform(t).getMatrix(),
-                    s = new Ki,
-                    a = this.offset();
-                return s.m = r.slice(), s.translate(a.x, a.y), s.getTranslation()
-            }
-            setAbsolutePosition(t) {
-                var n = this._clearTransform();
-                this.attrs.x = n.x, this.attrs.y = n.y, delete n.x, delete n.y, this._clearCache(na);
-                var i = this._getAbsoluteTransform().copy();
-                return i.invert(), i.translate(t.x, t.y), t = {
-                    x: this.attrs.x + i.getTranslation().x,
-                    y: this.attrs.y + i.getTranslation().y
-                }, this._setTransform(n), this.setPosition({
-                    x: t.x,
-                    y: t.y
-                }), this._clearCache(na), this._clearSelfAndDescendantCache(ms), this
-            }
-            _setTransform(t) {
-                var n;
-                for (n in t) this.attrs[n] = t[n]
-            }
-            _clearTransform() {
-                var t = {
-                    x: this.x(),
-                    y: this.y(),
-                    rotation: this.rotation(),
-                    scaleX: this.scaleX(),
-                    scaleY: this.scaleY(),
-                    offsetX: this.offsetX(),
-                    offsetY: this.offsetY(),
-                    skewX: this.skewX(),
-                    skewY: this.skewY()
-                };
-                return this.attrs.x = 0, this.attrs.y = 0, this.attrs.rotation = 0, this.attrs.scaleX = 1, this.attrs.scaleY = 1, this.attrs.offsetX = 0, this.attrs.offsetY = 0, this.attrs.skewX = 0, this.attrs.skewY = 0, t
-            }
-            move(t) {
-                var n = t.x,
-                    i = t.y,
-                    r = this.x(),
-                    s = this.y();
-                return n !== void 0 && (r += n), i !== void 0 && (s += i), this.setPosition({
-                    x: r,
-                    y: s
-                }), this
-            }
-            _eachAncestorReverse(t, n) {
-                var i = [],
-                    r = this.getParent(),
-                    s, a;
-                if (!(n && n._id === this._id)) {
-                    for (i.unshift(this); r && (!n || r._id !== n._id);) i.unshift(r), r = r.parent;
-                    for (s = i.length, a = 0; a < s; a++) t(i[a])
-                }
-            }
-            rotate(t) {
-                return this.rotation(this.rotation() + t), this
-            }
-            moveToTop() {
-                if (!this.parent) return D.warn("Node has no parent. moveToTop function is ignored."), !1;
-                var t = this.index,
-                    n = this.parent.getChildren().length;
-                return t < n - 1 ? (this.parent.children.splice(t, 1), this.parent.children.push(this), this.parent._setChildrenIndices(), !0) : !1
-            }
-            moveUp() {
-                if (!this.parent) return D.warn("Node has no parent. moveUp function is ignored."), !1;
-                var t = this.index,
-                    n = this.parent.getChildren().length;
-                return t < n - 1 ? (this.parent.children.splice(t, 1), this.parent.children.splice(t + 1, 0, this), this.parent._setChildrenIndices(), !0) : !1
-            }
-            moveDown() {
-                if (!this.parent) return D.warn("Node has no parent. moveDown function is ignored."), !1;
-                var t = this.index;
-                return t > 0 ? (this.parent.children.splice(t, 1), this.parent.children.splice(t - 1, 0, this), this.parent._setChildrenIndices(), !0) : !1
-            }
-            moveToBottom() {
-                if (!this.parent) return D.warn("Node has no parent. moveToBottom function is ignored."), !1;
-                var t = this.index;
-                return t > 0 ? (this.parent.children.splice(t, 1), this.parent.children.unshift(this), this.parent._setChildrenIndices(), !0) : !1
-            }
-            setZIndex(t) {
-                if (!this.parent) return D.warn("Node has no parent. zIndex parameter is ignored."), this;
-                (t < 0 || t >= this.parent.children.length) && D.warn("Unexpected value " + t + " for zIndex property. zIndex is just index of a node in children of its parent. Expected value is from 0 to " + (this.parent.children.length - 1) + ".");
-                var n = this.index;
-                return this.parent.children.splice(n, 1), this.parent.children.splice(t, 0, this), this.parent._setChildrenIndices(), this
-            }
-            getAbsoluteOpacity() {
-                return this._getCache(Ug, this._getAbsoluteOpacity)
-            }
-            _getAbsoluteOpacity() {
-                var t = this.opacity(),
-                    n = this.getParent();
-                return n && !n._isUnderCache && (t *= n.getAbsoluteOpacity()), t
-            }
-            moveTo(t) {
-                return this.getParent() !== t && (this._remove(), t.add(this)), this
-            }
-            toObject() {
-                var t = {},
-                    n = this.getAttrs(),
-                    i, r, s, a, o;
-                t.attrs = {};
-                for (i in n) r = n[i], o = D.isObject(r) && !D._isPlainObject(r) && !D._isArray(r), !o && (s = typeof this[i] == "function" && this[i], delete n[i], a = s ? s.call(this) : null, n[i] = r, a !== r && (t.attrs[i] = r));
-                return t.className = this.getClassName(), D._prepareToStringify(t)
-            }
-            toJSON() {
-                return JSON.stringify(this.toObject())
-            }
-            getParent() {
-                return this.parent
-            }
-            findAncestors(t, n, i) {
-                var r = [];
-                n && this._isMatch(t) && r.push(this);
-                for (var s = this.parent; s;) {
-                    if (s === i) return r;
-                    s._isMatch(t) && r.push(s), s = s.parent
-                }
-                return r
-            }
-            isAncestorOf(t) {
-                return !1
-            }
-            findAncestor(t, n, i) {
-                return this.findAncestors(t, n, i)[0]
-            }
-            _isMatch(t) {
-                if (!t) return !1;
-                if (typeof t == "function") return t(this);
-                var n = t.replace(/ /g, "").split(","),
-                    i = n.length,
-                    r, s;
-                for (r = 0; r < i; r++)
-                    if (s = n[r], D.isValidSelector(s) || (D.warn('Selector "' + s + '" is invalid. Allowed selectors examples are "#foo", ".bar" or "Group".'), D.warn('If you have a custom shape with such className, please change it to start with upper letter like "Triangle".'), D.warn("Konva is awesome, right?")), s.charAt(0) === "#") {
-                        if (this.id() === s.slice(1)) return !0
-                    } else if (s.charAt(0) === ".") {
-                    if (this.hasName(s.slice(1))) return !0
-                } else if (this.className === s || this.nodeType === s) return !0;
-                return !1
-            }
-            getLayer() {
-                var t = this.getParent();
-                return t ? t.getLayer() : null
-            }
-            getStage() {
-                return this._getCache(uk, this._getStage)
-            }
-            _getStage() {
-                var t = this.getParent();
-                if (t) return t.getStage()
-            }
-            fire(t, n = {}, i) {
-                return n.target = n.target || this, i ? this._fireAndBubble(t, n) : this._fire(t, n), this
-            }
-            getAbsoluteTransform(t) {
-                return t ? this._getAbsoluteTransform(t) : this._getCache(ms, this._getAbsoluteTransform)
-            }
-            _getAbsoluteTransform(t) {
-                var n;
-                if (t) return n = new Ki, this._eachAncestorReverse(function(r) {
-                    var s = r.transformsEnabled();
-                    s === "all" ? n.multiply(r.getTransform()) : s === "position" && n.translate(r.x() - r.offsetX(), r.y() - r.offsetY())
-                }, t), n;
-                n = this._cache.get(ms) || new Ki, this.parent ? this.parent.getAbsoluteTransform().copyInto(n) : n.reset();
-                var i = this.transformsEnabled();
-                if (i === "all") n.multiply(this.getTransform());
-                else if (i === "position") {
-                    const r = this.attrs.x || 0,
-                        s = this.attrs.y || 0,
-                        a = this.attrs.offsetX || 0,
-                        o = this.attrs.offsetY || 0;
-                    n.translate(r - a, s - o)
-                }
-                return n.dirty = !1, n
-            }
-            getAbsoluteScale(t) {
-                for (var n = this; n;) n._isUnderCache && (t = n), n = n.getParent();
-                const r = this.getAbsoluteTransform(t).decompose();
-                return {
-                    x: r.scaleX,
-                    y: r.scaleY
-                }
-            }
-            getAbsoluteRotation() {
-                return this.getAbsoluteTransform().decompose().rotation
-            }
-            getTransform() {
-                return this._getCache(na, this._getTransform)
-            }
-            _getTransform() {
-                var t, n, i = this._cache.get(na) || new Ki;
-                i.reset();
-                var r = this.x(),
-                    s = this.y(),
-                    a = le.getAngle(this.rotation()),
-                    o = (t = this.attrs.scaleX) !== null && t !== void 0 ? t : 1,
-                    l = (n = this.attrs.scaleY) !== null && n !== void 0 ? n : 1,
-                    u = this.attrs.skewX || 0,
-                    c = this.attrs.skewY || 0,
-                    f = this.attrs.offsetX || 0,
-                    h = this.attrs.offsetY || 0;
-                return (r !== 0 || s !== 0) && i.translate(r, s), a !== 0 && i.rotate(a), (u !== 0 || c !== 0) && i.skew(u, c), (o !== 1 || l !== 1) && i.scale(o, l), (f !== 0 || h !== 0) && i.translate(-1 * f, -1 * h), i.dirty = !1, i
-            }
-            clone(t) {
-                var n = D.cloneObject(this.attrs),
-                    i, r, s, a, o;
-                for (i in t) n[i] = t[i];
-                var l = new this.constructor(n);
-                for (i in this.eventListeners)
-                    for (r = this.eventListeners[i], s = r.length, a = 0; a < s; a++) o = r[a], o.name.indexOf(j9) < 0 && (l.eventListeners[i] || (l.eventListeners[i] = []), l.eventListeners[i].push(o));
-                return l
-            }
-            _toKonvaCanvas(t) {
-                t = t || {};
-                var n = this.getClientRect(),
-                    i = this.getStage(),
-                    r = t.x !== void 0 ? t.x : Math.floor(n.x),
-                    s = t.y !== void 0 ? t.y : Math.floor(n.y),
-                    a = t.pixelRatio || 1,
-                    o = new vu({
-                        width: t.width || Math.ceil(n.width) || (i ? i.width() : 0),
-                        height: t.height || Math.ceil(n.height) || (i ? i.height() : 0),
-                        pixelRatio: a
-                    }),
-                    l = o.getContext();
-                return t.imageSmoothingEnabled === !1 && (l._context.imageSmoothingEnabled = !1), l.save(), (r || s) && l.translate(-1 * r, -1 * s), this.drawScene(o), l.restore(), o
-            }
-            toCanvas(t) {
-                return this._toKonvaCanvas(t)._canvas
-            }
-            toDataURL(t) {
-                t = t || {};
-                var n = t.mimeType || null,
-                    i = t.quality || null,
-                    r = this._toKonvaCanvas(t).toDataURL(n, i);
-                return t.callback && t.callback(r), r
-            }
-            toImage(t) {
-                return new Promise((n, i) => {
-                    try {
-                        const r = t == null ? void 0 : t.callback;
-                        r && delete t.callback, D._urlToImage(this.toDataURL(t), function(s) {
-                            n(s), r == null || r(s)
-                        })
-                    } catch (r) {
-                        i(r)
-                    }
-                })
-            }
-            toBlob(t) {
-                return new Promise((n, i) => {
-                    try {
-                        const r = t == null ? void 0 : t.callback;
-                        r && delete t.callback, this.toCanvas(t).toBlob(s => {
-                            n(s), r == null || r(s)
-                        })
-                    } catch (r) {
-                        i(r)
-                    }
-                })
-            }
-            setSize(t) {
-                return this.width(t.width), this.height(t.height), this
-            }
-            getSize() {
-                return {
-                    width: this.width(),
-                    height: this.height()
-                }
-            }
-            getClassName() {
-                return this.className || this.nodeType
-            }
-            getType() {
-                return this.nodeType
-            }
-            getDragDistance() {
-                return this.attrs.dragDistance !== void 0 ? this.attrs.dragDistance : this.parent ? this.parent.getDragDistance() : le.dragDistance
-            }
-            _off(t, n, i) {
-                var r = this.eventListeners[t],
-                    s, a, o;
-                for (s = 0; s < r.length; s++)
-                    if (a = r[s].name, o = r[s].handler, (a !== "konva" || n === "konva") && (!n || a === n) && (!i || i === o)) {
-                        if (r.splice(s, 1), r.length === 0) {
-                            delete this.eventListeners[t];
-                            break
-                        }
-                        s--
-                    }
-            }
-            _fireChangeEvent(t, n, i) {
-                this._fire(t + z9, {
-                    oldVal: n,
-                    newVal: i
-                })
-            }
-            addName(t) {
-                if (!this.hasName(t)) {
-                    var n = this.name(),
-                        i = n ? n + " " + t : t;
-                    this.name(i)
-                }
-                return this
-            }
-            hasName(t) {
-                if (!t) return !1;
-                const n = this.name();
-                if (!n) return !1;
-                var i = (n || "").split(/\s/g);
-                return i.indexOf(t) !== -1
-            }
-            removeName(t) {
-                var n = (this.name() || "").split(/\s/g),
-                    i = n.indexOf(t);
-                return i !== -1 && (n.splice(i, 1), this.name(n.join(" "))), this
-            }
-            setAttr(t, n) {
-                var i = this[ok + D._capitalize(t)];
-                return D._isFunction(i) ? i.call(this, n) : this._setAttr(t, n), this
-            }
-            _requestDraw() {
-                if (le.autoDrawEnabled) {
-                    const t = this.getLayer() || this.getStage();
-                    t == null || t.batchDraw()
-                }
-            }
-            _setAttr(t, n) {
-                var i = this.attrs[t];
-                i === n && !D.isObject(n) || (n == null ? delete this.attrs[t] : this.attrs[t] = n, this._shouldFireChangeEvents && this._fireChangeEvent(t, i, n), this._requestDraw())
-            }
-            _setComponentAttr(t, n, i) {
-                var r;
-                i !== void 0 && (r = this.attrs[t], r || (this.attrs[t] = this.getAttr(t)), this.attrs[t][n] = i, this._fireChangeEvent(t, r, i))
-            }
-            _fireAndBubble(t, n, i) {
-                n && this.nodeType === lk && (n.target = this);
-                var r = (t === sk || t === ak) && (i && (this === i || this.isAncestorOf && this.isAncestorOf(i)) || this.nodeType === "Stage" && !i);
-                if (!r) {
-                    this._fire(t, n);
-                    var s = (t === sk || t === ak) && i && i.isAncestorOf && i.isAncestorOf(this) && !i.isAncestorOf(this.parent);
-                    (n && !n.cancelBubble || !n) && this.parent && this.parent.isListening() && !s && (i && i.parent ? this._fireAndBubble.call(this.parent, t, n, i) : this._fireAndBubble.call(this.parent, t, n))
-                }
-            }
-            _getProtoListeners(t) {
-                let n = this._cache.get(Wd);
-                if (!n) {
-                    n = {};
-                    let r = Object.getPrototypeOf(this);
-                    for (; r;) {
-                        if (!r.eventListeners) {
-                            r = Object.getPrototypeOf(r);
-                            continue
-                        }
-                        for (var i in r.eventListeners) {
-                            const s = r.eventListeners[i],
-                                a = n[i] || [];
-                            n[i] = s.concat(a)
-                        }
-                        r = Object.getPrototypeOf(r)
-                    }
-                    this._cache.set(Wd, n)
-                }
-                return n[t]
-            }
-            _fire(t, n) {
-                n = n || {}, n.currentTarget = this, n.type = t;
-                const i = this._getProtoListeners(t);
-                if (i)
-                    for (var r = 0; r < i.length; r++) i[r].handler.call(this, n);
-                const s = this.eventListeners[t];
-                if (s)
-                    for (var r = 0; r < s.length; r++) s[r].handler.call(this, n)
-            }
-            draw() {
-                return this.drawScene(), this.drawHit(), this
-            }
-            _createDragElement(t) {
-                var n = t ? t.pointerId : void 0,
-                    i = this.getStage(),
-                    r = this.getAbsolutePosition(),
-                    s = i._getPointerById(n) || i._changedPointerPositions[0] || r;
-                je._dragElements.set(this._id, {
-                    node: this,
-                    startPointerPos: s,
-                    offset: {
-                        x: s.x - r.x,
-                        y: s.y - r.y
-                    },
-                    dragStatus: "ready",
-                    pointerId: n
-                })
-            }
-            startDrag(t, n = !0) {
-                je._dragElements.has(this._id) || this._createDragElement(t);
-                const i = je._dragElements.get(this._id);
-                i.dragStatus = "dragging", this.fire("dragstart", {
-                    type: "dragstart",
-                    target: this,
-                    evt: t && t.evt
-                }, n)
-            }
-            _setDragPosition(t, n) {
-                const i = this.getStage()._getPointerById(n.pointerId);
-                if (i) {
-                    var r = {
-                            x: i.x - n.offset.x,
-                            y: i.y - n.offset.y
-                        },
-                        s = this.dragBoundFunc();
-                    if (s !== void 0) {
-                        const a = s.call(this, r, t);
-                        a ? r = a : D.warn("dragBoundFunc did not return any value. That is unexpected behavior. You must return new absolute position from dragBoundFunc.")
-                    }(!this._lastPos || this._lastPos.x !== r.x || this._lastPos.y !== r.y) && (this.setAbsolutePosition(r), this._requestDraw()), this._lastPos = r
+        function r(f, h) {
+            var d = [],
+                g = f.length,
+                p = 0,
+                m = 0,
+                y, v = g <= 0,
+                b = !1;
+            f.charCodeAt(g - 1) === yf && --g, f.charCodeAt(g - 1) === Ky && --g;
+
+            function x() {
+                if (v) return Xy;
+                if (b) return b = !1, rA;
+                var S, w = p,
+                    E;
+                if (f.charCodeAt(w) === Vy) {
+                    for (; p++ < g && f.charCodeAt(p) !== Vy || f.charCodeAt(++p) === Vy;);
+                    return (S = p) >= g ? v = !0 : (E = f.charCodeAt(p++)) === yf ? b = !0 : E === Ky && (b = !0, f.charCodeAt(p) === yf && ++p), f.slice(w + 1, S - 1).replace(/""/g, '"')
                 }
-            }
-            stopDrag(t) {
-                const n = je._dragElements.get(this._id);
-                n && (n.dragStatus = "stopped"), je._endDragBefore(t), je._endDragAfter(t)
-            }
-            setDraggable(t) {
-                this._setAttr("draggable", t), this._dragChange()
-            }
-            isDragging() {
-                const t = je._dragElements.get(this._id);
-                return t ? t.dragStatus === "dragging" : !1
-            }
-            _listenDrag() {
-                this._dragCleanup(), this.on("mousedown.konva touchstart.konva", function(t) {
-                    var n = t.evt.button !== void 0,
-                        i = !n || le.dragButtons.indexOf(t.evt.button) >= 0;
-                    if (i && !this.isDragging()) {
-                        var r = !1;
-                        je._dragElements.forEach(s => {
-                            this.isAncestorOf(s.node) && (r = !0)
-                        }), r || this._createDragElement(t)
-                    }
-                })
-            }
-            _dragChange() {
-                if (this.attrs.draggable) this._listenDrag();
-                else {
-                    this._dragCleanup();
-                    var t = this.getStage();
-                    if (!t) return;
-                    const n = je._dragElements.get(this._id),
-                        i = n && n.dragStatus === "dragging",
-                        r = n && n.dragStatus === "ready";
-                    i ? this.stopDrag() : r && je._dragElements.delete(this._id)
+                for (; p < g;) {
+                    if ((E = f.charCodeAt(S = p++)) === yf) b = !0;
+                    else if (E === Ky) b = !0, f.charCodeAt(p) === yf && ++p;
+                    else if (E !== n) continue;
+                    return f.slice(w, S)
                 }
+                return v = !0, f.slice(w, g)
             }
-            _dragCleanup() {
-                this.off("mousedown.konva"), this.off("touchstart.konva")
-            }
-            isClientRectOnScreen(t = {
-                x: 0,
-                y: 0
-            }) {
-                const n = this.getStage();
-                if (!n) return !1;
-                const i = {
-                    x: -t.x,
-                    y: -t.y,
-                    width: n.width() + 2 * t.x,
-                    height: n.height() + 2 * t.y
-                };
-                return D.haveIntersection(i, this.getClientRect())
-            }
-            static create(t, n) {
-                return D._isString(t) && (t = JSON.parse(t)), this._createNode(t, n)
-            }
-            static _createNode(t, n) {
-                var i = Vv.prototype.getClassName.call(t),
-                    r = t.children,
-                    s, a, o;
-                n && (t.attrs.container = n), le[i] || (D.warn('Can not find a node with class name "' + i + '". Fallback to "Shape".'), i = "Shape");
-                const l = le[i];
-                if (s = new l(t.attrs), r)
-                    for (a = r.length, o = 0; o < a; o++) s.add(Vv._createNode(r[o]));
-                return s
-            }
-        };
-    ne.prototype.nodeType = "Node";
-    ne.prototype._attrsAffectingSize = [];
-    ne.prototype.eventListeners = {};
-    ne.prototype.on.call(ne.prototype, G9, function() {
-        if (this._batchingTransformChange) {
-            this._needClearTransformCache = !0;
-            return
-        }
-        this._clearCache(na), this._clearSelfAndDescendantCache(ms)
-    });
-    ne.prototype.on.call(ne.prototype, "visibleChange.konva", function() {
-        this._clearSelfAndDescendantCache(Xv)
-    });
-    ne.prototype.on.call(ne.prototype, "listeningChange.konva", function() {
-        this._clearSelfAndDescendantCache(Yv)
-    });
-    ne.prototype.on.call(ne.prototype, "opacityChange.konva", function() {
-        this._clearSelfAndDescendantCache(Ug)
-    });
-    const rt = O.addGetterSetter;
-    rt(ne, "zIndex");
-    rt(ne, "absolutePosition");
-    rt(ne, "position");
-    rt(ne, "x", 0, te());
-    rt(ne, "y", 0, te());
-    rt(ne, "globalCompositeOperation", "source-over", hc());
-    rt(ne, "opacity", 1, te());
-    rt(ne, "name", "", hc());
-    rt(ne, "id", "", hc());
-    rt(ne, "rotation", 0, te());
-    O.addComponentsGetterSetter(ne, "scale", ["x", "y"]);
-    rt(ne, "scaleX", 1, te());
-    rt(ne, "scaleY", 1, te());
-    O.addComponentsGetterSetter(ne, "skew", ["x", "y"]);
-    rt(ne, "skewX", 0, te());
-    rt(ne, "skewY", 0, te());
-    O.addComponentsGetterSetter(ne, "offset", ["x", "y"]);
-    rt(ne, "offsetX", 0, te());
-    rt(ne, "offsetY", 0, te());
-    rt(ne, "dragDistance", null, te());
-    rt(ne, "width", 0, te());
-    rt(ne, "height", 0, te());
-    rt(ne, "listening", !0, mr());
-    rt(ne, "preventDefault", !0, mr());
-    rt(ne, "filters", null, function(e) {
-        return this._filterUpToDate = !1, e
-    });
-    rt(ne, "visible", !0, mr());
-    rt(ne, "transformsEnabled", "all", hc());
-    rt(ne, "size");
-    rt(ne, "dragBoundFunc");
-    rt(ne, "draggable", !1, mr());
-    O.backCompat(ne, {
-        rotateDeg: "rotate",
-        setRotationDeg: "setRotation",
-        getRotationDeg: "getRotation"
-    });
-    class mi extends ne {
-        constructor() {
-            super(...arguments), this.children = []
-        }
-        getChildren(t) {
-            if (!t) return this.children || [];
-            const n = this.children || [];
-            var i = [];
-            return n.forEach(function(r) {
-                t(r) && i.push(r)
-            }), i
-        }
-        hasChildren() {
-            return this.getChildren().length > 0
-        }
-        removeChildren() {
-            return this.getChildren().forEach(t => {
-                t.parent = null, t.index = 0, t.remove()
-            }), this.children = [], this._requestDraw(), this
-        }
-        destroyChildren() {
-            return this.getChildren().forEach(t => {
-                t.parent = null, t.index = 0, t.destroy()
-            }), this.children = [], this._requestDraw(), this
-        }
-        add(...t) {
-            if (t.length === 0) return this;
-            if (t.length > 1) {
-                for (var n = 0; n < t.length; n++) this.add(t[n]);
-                return this
-            }
-            const i = t[0];
-            return i.getParent() ? (i.moveTo(this), this) : (this._validateAdd(i), i.index = this.getChildren().length, i.parent = this, i._clearCaches(), this.getChildren().push(i), this._fire("add", {
-                child: i
-            }), this._requestDraw(), this)
-        }
-        destroy() {
-            return this.hasChildren() && this.destroyChildren(), super.destroy(), this
-        }
-        find(t) {
-            return this._generalFind(t, !1)
-        }
-        findOne(t) {
-            var n = this._generalFind(t, !0);
-            return n.length > 0 ? n[0] : void 0
-        }
-        _generalFind(t, n) {
-            var i = [];
-            return this._descendants(r => {
-                const s = r._isMatch(t);
-                return s && i.push(r), !!(s && n)
-            }), i
-        }
-        _descendants(t) {
-            let n = !1;
-            const i = this.getChildren();
-            for (const r of i) {
-                if (n = t(r), n) return !0;
-                if (r.hasChildren() && (n = r._descendants(t), n)) return !0
-            }
-            return !1
-        }
-        toObject() {
-            var t = ne.prototype.toObject.call(this);
-            return t.children = [], this.getChildren().forEach(n => {
-                t.children.push(n.toObject())
-            }), t
-        }
-        isAncestorOf(t) {
-            for (var n = t.getParent(); n;) {
-                if (n._id === this._id) return !0;
-                n = n.getParent()
+            for (;
+                (y = x()) !== Xy;) {
+                for (var _ = []; y !== rA && y !== Xy;) _.push(y), y = x();
+                h && (_ = h(_, m++)) == null || d.push(_)
             }
-            return !1
-        }
-        clone(t) {
-            var n = ne.prototype.clone.call(this, t);
-            return this.getChildren().forEach(function(i) {
-                n.add(i.clone())
-            }), n
+            return d
         }
-        getAllIntersections(t) {
-            var n = [];
-            return this.find("Shape").forEach(function(i) {
-                i.isVisible() && i.intersects(t) && n.push(i)
-            }), n
+
+        function s(f, h) {
+            return f.map(function(d) {
+                return h.map(function(g) {
+                    return c(d[g])
+                }).join(e)
+            })
         }
-        _clearSelfAndDescendantCache(t) {
-            var n;
-            super._clearSelfAndDescendantCache(t), !this.isCached() && ((n = this.children) === null || n === void 0 || n.forEach(function(i) {
-                i._clearSelfAndDescendantCache(t)
-            }))
+
+        function a(f, h) {
+            return h == null && (h = sA(f)), [h.map(c).join(e)].concat(s(f, h)).join(`
+`)
         }
-        _setChildrenIndices() {
-            var t;
-            (t = this.children) === null || t === void 0 || t.forEach(function(n, i) {
-                n.index = i
-            }), this._requestDraw()
+
+        function o(f, h) {
+            return h == null && (h = sA(f)), s(f, h).join(`
+`)
         }
-        drawScene(t, n) {
-            var i = this.getLayer(),
-                r = t || i && i.getCanvas(),
-                s = r && r.getContext(),
-                a = this._getCanvasCache(),
-                o = a && a.scene,
-                l = r && r.isCache;
-            if (!this.isVisible() && !l) return this;
-            if (o) {
-                s.save();
-                var u = this.getAbsoluteTransform(n).getMatrix();
-                s.transform(u[0], u[1], u[2], u[3], u[4], u[5]), this._drawCachedSceneCanvas(s), s.restore()
-            } else this._drawChildren("drawScene", r, n);
-            return this
+
+        function l(f) {
+            return f.map(u).join(`
+`)
         }
-        drawHit(t, n) {
-            if (!this.shouldDrawHit(n)) return this;
-            var i = this.getLayer(),
-                r = t || i && i.hitCanvas,
-                s = r && r.getContext(),
-                a = this._getCanvasCache(),
-                o = a && a.hit;
-            if (o) {
-                s.save();
-                var l = this.getAbsoluteTransform(n).getMatrix();
-                s.transform(l[0], l[1], l[2], l[3], l[4], l[5]), this._drawCachedHitCanvas(s), s.restore()
-            } else this._drawChildren("drawHit", r, n);
-            return this
+
+        function u(f) {
+            return f.map(c).join(e)
         }
-        _drawChildren(t, n, i) {
-            var r, s = n && n.getContext(),
-                a = this.clipWidth(),
-                o = this.clipHeight(),
-                l = this.clipFunc(),
-                u = a && o || l;
-            const c = i === this;
-            if (u) {
-                s.save();
-                var f = this.getAbsoluteTransform(i),
-                    h = f.getMatrix();
-                if (s.transform(h[0], h[1], h[2], h[3], h[4], h[5]), s.beginPath(), l) l.call(this, s, this);
-                else {
-                    var d = this.clipX(),
-                        g = this.clipY();
-                    s.rect(d, g, a, o)
-                }
-                s.clip(), h = f.copy().invert().getMatrix(), s.transform(h[0], h[1], h[2], h[3], h[4], h[5])
-            }
-            var p = !c && this.globalCompositeOperation() !== "source-over" && t === "drawScene";
-            p && (s.save(), s._applyGlobalCompositeOperation(this)), (r = this.children) === null || r === void 0 || r.forEach(function(m) {
-                m[t](n, i)
-            }), p && s.restore(), u && s.restore()
+
+        function c(f) {
+            return f == null ? "" : f instanceof Date ? IB(f) : t.test(f += "") ? '"' + f.replace(/"/g, '""') + '"' : f
         }
-        getClientRect(t) {
-            var n;
-            t = t || {};
-            var i = t.skipTransform,
-                r = t.relativeTo,
-                s, a, o, l, u = {
-                    x: 1 / 0,
-                    y: 1 / 0,
-                    width: 0,
-                    height: 0
-                },
-                c = this;
-            (n = this.children) === null || n === void 0 || n.forEach(function(p) {
-                if (p.visible()) {
-                    var m = p.getClientRect({
-                        relativeTo: c,
-                        skipShadow: t.skipShadow,
-                        skipStroke: t.skipStroke
-                    });
-                    m.width === 0 && m.height === 0 || (s === void 0 ? (s = m.x, a = m.y, o = m.x + m.width, l = m.y + m.height) : (s = Math.min(s, m.x), a = Math.min(a, m.y), o = Math.max(o, m.x + m.width), l = Math.max(l, m.y + m.height)))
-                }
-            });
-            for (var f = this.find("Shape"), h = !1, d = 0; d < f.length; d++) {
-                var g = f[d];
-                if (g._isVisible(this)) {
-                    h = !0;
-                    break
-                }
-            }
-            return h && s !== void 0 ? u = {
-                x: s,
-                y: a,
-                width: o - s,
-                height: l - a
-            } : u = {
-                x: 0,
-                y: 0,
-                width: 0,
-                height: 0
-            }, i ? u : this._transformedRect(u, r)
+        return {
+            parse: i,
+            parseRows: r,
+            format: a,
+            formatBody: o,
+            formatRows: l,
+            formatRow: u,
+            formatValue: c
         }
     }
-    O.addComponentsGetterSetter(mi, "clip", ["x", "y", "width", "height"]);
-    O.addGetterSetter(mi, "clipX", void 0, te());
-    O.addGetterSetter(mi, "clipY", void 0, te());
-    O.addGetterSetter(mi, "clipWidth", void 0, te());
-    O.addGetterSetter(mi, "clipHeight", void 0, te());
-    O.addGetterSetter(mi, "clipFunc");
-    const dh = new Map,
-        TM = le._global.PointerEvent !== void 0;
 
-    function fy(e) {
-        return dh.get(e)
+    function BB(e) {
+        return e
     }
 
-    function vx(e) {
-        return {
-            evt: e,
-            pointerId: e.pointerId
+    function jB(e) {
+        if (e == null) return BB;
+        var t, n, i = e.scale[0],
+            r = e.scale[1],
+            s = e.translate[0],
+            a = e.translate[1];
+        return function(o, l) {
+            l || (t = n = 0);
+            var u = 2,
+                c = o.length,
+                f = new Array(c);
+            for (f[0] = (t += o[0]) * i + s, f[1] = (n += o[1]) * r + a; u < c;) f[u] = o[u], ++u;
+            return f
         }
     }
 
-    function MM(e, t) {
-        return dh.get(e) === t
+    function GB(e, t) {
+        for (var n, i = e.length, r = i - t; r < --i;) n = e[r], e[r++] = e[i], e[i] = n
     }
 
-    function OM(e, t) {
-        Yf(e), t.getStage() && (dh.set(e, t), TM && t._fire("gotpointercapture", vx(new PointerEvent("gotpointercapture"))))
+    function UB(e, t) {
+        return typeof t == "string" && (t = e.objects[t]), t.type === "GeometryCollection" ? {
+            type: "FeatureCollection",
+            features: t.geometries.map(function(n) {
+                return aA(e, n)
+            })
+        } : aA(e, t)
     }
 
-    function Yf(e, t) {
-        const n = dh.get(e);
-        if (!n) return;
-        const i = n.getStage();
-        i && i.content, dh.delete(e), TM && n._fire("lostpointercapture", vx(new PointerEvent("lostpointercapture")))
+    function aA(e, t) {
+        var n = t.id,
+            i = t.bbox,
+            r = t.properties == null ? {} : t.properties,
+            s = pF(e, t);
+        return n == null && i == null ? {
+            type: "Feature",
+            properties: r,
+            geometry: s
+        } : i == null ? {
+            type: "Feature",
+            id: n,
+            properties: r,
+            geometry: s
+        } : {
+            type: "Feature",
+            id: n,
+            bbox: i,
+            properties: r,
+            geometry: s
+        }
     }
-    var q9 = "Stage",
-        H9 = "string",
-        ck = "px",
-        Y9 = "mouseout",
-        FM = "mouseleave",
-        RM = "mouseover",
-        DM = "mouseenter",
-        NM = "mousemove",
-        PM = "mousedown",
-        LM = "mouseup",
-        vf = "pointermove",
-        bf = "pointerdown",
-        lu = "pointerup",
-        xf = "pointercancel",
-        X9 = "lostpointercapture",
-        qd = "pointerout",
-        Hd = "pointerleave",
-        Yd = "pointerover",
-        Xd = "pointerenter",
-        Kv = "contextmenu",
-        IM = "touchstart",
-        zM = "touchend",
-        BM = "touchmove",
-        jM = "touchcancel",
-        Jv = "wheel",
-        V9 = 5,
-        K9 = [
-            [DM, "_pointerenter"],
-            [PM, "_pointerdown"],
-            [NM, "_pointermove"],
-            [LM, "_pointerup"],
-            [FM, "_pointerleave"],
-            [IM, "_pointerdown"],
-            [BM, "_pointermove"],
-            [zM, "_pointerup"],
-            [jM, "_pointercancel"],
-            [RM, "_pointerover"],
-            [Jv, "_wheel"],
-            [Kv, "_contextmenu"],
-            [bf, "_pointerdown"],
-            [vf, "_pointermove"],
-            [lu, "_pointerup"],
-            [xf, "_pointercancel"],
-            [X9, "_lostpointercapture"]
-        ];
-    const hy = {
-            mouse: {
-                [qd]: Y9,
-                [Hd]: FM,
-                [Yd]: RM,
-                [Xd]: DM,
-                [vf]: NM,
-                [bf]: PM,
-                [lu]: LM,
-                [xf]: "mousecancel",
-                pointerclick: "click",
-                pointerdblclick: "dblclick"
-            },
-            touch: {
-                [qd]: "touchout",
-                [Hd]: "touchleave",
-                [Yd]: "touchover",
-                [Xd]: "touchenter",
-                [vf]: BM,
-                [bf]: IM,
-                [lu]: zM,
-                [xf]: jM,
-                pointerclick: "tap",
-                pointerdblclick: "dbltap"
-            },
-            pointer: {
-                [qd]: qd,
-                [Hd]: Hd,
-                [Yd]: Yd,
-                [Xd]: Xd,
-                [vf]: vf,
-                [bf]: bf,
-                [lu]: lu,
-                [xf]: xf,
-                pointerclick: "pointerclick",
-                pointerdblclick: "pointerdblclick"
-            }
-        },
-        _f = e => e.indexOf("pointer") >= 0 ? "pointer" : e.indexOf("touch") >= 0 ? "touch" : "mouse",
-        Gl = e => {
-            const t = _f(e);
-            if (t === "pointer") return le.pointerEventsEnabled && hy.pointer;
-            if (t === "touch") return hy.touch;
-            if (t === "mouse") return hy.mouse
-        };
 
-    function fk(e = {}) {
-        return (e.clipFunc || e.clipWidth || e.clipHeight) && D.warn("Stage does not support clipping. Please use clip for Layers or Groups."), e
-    }
-    const J9 = "Pointer position is missing and not registered by the stage. Looks like it is outside of the stage container. You can set it manually from event: stage.setPointersPositions(event);",
-        Wg = [];
-    class nm extends mi {
-        constructor(t) {
-            super(fk(t)), this._pointerPositions = [], this._changedPointerPositions = [], this._buildDOM(), this._bindContentEvents(), Wg.push(this), this.on("widthChange.konva heightChange.konva", this._resizeDOM), this.on("visibleChange.konva", this._checkVisibility), this.on("clipWidthChange.konva clipHeightChange.konva clipFuncChange.konva", () => {
-                fk(this.attrs)
-            }), this._checkVisibility()
-        }
-        _validateAdd(t) {
-            const n = t.getType() === "Layer",
-                i = t.getType() === "FastLayer";
-            n || i || D.throw("You may only add layers to the stage.")
+    function pF(e, t) {
+        var n = jB(e.transform),
+            i = e.arcs;
+
+        function r(c, f) {
+            f.length && f.pop();
+            for (var h = i[c < 0 ? ~c : c], d = 0, g = h.length; d < g; ++d) f.push(n(h[d], d));
+            c < 0 && GB(f, g)
         }
-        _checkVisibility() {
-            if (!this.content) return;
-            const t = this.visible() ? "" : "none";
-            this.content.style.display = t
+
+        function s(c) {
+            return n(c)
         }
-        setContainer(t) {
-            if (typeof t === H9) {
-                if (t.charAt(0) === ".") {
-                    var n = t.slice(1);
-                    t = document.getElementsByClassName(n)[0]
-                } else {
-                    var i;
-                    t.charAt(0) !== "#" ? i = t : i = t.slice(1), t = document.getElementById(i)
-                }
-                if (!t) throw "Can not find container in document with id " + i
-            }
-            return this._setAttr("container", t), this.content && (this.content.parentElement && this.content.parentElement.removeChild(this.content), t.appendChild(this.content)), this
+
+        function a(c) {
+            for (var f = [], h = 0, d = c.length; h < d; ++h) r(c[h], f);
+            return f.length < 2 && f.push(f[0]), f
         }
-        shouldDrawHit() {
-            return !0
+
+        function o(c) {
+            for (var f = a(c); f.length < 4;) f.push(f[0]);
+            return f
         }
-        clear() {
-            var t = this.children,
-                n = t.length,
-                i;
-            for (i = 0; i < n; i++) t[i].clear();
-            return this
+
+        function l(c) {
+            return c.map(o)
         }
-        clone(t) {
-            return t || (t = {}), t.container = typeof document < "u" && document.createElement("div"), mi.prototype.clone.call(this, t)
+
+        function u(c) {
+            var f = c.type,
+                h;
+            switch (f) {
+                case "GeometryCollection":
+                    return {
+                        type: f, geometries: c.geometries.map(u)
+                    };
+                case "Point":
+                    h = s(c.coordinates);
+                    break;
+                case "MultiPoint":
+                    h = c.coordinates.map(s);
+                    break;
+                case "LineString":
+                    h = a(c.arcs);
+                    break;
+                case "MultiLineString":
+                    h = c.arcs.map(a);
+                    break;
+                case "Polygon":
+                    h = l(c.arcs);
+                    break;
+                case "MultiPolygon":
+                    h = c.arcs.map(l);
+                    break;
+                default:
+                    return null
+            }
+            return {
+                type: f,
+                coordinates: h
+            }
         }
-        destroy() {
-            super.destroy();
-            var t = this.content;
-            t && D._isInDocument(t) && this.container().removeChild(t);
-            var n = Wg.indexOf(this);
-            return n > -1 && Wg.splice(n, 1), D.releaseCanvas(this.bufferCanvas._canvas, this.bufferHitCanvas._canvas), this
+        return u(t)
+    }
+
+    function WB(e, t) {
+        var n = {},
+            i = {},
+            r = {},
+            s = [],
+            a = -1;
+        t.forEach(function(u, c) {
+            var f = e.arcs[u < 0 ? ~u : u],
+                h;
+            f.length < 3 && !f[1][0] && !f[1][1] && (h = t[++a], t[a] = u, t[c] = h)
+        }), t.forEach(function(u) {
+            var c = o(u),
+                f = c[0],
+                h = c[1],
+                d, g;
+            if (d = r[f])
+                if (delete r[d.end], d.push(u), d.end = h, g = i[h]) {
+                    delete i[g.start];
+                    var p = g === d ? d : d.concat(g);
+                    i[p.start = d.start] = r[p.end = g.end] = p
+                } else i[d.start] = r[d.end] = d;
+            else if (d = i[h])
+                if (delete i[d.start], d.unshift(u), d.start = f, g = r[f]) {
+                    delete r[g.end];
+                    var m = g === d ? d : g.concat(d);
+                    i[m.start = g.start] = r[m.end = d.end] = m
+                } else i[d.start] = r[d.end] = d;
+            else d = [u], i[d.start = f] = r[d.end = h] = d
+        });
+
+        function o(u) {
+            var c = e.arcs[u < 0 ? ~u : u],
+                f = c[0],
+                h;
+            return e.transform ? (h = [0, 0], c.forEach(function(d) {
+                h[0] += d[0], h[1] += d[1]
+            })) : h = c[c.length - 1], u < 0 ? [h, f] : [f, h]
         }
-        getPointerPosition() {
-            const t = this._pointerPositions[0] || this._changedPointerPositions[0];
-            return t ? {
-                x: t.x,
-                y: t.y
-            } : (D.warn(J9), null)
+
+        function l(u, c) {
+            for (var f in u) {
+                var h = u[f];
+                delete c[h.start], delete h.start, delete h.end, h.forEach(function(d) {
+                    n[d < 0 ? ~d : d] = 1
+                }), s.push(h)
+            }
         }
-        _getPointerById(t) {
-            return this._pointerPositions.find(n => n.id === t)
+        return l(r, i), l(i, r), t.forEach(function(u) {
+            n[u < 0 ? ~u : u] || s.push([u])
+        }), s
+    }
+
+    function qB(e) {
+        return pF(e, HB.apply(this, arguments))
+    }
+
+    function HB(e, t, n) {
+        var i, r, s;
+        if (arguments.length > 1) i = YB(e, t, n);
+        else
+            for (r = 0, i = new Array(s = e.arcs.length); r < s; ++r) i[r] = r;
+        return {
+            type: "MultiLineString",
+            arcs: WB(e, i)
         }
-        getPointersPositions() {
-            return this._pointerPositions
+    }
+
+    function YB(e, t, n) {
+        var i = [],
+            r = [],
+            s;
+
+        function a(f) {
+            var h = f < 0 ? ~f : f;
+            (r[h] || (r[h] = [])).push({
+                i: f,
+                g: s
+            })
         }
-        getStage() {
-            return this
+
+        function o(f) {
+            f.forEach(a)
         }
-        getContent() {
-            return this.content
+
+        function l(f) {
+            f.forEach(o)
         }
-        _toKonvaCanvas(t) {
-            t = t || {}, t.x = t.x || 0, t.y = t.y || 0, t.width = t.width || this.width(), t.height = t.height || this.height();
-            var n = new vu({
-                    width: t.width,
-                    height: t.height,
-                    pixelRatio: t.pixelRatio || 1
-                }),
-                i = n.getContext()._context,
-                r = this.children;
-            return (t.x || t.y) && i.translate(-1 * t.x, -1 * t.y), r.forEach(function(s) {
-                if (s.isVisible()) {
-                    var a = s._toKonvaCanvas(t);
-                    i.drawImage(a._canvas, t.x, t.y, a.getWidth() / a.getPixelRatio(), a.getHeight() / a.getPixelRatio())
-                }
-            }), n
+
+        function u(f) {
+            f.forEach(l)
         }
-        getIntersection(t) {
-            if (!t) return null;
-            var n = this.children,
-                i = n.length,
-                r = i - 1,
-                s;
-            for (s = r; s >= 0; s--) {
-                const a = n[s].getIntersection(t);
-                if (a) return a
+
+        function c(f) {
+            switch (s = f, f.type) {
+                case "GeometryCollection":
+                    f.geometries.forEach(c);
+                    break;
+                case "LineString":
+                    o(f.arcs);
+                    break;
+                case "MultiLineString":
+                case "Polygon":
+                    l(f.arcs);
+                    break;
+                case "MultiPolygon":
+                    u(f.arcs);
+                    break
             }
-            return null
-        }
-        _resizeDOM() {
-            var t = this.width(),
-                n = this.height();
-            this.content && (this.content.style.width = t + ck, this.content.style.height = n + ck), this.bufferCanvas.setSize(t, n), this.bufferHitCanvas.setSize(t, n), this.children.forEach(i => {
-                i.setSize({
-                    width: t,
-                    height: n
-                }), i.draw()
-            })
         }
-        add(t, ...n) {
-            if (arguments.length > 1) {
-                for (var i = 0; i < arguments.length; i++) this.add(arguments[i]);
-                return this
+        return c(t), r.forEach(n == null ? function(f) {
+            i.push(f[0].i)
+        } : function(f) {
+            n(f[0].g, f[f.length - 1].g) && i.push(f[0].i)
+        }), i
+    }
+
+    function Hs(e, t) {
+        return e == null || t == null ? NaN : e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN
+    }
+
+    function XB(e, t) {
+        return e == null || t == null ? NaN : t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN
+    }
+
+    function Ad(e) {
+        let t, n, i;
+        e.length !== 2 ? (t = Hs, n = (o, l) => Hs(e(o), l), i = (o, l) => e(o) - l) : (t = e === Hs || e === XB ? e : VB, n = e, i = e);
+
+        function r(o, l, u = 0, c = o.length) {
+            if (u < c) {
+                if (t(l, l) !== 0) return c;
+                do {
+                    const f = u + c >>> 1;
+                    n(o[f], l) < 0 ? u = f + 1 : c = f
+                } while (u < c)
             }
-            super.add(t);
-            var r = this.children.length;
-            return r > V9 && D.warn("The stage has " + r + " layers. Recommended maximum number of layers is 3-5. Adding more layers into the stage may drop the performance. Rethink your tree structure, you can use Konva.Group."), t.setSize({
-                width: this.width(),
-                height: this.height()
-            }), t.draw(), le.isBrowser && this.content.appendChild(t.canvas._canvas), this
-        }
-        getParent() {
-            return null
-        }
-        getLayer() {
-            return null
-        }
-        hasPointerCapture(t) {
-            return MM(t, this)
-        }
-        setPointerCapture(t) {
-            OM(t, this)
+            return u
         }
-        releaseCapture(t) {
-            Yf(t)
+
+        function s(o, l, u = 0, c = o.length) {
+            if (u < c) {
+                if (t(l, l) !== 0) return c;
+                do {
+                    const f = u + c >>> 1;
+                    n(o[f], l) <= 0 ? u = f + 1 : c = f
+                } while (u < c)
+            }
+            return u
         }
-        getLayers() {
-            return this.children
+
+        function a(o, l, u = 0, c = o.length) {
+            const f = r(o, l, u, c - 1);
+            return f > u && i(o[f - 1], l) > -i(o[f], l) ? f - 1 : f
         }
-        _bindContentEvents() {
-            le.isBrowser && K9.forEach(([t, n]) => {
-                this.content.addEventListener(t, i => {
-                    this[n](i)
-                }, {
-                    passive: !1
-                })
-            })
+        return {
+            left: r,
+            center: a,
+            right: s
         }
-        _pointerenter(t) {
-            this.setPointersPositions(t);
-            const n = Gl(t.type);
-            this._fire(n.pointerenter, {
-                evt: t,
-                target: this,
-                currentTarget: this
-            })
+    }
+
+    function VB() {
+        return 0
+    }
+
+    function mF(e) {
+        return e === null ? NaN : +e
+    }
+
+    function* KB(e, t) {
+        if (t === void 0)
+            for (let n of e) n != null && (n = +n) >= n && (yield n);
+        else {
+            let n = -1;
+            for (let i of e)(i = t(i, ++n, e)) != null && (i = +i) >= i && (yield i)
         }
-        _pointerover(t) {
-            this.setPointersPositions(t);
-            const n = Gl(t.type);
-            this._fire(n.pointerover, {
-                evt: t,
-                target: this,
-                currentTarget: this
-            })
+    }
+    const yF = Ad(Hs),
+        nm = yF.right,
+        JB = yF.left;
+    Ad(mF).center;
+    const $d = nm;
+
+    function QB(e, t) {
+        let n = 0,
+            i, r = 0,
+            s = 0;
+        if (t === void 0)
+            for (let a of e) a != null && (a = +a) >= a && (i = a - r, r += i / ++n, s += i * (a - r));
+        else {
+            let a = -1;
+            for (let o of e)(o = t(o, ++a, e)) != null && (o = +o) >= o && (i = o - r, r += i / ++n, s += i * (o - r))
         }
-        _getTargetShape(t) {
-            let n = this[t + "targetShape"];
-            return n && !n.getStage() && (n = null), n
+        if (n > 1) return s / (n - 1)
+    }
+
+    function ZB(e, t) {
+        const n = QB(e, t);
+        return n && Math.sqrt(n)
+    }
+    class Yn {
+        constructor() {
+            this._partials = new Float64Array(32), this._n = 0
         }
-        _pointerleave(t) {
-            const n = Gl(t.type),
-                i = _f(t.type);
-            if (n) {
-                this.setPointersPositions(t);
-                var r = this._getTargetShape(i),
-                    s = !je.isDragging || le.hitOnDragEnabled;
-                r && s ? (r._fireAndBubble(n.pointerout, {
-                    evt: t
-                }), r._fireAndBubble(n.pointerleave, {
-                    evt: t
-                }), this._fire(n.pointerleave, {
-                    evt: t,
-                    target: this,
-                    currentTarget: this
-                }), this[i + "targetShape"] = null) : s && (this._fire(n.pointerleave, {
-                    evt: t,
-                    target: this,
-                    currentTarget: this
-                }), this._fire(n.pointerout, {
-                    evt: t,
-                    target: this,
-                    currentTarget: this
-                })), this.pointerPos = void 0, this._pointerPositions = []
+        add(t) {
+            const n = this._partials;
+            let i = 0;
+            for (let r = 0; r < this._n && r < 32; r++) {
+                const s = n[r],
+                    a = t + s,
+                    o = Math.abs(t) < Math.abs(s) ? t - (a - s) : s - (a - t);
+                o && (n[i++] = o), t = a
             }
+            return n[i] = t, this._n = i + 1, this
         }
-        _pointerdown(t) {
-            const n = Gl(t.type),
-                i = _f(t.type);
-            if (n) {
-                this.setPointersPositions(t);
-                var r = !1;
-                this._changedPointerPositions.forEach(s => {
-                    var a = this.getIntersection(s);
-                    if (je.justDragged = !1, le["_" + i + "ListenClick"] = !0, !(a && a.isListening())) return;
-                    le.capturePointerEventsEnabled && a.setPointerCapture(s.id), this[i + "ClickStartShape"] = a, a._fireAndBubble(n.pointerdown, {
-                        evt: t,
-                        pointerId: s.id
-                    }), r = !0;
-                    const l = t.type.indexOf("touch") >= 0;
-                    a.preventDefault() && t.cancelable && l && t.preventDefault()
-                }), r || this._fire(n.pointerdown, {
-                    evt: t,
-                    target: this,
-                    currentTarget: this,
-                    pointerId: this._pointerPositions[0].id
-                })
+        valueOf() {
+            const t = this._partials;
+            let n = this._n,
+                i, r, s, a = 0;
+            if (n > 0) {
+                for (a = t[--n]; n > 0 && (i = a, r = t[--n], a = i + r, s = r - (a - i), !s););
+                n > 0 && (s < 0 && t[n - 1] < 0 || s > 0 && t[n - 1] > 0) && (r = s * 2, i = a + r, r == i - a && (a = i))
             }
+            return a
         }
-        _pointermove(t) {
-            const n = Gl(t.type),
-                i = _f(t.type);
-            if (!n) return;
-            je.isDragging && je.node.preventDefault() && t.cancelable && t.preventDefault(), this.setPointersPositions(t);
-            var r = !je.isDragging || le.hitOnDragEnabled;
-            if (!r) return;
-            var s = {};
-            let a = !1;
-            var o = this._getTargetShape(i);
-            this._changedPointerPositions.forEach(l => {
-                const u = fy(l.id) || this.getIntersection(l),
-                    c = l.id,
-                    f = {
-                        evt: t,
-                        pointerId: c
-                    };
-                var h = o !== u;
-                if (h && o && (o._fireAndBubble(n.pointerout, Object.assign({}, f), u), o._fireAndBubble(n.pointerleave, Object.assign({}, f), u)), u) {
-                    if (s[u._id]) return;
-                    s[u._id] = !0
-                }
-                u && u.isListening() ? (a = !0, h && (u._fireAndBubble(n.pointerover, Object.assign({}, f), o), u._fireAndBubble(n.pointerenter, Object.assign({}, f), o), this[i + "targetShape"] = u), u._fireAndBubble(n.pointermove, Object.assign({}, f))) : o && (this._fire(n.pointerover, {
-                    evt: t,
-                    target: this,
-                    currentTarget: this,
-                    pointerId: c
-                }), this[i + "targetShape"] = null)
-            }), a || this._fire(n.pointermove, {
-                evt: t,
-                target: this,
-                currentTarget: this,
-                pointerId: this._changedPointerPositions[0].id
-            })
-        }
-        _pointerup(t) {
-            const n = Gl(t.type),
-                i = _f(t.type);
-            if (!n) return;
-            this.setPointersPositions(t);
-            const r = this[i + "ClickStartShape"],
-                s = this[i + "ClickEndShape"];
-            var a = {};
-            let o = !1;
-            this._changedPointerPositions.forEach(l => {
-                const u = fy(l.id) || this.getIntersection(l);
-                if (u) {
-                    if (u.releaseCapture(l.id), a[u._id]) return;
-                    a[u._id] = !0
-                }
-                const c = l.id,
-                    f = {
-                        evt: t,
-                        pointerId: c
-                    };
-                let h = !1;
-                le["_" + i + "InDblClickWindow"] ? (h = !0, clearTimeout(this[i + "DblTimeout"])) : je.justDragged || (le["_" + i + "InDblClickWindow"] = !0, clearTimeout(this[i + "DblTimeout"])), this[i + "DblTimeout"] = setTimeout(function() {
-                    le["_" + i + "InDblClickWindow"] = !1
-                }, le.dblClickWindow), u && u.isListening() ? (o = !0, this[i + "ClickEndShape"] = u, u._fireAndBubble(n.pointerup, Object.assign({}, f)), le["_" + i + "ListenClick"] && r && r === u && (u._fireAndBubble(n.pointerclick, Object.assign({}, f)), h && s && s === u && u._fireAndBubble(n.pointerdblclick, Object.assign({}, f)))) : (this[i + "ClickEndShape"] = null, le["_" + i + "ListenClick"] && this._fire(n.pointerclick, {
-                    evt: t,
-                    target: this,
-                    currentTarget: this,
-                    pointerId: c
-                }), h && this._fire(n.pointerdblclick, {
-                    evt: t,
-                    target: this,
-                    currentTarget: this,
-                    pointerId: c
-                }))
-            }), o || this._fire(n.pointerup, {
-                evt: t,
-                target: this,
-                currentTarget: this,
-                pointerId: this._changedPointerPositions[0].id
-            }), le["_" + i + "ListenClick"] = !1, t.cancelable && i !== "touch" && t.preventDefault()
-        }
-        _contextmenu(t) {
-            this.setPointersPositions(t);
-            var n = this.getIntersection(this.getPointerPosition());
-            n && n.isListening() ? n._fireAndBubble(Kv, {
-                evt: t
-            }) : this._fire(Kv, {
-                evt: t,
-                target: this,
-                currentTarget: this
-            })
-        }
-        _wheel(t) {
-            this.setPointersPositions(t);
-            var n = this.getIntersection(this.getPointerPosition());
-            n && n.isListening() ? n._fireAndBubble(Jv, {
-                evt: t
-            }) : this._fire(Jv, {
-                evt: t,
-                target: this,
-                currentTarget: this
-            })
-        }
-        _pointercancel(t) {
-            this.setPointersPositions(t);
-            const n = fy(t.pointerId) || this.getIntersection(this.getPointerPosition());
-            n && n._fireAndBubble(lu, vx(t)), Yf(t.pointerId)
+    }
+    class oA extends Map {
+        constructor(t, n = xF) {
+            if (super(), Object.defineProperties(this, {
+                    _intern: {
+                        value: new Map
+                    },
+                    _key: {
+                        value: n
+                    }
+                }), t != null)
+                for (const [i, r] of t) this.set(i, r)
         }
-        _lostpointercapture(t) {
-            Yf(t.pointerId)
+        get(t) {
+            return super.get(zb(this, t))
         }
-        setPointersPositions(t) {
-            var n = this._getContentPosition(),
-                i = null,
-                r = null;
-            t = t || window.event, t.touches !== void 0 ? (this._pointerPositions = [], this._changedPointerPositions = [], Array.prototype.forEach.call(t.touches, s => {
-                this._pointerPositions.push({
-                    id: s.identifier,
-                    x: (s.clientX - n.left) / n.scaleX,
-                    y: (s.clientY - n.top) / n.scaleY
-                })
-            }), Array.prototype.forEach.call(t.changedTouches || t.touches, s => {
-                this._changedPointerPositions.push({
-                    id: s.identifier,
-                    x: (s.clientX - n.left) / n.scaleX,
-                    y: (s.clientY - n.top) / n.scaleY
-                })
-            })) : (i = (t.clientX - n.left) / n.scaleX, r = (t.clientY - n.top) / n.scaleY, this.pointerPos = {
-                x: i,
-                y: r
-            }, this._pointerPositions = [{
-                x: i,
-                y: r,
-                id: D._getFirstPointerId(t)
-            }], this._changedPointerPositions = [{
-                x: i,
-                y: r,
-                id: D._getFirstPointerId(t)
-            }])
+        has(t) {
+            return super.has(zb(this, t))
         }
-        _setPointerPosition(t) {
-            D.warn('Method _setPointerPosition is deprecated. Use "stage.setPointersPositions(event)" instead.'), this.setPointersPositions(t)
+        set(t, n) {
+            return super.set(vF(this, t), n)
         }
-        _getContentPosition() {
-            if (!this.content || !this.content.getBoundingClientRect) return {
-                top: 0,
-                left: 0,
-                scaleX: 1,
-                scaleY: 1
-            };
-            var t = this.content.getBoundingClientRect();
-            return {
-                top: t.top,
-                left: t.left,
-                scaleX: t.width / this.content.clientWidth || 1,
-                scaleY: t.height / this.content.clientHeight || 1
-            }
+        delete(t) {
+            return super.delete(bF(this, t))
         }
-        _buildDOM() {
-            if (this.bufferCanvas = new vu({
-                    width: this.width(),
-                    height: this.height()
-                }), this.bufferHitCanvas = new yx({
-                    pixelRatio: 1,
-                    width: this.width(),
-                    height: this.height()
-                }), !!le.isBrowser) {
-                var t = this.container();
-                if (!t) throw "Stage has no container. A container is required.";
-                t.innerHTML = "", this.content = document.createElement("div"), this.content.style.position = "relative", this.content.style.userSelect = "none", this.content.className = "konvajs-content", this.content.setAttribute("role", "presentation"), t.appendChild(this.content), this._resizeDOM()
-            }
+    }
+    class im extends Set {
+        constructor(t, n = xF) {
+            if (super(), Object.defineProperties(this, {
+                    _intern: {
+                        value: new Map
+                    },
+                    _key: {
+                        value: n
+                    }
+                }), t != null)
+                for (const i of t) this.add(i)
         }
-        cache() {
-            return D.warn("Cache function is not allowed for stage. You may use cache only for layers, groups and shapes."), this
+        has(t) {
+            return super.has(zb(this, t))
         }
-        clearCache() {
-            return this
+        add(t) {
+            return super.add(vF(this, t))
         }
-        batchDraw() {
-            return this.getChildren().forEach(function(t) {
-                t.batchDraw()
-            }), this
+        delete(t) {
+            return super.delete(bF(this, t))
         }
     }
-    nm.prototype.nodeType = q9;
-    pt(nm);
-    O.addGetterSetter(nm, "container");
-    var UM = "hasShadow",
-        GM = "shadowRGBA",
-        WM = "patternImage",
-        qM = "linearGradient",
-        HM = "radialGradient";
-    let Vd;
 
-    function dy() {
-        return Vd || (Vd = D.createCanvasElement().getContext("2d"), Vd)
+    function zb({
+        _intern: e,
+        _key: t
+    }, n) {
+        const i = t(n);
+        return e.has(i) ? e.get(i) : n
     }
-    const Xf = {};
 
-    function Q9(e) {
-        e.fill()
+    function vF({
+        _intern: e,
+        _key: t
+    }, n) {
+        const i = t(n);
+        return e.has(i) ? e.get(i) : (e.set(i, n), n)
     }
 
-    function Z9(e) {
-        e.stroke()
+    function bF({
+        _intern: e,
+        _key: t
+    }, n) {
+        const i = t(n);
+        return e.has(i) && (n = e.get(i), e.delete(i)), n
     }
 
-    function e7(e) {
-        e.fill()
+    function xF(e) {
+        return e !== null && typeof e == "object" ? e.valueOf() : e
     }
 
-    function t7(e) {
-        e.stroke()
+    function ej(e, t) {
+        return Array.from(t, n => e[n])
     }
 
-    function n7() {
-        this._clearCache(UM)
+    function tj(e = Hs) {
+        if (e === Hs) return _F;
+        if (typeof e != "function") throw new TypeError("compare is not a function");
+        return (t, n) => {
+            const i = e(t, n);
+            return i || i === 0 ? i : (e(n, n) === 0) - (e(t, t) === 0)
+        }
     }
 
-    function i7() {
-        this._clearCache(GM)
+    function _F(e, t) {
+        return (e == null || !(e >= e)) - (t == null || !(t >= t)) || (e < t ? -1 : e > t ? 1 : 0)
     }
+    const nj = Math.sqrt(50),
+        ij = Math.sqrt(10),
+        rj = Math.sqrt(2);
 
-    function r7() {
-        this._clearCache(WM)
+    function rm(e, t, n) {
+        const i = (t - e) / Math.max(0, n),
+            r = Math.floor(Math.log10(i)),
+            s = i / Math.pow(10, r),
+            a = s >= nj ? 10 : s >= ij ? 5 : s >= rj ? 2 : 1;
+        let o, l, u;
+        return r < 0 ? (u = Math.pow(10, -r) / a, o = Math.round(e * u), l = Math.round(t * u), o / u < e && ++o, l / u > t && --l, u = -u) : (u = Math.pow(10, r) * a, o = Math.round(e / u), l = Math.round(t / u), o * u < e && ++o, l * u > t && --l), l < o && .5 <= n && n < 2 ? rm(e, t, n * 2) : [o, l, u]
     }
 
-    function s7() {
-        this._clearCache(qM)
+    function Bb(e, t, n) {
+        if (t = +t, e = +e, n = +n, !(n > 0)) return [];
+        if (e === t) return [e];
+        const i = t < e,
+            [r, s, a] = i ? rm(t, e, n) : rm(e, t, n);
+        if (!(s >= r)) return [];
+        const o = s - r + 1,
+            l = new Array(o);
+        if (i)
+            if (a < 0)
+                for (let u = 0; u < o; ++u) l[u] = (s - u) / -a;
+            else
+                for (let u = 0; u < o; ++u) l[u] = (s - u) * a;
+        else if (a < 0)
+            for (let u = 0; u < o; ++u) l[u] = (r + u) / -a;
+        else
+            for (let u = 0; u < o; ++u) l[u] = (r + u) * a;
+        return l
     }
 
-    function a7() {
-        this._clearCache(HM)
+    function jb(e, t, n) {
+        return t = +t, e = +e, n = +n, rm(e, t, n)[2]
     }
-    let V = class extends ne {
-        constructor(t) {
-            super(t);
-            let n;
-            for (; n = D.getRandomColor(), !(n && !(n in Xf)););
-            this.colorKey = n, Xf[n] = this
-        }
-        getContext() {
-            return D.warn("shape.getContext() method is deprecated. Please do not use it."), this.getLayer().getContext()
-        }
-        getCanvas() {
-            return D.warn("shape.getCanvas() method is deprecated. Please do not use it."), this.getLayer().getCanvas()
-        }
-        getSceneFunc() {
-            return this.attrs.sceneFunc || this._sceneFunc
-        }
-        getHitFunc() {
-            return this.attrs.hitFunc || this._hitFunc
-        }
-        hasShadow() {
-            return this._getCache(UM, this._hasShadow)
-        }
-        _hasShadow() {
-            return this.shadowEnabled() && this.shadowOpacity() !== 0 && !!(this.shadowColor() || this.shadowBlur() || this.shadowOffsetX() || this.shadowOffsetY())
-        }
-        _getFillPattern() {
-            return this._getCache(WM, this.__getFillPattern)
-        }
-        __getFillPattern() {
-            if (this.fillPatternImage()) {
-                var t = dy();
-                const n = t.createPattern(this.fillPatternImage(), this.fillPatternRepeat() || "repeat");
-                if (n && n.setTransform) {
-                    const i = new Ki;
-                    i.translate(this.fillPatternX(), this.fillPatternY()), i.rotate(le.getAngle(this.fillPatternRotation())), i.scale(this.fillPatternScaleX(), this.fillPatternScaleY()), i.translate(-1 * this.fillPatternOffsetX(), -1 * this.fillPatternOffsetY());
-                    const r = i.getMatrix(),
-                        s = typeof DOMMatrix > "u" ? {
-                            a: r[0],
-                            b: r[1],
-                            c: r[2],
-                            d: r[3],
-                            e: r[4],
-                            f: r[5]
-                        } : new DOMMatrix(r);
-                    n.setTransform(s)
-                }
-                return n
-            }
-        }
-        _getLinearGradient() {
-            return this._getCache(qM, this.__getLinearGradient)
-        }
-        __getLinearGradient() {
-            var t = this.fillLinearGradientColorStops();
-            if (t) {
-                for (var n = dy(), i = this.fillLinearGradientStartPoint(), r = this.fillLinearGradientEndPoint(), s = n.createLinearGradient(i.x, i.y, r.x, r.y), a = 0; a < t.length; a += 2) s.addColorStop(t[a], t[a + 1]);
-                return s
-            }
+
+    function Qa(e, t, n) {
+        t = +t, e = +e, n = +n;
+        const i = t < e,
+            r = i ? jb(t, e, n) : jb(e, t, n);
+        return (i ? -1 : 1) * (r < 0 ? 1 / -r : r)
+    }
+
+    function cl(e, t) {
+        let n;
+        if (t === void 0)
+            for (const i of e) i != null && (n < i || n === void 0 && i >= i) && (n = i);
+        else {
+            let i = -1;
+            for (let r of e)(r = t(r, ++i, e)) != null && (n < r || n === void 0 && r >= r) && (n = r)
         }
-        _getRadialGradient() {
-            return this._getCache(HM, this.__getRadialGradient)
+        return n
+    }
+
+    function Gb(e, t) {
+        let n;
+        if (t === void 0)
+            for (const i of e) i != null && (n > i || n === void 0 && i >= i) && (n = i);
+        else {
+            let i = -1;
+            for (let r of e)(r = t(r, ++i, e)) != null && (n > r || n === void 0 && r >= r) && (n = r)
         }
-        __getRadialGradient() {
-            var t = this.fillRadialGradientColorStops();
-            if (t) {
-                for (var n = dy(), i = this.fillRadialGradientStartPoint(), r = this.fillRadialGradientEndPoint(), s = n.createRadialGradient(i.x, i.y, this.fillRadialGradientStartRadius(), r.x, r.y, this.fillRadialGradientEndRadius()), a = 0; a < t.length; a += 2) s.addColorStop(t[a], t[a + 1]);
-                return s
+        return n
+    }
+
+    function wF(e, t, n = 0, i = 1 / 0, r) {
+        if (t = Math.floor(t), n = Math.floor(Math.max(0, n)), i = Math.floor(Math.min(e.length - 1, i)), !(n <= t && t <= i)) return e;
+        for (r = r === void 0 ? _F : tj(r); i > n;) {
+            if (i - n > 600) {
+                const l = i - n + 1,
+                    u = t - n + 1,
+                    c = Math.log(l),
+                    f = .5 * Math.exp(2 * c / 3),
+                    h = .5 * Math.sqrt(c * f * (l - f) / l) * (u - l / 2 < 0 ? -1 : 1),
+                    d = Math.max(n, Math.floor(t - u * f / l + h)),
+                    g = Math.min(i, Math.floor(t + (l - u) * f / l + h));
+                wF(e, t, d, g, r)
             }
-        }
-        getShadowRGBA() {
-            return this._getCache(GM, this._getShadowRGBA)
-        }
-        _getShadowRGBA() {
-            if (this.hasShadow()) {
-                var t = D.colorToRGBA(this.shadowColor());
-                if (t) return "rgba(" + t.r + "," + t.g + "," + t.b + "," + t.a * (this.shadowOpacity() || 1) + ")"
+            const s = e[t];
+            let a = n,
+                o = i;
+            for (vf(e, n, t), r(e[i], s) > 0 && vf(e, n, i); a < o;) {
+                for (vf(e, a, o), ++a, --o; r(e[a], s) < 0;) ++a;
+                for (; r(e[o], s) > 0;) --o
             }
+            r(e[n], s) === 0 ? vf(e, n, o) : (++o, vf(e, o, i)), o <= t && (n = o + 1), t <= o && (i = o - 1)
         }
-        hasFill() {
-            return this._calculate("hasFill", ["fillEnabled", "fill", "fillPatternImage", "fillLinearGradientColorStops", "fillRadialGradientColorStops"], () => this.fillEnabled() && !!(this.fill() || this.fillPatternImage() || this.fillLinearGradientColorStops() || this.fillRadialGradientColorStops()))
-        }
-        hasStroke() {
-            return this._calculate("hasStroke", ["strokeEnabled", "strokeWidth", "stroke", "strokeLinearGradientColorStops"], () => this.strokeEnabled() && this.strokeWidth() && !!(this.stroke() || this.strokeLinearGradientColorStops()))
-        }
-        hasHitStroke() {
-            const t = this.hitStrokeWidth();
-            return t === "auto" ? this.hasStroke() : this.strokeEnabled() && !!t
-        }
-        intersects(t) {
-            var n = this.getStage(),
-                i = n.bufferHitCanvas,
-                r;
-            return i.getContext().clear(), this.drawHit(i, null, !0), r = i.context.getImageData(Math.round(t.x), Math.round(t.y), 1, 1).data, r[3] > 0
+        return e
+    }
+
+    function vf(e, t, n) {
+        const i = e[t];
+        e[t] = e[n], e[n] = i
+    }
+
+    function Ub(e, t, n) {
+        if (e = Float64Array.from(KB(e, n)), !(!(i = e.length) || isNaN(t = +t))) {
+            if (t <= 0 || i < 2) return Gb(e);
+            if (t >= 1) return cl(e);
+            var i, r = (i - 1) * t,
+                s = Math.floor(r),
+                a = cl(wF(e, s).subarray(0, s + 1)),
+                o = Gb(e.subarray(s + 1));
+            return a + (o - a) * (r - s)
         }
-        destroy() {
-            return ne.prototype.destroy.call(this), delete Xf[this.colorKey], delete this.colorKey, this
+    }
+
+    function SF(e, t, n = mF) {
+        if (!(!(i = e.length) || isNaN(t = +t))) {
+            if (t <= 0 || i < 2) return +n(e[0], 0, e);
+            if (t >= 1) return +n(e[i - 1], i - 1, e);
+            var i, r = (i - 1) * t,
+                s = Math.floor(r),
+                a = +n(e[s], s, e),
+                o = +n(e[s + 1], s + 1, e);
+            return a + (o - a) * (r - s)
         }
-        _useBufferCanvas(t) {
-            var n;
-            if (!this.getStage() || !((n = this.attrs.perfectDrawEnabled) !== null && n !== void 0 ? n : !0)) return !1;
-            const r = t || this.hasFill(),
-                s = this.hasStroke(),
-                a = this.getAbsoluteOpacity() !== 1;
-            if (r && s && a) return !0;
-            const o = this.hasShadow(),
-                l = this.shadowForStrokeEnabled();
-            return !!(r && s && o && l)
+    }
+
+    function sj(e, t) {
+        let n = 0,
+            i = 0;
+        if (t === void 0)
+            for (let r of e) r != null && (r = +r) >= r && (++n, i += r);
+        else {
+            let r = -1;
+            for (let s of e)(s = t(s, ++r, e)) != null && (s = +s) >= s && (++n, i += s)
         }
-        setStrokeHitEnabled(t) {
-            D.warn("strokeHitEnabled property is deprecated. Please use hitStrokeWidth instead."), t ? this.hitStrokeWidth("auto") : this.hitStrokeWidth(0)
+        if (n) return i / n
+    }
+
+    function EF(e, t) {
+        return Ub(e, .5, t)
+    }
+
+    function* aj(e) {
+        for (const t of e) yield* t
+    }
+
+    function kF(e) {
+        return Array.from(aj(e))
+    }
+
+    function $i(e, t, n) {
+        e = +e, t = +t, n = (r = arguments.length) < 2 ? (t = e, e = 0, 1) : r < 3 ? 1 : +n;
+        for (var i = -1, r = Math.max(0, Math.ceil((t - e) / n)) | 0, s = new Array(r); ++i < r;) s[i] = e + i * n;
+        return s
+    }
+
+    function CF(e, t) {
+        let n = 0;
+        if (t === void 0)
+            for (let i of e)(i = +i) && (n += i);
+        else {
+            let i = -1;
+            for (let r of e)(r = +t(r, ++i, e)) && (n += r)
         }
-        getStrokeHitEnabled() {
-            return this.hitStrokeWidth() !== 0
+        return n
+    }
+
+    function oj(e) {
+        return Math.abs(e = Math.round(e)) >= 1e21 ? e.toLocaleString("en").replace(/,/g, "") : e.toString(10)
+    }
+
+    function sm(e, t) {
+        if ((n = (e = t ? e.toExponential(t - 1) : e.toExponential()).indexOf("e")) < 0) return null;
+        var n, i = e.slice(0, n);
+        return [i.length > 1 ? i[0] + i.slice(2) : i, +e.slice(n + 1)]
+    }
+
+    function ic(e) {
+        return e = sm(Math.abs(e)), e ? e[1] : NaN
+    }
+
+    function lj(e, t) {
+        return function(n, i) {
+            for (var r = n.length, s = [], a = 0, o = e[0], l = 0; r > 0 && o > 0 && (l + o + 1 > i && (o = Math.max(1, i - l)), s.push(n.substring(r -= o, r + o)), !((l += o + 1) > i));) o = e[a = (a + 1) % e.length];
+            return s.reverse().join(t)
         }
-        getSelfRect() {
-            var t = this.size();
-            return {
-                x: this._centroid ? -t.width / 2 : 0,
-                y: this._centroid ? -t.height / 2 : 0,
-                width: t.width,
-                height: t.height
-            }
+    }
+
+    function uj(e) {
+        return function(t) {
+            return t.replace(/[0-9]/g, function(n) {
+                return e[+n]
+            })
         }
-        getClientRect(t = {}) {
-            const n = t.skipTransform,
-                i = t.relativeTo,
-                r = this.getSelfRect(),
-                a = !t.skipStroke && this.hasStroke() && this.strokeWidth() || 0,
-                o = r.width + a,
-                l = r.height + a,
-                u = !t.skipShadow && this.hasShadow(),
-                c = u ? this.shadowOffsetX() : 0,
-                f = u ? this.shadowOffsetY() : 0,
-                h = o + Math.abs(c),
-                d = l + Math.abs(f),
-                g = u && this.shadowBlur() || 0,
-                p = h + g * 2,
-                m = d + g * 2,
-                y = {
-                    width: p,
-                    height: m,
-                    x: -(a / 2 + g) + Math.min(c, 0) + r.x,
-                    y: -(a / 2 + g) + Math.min(f, 0) + r.y
-                };
-            return n ? y : this._transformedRect(y, i)
+    }
+    var cj = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
+
+    function _l(e) {
+        if (!(t = cj.exec(e))) throw new Error("invalid format: " + e);
+        var t;
+        return new E_({
+            fill: t[1],
+            align: t[2],
+            sign: t[3],
+            symbol: t[4],
+            zero: t[5],
+            width: t[6],
+            comma: t[7],
+            precision: t[8] && t[8].slice(1),
+            trim: t[9],
+            type: t[10]
+        })
+    }
+    _l.prototype = E_.prototype;
+
+    function E_(e) {
+        this.fill = e.fill === void 0 ? " " : e.fill + "", this.align = e.align === void 0 ? ">" : e.align + "", this.sign = e.sign === void 0 ? "-" : e.sign + "", this.symbol = e.symbol === void 0 ? "" : e.symbol + "", this.zero = !!e.zero, this.width = e.width === void 0 ? void 0 : +e.width, this.comma = !!e.comma, this.precision = e.precision === void 0 ? void 0 : +e.precision, this.trim = !!e.trim, this.type = e.type === void 0 ? "" : e.type + ""
+    }
+    E_.prototype.toString = function() {
+        return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type
+    };
+
+    function fj(e) {
+        e: for (var t = e.length, n = 1, i = -1, r; n < t; ++n) switch (e[n]) {
+            case ".":
+                i = r = n;
+                break;
+            case "0":
+                i === 0 && (i = n), r = n;
+                break;
+            default:
+                if (!+e[n]) break e;
+                i > 0 && (i = 0);
+                break
         }
-        drawScene(t, n) {
-            var i = this.getLayer(),
-                r = t || i.getCanvas(),
-                s = r.getContext(),
-                a = this._getCanvasCache(),
-                o = this.getSceneFunc(),
-                l = this.hasShadow(),
-                u, c, f, h = r.isCache,
-                d = n === this;
-            if (!this.isVisible() && !d) return this;
-            if (a) {
-                s.save();
-                var g = this.getAbsoluteTransform(n).getMatrix();
-                return s.transform(g[0], g[1], g[2], g[3], g[4], g[5]), this._drawCachedSceneCanvas(s), s.restore(), this
-            }
-            if (!o) return this;
-            if (s.save(), this._useBufferCanvas() && !h) {
-                u = this.getStage(), c = u.bufferCanvas, f = c.getContext(), f.clear(), f.save(), f._applyLineJoin(this);
-                var p = this.getAbsoluteTransform(n).getMatrix();
-                f.transform(p[0], p[1], p[2], p[3], p[4], p[5]), o.call(this, f, this), f.restore();
-                var m = c.pixelRatio;
-                l && s._applyShadow(this), s._applyOpacity(this), s._applyGlobalCompositeOperation(this), s.drawImage(c._canvas, 0, 0, c.width / m, c.height / m)
-            } else {
-                if (s._applyLineJoin(this), !d) {
-                    var p = this.getAbsoluteTransform(n).getMatrix();
-                    s.transform(p[0], p[1], p[2], p[3], p[4], p[5]), s._applyOpacity(this), s._applyGlobalCompositeOperation(this)
+        return i > 0 ? e.slice(0, i) + e.slice(r + 1) : e
+    }
+    var AF;
+
+    function hj(e, t) {
+        var n = sm(e, t);
+        if (!n) return e + "";
+        var i = n[0],
+            r = n[1],
+            s = r - (AF = Math.max(-8, Math.min(8, Math.floor(r / 3))) * 3) + 1,
+            a = i.length;
+        return s === a ? i : s > a ? i + new Array(s - a + 1).join("0") : s > 0 ? i.slice(0, s) + "." + i.slice(s) : "0." + new Array(1 - s).join("0") + sm(e, Math.max(0, t + s - 1))[0]
+    }
+
+    function lA(e, t) {
+        var n = sm(e, t);
+        if (!n) return e + "";
+        var i = n[0],
+            r = n[1];
+        return r < 0 ? "0." + new Array(-r).join("0") + i : i.length > r + 1 ? i.slice(0, r + 1) + "." + i.slice(r + 1) : i + new Array(r - i.length + 2).join("0")
+    }
+    const uA = {
+        "%": (e, t) => (e * 100).toFixed(t),
+        b: e => Math.round(e).toString(2),
+        c: e => e + "",
+        d: oj,
+        e: (e, t) => e.toExponential(t),
+        f: (e, t) => e.toFixed(t),
+        g: (e, t) => e.toPrecision(t),
+        o: e => Math.round(e).toString(8),
+        p: (e, t) => lA(e * 100, t),
+        r: lA,
+        s: hj,
+        X: e => Math.round(e).toString(16).toUpperCase(),
+        x: e => Math.round(e).toString(16)
+    };
+
+    function cA(e) {
+        return e
+    }
+    var fA = Array.prototype.map,
+        hA = ["y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
+
+    function $F(e) {
+        var t = e.grouping === void 0 || e.thousands === void 0 ? cA : lj(fA.call(e.grouping, Number), e.thousands + ""),
+            n = e.currency === void 0 ? "" : e.currency[0] + "",
+            i = e.currency === void 0 ? "" : e.currency[1] + "",
+            r = e.decimal === void 0 ? "." : e.decimal + "",
+            s = e.numerals === void 0 ? cA : uj(fA.call(e.numerals, String)),
+            a = e.percent === void 0 ? "%" : e.percent + "",
+            o = e.minus === void 0 ? "−" : e.minus + "",
+            l = e.nan === void 0 ? "NaN" : e.nan + "";
+
+        function u(f) {
+            f = _l(f);
+            var h = f.fill,
+                d = f.align,
+                g = f.sign,
+                p = f.symbol,
+                m = f.zero,
+                y = f.width,
+                v = f.comma,
+                b = f.precision,
+                x = f.trim,
+                _ = f.type;
+            _ === "n" ? (v = !0, _ = "g") : uA[_] || (b === void 0 && (b = 12), x = !0, _ = "g"), (m || h === "0" && d === "=") && (m = !0, h = "0", d = "=");
+            var S = p === "$" ? n : p === "#" && /[boxX]/.test(_) ? "0" + _.toLowerCase() : "",
+                w = p === "$" ? i : /[%p]/.test(_) ? a : "",
+                E = uA[_],
+                C = /[defgprs%]/.test(_);
+            b = b === void 0 ? 6 : /[gprs]/.test(_) ? Math.max(1, Math.min(21, b)) : Math.max(0, Math.min(20, b));
+
+            function k(A) {
+                var F = S,
+                    $ = w,
+                    T, M, R;
+                if (_ === "c") $ = E(A) + $, A = "";
+                else {
+                    A = +A;
+                    var N = A < 0 || 1 / A < 0;
+                    if (A = isNaN(A) ? l : E(Math.abs(A), b), x && (A = fj(A)), N && +A == 0 && g !== "+" && (N = !1), F = (N ? g === "(" ? g : o : g === "-" || g === "(" ? "" : g) + F, $ = (_ === "s" ? hA[8 + AF / 3] : "") + $ + (N && g === "(" ? ")" : ""), C) {
+                        for (T = -1, M = A.length; ++T < M;)
+                            if (R = A.charCodeAt(T), 48 > R || R > 57) {
+                                $ = (R === 46 ? r + A.slice(T + 1) : A.slice(T)) + $, A = A.slice(0, T);
+                                break
+                            }
+                    }
                 }
-                l && s._applyShadow(this), o.call(this, s, this)
-            }
-            return s.restore(), this
-        }
-        drawHit(t, n, i = !1) {
-            if (!this.shouldDrawHit(n, i)) return this;
-            var r = this.getLayer(),
-                s = t || r.hitCanvas,
-                a = s && s.getContext(),
-                o = this.hitFunc() || this.sceneFunc(),
-                l = this._getCanvasCache(),
-                u = l && l.hit;
-            if (this.colorKey || D.warn("Looks like your canvas has a destroyed shape in it. Do not reuse shape after you destroyed it. If you want to reuse shape you should call remove() instead of destroy()"), u) {
-                a.save();
-                var c = this.getAbsoluteTransform(n).getMatrix();
-                return a.transform(c[0], c[1], c[2], c[3], c[4], c[5]), this._drawCachedHitCanvas(a), a.restore(), this
-            }
-            if (!o) return this;
-            if (a.save(), a._applyLineJoin(this), !(this === n)) {
-                var h = this.getAbsoluteTransform(n).getMatrix();
-                a.transform(h[0], h[1], h[2], h[3], h[4], h[5])
+                v && !m && (A = t(A, 1 / 0));
+                var L = F.length + A.length + $.length,
+                    I = L < y ? new Array(y - L + 1).join(h) : "";
+                switch (v && m && (A = t(I + A, I.length ? y - $.length : 1 / 0), I = ""), d) {
+                    case "<":
+                        A = F + A + $ + I;
+                        break;
+                    case "=":
+                        A = F + I + A + $;
+                        break;
+                    case "^":
+                        A = I.slice(0, L = I.length >> 1) + F + A + $ + I.slice(L);
+                        break;
+                    default:
+                        A = I + F + A + $;
+                        break
+                }
+                return s(A)
             }
-            return o.call(this, a, this), a.restore(), this
+            return k.toString = function() {
+                return f + ""
+            }, k
         }
-        drawHitFromCache(t = 0) {
-            var n = this._getCanvasCache(),
-                i = this._getCachedSceneCanvas(),
-                r = n.hit,
-                s = r.getContext(),
-                a = r.getWidth(),
-                o = r.getHeight(),
-                l, u, c, f, h, d;
-            s.clear(), s.drawImage(i._canvas, 0, 0, a, o);
-            try {
-                for (l = s.getImageData(0, 0, a, o), u = l.data, c = u.length, f = D._hexToRgb(this.colorKey), h = 0; h < c; h += 4) d = u[h + 3], d > t ? (u[h] = f.r, u[h + 1] = f.g, u[h + 2] = f.b, u[h + 3] = 255) : u[h + 3] = 0;
-                s.putImageData(l, 0, 0)
-            } catch (g) {
-                D.error("Unable to draw hit graph from cached scene canvas. " + g.message)
+
+        function c(f, h) {
+            var d = u((f = _l(f), f.type = "f", f)),
+                g = Math.max(-8, Math.min(8, Math.floor(ic(h) / 3))) * 3,
+                p = Math.pow(10, -g),
+                m = hA[8 + g / 3];
+            return function(y) {
+                return d(p * y) + m
             }
-            return this
-        }
-        hasPointerCapture(t) {
-            return MM(t, this)
-        }
-        setPointerCapture(t) {
-            OM(t, this)
         }
-        releaseCapture(t) {
-            Yf(t)
+        return {
+            format: u,
+            formatPrefix: c
         }
-    };
-    V.prototype._fillFunc = Q9;
-    V.prototype._strokeFunc = Z9;
-    V.prototype._fillFuncHit = e7;
-    V.prototype._strokeFuncHit = t7;
-    V.prototype._centroid = !1;
-    V.prototype.nodeType = "Shape";
-    pt(V);
-    V.prototype.eventListeners = {};
-    V.prototype.on.call(V.prototype, "shadowColorChange.konva shadowBlurChange.konva shadowOffsetChange.konva shadowOpacityChange.konva shadowEnabledChange.konva", n7);
-    V.prototype.on.call(V.prototype, "shadowColorChange.konva shadowOpacityChange.konva shadowEnabledChange.konva", i7);
-    V.prototype.on.call(V.prototype, "fillPriorityChange.konva fillPatternImageChange.konva fillPatternRepeatChange.konva fillPatternScaleXChange.konva fillPatternScaleYChange.konva fillPatternOffsetXChange.konva fillPatternOffsetYChange.konva fillPatternXChange.konva fillPatternYChange.konva fillPatternRotationChange.konva", r7);
-    V.prototype.on.call(V.prototype, "fillPriorityChange.konva fillLinearGradientColorStopsChange.konva fillLinearGradientStartPointXChange.konva fillLinearGradientStartPointYChange.konva fillLinearGradientEndPointXChange.konva fillLinearGradientEndPointYChange.konva", s7);
-    V.prototype.on.call(V.prototype, "fillPriorityChange.konva fillRadialGradientColorStopsChange.konva fillRadialGradientStartPointXChange.konva fillRadialGradientStartPointYChange.konva fillRadialGradientEndPointXChange.konva fillRadialGradientEndPointYChange.konva fillRadialGradientStartRadiusChange.konva fillRadialGradientEndRadiusChange.konva", a7);
-    O.addGetterSetter(V, "stroke", void 0, $M());
-    O.addGetterSetter(V, "strokeWidth", 2, te());
-    O.addGetterSetter(V, "fillAfterStrokeEnabled", !1);
-    O.addGetterSetter(V, "hitStrokeWidth", "auto", mx());
-    O.addGetterSetter(V, "strokeHitEnabled", !0, mr());
-    O.addGetterSetter(V, "perfectDrawEnabled", !0, mr());
-    O.addGetterSetter(V, "shadowForStrokeEnabled", !0, mr());
-    O.addGetterSetter(V, "lineJoin");
-    O.addGetterSetter(V, "lineCap");
-    O.addGetterSetter(V, "sceneFunc");
-    O.addGetterSetter(V, "hitFunc");
-    O.addGetterSetter(V, "dash");
-    O.addGetterSetter(V, "dashOffset", 0, te());
-    O.addGetterSetter(V, "shadowColor", void 0, hc());
-    O.addGetterSetter(V, "shadowBlur", 0, te());
-    O.addGetterSetter(V, "shadowOpacity", 1, te());
-    O.addComponentsGetterSetter(V, "shadowOffset", ["x", "y"]);
-    O.addGetterSetter(V, "shadowOffsetX", 0, te());
-    O.addGetterSetter(V, "shadowOffsetY", 0, te());
-    O.addGetterSetter(V, "fillPatternImage");
-    O.addGetterSetter(V, "fill", void 0, $M());
-    O.addGetterSetter(V, "fillPatternX", 0, te());
-    O.addGetterSetter(V, "fillPatternY", 0, te());
-    O.addGetterSetter(V, "fillLinearGradientColorStops");
-    O.addGetterSetter(V, "strokeLinearGradientColorStops");
-    O.addGetterSetter(V, "fillRadialGradientStartRadius", 0);
-    O.addGetterSetter(V, "fillRadialGradientEndRadius", 0);
-    O.addGetterSetter(V, "fillRadialGradientColorStops");
-    O.addGetterSetter(V, "fillPatternRepeat", "repeat");
-    O.addGetterSetter(V, "fillEnabled", !0);
-    O.addGetterSetter(V, "strokeEnabled", !0);
-    O.addGetterSetter(V, "shadowEnabled", !0);
-    O.addGetterSetter(V, "dashEnabled", !0);
-    O.addGetterSetter(V, "strokeScaleEnabled", !0);
-    O.addGetterSetter(V, "fillPriority", "color");
-    O.addComponentsGetterSetter(V, "fillPatternOffset", ["x", "y"]);
-    O.addGetterSetter(V, "fillPatternOffsetX", 0, te());
-    O.addGetterSetter(V, "fillPatternOffsetY", 0, te());
-    O.addComponentsGetterSetter(V, "fillPatternScale", ["x", "y"]);
-    O.addGetterSetter(V, "fillPatternScaleX", 1, te());
-    O.addGetterSetter(V, "fillPatternScaleY", 1, te());
-    O.addComponentsGetterSetter(V, "fillLinearGradientStartPoint", ["x", "y"]);
-    O.addComponentsGetterSetter(V, "strokeLinearGradientStartPoint", ["x", "y"]);
-    O.addGetterSetter(V, "fillLinearGradientStartPointX", 0);
-    O.addGetterSetter(V, "strokeLinearGradientStartPointX", 0);
-    O.addGetterSetter(V, "fillLinearGradientStartPointY", 0);
-    O.addGetterSetter(V, "strokeLinearGradientStartPointY", 0);
-    O.addComponentsGetterSetter(V, "fillLinearGradientEndPoint", ["x", "y"]);
-    O.addComponentsGetterSetter(V, "strokeLinearGradientEndPoint", ["x", "y"]);
-    O.addGetterSetter(V, "fillLinearGradientEndPointX", 0);
-    O.addGetterSetter(V, "strokeLinearGradientEndPointX", 0);
-    O.addGetterSetter(V, "fillLinearGradientEndPointY", 0);
-    O.addGetterSetter(V, "strokeLinearGradientEndPointY", 0);
-    O.addComponentsGetterSetter(V, "fillRadialGradientStartPoint", ["x", "y"]);
-    O.addGetterSetter(V, "fillRadialGradientStartPointX", 0);
-    O.addGetterSetter(V, "fillRadialGradientStartPointY", 0);
-    O.addComponentsGetterSetter(V, "fillRadialGradientEndPoint", ["x", "y"]);
-    O.addGetterSetter(V, "fillRadialGradientEndPointX", 0);
-    O.addGetterSetter(V, "fillRadialGradientEndPointY", 0);
-    O.addGetterSetter(V, "fillPatternRotation", 0);
-    O.backCompat(V, {
-        dashArray: "dash",
-        getDashArray: "getDash",
-        setDashArray: "getDash",
-        drawFunc: "sceneFunc",
-        getDrawFunc: "getSceneFunc",
-        setDrawFunc: "setSceneFunc",
-        drawHitFunc: "hitFunc",
-        getDrawHitFunc: "getHitFunc",
-        setDrawHitFunc: "setHitFunc"
+    }
+    var xg, B0, k_;
+    dj({
+        thousands: ",",
+        grouping: [3],
+        currency: ["$", ""]
     });
-    var o7 = "#",
-        l7 = "beforeDraw",
-        u7 = "draw",
-        YM = [{
-            x: 0,
-            y: 0
-        }, {
-            x: -1,
-            y: -1
-        }, {
-            x: 1,
-            y: -1
-        }, {
-            x: 1,
-            y: 1
-        }, {
-            x: -1,
-            y: 1
-        }],
-        c7 = YM.length;
-    class xl extends mi {
-        constructor(t) {
-            super(t), this.canvas = new vu, this.hitCanvas = new yx({
-                pixelRatio: 1
-            }), this._waitingForDraw = !1, this.on("visibleChange.konva", this._checkVisibility), this._checkVisibility(), this.on("imageSmoothingEnabledChange.konva", this._setSmoothEnabled), this._setSmoothEnabled()
+
+    function dj(e) {
+        return xg = $F(e), B0 = xg.format, k_ = xg.formatPrefix, xg
+    }
+
+    function TF(e) {
+        return Math.max(0, -ic(Math.abs(e)))
+    }
+
+    function MF(e, t) {
+        return Math.max(0, Math.max(-8, Math.min(8, Math.floor(ic(t) / 3))) * 3 - ic(Math.abs(e)))
+    }
+
+    function OF(e, t) {
+        return e = Math.abs(e), t = Math.abs(t) - e, Math.max(0, ic(t) - ic(e)) + 1
+    }
+    const Jy = new Date,
+        Qy = new Date;
+
+    function Vt(e, t, n, i) {
+        function r(s) {
+            return e(s = arguments.length === 0 ? new Date : new Date(+s)), s
         }
-        createPNGStream() {
-            return this.canvas._canvas.createPNGStream()
+        return r.floor = s => (e(s = new Date(+s)), s), r.ceil = s => (e(s = new Date(s - 1)), t(s, 1), e(s), s), r.round = s => {
+            const a = r(s),
+                o = r.ceil(s);
+            return s - a < o - s ? a : o
+        }, r.offset = (s, a) => (t(s = new Date(+s), a == null ? 1 : Math.floor(a)), s), r.range = (s, a, o) => {
+            const l = [];
+            if (s = r.ceil(s), o = o == null ? 1 : Math.floor(o), !(s < a) || !(o > 0)) return l;
+            let u;
+            do l.push(u = new Date(+s)), t(s, o), e(s); while (u < s && s < a);
+            return l
+        }, r.filter = s => Vt(a => {
+            if (a >= a)
+                for (; e(a), !s(a);) a.setTime(a - 1)
+        }, (a, o) => {
+            if (a >= a)
+                if (o < 0)
+                    for (; ++o <= 0;)
+                        for (; t(a, -1), !s(a););
+                else
+                    for (; --o >= 0;)
+                        for (; t(a, 1), !s(a););
+        }), n && (r.count = (s, a) => (Jy.setTime(+s), Qy.setTime(+a), e(Jy), e(Qy), Math.floor(n(Jy, Qy))), r.every = s => (s = Math.floor(s), !isFinite(s) || !(s > 0) ? null : s > 1 ? r.filter(i ? a => i(a) % s === 0 : a => r.count(0, a) % s === 0) : r)), r
+    }
+    const rc = Vt(() => {}, (e, t) => {
+        e.setTime(+e + t)
+    }, (e, t) => t - e);
+    rc.every = e => (e = Math.floor(e), !isFinite(e) || !(e > 0) ? null : e > 1 ? Vt(t => {
+        t.setTime(Math.floor(t / e) * e)
+    }, (t, n) => {
+        t.setTime(+t + n * e)
+    }, (t, n) => (n - t) / e) : rc);
+    rc.range;
+    const Bs = 1e3,
+        Bi = Bs * 60,
+        js = Bi * 60,
+        Zs = js * 24,
+        C_ = Zs * 7,
+        dA = Zs * 30,
+        Zy = Zs * 365,
+        Gs = Vt(e => {
+            e.setTime(e - e.getMilliseconds())
+        }, (e, t) => {
+            e.setTime(+e + t * Bs)
+        }, (e, t) => (t - e) / Bs, e => e.getUTCSeconds());
+    Gs.range;
+    const j0 = Vt(e => {
+        e.setTime(e - e.getMilliseconds() - e.getSeconds() * Bs)
+    }, (e, t) => {
+        e.setTime(+e + t * Bi)
+    }, (e, t) => (t - e) / Bi, e => e.getMinutes());
+    j0.range;
+    const G0 = Vt(e => {
+        e.setUTCSeconds(0, 0)
+    }, (e, t) => {
+        e.setTime(+e + t * Bi)
+    }, (e, t) => (t - e) / Bi, e => e.getUTCMinutes());
+    G0.range;
+    const U0 = Vt(e => {
+        e.setTime(e - e.getMilliseconds() - e.getSeconds() * Bs - e.getMinutes() * Bi)
+    }, (e, t) => {
+        e.setTime(+e + t * js)
+    }, (e, t) => (t - e) / js, e => e.getHours());
+    U0.range;
+    const W0 = Vt(e => {
+        e.setUTCMinutes(0, 0, 0)
+    }, (e, t) => {
+        e.setTime(+e + t * js)
+    }, (e, t) => (t - e) / js, e => e.getUTCHours());
+    W0.range;
+    const Ys = Vt(e => e.setHours(0, 0, 0, 0), (e, t) => e.setDate(e.getDate() + t), (e, t) => (t - e - (t.getTimezoneOffset() - e.getTimezoneOffset()) * Bi) / Zs, e => e.getDate() - 1);
+    Ys.range;
+    const Wa = Vt(e => {
+        e.setUTCHours(0, 0, 0, 0)
+    }, (e, t) => {
+        e.setUTCDate(e.getUTCDate() + t)
+    }, (e, t) => (t - e) / Zs, e => e.getUTCDate() - 1);
+    Wa.range;
+    const FF = Vt(e => {
+        e.setUTCHours(0, 0, 0, 0)
+    }, (e, t) => {
+        e.setUTCDate(e.getUTCDate() + t)
+    }, (e, t) => (t - e) / Zs, e => Math.floor(e / Zs));
+    FF.range;
+
+    function ql(e) {
+        return Vt(t => {
+            t.setDate(t.getDate() - (t.getDay() + 7 - e) % 7), t.setHours(0, 0, 0, 0)
+        }, (t, n) => {
+            t.setDate(t.getDate() + n * 7)
+        }, (t, n) => (n - t - (n.getTimezoneOffset() - t.getTimezoneOffset()) * Bi) / C_)
+    }
+    const Wc = ql(0),
+        am = ql(1),
+        gj = ql(2),
+        pj = ql(3),
+        sc = ql(4),
+        mj = ql(5),
+        yj = ql(6);
+    Wc.range;
+    am.range;
+    gj.range;
+    pj.range;
+    sc.range;
+    mj.range;
+    yj.range;
+
+    function Hl(e) {
+        return Vt(t => {
+            t.setUTCDate(t.getUTCDate() - (t.getUTCDay() + 7 - e) % 7), t.setUTCHours(0, 0, 0, 0)
+        }, (t, n) => {
+            t.setUTCDate(t.getUTCDate() + n * 7)
+        }, (t, n) => (n - t) / C_)
+    }
+    const qc = Hl(0),
+        om = Hl(1),
+        vj = Hl(2),
+        bj = Hl(3),
+        ac = Hl(4),
+        xj = Hl(5),
+        _j = Hl(6);
+    qc.range;
+    om.range;
+    vj.range;
+    bj.range;
+    ac.range;
+    xj.range;
+    _j.range;
+    const Wh = Vt(e => {
+        e.setDate(1), e.setHours(0, 0, 0, 0)
+    }, (e, t) => {
+        e.setMonth(e.getMonth() + t)
+    }, (e, t) => t.getMonth() - e.getMonth() + (t.getFullYear() - e.getFullYear()) * 12, e => e.getMonth());
+    Wh.range;
+    const qh = Vt(e => {
+        e.setUTCDate(1), e.setUTCHours(0, 0, 0, 0)
+    }, (e, t) => {
+        e.setUTCMonth(e.getUTCMonth() + t)
+    }, (e, t) => t.getUTCMonth() - e.getUTCMonth() + (t.getUTCFullYear() - e.getUTCFullYear()) * 12, e => e.getUTCMonth());
+    qh.range;
+    const as = Vt(e => {
+        e.setMonth(0, 1), e.setHours(0, 0, 0, 0)
+    }, (e, t) => {
+        e.setFullYear(e.getFullYear() + t)
+    }, (e, t) => t.getFullYear() - e.getFullYear(), e => e.getFullYear());
+    as.every = e => !isFinite(e = Math.floor(e)) || !(e > 0) ? null : Vt(t => {
+        t.setFullYear(Math.floor(t.getFullYear() / e) * e), t.setMonth(0, 1), t.setHours(0, 0, 0, 0)
+    }, (t, n) => {
+        t.setFullYear(t.getFullYear() + n * e)
+    });
+    as.range;
+    const os = Vt(e => {
+        e.setUTCMonth(0, 1), e.setUTCHours(0, 0, 0, 0)
+    }, (e, t) => {
+        e.setUTCFullYear(e.getUTCFullYear() + t)
+    }, (e, t) => t.getUTCFullYear() - e.getUTCFullYear(), e => e.getUTCFullYear());
+    os.every = e => !isFinite(e = Math.floor(e)) || !(e > 0) ? null : Vt(t => {
+        t.setUTCFullYear(Math.floor(t.getUTCFullYear() / e) * e), t.setUTCMonth(0, 1), t.setUTCHours(0, 0, 0, 0)
+    }, (t, n) => {
+        t.setUTCFullYear(t.getUTCFullYear() + n * e)
+    });
+    os.range;
+
+    function RF(e, t, n, i, r, s) {
+        const a = [
+            [Gs, 1, Bs],
+            [Gs, 5, 5 * Bs],
+            [Gs, 15, 15 * Bs],
+            [Gs, 30, 30 * Bs],
+            [s, 1, Bi],
+            [s, 5, 5 * Bi],
+            [s, 15, 15 * Bi],
+            [s, 30, 30 * Bi],
+            [r, 1, js],
+            [r, 3, 3 * js],
+            [r, 6, 6 * js],
+            [r, 12, 12 * js],
+            [i, 1, Zs],
+            [i, 2, 2 * Zs],
+            [n, 1, C_],
+            [t, 1, dA],
+            [t, 3, 3 * dA],
+            [e, 1, Zy]
+        ];
+
+        function o(u, c, f) {
+            const h = c < u;
+            h && ([u, c] = [c, u]);
+            const d = f && typeof f.range == "function" ? f : l(u, c, f),
+                g = d ? d.range(u, +c + 1) : [];
+            return h ? g.reverse() : g
         }
-        getCanvas() {
-            return this.canvas
+
+        function l(u, c, f) {
+            const h = Math.abs(c - u) / f,
+                d = Ad(([, , m]) => m).right(a, h);
+            if (d === a.length) return e.every(Qa(u / Zy, c / Zy, f));
+            if (d === 0) return rc.every(Math.max(Qa(u, c, f), 1));
+            const [g, p] = a[h / a[d - 1][2] < a[d][2] / h ? d - 1 : d];
+            return g.every(p)
         }
-        getNativeCanvasElement() {
-            return this.canvas._canvas
+        return [o, l]
+    }
+    const [wj, Sj] = RF(os, qh, qc, FF, W0, G0), [Ej, kj] = RF(as, Wh, Wc, Ys, U0, j0), vn = "year", hi = "quarter", Rn = "month", Ht = "week", di = "date", $n = "day", ls = "dayofyear", Oi = "hours", Fi = "minutes", Xi = "seconds", Ar = "milliseconds", A_ = [vn, hi, Rn, Ht, di, $n, ls, Oi, Fi, Xi, Ar], ev = A_.reduce((e, t, n) => (e[t] = 1 + n, e), {});
+
+    function $_(e) {
+        const t = ue(e).slice(),
+            n = {};
+        return t.length || q("Missing time unit."), t.forEach(r => {
+            Ce(ev, r) ? n[r] = 1 : q(`Invalid time unit: ${r}.`)
+        }), (n[Ht] || n[$n] ? 1 : 0) + (n[hi] || n[Rn] || n[di] ? 1 : 0) + (n[ls] ? 1 : 0) > 1 && q(`Incompatible time units: ${e}`), t.sort((r, s) => ev[r] - ev[s]), t
+    }
+    const Cj = {
+        [vn]: "%Y ",
+        [hi]: "Q%q ",
+        [Rn]: "%b ",
+        [di]: "%d ",
+        [Ht]: "W%U ",
+        [$n]: "%a ",
+        [ls]: "%j ",
+        [Oi]: "%H:00",
+        [Fi]: "00:%M",
+        [Xi]: ":%S",
+        [Ar]: ".%L",
+        [`${vn}-${Rn}`]: "%Y-%m ",
+        [`${vn}-${Rn}-${di}`]: "%Y-%m-%d ",
+        [`${Oi}-${Fi}`]: "%H:%M"
+    };
+
+    function DF(e, t) {
+        const n = Ne({}, Cj, t),
+            i = $_(e),
+            r = i.length;
+        let s = "",
+            a = 0,
+            o, l;
+        for (a = 0; a < r;)
+            for (o = i.length; o > a; --o)
+                if (l = i.slice(a, o).join("-"), n[l] != null) {
+                    s += n[l], a = o;
+                    break
+                } return s.trim()
+    }
+    const Ko = new Date;
+
+    function T_(e) {
+        return Ko.setFullYear(e), Ko.setMonth(0), Ko.setDate(1), Ko.setHours(0, 0, 0, 0), Ko
+    }
+
+    function NF(e) {
+        return LF(new Date(e))
+    }
+
+    function PF(e) {
+        return Wb(new Date(e))
+    }
+
+    function LF(e) {
+        return Ys.count(T_(e.getFullYear()) - 1, e)
+    }
+
+    function Wb(e) {
+        return Wc.count(T_(e.getFullYear()) - 1, e)
+    }
+
+    function qb(e) {
+        return T_(e).getDay()
+    }
+
+    function Aj(e, t, n, i, r, s, a) {
+        if (0 <= e && e < 100) {
+            const o = new Date(-1, t, n, i, r, s, a);
+            return o.setFullYear(e), o
         }
-        getHitCanvas() {
-            return this.hitCanvas
+        return new Date(e, t, n, i, r, s, a)
+    }
+
+    function IF(e) {
+        return BF(new Date(e))
+    }
+
+    function zF(e) {
+        return Hb(new Date(e))
+    }
+
+    function BF(e) {
+        const t = Date.UTC(e.getUTCFullYear(), 0, 1);
+        return Wa.count(t - 1, e)
+    }
+
+    function Hb(e) {
+        const t = Date.UTC(e.getUTCFullYear(), 0, 1);
+        return qc.count(t - 1, e)
+    }
+
+    function Yb(e) {
+        return Ko.setTime(Date.UTC(e, 0, 1)), Ko.getUTCDay()
+    }
+
+    function $j(e, t, n, i, r, s, a) {
+        if (0 <= e && e < 100) {
+            const o = new Date(Date.UTC(-1, t, n, i, r, s, a));
+            return o.setUTCFullYear(n.y), o
         }
-        getContext() {
-            return this.getCanvas().getContext()
+        return new Date(Date.UTC(e, t, n, i, r, s, a))
+    }
+
+    function jF(e, t, n, i, r) {
+        const s = t || 1,
+            a = We(e),
+            o = (y, v, b) => (b = b || y, Tj(n[b], i[b], y === a && s, v)),
+            l = new Date,
+            u = Cr(e),
+            c = u[vn] ? o(vn) : Ln(2012),
+            f = u[Rn] ? o(Rn) : u[hi] ? o(hi) : Ma,
+            h = u[Ht] && u[$n] ? o($n, 1, Ht + $n) : u[Ht] ? o(Ht, 1) : u[$n] ? o($n, 1) : u[di] ? o(di, 1) : u[ls] ? o(ls, 1) : Bc,
+            d = u[Oi] ? o(Oi) : Ma,
+            g = u[Fi] ? o(Fi) : Ma,
+            p = u[Xi] ? o(Xi) : Ma,
+            m = u[Ar] ? o(Ar) : Ma;
+        return function(y) {
+            l.setTime(+y);
+            const v = c(l);
+            return r(v, f(l), h(l, v), d(l), g(l), p(l), m(l))
         }
-        clear(t) {
-            return this.getContext().clear(t), this.getHitCanvas().getContext().clear(t), this
+    }
+
+    function Tj(e, t, n, i) {
+        const r = n <= 1 ? e : i ? (s, a) => i + n * Math.floor((e(s, a) - i) / n) : (s, a) => n * Math.floor(e(s, a) / n);
+        return t ? (s, a) => t(r(s, a), a) : r
+    }
+
+    function oc(e, t, n) {
+        return t + e * 7 - (n + 6) % 7
+    }
+    const Mj = {
+            [vn]: e => e.getFullYear(),
+            [hi]: e => Math.floor(e.getMonth() / 3),
+            [Rn]: e => e.getMonth(),
+            [di]: e => e.getDate(),
+            [Oi]: e => e.getHours(),
+            [Fi]: e => e.getMinutes(),
+            [Xi]: e => e.getSeconds(),
+            [Ar]: e => e.getMilliseconds(),
+            [ls]: e => LF(e),
+            [Ht]: e => Wb(e),
+            [Ht + $n]: (e, t) => oc(Wb(e), e.getDay(), qb(t)),
+            [$n]: (e, t) => oc(1, e.getDay(), qb(t))
+        },
+        Oj = {
+            [hi]: e => 3 * e,
+            [Ht]: (e, t) => oc(e, 0, qb(t))
+        };
+
+    function GF(e, t) {
+        return jF(e, t || 1, Mj, Oj, Aj)
+    }
+    const Fj = {
+            [vn]: e => e.getUTCFullYear(),
+            [hi]: e => Math.floor(e.getUTCMonth() / 3),
+            [Rn]: e => e.getUTCMonth(),
+            [di]: e => e.getUTCDate(),
+            [Oi]: e => e.getUTCHours(),
+            [Fi]: e => e.getUTCMinutes(),
+            [Xi]: e => e.getUTCSeconds(),
+            [Ar]: e => e.getUTCMilliseconds(),
+            [ls]: e => BF(e),
+            [Ht]: e => Hb(e),
+            [$n]: (e, t) => oc(1, e.getUTCDay(), Yb(t)),
+            [Ht + $n]: (e, t) => oc(Hb(e), e.getUTCDay(), Yb(t))
+        },
+        Rj = {
+            [hi]: e => 3 * e,
+            [Ht]: (e, t) => oc(e, 0, Yb(t))
+        };
+
+    function UF(e, t) {
+        return jF(e, t || 1, Fj, Rj, $j)
+    }
+    const Dj = {
+            [vn]: as,
+            [hi]: Wh.every(3),
+            [Rn]: Wh,
+            [Ht]: Wc,
+            [di]: Ys,
+            [$n]: Ys,
+            [ls]: Ys,
+            [Oi]: U0,
+            [Fi]: j0,
+            [Xi]: Gs,
+            [Ar]: rc
+        },
+        Nj = {
+            [vn]: os,
+            [hi]: qh.every(3),
+            [Rn]: qh,
+            [Ht]: qc,
+            [di]: Wa,
+            [$n]: Wa,
+            [ls]: Wa,
+            [Oi]: W0,
+            [Fi]: G0,
+            [Xi]: Gs,
+            [Ar]: rc
+        };
+
+    function Hc(e) {
+        return Dj[e]
+    }
+
+    function Yc(e) {
+        return Nj[e]
+    }
+
+    function WF(e, t, n) {
+        return e ? e.offset(t, n) : void 0
+    }
+
+    function qF(e, t, n) {
+        return WF(Hc(e), t, n)
+    }
+
+    function HF(e, t, n) {
+        return WF(Yc(e), t, n)
+    }
+
+    function YF(e, t, n, i) {
+        return e ? e.range(t, n, i) : void 0
+    }
+
+    function XF(e, t, n, i) {
+        return YF(Hc(e), t, n, i)
+    }
+
+    function VF(e, t, n, i) {
+        return YF(Yc(e), t, n, i)
+    }
+    const Vf = 1e3,
+        Kf = Vf * 60,
+        Jf = Kf * 60,
+        q0 = Jf * 24,
+        Pj = q0 * 7,
+        gA = q0 * 30,
+        Xb = q0 * 365,
+        KF = [vn, Rn, di, Oi, Fi, Xi, Ar],
+        Qf = KF.slice(0, -1),
+        Zf = Qf.slice(0, -1),
+        eh = Zf.slice(0, -1),
+        Lj = eh.slice(0, -1),
+        Ij = [vn, Ht],
+        pA = [vn, Rn],
+        JF = [vn],
+        bf = [
+            [Qf, 1, Vf],
+            [Qf, 5, 5 * Vf],
+            [Qf, 15, 15 * Vf],
+            [Qf, 30, 30 * Vf],
+            [Zf, 1, Kf],
+            [Zf, 5, 5 * Kf],
+            [Zf, 15, 15 * Kf],
+            [Zf, 30, 30 * Kf],
+            [eh, 1, Jf],
+            [eh, 3, 3 * Jf],
+            [eh, 6, 6 * Jf],
+            [eh, 12, 12 * Jf],
+            [Lj, 1, q0],
+            [Ij, 1, Pj],
+            [pA, 1, gA],
+            [pA, 3, 3 * gA],
+            [JF, 1, Xb]
+        ];
+
+    function QF(e) {
+        const t = e.extent,
+            n = e.maxbins || 40,
+            i = Math.abs(Cd(t)) / n;
+        let r = Ad(o => o[2]).right(bf, i),
+            s, a;
+        return r === bf.length ? (s = JF, a = Qa(t[0] / Xb, t[1] / Xb, n)) : r ? (r = bf[i / bf[r - 1][2] < bf[r][2] / i ? r - 1 : r], s = r[0], a = r[1]) : (s = KF, a = Math.max(Qa(t[0], t[1], n), 1)), {
+            units: s,
+            step: a
         }
-        setZIndex(t) {
-            super.setZIndex(t);
-            var n = this.getStage();
-            return n && n.content && (n.content.removeChild(this.getNativeCanvasElement()), t < n.children.length - 1 ? n.content.insertBefore(this.getNativeCanvasElement(), n.children[t + 1].getCanvas()._canvas) : n.content.appendChild(this.getNativeCanvasElement())), this
+    }
+
+    function tv(e) {
+        if (0 <= e.y && e.y < 100) {
+            var t = new Date(-1, e.m, e.d, e.H, e.M, e.S, e.L);
+            return t.setFullYear(e.y), t
         }
-        moveToTop() {
-            ne.prototype.moveToTop.call(this);
-            var t = this.getStage();
-            return t && t.content && (t.content.removeChild(this.getNativeCanvasElement()), t.content.appendChild(this.getNativeCanvasElement())), !0
+        return new Date(e.y, e.m, e.d, e.H, e.M, e.S, e.L)
+    }
+
+    function nv(e) {
+        if (0 <= e.y && e.y < 100) {
+            var t = new Date(Date.UTC(-1, e.m, e.d, e.H, e.M, e.S, e.L));
+            return t.setUTCFullYear(e.y), t
         }
-        moveUp() {
-            var t = ne.prototype.moveUp.call(this);
-            if (!t) return !1;
-            var n = this.getStage();
-            return !n || !n.content ? !1 : (n.content.removeChild(this.getNativeCanvasElement()), this.index < n.children.length - 1 ? n.content.insertBefore(this.getNativeCanvasElement(), n.children[this.index + 1].getCanvas()._canvas) : n.content.appendChild(this.getNativeCanvasElement()), !0)
+        return new Date(Date.UTC(e.y, e.m, e.d, e.H, e.M, e.S, e.L))
+    }
+
+    function xf(e, t, n) {
+        return {
+            y: e,
+            m: t,
+            d: n,
+            H: 0,
+            M: 0,
+            S: 0,
+            L: 0
         }
-        moveDown() {
-            if (ne.prototype.moveDown.call(this)) {
-                var t = this.getStage();
-                if (t) {
-                    var n = t.children;
-                    t.content && (t.content.removeChild(this.getNativeCanvasElement()), t.content.insertBefore(this.getNativeCanvasElement(), n[this.index + 1].getCanvas()._canvas))
-                }
-                return !0
+    }
+
+    function ZF(e) {
+        var t = e.dateTime,
+            n = e.date,
+            i = e.time,
+            r = e.periods,
+            s = e.days,
+            a = e.shortDays,
+            o = e.months,
+            l = e.shortMonths,
+            u = _f(r),
+            c = wf(r),
+            f = _f(s),
+            h = wf(s),
+            d = _f(a),
+            g = wf(a),
+            p = _f(o),
+            m = wf(o),
+            y = _f(l),
+            v = wf(l),
+            b = {
+                a: N,
+                A: L,
+                b: I,
+                B: G,
+                c: null,
+                d: _A,
+                e: _A,
+                f: oG,
+                g: yG,
+                G: bG,
+                H: rG,
+                I: sG,
+                j: aG,
+                L: eR,
+                m: lG,
+                M: uG,
+                p: ie,
+                q: ge,
+                Q: EA,
+                s: kA,
+                S: cG,
+                u: fG,
+                U: hG,
+                V: dG,
+                w: gG,
+                W: pG,
+                x: null,
+                X: null,
+                y: mG,
+                Y: vG,
+                Z: xG,
+                "%": SA
+            },
+            x = {
+                a: Re,
+                A: Te,
+                b: tt,
+                B: wn,
+                c: null,
+                d: wA,
+                e: wA,
+                f: EG,
+                g: DG,
+                G: PG,
+                H: _G,
+                I: wG,
+                j: SG,
+                L: nR,
+                m: kG,
+                M: CG,
+                p: Pi,
+                q: xi,
+                Q: EA,
+                s: kA,
+                S: AG,
+                u: $G,
+                U: TG,
+                V: MG,
+                w: OG,
+                W: FG,
+                x: null,
+                X: null,
+                y: RG,
+                Y: NG,
+                Z: LG,
+                "%": SA
+            },
+            _ = {
+                a: k,
+                A,
+                b: F,
+                B: $,
+                c: T,
+                d: bA,
+                e: bA,
+                f: eG,
+                g: vA,
+                G: yA,
+                H: xA,
+                I: xA,
+                j: Kj,
+                L: Zj,
+                m: Vj,
+                M: Jj,
+                p: C,
+                q: Xj,
+                Q: nG,
+                s: iG,
+                S: Qj,
+                u: Uj,
+                U: Wj,
+                V: qj,
+                w: Gj,
+                W: Hj,
+                x: M,
+                X: R,
+                y: vA,
+                Y: yA,
+                Z: Yj,
+                "%": tG
+            };
+        b.x = S(n, b), b.X = S(i, b), b.c = S(t, b), x.x = S(n, x), x.X = S(i, x), x.c = S(t, x);
+
+        function S(ae, _e) {
+            return function(Ae) {
+                var Y = [],
+                    je = -1,
+                    be = 0,
+                    qe = ae.length,
+                    dn, $s, Do;
+                for (Ae instanceof Date || (Ae = new Date(+Ae)); ++je < qe;) ae.charCodeAt(je) === 37 && (Y.push(ae.slice(be, je)), ($s = mA[dn = ae.charAt(++je)]) != null ? dn = ae.charAt(++je) : $s = dn === "e" ? " " : "0", (Do = _e[dn]) && (dn = Do(Ae, $s)), Y.push(dn), be = je + 1);
+                return Y.push(ae.slice(be, je)), Y.join("")
             }
-            return !1
         }
-        moveToBottom() {
-            if (ne.prototype.moveToBottom.call(this)) {
-                var t = this.getStage();
-                if (t) {
-                    var n = t.children;
-                    t.content && (t.content.removeChild(this.getNativeCanvasElement()), t.content.insertBefore(this.getNativeCanvasElement(), n[1].getCanvas()._canvas))
-                }
-                return !0
+
+        function w(ae, _e) {
+            return function(Ae) {
+                var Y = xf(1900, void 0, 1),
+                    je = E(Y, ae, Ae += "", 0),
+                    be, qe;
+                if (je != Ae.length) return null;
+                if ("Q" in Y) return new Date(Y.Q);
+                if ("s" in Y) return new Date(Y.s * 1e3 + ("L" in Y ? Y.L : 0));
+                if (_e && !("Z" in Y) && (Y.Z = 0), "p" in Y && (Y.H = Y.H % 12 + Y.p * 12), Y.m === void 0 && (Y.m = "q" in Y ? Y.q : 0), "V" in Y) {
+                    if (Y.V < 1 || Y.V > 53) return null;
+                    "w" in Y || (Y.w = 1), "Z" in Y ? (be = nv(xf(Y.y, 0, 1)), qe = be.getUTCDay(), be = qe > 4 || qe === 0 ? om.ceil(be) : om(be), be = Wa.offset(be, (Y.V - 1) * 7), Y.y = be.getUTCFullYear(), Y.m = be.getUTCMonth(), Y.d = be.getUTCDate() + (Y.w + 6) % 7) : (be = tv(xf(Y.y, 0, 1)), qe = be.getDay(), be = qe > 4 || qe === 0 ? am.ceil(be) : am(be), be = Ys.offset(be, (Y.V - 1) * 7), Y.y = be.getFullYear(), Y.m = be.getMonth(), Y.d = be.getDate() + (Y.w + 6) % 7)
+                } else("W" in Y || "U" in Y) && ("w" in Y || (Y.w = "u" in Y ? Y.u % 7 : "W" in Y ? 1 : 0), qe = "Z" in Y ? nv(xf(Y.y, 0, 1)).getUTCDay() : tv(xf(Y.y, 0, 1)).getDay(), Y.m = 0, Y.d = "W" in Y ? (Y.w + 6) % 7 + Y.W * 7 - (qe + 5) % 7 : Y.w + Y.U * 7 - (qe + 6) % 7);
+                return "Z" in Y ? (Y.H += Y.Z / 100 | 0, Y.M += Y.Z % 100, nv(Y)) : tv(Y)
             }
-            return !1
         }
-        getLayer() {
-            return this
+
+        function E(ae, _e, Ae, Y) {
+            for (var je = 0, be = _e.length, qe = Ae.length, dn, $s; je < be;) {
+                if (Y >= qe) return -1;
+                if (dn = _e.charCodeAt(je++), dn === 37) {
+                    if (dn = _e.charAt(je++), $s = _[dn in mA ? _e.charAt(je++) : dn], !$s || (Y = $s(ae, Ae, Y)) < 0) return -1
+                } else if (dn != Ae.charCodeAt(Y++)) return -1
+            }
+            return Y
         }
-        remove() {
-            var t = this.getNativeCanvasElement();
-            return ne.prototype.remove.call(this), t && t.parentNode && D._isInDocument(t) && t.parentNode.removeChild(t), this
+
+        function C(ae, _e, Ae) {
+            var Y = u.exec(_e.slice(Ae));
+            return Y ? (ae.p = c.get(Y[0].toLowerCase()), Ae + Y[0].length) : -1
         }
-        getStage() {
-            return this.parent
+
+        function k(ae, _e, Ae) {
+            var Y = d.exec(_e.slice(Ae));
+            return Y ? (ae.w = g.get(Y[0].toLowerCase()), Ae + Y[0].length) : -1
         }
-        setSize({
-            width: t,
-            height: n
-        }) {
-            return this.canvas.setSize(t, n), this.hitCanvas.setSize(t, n), this._setSmoothEnabled(), this
+
+        function A(ae, _e, Ae) {
+            var Y = f.exec(_e.slice(Ae));
+            return Y ? (ae.w = h.get(Y[0].toLowerCase()), Ae + Y[0].length) : -1
         }
-        _validateAdd(t) {
-            var n = t.getType();
-            n !== "Group" && n !== "Shape" && D.throw("You may only add groups and shapes to a layer.")
+
+        function F(ae, _e, Ae) {
+            var Y = y.exec(_e.slice(Ae));
+            return Y ? (ae.m = v.get(Y[0].toLowerCase()), Ae + Y[0].length) : -1
         }
-        _toKonvaCanvas(t) {
-            return t = t || {}, t.width = t.width || this.getWidth(), t.height = t.height || this.getHeight(), t.x = t.x !== void 0 ? t.x : this.x(), t.y = t.y !== void 0 ? t.y : this.y(), ne.prototype._toKonvaCanvas.call(this, t)
+
+        function $(ae, _e, Ae) {
+            var Y = p.exec(_e.slice(Ae));
+            return Y ? (ae.m = m.get(Y[0].toLowerCase()), Ae + Y[0].length) : -1
         }
-        _checkVisibility() {
-            this.visible() ? this.canvas._canvas.style.display = "block" : this.canvas._canvas.style.display = "none"
+
+        function T(ae, _e, Ae) {
+            return E(ae, t, _e, Ae)
         }
-        _setSmoothEnabled() {
-            this.getContext()._context.imageSmoothingEnabled = this.imageSmoothingEnabled()
+
+        function M(ae, _e, Ae) {
+            return E(ae, n, _e, Ae)
         }
-        getWidth() {
-            if (this.parent) return this.parent.width()
+
+        function R(ae, _e, Ae) {
+            return E(ae, i, _e, Ae)
         }
-        setWidth() {
-            D.warn('Can not change width of layer. Use "stage.width(value)" function instead.')
+
+        function N(ae) {
+            return a[ae.getDay()]
         }
-        getHeight() {
-            if (this.parent) return this.parent.height()
+
+        function L(ae) {
+            return s[ae.getDay()]
         }
-        setHeight() {
-            D.warn('Can not change height of layer. Use "stage.height(value)" function instead.')
+
+        function I(ae) {
+            return l[ae.getMonth()]
         }
-        batchDraw() {
-            return this._waitingForDraw || (this._waitingForDraw = !0, D.requestAnimFrame(() => {
-                this.draw(), this._waitingForDraw = !1
-            })), this
+
+        function G(ae) {
+            return o[ae.getMonth()]
         }
-        getIntersection(t) {
-            if (!this.isListening() || !this.isVisible()) return null;
-            for (var n = 1, i = !1;;) {
-                for (let r = 0; r < c7; r++) {
-                    const s = YM[r],
-                        a = this._getIntersection({
-                            x: t.x + s.x * n,
-                            y: t.y + s.y * n
-                        }),
-                        o = a.shape;
-                    if (o) return o;
-                    if (i = !!a.antialiased, !a.antialiased) break
-                }
-                if (i) n += 1;
-                else return null
-            }
+
+        function ie(ae) {
+            return r[+(ae.getHours() >= 12)]
         }
-        _getIntersection(t) {
-            const n = this.hitCanvas.pixelRatio,
-                i = this.hitCanvas.context.getImageData(Math.round(t.x * n), Math.round(t.y * n), 1, 1).data,
-                r = i[3];
-            if (r === 255) {
-                const s = D._rgbToHex(i[0], i[1], i[2]),
-                    a = Xf[o7 + s];
-                return a ? {
-                    shape: a
-                } : {
-                    antialiased: !0
-                }
-            } else if (r > 0) return {
-                antialiased: !0
-            };
-            return {}
+
+        function ge(ae) {
+            return 1 + ~~(ae.getMonth() / 3)
         }
-        drawScene(t, n) {
-            var i = this.getLayer(),
-                r = t || i && i.getCanvas();
-            return this._fire(l7, {
-                node: this
-            }), this.clearBeforeDraw() && r.getContext().clear(), mi.prototype.drawScene.call(this, r, n), this._fire(u7, {
-                node: this
-            }), this
+
+        function Re(ae) {
+            return a[ae.getUTCDay()]
         }
-        drawHit(t, n) {
-            var i = this.getLayer(),
-                r = t || i && i.hitCanvas;
-            return i && i.clearBeforeDraw() && i.getHitCanvas().getContext().clear(), mi.prototype.drawHit.call(this, r, n), this
+
+        function Te(ae) {
+            return s[ae.getUTCDay()]
         }
-        enableHitGraph() {
-            return this.hitGraphEnabled(!0), this
+
+        function tt(ae) {
+            return l[ae.getUTCMonth()]
         }
-        disableHitGraph() {
-            return this.hitGraphEnabled(!1), this
+
+        function wn(ae) {
+            return o[ae.getUTCMonth()]
         }
-        setHitGraphEnabled(t) {
-            D.warn("hitGraphEnabled method is deprecated. Please use layer.listening() instead."), this.listening(t)
+
+        function Pi(ae) {
+            return r[+(ae.getUTCHours() >= 12)]
         }
-        getHitGraphEnabled(t) {
-            return D.warn("hitGraphEnabled method is deprecated. Please use layer.listening() instead."), this.listening()
+
+        function xi(ae) {
+            return 1 + ~~(ae.getUTCMonth() / 3)
         }
-        toggleHitCanvas() {
-            if (!(!this.parent || !this.parent.content)) {
-                var t = this.parent,
-                    n = !!this.hitCanvas._canvas.parentNode;
-                n ? t.content.removeChild(this.hitCanvas._canvas) : t.content.appendChild(this.hitCanvas._canvas)
+        return {
+            format: function(ae) {
+                var _e = S(ae += "", b);
+                return _e.toString = function() {
+                    return ae
+                }, _e
+            },
+            parse: function(ae) {
+                var _e = w(ae += "", !1);
+                return _e.toString = function() {
+                    return ae
+                }, _e
+            },
+            utcFormat: function(ae) {
+                var _e = S(ae += "", x);
+                return _e.toString = function() {
+                    return ae
+                }, _e
+            },
+            utcParse: function(ae) {
+                var _e = w(ae += "", !0);
+                return _e.toString = function() {
+                    return ae
+                }, _e
             }
         }
-        destroy() {
-            return D.releaseCanvas(this.getNativeCanvasElement(), this.getHitCanvas()._canvas), super.destroy()
-        }
     }
-    xl.prototype.nodeType = "Layer";
-    pt(xl);
-    O.addGetterSetter(xl, "imageSmoothingEnabled", !0);
-    O.addGetterSetter(xl, "clearBeforeDraw", !0);
-    O.addGetterSetter(xl, "hitGraphEnabled", !0, mr());
-    class bx extends xl {
-        constructor(t) {
-            super(t), this.listening(!1), D.warn('Konva.Fast layer is deprecated. Please use "new Konva.Layer({ listening: false })" instead.')
-        }
+    var mA = {
+            "-": "",
+            _: " ",
+            0: "0"
+        },
+        hn = /^\s*\d+/,
+        zj = /^%/,
+        Bj = /[\\^$*+?|[\]().{}]/g;
+
+    function Qe(e, t, n) {
+        var i = e < 0 ? "-" : "",
+            r = (i ? -e : e) + "",
+            s = r.length;
+        return i + (s < n ? new Array(n - s + 1).join(t) + r : r)
     }
-    bx.prototype.nodeType = "FastLayer";
-    pt(bx);
-    let Mu = class extends mi {
-        _validateAdd(t) {
-            var n = t.getType();
-            n !== "Group" && n !== "Shape" && D.throw("You may only add groups and shapes to groups.")
-        }
-    };
-    Mu.prototype.nodeType = "Group";
-    pt(Mu);
-    var gy = function() {
-        return yu.performance && yu.performance.now ? function() {
-            return yu.performance.now()
-        } : function() {
-            return new Date().getTime()
-        }
-    }();
-    class Ci {
-        constructor(t, n) {
-            this.id = Ci.animIdCounter++, this.frame = {
-                time: 0,
-                timeDiff: 0,
-                lastTime: gy(),
-                frameRate: 0
-            }, this.func = t, this.setLayers(n)
-        }
-        setLayers(t) {
-            var n = [];
-            return t ? t.length > 0 ? n = t : n = [t] : n = [], this.layers = n, this
-        }
-        getLayers() {
-            return this.layers
-        }
-        addLayer(t) {
-            var n = this.layers,
-                i = n.length,
-                r;
-            for (r = 0; r < i; r++)
-                if (n[r]._id === t._id) return !1;
-            return this.layers.push(t), !0
-        }
-        isRunning() {
-            var t = Ci,
-                n = t.animations,
-                i = n.length,
-                r;
-            for (r = 0; r < i; r++)
-                if (n[r].id === this.id) return !0;
-            return !1
-        }
-        start() {
-            return this.stop(), this.frame.timeDiff = 0, this.frame.lastTime = gy(), Ci._addAnimation(this), this
-        }
-        stop() {
-            return Ci._removeAnimation(this), this
-        }
-        _updateFrameObject(t) {
-            this.frame.timeDiff = t - this.frame.lastTime, this.frame.lastTime = t, this.frame.time += this.frame.timeDiff, this.frame.frameRate = 1e3 / this.frame.timeDiff
-        }
-        static _addAnimation(t) {
-            this.animations.push(t), this._handleAnimation()
-        }
-        static _removeAnimation(t) {
-            var n = t.id,
-                i = this.animations,
-                r = i.length,
-                s;
-            for (s = 0; s < r; s++)
-                if (i[s].id === n) {
-                    this.animations.splice(s, 1);
-                    break
-                }
-        }
-        static _runFrames() {
-            var t = {},
-                n = this.animations,
-                i, r, s, a, o, l, u, c, f;
-            for (a = 0; a < n.length; a++)
-                if (i = n[a], r = i.layers, s = i.func, i._updateFrameObject(gy()), l = r.length, s ? f = s.call(i, i.frame) !== !1 : f = !0, !!f)
-                    for (o = 0; o < l; o++) u = r[o], u._id !== void 0 && (t[u._id] = u);
-            for (c in t) t.hasOwnProperty(c) && t[c].batchDraw()
-        }
-        static _animationLoop() {
-            var t = Ci;
-            t.animations.length ? (t._runFrames(), D.requestAnimFrame(t._animationLoop)) : t.animRunning = !1
-        }
-        static _handleAnimation() {
-            this.animRunning || (this.animRunning = !0, D.requestAnimFrame(this._animationLoop))
-        }
+
+    function jj(e) {
+        return e.replace(Bj, "\\$&")
     }
-    Ci.animations = [];
-    Ci.animIdCounter = 0;
-    Ci.animRunning = !1;
-    var f7 = {
-            node: 1,
-            duration: 1,
-            easing: 1,
-            onFinish: 1,
-            yoyo: 1
-        },
-        h7 = 1,
-        hk = 2,
-        dk = 3,
-        d7 = 0,
-        gk = ["fill", "stroke", "shadowColor"];
-    class g7 {
-        constructor(t, n, i, r, s, a, o) {
-            this.prop = t, this.propFunc = n, this.begin = r, this._pos = r, this.duration = a, this._change = 0, this.prevPos = 0, this.yoyo = o, this._time = 0, this._position = 0, this._startTime = 0, this._finish = 0, this.func = i, this._change = s - this.begin, this.pause()
-        }
-        fire(t) {
-            var n = this[t];
-            n && n()
-        }
-        setTime(t) {
-            t > this.duration ? this.yoyo ? (this._time = this.duration, this.reverse()) : this.finish() : t < 0 ? this.yoyo ? (this._time = 0, this.play()) : this.reset() : (this._time = t, this.update())
-        }
-        getTime() {
-            return this._time
-        }
-        setPosition(t) {
-            this.prevPos = this._pos, this.propFunc(t), this._pos = t
-        }
-        getPosition(t) {
-            return t === void 0 && (t = this._time), this.func(t, this.begin, this._change, this.duration)
-        }
-        play() {
-            this.state = hk, this._startTime = this.getTimer() - this._time, this.onEnterFrame(), this.fire("onPlay")
-        }
-        reverse() {
-            this.state = dk, this._time = this.duration - this._time, this._startTime = this.getTimer() - this._time, this.onEnterFrame(), this.fire("onReverse")
-        }
-        seek(t) {
-            this.pause(), this._time = t, this.update(), this.fire("onSeek")
-        }
-        reset() {
-            this.pause(), this._time = 0, this.update(), this.fire("onReset")
-        }
-        finish() {
-            this.pause(), this._time = this.duration, this.update(), this.fire("onFinish")
-        }
-        update() {
-            this.setPosition(this.getPosition(this._time)), this.fire("onUpdate")
-        }
-        onEnterFrame() {
-            var t = this.getTimer() - this._startTime;
-            this.state === hk ? this.setTime(t) : this.state === dk && this.setTime(this.duration - t)
-        }
-        pause() {
-            this.state = h7, this.fire("onPause")
-        }
-        getTimer() {
-            return new Date().getTime()
-        }
+
+    function _f(e) {
+        return new RegExp("^(?:" + e.map(jj).join("|") + ")", "i")
     }
-    class _t {
-        constructor(t) {
-            var n = this,
-                i = t.node,
-                r = i._id,
-                s, a = t.easing || Vf.Linear,
-                o = !!t.yoyo,
-                l;
-            typeof t.duration > "u" ? s = .3 : t.duration === 0 ? s = .001 : s = t.duration, this.node = i, this._id = d7++;
-            var u = i.getLayer() || (i instanceof le.Stage ? i.getLayers() : null);
-            u || D.error("Tween constructor have `node` that is not in a layer. Please add node into layer first."), this.anim = new Ci(function() {
-                n.tween.onEnterFrame()
-            }, u), this.tween = new g7(l, function(c) {
-                n._tweenFunc(c)
-            }, a, 0, 1, s * 1e3, o), this._addListeners(), _t.attrs[r] || (_t.attrs[r] = {}), _t.attrs[r][this._id] || (_t.attrs[r][this._id] = {}), _t.tweens[r] || (_t.tweens[r] = {});
-            for (l in t) f7[l] === void 0 && this._addAttr(l, t[l]);
-            this.reset(), this.onFinish = t.onFinish, this.onReset = t.onReset, this.onUpdate = t.onUpdate
-        }
-        _addAttr(t, n) {
-            var i = this.node,
-                r = i._id,
-                s, a, o, l, u, c, f, h;
-            if (o = _t.tweens[r][t], o && delete _t.attrs[r][o][t], s = i.getAttr(t), D._isArray(n))
-                if (a = [], u = Math.max(n.length, s.length), t === "points" && n.length !== s.length && (n.length > s.length ? (f = s, s = D._prepareArrayForTween(s, n, i.closed())) : (c = n, n = D._prepareArrayForTween(n, s, i.closed()))), t.indexOf("fill") === 0)
-                    for (l = 0; l < u; l++)
-                        if (l % 2 === 0) a.push(n[l] - s[l]);
-                        else {
-                            var d = D.colorToRGBA(s[l]);
-                            h = D.colorToRGBA(n[l]), s[l] = d, a.push({
-                                r: h.r - d.r,
-                                g: h.g - d.g,
-                                b: h.b - d.b,
-                                a: h.a - d.a
-                            })
-                        }
-            else
-                for (l = 0; l < u; l++) a.push(n[l] - s[l]);
-            else gk.indexOf(t) !== -1 ? (s = D.colorToRGBA(s), h = D.colorToRGBA(n), a = {
-                r: h.r - s.r,
-                g: h.g - s.g,
-                b: h.b - s.b,
-                a: h.a - s.a
-            }) : a = n - s;
-            _t.attrs[r][this._id][t] = {
-                start: s,
-                diff: a,
-                end: n,
-                trueEnd: c,
-                trueStart: f
-            }, _t.tweens[r][t] = this._id
-        }
-        _tweenFunc(t) {
-            var n = this.node,
-                i = _t.attrs[n._id][this._id],
-                r, s, a, o, l, u, c, f;
-            for (r in i) {
-                if (s = i[r], a = s.start, o = s.diff, f = s.end, D._isArray(a))
-                    if (l = [], c = Math.max(a.length, f.length), r.indexOf("fill") === 0)
-                        for (u = 0; u < c; u++) u % 2 === 0 ? l.push((a[u] || 0) + o[u] * t) : l.push("rgba(" + Math.round(a[u].r + o[u].r * t) + "," + Math.round(a[u].g + o[u].g * t) + "," + Math.round(a[u].b + o[u].b * t) + "," + (a[u].a + o[u].a * t) + ")");
-                    else
-                        for (u = 0; u < c; u++) l.push((a[u] || 0) + o[u] * t);
-                else gk.indexOf(r) !== -1 ? l = "rgba(" + Math.round(a.r + o.r * t) + "," + Math.round(a.g + o.g * t) + "," + Math.round(a.b + o.b * t) + "," + (a.a + o.a * t) + ")" : l = a + o * t;
-                n.setAttr(r, l)
-            }
-        }
-        _addListeners() {
-            this.tween.onPlay = () => {
-                this.anim.start()
-            }, this.tween.onReverse = () => {
-                this.anim.start()
-            }, this.tween.onPause = () => {
-                this.anim.stop()
-            }, this.tween.onFinish = () => {
-                var t = this.node,
-                    n = _t.attrs[t._id][this._id];
-                n.points && n.points.trueEnd && t.setAttr("points", n.points.trueEnd), this.onFinish && this.onFinish.call(this)
-            }, this.tween.onReset = () => {
-                var t = this.node,
-                    n = _t.attrs[t._id][this._id];
-                n.points && n.points.trueStart && t.points(n.points.trueStart), this.onReset && this.onReset()
-            }, this.tween.onUpdate = () => {
-                this.onUpdate && this.onUpdate.call(this)
-            }
-        }
-        play() {
-            return this.tween.play(), this
-        }
-        reverse() {
-            return this.tween.reverse(), this
-        }
-        reset() {
-            return this.tween.reset(), this
-        }
-        seek(t) {
-            return this.tween.seek(t * 1e3), this
-        }
-        pause() {
-            return this.tween.pause(), this
-        }
-        finish() {
-            return this.tween.finish(), this
-        }
-        destroy() {
-            var t = this.node._id,
-                n = this._id,
-                i = _t.tweens[t],
-                r;
-            this.pause();
-            for (r in i) delete _t.tweens[t][r];
-            delete _t.attrs[t][n]
-        }
+
+    function wf(e) {
+        return new Map(e.map((t, n) => [t.toLowerCase(), n]))
     }
-    _t.attrs = {};
-    _t.tweens = {};
-    ne.prototype.to = function(e) {
-        var t = e.onFinish;
-        e.node = this, e.onFinish = function() {
-            this.destroy(), t && t()
-        };
-        var n = new _t(e);
-        n.play()
-    };
-    const Vf = {
-            BackEaseIn(e, t, n, i) {
-                var r = 1.70158;
-                return n * (e /= i) * e * ((r + 1) * e - r) + t
-            },
-            BackEaseOut(e, t, n, i) {
-                var r = 1.70158;
-                return n * ((e = e / i - 1) * e * ((r + 1) * e + r) + 1) + t
-            },
-            BackEaseInOut(e, t, n, i) {
-                var r = 1.70158;
-                return (e /= i / 2) < 1 ? n / 2 * (e * e * (((r *= 1.525) + 1) * e - r)) + t : n / 2 * ((e -= 2) * e * (((r *= 1.525) + 1) * e + r) + 2) + t
-            },
-            ElasticEaseIn(e, t, n, i, r, s) {
-                var a = 0;
-                return e === 0 ? t : (e /= i) === 1 ? t + n : (s || (s = i * .3), !r || r < Math.abs(n) ? (r = n, a = s / 4) : a = s / (2 * Math.PI) * Math.asin(n / r), -(r * Math.pow(2, 10 * (e -= 1)) * Math.sin((e * i - a) * (2 * Math.PI) / s)) + t)
-            },
-            ElasticEaseOut(e, t, n, i, r, s) {
-                var a = 0;
-                return e === 0 ? t : (e /= i) === 1 ? t + n : (s || (s = i * .3), !r || r < Math.abs(n) ? (r = n, a = s / 4) : a = s / (2 * Math.PI) * Math.asin(n / r), r * Math.pow(2, -10 * e) * Math.sin((e * i - a) * (2 * Math.PI) / s) + n + t)
-            },
-            ElasticEaseInOut(e, t, n, i, r, s) {
-                var a = 0;
-                return e === 0 ? t : (e /= i / 2) === 2 ? t + n : (s || (s = i * (.3 * 1.5)), !r || r < Math.abs(n) ? (r = n, a = s / 4) : a = s / (2 * Math.PI) * Math.asin(n / r), e < 1 ? -.5 * (r * Math.pow(2, 10 * (e -= 1)) * Math.sin((e * i - a) * (2 * Math.PI) / s)) + t : r * Math.pow(2, -10 * (e -= 1)) * Math.sin((e * i - a) * (2 * Math.PI) / s) * .5 + n + t)
-            },
-            BounceEaseOut(e, t, n, i) {
-                return (e /= i) < 1 / 2.75 ? n * (7.5625 * e * e) + t : e < 2 / 2.75 ? n * (7.5625 * (e -= 1.5 / 2.75) * e + .75) + t : e < 2.5 / 2.75 ? n * (7.5625 * (e -= 2.25 / 2.75) * e + .9375) + t : n * (7.5625 * (e -= 2.625 / 2.75) * e + .984375) + t
-            },
-            BounceEaseIn(e, t, n, i) {
-                return n - Vf.BounceEaseOut(i - e, 0, n, i) + t
-            },
-            BounceEaseInOut(e, t, n, i) {
-                return e < i / 2 ? Vf.BounceEaseIn(e * 2, 0, n, i) * .5 + t : Vf.BounceEaseOut(e * 2 - i, 0, n, i) * .5 + n * .5 + t
-            },
-            EaseIn(e, t, n, i) {
-                return n * (e /= i) * e + t
-            },
-            EaseOut(e, t, n, i) {
-                return -n * (e /= i) * (e - 2) + t
-            },
-            EaseInOut(e, t, n, i) {
-                return (e /= i / 2) < 1 ? n / 2 * e * e + t : -n / 2 * (--e * (e - 2) - 1) + t
-            },
-            StrongEaseIn(e, t, n, i) {
-                return n * (e /= i) * e * e * e * e + t
-            },
-            StrongEaseOut(e, t, n, i) {
-                return n * ((e = e / i - 1) * e * e * e * e + 1) + t
-            },
-            StrongEaseInOut(e, t, n, i) {
-                return (e /= i / 2) < 1 ? n / 2 * e * e * e * e * e + t : n / 2 * ((e -= 2) * e * e * e * e + 2) + t
-            },
-            Linear(e, t, n, i) {
-                return n * e / i + t
-            }
-        },
-        pk = D._assign(le, {
-            Util: D,
-            Transform: Ki,
-            Node: ne,
-            Container: mi,
-            Stage: nm,
-            stages: Wg,
-            Layer: xl,
-            FastLayer: bx,
-            Group: Mu,
-            DD: je,
-            Shape: V,
-            shapes: Xf,
-            Animation: Ci,
-            Tween: _t,
-            Easings: Vf,
-            Context: em,
-            Canvas: tm
-        });
-    class Us extends V {
-        _sceneFunc(t) {
-            var n = le.getAngle(this.angle()),
-                i = this.clockwise();
-            t.beginPath(), t.arc(0, 0, this.outerRadius(), 0, n, i), t.arc(0, 0, this.innerRadius(), n, 0, !i), t.closePath(), t.fillStrokeShape(this)
-        }
-        getWidth() {
-            return this.outerRadius() * 2
-        }
-        getHeight() {
-            return this.outerRadius() * 2
-        }
-        setWidth(t) {
-            this.outerRadius(t / 2)
-        }
-        setHeight(t) {
-            this.outerRadius(t / 2)
-        }
-        getSelfRect() {
-            const t = this.innerRadius(),
-                n = this.outerRadius(),
-                i = this.clockwise(),
-                r = le.getAngle(i ? 360 - this.angle() : this.angle()),
-                s = Math.cos(Math.min(r, Math.PI)),
-                a = 1,
-                o = Math.sin(Math.min(Math.max(Math.PI, r), 3 * Math.PI / 2)),
-                l = Math.sin(Math.min(r, Math.PI / 2)),
-                u = s * (s > 0 ? t : n),
-                c = a * n,
-                f = o * (o > 0 ? t : n),
-                h = l * (l > 0 ? n : t);
-            return {
-                x: u,
-                y: i ? -1 * h : f,
-                width: c - u,
-                height: h - f
-            }
-        }
+
+    function Gj(e, t, n) {
+        var i = hn.exec(t.slice(n, n + 1));
+        return i ? (e.w = +i[0], n + i[0].length) : -1
     }
-    Us.prototype._centroid = !0;
-    Us.prototype.className = "Arc";
-    Us.prototype._attrsAffectingSize = ["innerRadius", "outerRadius"];
-    pt(Us);
-    O.addGetterSetter(Us, "innerRadius", 0, te());
-    O.addGetterSetter(Us, "outerRadius", 0, te());
-    O.addGetterSetter(Us, "angle", 0, te());
-    O.addGetterSetter(Us, "clockwise", !1, mr());
 
-    function Qv(e, t, n, i, r, s, a) {
-        var o = Math.sqrt(Math.pow(n - e, 2) + Math.pow(i - t, 2)),
-            l = Math.sqrt(Math.pow(r - n, 2) + Math.pow(s - i, 2)),
-            u = a * o / (o + l),
-            c = a * l / (o + l),
-            f = n - u * (r - e),
-            h = i - u * (s - t),
-            d = n + c * (r - e),
-            g = i + c * (s - t);
-        return [f, h, d, g]
+    function Uj(e, t, n) {
+        var i = hn.exec(t.slice(n, n + 1));
+        return i ? (e.u = +i[0], n + i[0].length) : -1
     }
 
-    function mk(e, t) {
-        var n = e.length,
-            i = [],
-            r, s;
-        for (r = 2; r < n - 2; r += 2) s = Qv(e[r - 2], e[r - 1], e[r], e[r + 1], e[r + 2], e[r + 3], t), !isNaN(s[0]) && (i.push(s[0]), i.push(s[1]), i.push(e[r]), i.push(e[r + 1]), i.push(s[2]), i.push(s[3]));
-        return i
+    function Wj(e, t, n) {
+        var i = hn.exec(t.slice(n, n + 2));
+        return i ? (e.U = +i[0], n + i[0].length) : -1
     }
-    class Gs extends V {
-        constructor(t) {
-            super(t), this.on("pointsChange.konva tensionChange.konva closedChange.konva bezierChange.konva", function() {
-                this._clearCache("tensionPoints")
-            })
-        }
-        _sceneFunc(t) {
-            var n = this.points(),
-                i = n.length,
-                r = this.tension(),
-                s = this.closed(),
-                a = this.bezier(),
-                o, l, u;
-            if (i) {
-                if (t.beginPath(), t.moveTo(n[0], n[1]), r !== 0 && i > 4) {
-                    for (o = this.getTensionPoints(), l = o.length, u = s ? 0 : 4, s || t.quadraticCurveTo(o[0], o[1], o[2], o[3]); u < l - 2;) t.bezierCurveTo(o[u++], o[u++], o[u++], o[u++], o[u++], o[u++]);
-                    s || t.quadraticCurveTo(o[l - 2], o[l - 1], n[i - 2], n[i - 1])
-                } else if (a)
-                    for (u = 2; u < i;) t.bezierCurveTo(n[u++], n[u++], n[u++], n[u++], n[u++], n[u++]);
-                else
-                    for (u = 2; u < i; u += 2) t.lineTo(n[u], n[u + 1]);
-                s ? (t.closePath(), t.fillStrokeShape(this)) : t.strokeShape(this)
-            }
-        }
-        getTensionPoints() {
-            return this._getCache("tensionPoints", this._getTensionPoints)
-        }
-        _getTensionPoints() {
-            return this.closed() ? this._getTensionPointsClosed() : mk(this.points(), this.tension())
-        }
-        _getTensionPointsClosed() {
-            var t = this.points(),
-                n = t.length,
-                i = this.tension(),
-                r = Qv(t[n - 2], t[n - 1], t[0], t[1], t[2], t[3], i),
-                s = Qv(t[n - 4], t[n - 3], t[n - 2], t[n - 1], t[0], t[1], i),
-                a = mk(t, i),
-                o = [r[2], r[3]].concat(a).concat([s[0], s[1], t[n - 2], t[n - 1], s[2], s[3], r[0], r[1], t[0], t[1]]);
-            return o
-        }
-        getWidth() {
-            return this.getSelfRect().width
-        }
-        getHeight() {
-            return this.getSelfRect().height
-        }
-        getSelfRect() {
-            var t = this.points();
-            if (t.length < 4) return {
-                x: t[0] || 0,
-                y: t[1] || 0,
-                width: 0,
-                height: 0
-            };
-            this.tension() !== 0 ? t = [t[0], t[1], ...this._getTensionPoints(), t[t.length - 2], t[t.length - 1]] : t = this.points();
-            for (var n = t[0], i = t[0], r = t[1], s = t[1], a, o, l = 0; l < t.length / 2; l++) a = t[l * 2], o = t[l * 2 + 1], n = Math.min(n, a), i = Math.max(i, a), r = Math.min(r, o), s = Math.max(s, o);
-            return {
-                x: n,
-                y: r,
-                width: i - n,
-                height: s - r
-            }
-        }
+
+    function qj(e, t, n) {
+        var i = hn.exec(t.slice(n, n + 2));
+        return i ? (e.V = +i[0], n + i[0].length) : -1
     }
-    Gs.prototype.className = "Line";
-    Gs.prototype._attrsAffectingSize = ["points", "bezier", "tension"];
-    pt(Gs);
-    O.addGetterSetter(Gs, "closed", !1);
-    O.addGetterSetter(Gs, "bezier", !1);
-    O.addGetterSetter(Gs, "tension", 0, te());
-    O.addGetterSetter(Gs, "points", [], E9());
-    let Yt = class Ui extends V {
-        constructor(t) {
-            super(t), this.dataArray = [], this.pathLength = 0, this.dataArray = Ui.parsePathData(this.data()), this.pathLength = 0;
-            for (var n = 0; n < this.dataArray.length; ++n) this.pathLength += this.dataArray[n].pathLength;
-            this.on("dataChange.konva", function() {
-                this.dataArray = Ui.parsePathData(this.data()), this.pathLength = 0;
-                for (var i = 0; i < this.dataArray.length; ++i) this.pathLength += this.dataArray[i].pathLength
-            })
-        }
-        _sceneFunc(t) {
-            var n = this.dataArray;
-            t.beginPath();
-            for (var i = !1, r = 0; r < n.length; r++) {
-                var s = n[r].command,
-                    a = n[r].points;
-                switch (s) {
-                    case "L":
-                        t.lineTo(a[0], a[1]);
-                        break;
-                    case "M":
-                        t.moveTo(a[0], a[1]);
-                        break;
-                    case "C":
-                        t.bezierCurveTo(a[0], a[1], a[2], a[3], a[4], a[5]);
-                        break;
-                    case "Q":
-                        t.quadraticCurveTo(a[0], a[1], a[2], a[3]);
-                        break;
-                    case "A":
-                        var o = a[0],
-                            l = a[1],
-                            u = a[2],
-                            c = a[3],
-                            f = a[4],
-                            h = a[5],
-                            d = a[6],
-                            g = a[7],
-                            p = u > c ? u : c,
-                            m = u > c ? 1 : u / c,
-                            y = u > c ? c / u : 1;
-                        t.translate(o, l), t.rotate(d), t.scale(m, y), t.arc(0, 0, p, f, f + h, 1 - g), t.scale(1 / m, 1 / y), t.rotate(-d), t.translate(-o, -l);
-                        break;
-                    case "z":
-                        i = !0, t.closePath();
-                        break
-                }
-            }!i && !this.hasFill() ? t.strokeShape(this) : t.fillStrokeShape(this)
-        }
-        getSelfRect() {
-            var t = [];
-            this.dataArray.forEach(function(u) {
-                if (u.command === "A") {
-                    var c = u.points[4],
-                        f = u.points[5],
-                        h = u.points[4] + f,
-                        d = Math.PI / 180;
-                    if (Math.abs(c - h) < d && (d = Math.abs(c - h)), f < 0)
-                        for (let g = c - d; g > h; g -= d) {
-                            const p = Ui.getPointOnEllipticalArc(u.points[0], u.points[1], u.points[2], u.points[3], g, 0);
-                            t.push(p.x, p.y)
-                        } else
-                            for (let g = c + d; g < h; g += d) {
-                                const p = Ui.getPointOnEllipticalArc(u.points[0], u.points[1], u.points[2], u.points[3], g, 0);
-                                t.push(p.x, p.y)
-                            }
-                } else if (u.command === "C")
-                    for (let g = 0; g <= 1; g += .01) {
-                        const p = Ui.getPointOnCubicBezier(g, u.start.x, u.start.y, u.points[0], u.points[1], u.points[2], u.points[3], u.points[4], u.points[5]);
-                        t.push(p.x, p.y)
-                    } else t = t.concat(u.points)
-            });
-            for (var n = t[0], i = t[0], r = t[1], s = t[1], a, o, l = 0; l < t.length / 2; l++) a = t[l * 2], o = t[l * 2 + 1], isNaN(a) || (n = Math.min(n, a), i = Math.max(i, a)), isNaN(o) || (r = Math.min(r, o), s = Math.max(s, o));
-            return {
-                x: n,
-                y: r,
-                width: i - n,
-                height: s - r
-            }
-        }
-        getLength() {
-            return this.pathLength
-        }
-        getPointAtLength(t) {
-            var n, i = 0,
-                r = this.dataArray.length;
-            if (!r) return null;
-            for (; i < r && t > this.dataArray[i].pathLength;) t -= this.dataArray[i].pathLength, ++i;
-            if (i === r) return n = this.dataArray[i - 1].points.slice(-2), {
-                x: n[0],
-                y: n[1]
-            };
-            if (t < .01) return n = this.dataArray[i].points.slice(0, 2), {
-                x: n[0],
-                y: n[1]
-            };
-            var s = this.dataArray[i],
-                a = s.points;
-            switch (s.command) {
-                case "L":
-                    return Ui.getPointOnLine(t, s.start.x, s.start.y, a[0], a[1]);
-                case "C":
-                    return Ui.getPointOnCubicBezier(t / s.pathLength, s.start.x, s.start.y, a[0], a[1], a[2], a[3], a[4], a[5]);
-                case "Q":
-                    return Ui.getPointOnQuadraticBezier(t / s.pathLength, s.start.x, s.start.y, a[0], a[1], a[2], a[3]);
-                case "A":
-                    var o = a[0],
-                        l = a[1],
-                        u = a[2],
-                        c = a[3],
-                        f = a[4],
-                        h = a[5],
-                        d = a[6];
-                    return f += h * t / s.pathLength, Ui.getPointOnEllipticalArc(o, l, u, c, f, d)
-            }
-            return null
-        }
-        static getLineLength(t, n, i, r) {
-            return Math.sqrt((i - t) * (i - t) + (r - n) * (r - n))
-        }
-        static getPointOnLine(t, n, i, r, s, a, o) {
-            a === void 0 && (a = n), o === void 0 && (o = i);
-            var l = (s - i) / (r - n + 1e-8),
-                u = Math.sqrt(t * t / (1 + l * l));
-            r < n && (u *= -1);
-            var c = l * u,
-                f;
-            if (r === n) f = {
-                x: a,
-                y: o + c
-            };
-            else if ((o - i) / (a - n + 1e-8) === l) f = {
-                x: a + u,
-                y: o + c
-            };
-            else {
-                var h, d, g = this.getLineLength(n, i, r, s),
-                    p = (a - n) * (r - n) + (o - i) * (s - i);
-                p = p / (g * g), h = n + p * (r - n), d = i + p * (s - i);
-                var m = this.getLineLength(a, o, h, d),
-                    y = Math.sqrt(t * t - m * m);
-                u = Math.sqrt(y * y / (1 + l * l)), r < n && (u *= -1), c = l * u, f = {
-                    x: h + u,
-                    y: d + c
-                }
-            }
-            return f
-        }
-        static getPointOnCubicBezier(t, n, i, r, s, a, o, l, u) {
-            function c(m) {
-                return m * m * m
-            }
 
-            function f(m) {
-                return 3 * m * m * (1 - m)
-            }
+    function Hj(e, t, n) {
+        var i = hn.exec(t.slice(n, n + 2));
+        return i ? (e.W = +i[0], n + i[0].length) : -1
+    }
 
-            function h(m) {
-                return 3 * m * (1 - m) * (1 - m)
-            }
+    function yA(e, t, n) {
+        var i = hn.exec(t.slice(n, n + 4));
+        return i ? (e.y = +i[0], n + i[0].length) : -1
+    }
 
-            function d(m) {
-                return (1 - m) * (1 - m) * (1 - m)
-            }
-            var g = l * c(t) + a * f(t) + r * h(t) + n * d(t),
-                p = u * c(t) + o * f(t) + s * h(t) + i * d(t);
-            return {
-                x: g,
-                y: p
-            }
-        }
-        static getPointOnQuadraticBezier(t, n, i, r, s, a, o) {
-            function l(d) {
-                return d * d
-            }
+    function vA(e, t, n) {
+        var i = hn.exec(t.slice(n, n + 2));
+        return i ? (e.y = +i[0] + (+i[0] > 68 ? 1900 : 2e3), n + i[0].length) : -1
+    }
 
-            function u(d) {
-                return 2 * d * (1 - d)
-            }
+    function Yj(e, t, n) {
+        var i = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(t.slice(n, n + 6));
+        return i ? (e.Z = i[1] ? 0 : -(i[2] + (i[3] || "00")), n + i[0].length) : -1
+    }
 
-            function c(d) {
-                return (1 - d) * (1 - d)
-            }
-            var f = a * l(t) + r * u(t) + n * c(t),
-                h = o * l(t) + s * u(t) + i * c(t);
-            return {
-                x: f,
-                y: h
-            }
-        }
-        static getPointOnEllipticalArc(t, n, i, r, s, a) {
-            var o = Math.cos(a),
-                l = Math.sin(a),
-                u = {
-                    x: i * Math.cos(s),
-                    y: r * Math.sin(s)
-                };
-            return {
-                x: t + (u.x * o - u.y * l),
-                y: n + (u.x * l + u.y * o)
-            }
-        }
-        static parsePathData(t) {
-            if (!t) return [];
-            var n = t,
-                i = ["m", "M", "l", "L", "v", "V", "h", "H", "z", "Z", "c", "C", "q", "Q", "t", "T", "s", "S", "a", "A"];
-            n = n.replace(new RegExp(" ", "g"), ",");
-            for (var r = 0; r < i.length; r++) n = n.replace(new RegExp(i[r], "g"), "|" + i[r]);
-            var s = n.split("|"),
-                a = [],
-                o = [],
-                l = 0,
-                u = 0,
-                c = /([-+]?((\d+\.\d+)|((\d+)|(\.\d+)))(?:e[-+]?\d+)?)/gi,
-                f;
-            for (r = 1; r < s.length; r++) {
-                var h = s[r],
-                    d = h.charAt(0);
-                for (h = h.slice(1), o.length = 0; f = c.exec(h);) o.push(f[0]);
-                for (var g = [], p = 0, m = o.length; p < m; p++) {
-                    if (o[p] === "00") {
-                        g.push(0, 0);
-                        continue
-                    }
-                    var y = parseFloat(o[p]);
-                    isNaN(y) ? g.push(0) : g.push(y)
-                }
-                for (; g.length > 0 && !isNaN(g[0]);) {
-                    var v = null,
-                        b = [],
-                        x = l,
-                        _ = u,
-                        S, w, E, A, C, k, R, $, T, M;
-                    switch (d) {
-                        case "l":
-                            l += g.shift(), u += g.shift(), v = "L", b.push(l, u);
-                            break;
-                        case "L":
-                            l = g.shift(), u = g.shift(), b.push(l, u);
-                            break;
-                        case "m":
-                            var F = g.shift(),
-                                N = g.shift();
-                            if (l += F, u += N, v = "M", a.length > 2 && a[a.length - 1].command === "z") {
-                                for (var P = a.length - 2; P >= 0; P--)
-                                    if (a[P].command === "M") {
-                                        l = a[P].points[0] + F, u = a[P].points[1] + N;
-                                        break
-                                    }
-                            }
-                            b.push(l, u), d = "l";
-                            break;
-                        case "M":
-                            l = g.shift(), u = g.shift(), v = "M", b.push(l, u), d = "L";
-                            break;
-                        case "h":
-                            l += g.shift(), v = "L", b.push(l, u);
-                            break;
-                        case "H":
-                            l = g.shift(), v = "L", b.push(l, u);
-                            break;
-                        case "v":
-                            u += g.shift(), v = "L", b.push(l, u);
-                            break;
-                        case "V":
-                            u = g.shift(), v = "L", b.push(l, u);
-                            break;
-                        case "C":
-                            b.push(g.shift(), g.shift(), g.shift(), g.shift()), l = g.shift(), u = g.shift(), b.push(l, u);
-                            break;
-                        case "c":
-                            b.push(l + g.shift(), u + g.shift(), l + g.shift(), u + g.shift()), l += g.shift(), u += g.shift(), v = "C", b.push(l, u);
-                            break;
-                        case "S":
-                            w = l, E = u, S = a[a.length - 1], S.command === "C" && (w = l + (l - S.points[2]), E = u + (u - S.points[3])), b.push(w, E, g.shift(), g.shift()), l = g.shift(), u = g.shift(), v = "C", b.push(l, u);
-                            break;
-                        case "s":
-                            w = l, E = u, S = a[a.length - 1], S.command === "C" && (w = l + (l - S.points[2]), E = u + (u - S.points[3])), b.push(w, E, l + g.shift(), u + g.shift()), l += g.shift(), u += g.shift(), v = "C", b.push(l, u);
-                            break;
-                        case "Q":
-                            b.push(g.shift(), g.shift()), l = g.shift(), u = g.shift(), b.push(l, u);
-                            break;
-                        case "q":
-                            b.push(l + g.shift(), u + g.shift()), l += g.shift(), u += g.shift(), v = "Q", b.push(l, u);
-                            break;
-                        case "T":
-                            w = l, E = u, S = a[a.length - 1], S.command === "Q" && (w = l + (l - S.points[0]), E = u + (u - S.points[1])), l = g.shift(), u = g.shift(), v = "Q", b.push(w, E, l, u);
-                            break;
-                        case "t":
-                            w = l, E = u, S = a[a.length - 1], S.command === "Q" && (w = l + (l - S.points[0]), E = u + (u - S.points[1])), l += g.shift(), u += g.shift(), v = "Q", b.push(w, E, l, u);
-                            break;
-                        case "A":
-                            A = g.shift(), C = g.shift(), k = g.shift(), R = g.shift(), $ = g.shift(), T = l, M = u, l = g.shift(), u = g.shift(), v = "A", b = this.convertEndpointToCenterParameterization(T, M, l, u, R, $, A, C, k);
-                            break;
-                        case "a":
-                            A = g.shift(), C = g.shift(), k = g.shift(), R = g.shift(), $ = g.shift(), T = l, M = u, l += g.shift(), u += g.shift(), v = "A", b = this.convertEndpointToCenterParameterization(T, M, l, u, R, $, A, C, k);
-                            break
-                    }
-                    a.push({
-                        command: v || d,
-                        points: b,
-                        start: {
-                            x,
-                            y: _
-                        },
-                        pathLength: this.calcLength(x, _, v || d, b)
-                    })
-                }(d === "z" || d === "Z") && a.push({
-                    command: "z",
-                    points: [],
-                    start: void 0,
-                    pathLength: 0
-                })
-            }
-            return a
-        }
-        static calcLength(t, n, i, r) {
-            var s, a, o, l, u = Ui;
-            switch (i) {
-                case "L":
-                    return u.getLineLength(t, n, r[0], r[1]);
-                case "C":
-                    for (s = 0, a = u.getPointOnCubicBezier(0, t, n, r[0], r[1], r[2], r[3], r[4], r[5]), l = .01; l <= 1; l += .01) o = u.getPointOnCubicBezier(l, t, n, r[0], r[1], r[2], r[3], r[4], r[5]), s += u.getLineLength(a.x, a.y, o.x, o.y), a = o;
-                    return s;
-                case "Q":
-                    for (s = 0, a = u.getPointOnQuadraticBezier(0, t, n, r[0], r[1], r[2], r[3]), l = .01; l <= 1; l += .01) o = u.getPointOnQuadraticBezier(l, t, n, r[0], r[1], r[2], r[3]), s += u.getLineLength(a.x, a.y, o.x, o.y), a = o;
-                    return s;
-                case "A":
-                    s = 0;
-                    var c = r[4],
-                        f = r[5],
-                        h = r[4] + f,
-                        d = Math.PI / 180;
-                    if (Math.abs(c - h) < d && (d = Math.abs(c - h)), a = u.getPointOnEllipticalArc(r[0], r[1], r[2], r[3], c, 0), f < 0)
-                        for (l = c - d; l > h; l -= d) o = u.getPointOnEllipticalArc(r[0], r[1], r[2], r[3], l, 0), s += u.getLineLength(a.x, a.y, o.x, o.y), a = o;
-                    else
-                        for (l = c + d; l < h; l += d) o = u.getPointOnEllipticalArc(r[0], r[1], r[2], r[3], l, 0), s += u.getLineLength(a.x, a.y, o.x, o.y), a = o;
-                    return o = u.getPointOnEllipticalArc(r[0], r[1], r[2], r[3], h, 0), s += u.getLineLength(a.x, a.y, o.x, o.y), s
-            }
-            return 0
-        }
-        static convertEndpointToCenterParameterization(t, n, i, r, s, a, o, l, u) {
-            var c = u * (Math.PI / 180),
-                f = Math.cos(c) * (t - i) / 2 + Math.sin(c) * (n - r) / 2,
-                h = -1 * Math.sin(c) * (t - i) / 2 + Math.cos(c) * (n - r) / 2,
-                d = f * f / (o * o) + h * h / (l * l);
-            d > 1 && (o *= Math.sqrt(d), l *= Math.sqrt(d));
-            var g = Math.sqrt((o * o * (l * l) - o * o * (h * h) - l * l * (f * f)) / (o * o * (h * h) + l * l * (f * f)));
-            s === a && (g *= -1), isNaN(g) && (g = 0);
-            var p = g * o * h / l,
-                m = g * -l * f / o,
-                y = (t + i) / 2 + Math.cos(c) * p - Math.sin(c) * m,
-                v = (n + r) / 2 + Math.sin(c) * p + Math.cos(c) * m,
-                b = function(C) {
-                    return Math.sqrt(C[0] * C[0] + C[1] * C[1])
-                },
-                x = function(C, k) {
-                    return (C[0] * k[0] + C[1] * k[1]) / (b(C) * b(k))
-                },
-                _ = function(C, k) {
-                    return (C[0] * k[1] < C[1] * k[0] ? -1 : 1) * Math.acos(x(C, k))
-                },
-                S = _([1, 0], [(f - p) / o, (h - m) / l]),
-                w = [(f - p) / o, (h - m) / l],
-                E = [(-1 * f - p) / o, (-1 * h - m) / l],
-                A = _(w, E);
-            return x(w, E) <= -1 && (A = Math.PI), x(w, E) >= 1 && (A = 0), a === 0 && A > 0 && (A = A - 2 * Math.PI), a === 1 && A < 0 && (A = A + 2 * Math.PI), [y, v, o, l, S, A, c, a]
-        }
-    };
-    Yt.prototype.className = "Path";
-    Yt.prototype._attrsAffectingSize = ["data"];
-    pt(Yt);
-    O.addGetterSetter(Yt, "data");
-    class _l extends Gs {
-        _sceneFunc(t) {
-            super._sceneFunc(t);
-            var n = Math.PI * 2,
-                i = this.points(),
-                r = i,
-                s = this.tension() !== 0 && i.length > 4;
-            s && (r = this.getTensionPoints());
-            var a = this.pointerLength(),
-                o = i.length,
-                l, u;
-            if (s) {
-                const h = [r[r.length - 4], r[r.length - 3], r[r.length - 2], r[r.length - 1], i[o - 2], i[o - 1]],
-                    d = Yt.calcLength(r[r.length - 4], r[r.length - 3], "C", h),
-                    g = Yt.getPointOnQuadraticBezier(Math.min(1, 1 - a / d), h[0], h[1], h[2], h[3], h[4], h[5]);
-                l = i[o - 2] - g.x, u = i[o - 1] - g.y
-            } else l = i[o - 2] - i[o - 4], u = i[o - 1] - i[o - 3];
-            var c = (Math.atan2(u, l) + n) % n,
-                f = this.pointerWidth();
-            this.pointerAtEnding() && (t.save(), t.beginPath(), t.translate(i[o - 2], i[o - 1]), t.rotate(c), t.moveTo(0, 0), t.lineTo(-a, f / 2), t.lineTo(-a, -f / 2), t.closePath(), t.restore(), this.__fillStroke(t)), this.pointerAtBeginning() && (t.save(), t.beginPath(), t.translate(i[0], i[1]), s ? (l = (r[0] + r[2]) / 2 - i[0], u = (r[1] + r[3]) / 2 - i[1]) : (l = i[2] - i[0], u = i[3] - i[1]), t.rotate((Math.atan2(-u, -l) + n) % n), t.moveTo(0, 0), t.lineTo(-a, f / 2), t.lineTo(-a, -f / 2), t.closePath(), t.restore(), this.__fillStroke(t))
-        }
-        __fillStroke(t) {
-            var n = this.dashEnabled();
-            n && (this.attrs.dashEnabled = !1, t.setLineDash([])), t.fillStrokeShape(this), n && (this.attrs.dashEnabled = !0)
-        }
-        getSelfRect() {
-            const t = super.getSelfRect(),
-                n = this.pointerWidth() / 2;
-            return {
-                x: t.x - n,
-                y: t.y - n,
-                width: t.width + n * 2,
-                height: t.height + n * 2
-            }
-        }
+    function Xj(e, t, n) {
+        var i = hn.exec(t.slice(n, n + 1));
+        return i ? (e.q = i[0] * 3 - 3, n + i[0].length) : -1
     }
-    _l.prototype.className = "Arrow";
-    pt(_l);
-    O.addGetterSetter(_l, "pointerLength", 10, te());
-    O.addGetterSetter(_l, "pointerWidth", 10, te());
-    O.addGetterSetter(_l, "pointerAtBeginning", !1);
-    O.addGetterSetter(_l, "pointerAtEnding", !0);
-    class dc extends V {
-        _sceneFunc(t) {
-            t.beginPath(), t.arc(0, 0, this.attrs.radius || 0, 0, Math.PI * 2, !1), t.closePath(), t.fillStrokeShape(this)
-        }
-        getWidth() {
-            return this.radius() * 2
-        }
-        getHeight() {
-            return this.radius() * 2
-        }
-        setWidth(t) {
-            this.radius() !== t / 2 && this.radius(t / 2)
-        }
-        setHeight(t) {
-            this.radius() !== t / 2 && this.radius(t / 2)
-        }
+
+    function Vj(e, t, n) {
+        var i = hn.exec(t.slice(n, n + 2));
+        return i ? (e.m = i[0] - 1, n + i[0].length) : -1
     }
-    dc.prototype._centroid = !0;
-    dc.prototype.className = "Circle";
-    dc.prototype._attrsAffectingSize = ["radius"];
-    pt(dc);
-    O.addGetterSetter(dc, "radius", 0, te());
-    class Ya extends V {
-        _sceneFunc(t) {
-            var n = this.radiusX(),
-                i = this.radiusY();
-            t.beginPath(), t.save(), n !== i && t.scale(1, i / n), t.arc(0, 0, n, 0, Math.PI * 2, !1), t.restore(), t.closePath(), t.fillStrokeShape(this)
-        }
-        getWidth() {
-            return this.radiusX() * 2
-        }
-        getHeight() {
-            return this.radiusY() * 2
-        }
-        setWidth(t) {
-            this.radiusX(t / 2)
-        }
-        setHeight(t) {
-            this.radiusY(t / 2)
-        }
+
+    function bA(e, t, n) {
+        var i = hn.exec(t.slice(n, n + 2));
+        return i ? (e.d = +i[0], n + i[0].length) : -1
     }
-    Ya.prototype.className = "Ellipse";
-    Ya.prototype._centroid = !0;
-    Ya.prototype._attrsAffectingSize = ["radiusX", "radiusY"];
-    pt(Ya);
-    O.addComponentsGetterSetter(Ya, "radius", ["x", "y"]);
-    O.addGetterSetter(Ya, "radiusX", 0, te());
-    O.addGetterSetter(Ya, "radiusY", 0, te());
-    let Qr = class XM extends V {
-        constructor(t) {
-            super(t), this.on("imageChange.konva", () => {
-                this._setImageLoad()
-            }), this._setImageLoad()
-        }
-        _setImageLoad() {
-            const t = this.image();
-            t && t.complete || t && t.readyState === 4 || t && t.addEventListener && t.addEventListener("load", () => {
-                this._requestDraw()
-            })
-        }
-        _useBufferCanvas() {
-            return super._useBufferCanvas(!0)
-        }
-        _sceneFunc(t) {
-            const n = this.getWidth(),
-                i = this.getHeight(),
-                r = this.cornerRadius(),
-                s = this.attrs.image;
-            let a;
-            if (s) {
-                const o = this.attrs.cropWidth,
-                    l = this.attrs.cropHeight;
-                o && l ? a = [s, this.cropX(), this.cropY(), o, l, 0, 0, n, i] : a = [s, 0, 0, n, i]
-            }(this.hasFill() || this.hasStroke() || r) && (t.beginPath(), r ? D.drawRoundedRectPath(t, n, i, r) : t.rect(0, 0, n, i), t.closePath(), t.fillStrokeShape(this)), s && (r && t.clip(), t.drawImage.apply(t, a))
-        }
-        _hitFunc(t) {
-            var n = this.width(),
-                i = this.height(),
-                r = this.cornerRadius();
-            t.beginPath(), r ? D.drawRoundedRectPath(t, n, i, r) : t.rect(0, 0, n, i), t.closePath(), t.fillStrokeShape(this)
-        }
-        getWidth() {
-            var t, n;
-            return (t = this.attrs.width) !== null && t !== void 0 ? t : (n = this.image()) === null || n === void 0 ? void 0 : n.width
-        }
-        getHeight() {
-            var t, n;
-            return (t = this.attrs.height) !== null && t !== void 0 ? t : (n = this.image()) === null || n === void 0 ? void 0 : n.height
-        }
-        static fromURL(t, n, i = null) {
-            var r = D.createImageElement();
-            r.onload = function() {
-                var s = new XM({
-                    image: r
-                });
-                n(s)
-            }, r.onerror = i, r.crossOrigin = "Anonymous", r.src = t
-        }
-    };
-    Qr.prototype.className = "Image";
-    pt(Qr);
-    O.addGetterSetter(Qr, "cornerRadius", 0, px(4));
-    O.addGetterSetter(Qr, "image");
-    O.addComponentsGetterSetter(Qr, "crop", ["x", "y", "width", "height"]);
-    O.addGetterSetter(Qr, "cropX", 0, te());
-    O.addGetterSetter(Qr, "cropY", 0, te());
-    O.addGetterSetter(Qr, "cropWidth", 0, te());
-    O.addGetterSetter(Qr, "cropHeight", 0, te());
-    var VM = ["fontFamily", "fontSize", "fontStyle", "padding", "lineHeight", "text", "width", "height", "pointerDirection", "pointerWidth", "pointerHeight"],
-        p7 = "Change.konva",
-        m7 = "none",
-        Zv = "up",
-        eb = "right",
-        tb = "down",
-        nb = "left",
-        y7 = VM.length;
-    let xx = class extends Mu {
-        constructor(t) {
-            super(t), this.on("add.konva", function(n) {
-                this._addListeners(n.child), this._sync()
-            })
-        }
-        getText() {
-            return this.find("Text")[0]
-        }
-        getTag() {
-            return this.find("Tag")[0]
-        }
-        _addListeners(t) {
-            var n = this,
-                i, r = function() {
-                    n._sync()
-                };
-            for (i = 0; i < y7; i++) t.on(VM[i] + p7, r)
-        }
-        getWidth() {
-            return this.getText().width()
-        }
-        getHeight() {
-            return this.getText().height()
-        }
-        _sync() {
-            var t = this.getText(),
-                n = this.getTag(),
-                i, r, s, a, o, l, u;
-            if (t && n) {
-                switch (i = t.width(), r = t.height(), s = n.pointerDirection(), a = n.pointerWidth(), u = n.pointerHeight(), o = 0, l = 0, s) {
-                    case Zv:
-                        o = i / 2, l = -1 * u;
-                        break;
-                    case eb:
-                        o = i + a, l = r / 2;
-                        break;
-                    case tb:
-                        o = i / 2, l = r + u;
-                        break;
-                    case nb:
-                        o = -1 * a, l = r / 2;
-                        break
-                }
-                n.setAttrs({
-                    x: -1 * o,
-                    y: -1 * l,
-                    width: i,
-                    height: r
-                }), t.setAttrs({
-                    x: -1 * o,
-                    y: -1 * l
-                })
-            }
-        }
-    };
-    xx.prototype.className = "Label";
-    pt(xx);
-    class wl extends V {
-        _sceneFunc(t) {
-            var n = this.width(),
-                i = this.height(),
-                r = this.pointerDirection(),
-                s = this.pointerWidth(),
-                a = this.pointerHeight(),
-                o = this.cornerRadius();
-            let l = 0,
-                u = 0,
-                c = 0,
-                f = 0;
-            typeof o == "number" ? l = u = c = f = Math.min(o, n / 2, i / 2) : (l = Math.min(o[0] || 0, n / 2, i / 2), u = Math.min(o[1] || 0, n / 2, i / 2), f = Math.min(o[2] || 0, n / 2, i / 2), c = Math.min(o[3] || 0, n / 2, i / 2)), t.beginPath(), t.moveTo(l, 0), r === Zv && (t.lineTo((n - s) / 2, 0), t.lineTo(n / 2, -1 * a), t.lineTo((n + s) / 2, 0)), t.lineTo(n - u, 0), t.arc(n - u, u, u, Math.PI * 3 / 2, 0, !1), r === eb && (t.lineTo(n, (i - a) / 2), t.lineTo(n + s, i / 2), t.lineTo(n, (i + a) / 2)), t.lineTo(n, i - f), t.arc(n - f, i - f, f, 0, Math.PI / 2, !1), r === tb && (t.lineTo((n + s) / 2, i), t.lineTo(n / 2, i + a), t.lineTo((n - s) / 2, i)), t.lineTo(c, i), t.arc(c, i - c, c, Math.PI / 2, Math.PI, !1), r === nb && (t.lineTo(0, (i + a) / 2), t.lineTo(-1 * s, i / 2), t.lineTo(0, (i - a) / 2)), t.lineTo(0, l), t.arc(l, l, l, Math.PI, Math.PI * 3 / 2, !1), t.closePath(), t.fillStrokeShape(this)
-        }
-        getSelfRect() {
-            var t = 0,
-                n = 0,
-                i = this.pointerWidth(),
-                r = this.pointerHeight(),
-                s = this.pointerDirection(),
-                a = this.width(),
-                o = this.height();
-            return s === Zv ? (n -= r, o += r) : s === tb ? o += r : s === nb ? (t -= i * 1.5, a += i) : s === eb && (a += i * 1.5), {
-                x: t,
-                y: n,
-                width: a,
-                height: o
-            }
-        }
+
+    function Kj(e, t, n) {
+        var i = hn.exec(t.slice(n, n + 3));
+        return i ? (e.m = 0, e.d = +i[0], n + i[0].length) : -1
     }
-    wl.prototype.className = "Tag";
-    pt(wl);
-    O.addGetterSetter(wl, "pointerDirection", m7);
-    O.addGetterSetter(wl, "pointerWidth", 0, te());
-    O.addGetterSetter(wl, "pointerHeight", 0, te());
-    O.addGetterSetter(wl, "cornerRadius", 0, px(4));
-    class Vh extends V {
-        _sceneFunc(t) {
-            var n = this.cornerRadius(),
-                i = this.width(),
-                r = this.height();
-            t.beginPath(), n ? D.drawRoundedRectPath(t, i, r, n) : t.rect(0, 0, i, r), t.closePath(), t.fillStrokeShape(this)
-        }
+
+    function xA(e, t, n) {
+        var i = hn.exec(t.slice(n, n + 2));
+        return i ? (e.H = +i[0], n + i[0].length) : -1
     }
-    Vh.prototype.className = "Rect";
-    pt(Vh);
-    O.addGetterSetter(Vh, "cornerRadius", 0, px(4));
-    class Sl extends V {
-        _sceneFunc(t) {
-            const n = this._getPoints();
-            t.beginPath(), t.moveTo(n[0].x, n[0].y);
-            for (var i = 1; i < n.length; i++) t.lineTo(n[i].x, n[i].y);
-            t.closePath(), t.fillStrokeShape(this)
-        }
-        _getPoints() {
-            const t = this.attrs.sides,
-                n = this.attrs.radius || 0,
-                i = [];
-            for (var r = 0; r < t; r++) i.push({
-                x: n * Math.sin(r * 2 * Math.PI / t),
-                y: -1 * n * Math.cos(r * 2 * Math.PI / t)
-            });
-            return i
-        }
-        getSelfRect() {
-            const t = this._getPoints();
-            var n = t[0].x,
-                i = t[0].y,
-                r = t[0].x,
-                s = t[0].y;
-            return t.forEach(a => {
-                n = Math.min(n, a.x), i = Math.max(i, a.x), r = Math.min(r, a.y), s = Math.max(s, a.y)
-            }), {
-                x: n,
-                y: r,
-                width: i - n,
-                height: s - r
-            }
-        }
-        getWidth() {
-            return this.radius() * 2
-        }
-        getHeight() {
-            return this.radius() * 2
-        }
-        setWidth(t) {
-            this.radius(t / 2)
-        }
-        setHeight(t) {
-            this.radius(t / 2)
-        }
+
+    function Jj(e, t, n) {
+        var i = hn.exec(t.slice(n, n + 2));
+        return i ? (e.M = +i[0], n + i[0].length) : -1
     }
-    Sl.prototype.className = "RegularPolygon";
-    Sl.prototype._centroid = !0;
-    Sl.prototype._attrsAffectingSize = ["radius"];
-    pt(Sl);
-    O.addGetterSetter(Sl, "radius", 0, te());
-    O.addGetterSetter(Sl, "sides", 0, te());
-    var yk = Math.PI * 2;
-    class El extends V {
-        _sceneFunc(t) {
-            t.beginPath(), t.arc(0, 0, this.innerRadius(), 0, yk, !1), t.moveTo(this.outerRadius(), 0), t.arc(0, 0, this.outerRadius(), yk, 0, !0), t.closePath(), t.fillStrokeShape(this)
-        }
-        getWidth() {
-            return this.outerRadius() * 2
-        }
-        getHeight() {
-            return this.outerRadius() * 2
-        }
-        setWidth(t) {
-            this.outerRadius(t / 2)
-        }
-        setHeight(t) {
-            this.outerRadius(t / 2)
-        }
+
+    function Qj(e, t, n) {
+        var i = hn.exec(t.slice(n, n + 2));
+        return i ? (e.S = +i[0], n + i[0].length) : -1
     }
-    El.prototype.className = "Ring";
-    El.prototype._centroid = !0;
-    El.prototype._attrsAffectingSize = ["innerRadius", "outerRadius"];
-    pt(El);
-    O.addGetterSetter(El, "innerRadius", 0, te());
-    O.addGetterSetter(El, "outerRadius", 0, te());
-    class Zr extends V {
-        constructor(t) {
-            super(t), this._updated = !0, this.anim = new Ci(() => {
-                var n = this._updated;
-                return this._updated = !1, n
-            }), this.on("animationChange.konva", function() {
-                this.frameIndex(0)
-            }), this.on("frameIndexChange.konva", function() {
-                this._updated = !0
-            }), this.on("frameRateChange.konva", function() {
-                this.anim.isRunning() && (clearInterval(this.interval), this._setInterval())
-            })
-        }
-        _sceneFunc(t) {
-            var n = this.animation(),
-                i = this.frameIndex(),
-                r = i * 4,
-                s = this.animations()[n],
-                a = this.frameOffsets(),
-                o = s[r + 0],
-                l = s[r + 1],
-                u = s[r + 2],
-                c = s[r + 3],
-                f = this.image();
-            if ((this.hasFill() || this.hasStroke()) && (t.beginPath(), t.rect(0, 0, u, c), t.closePath(), t.fillStrokeShape(this)), f)
-                if (a) {
-                    var h = a[n],
-                        d = i * 2;
-                    t.drawImage(f, o, l, u, c, h[d + 0], h[d + 1], u, c)
-                } else t.drawImage(f, o, l, u, c, 0, 0, u, c)
-        }
-        _hitFunc(t) {
-            var n = this.animation(),
-                i = this.frameIndex(),
-                r = i * 4,
-                s = this.animations()[n],
-                a = this.frameOffsets(),
-                o = s[r + 2],
-                l = s[r + 3];
-            if (t.beginPath(), a) {
-                var u = a[n],
-                    c = i * 2;
-                t.rect(u[c + 0], u[c + 1], o, l)
-            } else t.rect(0, 0, o, l);
-            t.closePath(), t.fillShape(this)
-        }
-        _useBufferCanvas() {
-            return super._useBufferCanvas(!0)
-        }
-        _setInterval() {
-            var t = this;
-            this.interval = setInterval(function() {
-                t._updateIndex()
-            }, 1e3 / this.frameRate())
-        }
-        start() {
-            if (!this.isRunning()) {
-                var t = this.getLayer();
-                this.anim.setLayers(t), this._setInterval(), this.anim.start()
-            }
-        }
-        stop() {
-            this.anim.stop(), clearInterval(this.interval)
-        }
-        isRunning() {
-            return this.anim.isRunning()
-        }
-        _updateIndex() {
-            var t = this.frameIndex(),
-                n = this.animation(),
-                i = this.animations(),
-                r = i[n],
-                s = r.length / 4;
-            t < s - 1 ? this.frameIndex(t + 1) : this.frameIndex(0)
-        }
+
+    function Zj(e, t, n) {
+        var i = hn.exec(t.slice(n, n + 3));
+        return i ? (e.L = +i[0], n + i[0].length) : -1
     }
-    Zr.prototype.className = "Sprite";
-    pt(Zr);
-    O.addGetterSetter(Zr, "animation");
-    O.addGetterSetter(Zr, "animations");
-    O.addGetterSetter(Zr, "frameOffsets");
-    O.addGetterSetter(Zr, "image");
-    O.addGetterSetter(Zr, "frameIndex", 0, te());
-    O.addGetterSetter(Zr, "frameRate", 17, te());
-    O.backCompat(Zr, {
-        index: "frameIndex",
-        getIndex: "getFrameIndex",
-        setIndex: "setFrameIndex"
-    });
-    class Xa extends V {
-        _sceneFunc(t) {
-            var n = this.innerRadius(),
-                i = this.outerRadius(),
-                r = this.numPoints();
-            t.beginPath(), t.moveTo(0, 0 - i);
-            for (var s = 1; s < r * 2; s++) {
-                var a = s % 2 === 0 ? i : n,
-                    o = a * Math.sin(s * Math.PI / r),
-                    l = -1 * a * Math.cos(s * Math.PI / r);
-                t.lineTo(o, l)
-            }
-            t.closePath(), t.fillStrokeShape(this)
-        }
-        getWidth() {
-            return this.outerRadius() * 2
-        }
-        getHeight() {
-            return this.outerRadius() * 2
-        }
-        setWidth(t) {
-            this.outerRadius(t / 2)
-        }
-        setHeight(t) {
-            this.outerRadius(t / 2)
-        }
+
+    function eG(e, t, n) {
+        var i = hn.exec(t.slice(n, n + 6));
+        return i ? (e.L = Math.floor(i[0] / 1e3), n + i[0].length) : -1
     }
-    Xa.prototype.className = "Star";
-    Xa.prototype._centroid = !0;
-    Xa.prototype._attrsAffectingSize = ["innerRadius", "outerRadius"];
-    pt(Xa);
-    O.addGetterSetter(Xa, "numPoints", 5, te());
-    O.addGetterSetter(Xa, "innerRadius", 0, te());
-    O.addGetterSetter(Xa, "outerRadius", 0, te());
 
-    function KM(e) {
-        return Array.from(e)
+    function tG(e, t, n) {
+        var i = zj.exec(t.slice(n, n + 1));
+        return i ? n + i[0].length : -1
     }
-    var Wl = "auto",
-        v7 = "center",
-        Uc = "justify",
-        b7 = "Change.konva",
-        x7 = "2d",
-        vk = "-",
-        JM = "left",
-        _7 = "text",
-        w7 = "Text",
-        S7 = "top",
-        E7 = "bottom",
-        bk = "middle",
-        QM = "normal",
-        C7 = "px ",
-        Kd = " ",
-        k7 = "right",
-        A7 = "word",
-        $7 = "char",
-        xk = "none",
-        py = "…",
-        ZM = ["fontFamily", "fontSize", "fontStyle", "fontVariant", "padding", "align", "verticalAlign", "lineHeight", "text", "width", "height", "wrap", "ellipsis", "letterSpacing"],
-        T7 = ZM.length;
 
-    function M7(e) {
-        return e.split(",").map(t => {
-            t = t.trim();
-            const n = t.indexOf(" ") >= 0,
-                i = t.indexOf('"') >= 0 || t.indexOf("'") >= 0;
-            return n && !i && (t = `"${t}"`), t
-        }).join(", ")
+    function nG(e, t, n) {
+        var i = hn.exec(t.slice(n));
+        return i ? (e.Q = +i[0], n + i[0].length) : -1
     }
-    var Jd;
 
-    function my() {
-        return Jd || (Jd = D.createCanvasElement().getContext(x7), Jd)
+    function iG(e, t, n) {
+        var i = hn.exec(t.slice(n));
+        return i ? (e.s = +i[0], n + i[0].length) : -1
     }
 
-    function O7(e) {
-        e.fillText(this._partialText, this._partialTextX, this._partialTextY)
+    function _A(e, t) {
+        return Qe(e.getDate(), t, 2)
     }
 
-    function F7(e) {
-        e.strokeText(this._partialText, this._partialTextX, this._partialTextY)
+    function rG(e, t) {
+        return Qe(e.getHours(), t, 2)
     }
 
-    function R7(e) {
-        return e = e || {}, !e.fillLinearGradientColorStops && !e.fillRadialGradientColorStops && !e.fillPatternImage && (e.fill = e.fill || "black"), e
+    function sG(e, t) {
+        return Qe(e.getHours() % 12 || 12, t, 2)
     }
-    class gt extends V {
-        constructor(t) {
-            super(R7(t)), this._partialTextX = 0, this._partialTextY = 0;
-            for (var n = 0; n < T7; n++) this.on(ZM[n] + b7, this._setTextData);
-            this._setTextData()
-        }
-        _sceneFunc(t) {
-            var n = this.textArr,
-                i = n.length;
-            if (this.text()) {
-                var r = this.padding(),
-                    s = this.fontSize(),
-                    a = this.lineHeight() * s,
-                    o = this.verticalAlign(),
-                    l = 0,
-                    u = this.align(),
-                    c = this.getWidth(),
-                    f = this.letterSpacing(),
-                    h = this.fill(),
-                    d = this.textDecoration(),
-                    g = d.indexOf("underline") !== -1,
-                    p = d.indexOf("line-through") !== -1,
-                    m, y = 0,
-                    y = a / 2,
-                    v = 0,
-                    b = 0;
-                for (t.setAttr("font", this._getContextFont()), t.setAttr("textBaseline", bk), t.setAttr("textAlign", JM), o === bk ? l = (this.getHeight() - i * a - r * 2) / 2 : o === E7 && (l = this.getHeight() - i * a - r * 2), t.translate(r, l + r), m = 0; m < i; m++) {
-                    var v = 0,
-                        b = 0,
-                        x = n[m],
-                        _ = x.text,
-                        S = x.width,
-                        w = x.lastInParagraph,
-                        E, A, C;
-                    if (t.save(), u === k7 ? v += c - S - r * 2 : u === v7 && (v += (c - S - r * 2) / 2), g) {
-                        t.save(), t.beginPath(), t.moveTo(v, y + b + Math.round(s / 2)), E = _.split(" ").length - 1, A = E === 0, C = u === Uc && !w ? c - r * 2 : S, t.lineTo(v + Math.round(C), y + b + Math.round(s / 2)), t.lineWidth = s / 15;
-                        const F = this._getLinearGradient();
-                        t.strokeStyle = F || h, t.stroke(), t.restore()
-                    }
-                    if (p) {
-                        t.save(), t.beginPath(), t.moveTo(v, y + b), E = _.split(" ").length - 1, A = E === 0, C = u === Uc && w && !A ? c - r * 2 : S, t.lineTo(v + Math.round(C), y + b), t.lineWidth = s / 15;
-                        const F = this._getLinearGradient();
-                        t.strokeStyle = F || h, t.stroke(), t.restore()
-                    }
-                    if (f !== 0 || u === Uc) {
-                        E = _.split(" ").length - 1;
-                        for (var k = KM(_), R = 0; R < k.length; R++) {
-                            var $ = k[R];
-                            $ === " " && !w && u === Uc && (v += (c - r * 2 - S) / E), this._partialTextX = v, this._partialTextY = y + b, this._partialText = $, t.fillStrokeShape(this), v += this.measureSize($).width + f
-                        }
-                    } else this._partialTextX = v, this._partialTextY = y + b, this._partialText = _, t.fillStrokeShape(this);
-                    t.restore(), i > 1 && (y += a)
-                }
-            }
-        }
-        _hitFunc(t) {
-            var n = this.getWidth(),
-                i = this.getHeight();
-            t.beginPath(), t.rect(0, 0, n, i), t.closePath(), t.fillStrokeShape(this)
-        }
-        setText(t) {
-            var n = D._isString(t) ? t : t == null ? "" : t + "";
-            return this._setAttr(_7, n), this
-        }
-        getWidth() {
-            var t = this.attrs.width === Wl || this.attrs.width === void 0;
-            return t ? this.getTextWidth() + this.padding() * 2 : this.attrs.width
-        }
-        getHeight() {
-            var t = this.attrs.height === Wl || this.attrs.height === void 0;
-            return t ? this.fontSize() * this.textArr.length * this.lineHeight() + this.padding() * 2 : this.attrs.height
-        }
-        getTextWidth() {
-            return this.textWidth
-        }
-        getTextHeight() {
-            return D.warn("text.getTextHeight() method is deprecated. Use text.height() - for full height and text.fontSize() - for one line height."), this.textHeight
-        }
-        measureSize(t) {
-            var n = my(),
-                i = this.fontSize(),
-                r;
-            return n.save(), n.font = this._getContextFont(), r = n.measureText(t), n.restore(), {
-                width: r.width,
-                height: i
-            }
-        }
-        _getContextFont() {
-            return this.fontStyle() + Kd + this.fontVariant() + Kd + (this.fontSize() + C7) + M7(this.fontFamily())
-        }
-        _addTextLine(t) {
-            this.align() === Uc && (t = t.trim());
-            var i = this._getTextWidth(t);
-            return this.textArr.push({
-                text: t,
-                width: i,
-                lastInParagraph: !1
-            })
-        }
-        _getTextWidth(t) {
-            var n = this.letterSpacing(),
-                i = t.length;
-            return my().measureText(t).width + (i ? n * (i - 1) : 0)
-        }
-        _setTextData() {
-            var t = this.text().split(`
-`),
-                n = +this.fontSize(),
-                i = 0,
-                r = this.lineHeight() * n,
-                s = this.attrs.width,
-                a = this.attrs.height,
-                o = s !== Wl && s !== void 0,
-                l = a !== Wl && a !== void 0,
-                u = this.padding(),
-                c = s - u * 2,
-                f = a - u * 2,
-                h = 0,
-                d = this.wrap(),
-                g = d !== xk,
-                p = d !== $7 && g,
-                m = this.ellipsis();
-            this.textArr = [], my().font = this._getContextFont();
-            for (var y = m ? this._getTextWidth(py) : 0, v = 0, b = t.length; v < b; ++v) {
-                var x = t[v],
-                    _ = this._getTextWidth(x);
-                if (o && _ > c)
-                    for (; x.length > 0;) {
-                        for (var S = 0, w = x.length, E = "", A = 0; S < w;) {
-                            var C = S + w >>> 1,
-                                k = x.slice(0, C + 1),
-                                R = this._getTextWidth(k) + y;
-                            R <= c ? (S = C + 1, E = k, A = R) : w = C
-                        }
-                        if (E) {
-                            if (p) {
-                                var $, T = x[E.length],
-                                    M = T === Kd || T === vk;
-                                M && A <= c ? $ = E.length : $ = Math.max(E.lastIndexOf(Kd), E.lastIndexOf(vk)) + 1, $ > 0 && (S = $, E = E.slice(0, S), A = this._getTextWidth(E))
-                            }
-                            E = E.trimRight(), this._addTextLine(E), i = Math.max(i, A), h += r;
-                            var F = this._shouldHandleEllipsis(h);
-                            if (F) {
-                                this._tryToAddEllipsisToLastLine();
-                                break
-                            }
-                            if (x = x.slice(S), x = x.trimLeft(), x.length > 0 && (_ = this._getTextWidth(x), _ <= c)) {
-                                this._addTextLine(x), h += r, i = Math.max(i, _);
-                                break
-                            }
-                        } else break
-                    } else this._addTextLine(x), h += r, i = Math.max(i, _), this._shouldHandleEllipsis(h) && v < b - 1 && this._tryToAddEllipsisToLastLine();
-                if (this.textArr[this.textArr.length - 1] && (this.textArr[this.textArr.length - 1].lastInParagraph = !0), l && h + r > f) break
-            }
-            this.textHeight = n, this.textWidth = i
-        }
-        _shouldHandleEllipsis(t) {
-            var n = +this.fontSize(),
-                i = this.lineHeight() * n,
-                r = this.attrs.height,
-                s = r !== Wl && r !== void 0,
-                a = this.padding(),
-                o = r - a * 2,
-                l = this.wrap(),
-                u = l !== xk;
-            return !u || s && t + i > o
-        }
-        _tryToAddEllipsisToLastLine() {
-            var t = this.attrs.width,
-                n = t !== Wl && t !== void 0,
-                i = this.padding(),
-                r = t - i * 2,
-                s = this.ellipsis(),
-                a = this.textArr[this.textArr.length - 1];
-            if (!(!a || !s)) {
-                if (n) {
-                    var o = this._getTextWidth(a.text + py) < r;
-                    o || (a.text = a.text.slice(0, a.text.length - 3))
-                }
-                this.textArr.splice(this.textArr.length - 1, 1), this._addTextLine(a.text + py)
-            }
-        }
-        getStrokeScaleEnabled() {
-            return !0
-        }
+
+    function aG(e, t) {
+        return Qe(1 + Ys.count(as(e), e), t, 3)
     }
-    gt.prototype._fillFunc = O7;
-    gt.prototype._strokeFunc = F7;
-    gt.prototype.className = w7;
-    gt.prototype._attrsAffectingSize = ["text", "fontSize", "padding", "wrap", "lineHeight", "letterSpacing"];
-    pt(gt);
-    O.overWriteSetter(gt, "width", mx());
-    O.overWriteSetter(gt, "height", mx());
-    O.addGetterSetter(gt, "fontFamily", "Arial");
-    O.addGetterSetter(gt, "fontSize", 12, te());
-    O.addGetterSetter(gt, "fontStyle", QM);
-    O.addGetterSetter(gt, "fontVariant", QM);
-    O.addGetterSetter(gt, "padding", 0, te());
-    O.addGetterSetter(gt, "align", JM);
-    O.addGetterSetter(gt, "verticalAlign", S7);
-    O.addGetterSetter(gt, "lineHeight", 1, te());
-    O.addGetterSetter(gt, "wrap", A7);
-    O.addGetterSetter(gt, "ellipsis", !1, mr());
-    O.addGetterSetter(gt, "letterSpacing", 0, te());
-    O.addGetterSetter(gt, "text", "", hc());
-    O.addGetterSetter(gt, "textDecoration", "");
-    var D7 = "",
-        eO = "normal";
 
-    function tO(e) {
-        e.fillText(this.partialText, 0, 0)
+    function eR(e, t) {
+        return Qe(e.getMilliseconds(), t, 3)
     }
 
-    function nO(e) {
-        e.strokeText(this.partialText, 0, 0)
+    function oG(e, t) {
+        return eR(e, t) + "000"
     }
-    class Rt extends V {
-        constructor(t) {
-            super(t), this.dummyCanvas = D.createCanvasElement(), this.dataArray = [], this.dataArray = Yt.parsePathData(this.attrs.data), this.on("dataChange.konva", function() {
-                this.dataArray = Yt.parsePathData(this.attrs.data), this._setTextData()
-            }), this.on("textChange.konva alignChange.konva letterSpacingChange.konva kerningFuncChange.konva fontSizeChange.konva fontFamilyChange.konva", this._setTextData), this._setTextData()
-        }
-        _sceneFunc(t) {
-            t.setAttr("font", this._getContextFont()), t.setAttr("textBaseline", this.textBaseline()), t.setAttr("textAlign", "left"), t.save();
-            var n = this.textDecoration(),
-                i = this.fill(),
-                r = this.fontSize(),
-                s = this.glyphInfo;
-            n === "underline" && t.beginPath();
-            for (var a = 0; a < s.length; a++) {
-                t.save();
-                var o = s[a].p0;
-                t.translate(o.x, o.y), t.rotate(s[a].rotation), this.partialText = s[a].text, t.fillStrokeShape(this), n === "underline" && (a === 0 && t.moveTo(0, r / 2 + 1), t.lineTo(r, r / 2 + 1)), t.restore()
-            }
-            n === "underline" && (t.strokeStyle = i, t.lineWidth = r / 20, t.stroke()), t.restore()
-        }
-        _hitFunc(t) {
-            t.beginPath();
-            var n = this.glyphInfo;
-            if (n.length >= 1) {
-                var i = n[0].p0;
-                t.moveTo(i.x, i.y)
-            }
-            for (var r = 0; r < n.length; r++) {
-                var s = n[r].p1;
-                t.lineTo(s.x, s.y)
-            }
-            t.setAttr("lineWidth", this.fontSize()), t.setAttr("strokeStyle", this.colorKey), t.stroke()
-        }
-        getTextWidth() {
-            return this.textWidth
-        }
-        getTextHeight() {
-            return D.warn("text.getTextHeight() method is deprecated. Use text.height() - for full height and text.fontSize() - for one line height."), this.textHeight
-        }
-        setText(t) {
-            return gt.prototype.setText.call(this, t)
-        }
-        _getContextFont() {
-            return gt.prototype._getContextFont.call(this)
-        }
-        _getTextSize(t) {
-            var n = this.dummyCanvas,
-                i = n.getContext("2d");
-            i.save(), i.font = this._getContextFont();
-            var r = i.measureText(t);
-            return i.restore(), {
-                width: r.width,
-                height: parseInt(this.attrs.fontSize, 10)
-            }
-        }
-        _setTextData() {
-            var t = this,
-                n = this._getTextSize(this.attrs.text),
-                i = this.letterSpacing(),
-                r = this.align(),
-                s = this.kerningFunc();
-            this.textWidth = n.width, this.textHeight = n.height;
-            var a = Math.max(this.textWidth + ((this.attrs.text || "").length - 1) * i, 0);
-            this.glyphInfo = [];
-            for (var o = 0, l = 0; l < t.dataArray.length; l++) t.dataArray[l].pathLength > 0 && (o += t.dataArray[l].pathLength);
-            var u = 0;
-            r === "center" && (u = Math.max(0, o / 2 - a / 2)), r === "right" && (u = Math.max(0, o - a));
-            for (var c = KM(this.text()), f = this.text().split(" ").length - 1, h, d, g, p = -1, m = 0, y = function() {
-                    m = 0;
-                    for (var R = t.dataArray, $ = p + 1; $ < R.length; $++) {
-                        if (R[$].pathLength > 0) return p = $, R[$];
-                        R[$].command === "M" && (h = {
-                            x: R[$].points[0],
-                            y: R[$].points[1]
-                        })
-                    }
-                    return {}
-                }, v = function(R) {
-                    var $ = t._getTextSize(R).width + i;
-                    R === " " && r === "justify" && ($ += (o - a) / f);
-                    var T = 0,
-                        M = 0;
-                    for (d = void 0; Math.abs($ - T) / $ > .01 && M < 20;) {
-                        M++;
-                        for (var F = T; g === void 0;) g = y(), g && F + g.pathLength < $ && (F += g.pathLength, g = void 0);
-                        if (Object.keys(g).length === 0 || h === void 0) return;
-                        var N = !1;
-                        switch (g.command) {
-                            case "L":
-                                Yt.getLineLength(h.x, h.y, g.points[0], g.points[1]) > $ ? d = Yt.getPointOnLine($, h.x, h.y, g.points[0], g.points[1], h.x, h.y) : g = void 0;
-                                break;
-                            case "A":
-                                var P = g.points[4],
-                                    z = g.points[5],
-                                    I = g.points[4] + z;
-                                m === 0 ? m = P + 1e-8 : $ > T ? m += Math.PI / 180 * z / Math.abs(z) : m -= Math.PI / 360 * z / Math.abs(z), (z < 0 && m < I || z >= 0 && m > I) && (m = I, N = !0), d = Yt.getPointOnEllipticalArc(g.points[0], g.points[1], g.points[2], g.points[3], m, g.points[6]);
-                                break;
-                            case "C":
-                                m === 0 ? $ > g.pathLength ? m = 1e-8 : m = $ / g.pathLength : $ > T ? m += ($ - T) / g.pathLength / 2 : m = Math.max(m - (T - $) / g.pathLength / 2, 0), m > 1 && (m = 1, N = !0), d = Yt.getPointOnCubicBezier(m, g.start.x, g.start.y, g.points[0], g.points[1], g.points[2], g.points[3], g.points[4], g.points[5]);
-                                break;
-                            case "Q":
-                                m === 0 ? m = $ / g.pathLength : $ > T ? m += ($ - T) / g.pathLength : m -= (T - $) / g.pathLength, m > 1 && (m = 1, N = !0), d = Yt.getPointOnQuadraticBezier(m, g.start.x, g.start.y, g.points[0], g.points[1], g.points[2], g.points[3]);
-                                break
-                        }
-                        d !== void 0 && (T = Yt.getLineLength(h.x, h.y, d.x, d.y)), N && (N = !1, g = void 0)
-                    }
-                }, b = "C", x = t._getTextSize(b).width + i, _ = u / x - 1, S = 0; S < _ && (v(b), !(h === void 0 || d === void 0)); S++) h = d;
-            for (var w = 0; w < c.length && (v(c[w]), !(h === void 0 || d === void 0)); w++) {
-                var E = Yt.getLineLength(h.x, h.y, d.x, d.y),
-                    A = 0;
-                if (s) try {
-                    A = s(c[w - 1], c[w]) * this.fontSize()
-                } catch {
-                    A = 0
-                }
-                h.x += A, d.x += A, this.textWidth += A;
-                var C = Yt.getPointOnLine(A + E / 2, h.x, h.y, d.x, d.y),
-                    k = Math.atan2(d.y - h.y, d.x - h.x);
-                this.glyphInfo.push({
-                    transposeX: C.x,
-                    transposeY: C.y,
-                    text: c[w],
-                    rotation: k,
-                    p0: h,
-                    p1: d
-                }), h = d
-            }
-        }
-        getSelfRect() {
-            if (!this.glyphInfo.length) return {
-                x: 0,
-                y: 0,
-                width: 0,
-                height: 0
-            };
-            var t = [];
-            this.glyphInfo.forEach(function(c) {
-                t.push(c.p0.x), t.push(c.p0.y), t.push(c.p1.x), t.push(c.p1.y)
-            });
-            for (var n = t[0] || 0, i = t[0] || 0, r = t[1] || 0, s = t[1] || 0, a, o, l = 0; l < t.length / 2; l++) a = t[l * 2], o = t[l * 2 + 1], n = Math.min(n, a), i = Math.max(i, a), r = Math.min(r, o), s = Math.max(s, o);
-            var u = this.fontSize();
-            return {
-                x: n - u / 2,
-                y: r - u / 2,
-                width: i - n + u,
-                height: s - r + u
-            }
-        }
-        destroy() {
-            return D.releaseCanvas(this.dummyCanvas), super.destroy()
-        }
+
+    function lG(e, t) {
+        return Qe(e.getMonth() + 1, t, 2)
     }
-    Rt.prototype._fillFunc = tO;
-    Rt.prototype._strokeFunc = nO;
-    Rt.prototype._fillFuncHit = tO;
-    Rt.prototype._strokeFuncHit = nO;
-    Rt.prototype.className = "TextPath";
-    Rt.prototype._attrsAffectingSize = ["text", "fontSize", "data"];
-    pt(Rt);
-    O.addGetterSetter(Rt, "data");
-    O.addGetterSetter(Rt, "fontFamily", "Arial");
-    O.addGetterSetter(Rt, "fontSize", 12, te());
-    O.addGetterSetter(Rt, "fontStyle", eO);
-    O.addGetterSetter(Rt, "align", "left");
-    O.addGetterSetter(Rt, "letterSpacing", 0, te());
-    O.addGetterSetter(Rt, "textBaseline", "middle");
-    O.addGetterSetter(Rt, "fontVariant", eO);
-    O.addGetterSetter(Rt, "text", D7);
-    O.addGetterSetter(Rt, "textDecoration", null);
-    O.addGetterSetter(Rt, "kerningFunc", null);
-    var iO = "tr-konva",
-        N7 = ["resizeEnabledChange", "rotateAnchorOffsetChange", "rotateEnabledChange", "enabledAnchorsChange", "anchorSizeChange", "borderEnabledChange", "borderStrokeChange", "borderStrokeWidthChange", "borderDashChange", "anchorStrokeChange", "anchorStrokeWidthChange", "anchorFillChange", "anchorCornerRadiusChange", "ignoreStrokeChange"].map(e => e + `.${iO}`).join(" "),
-        _k = "nodesRect",
-        P7 = ["widthChange", "heightChange", "scaleXChange", "scaleYChange", "skewXChange", "skewYChange", "rotationChange", "offsetXChange", "offsetYChange", "transformsEnabledChange", "strokeWidthChange"],
-        L7 = {
-            "top-left": -45,
-            "top-center": 0,
-            "top-right": 45,
-            "middle-right": -90,
-            "middle-left": 90,
-            "bottom-left": -135,
-            "bottom-center": 180,
-            "bottom-right": 135
-        };
-    const I7 = "ontouchstart" in le._global;
 
-    function z7(e, t) {
-        if (e === "rotater") return "crosshair";
-        t += D.degToRad(L7[e] || 0);
-        var n = (D.radToDeg(t) % 360 + 360) % 360;
-        return D._inRange(n, 315 + 22.5, 360) || D._inRange(n, 0, 22.5) ? "ns-resize" : D._inRange(n, 45 - 22.5, 45 + 22.5) ? "nesw-resize" : D._inRange(n, 90 - 22.5, 90 + 22.5) ? "ew-resize" : D._inRange(n, 135 - 22.5, 135 + 22.5) ? "nwse-resize" : D._inRange(n, 180 - 22.5, 180 + 22.5) ? "ns-resize" : D._inRange(n, 225 - 22.5, 225 + 22.5) ? "nesw-resize" : D._inRange(n, 270 - 22.5, 270 + 22.5) ? "ew-resize" : D._inRange(n, 315 - 22.5, 315 + 22.5) ? "nwse-resize" : (D.error("Transformer has unknown angle for cursor detection: " + n), "pointer")
+    function uG(e, t) {
+        return Qe(e.getMinutes(), t, 2)
     }
-    var mp = ["top-left", "top-center", "top-right", "middle-right", "middle-left", "bottom-left", "bottom-center", "bottom-right"],
-        wk = 1e8;
 
-    function B7(e) {
-        return {
-            x: e.x + e.width / 2 * Math.cos(e.rotation) + e.height / 2 * Math.sin(-e.rotation),
-            y: e.y + e.height / 2 * Math.cos(e.rotation) + e.width / 2 * Math.sin(e.rotation)
-        }
+    function cG(e, t) {
+        return Qe(e.getSeconds(), t, 2)
     }
 
-    function rO(e, t, n) {
-        const i = n.x + (e.x - n.x) * Math.cos(t) - (e.y - n.y) * Math.sin(t),
-            r = n.y + (e.x - n.x) * Math.sin(t) + (e.y - n.y) * Math.cos(t);
-        return Object.assign(Object.assign({}, e), {
-            rotation: e.rotation + t,
-            x: i,
-            y: r
-        })
+    function fG(e) {
+        var t = e.getDay();
+        return t === 0 ? 7 : t
     }
 
-    function j7(e, t) {
-        const n = B7(e);
-        return rO(e, t, n)
+    function hG(e, t) {
+        return Qe(Wc.count(as(e) - 1, e), t, 2)
     }
 
-    function U7(e, t, n) {
-        let i = t;
-        for (let r = 0; r < e.length; r++) {
-            const s = le.getAngle(e[r]),
-                a = Math.abs(s - t) % (Math.PI * 2);
-            Math.min(a, Math.PI * 2 - a) < n && (i = s)
-        }
-        return i
+    function tR(e) {
+        var t = e.getDay();
+        return t >= 4 || t === 0 ? sc(e) : sc.ceil(e)
     }
-    class Ke extends Mu {
-        constructor(t) {
-            super(t), this._transforming = !1, this._createElements(), this._handleMouseMove = this._handleMouseMove.bind(this), this._handleMouseUp = this._handleMouseUp.bind(this), this.update = this.update.bind(this), this.on(N7, this.update), this.getNode() && this.update()
-        }
-        attachTo(t) {
-            return this.setNode(t), this
-        }
-        setNode(t) {
-            return D.warn("tr.setNode(shape), tr.node(shape) and tr.attachTo(shape) methods are deprecated. Please use tr.nodes(nodesArray) instead."), this.setNodes([t])
-        }
-        getNode() {
-            return this._nodes && this._nodes[0]
-        }
-        _getEventNamespace() {
-            return iO + this._id
-        }
-        setNodes(t = []) {
-            this._nodes && this._nodes.length && this.detach();
-            const n = t.filter(r => r.isAncestorOf(this) ? (D.error("Konva.Transformer cannot be an a child of the node you are trying to attach"), !1) : !0);
-            this._nodes = t = n, t.length === 1 && this.useSingleNodeRotation() ? this.rotation(t[0].getAbsoluteRotation()) : this.rotation(0), this._nodes.forEach(r => {
-                const s = () => {
-                        this.nodes().length === 1 && this.useSingleNodeRotation() && this.rotation(this.nodes()[0].getAbsoluteRotation()), this._resetTransformCache(), !this._transforming && !this.isDragging() && this.update()
-                    },
-                    a = r._attrsAffectingSize.map(o => o + "Change." + this._getEventNamespace()).join(" ");
-                r.on(a, s), r.on(P7.map(o => o + `.${this._getEventNamespace()}`).join(" "), s), r.on(`absoluteTransformChange.${this._getEventNamespace()}`, s), this._proxyDrag(r)
-            }), this._resetTransformCache();
-            var i = !!this.findOne(".top-left");
-            return i && this.update(), this
-        }
-        _proxyDrag(t) {
-            let n;
-            t.on(`dragstart.${this._getEventNamespace()}`, i => {
-                n = t.getAbsolutePosition(), !this.isDragging() && t !== this.findOne(".back") && this.startDrag(i, !1)
-            }), t.on(`dragmove.${this._getEventNamespace()}`, i => {
-                if (!n) return;
-                const r = t.getAbsolutePosition(),
-                    s = r.x - n.x,
-                    a = r.y - n.y;
-                this.nodes().forEach(o => {
-                    if (o === t || o.isDragging()) return;
-                    const l = o.getAbsolutePosition();
-                    o.setAbsolutePosition({
-                        x: l.x + s,
-                        y: l.y + a
-                    }), o.startDrag(i)
-                }), n = null
-            })
-        }
-        getNodes() {
-            return this._nodes || []
-        }
-        getActiveAnchor() {
-            return this._movingAnchorName
-        }
-        detach() {
-            this._nodes && this._nodes.forEach(t => {
-                t.off("." + this._getEventNamespace())
-            }), this._nodes = [], this._resetTransformCache()
-        }
-        _resetTransformCache() {
-            this._clearCache(_k), this._clearCache("transform"), this._clearSelfAndDescendantCache("absoluteTransform")
-        }
-        _getNodeRect() {
-            return this._getCache(_k, this.__getNodeRect)
-        }
-        __getNodeShape(t, n = this.rotation(), i) {
-            var r = t.getClientRect({
-                    skipTransform: !0,
-                    skipShadow: !0,
-                    skipStroke: this.ignoreStroke()
-                }),
-                s = t.getAbsoluteScale(i),
-                a = t.getAbsolutePosition(i),
-                o = r.x * s.x - t.offsetX() * s.x,
-                l = r.y * s.y - t.offsetY() * s.y;
-            const u = (le.getAngle(t.getAbsoluteRotation()) + Math.PI * 2) % (Math.PI * 2),
-                c = {
-                    x: a.x + o * Math.cos(u) + l * Math.sin(-u),
-                    y: a.y + l * Math.cos(u) + o * Math.sin(u),
-                    width: r.width * s.x,
-                    height: r.height * s.y,
-                    rotation: u
-                };
-            return rO(c, -le.getAngle(n), {
-                x: 0,
-                y: 0
-            })
-        }
-        __getNodeRect() {
-            var t = this.getNode();
-            if (!t) return {
-                x: -wk,
-                y: -wk,
-                width: 0,
-                height: 0,
-                rotation: 0
-            };
-            const n = [];
-            this.nodes().map(u => {
-                const c = u.getClientRect({
-                    skipTransform: !0,
-                    skipShadow: !0,
-                    skipStroke: this.ignoreStroke()
-                });
-                var f = [{
-                        x: c.x,
-                        y: c.y
-                    }, {
-                        x: c.x + c.width,
-                        y: c.y
-                    }, {
-                        x: c.x + c.width,
-                        y: c.y + c.height
-                    }, {
-                        x: c.x,
-                        y: c.y + c.height
-                    }],
-                    h = u.getAbsoluteTransform();
-                f.forEach(function(d) {
-                    var g = h.point(d);
-                    n.push(g)
-                })
-            });
-            const i = new Ki;
-            i.rotate(-le.getAngle(this.rotation()));
-            var r, s, a, o;
-            n.forEach(function(u) {
-                var c = i.point(u);
-                r === void 0 && (r = a = c.x, s = o = c.y), r = Math.min(r, c.x), s = Math.min(s, c.y), a = Math.max(a, c.x), o = Math.max(o, c.y)
-            }), i.invert();
-            const l = i.point({
-                x: r,
-                y: s
-            });
-            return {
-                x: l.x,
-                y: l.y,
-                width: a - r,
-                height: o - s,
-                rotation: le.getAngle(this.rotation())
-            }
-        }
-        getX() {
-            return this._getNodeRect().x
-        }
-        getY() {
-            return this._getNodeRect().y
-        }
-        getWidth() {
-            return this._getNodeRect().width
-        }
-        getHeight() {
-            return this._getNodeRect().height
-        }
-        _createElements() {
-            this._createBack(), mp.forEach(function(t) {
-                this._createAnchor(t)
-            }.bind(this)), this._createAnchor("rotater")
-        }
-        _createAnchor(t) {
-            var n = new Vh({
-                    stroke: "rgb(0, 161, 255)",
-                    fill: "white",
-                    strokeWidth: 1,
-                    name: t + " _anchor",
-                    dragDistance: 0,
-                    draggable: !0,
-                    hitStrokeWidth: I7 ? 10 : "auto"
-                }),
-                i = this;
-            n.on("mousedown touchstart", function(r) {
-                i._handleMouseDown(r)
-            }), n.on("dragstart", r => {
-                n.stopDrag(), r.cancelBubble = !0
-            }), n.on("dragend", r => {
-                r.cancelBubble = !0
-            }), n.on("mouseenter", () => {
-                var r = le.getAngle(this.rotation()),
-                    s = z7(t, r);
-                n.getStage().content && (n.getStage().content.style.cursor = s), this._cursorChange = !0
-            }), n.on("mouseout", () => {
-                n.getStage().content && (n.getStage().content.style.cursor = ""), this._cursorChange = !1
-            }), this.add(n)
-        }
-        _createBack() {
-            var t = new V({
-                name: "back",
-                width: 0,
-                height: 0,
-                draggable: !0,
-                sceneFunc(n) {
-                    var i = this.getParent(),
-                        r = i.padding();
-                    n.beginPath(), n.rect(-r, -r, this.width() + r * 2, this.height() + r * 2), n.moveTo(this.width() / 2, -r), i.rotateEnabled() && n.lineTo(this.width() / 2, -i.rotateAnchorOffset() * D._sign(this.height()) - r), n.fillStrokeShape(this)
-                },
-                hitFunc: (n, i) => {
-                    if (this.shouldOverdrawWholeArea()) {
-                        var r = this.padding();
-                        n.beginPath(), n.rect(-r, -r, i.width() + r * 2, i.height() + r * 2), n.fillStrokeShape(i)
-                    }
-                }
-            });
-            this.add(t), this._proxyDrag(t), t.on("dragstart", n => {
-                n.cancelBubble = !0
-            }), t.on("dragmove", n => {
-                n.cancelBubble = !0
-            }), t.on("dragend", n => {
-                n.cancelBubble = !0
-            }), this.on("dragmove", n => {
-                this.update()
-            })
-        }
-        _handleMouseDown(t) {
-            this._movingAnchorName = t.target.name().split(" ")[0];
-            var n = this._getNodeRect(),
-                i = n.width,
-                r = n.height,
-                s = Math.sqrt(Math.pow(i, 2) + Math.pow(r, 2));
-            this.sin = Math.abs(r / s), this.cos = Math.abs(i / s), typeof window < "u" && (window.addEventListener("mousemove", this._handleMouseMove), window.addEventListener("touchmove", this._handleMouseMove), window.addEventListener("mouseup", this._handleMouseUp, !0), window.addEventListener("touchend", this._handleMouseUp, !0)), this._transforming = !0;
-            var a = t.target.getAbsolutePosition(),
-                o = t.target.getStage().getPointerPosition();
-            this._anchorDragOffset = {
-                x: o.x - a.x,
-                y: o.y - a.y
-            }, this._fire("transformstart", {
-                evt: t.evt,
-                target: this.getNode()
-            }), this._nodes.forEach(l => {
-                l._fire("transformstart", {
-                    evt: t.evt,
-                    target: l
-                })
-            })
-        }
-        _handleMouseMove(t) {
-            var n, i, r, s = this.findOne("." + this._movingAnchorName),
-                a = s.getStage();
-            a.setPointersPositions(t);
-            const o = a.getPointerPosition();
-            let l = {
-                x: o.x - this._anchorDragOffset.x,
-                y: o.y - this._anchorDragOffset.y
-            };
-            const u = s.getAbsolutePosition();
-            this.anchorDragBoundFunc() && (l = this.anchorDragBoundFunc()(u, l, t)), s.setAbsolutePosition(l);
-            const c = s.getAbsolutePosition();
-            if (!(u.x === c.x && u.y === c.y)) {
-                if (this._movingAnchorName === "rotater") {
-                    var f = this._getNodeRect();
-                    n = s.x() - f.width / 2, i = -s.y() + f.height / 2;
-                    let R = Math.atan2(-i, n) + Math.PI / 2;
-                    f.height < 0 && (R -= Math.PI);
-                    var h = le.getAngle(this.rotation());
-                    const $ = h + R,
-                        T = le.getAngle(this.rotationSnapTolerance()),
-                        F = U7(this.rotationSnaps(), $, T) - f.rotation,
-                        N = j7(f, F);
-                    this._fitNodesInto(N, t);
-                    return
-                }
-                var d = this.keepRatio() || t.shiftKey,
-                    v = this.centeredScaling() || t.altKey;
-                if (this._movingAnchorName === "top-left") {
-                    if (d) {
-                        var g = v ? {
-                            x: this.width() / 2,
-                            y: this.height() / 2
-                        } : {
-                            x: this.findOne(".bottom-right").x(),
-                            y: this.findOne(".bottom-right").y()
-                        };
-                        r = Math.sqrt(Math.pow(g.x - s.x(), 2) + Math.pow(g.y - s.y(), 2));
-                        var p = this.findOne(".top-left").x() > g.x ? -1 : 1,
-                            m = this.findOne(".top-left").y() > g.y ? -1 : 1;
-                        n = r * this.cos * p, i = r * this.sin * m, this.findOne(".top-left").x(g.x - n), this.findOne(".top-left").y(g.y - i)
-                    }
-                } else if (this._movingAnchorName === "top-center") this.findOne(".top-left").y(s.y());
-                else if (this._movingAnchorName === "top-right") {
-                    if (d) {
-                        var g = v ? {
-                            x: this.width() / 2,
-                            y: this.height() / 2
-                        } : {
-                            x: this.findOne(".bottom-left").x(),
-                            y: this.findOne(".bottom-left").y()
-                        };
-                        r = Math.sqrt(Math.pow(s.x() - g.x, 2) + Math.pow(g.y - s.y(), 2));
-                        var p = this.findOne(".top-right").x() < g.x ? -1 : 1,
-                            m = this.findOne(".top-right").y() > g.y ? -1 : 1;
-                        n = r * this.cos * p, i = r * this.sin * m, this.findOne(".top-right").x(g.x + n), this.findOne(".top-right").y(g.y - i)
-                    }
-                    var y = s.position();
-                    this.findOne(".top-left").y(y.y), this.findOne(".bottom-right").x(y.x)
-                } else if (this._movingAnchorName === "middle-left") this.findOne(".top-left").x(s.x());
-                else if (this._movingAnchorName === "middle-right") this.findOne(".bottom-right").x(s.x());
-                else if (this._movingAnchorName === "bottom-left") {
-                    if (d) {
-                        var g = v ? {
-                            x: this.width() / 2,
-                            y: this.height() / 2
-                        } : {
-                            x: this.findOne(".top-right").x(),
-                            y: this.findOne(".top-right").y()
-                        };
-                        r = Math.sqrt(Math.pow(g.x - s.x(), 2) + Math.pow(s.y() - g.y, 2));
-                        var p = g.x < s.x() ? -1 : 1,
-                            m = s.y() < g.y ? -1 : 1;
-                        n = r * this.cos * p, i = r * this.sin * m, s.x(g.x - n), s.y(g.y + i)
-                    }
-                    y = s.position(), this.findOne(".top-left").x(y.x), this.findOne(".bottom-right").y(y.y)
-                } else if (this._movingAnchorName === "bottom-center") this.findOne(".bottom-right").y(s.y());
-                else if (this._movingAnchorName === "bottom-right") {
-                    if (d) {
-                        var g = v ? {
-                            x: this.width() / 2,
-                            y: this.height() / 2
-                        } : {
-                            x: this.findOne(".top-left").x(),
-                            y: this.findOne(".top-left").y()
-                        };
-                        r = Math.sqrt(Math.pow(s.x() - g.x, 2) + Math.pow(s.y() - g.y, 2));
-                        var p = this.findOne(".bottom-right").x() < g.x ? -1 : 1,
-                            m = this.findOne(".bottom-right").y() < g.y ? -1 : 1;
-                        n = r * this.cos * p, i = r * this.sin * m, this.findOne(".bottom-right").x(g.x + n), this.findOne(".bottom-right").y(g.y + i)
-                    }
-                } else console.error(new Error("Wrong position argument of selection resizer: " + this._movingAnchorName));
-                var v = this.centeredScaling() || t.altKey;
-                if (v) {
-                    var b = this.findOne(".top-left"),
-                        x = this.findOne(".bottom-right"),
-                        _ = b.x(),
-                        S = b.y(),
-                        w = this.getWidth() - x.x(),
-                        E = this.getHeight() - x.y();
-                    x.move({
-                        x: -_,
-                        y: -S
-                    }), b.move({
-                        x: w,
-                        y: E
-                    })
-                }
-                var A = this.findOne(".top-left").getAbsolutePosition();
-                n = A.x, i = A.y;
-                var C = this.findOne(".bottom-right").x() - this.findOne(".top-left").x(),
-                    k = this.findOne(".bottom-right").y() - this.findOne(".top-left").y();
-                this._fitNodesInto({
-                    x: n,
-                    y: i,
-                    width: C,
-                    height: k,
-                    rotation: le.getAngle(this.rotation())
-                }, t)
-            }
-        }
-        _handleMouseUp(t) {
-            this._removeEvents(t)
-        }
-        getAbsoluteTransform() {
-            return this.getTransform()
-        }
-        _removeEvents(t) {
-            if (this._transforming) {
-                this._transforming = !1, typeof window < "u" && (window.removeEventListener("mousemove", this._handleMouseMove), window.removeEventListener("touchmove", this._handleMouseMove), window.removeEventListener("mouseup", this._handleMouseUp, !0), window.removeEventListener("touchend", this._handleMouseUp, !0));
-                var n = this.getNode();
-                this._fire("transformend", {
-                    evt: t,
-                    target: n
-                }), n && this._nodes.forEach(i => {
-                    i._fire("transformend", {
-                        evt: t,
-                        target: i
-                    })
-                }), this._movingAnchorName = null
-            }
-        }
-        _fitNodesInto(t, n) {
-            var i = this._getNodeRect();
-            const r = 1;
-            if (D._inRange(t.width, -this.padding() * 2 - r, r)) {
-                this.update();
-                return
-            }
-            if (D._inRange(t.height, -this.padding() * 2 - r, r)) {
-                this.update();
-                return
-            }
-            const s = this.flipEnabled();
-            var a = new Ki;
-            if (a.rotate(le.getAngle(this.rotation())), this._movingAnchorName && t.width < 0 && this._movingAnchorName.indexOf("left") >= 0) {
-                const f = a.point({
-                    x: -this.padding() * 2,
-                    y: 0
-                });
-                if (t.x += f.x, t.y += f.y, t.width += this.padding() * 2, this._movingAnchorName = this._movingAnchorName.replace("left", "right"), this._anchorDragOffset.x -= f.x, this._anchorDragOffset.y -= f.y, !s) {
-                    this.update();
-                    return
-                }
-            } else if (this._movingAnchorName && t.width < 0 && this._movingAnchorName.indexOf("right") >= 0) {
-                const f = a.point({
-                    x: this.padding() * 2,
-                    y: 0
-                });
-                if (this._movingAnchorName = this._movingAnchorName.replace("right", "left"), this._anchorDragOffset.x -= f.x, this._anchorDragOffset.y -= f.y, t.width += this.padding() * 2, !s) {
-                    this.update();
-                    return
-                }
-            }
-            if (this._movingAnchorName && t.height < 0 && this._movingAnchorName.indexOf("top") >= 0) {
-                const f = a.point({
-                    x: 0,
-                    y: -this.padding() * 2
-                });
-                if (t.x += f.x, t.y += f.y, this._movingAnchorName = this._movingAnchorName.replace("top", "bottom"), this._anchorDragOffset.x -= f.x, this._anchorDragOffset.y -= f.y, t.height += this.padding() * 2, !s) {
-                    this.update();
-                    return
-                }
-            } else if (this._movingAnchorName && t.height < 0 && this._movingAnchorName.indexOf("bottom") >= 0) {
-                const f = a.point({
-                    x: 0,
-                    y: this.padding() * 2
-                });
-                if (this._movingAnchorName = this._movingAnchorName.replace("bottom", "top"), this._anchorDragOffset.x -= f.x, this._anchorDragOffset.y -= f.y, t.height += this.padding() * 2, !s) {
-                    this.update();
-                    return
-                }
-            }
-            if (this.boundBoxFunc()) {
-                const f = this.boundBoxFunc()(i, t);
-                f ? t = f : D.warn("boundBoxFunc returned falsy. You should return new bound rect from it!")
-            }
-            const o = 1e7,
-                l = new Ki;
-            l.translate(i.x, i.y), l.rotate(i.rotation), l.scale(i.width / o, i.height / o);
-            const u = new Ki;
-            u.translate(t.x, t.y), u.rotate(t.rotation), u.scale(t.width / o, t.height / o);
-            const c = u.multiply(l.invert());
-            this._nodes.forEach(f => {
-                var h;
-                const d = f.getParent().getAbsoluteTransform(),
-                    g = f.getTransform().copy();
-                g.translate(f.offsetX(), f.offsetY());
-                const p = new Ki;
-                p.multiply(d.copy().invert()).multiply(c).multiply(d).multiply(g);
-                const m = p.decompose();
-                f.setAttrs(m), this._fire("transform", {
-                    evt: n,
-                    target: f
-                }), f._fire("transform", {
-                    evt: n,
-                    target: f
-                }), (h = f.getLayer()) === null || h === void 0 || h.batchDraw()
-            }), this.rotation(D._getRotation(t.rotation)), this._resetTransformCache(), this.update(), this.getLayer().batchDraw()
-        }
-        forceUpdate() {
-            this._resetTransformCache(), this.update()
-        }
-        _batchChangeChild(t, n) {
-            this.findOne(t).setAttrs(n)
-        }
-        update() {
-            var t, n = this._getNodeRect();
-            this.rotation(D._getRotation(n.rotation));
-            var i = n.width,
-                r = n.height,
-                s = this.enabledAnchors(),
-                a = this.resizeEnabled(),
-                o = this.padding(),
-                l = this.anchorSize();
-            this.find("._anchor").forEach(u => {
-                u.setAttrs({
-                    width: l,
-                    height: l,
-                    offsetX: l / 2,
-                    offsetY: l / 2,
-                    stroke: this.anchorStroke(),
-                    strokeWidth: this.anchorStrokeWidth(),
-                    fill: this.anchorFill(),
-                    cornerRadius: this.anchorCornerRadius()
-                })
-            }), this._batchChangeChild(".top-left", {
-                x: 0,
-                y: 0,
-                offsetX: l / 2 + o,
-                offsetY: l / 2 + o,
-                visible: a && s.indexOf("top-left") >= 0
-            }), this._batchChangeChild(".top-center", {
-                x: i / 2,
-                y: 0,
-                offsetY: l / 2 + o,
-                visible: a && s.indexOf("top-center") >= 0
-            }), this._batchChangeChild(".top-right", {
-                x: i,
-                y: 0,
-                offsetX: l / 2 - o,
-                offsetY: l / 2 + o,
-                visible: a && s.indexOf("top-right") >= 0
-            }), this._batchChangeChild(".middle-left", {
-                x: 0,
-                y: r / 2,
-                offsetX: l / 2 + o,
-                visible: a && s.indexOf("middle-left") >= 0
-            }), this._batchChangeChild(".middle-right", {
-                x: i,
-                y: r / 2,
-                offsetX: l / 2 - o,
-                visible: a && s.indexOf("middle-right") >= 0
-            }), this._batchChangeChild(".bottom-left", {
-                x: 0,
-                y: r,
-                offsetX: l / 2 + o,
-                offsetY: l / 2 - o,
-                visible: a && s.indexOf("bottom-left") >= 0
-            }), this._batchChangeChild(".bottom-center", {
-                x: i / 2,
-                y: r,
-                offsetY: l / 2 - o,
-                visible: a && s.indexOf("bottom-center") >= 0
-            }), this._batchChangeChild(".bottom-right", {
-                x: i,
-                y: r,
-                offsetX: l / 2 - o,
-                offsetY: l / 2 - o,
-                visible: a && s.indexOf("bottom-right") >= 0
-            }), this._batchChangeChild(".rotater", {
-                x: i / 2,
-                y: -this.rotateAnchorOffset() * D._sign(r) - o,
-                visible: this.rotateEnabled()
-            }), this._batchChangeChild(".back", {
-                width: i,
-                height: r,
-                visible: this.borderEnabled(),
-                stroke: this.borderStroke(),
-                strokeWidth: this.borderStrokeWidth(),
-                dash: this.borderDash(),
-                x: 0,
-                y: 0
-            }), (t = this.getLayer()) === null || t === void 0 || t.batchDraw()
-        }
-        isTransforming() {
-            return this._transforming
-        }
-        stopTransform() {
-            if (this._transforming) {
-                this._removeEvents();
-                var t = this.findOne("." + this._movingAnchorName);
-                t && t.stopDrag()
-            }
-        }
-        destroy() {
-            return this.getStage() && this._cursorChange && this.getStage().content && (this.getStage().content.style.cursor = ""), Mu.prototype.destroy.call(this), this.detach(), this._removeEvents(), this
-        }
-        toObject() {
-            return ne.prototype.toObject.call(this)
-        }
-        clone(t) {
-            var n = ne.prototype.clone.call(this, t);
-            return n
-        }
-        getClientRect() {
-            return this.nodes().length > 0 ? super.getClientRect() : {
-                x: 0,
-                y: 0,
-                width: 0,
-                height: 0
-            }
-        }
+
+    function dG(e, t) {
+        return e = tR(e), Qe(sc.count(as(e), e) + (as(e).getDay() === 4), t, 2)
     }
 
-    function G7(e) {
-        return e instanceof Array || D.warn("enabledAnchors value should be an array"), e instanceof Array && e.forEach(function(t) {
-            mp.indexOf(t) === -1 && D.warn("Unknown anchor name: " + t + ". Available names are: " + mp.join(", "))
-        }), e || []
+    function gG(e) {
+        return e.getDay()
     }
-    Ke.prototype.className = "Transformer";
-    pt(Ke);
-    O.addGetterSetter(Ke, "enabledAnchors", mp, G7);
-    O.addGetterSetter(Ke, "flipEnabled", !0, mr());
-    O.addGetterSetter(Ke, "resizeEnabled", !0);
-    O.addGetterSetter(Ke, "anchorSize", 10, te());
-    O.addGetterSetter(Ke, "rotateEnabled", !0);
-    O.addGetterSetter(Ke, "rotationSnaps", []);
-    O.addGetterSetter(Ke, "rotateAnchorOffset", 50, te());
-    O.addGetterSetter(Ke, "rotationSnapTolerance", 5, te());
-    O.addGetterSetter(Ke, "borderEnabled", !0);
-    O.addGetterSetter(Ke, "anchorStroke", "rgb(0, 161, 255)");
-    O.addGetterSetter(Ke, "anchorStrokeWidth", 1, te());
-    O.addGetterSetter(Ke, "anchorFill", "white");
-    O.addGetterSetter(Ke, "anchorCornerRadius", 0, te());
-    O.addGetterSetter(Ke, "borderStroke", "rgb(0, 161, 255)");
-    O.addGetterSetter(Ke, "borderStrokeWidth", 1, te());
-    O.addGetterSetter(Ke, "borderDash");
-    O.addGetterSetter(Ke, "keepRatio", !0);
-    O.addGetterSetter(Ke, "centeredScaling", !1);
-    O.addGetterSetter(Ke, "ignoreStroke", !1);
-    O.addGetterSetter(Ke, "padding", 0, te());
-    O.addGetterSetter(Ke, "node");
-    O.addGetterSetter(Ke, "nodes");
-    O.addGetterSetter(Ke, "boundBoxFunc");
-    O.addGetterSetter(Ke, "anchorDragBoundFunc");
-    O.addGetterSetter(Ke, "shouldOverdrawWholeArea", !1);
-    O.addGetterSetter(Ke, "useSingleNodeRotation", !0);
-    O.backCompat(Ke, {
-        lineEnabled: "borderEnabled",
-        rotateHandlerOffset: "rotateAnchorOffset",
-        enabledHandlers: "enabledAnchors"
-    });
-    class Ws extends V {
-        _sceneFunc(t) {
-            t.beginPath(), t.arc(0, 0, this.radius(), 0, le.getAngle(this.angle()), this.clockwise()), t.lineTo(0, 0), t.closePath(), t.fillStrokeShape(this)
-        }
-        getWidth() {
-            return this.radius() * 2
-        }
-        getHeight() {
-            return this.radius() * 2
-        }
-        setWidth(t) {
-            this.radius(t / 2)
-        }
-        setHeight(t) {
-            this.radius(t / 2)
-        }
+
+    function pG(e, t) {
+        return Qe(am.count(as(e) - 1, e), t, 2)
     }
-    Ws.prototype.className = "Wedge";
-    Ws.prototype._centroid = !0;
-    Ws.prototype._attrsAffectingSize = ["radius"];
-    pt(Ws);
-    O.addGetterSetter(Ws, "radius", 0, te());
-    O.addGetterSetter(Ws, "angle", 0, te());
-    O.addGetterSetter(Ws, "clockwise", !1);
-    O.backCompat(Ws, {
-        angleDeg: "angle",
-        getAngleDeg: "getAngle",
-        setAngleDeg: "setAngle"
-    });
 
-    function Sk() {
-        this.r = 0, this.g = 0, this.b = 0, this.a = 0, this.next = null
+    function mG(e, t) {
+        return Qe(e.getFullYear() % 100, t, 2)
     }
-    var W7 = [512, 512, 456, 512, 328, 456, 335, 512, 405, 328, 271, 456, 388, 335, 292, 512, 454, 405, 364, 328, 298, 271, 496, 456, 420, 388, 360, 335, 312, 292, 273, 512, 482, 454, 428, 405, 383, 364, 345, 328, 312, 298, 284, 271, 259, 496, 475, 456, 437, 420, 404, 388, 374, 360, 347, 335, 323, 312, 302, 292, 282, 273, 265, 512, 497, 482, 468, 454, 441, 428, 417, 405, 394, 383, 373, 364, 354, 345, 337, 328, 320, 312, 305, 298, 291, 284, 278, 271, 265, 259, 507, 496, 485, 475, 465, 456, 446, 437, 428, 420, 412, 404, 396, 388, 381, 374, 367, 360, 354, 347, 341, 335, 329, 323, 318, 312, 307, 302, 297, 292, 287, 282, 278, 273, 269, 265, 261, 512, 505, 497, 489, 482, 475, 468, 461, 454, 447, 441, 435, 428, 422, 417, 411, 405, 399, 394, 389, 383, 378, 373, 368, 364, 359, 354, 350, 345, 341, 337, 332, 328, 324, 320, 316, 312, 309, 305, 301, 298, 294, 291, 287, 284, 281, 278, 274, 271, 268, 265, 262, 259, 257, 507, 501, 496, 491, 485, 480, 475, 470, 465, 460, 456, 451, 446, 442, 437, 433, 428, 424, 420, 416, 412, 408, 404, 400, 396, 392, 388, 385, 381, 377, 374, 370, 367, 363, 360, 357, 354, 350, 347, 344, 341, 338, 335, 332, 329, 326, 323, 320, 318, 315, 312, 310, 307, 304, 302, 299, 297, 294, 292, 289, 287, 285, 282, 280, 278, 275, 273, 271, 269, 267, 265, 263, 261, 259],
-        q7 = [9, 11, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24];
 
-    function H7(e, t) {
-        var n = e.data,
-            i = e.width,
-            r = e.height,
-            s, a, o, l, u, c, f, h, d, g, p, m, y, v, b, x, _, S, w, E, A, C, k, R, $ = t + t + 1,
-            T = i - 1,
-            M = r - 1,
-            F = t + 1,
-            N = F * (F + 1) / 2,
-            P = new Sk,
-            z = null,
-            I = P,
-            Q = null,
-            oe = null,
-            Se = W7[t],
-            ye = q7[t];
-        for (o = 1; o < $; o++) I = I.next = new Sk, o === F && (z = I);
-        for (I.next = P, f = c = 0, a = 0; a < r; a++) {
-            for (x = _ = S = w = h = d = g = p = 0, m = F * (E = n[c]), y = F * (A = n[c + 1]), v = F * (C = n[c + 2]), b = F * (k = n[c + 3]), h += N * E, d += N * A, g += N * C, p += N * k, I = P, o = 0; o < F; o++) I.r = E, I.g = A, I.b = C, I.a = k, I = I.next;
-            for (o = 1; o < F; o++) l = c + ((T < o ? T : o) << 2), h += (I.r = E = n[l]) * (R = F - o), d += (I.g = A = n[l + 1]) * R, g += (I.b = C = n[l + 2]) * R, p += (I.a = k = n[l + 3]) * R, x += E, _ += A, S += C, w += k, I = I.next;
-            for (Q = P, oe = z, s = 0; s < i; s++) n[c + 3] = k = p * Se >> ye, k !== 0 ? (k = 255 / k, n[c] = (h * Se >> ye) * k, n[c + 1] = (d * Se >> ye) * k, n[c + 2] = (g * Se >> ye) * k) : n[c] = n[c + 1] = n[c + 2] = 0, h -= m, d -= y, g -= v, p -= b, m -= Q.r, y -= Q.g, v -= Q.b, b -= Q.a, l = f + ((l = s + t + 1) < T ? l : T) << 2, x += Q.r = n[l], _ += Q.g = n[l + 1], S += Q.b = n[l + 2], w += Q.a = n[l + 3], h += x, d += _, g += S, p += w, Q = Q.next, m += E = oe.r, y += A = oe.g, v += C = oe.b, b += k = oe.a, x -= E, _ -= A, S -= C, w -= k, oe = oe.next, c += 4;
-            f += i
-        }
-        for (s = 0; s < i; s++) {
-            for (_ = S = w = x = d = g = p = h = 0, c = s << 2, m = F * (E = n[c]), y = F * (A = n[c + 1]), v = F * (C = n[c + 2]), b = F * (k = n[c + 3]), h += N * E, d += N * A, g += N * C, p += N * k, I = P, o = 0; o < F; o++) I.r = E, I.g = A, I.b = C, I.a = k, I = I.next;
-            for (u = i, o = 1; o <= t; o++) c = u + s << 2, h += (I.r = E = n[c]) * (R = F - o), d += (I.g = A = n[c + 1]) * R, g += (I.b = C = n[c + 2]) * R, p += (I.a = k = n[c + 3]) * R, x += E, _ += A, S += C, w += k, I = I.next, o < M && (u += i);
-            for (c = s, Q = P, oe = z, a = 0; a < r; a++) l = c << 2, n[l + 3] = k = p * Se >> ye, k > 0 ? (k = 255 / k, n[l] = (h * Se >> ye) * k, n[l + 1] = (d * Se >> ye) * k, n[l + 2] = (g * Se >> ye) * k) : n[l] = n[l + 1] = n[l + 2] = 0, h -= m, d -= y, g -= v, p -= b, m -= Q.r, y -= Q.g, v -= Q.b, b -= Q.a, l = s + ((l = a + F) < M ? l : M) * i << 2, h += x += Q.r = n[l], d += _ += Q.g = n[l + 1], g += S += Q.b = n[l + 2], p += w += Q.a = n[l + 3], Q = Q.next, m += E = oe.r, y += A = oe.g, v += C = oe.b, b += k = oe.a, x -= E, _ -= A, S -= C, w -= k, oe = oe.next, c += i
-        }
+    function yG(e, t) {
+        return e = tR(e), Qe(e.getFullYear() % 100, t, 2)
     }
-    const Y7 = function(t) {
-        var n = Math.round(this.blurRadius());
-        n > 0 && H7(t, n)
-    };
-    O.addGetterSetter(ne, "blurRadius", 0, te(), O.afterSetFilter);
-    const X7 = function(e) {
-        var t = this.brightness() * 255,
-            n = e.data,
-            i = n.length,
-            r;
-        for (r = 0; r < i; r += 4) n[r] += t, n[r + 1] += t, n[r + 2] += t
-    };
-    O.addGetterSetter(ne, "brightness", 0, te(), O.afterSetFilter);
-    const V7 = function(e) {
-        var t = Math.pow((this.contrast() + 100) / 100, 2),
-            n = e.data,
-            i = n.length,
-            r = 150,
-            s = 150,
-            a = 150,
-            o;
-        for (o = 0; o < i; o += 4) r = n[o], s = n[o + 1], a = n[o + 2], r /= 255, r -= .5, r *= t, r += .5, r *= 255, s /= 255, s -= .5, s *= t, s += .5, s *= 255, a /= 255, a -= .5, a *= t, a += .5, a *= 255, r = r < 0 ? 0 : r > 255 ? 255 : r, s = s < 0 ? 0 : s > 255 ? 255 : s, a = a < 0 ? 0 : a > 255 ? 255 : a, n[o] = r, n[o + 1] = s, n[o + 2] = a
-    };
-    O.addGetterSetter(ne, "contrast", 0, te(), O.afterSetFilter);
-    const K7 = function(e) {
-        var t = this.embossStrength() * 10,
-            n = this.embossWhiteLevel() * 255,
-            i = this.embossDirection(),
-            r = this.embossBlend(),
-            s = 0,
-            a = 0,
-            o = e.data,
-            l = e.width,
-            u = e.height,
-            c = l * 4,
-            f = u;
-        switch (i) {
-            case "top-left":
-                s = -1, a = -1;
-                break;
-            case "top":
-                s = -1, a = 0;
-                break;
-            case "top-right":
-                s = -1, a = 1;
-                break;
-            case "right":
-                s = 0, a = 1;
-                break;
-            case "bottom-right":
-                s = 1, a = 1;
-                break;
-            case "bottom":
-                s = 1, a = 0;
-                break;
-            case "bottom-left":
-                s = 1, a = -1;
-                break;
-            case "left":
-                s = 0, a = -1;
-                break;
-            default:
-                D.error("Unknown emboss direction: " + i)
-        }
-        do {
-            var h = (f - 1) * c,
-                d = s;
-            f + d < 1 && (d = 0), f + d > u && (d = 0);
-            var g = (f - 1 + d) * l * 4,
-                p = l;
-            do {
-                var m = h + (p - 1) * 4,
-                    y = a;
-                p + y < 1 && (y = 0), p + y > l && (y = 0);
-                var v = g + (p - 1 + y) * 4,
-                    b = o[m] - o[v],
-                    x = o[m + 1] - o[v + 1],
-                    _ = o[m + 2] - o[v + 2],
-                    S = b,
-                    w = S > 0 ? S : -S,
-                    E = x > 0 ? x : -x,
-                    A = _ > 0 ? _ : -_;
-                if (E > w && (S = x), A > w && (S = _), S *= t, r) {
-                    var C = o[m] + S,
-                        k = o[m + 1] + S,
-                        R = o[m + 2] + S;
-                    o[m] = C > 255 ? 255 : C < 0 ? 0 : C, o[m + 1] = k > 255 ? 255 : k < 0 ? 0 : k, o[m + 2] = R > 255 ? 255 : R < 0 ? 0 : R
-                } else {
-                    var $ = n - S;
-                    $ < 0 ? $ = 0 : $ > 255 && ($ = 255), o[m] = o[m + 1] = o[m + 2] = $
-                }
-            } while (--p)
-        } while (--f)
-    };
-    O.addGetterSetter(ne, "embossStrength", .5, te(), O.afterSetFilter);
-    O.addGetterSetter(ne, "embossWhiteLevel", .5, te(), O.afterSetFilter);
-    O.addGetterSetter(ne, "embossDirection", "top-left", null, O.afterSetFilter);
-    O.addGetterSetter(ne, "embossBlend", !1, null, O.afterSetFilter);
 
-    function yy(e, t, n, i, r) {
-        var s = n - t,
-            a = r - i,
-            o;
-        return s === 0 ? i + a / 2 : a === 0 ? i : (o = (e - t) / s, o = a * o + i, o)
+    function vG(e, t) {
+        return Qe(e.getFullYear() % 1e4, t, 4)
     }
-    const J7 = function(e) {
-        var t = e.data,
-            n = t.length,
-            i = t[0],
-            r = i,
-            s, a = t[1],
-            o = a,
-            l, u = t[2],
-            c = u,
-            f, h, d = this.enhance();
-        if (d !== 0) {
-            for (h = 0; h < n; h += 4) s = t[h + 0], s < i ? i = s : s > r && (r = s), l = t[h + 1], l < a ? a = l : l > o && (o = l), f = t[h + 2], f < u ? u = f : f > c && (c = f);
-            r === i && (r = 255, i = 0), o === a && (o = 255, a = 0), c === u && (c = 255, u = 0);
-            var g, p, m, y, v, b, x, _, S;
-            for (d > 0 ? (p = r + d * (255 - r), m = i - d * (i - 0), v = o + d * (255 - o), b = a - d * (a - 0), _ = c + d * (255 - c), S = u - d * (u - 0)) : (g = (r + i) * .5, p = r + d * (r - g), m = i + d * (i - g), y = (o + a) * .5, v = o + d * (o - y), b = a + d * (a - y), x = (c + u) * .5, _ = c + d * (c - x), S = u + d * (u - x)), h = 0; h < n; h += 4) t[h + 0] = yy(t[h + 0], i, r, m, p), t[h + 1] = yy(t[h + 1], a, o, b, v), t[h + 2] = yy(t[h + 2], u, c, S, _)
-        }
-    };
-    O.addGetterSetter(ne, "enhance", 0, te(), O.afterSetFilter);
-    const Q7 = function(e) {
-        var t = e.data,
-            n = t.length,
-            i, r;
-        for (i = 0; i < n; i += 4) r = .34 * t[i] + .5 * t[i + 1] + .16 * t[i + 2], t[i] = r, t[i + 1] = r, t[i + 2] = r
-    };
-    O.addGetterSetter(ne, "hue", 0, te(), O.afterSetFilter);
-    O.addGetterSetter(ne, "saturation", 0, te(), O.afterSetFilter);
-    O.addGetterSetter(ne, "luminance", 0, te(), O.afterSetFilter);
-    const Z7 = function(e) {
-            var t = e.data,
-                n = t.length,
-                i = 1,
-                r = Math.pow(2, this.saturation()),
-                s = Math.abs(this.hue() + 360) % 360,
-                a = this.luminance() * 127,
-                o, l = i * r * Math.cos(s * Math.PI / 180),
-                u = i * r * Math.sin(s * Math.PI / 180),
-                c = .299 * i + .701 * l + .167 * u,
-                f = .587 * i - .587 * l + .33 * u,
-                h = .114 * i - .114 * l - .497 * u,
-                d = .299 * i - .299 * l - .328 * u,
-                g = .587 * i + .413 * l + .035 * u,
-                p = .114 * i - .114 * l + .293 * u,
-                m = .299 * i - .3 * l + 1.25 * u,
-                y = .587 * i - .586 * l - 1.05 * u,
-                v = .114 * i + .886 * l - .2 * u,
-                b, x, _, S;
-            for (o = 0; o < n; o += 4) b = t[o + 0], x = t[o + 1], _ = t[o + 2], S = t[o + 3], t[o + 0] = c * b + f * x + h * _ + a, t[o + 1] = d * b + g * x + p * _ + a, t[o + 2] = m * b + y * x + v * _ + a, t[o + 3] = S
-        },
-        eB = function(e) {
-            var t = e.data,
-                n = t.length,
-                i = Math.pow(2, this.value()),
-                r = Math.pow(2, this.saturation()),
-                s = Math.abs(this.hue() + 360) % 360,
-                a, o = i * r * Math.cos(s * Math.PI / 180),
-                l = i * r * Math.sin(s * Math.PI / 180),
-                u = .299 * i + .701 * o + .167 * l,
-                c = .587 * i - .587 * o + .33 * l,
-                f = .114 * i - .114 * o - .497 * l,
-                h = .299 * i - .299 * o - .328 * l,
-                d = .587 * i + .413 * o + .035 * l,
-                g = .114 * i - .114 * o + .293 * l,
-                p = .299 * i - .3 * o + 1.25 * l,
-                m = .587 * i - .586 * o - 1.05 * l,
-                y = .114 * i + .886 * o - .2 * l,
-                v, b, x, _;
-            for (a = 0; a < n; a += 4) v = t[a + 0], b = t[a + 1], x = t[a + 2], _ = t[a + 3], t[a + 0] = u * v + c * b + f * x, t[a + 1] = h * v + d * b + g * x, t[a + 2] = p * v + m * b + y * x, t[a + 3] = _
-        };
-    O.addGetterSetter(ne, "hue", 0, te(), O.afterSetFilter);
-    O.addGetterSetter(ne, "saturation", 0, te(), O.afterSetFilter);
-    O.addGetterSetter(ne, "value", 0, te(), O.afterSetFilter);
-    const tB = function(e) {
-        var t = e.data,
-            n = t.length,
-            i;
-        for (i = 0; i < n; i += 4) t[i] = 255 - t[i], t[i + 1] = 255 - t[i + 1], t[i + 2] = 255 - t[i + 2]
-    };
-    var nB = function(e, t, n) {
-            var i = e.data,
-                r = t.data,
-                s = e.width,
-                a = e.height,
-                o = n.polarCenterX || s / 2,
-                l = n.polarCenterY || a / 2,
-                u, c, f, h = 0,
-                d = 0,
-                g = 0,
-                p = 0,
-                m, y = Math.sqrt(o * o + l * l);
-            c = s - o, f = a - l, m = Math.sqrt(c * c + f * f), y = m > y ? m : y;
-            var v = a,
-                b = s,
-                x, _, S = 360 / b * Math.PI / 180,
-                w, E;
-            for (_ = 0; _ < b; _ += 1)
-                for (w = Math.sin(_ * S), E = Math.cos(_ * S), x = 0; x < v; x += 1) c = Math.floor(o + y * x / v * E), f = Math.floor(l + y * x / v * w), u = (f * s + c) * 4, h = i[u + 0], d = i[u + 1], g = i[u + 2], p = i[u + 3], u = (_ + x * s) * 4, r[u + 0] = h, r[u + 1] = d, r[u + 2] = g, r[u + 3] = p
-        },
-        iB = function(e, t, n) {
-            var i = e.data,
-                r = t.data,
-                s = e.width,
-                a = e.height,
-                o = n.polarCenterX || s / 2,
-                l = n.polarCenterY || a / 2,
-                u, c, f, h, d, g = 0,
-                p = 0,
-                m = 0,
-                y = 0,
-                v, b = Math.sqrt(o * o + l * l);
-            c = s - o, f = a - l, v = Math.sqrt(c * c + f * f), b = v > b ? v : b;
-            var x = a,
-                _ = s,
-                S, w, E = n.polarRotation || 0,
-                A, C;
-            for (c = 0; c < s; c += 1)
-                for (f = 0; f < a; f += 1) h = c - o, d = f - l, S = Math.sqrt(h * h + d * d) * x / b, w = (Math.atan2(d, h) * 180 / Math.PI + 360 + E) % 360, w = w * _ / 360, A = Math.floor(w), C = Math.floor(S), u = (C * s + A) * 4, g = i[u + 0], p = i[u + 1], m = i[u + 2], y = i[u + 3], u = (f * s + c) * 4, r[u + 0] = g, r[u + 1] = p, r[u + 2] = m, r[u + 3] = y
-        };
-    const rB = function(e) {
-        var t = e.width,
-            n = e.height,
-            i, r, s, a, o, l, u, c, f, h, d = Math.round(this.kaleidoscopePower()),
-            g = Math.round(this.kaleidoscopeAngle()),
-            p = Math.floor(t * (g % 360) / 360);
-        if (!(d < 1)) {
-            var m = D.createCanvasElement();
-            m.width = t, m.height = n;
-            var y = m.getContext("2d").getImageData(0, 0, t, n);
-            D.releaseCanvas(m), nB(e, y, {
-                polarCenterX: t / 2,
-                polarCenterY: n / 2
-            });
-            for (var v = t / Math.pow(2, d); v <= 8;) v = v * 2, d -= 1;
-            v = Math.ceil(v);
-            var b = v,
-                x = 0,
-                _ = b,
-                S = 1;
-            for (p + v > t && (x = b, _ = 0, S = -1), r = 0; r < n; r += 1)
-                for (i = x; i !== _; i += S) s = Math.round(i + p) % t, f = (t * r + s) * 4, o = y.data[f + 0], l = y.data[f + 1], u = y.data[f + 2], c = y.data[f + 3], h = (t * r + i) * 4, y.data[h + 0] = o, y.data[h + 1] = l, y.data[h + 2] = u, y.data[h + 3] = c;
-            for (r = 0; r < n; r += 1)
-                for (b = Math.floor(v), a = 0; a < d; a += 1) {
-                    for (i = 0; i < b + 1; i += 1) f = (t * r + i) * 4, o = y.data[f + 0], l = y.data[f + 1], u = y.data[f + 2], c = y.data[f + 3], h = (t * r + b * 2 - i - 1) * 4, y.data[h + 0] = o, y.data[h + 1] = l, y.data[h + 2] = u, y.data[h + 3] = c;
-                    b *= 2
-                }
-            iB(y, e, {
-                polarRotation: 0
-            })
-        }
-    };
-    O.addGetterSetter(ne, "kaleidoscopePower", 2, te(), O.afterSetFilter);
-    O.addGetterSetter(ne, "kaleidoscopeAngle", 0, te(), O.afterSetFilter);
 
-    function Qd(e, t, n) {
-        var i = (n * e.width + t) * 4,
-            r = [];
-        return r.push(e.data[i++], e.data[i++], e.data[i++], e.data[i++]), r
+    function bG(e, t) {
+        var n = e.getDay();
+        return e = n >= 4 || n === 0 ? sc(e) : sc.ceil(e), Qe(e.getFullYear() % 1e4, t, 4)
     }
 
-    function Gc(e, t) {
-        return Math.sqrt(Math.pow(e[0] - t[0], 2) + Math.pow(e[1] - t[1], 2) + Math.pow(e[2] - t[2], 2))
+    function xG(e) {
+        var t = e.getTimezoneOffset();
+        return (t > 0 ? "-" : (t *= -1, "+")) + Qe(t / 60 | 0, "0", 2) + Qe(t % 60, "0", 2)
     }
 
-    function sB(e) {
-        for (var t = [0, 0, 0], n = 0; n < e.length; n++) t[0] += e[n][0], t[1] += e[n][1], t[2] += e[n][2];
-        return t[0] /= e.length, t[1] /= e.length, t[2] /= e.length, t
+    function wA(e, t) {
+        return Qe(e.getUTCDate(), t, 2)
     }
 
-    function aB(e, t) {
-        var n = Qd(e, 0, 0),
-            i = Qd(e, e.width - 1, 0),
-            r = Qd(e, 0, e.height - 1),
-            s = Qd(e, e.width - 1, e.height - 1),
-            a = t || 10;
-        if (Gc(n, i) < a && Gc(i, s) < a && Gc(s, r) < a && Gc(r, n) < a) {
-            for (var o = sB([i, n, s, r]), l = [], u = 0; u < e.width * e.height; u++) {
-                var c = Gc(o, [e.data[u * 4], e.data[u * 4 + 1], e.data[u * 4 + 2]]);
-                l[u] = c < a ? 0 : 255
-            }
-            return l
-        }
+    function _G(e, t) {
+        return Qe(e.getUTCHours(), t, 2)
     }
 
-    function oB(e, t) {
-        for (var n = 0; n < e.width * e.height; n++) e.data[4 * n + 3] = t[n]
+    function wG(e, t) {
+        return Qe(e.getUTCHours() % 12 || 12, t, 2)
     }
 
-    function lB(e, t, n) {
-        for (var i = [1, 1, 1, 1, 0, 1, 1, 1, 1], r = Math.round(Math.sqrt(i.length)), s = Math.floor(r / 2), a = [], o = 0; o < n; o++)
-            for (var l = 0; l < t; l++) {
-                for (var u = o * t + l, c = 0, f = 0; f < r; f++)
-                    for (var h = 0; h < r; h++) {
-                        var d = o + f - s,
-                            g = l + h - s;
-                        if (d >= 0 && d < n && g >= 0 && g < t) {
-                            var p = d * t + g,
-                                m = i[f * r + h];
-                            c += e[p] * m
-                        }
-                    }
-                a[u] = c === 255 * 8 ? 255 : 0
-            }
-        return a
+    function SG(e, t) {
+        return Qe(1 + Wa.count(os(e), e), t, 3)
     }
 
-    function uB(e, t, n) {
-        for (var i = [1, 1, 1, 1, 1, 1, 1, 1, 1], r = Math.round(Math.sqrt(i.length)), s = Math.floor(r / 2), a = [], o = 0; o < n; o++)
-            for (var l = 0; l < t; l++) {
-                for (var u = o * t + l, c = 0, f = 0; f < r; f++)
-                    for (var h = 0; h < r; h++) {
-                        var d = o + f - s,
-                            g = l + h - s;
-                        if (d >= 0 && d < n && g >= 0 && g < t) {
-                            var p = d * t + g,
-                                m = i[f * r + h];
-                            c += e[p] * m
-                        }
-                    }
-                a[u] = c >= 255 * 4 ? 255 : 0
-            }
-        return a
+    function nR(e, t) {
+        return Qe(e.getUTCMilliseconds(), t, 3)
     }
 
-    function cB(e, t, n) {
-        for (var i = [.1111111111111111, .1111111111111111, .1111111111111111, .1111111111111111, .1111111111111111, .1111111111111111, .1111111111111111, .1111111111111111, .1111111111111111], r = Math.round(Math.sqrt(i.length)), s = Math.floor(r / 2), a = [], o = 0; o < n; o++)
-            for (var l = 0; l < t; l++) {
-                for (var u = o * t + l, c = 0, f = 0; f < r; f++)
-                    for (var h = 0; h < r; h++) {
-                        var d = o + f - s,
-                            g = l + h - s;
-                        if (d >= 0 && d < n && g >= 0 && g < t) {
-                            var p = d * t + g,
-                                m = i[f * r + h];
-                            c += e[p] * m
-                        }
-                    }
-                a[u] = c
-            }
-        return a
+    function EG(e, t) {
+        return nR(e, t) + "000"
     }
-    const fB = function(e) {
-        var t = this.threshold(),
-            n = aB(e, t);
-        return n && (n = lB(n, e.width, e.height), n = uB(n, e.width, e.height), n = cB(n, e.width, e.height), oB(e, n)), e
-    };
-    O.addGetterSetter(ne, "threshold", 0, te(), O.afterSetFilter);
-    const hB = function(e) {
-        var t = this.noise() * 255,
-            n = e.data,
-            i = n.length,
-            r = t / 2,
-            s;
-        for (s = 0; s < i; s += 4) n[s + 0] += r - 2 * r * Math.random(), n[s + 1] += r - 2 * r * Math.random(), n[s + 2] += r - 2 * r * Math.random()
-    };
-    O.addGetterSetter(ne, "noise", .2, te(), O.afterSetFilter);
-    const dB = function(e) {
-        var t = Math.ceil(this.pixelSize()),
-            n = e.width,
-            i = e.height,
-            r, s, a, o, l, u, c, f = Math.ceil(n / t),
-            h = Math.ceil(i / t),
-            d, g, p, m, y, v, b, x = e.data;
-        if (t <= 0) {
-            D.error("pixelSize value can not be <= 0");
-            return
-        }
-        for (y = 0; y < f; y += 1)
-            for (v = 0; v < h; v += 1) {
-                for (o = 0, l = 0, u = 0, c = 0, d = y * t, g = d + t, p = v * t, m = p + t, b = 0, r = d; r < g; r += 1)
-                    if (!(r >= n))
-                        for (s = p; s < m; s += 1) s >= i || (a = (n * s + r) * 4, o += x[a + 0], l += x[a + 1], u += x[a + 2], c += x[a + 3], b += 1);
-                for (o = o / b, l = l / b, u = u / b, c = c / b, r = d; r < g; r += 1)
-                    if (!(r >= n))
-                        for (s = p; s < m; s += 1) s >= i || (a = (n * s + r) * 4, x[a + 0] = o, x[a + 1] = l, x[a + 2] = u, x[a + 3] = c)
-            }
-    };
-    O.addGetterSetter(ne, "pixelSize", 8, te(), O.afterSetFilter);
-    const gB = function(e) {
-        var t = Math.round(this.levels() * 254) + 1,
-            n = e.data,
-            i = n.length,
-            r = 255 / t,
-            s;
-        for (s = 0; s < i; s += 1) n[s] = Math.floor(n[s] / r) * r
-    };
-    O.addGetterSetter(ne, "levels", .5, te(), O.afterSetFilter);
-    const pB = function(e) {
-        var t = e.data,
-            n = t.length,
-            i = this.red(),
-            r = this.green(),
-            s = this.blue(),
-            a, o;
-        for (a = 0; a < n; a += 4) o = (.34 * t[a] + .5 * t[a + 1] + .16 * t[a + 2]) / 255, t[a] = o * i, t[a + 1] = o * r, t[a + 2] = o * s, t[a + 3] = t[a + 3]
-    };
-    O.addGetterSetter(ne, "red", 0, function(e) {
-        return this._filterUpToDate = !1, e > 255 ? 255 : e < 0 ? 0 : Math.round(e)
-    });
-    O.addGetterSetter(ne, "green", 0, function(e) {
-        return this._filterUpToDate = !1, e > 255 ? 255 : e < 0 ? 0 : Math.round(e)
-    });
-    O.addGetterSetter(ne, "blue", 0, AM, O.afterSetFilter);
-    const mB = function(e) {
-        var t = e.data,
-            n = t.length,
-            i = this.red(),
-            r = this.green(),
-            s = this.blue(),
-            a = this.alpha(),
-            o, l;
-        for (o = 0; o < n; o += 4) l = 1 - a, t[o] = i * a + t[o] * l, t[o + 1] = r * a + t[o + 1] * l, t[o + 2] = s * a + t[o + 2] * l
-    };
-    O.addGetterSetter(ne, "red", 0, function(e) {
-        return this._filterUpToDate = !1, e > 255 ? 255 : e < 0 ? 0 : Math.round(e)
-    });
-    O.addGetterSetter(ne, "green", 0, function(e) {
-        return this._filterUpToDate = !1, e > 255 ? 255 : e < 0 ? 0 : Math.round(e)
-    });
-    O.addGetterSetter(ne, "blue", 0, AM, O.afterSetFilter);
-    O.addGetterSetter(ne, "alpha", 1, function(e) {
-        return this._filterUpToDate = !1, e > 1 ? 1 : e < 0 ? 0 : e
-    });
-    const yB = function(e) {
-            var t = e.data,
-                n = t.length,
-                i, r, s, a;
-            for (i = 0; i < n; i += 4) r = t[i + 0], s = t[i + 1], a = t[i + 2], t[i + 0] = Math.min(255, r * .393 + s * .769 + a * .189), t[i + 1] = Math.min(255, r * .349 + s * .686 + a * .168), t[i + 2] = Math.min(255, r * .272 + s * .534 + a * .131)
-        },
-        vB = function(e) {
-            var t = e.data,
-                n = e.width,
-                i = e.height,
-                r = n * 4,
-                s = i;
-            do {
-                var a = (s - 1) * r,
-                    o = n;
-                do {
-                    var l = a + (o - 1) * 4,
-                        u = t[l],
-                        c = t[l + 1],
-                        f = t[l + 2];
-                    u > 127 && (u = 255 - u), c > 127 && (c = 255 - c), f > 127 && (f = 255 - f), t[l] = u, t[l + 1] = c, t[l + 2] = f
-                } while (--o)
-            } while (--s)
-        },
-        bB = function(e) {
-            var t = this.threshold() * 255,
-                n = e.data,
-                i = n.length,
-                r;
-            for (r = 0; r < i; r += 1) n[r] = n[r] < t ? 0 : 255
-        };
-    O.addGetterSetter(ne, "threshold", .5, te(), O.afterSetFilter);
-    const cn = pk.Util._assign(pk, {
-        Arc: Us,
-        Arrow: _l,
-        Circle: dc,
-        Ellipse: Ya,
-        Image: Qr,
-        Label: xx,
-        Tag: wl,
-        Line: Gs,
-        Path: Yt,
-        Rect: Vh,
-        RegularPolygon: Sl,
-        Ring: El,
-        Sprite: Zr,
-        Star: Xa,
-        Text: gt,
-        TextPath: Rt,
-        Transformer: Ke,
-        Wedge: Ws,
-        Filters: {
-            Blur: Y7,
-            Brighten: X7,
-            Contrast: V7,
-            Emboss: K7,
-            Enhance: J7,
-            Grayscale: Q7,
-            HSL: Z7,
-            HSV: eB,
-            Invert: tB,
-            Kaleidoscope: rB,
-            Mask: fB,
-            Noise: hB,
-            Pixelate: dB,
-            Posterize: gB,
-            RGB: pB,
-            RGBA: mB,
-            Sepia: yB,
-            Solarize: vB,
-            Threshold: bB
-        }
-    });
-    /**
-    @copyright CEA-LIST/DIASI/SIALV/LVA (2023)
-    @author CEA-LIST/DIASI/SIALV/LVA <pixano@cea.fr>
-    @license CECILL-C
 
-    This software is a collaborative computer program whose purpose is to
-    generate and explore labeled data for computer vision applications.
-    This software is governed by the CeCILL-C license under French law and
-    abiding by the rules of distribution of free software. You can use, 
-    modify and/ or redistribute the software under the terms of the CeCILL-C
-    license as circulated by CEA, CNRS and INRIA at the following URL
+    function kG(e, t) {
+        return Qe(e.getUTCMonth() + 1, t, 2)
+    }
 
-    http://www.cecill.info
-    */
-    function xB(e, t, n) {
-        return {
-            x: e.x * t.width + n.x,
-            y: e.y * t.height + n.y,
-            width: e.width * t.width,
-            height: e.height * t.height
-        }
+    function CG(e, t) {
+        return Qe(e.getUTCMinutes(), t, 2)
     }
 
-    function _B(e, t, n) {
-        const i = (r, s) => s % 2 == 0 ? r * t.width + n.x : r * t.height + n.y;
-        for (let r = 0; r < e.length; ++r) {
-            let s = e[r];
-            for (let a = 0; a < s.length; ++a) s[a] = i(s[a], a)
-        }
-        return e
+    function AG(e, t) {
+        return Qe(e.getUTCSeconds(), t, 2)
     }
 
-    function wB(e) {
-        e.clear(), e.children.forEach(t => t.destroyChildren())
+    function $G(e) {
+        var t = e.getUTCDay();
+        return t === 0 ? 7 : t
     }
 
-    function SB(e, t, n, i, r = "black", s = !0) {
-        const a = new cn.Label({
-            id: e,
-            x: i.x,
-            y: i.y,
-            visible: s
-        });
-        a.add(new cn.Tag({
-            fill: r,
-            stroke: r
-        })), a.add(new cn.Text({
-            text: n,
-            fontSize: 10,
-            fontStyle: "bold",
-            padding: 2,
-            x: i.x,
-            y: i.y
-        })), t.add(a)
-    }
-
-    function EB(e = "", t, n, i = "black", r = !1, s = !0) {
-        const a = new cn.Rect({
-            x: n.x,
-            y: n.y,
-            id: e,
-            width: n.width,
-            height: n.height,
-            stroke: i,
-            strokeWidth: 3,
-            visible: s,
-            dash: r ? [10, 10] : []
-        });
-        t.add(a)
+    function TG(e, t) {
+        return Qe(qc.count(os(e) - 1, e), t, 2)
     }
 
-    function CB(e = "", t, n, i = "black", r = !0, s = .5) {
-        let a = new cn.Group({
-            id: e,
-            opacity: s,
-            visible: r
-        });
-        n.forEach(o => {
-            const l = new cn.Line({
-                points: o,
-                fill: i,
-                closed: !0
-            });
-            a.add(l)
-        }), t.add(a)
+    function iR(e) {
+        var t = e.getUTCDay();
+        return t >= 4 || t === 0 ? ac(e) : ac.ceil(e)
     }
 
-    function kB(e, t, n, i) {
-        const r = new cn.Image({
-            image: t,
-            x: n.x,
-            y: n.y,
-            scaleX: i,
-            scaleY: i
-        });
-        e.add(r)
+    function MG(e, t) {
+        return e = iR(e), Qe(ac.count(os(e), e) + (os(e).getUTCDay() === 4), t, 2)
     }
 
-    function AB(e, t, n) {
-        const i = new cn.Label({
-            x: n.x + 5,
-            y: n.y + 5
-        });
-        i.add(new cn.Tag({
-            fill: "black",
-            cornerRadius: 5
-        })), i.add(new cn.Text({
-            text: t,
-            fontSize: 15,
-            fontStyle: "bold",
-            padding: 5,
-            fill: "white"
-        })), e.add(i)
+    function OG(e) {
+        return e.getUTCDay()
     }
 
-    function $B(e, t) {
-        e == null || e.children.forEach(n => n.opacity(t))
+    function FG(e, t) {
+        return Qe(om.count(os(e) - 1, e), t, 2)
     }
 
-    function TB(e, t) {
-        const i = e.scaleX(),
-            r = e.getPointerPosition(),
-            s = {
-                x: (r.x - e.x()) / i,
-                y: (r.y - e.y()) / i
-            },
-            a = t > 0 ? i * 1.05 : i / 1.05,
-            o = {
-                x: r.x - s.x * a,
-                y: r.y - s.y * a
-            };
-        e.scale({
-            x: a,
-            y: a
-        }), e.position(o)
+    function RG(e, t) {
+        return Qe(e.getUTCFullYear() % 100, t, 2)
     }
 
-    function MB(e) {
-        for (var t = e.length / 6 | 0, n = new Array(t), i = 0; i < t;) n[i] = "#" + e.slice(i * 6, ++i * 6);
-        return n
+    function DG(e, t) {
+        return e = iR(e), Qe(e.getUTCFullYear() % 100, t, 2)
     }
-    const OB = MB("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f");
 
-    function gc(e, t, n) {
-        e.prototype = t.prototype = n, n.constructor = e
+    function NG(e, t) {
+        return Qe(e.getUTCFullYear() % 1e4, t, 4)
     }
 
-    function Kh(e, t) {
-        var n = Object.create(e.prototype);
-        for (var i in t) n[i] = t[i];
-        return n
+    function PG(e, t) {
+        var n = e.getUTCDay();
+        return e = n >= 4 || n === 0 ? ac(e) : ac.ceil(e), Qe(e.getUTCFullYear() % 1e4, t, 4)
     }
 
-    function Va() {}
-    var Ko = .7,
-        Ou = 1 / Ko,
-        bu = "\\s*([+-]?\\d+)\\s*",
-        gh = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*",
-        Lr = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
-        FB = /^#([0-9a-f]{3,8})$/,
-        RB = new RegExp(`^rgb\\(${bu},${bu},${bu}\\)$`),
-        DB = new RegExp(`^rgb\\(${Lr},${Lr},${Lr}\\)$`),
-        NB = new RegExp(`^rgba\\(${bu},${bu},${bu},${gh}\\)$`),
-        PB = new RegExp(`^rgba\\(${Lr},${Lr},${Lr},${gh}\\)$`),
-        LB = new RegExp(`^hsl\\(${gh},${Lr},${Lr}\\)$`),
-        IB = new RegExp(`^hsla\\(${gh},${Lr},${Lr},${gh}\\)$`),
-        Ek = {
-            aliceblue: 15792383,
-            antiquewhite: 16444375,
-            aqua: 65535,
-            aquamarine: 8388564,
-            azure: 15794175,
-            beige: 16119260,
-            bisque: 16770244,
-            black: 0,
-            blanchedalmond: 16772045,
-            blue: 255,
-            blueviolet: 9055202,
-            brown: 10824234,
-            burlywood: 14596231,
-            cadetblue: 6266528,
-            chartreuse: 8388352,
-            chocolate: 13789470,
-            coral: 16744272,
-            cornflowerblue: 6591981,
-            cornsilk: 16775388,
-            crimson: 14423100,
-            cyan: 65535,
-            darkblue: 139,
-            darkcyan: 35723,
-            darkgoldenrod: 12092939,
-            darkgray: 11119017,
-            darkgreen: 25600,
-            darkgrey: 11119017,
-            darkkhaki: 12433259,
-            darkmagenta: 9109643,
-            darkolivegreen: 5597999,
-            darkorange: 16747520,
-            darkorchid: 10040012,
-            darkred: 9109504,
-            darksalmon: 15308410,
-            darkseagreen: 9419919,
-            darkslateblue: 4734347,
-            darkslategray: 3100495,
-            darkslategrey: 3100495,
-            darkturquoise: 52945,
-            darkviolet: 9699539,
-            deeppink: 16716947,
-            deepskyblue: 49151,
-            dimgray: 6908265,
-            dimgrey: 6908265,
-            dodgerblue: 2003199,
-            firebrick: 11674146,
-            floralwhite: 16775920,
-            forestgreen: 2263842,
-            fuchsia: 16711935,
-            gainsboro: 14474460,
-            ghostwhite: 16316671,
-            gold: 16766720,
-            goldenrod: 14329120,
-            gray: 8421504,
-            green: 32768,
-            greenyellow: 11403055,
-            grey: 8421504,
-            honeydew: 15794160,
-            hotpink: 16738740,
-            indianred: 13458524,
-            indigo: 4915330,
-            ivory: 16777200,
-            khaki: 15787660,
-            lavender: 15132410,
-            lavenderblush: 16773365,
-            lawngreen: 8190976,
-            lemonchiffon: 16775885,
-            lightblue: 11393254,
-            lightcoral: 15761536,
-            lightcyan: 14745599,
-            lightgoldenrodyellow: 16448210,
-            lightgray: 13882323,
-            lightgreen: 9498256,
-            lightgrey: 13882323,
-            lightpink: 16758465,
-            lightsalmon: 16752762,
-            lightseagreen: 2142890,
-            lightskyblue: 8900346,
-            lightslategray: 7833753,
-            lightslategrey: 7833753,
-            lightsteelblue: 11584734,
-            lightyellow: 16777184,
-            lime: 65280,
-            limegreen: 3329330,
-            linen: 16445670,
-            magenta: 16711935,
-            maroon: 8388608,
-            mediumaquamarine: 6737322,
-            mediumblue: 205,
-            mediumorchid: 12211667,
-            mediumpurple: 9662683,
-            mediumseagreen: 3978097,
-            mediumslateblue: 8087790,
-            mediumspringgreen: 64154,
-            mediumturquoise: 4772300,
-            mediumvioletred: 13047173,
-            midnightblue: 1644912,
-            mintcream: 16121850,
-            mistyrose: 16770273,
-            moccasin: 16770229,
-            navajowhite: 16768685,
-            navy: 128,
-            oldlace: 16643558,
-            olive: 8421376,
-            olivedrab: 7048739,
-            orange: 16753920,
-            orangered: 16729344,
-            orchid: 14315734,
-            palegoldenrod: 15657130,
-            palegreen: 10025880,
-            paleturquoise: 11529966,
-            palevioletred: 14381203,
-            papayawhip: 16773077,
-            peachpuff: 16767673,
-            peru: 13468991,
-            pink: 16761035,
-            plum: 14524637,
-            powderblue: 11591910,
-            purple: 8388736,
-            rebeccapurple: 6697881,
-            red: 16711680,
-            rosybrown: 12357519,
-            royalblue: 4286945,
-            saddlebrown: 9127187,
-            salmon: 16416882,
-            sandybrown: 16032864,
-            seagreen: 3050327,
-            seashell: 16774638,
-            sienna: 10506797,
-            silver: 12632256,
-            skyblue: 8900331,
-            slateblue: 6970061,
-            slategray: 7372944,
-            slategrey: 7372944,
-            snow: 16775930,
-            springgreen: 65407,
-            steelblue: 4620980,
-            tan: 13808780,
-            teal: 32896,
-            thistle: 14204888,
-            tomato: 16737095,
-            turquoise: 4251856,
-            violet: 15631086,
-            wheat: 16113331,
-            white: 16777215,
-            whitesmoke: 16119285,
-            yellow: 16776960,
-            yellowgreen: 10145074
-        };
-    gc(Va, ph, {
-        copy(e) {
-            return Object.assign(new this.constructor, this, e)
-        },
-        displayable() {
-            return this.rgb().displayable()
-        },
-        hex: Ck,
-        formatHex: Ck,
-        formatHex8: zB,
-        formatHsl: BB,
-        formatRgb: kk,
-        toString: kk
-    });
+    function LG() {
+        return "+0000"
+    }
 
-    function Ck() {
-        return this.rgb().formatHex()
+    function SA() {
+        return "%"
     }
 
-    function zB() {
-        return this.rgb().formatHex8()
+    function EA(e) {
+        return +e
     }
 
-    function BB() {
-        return sO(this).formatHsl()
+    function kA(e) {
+        return Math.floor(+e / 1e3)
     }
+    var pu, M_, rR, O_, sR;
+    IG({
+        dateTime: "%x, %X",
+        date: "%-m/%-d/%Y",
+        time: "%-I:%M:%S %p",
+        periods: ["AM", "PM"],
+        days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
+        shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
+        months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
+        shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
+    });
 
-    function kk() {
-        return this.rgb().formatRgb()
+    function IG(e) {
+        return pu = ZF(e), M_ = pu.format, rR = pu.parse, O_ = pu.utcFormat, sR = pu.utcParse, pu
     }
 
-    function ph(e) {
-        var t, n;
-        return e = (e + "").trim().toLowerCase(), (t = FB.exec(e)) ? (n = t[1].length, t = parseInt(t[1], 16), n === 6 ? Ak(t) : n === 3 ? new It(t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, (t & 15) << 4 | t & 15, 1) : n === 8 ? Zd(t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, (t & 255) / 255) : n === 4 ? Zd(t >> 12 & 15 | t >> 8 & 240, t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, ((t & 15) << 4 | t & 15) / 255) : null) : (t = RB.exec(e)) ? new It(t[1], t[2], t[3], 1) : (t = DB.exec(e)) ? new It(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, 1) : (t = NB.exec(e)) ? Zd(t[1], t[2], t[3], t[4]) : (t = PB.exec(e)) ? Zd(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, t[4]) : (t = LB.exec(e)) ? Mk(t[1], t[2] / 100, t[3] / 100, 1) : (t = IB.exec(e)) ? Mk(t[1], t[2] / 100, t[3] / 100, t[4]) : Ek.hasOwnProperty(e) ? Ak(Ek[e]) : e === "transparent" ? new It(NaN, NaN, NaN, 0) : null
+    function th(e) {
+        const t = {};
+        return n => t[n] || (t[n] = e(n))
     }
 
-    function Ak(e) {
-        return new It(e >> 16 & 255, e >> 8 & 255, e & 255, 1)
+    function zG(e, t) {
+        return n => {
+            const i = e(n),
+                r = i.indexOf(t);
+            if (r < 0) return i;
+            let s = BG(i, r);
+            const a = s < i.length ? i.slice(s) : "";
+            for (; --s > r;)
+                if (i[s] !== "0") {
+                    ++s;
+                    break
+                } return i.slice(0, s) + a
+        }
     }
 
-    function Zd(e, t, n, i) {
-        return i <= 0 && (e = t = n = NaN), new It(e, t, n, i)
+    function BG(e, t) {
+        let n = e.lastIndexOf("e"),
+            i;
+        if (n > 0) return n;
+        for (n = e.length; --n > t;)
+            if (i = e.charCodeAt(n), i >= 48 && i <= 57) return n + 1
     }
 
-    function _x(e) {
-        return e instanceof Va || (e = ph(e)), e ? (e = e.rgb(), new It(e.r, e.g, e.b, e.opacity)) : new It
+    function aR(e) {
+        const t = th(e.format),
+            n = e.formatPrefix;
+        return {
+            format: t,
+            formatPrefix: n,
+            formatFloat(i) {
+                const r = _l(i || ",");
+                if (r.precision == null) {
+                    switch (r.precision = 12, r.type) {
+                        case "%":
+                            r.precision -= 2;
+                            break;
+                        case "e":
+                            r.precision -= 1;
+                            break
+                    }
+                    return zG(t(r), t(".1f")(1)[1])
+                } else return t(r)
+            },
+            formatSpan(i, r, s, a) {
+                a = _l(a ?? ",f");
+                const o = Qa(i, r, s),
+                    l = Math.max(Math.abs(i), Math.abs(r));
+                let u;
+                if (a.precision == null) switch (a.type) {
+                    case "s":
+                        return isNaN(u = MF(o, l)) || (a.precision = u), n(a, l);
+                    case "":
+                    case "e":
+                    case "g":
+                    case "p":
+                    case "r": {
+                        isNaN(u = OF(o, l)) || (a.precision = u - (a.type === "e"));
+                        break
+                    }
+                    case "f":
+                    case "%": {
+                        isNaN(u = TF(o)) || (a.precision = u - (a.type === "%") * 2);
+                        break
+                    }
+                }
+                return t(a)
+            }
+        }
     }
+    let Vb;
+    oR();
 
-    function Ma(e, t, n, i) {
-        return arguments.length === 1 ? _x(e) : new It(e, t, n, i ?? 1)
+    function oR() {
+        return Vb = aR({
+            format: B0,
+            formatPrefix: k_
+        })
     }
 
-    function It(e, t, n, i) {
-        this.r = +e, this.g = +t, this.b = +n, this.opacity = +i
+    function lR(e) {
+        return aR($F(e))
     }
-    gc(It, Ma, Kh(Va, {
-        brighter(e) {
-            return e = e == null ? Ou : Math.pow(Ou, e), new It(this.r * e, this.g * e, this.b * e, this.opacity)
-        },
-        darker(e) {
-            return e = e == null ? Ko : Math.pow(Ko, e), new It(this.r * e, this.g * e, this.b * e, this.opacity)
-        },
-        rgb() {
-            return this
-        },
-        clamp() {
-            return new It(zo(this.r), zo(this.g), zo(this.b), yp(this.opacity))
-        },
-        displayable() {
-            return -.5 <= this.r && this.r < 255.5 && -.5 <= this.g && this.g < 255.5 && -.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1
-        },
-        hex: $k,
-        formatHex: $k,
-        formatHex8: jB,
-        formatRgb: Tk,
-        toString: Tk
-    }));
 
-    function $k() {
-        return `#${Do(this.r)}${Do(this.g)}${Do(this.b)}`
+    function lm(e) {
+        return arguments.length ? Vb = lR(e) : Vb
     }
 
-    function jB() {
-        return `#${Do(this.r)}${Do(this.g)}${Do(this.b)}${Do((isNaN(this.opacity)?1:this.opacity)*255)}`
+    function CA(e, t, n) {
+        n = n || {}, ce(n) || q(`Invalid time multi-format specifier: ${n}`);
+        const i = t(Xi),
+            r = t(Fi),
+            s = t(Oi),
+            a = t(di),
+            o = t(Ht),
+            l = t(Rn),
+            u = t(hi),
+            c = t(vn),
+            f = e(n[Ar] || ".%L"),
+            h = e(n[Xi] || ":%S"),
+            d = e(n[Fi] || "%I:%M"),
+            g = e(n[Oi] || "%I %p"),
+            p = e(n[di] || n[$n] || "%a %d"),
+            m = e(n[Ht] || "%b %d"),
+            y = e(n[Rn] || "%B"),
+            v = e(n[hi] || "%B"),
+            b = e(n[vn] || "%Y");
+        return x => (i(x) < x ? f : r(x) < x ? h : s(x) < x ? d : a(x) < x ? g : l(x) < x ? o(x) < x ? p : m : c(x) < x ? u(x) < x ? y : v : b)(x)
     }
 
-    function Tk() {
-        const e = yp(this.opacity);
-        return `${e===1?"rgb(":"rgba("}${zo(this.r)}, ${zo(this.g)}, ${zo(this.b)}${e===1?")":`, ${e})`}`
+    function uR(e) {
+        const t = th(e.format),
+            n = th(e.utcFormat);
+        return {
+            timeFormat: i => le(i) ? t(i) : CA(t, Hc, i),
+            utcFormat: i => le(i) ? n(i) : CA(n, Yc, i),
+            timeParse: th(e.parse),
+            utcParse: th(e.utcParse)
+        }
     }
+    let Kb;
+    cR();
 
-    function yp(e) {
-        return isNaN(e) ? 1 : Math.max(0, Math.min(1, e))
+    function cR() {
+        return Kb = uR({
+            format: M_,
+            parse: rR,
+            utcFormat: O_,
+            utcParse: sR
+        })
     }
 
-    function zo(e) {
-        return Math.max(0, Math.min(255, Math.round(e) || 0))
+    function fR(e) {
+        return uR(ZF(e))
     }
 
-    function Do(e) {
-        return e = zo(e), (e < 16 ? "0" : "") + e.toString(16)
+    function Hh(e) {
+        return arguments.length ? Kb = fR(e) : Kb
     }
+    const Jb = (e, t) => Ne({}, e, t);
 
-    function Mk(e, t, n, i) {
-        return i <= 0 ? e = t = n = NaN : n <= 0 || n >= 1 ? e = t = NaN : t <= 0 && (e = NaN), new Ji(e, t, n, i)
+    function hR(e, t) {
+        const n = e ? lR(e) : lm(),
+            i = t ? fR(t) : Hh();
+        return Jb(n, i)
     }
 
-    function sO(e) {
-        if (e instanceof Ji) return new Ji(e.h, e.s, e.l, e.opacity);
-        if (e instanceof Va || (e = ph(e)), !e) return new Ji;
-        if (e instanceof Ji) return e;
-        e = e.rgb();
-        var t = e.r / 255,
-            n = e.g / 255,
-            i = e.b / 255,
-            r = Math.min(t, n, i),
-            s = Math.max(t, n, i),
-            a = NaN,
-            o = s - r,
-            l = (s + r) / 2;
-        return o ? (t === s ? a = (n - i) / o + (n < i) * 6 : n === s ? a = (i - t) / o + 2 : a = (t - n) / o + 4, o /= l < .5 ? s + r : 2 - s - r, a *= 60) : o = l > 0 && l < 1 ? 0 : a, new Ji(a, o, l, e.opacity)
+    function F_(e, t) {
+        const n = arguments.length;
+        return n && n !== 2 && q("defaultLocale expects either zero or two arguments."), n ? Jb(lm(e), Hh(t)) : Jb(lm(), Hh())
     }
 
-    function vp(e, t, n, i) {
-        return arguments.length === 1 ? sO(e) : new Ji(e, t, n, i ?? 1)
+    function jG() {
+        return oR(), cR(), F_()
     }
+    const GG = /^(data:|([A-Za-z]+:)?\/\/)/,
+        UG = /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp|file|data):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i,
+        WG = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205f\u3000]/g,
+        AA = "file://";
 
-    function Ji(e, t, n, i) {
-        this.h = +e, this.s = +t, this.l = +n, this.opacity = +i
+    function qG(e, t) {
+        return n => ({
+            options: n || {},
+            sanitize: YG,
+            load: HG,
+            fileAccess: !!t,
+            file: XG(t),
+            http: KG(e)
+        })
+    }
+    async function HG(e, t) {
+        const n = await this.sanitize(e, t),
+            i = n.href;
+        return n.localFile ? this.file(i) : this.http(i, t)
+    }
+    async function YG(e, t) {
+        t = Ne({}, this.options, t);
+        const n = this.fileAccess,
+            i = {
+                href: null
+            };
+        let r, s, a;
+        const o = UG.test(e.replace(WG, ""));
+        (e == null || typeof e != "string" || !o) && q("Sanitize failure, invalid URI: " + te(e));
+        const l = GG.test(e);
+        return (a = t.baseURL) && !l && (!e.startsWith("/") && !a.endsWith("/") && (e = "/" + e), e = a + e), s = (r = e.startsWith(AA)) || t.mode === "file" || t.mode !== "http" && !l && n, r ? e = e.slice(AA.length) : e.startsWith("//") && (t.defaultProtocol === "file" ? (e = e.slice(2), s = !0) : e = (t.defaultProtocol || "http") + ":" + e), Object.defineProperty(i, "localFile", {
+            value: !!s
+        }), i.href = e, t.target && (i.target = t.target + ""), t.rel && (i.rel = t.rel + ""), t.context === "image" && t.crossOrigin && (i.crossOrigin = t.crossOrigin + ""), i
     }
-    gc(Ji, vp, Kh(Va, {
-        brighter(e) {
-            return e = e == null ? Ou : Math.pow(Ou, e), new Ji(this.h, this.s, this.l * e, this.opacity)
-        },
-        darker(e) {
-            return e = e == null ? Ko : Math.pow(Ko, e), new Ji(this.h, this.s, this.l * e, this.opacity)
-        },
-        rgb() {
-            var e = this.h % 360 + (this.h < 0) * 360,
-                t = isNaN(e) || isNaN(this.s) ? 0 : this.s,
-                n = this.l,
-                i = n + (n < .5 ? n : 1 - n) * t,
-                r = 2 * n - i;
-            return new It(vy(e >= 240 ? e - 240 : e + 120, r, i), vy(e, r, i), vy(e < 120 ? e + 240 : e - 120, r, i), this.opacity)
-        },
-        clamp() {
-            return new Ji(Ok(this.h), eg(this.s), eg(this.l), yp(this.opacity))
-        },
-        displayable() {
-            return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1
-        },
-        formatHsl() {
-            const e = yp(this.opacity);
-            return `${e===1?"hsl(":"hsla("}${Ok(this.h)}, ${eg(this.s)*100}%, ${eg(this.l)*100}%${e===1?")":`, ${e})`}`
-        }
-    }));
 
-    function Ok(e) {
-        return e = (e || 0) % 360, e < 0 ? e + 360 : e
+    function XG(e) {
+        return e ? t => new Promise((n, i) => {
+            e.readFile(t, (r, s) => {
+                r ? i(r) : n(s)
+            })
+        }) : VG
+    }
+    async function VG() {
+        q("No file system access.")
     }
 
-    function eg(e) {
-        return Math.max(0, Math.min(1, e || 0))
+    function KG(e) {
+        return e ? async function(t, n) {
+            const i = Ne({}, this.options.http, n),
+                r = n && n.response,
+                s = await e(t, i);
+            return s.ok ? Pe(s[r]) ? s[r]() : s.text() : q(s.status + "" + s.statusText)
+        }: JG
     }
+    async function JG() {
+        q("No HTTP fetch method available.")
+    }
+    const QG = e => e != null && e === e,
+        ZG = e => e === "true" || e === "false" || e === !0 || e === !1,
+        eU = e => !Number.isNaN(Date.parse(e)),
+        dR = e => !Number.isNaN(+e) && !(e instanceof Date),
+        tU = e => dR(e) && Number.isInteger(+e),
+        Qb = {
+            boolean: __,
+            integer: Tn,
+            number: Tn,
+            date: w_,
+            string: S_,
+            unknown: Pn
+        },
+        _g = [ZG, tU, dR, eU],
+        nU = ["boolean", "integer", "number", "date"];
 
-    function vy(e, t, n) {
-        return (e < 60 ? t + (n - t) * e / 60 : e < 180 ? n : e < 240 ? t + (n - t) * (240 - e) / 60 : t) * 255
+    function gR(e, t) {
+        if (!e || !e.length) return "unknown";
+        const n = e.length,
+            i = _g.length,
+            r = _g.map((s, a) => a + 1);
+        for (let s = 0, a = 0, o, l; s < n; ++s)
+            for (l = t ? e[s][t] : e[s], o = 0; o < i; ++o)
+                if (r[o] && QG(l) && !_g[o](l) && (r[o] = 0, ++a, a === _g.length)) return "string";
+        return nU[r.reduce((s, a) => s === 0 ? a : s, 0) - 1]
     }
-    const aO = Math.PI / 180,
-        oO = 180 / Math.PI,
-        bp = 18,
-        lO = .96422,
-        uO = 1,
-        cO = .82521,
-        fO = 4 / 29,
-        xu = 6 / 29,
-        hO = 3 * xu * xu,
-        UB = xu * xu * xu;
 
-    function dO(e) {
-        if (e instanceof Ir) return new Ir(e.l, e.a, e.b, e.opacity);
-        if (e instanceof Ss) return gO(e);
-        e instanceof It || (e = _x(e));
-        var t = wy(e.r),
-            n = wy(e.g),
-            i = wy(e.b),
-            r = by((.2225045 * t + .7168786 * n + .0606169 * i) / uO),
-            s, a;
-        return t === n && n === i ? s = a = r : (s = by((.4360747 * t + .3850649 * n + .1430804 * i) / lO), a = by((.0139322 * t + .0971045 * n + .7141733 * i) / cO)), new Ir(116 * r - 16, 500 * (s - r), 200 * (r - a), e.opacity)
+    function pR(e, t) {
+        return t.reduce((n, i) => (n[i] = gR(e, i), n), {})
     }
 
-    function xp(e, t, n, i) {
-        return arguments.length === 1 ? dO(e) : new Ir(e, t, n, i ?? 1)
+    function $A(e) {
+        const t = function(n, i) {
+            const r = {
+                delimiter: e
+            };
+            return R_(n, i ? Ne(i, r) : r)
+        };
+        return t.responseType = "text", t
     }
 
-    function Ir(e, t, n, i) {
-        this.l = +e, this.a = +t, this.b = +n, this.opacity = +i
+    function R_(e, t) {
+        return t.header && (e = t.header.map(te).join(t.delimiter) + `
+` + e), zB(t.delimiter).parse(e + "")
     }
-    gc(Ir, xp, Kh(Va, {
-        brighter(e) {
-            return new Ir(this.l + bp * (e ?? 1), this.a, this.b, this.opacity)
-        },
-        darker(e) {
-            return new Ir(this.l - bp * (e ?? 1), this.a, this.b, this.opacity)
-        },
-        rgb() {
-            var e = (this.l + 16) / 116,
-                t = isNaN(this.a) ? e : e + this.a / 500,
-                n = isNaN(this.b) ? e : e - this.b / 200;
-            return t = lO * xy(t), e = uO * xy(e), n = cO * xy(n), new It(_y(3.1338561 * t - 1.6168667 * e - .4906146 * n), _y(-.9787684 * t + 1.9161415 * e + .033454 * n), _y(.0719453 * t - .2289914 * e + 1.4052427 * n), this.opacity)
-        }
-    }));
+    R_.responseType = "text";
 
-    function by(e) {
-        return e > UB ? Math.pow(e, 1 / 3) : e / hO + fO
+    function iU(e) {
+        return typeof Buffer == "function" && Pe(Buffer.isBuffer) ? Buffer.isBuffer(e) : !1
     }
 
-    function xy(e) {
-        return e > xu ? e * e * e : hO * (e - fO)
+    function D_(e, t) {
+        const n = t && t.property ? fi(t.property) : Pn;
+        return ce(e) && !iU(e) ? rU(n(e), t) : n(JSON.parse(e))
     }
+    D_.responseType = "json";
 
-    function _y(e) {
-        return 255 * (e <= .0031308 ? 12.92 * e : 1.055 * Math.pow(e, 1 / 2.4) - .055)
+    function rU(e, t) {
+        return !H(e) && oF(e) && (e = [...e]), t && t.copy ? JSON.parse(JSON.stringify(e)) : e
     }
+    const sU = {
+        interior: (e, t) => e !== t,
+        exterior: (e, t) => e === t
+    };
 
-    function wy(e) {
-        return (e /= 255) <= .04045 ? e / 12.92 : Math.pow((e + .055) / 1.055, 2.4)
+    function mR(e, t) {
+        let n, i, r, s;
+        return e = D_(e, t), t && t.feature ? (n = UB, r = t.feature) : t && t.mesh ? (n = qB, r = t.mesh, s = sU[t.filter]) : q("Missing TopoJSON feature or mesh parameter."), i = (i = e.objects[r]) ? n(e, i, s) : q("Invalid TopoJSON object: " + r), i && i.features || [i]
     }
+    mR.responseType = "json";
+    const _p = {
+        dsv: R_,
+        csv: $A(","),
+        tsv: $A("	"),
+        json: D_,
+        topojson: mR
+    };
 
-    function GB(e) {
-        if (e instanceof Ss) return new Ss(e.h, e.c, e.l, e.opacity);
-        if (e instanceof Ir || (e = dO(e)), e.a === 0 && e.b === 0) return new Ss(NaN, 0 < e.l && e.l < 100 ? 0 : NaN, e.l, e.opacity);
-        var t = Math.atan2(e.b, e.a) * oO;
-        return new Ss(t < 0 ? t + 360 : t, Math.sqrt(e.a * e.a + e.b * e.b), e.l, e.opacity)
+    function N_(e, t) {
+        return arguments.length > 1 ? (_p[e] = t, this) : Ce(_p, e) ? _p[e] : null
     }
 
-    function _p(e, t, n, i) {
-        return arguments.length === 1 ? GB(e) : new Ss(e, t, n, i ?? 1)
+    function yR(e) {
+        const t = N_(e);
+        return t && t.responseType || "text"
     }
 
-    function Ss(e, t, n, i) {
-        this.h = +e, this.c = +t, this.l = +n, this.opacity = +i
+    function vR(e, t, n, i) {
+        t = t || {};
+        const r = N_(t.type || "json");
+        return r || q("Unknown data format type: " + t.type), e = r(e, t), t.parse && aU(e, t.parse, n, i), Ce(e, "columns") && delete e.columns, e
     }
 
-    function gO(e) {
-        if (isNaN(e.h)) return new Ir(e.l, 0, 0, e.opacity);
-        var t = e.h * aO;
-        return new Ir(e.l, Math.cos(t) * e.c, Math.sin(t) * e.c, e.opacity)
+    function aU(e, t, n, i) {
+        if (!e.length) return;
+        const r = Hh();
+        n = n || r.timeParse, i = i || r.utcParse;
+        let s = e.columns || Object.keys(e[0]),
+            a, o, l, u, c, f;
+        t === "auto" && (t = pR(e, s)), s = Object.keys(t);
+        const h = s.map(d => {
+            const g = t[d];
+            let p, m;
+            if (g && (g.startsWith("date:") || g.startsWith("utc:"))) return p = g.split(/:(.+)?/, 2), m = p[1], (m[0] === "'" && m[m.length - 1] === "'" || m[0] === '"' && m[m.length - 1] === '"') && (m = m.slice(1, -1)), (p[0] === "utc" ? i : n)(m);
+            if (!Qb[g]) throw Error("Illegal format pattern: " + d + ":" + g);
+            return Qb[g]
+        });
+        for (l = 0, c = e.length, f = s.length; l < c; ++l)
+            for (a = e[l], u = 0; u < f; ++u) o = s[u], a[o] = h[u](a[o])
     }
-    gc(Ss, _p, Kh(Va, {
-        brighter(e) {
-            return new Ss(this.h, this.c, this.l + bp * (e ?? 1), this.opacity)
-        },
-        darker(e) {
-            return new Ss(this.h, this.c, this.l - bp * (e ?? 1), this.opacity)
-        },
-        rgb() {
-            return gO(this).rgb()
+    const H0 = qG(typeof fetch < "u" && fetch, null);
+
+    function Y0(e) {
+        const t = e || Pn,
+            n = [],
+            i = {};
+        return n.add = r => {
+            const s = t(r);
+            return i[s] || (i[s] = 1, n.push(r)), n
+        }, n.remove = r => {
+            const s = t(r);
+            if (i[s]) {
+                i[s] = 0;
+                const a = n.indexOf(r);
+                a >= 0 && n.splice(a, 1)
+            }
+            return n
+        }, n
+    }
+    async function wp(e, t) {
+        try {
+            await t(e)
+        } catch (n) {
+            e.error(n)
         }
-    }));
-    var pO = -.14861,
-        wx = 1.78277,
-        Sx = -.29227,
-        im = -.90649,
-        mh = 1.97294,
-        Fk = mh * im,
-        Rk = mh * wx,
-        Dk = wx * Sx - im * pO;
-
-    function WB(e) {
-        if (e instanceof Bo) return new Bo(e.h, e.s, e.l, e.opacity);
-        e instanceof It || (e = _x(e));
-        var t = e.r / 255,
-            n = e.g / 255,
-            i = e.b / 255,
-            r = (Dk * i + Fk * t - Rk * n) / (Dk + Fk - Rk),
-            s = i - r,
-            a = (mh * (n - r) - Sx * s) / im,
-            o = Math.sqrt(a * a + s * s) / (mh * r * (1 - r)),
-            l = o ? Math.atan2(a, s) * oO - 120 : NaN;
-        return new Bo(l < 0 ? l + 360 : l, o, r, e.opacity)
     }
+    const bR = Symbol("vega_id");
+    let oU = 1;
 
-    function ib(e, t, n, i) {
-        return arguments.length === 1 ? WB(e) : new Bo(e, t, n, i ?? 1)
+    function X0(e) {
+        return !!(e && Ee(e))
     }
 
-    function Bo(e, t, n, i) {
-        this.h = +e, this.s = +t, this.l = +n, this.opacity = +i
+    function Ee(e) {
+        return e[bR]
     }
-    gc(Bo, ib, Kh(Va, {
-        brighter(e) {
-            return e = e == null ? Ou : Math.pow(Ou, e), new Bo(this.h, this.s, this.l * e, this.opacity)
-        },
-        darker(e) {
-            return e = e == null ? Ko : Math.pow(Ko, e), new Bo(this.h, this.s, this.l * e, this.opacity)
-        },
-        rgb() {
-            var e = isNaN(this.h) ? 0 : (this.h + 120) * aO,
-                t = +this.l,
-                n = isNaN(this.s) ? 0 : this.s * t * (1 - t),
-                i = Math.cos(e),
-                r = Math.sin(e);
-            return new It(255 * (t + n * (pO * i + wx * r)), 255 * (t + n * (Sx * i + im * r)), 255 * (t + n * (mh * i)), this.opacity)
-        }
-    }));
 
-    function mO(e, t, n, i, r) {
-        var s = e * e,
-            a = s * e;
-        return ((1 - 3 * e + 3 * s - a) * t + (4 - 6 * s + 3 * a) * n + (1 + 3 * e + 3 * s - 3 * a) * i + a * r) / 6
+    function xR(e, t) {
+        return e[bR] = t, e
     }
 
-    function yO(e) {
-        var t = e.length - 1;
-        return function(n) {
-            var i = n <= 0 ? n = 0 : n >= 1 ? (n = 1, t - 1) : Math.floor(n * t),
-                r = e[i],
-                s = e[i + 1],
-                a = i > 0 ? e[i - 1] : 2 * r - s,
-                o = i < t - 1 ? e[i + 2] : 2 * s - r;
-            return mO((n - i / t) * t, a, r, s, o)
-        }
+    function it(e) {
+        const t = e === Object(e) ? e : {
+            data: e
+        };
+        return Ee(t) ? t : xR(t, oU++)
     }
 
-    function vO(e) {
-        var t = e.length;
-        return function(n) {
-            var i = Math.floor(((n %= 1) < 0 ? ++n : n) * t),
-                r = e[(i + t - 1) % t],
-                s = e[i % t],
-                a = e[(i + 1) % t],
-                o = e[(i + 2) % t];
-            return mO((n - i / t) * t, r, s, a, o)
-        }
+    function P_(e) {
+        return V0(e, it({}))
     }
-    const rm = e => () => e;
 
-    function bO(e, t) {
-        return function(n) {
-            return e + n * t
-        }
+    function V0(e, t) {
+        for (const n in e) t[n] = e[n];
+        return t
     }
 
-    function qB(e, t, n) {
-        return e = Math.pow(e, n), t = Math.pow(t, n) - e, n = 1 / n,
-            function(i) {
-                return Math.pow(e + i * t, n)
-            }
+    function _R(e, t) {
+        return xR(t, Ee(e))
     }
 
-    function sm(e, t) {
-        var n = t - e;
-        return n ? bO(e, n > 180 || n < -180 ? n - 360 * Math.round(n / 360) : n) : rm(isNaN(e) ? t : e)
+    function Yl(e, t) {
+        return e ? t ? (n, i) => e(n, i) || Ee(t(n)) - Ee(t(i)) : (n, i) => e(n, i) || Ee(n) - Ee(i) : null
     }
 
-    function HB(e) {
-        return (e = +e) == 1 ? zt : function(t, n) {
-            return n - t ? qB(t, n, e) : rm(isNaN(t) ? n : t)
-        }
+    function wR(e) {
+        return e && e.constructor === Xl
     }
 
-    function zt(e, t) {
-        var n = t - e;
-        return n ? bO(e, n) : rm(isNaN(e) ? t : e)
-    }
-    const rb = function e(t) {
-        var n = HB(t);
+    function Xl() {
+        const e = [],
+            t = [],
+            n = [],
+            i = [],
+            r = [];
+        let s = null,
+            a = !1;
+        return {
+            constructor: Xl,
+            insert(o) {
+                const l = ue(o),
+                    u = l.length;
+                for (let c = 0; c < u; ++c) e.push(l[c]);
+                return this
+            },
+            remove(o) {
+                const l = Pe(o) ? i : t,
+                    u = ue(o),
+                    c = u.length;
+                for (let f = 0; f < c; ++f) l.push(u[f]);
+                return this
+            },
+            modify(o, l, u) {
+                const c = {
+                    field: l,
+                    value: Ln(u)
+                };
+                return Pe(o) ? (c.filter = o, r.push(c)) : (c.tuple = o, n.push(c)), this
+            },
+            encode(o, l) {
+                return Pe(o) ? r.push({
+                    filter: o,
+                    field: l
+                }) : n.push({
+                    tuple: o,
+                    field: l
+                }), this
+            },
+            clean(o) {
+                return s = o, this
+            },
+            reflow() {
+                return a = !0, this
+            },
+            pulse(o, l) {
+                const u = {},
+                    c = {};
+                let f, h, d, g, p, m;
+                for (f = 0, h = l.length; f < h; ++f) u[Ee(l[f])] = 1;
+                for (f = 0, h = t.length; f < h; ++f) p = t[f], u[Ee(p)] = -1;
+                for (f = 0, h = i.length; f < h; ++f) g = i[f], l.forEach(v => {
+                    g(v) && (u[Ee(v)] = -1)
+                });
+                for (f = 0, h = e.length; f < h; ++f) p = e[f], m = Ee(p), u[m] ? u[m] = 1 : o.add.push(it(e[f]));
+                for (f = 0, h = l.length; f < h; ++f) p = l[f], u[Ee(p)] < 0 && o.rem.push(p);
 
-        function i(r, s) {
-            var a = n((r = Ma(r)).r, (s = Ma(s)).r),
-                o = n(r.g, s.g),
-                l = n(r.b, s.b),
-                u = zt(r.opacity, s.opacity);
-            return function(c) {
-                return r.r = a(c), r.g = o(c), r.b = l(c), r.opacity = u(c), r + ""
+                function y(v, b, x) {
+                    x ? v[b] = x(v) : o.encode = b, a || (c[Ee(v)] = v)
+                }
+                for (f = 0, h = n.length; f < h; ++f) d = n[f], p = d.tuple, g = d.field, m = u[Ee(p)], m > 0 && (y(p, g, d.value), o.modifies(g));
+                for (f = 0, h = r.length; f < h; ++f) d = r[f], g = d.filter, l.forEach(v => {
+                    g(v) && u[Ee(v)] > 0 && y(v, d.field, d.value)
+                }), o.modifies(d.field);
+                if (a) o.mod = t.length || i.length ? l.filter(v => u[Ee(v)] > 0) : l.slice();
+                else
+                    for (m in c) o.mod.push(c[m]);
+                return (s || s == null && (t.length || i.length)) && o.clean(!0), o
             }
         }
-        return i.gamma = e, i
-    }(1);
+    }
+    const Sp = "_:mod:_";
 
-    function xO(e) {
-        return function(t) {
-            var n = t.length,
-                i = new Array(n),
-                r = new Array(n),
-                s = new Array(n),
-                a, o;
-            for (a = 0; a < n; ++a) o = Ma(t[a]), i[a] = o.r || 0, r[a] = o.g || 0, s[a] = o.b || 0;
-            return i = e(i), r = e(r), s = e(s), o.opacity = 1,
-                function(l) {
-                    return o.r = i(l), o.g = r(l), o.b = s(l), o + ""
+    function K0() {
+        Object.defineProperty(this, Sp, {
+            writable: !0,
+            value: {}
+        })
+    }
+    K0.prototype = {
+        set(e, t, n, i) {
+            const r = this,
+                s = r[e],
+                a = r[Sp];
+            return t != null && t >= 0 ? (s[t] !== n || i) && (s[t] = n, a[t + ":" + e] = -1, a[e] = -1) : (s !== n || i) && (r[e] = n, a[e] = H(n) ? 1 + n.length : -1), r
+        },
+        modified(e, t) {
+            const n = this[Sp];
+            if (arguments.length) {
+                if (H(e)) {
+                    for (let i = 0; i < e.length; ++i)
+                        if (n[e[i]]) return !0;
+                    return !1
                 }
+            } else {
+                for (const i in n)
+                    if (n[i]) return !0;
+                return !1
+            }
+            return t != null && t >= 0 ? t + 1 < n[e] || !!n[t + ":" + e] : !!n[e]
+        },
+        clear() {
+            return this[Sp] = {}, this
         }
+    };
+    let lU = 0;
+    const uU = "pulse",
+        cU = new K0,
+        fU = 1,
+        hU = 2;
+
+    function dt(e, t, n, i) {
+        this.id = ++lU, this.value = e, this.stamp = -1, this.rank = -1, this.qrank = -1, this.flags = 0, t && (this._update = t), n && this.parameters(n, i)
     }
-    var YB = xO(yO),
-        XB = xO(vO);
 
-    function Ex(e, t) {
-        t || (t = []);
-        var n = e ? Math.min(t.length, e.length) : 0,
-            i = t.slice(),
-            r;
-        return function(s) {
-            for (r = 0; r < n; ++r) i[r] = e[r] * (1 - s) + t[r] * s;
-            return i
+    function TA(e) {
+        return function(t) {
+            const n = this.flags;
+            return arguments.length === 0 ? !!(n & e) : (this.flags = t ? n | e : n & ~e, this)
         }
     }
+    dt.prototype = {
+        targets() {
+            return this._targets || (this._targets = Y0(kd))
+        },
+        set(e) {
+            return this.value !== e ? (this.value = e, 1) : 0
+        },
+        skip: TA(fU),
+        modified: TA(hU),
+        parameters(e, t, n) {
+            t = t !== !1;
+            const i = this._argval = this._argval || new K0,
+                r = this._argops = this._argops || [],
+                s = [];
+            let a, o, l, u;
+            const c = (f, h, d) => {
+                d instanceof dt ? (d !== this && (t && d.targets().add(this), s.push(d)), r.push({
+                    op: d,
+                    name: f,
+                    index: h
+                })) : i.set(f, h, d)
+            };
+            for (a in e)
+                if (o = e[a], a === uU) ue(o).forEach(f => {
+                    f instanceof dt ? f !== this && (f.targets().add(this), s.push(f)) : q("Pulse parameters must be operator instances.")
+                }), this.source = o;
+                else if (H(o))
+                for (i.set(a, -1, Array(l = o.length)), u = 0; u < l; ++u) c(a, u, o[u]);
+            else c(a, -1, o);
+            return this.marshall().clear(), n && (r.initonly = !0), s
+        },
+        marshall(e) {
+            const t = this._argval || cU,
+                n = this._argops;
+            let i, r, s, a;
+            if (n) {
+                const o = n.length;
+                for (r = 0; r < o; ++r) i = n[r], s = i.op, a = s.modified() && s.stamp === e, t.set(i.name, i.index, s.value, a);
+                if (n.initonly) {
+                    for (r = 0; r < o; ++r) i = n[r], i.op.targets().remove(this);
+                    this._argops = null, this._update = null
+                }
+            }
+            return t
+        },
+        detach() {
+            const e = this._argops;
+            let t, n, i, r;
+            if (e)
+                for (t = 0, n = e.length; t < n; ++t) i = e[t], r = i.op, r._targets && r._targets.remove(this);
+            this.pulse = null, this.source = null
+        },
+        evaluate(e) {
+            const t = this._update;
+            if (t) {
+                const n = this.marshall(e.stamp),
+                    i = t.call(this, n, e);
+                if (n.clear(), i !== this.value) this.value = i;
+                else if (!this.modified()) return e.StopPropagation
+            }
+        },
+        run(e) {
+            if (e.stamp < this.stamp) return e.StopPropagation;
+            let t;
+            return this.skip() ? (this.skip(!1), t = 0) : t = this.evaluate(e), this.pulse = t || e
+        }
+    };
 
-    function _O(e) {
-        return ArrayBuffer.isView(e) && !(e instanceof DataView)
+    function dU(e, t, n, i) {
+        let r = 1,
+            s;
+        return e instanceof dt ? s = e : e && e.prototype instanceof dt ? s = new e : Pe(e) ? s = new dt(null, e) : (r = 0, s = new dt(e, t)), this.rank(s), r && (i = n, n = t), n && this.connect(s, s.parameters(n, i)), this.touch(s), s
     }
 
-    function VB(e, t) {
-        return (_O(t) ? Ex : wO)(e, t)
+    function gU(e, t) {
+        const n = e.rank,
+            i = t.length;
+        for (let r = 0; r < i; ++r)
+            if (n < t[r].rank) {
+                this.rerank(e);
+                return
+            }
     }
+    let pU = 0;
 
-    function wO(e, t) {
-        var n = t ? t.length : 0,
-            i = e ? Math.min(n, e.length) : 0,
-            r = new Array(i),
-            s = new Array(n),
-            a;
-        for (a = 0; a < i; ++a) r[a] = Ka(e[a], t[a]);
-        for (; a < n; ++a) s[a] = t[a];
-        return function(o) {
-            for (a = 0; a < i; ++a) s[a] = r[a](o);
-            return s
-        }
+    function J0(e, t, n) {
+        this.id = ++pU, this.value = null, n && (this.receive = n), e && (this._filter = e), t && (this._apply = t)
     }
 
-    function SO(e, t) {
-        var n = new Date;
-        return e = +e, t = +t,
-            function(i) {
-                return n.setTime(e * (1 - i) + t * i), n
+    function wa(e, t, n) {
+        return new J0(e, t, n)
+    }
+    J0.prototype = {
+        _filter: Yi,
+        _apply: Pn,
+        targets() {
+            return this._targets || (this._targets = Y0(kd))
+        },
+        consume(e) {
+            return arguments.length ? (this._consume = !!e, this) : !!this._consume
+        },
+        receive(e) {
+            if (this._filter(e)) {
+                const t = this.value = this._apply(e),
+                    n = this._targets,
+                    i = n ? n.length : 0;
+                for (let r = 0; r < i; ++r) n[r].receive(t);
+                this._consume && (e.preventDefault(), e.stopPropagation())
             }
+        },
+        filter(e) {
+            const t = wa(e);
+            return this.targets().add(t), t
+        },
+        apply(e) {
+            const t = wa(null, e);
+            return this.targets().add(t), t
+        },
+        merge() {
+            const e = wa();
+            this.targets().add(e);
+            for (let t = 0, n = arguments.length; t < n; ++t) arguments[t].targets().add(e);
+            return e
+        },
+        throttle(e) {
+            let t = -1;
+            return this.filter(() => {
+                const n = Date.now();
+                return n - t > e ? (t = n, 1) : 0
+            })
+        },
+        debounce(e) {
+            const t = wa();
+            return this.targets().add(wa(null, null, b_(e, n => {
+                const i = n.dataflow;
+                t.receive(n), i && i.run && i.run()
+            }))), t
+        },
+        between(e, t) {
+            let n = !1;
+            return e.targets().add(wa(null, null, () => n = !0)), t.targets().add(wa(null, null, () => n = !1)), this.filter(() => n)
+        },
+        detach() {
+            this._filter = Yi, this._targets = null
+        }
+    };
+
+    function mU(e, t, n, i) {
+        const r = this,
+            s = wa(n, i),
+            a = function(u) {
+                u.dataflow = r;
+                try {
+                    s.receive(u)
+                } catch (c) {
+                    r.error(c)
+                } finally {
+                    r.run()
+                }
+            };
+        let o;
+        typeof e == "string" && typeof document < "u" ? o = document.querySelectorAll(e) : o = ue(e);
+        const l = o.length;
+        for (let u = 0; u < l; ++u) o[u].addEventListener(t, a);
+        return s
     }
 
-    function Xi(e, t) {
-        return e = +e, t = +t,
-            function(n) {
-                return e * (1 - n) + t * n
-            }
+    function yU(e, t) {
+        const n = this.locale();
+        return vR(e, t, n.timeParse, n.utcParse)
     }
 
-    function EO(e, t) {
-        var n = {},
-            i = {},
+    function vU(e, t, n) {
+        return t = this.parse(t, n), this.pulse(e, this.changeset().insert(t))
+    }
+    async function bU(e, t) {
+        const n = this;
+        let i = 0,
             r;
-        (e === null || typeof e != "object") && (e = {}), (t === null || typeof t != "object") && (t = {});
-        for (r in t) r in e ? n[r] = Ka(e[r], t[r]) : i[r] = t[r];
-        return function(s) {
-            for (r in n) i[r] = n[r](s);
-            return i
+        try {
+            r = await n.loader().load(e, {
+                context: "dataflow",
+                response: yR(t && t.type)
+            });
+            try {
+                r = n.parse(r, t)
+            } catch (s) {
+                i = -2, n.warn("Data ingestion failed", e, s)
+            }
+        } catch (s) {
+            i = -1, n.warn("Loading failed", e, s)
         }
-    }
-    var sb = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
-        Sy = new RegExp(sb.source, "g");
-
-    function KB(e) {
-        return function() {
-            return e
+        return {
+            data: r,
+            status: i
         }
     }
-
-    function JB(e) {
-        return function(t) {
-            return e(t) + ""
-        }
+    async function xU(e, t, n) {
+        const i = this,
+            r = i._pending || _U(i);
+        r.requests += 1;
+        const s = await i.request(t, n);
+        return i.pulse(e, i.changeset().remove(Yi).insert(s.data || [])), r.done(), s
     }
 
-    function CO(e, t) {
-        var n = sb.lastIndex = Sy.lastIndex = 0,
-            i, r, s, a = -1,
-            o = [],
-            l = [];
-        for (e = e + "", t = t + "";
-            (i = sb.exec(e)) && (r = Sy.exec(t));)(s = r.index) > n && (s = t.slice(n, s), o[a] ? o[a] += s : o[++a] = s), (i = i[0]) === (r = r[0]) ? o[a] ? o[a] += r : o[++a] = r : (o[++a] = null, l.push({
-            i: a,
-            x: Xi(i, r)
-        })), n = Sy.lastIndex;
-        return n < t.length && (s = t.slice(n), o[a] ? o[a] += s : o[++a] = s), o.length < 2 ? l[0] ? JB(l[0].x) : KB(t) : (t = l.length, function(u) {
-            for (var c = 0, f; c < t; ++c) o[(f = l[c]).i] = f.x(u);
-            return o.join("")
-        })
+    function _U(e) {
+        let t;
+        const n = new Promise(i => t = i);
+        return n.requests = 0, n.done = () => {
+            --n.requests === 0 && (e._pending = null, t(e))
+        }, e._pending = n
     }
+    const wU = {
+        skip: !0
+    };
 
-    function Ka(e, t) {
-        var n = typeof t,
-            i;
-        return t == null || n === "boolean" ? rm(t) : (n === "number" ? Xi : n === "string" ? (i = ph(t)) ? (t = i, rb) : CO : t instanceof ph ? rb : t instanceof Date ? SO : _O(t) ? Ex : Array.isArray(t) ? wO : typeof t.valueOf != "function" && typeof t.toString != "function" || isNaN(t) ? EO : Xi)(e, t)
+    function SU(e, t, n, i, r) {
+        return (e instanceof dt ? kU : EU)(this, e, t, n, i, r), this
     }
 
-    function QB(e) {
-        var t = e.length;
-        return function(n) {
-            return e[Math.max(0, Math.min(t - 1, Math.floor(n * t)))]
-        }
+    function EU(e, t, n, i, r, s) {
+        const a = Ne({}, s, wU);
+        let o, l;
+        Pe(n) || (n = Ln(n)), i === void 0 ? o = u => e.touch(n(u)) : Pe(i) ? (l = new dt(null, i, r, !1), o = u => {
+            l.evaluate(u);
+            const c = n(u),
+                f = l.value;
+            wR(f) ? e.pulse(c, f, s) : e.update(c, f, a)
+        }) : o = u => e.update(n(u), i, a), t.apply(o)
     }
 
-    function ZB(e, t) {
-        var n = sm(+e, +t);
-        return function(i) {
-            var r = n(i);
-            return r - 360 * Math.floor(r / 360)
+    function kU(e, t, n, i, r, s) {
+        if (i === void 0) t.targets().add(n);
+        else {
+            const a = s || {},
+                o = new dt(null, CU(n, i), r, !1);
+            o.modified(a.force), o.rank = t.rank, t.targets().add(o), n && (o.skip(!0), o.value = n.value, o.targets().add(n), e.connect(n, [o]))
         }
     }
 
-    function Jh(e, t) {
-        return e = +e, t = +t,
-            function(n) {
-                return Math.round(e * (1 - n) + t * n)
-            }
+    function CU(e, t) {
+        return t = Pe(t) ? t : Ln(t), e ? function(n, i) {
+            const r = t(n, i);
+            return e.skip() || (e.skip(r !== this.value).value = r), r
+        } : t
     }
-    var Nk = 180 / Math.PI,
-        ab = {
-            translateX: 0,
-            translateY: 0,
-            rotate: 0,
-            skewX: 0,
-            scaleX: 1,
-            scaleY: 1
-        };
 
-    function kO(e, t, n, i, r, s) {
-        var a, o, l;
-        return (a = Math.sqrt(e * e + t * t)) && (e /= a, t /= a), (l = e * n + t * i) && (n -= e * l, i -= t * l), (o = Math.sqrt(n * n + i * i)) && (n /= o, i /= o, l /= o), e * i < t * n && (e = -e, t = -t, l = -l, a = -a), {
-            translateX: r,
-            translateY: s,
-            rotate: Math.atan2(t, e) * Nk,
-            skewX: Math.atan(l) * Nk,
-            scaleX: a,
-            scaleY: o
-        }
+    function AU(e) {
+        e.rank = ++this._rank
     }
-    var tg;
 
-    function ej(e) {
-        const t = new(typeof DOMMatrix == "function" ? DOMMatrix : WebKitCSSMatrix)(e + "");
-        return t.isIdentity ? ab : kO(t.a, t.b, t.c, t.d, t.e, t.f)
+    function $U(e) {
+        const t = [e];
+        let n, i, r;
+        for (; t.length;)
+            if (this.rank(n = t.pop()), i = n._targets)
+                for (r = i.length; --r >= 0;) t.push(n = i[r]), n === e && q("Cycle detected in dataflow graph.")
     }
+    const um = {},
+        qr = 1,
+        Ca = 2,
+        Ds = 4,
+        TU = qr | Ca,
+        MA = qr | Ds,
+        mu = qr | Ca | Ds,
+        OA = 8,
+        Sf = 16,
+        FA = 32,
+        RA = 64;
 
-    function tj(e) {
-        return e == null || (tg || (tg = document.createElementNS("http://www.w3.org/2000/svg", "g")), tg.setAttribute("transform", e), !(e = tg.transform.baseVal.consolidate())) ? ab : (e = e.matrix, kO(e.a, e.b, e.c, e.d, e.e, e.f))
+    function qa(e, t, n) {
+        this.dataflow = e, this.stamp = t ?? -1, this.add = [], this.rem = [], this.mod = [], this.fields = null, this.encode = n || null
     }
 
-    function AO(e, t, n, i) {
-        function r(u) {
-            return u.length ? u.pop() + " " : ""
-        }
-
-        function s(u, c, f, h, d, g) {
-            if (u !== f || c !== h) {
-                var p = d.push("translate(", null, t, null, n);
-                g.push({
-                    i: p - 4,
-                    x: Xi(u, f)
-                }, {
-                    i: p - 2,
-                    x: Xi(c, h)
-                })
-            } else(f || h) && d.push("translate(" + f + t + h + n)
-        }
-
-        function a(u, c, f, h) {
-            u !== c ? (u - c > 180 ? c += 360 : c - u > 180 && (u += 360), h.push({
-                i: f.push(r(f) + "rotate(", null, i) - 2,
-                x: Xi(u, c)
-            })) : c && f.push(r(f) + "rotate(" + c + i)
-        }
-
-        function o(u, c, f, h) {
-            u !== c ? h.push({
-                i: f.push(r(f) + "skewX(", null, i) - 2,
-                x: Xi(u, c)
-            }) : c && f.push(r(f) + "skewX(" + c + i)
-        }
-
-        function l(u, c, f, h, d, g) {
-            if (u !== f || c !== h) {
-                var p = d.push(r(d) + "scale(", null, ",", null, ")");
-                g.push({
-                    i: p - 4,
-                    x: Xi(u, f)
-                }, {
-                    i: p - 2,
-                    x: Xi(c, h)
-                })
-            } else(f !== 1 || h !== 1) && d.push(r(d) + "scale(" + f + "," + h + ")")
-        }
-        return function(u, c) {
-            var f = [],
-                h = [];
-            return u = e(u), c = e(c), s(u.translateX, u.translateY, c.translateX, c.translateY, f, h), a(u.rotate, c.rotate, f, h), o(u.skewX, c.skewX, f, h), l(u.scaleX, u.scaleY, c.scaleX, c.scaleY, f, h), u = c = null,
-                function(d) {
-                    for (var g = -1, p = h.length, m; ++g < p;) f[(m = h[g]).i] = m.x(d);
-                    return f.join("")
-                }
-        }
+    function iv(e, t) {
+        const n = [];
+        return ka(e, t, i => n.push(i)), n
     }
-    var nj = AO(ej, "px, ", "px)", "deg)"),
-        ij = AO(tj, ", ", ")", ")"),
-        rj = 1e-12;
 
-    function Pk(e) {
-        return ((e = Math.exp(e)) + 1 / e) / 2
+    function DA(e, t) {
+        const n = {};
+        return e.visit(t, i => {
+            n[Ee(i)] = 1
+        }), i => n[Ee(i)] ? null : i
     }
 
-    function sj(e) {
-        return ((e = Math.exp(e)) - 1 / e) / 2
+    function wg(e, t) {
+        return e ? (n, i) => e(n, i) && t(n, i) : t
     }
+    qa.prototype = {
+        StopPropagation: um,
+        ADD: qr,
+        REM: Ca,
+        MOD: Ds,
+        ADD_REM: TU,
+        ADD_MOD: MA,
+        ALL: mu,
+        REFLOW: OA,
+        SOURCE: Sf,
+        NO_SOURCE: FA,
+        NO_FIELDS: RA,
+        fork(e) {
+            return new qa(this.dataflow).init(this, e)
+        },
+        clone() {
+            const e = this.fork(mu);
+            return e.add = e.add.slice(), e.rem = e.rem.slice(), e.mod = e.mod.slice(), e.source && (e.source = e.source.slice()), e.materialize(mu | Sf)
+        },
+        addAll() {
+            let e = this;
+            return !e.source || e.add === e.rem || !e.rem.length && e.source.length === e.add.length || (e = new qa(this.dataflow).init(this), e.add = e.source, e.rem = []), e
+        },
+        init(e, t) {
+            const n = this;
+            return n.stamp = e.stamp, n.encode = e.encode, e.fields && !(t & RA) && (n.fields = e.fields), t & qr ? (n.addF = e.addF, n.add = e.add) : (n.addF = null, n.add = []), t & Ca ? (n.remF = e.remF, n.rem = e.rem) : (n.remF = null, n.rem = []), t & Ds ? (n.modF = e.modF, n.mod = e.mod) : (n.modF = null, n.mod = []), t & FA ? (n.srcF = null, n.source = null) : (n.srcF = e.srcF, n.source = e.source, e.cleans && (n.cleans = e.cleans)), n
+        },
+        runAfter(e) {
+            this.dataflow.runAfter(e)
+        },
+        changed(e) {
+            const t = e || mu;
+            return t & qr && this.add.length || t & Ca && this.rem.length || t & Ds && this.mod.length
+        },
+        reflow(e) {
+            if (e) return this.fork(mu).reflow();
+            const t = this.add.length,
+                n = this.source && this.source.length;
+            return n && n !== t && (this.mod = this.source, t && this.filter(Ds, DA(this, qr))), this
+        },
+        clean(e) {
+            return arguments.length ? (this.cleans = !!e, this) : this.cleans
+        },
+        modifies(e) {
+            const t = this.fields || (this.fields = {});
+            return H(e) ? e.forEach(n => t[n] = !0) : t[e] = !0, this
+        },
+        modified(e, t) {
+            const n = this.fields;
+            return (t || this.mod.length) && n ? arguments.length ? H(e) ? e.some(i => n[i]) : n[e] : !!n : !1
+        },
+        filter(e, t) {
+            const n = this;
+            return e & qr && (n.addF = wg(n.addF, t)), e & Ca && (n.remF = wg(n.remF, t)), e & Ds && (n.modF = wg(n.modF, t)), e & Sf && (n.srcF = wg(n.srcF, t)), n
+        },
+        materialize(e) {
+            e = e || mu;
+            const t = this;
+            return e & qr && t.addF && (t.add = iv(t.add, t.addF), t.addF = null), e & Ca && t.remF && (t.rem = iv(t.rem, t.remF), t.remF = null), e & Ds && t.modF && (t.mod = iv(t.mod, t.modF), t.modF = null), e & Sf && t.srcF && (t.source = t.source.filter(t.srcF), t.srcF = null), t
+        },
+        visit(e, t) {
+            const n = this,
+                i = t;
+            if (e & Sf) return ka(n.source, n.srcF, i), n;
+            e & qr && ka(n.add, n.addF, i), e & Ca && ka(n.rem, n.remF, i), e & Ds && ka(n.mod, n.modF, i);
+            const r = n.source;
+            if (e & OA && r) {
+                const s = n.add.length + n.mod.length;
+                s === r.length || (s ? ka(r, DA(n, MA), i) : ka(r, n.srcF, i))
+            }
+            return n
+        }
+    };
 
-    function aj(e) {
-        return ((e = Math.exp(2 * e)) - 1) / (e + 1)
+    function L_(e, t, n, i) {
+        const r = this;
+        let s = 0;
+        this.dataflow = e, this.stamp = t, this.fields = null, this.encode = i || null, this.pulses = n;
+        for (const a of n)
+            if (a.stamp === t) {
+                if (a.fields) {
+                    const o = r.fields || (r.fields = {});
+                    for (const l in a.fields) o[l] = 1
+                }
+                a.changed(r.ADD) && (s |= r.ADD), a.changed(r.REM) && (s |= r.REM), a.changed(r.MOD) && (s |= r.MOD)
+            } this.changes = s
     }
-    const oj = function e(t, n, i) {
-        function r(s, a) {
-            var o = s[0],
-                l = s[1],
-                u = s[2],
-                c = a[0],
-                f = a[1],
-                h = a[2],
-                d = c - o,
-                g = f - l,
-                p = d * d + g * g,
-                m, y;
-            if (p < rj) y = Math.log(h / u) / t, m = function(w) {
-                return [o + w * d, l + w * g, u * Math.exp(t * w * y)]
-            };
-            else {
-                var v = Math.sqrt(p),
-                    b = (h * h - u * u + i * p) / (2 * u * n * v),
-                    x = (h * h - u * u - i * p) / (2 * h * n * v),
-                    _ = Math.log(Math.sqrt(b * b + 1) - b),
-                    S = Math.log(Math.sqrt(x * x + 1) - x);
-                y = (S - _) / t, m = function(w) {
-                    var E = w * y,
-                        A = Pk(_),
-                        C = u / (n * v) * (A * aj(t * E + _) - sj(_));
-                    return [o + C * d, l + C * g, u * A / Pk(t * E + _)]
+    ne(L_, qa, {
+        fork(e) {
+            const t = new qa(this.dataflow).init(this, e & this.NO_FIELDS);
+            return e !== void 0 && (e & t.ADD && this.visit(t.ADD, n => t.add.push(n)), e & t.REM && this.visit(t.REM, n => t.rem.push(n)), e & t.MOD && this.visit(t.MOD, n => t.mod.push(n))), t
+        },
+        changed(e) {
+            return this.changes & e
+        },
+        modified(e) {
+            const t = this,
+                n = t.fields;
+            return n && t.changes & t.MOD ? H(e) ? e.some(i => n[i]) : n[e] : 0
+        },
+        filter() {
+            q("MultiPulse does not support filtering.")
+        },
+        materialize() {
+            q("MultiPulse does not support materialization.")
+        },
+        visit(e, t) {
+            const n = this,
+                i = n.pulses,
+                r = i.length;
+            let s = 0;
+            if (e & n.SOURCE)
+                for (; s < r; ++s) i[s].visit(e, t);
+            else
+                for (; s < r; ++s) i[s].stamp === n.stamp && i[s].visit(e, t);
+            return n
+        }
+    });
+    async function MU(e, t, n) {
+        const i = this,
+            r = [];
+        if (i._pulse) return SR(i);
+        if (i._pending && await i._pending, t && await wp(i, t), !i._touched.length) return i.debug("Dataflow invoked, but nothing to do."), i;
+        const s = ++i._clock;
+        i._pulse = new qa(i, s, e), i._touched.forEach(c => i._enqueue(c, !0)), i._touched = Y0(kd);
+        let a = 0,
+            o, l, u;
+        try {
+            for (; i._heap.size() > 0;) {
+                if (o = i._heap.pop(), o.rank !== o.qrank) {
+                    i._enqueue(o, !0);
+                    continue
                 }
+                l = o.run(i._getPulse(o, e)), l.then ? l = await l : l.async && (r.push(l.async), l = um), l !== um && o._targets && o._targets.forEach(c => i._enqueue(c)), ++a
             }
-            return m.duration = y * 1e3 * t / Math.SQRT2, m
+        } catch (c) {
+            i._heap.clear(), u = c
         }
-        return r.rho = function(s) {
-            var a = Math.max(.001, +s),
-                o = a * a,
-                l = o * o;
-            return e(a, o, l)
-        }, r
-    }(Math.SQRT2, 2, 4);
-
-    function $O(e) {
-        return function(t, n) {
-            var i = e((t = vp(t)).h, (n = vp(n)).h),
-                r = zt(t.s, n.s),
-                s = zt(t.l, n.l),
-                a = zt(t.opacity, n.opacity);
-            return function(o) {
-                return t.h = i(o), t.s = r(o), t.l = s(o), t.opacity = a(o), t + ""
-            }
+        if (i._input = {}, i._pulse = null, i.debug(`Pulse ${s}: ${a} operators`), u && (i._postrun = [], i.error(u)), i._postrun.length) {
+            const c = i._postrun.sort((f, h) => h.priority - f.priority);
+            i._postrun = [];
+            for (let f = 0; f < c.length; ++f) await wp(i, c[f].callback)
         }
+        return n && await wp(i, n), r.length && Promise.all(r).then(c => i.runAsync(null, () => {
+            c.forEach(f => {
+                try {
+                    f(i)
+                } catch (h) {
+                    i.error(h)
+                }
+            })
+        })), i
+    }
+    async function OU(e, t, n) {
+        for (; this._running;) await this._running;
+        const i = () => this._running = null;
+        return (this._running = this.evaluate(e, t, n)).then(i, i), this._running
     }
-    const lj = $O(sm);
-    var uj = $O(zt);
 
-    function cj(e, t) {
-        var n = zt((e = xp(e)).l, (t = xp(t)).l),
-            i = zt(e.a, t.a),
-            r = zt(e.b, t.b),
-            s = zt(e.opacity, t.opacity);
-        return function(a) {
-            return e.l = n(a), e.a = i(a), e.b = r(a), e.opacity = s(a), e + ""
-        }
+    function FU(e, t, n) {
+        return this._pulse ? SR(this) : (this.evaluate(e, t, n), this)
     }
 
-    function TO(e) {
-        return function(t, n) {
-            var i = e((t = _p(t)).h, (n = _p(n)).h),
-                r = zt(t.c, n.c),
-                s = zt(t.l, n.l),
-                a = zt(t.opacity, n.opacity);
-            return function(o) {
-                return t.h = i(o), t.c = r(o), t.l = s(o), t.opacity = a(o), t + ""
-            }
+    function RU(e, t, n) {
+        if (this._pulse || t) this._postrun.push({
+            priority: n || 0,
+            callback: e
+        });
+        else try {
+            e(this)
+        } catch (i) {
+            this.error(i)
         }
     }
-    const fj = TO(sm);
-    var hj = TO(zt);
 
-    function MO(e) {
-        return function t(n) {
-            n = +n;
+    function SR(e) {
+        return e.error("Dataflow already running. Use runAsync() to chain invocations."), e
+    }
 
-            function i(r, s) {
-                var a = e((r = ib(r)).h, (s = ib(s)).h),
-                    o = zt(r.s, s.s),
-                    l = zt(r.l, s.l),
-                    u = zt(r.opacity, s.opacity);
-                return function(c) {
-                    return r.h = a(c), r.s = o(c), r.l = l(Math.pow(c, n)), r.opacity = u(c), r + ""
-                }
-            }
-            return i.gamma = t, i
-        }(1)
+    function DU(e, t) {
+        const n = e.stamp < this._clock;
+        n && (e.stamp = this._clock), (n || t) && (e.qrank = e.rank, this._heap.push(e))
     }
-    const dj = MO(sm);
-    var gj = MO(zt);
 
-    function Cx(e, t) {
-        t === void 0 && (t = e, e = Ka);
-        for (var n = 0, i = t.length - 1, r = t[0], s = new Array(i < 0 ? 0 : i); n < i;) s[n] = e(r, r = t[++n]);
-        return function(a) {
-            var o = Math.max(0, Math.min(i - 1, Math.floor(a *= i)));
-            return s[o](a - o)
-        }
+    function NU(e, t) {
+        const n = e.source,
+            i = this._clock;
+        return n && H(n) ? new L_(this, i, n.map(r => r.pulse), t) : this._input[e.id] || PU(this._pulse, n && n.pulse)
     }
 
-    function pj(e, t) {
-        for (var n = new Array(t), i = 0; i < t; ++i) n[i] = e(i / (t - 1));
-        return n
+    function PU(e, t) {
+        return t && t.stamp === e.stamp ? t : (e = e.fork(), t && t !== um && (e.source = t.source), e)
     }
-    const mj = Object.freeze(Object.defineProperty({
-        __proto__: null,
-        interpolate: Ka,
-        interpolateArray: VB,
-        interpolateBasis: yO,
-        interpolateBasisClosed: vO,
-        interpolateCubehelix: dj,
-        interpolateCubehelixLong: gj,
-        interpolateDate: SO,
-        interpolateDiscrete: QB,
-        interpolateHcl: fj,
-        interpolateHclLong: hj,
-        interpolateHsl: lj,
-        interpolateHslLong: uj,
-        interpolateHue: ZB,
-        interpolateLab: cj,
-        interpolateNumber: Xi,
-        interpolateNumberArray: Ex,
-        interpolateObject: EO,
-        interpolateRgb: rb,
-        interpolateRgbBasis: YB,
-        interpolateRgbBasisClosed: XB,
-        interpolateRound: Jh,
-        interpolateString: CO,
-        interpolateTransformCss: nj,
-        interpolateTransformSvg: ij,
-        interpolateZoom: oj,
-        piecewise: Cx,
-        quantize: pj
-    }, Symbol.toStringTag, {
-        value: "Module"
-    }));
+    const I_ = {
+        skip: !1,
+        force: !1
+    };
 
-    function Ts(e, t) {
-        return e == null || t == null ? NaN : e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN
+    function LU(e, t) {
+        const n = t || I_;
+        return this._pulse ? this._enqueue(e) : this._touched.add(e), n.skip && e.skip(!0), this
     }
 
-    function yj(e, t) {
-        return e == null || t == null ? NaN : t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN
+    function IU(e, t, n) {
+        const i = n || I_;
+        return (e.set(t) || i.force) && this.touch(e, i), this
     }
 
-    function Qh(e) {
-        let t, n, i;
-        e.length !== 2 ? (t = Ts, n = (o, l) => Ts(e(o), l), i = (o, l) => e(o) - l) : (t = e === Ts || e === yj ? e : vj, n = e, i = e);
+    function zU(e, t, n) {
+        this.touch(e, n || I_);
+        const i = new qa(this, this._clock + (this._pulse ? 0 : 1)),
+            r = e.pulse && e.pulse.source || [];
+        return i.target = e, this._input[e.id] = t.pulse(i, r), this
+    }
 
-        function r(o, l, u = 0, c = o.length) {
-            if (u < c) {
-                if (t(l, l) !== 0) return c;
-                do {
-                    const f = u + c >>> 1;
-                    n(o[f], l) < 0 ? u = f + 1 : c = f
-                } while (u < c)
+    function BU(e) {
+        let t = [];
+        return {
+            clear: () => t = [],
+            size: () => t.length,
+            peek: () => t[0],
+            push: n => (t.push(n), ER(t, 0, t.length - 1, e)),
+            pop: () => {
+                const n = t.pop();
+                let i;
+                return t.length ? (i = t[0], t[0] = n, jU(t, 0, e)) : i = n, i
             }
-            return u
         }
+    }
 
-        function s(o, l, u = 0, c = o.length) {
-            if (u < c) {
-                if (t(l, l) !== 0) return c;
-                do {
-                    const f = u + c >>> 1;
-                    n(o[f], l) <= 0 ? u = f + 1 : c = f
-                } while (u < c)
+    function ER(e, t, n, i) {
+        let r, s;
+        const a = e[n];
+        for (; n > t;) {
+            if (s = n - 1 >> 1, r = e[s], i(a, r) < 0) {
+                e[n] = r, n = s;
+                continue
             }
-            return u
+            break
         }
+        return e[n] = a
+    }
 
-        function a(o, l, u = 0, c = o.length) {
-            const f = r(o, l, u, c - 1);
-            return f > u && i(o[f - 1], l) > -i(o[f], l) ? f - 1 : f
-        }
-        return {
-            left: r,
-            center: a,
-            right: s
+    function jU(e, t, n) {
+        const i = t,
+            r = e.length,
+            s = e[t];
+        let a = (t << 1) + 1,
+            o;
+        for (; a < r;) o = a + 1, o < r && n(e[a], e[o]) >= 0 && (a = o), e[t] = e[a], t = a, a = (t << 1) + 1;
+        return e[t] = s, ER(e, i, t, n)
+    }
+
+    function Wu() {
+        this.logger(g_()), this.logLevel(h_), this._clock = 0, this._rank = 0, this._locale = F_();
+        try {
+            this._loader = H0()
+        } catch {}
+        this._touched = Y0(kd), this._input = {}, this._pulse = null, this._heap = BU((e, t) => e.qrank - t.qrank), this._postrun = []
+    }
+
+    function Ef(e) {
+        return function() {
+            return this._log[e].apply(this, arguments)
         }
     }
+    Wu.prototype = {
+        stamp() {
+            return this._clock
+        },
+        loader(e) {
+            return arguments.length ? (this._loader = e, this) : this._loader
+        },
+        locale(e) {
+            return arguments.length ? (this._locale = e, this) : this._locale
+        },
+        logger(e) {
+            return arguments.length ? (this._log = e, this) : this._log
+        },
+        error: Ef("error"),
+        warn: Ef("warn"),
+        info: Ef("info"),
+        debug: Ef("debug"),
+        logLevel: Ef("level"),
+        cleanThreshold: 1e4,
+        add: dU,
+        connect: gU,
+        rank: AU,
+        rerank: $U,
+        pulse: zU,
+        touch: LU,
+        update: IU,
+        changeset: Xl,
+        ingest: vU,
+        parse: yU,
+        preload: xU,
+        request: bU,
+        events: mU,
+        on: SU,
+        evaluate: MU,
+        run: FU,
+        runAsync: OU,
+        runAfter: RU,
+        _enqueue: DU,
+        _getPulse: NU
+    };
+
+    function j(e, t) {
+        dt.call(this, e, null, t)
+    }
+    ne(j, dt, {
+        run(e) {
+            if (e.stamp < this.stamp) return e.StopPropagation;
+            let t;
+            return this.skip() ? this.skip(!1) : t = this.evaluate(e), t = t || e, t.then ? t = t.then(n => this.pulse = n) : t !== e.StopPropagation && (this.pulse = t), t
+        },
+        evaluate(e) {
+            const t = this.marshall(e.stamp),
+                n = this.transform(t, e);
+            return t.clear(), n
+        },
+        transform() {}
+    });
+    const lc = {};
 
-    function vj() {
-        return 0
+    function kR(e) {
+        const t = CR(e);
+        return t && t.Definition || null
     }
 
-    function OO(e) {
-        return e === null ? NaN : +e
+    function CR(e) {
+        return e = e && e.toLowerCase(), Ce(lc, e) ? lc[e] : null
     }
 
-    function* bj(e, t) {
-        if (t === void 0)
-            for (let n of e) n != null && (n = +n) >= n && (yield n);
+    function* AR(e, t) {
+        if (t == null)
+            for (let n of e) n != null && n !== "" && (n = +n) >= n && (yield n);
         else {
             let n = -1;
-            for (let i of e)(i = t(i, ++n, e)) != null && (i = +i) >= i && (yield i)
+            for (let i of e) i = t(i, ++n, e), i != null && i !== "" && (i = +i) >= i && (yield i)
         }
     }
-    const FO = Qh(Ts),
-        wp = FO.right,
-        xj = FO.left;
-    Qh(OO).center;
-    const Zh = wp;
 
-    function _j(e, t) {
-        let n = 0,
-            i, r = 0,
-            s = 0;
-        if (t === void 0)
-            for (let a of e) a != null && (a = +a) >= a && (i = a - r, r += i / ++n, s += i * (a - r));
-        else {
-            let a = -1;
-            for (let o of e)(o = t(o, ++a, e)) != null && (o = +o) >= o && (i = o - r, r += i / ++n, s += i * (o - r))
-        }
-        if (n > 1) return s / (n - 1)
+    function z_(e, t, n) {
+        const i = Float64Array.from(AR(e, n));
+        return i.sort(Hs), t.map(r => SF(i, r))
     }
 
-    function wj(e, t) {
-        const n = _j(e, t);
-        return n && Math.sqrt(n)
+    function B_(e, t) {
+        return z_(e, [.25, .5, .75], t)
     }
-    class Rn {
-        constructor() {
-            this._partials = new Float64Array(32), this._n = 0
-        }
-        add(t) {
-            const n = this._partials;
-            let i = 0;
-            for (let r = 0; r < this._n && r < 32; r++) {
-                const s = n[r],
-                    a = t + s,
-                    o = Math.abs(t) < Math.abs(s) ? t - (a - s) : s - (a - t);
-                o && (n[i++] = o), t = a
-            }
-            return n[i] = t, this._n = i + 1, this
-        }
-        valueOf() {
-            const t = this._partials;
-            let n = this._n,
-                i, r, s, a = 0;
-            if (n > 0) {
-                for (a = t[--n]; n > 0 && (i = a, r = t[--n], a = i + r, s = r - (a - i), !s););
-                n > 0 && (s < 0 && t[n - 1] < 0 || s > 0 && t[n - 1] > 0) && (r = s * 2, i = a + r, r == i - a && (a = i))
-            }
-            return a
-        }
+
+    function j_(e, t) {
+        const n = e.length,
+            i = ZB(e, t),
+            r = B_(e, t),
+            s = (r[2] - r[0]) / 1.34;
+        return 1.06 * (Math.min(i, s) || i || Math.abs(r[0]) || 1) * Math.pow(n, -.2)
     }
-    class Lk extends Map {
-        constructor(t, n = NO) {
-            if (super(), Object.defineProperties(this, {
-                    _intern: {
-                        value: new Map
-                    },
-                    _key: {
-                        value: n
-                    }
-                }), t != null)
-                for (const [i, r] of t) this.set(i, r)
-        }
-        get(t) {
-            return super.get(ob(this, t))
-        }
-        has(t) {
-            return super.has(ob(this, t))
-        }
-        set(t, n) {
-            return super.set(RO(this, t), n)
+
+    function $R(e) {
+        const t = e.maxbins || 20,
+            n = e.base || 10,
+            i = Math.log(n),
+            r = e.divide || [5, 2];
+        let s = e.extent[0],
+            a = e.extent[1],
+            o, l, u, c, f, h;
+        const d = e.span || a - s || Math.abs(s) || 1;
+        if (e.step) o = e.step;
+        else if (e.steps) {
+            for (c = d / t, f = 0, h = e.steps.length; f < h && e.steps[f] < c; ++f);
+            o = e.steps[Math.max(0, f - 1)]
+        } else {
+            for (l = Math.ceil(Math.log(t) / i), u = e.minstep || 0, o = Math.max(u, Math.pow(n, Math.round(Math.log(d) / i) - l)); Math.ceil(d / o) > t;) o *= n;
+            for (f = 0, h = r.length; f < h; ++f) c = o / r[f], c >= u && d / c <= t && (o = c)
         }
-        delete(t) {
-            return super.delete(DO(this, t))
+        c = Math.log(o);
+        const g = c >= 0 ? 0 : ~~(-c / i) + 1,
+            p = Math.pow(n, -g - 1);
+        return (e.nice || e.nice === void 0) && (c = Math.floor(s / o + p) * o, s = s < c ? c - o : c, a = Math.ceil(a / o) * o), {
+            start: s,
+            stop: a === s ? s + o : a,
+            step: o
         }
     }
-    class Sp extends Set {
-        constructor(t, n = NO) {
-            if (super(), Object.defineProperties(this, {
-                    _intern: {
-                        value: new Map
-                    },
-                    _key: {
-                        value: n
-                    }
-                }), t != null)
-                for (const i of t) this.add(i)
-        }
-        has(t) {
-            return super.has(ob(this, t))
-        }
-        add(t) {
-            return super.add(RO(this, t))
-        }
-        delete(t) {
-            return super.delete(DO(this, t))
-        }
+    var Vi = Math.random;
+
+    function GU(e) {
+        Vi = e
     }
 
-    function ob({
-        _intern: e,
-        _key: t
-    }, n) {
-        const i = t(n);
-        return e.has(i) ? e.get(i) : n
+    function TR(e, t, n, i) {
+        if (!e.length) return [void 0, void 0];
+        const r = Float64Array.from(AR(e, i)),
+            s = r.length,
+            a = t;
+        let o, l, u, c;
+        for (u = 0, c = Array(a); u < a; ++u) {
+            for (o = 0, l = 0; l < s; ++l) o += r[~~(Vi() * s)];
+            c[u] = o / s
+        }
+        return c.sort(Hs), [Ub(c, n / 2), Ub(c, 1 - n / 2)]
     }
 
-    function RO({
-        _intern: e,
-        _key: t
-    }, n) {
-        const i = t(n);
-        return e.has(i) ? e.get(i) : (e.set(i, n), n)
+    function MR(e, t, n, i) {
+        i = i || (h => h);
+        const r = e.length,
+            s = new Float64Array(r);
+        let a = 0,
+            o = 1,
+            l = i(e[0]),
+            u = l,
+            c = l + t,
+            f;
+        for (; o < r; ++o) {
+            if (f = i(e[o]), f >= c) {
+                for (u = (l + u) / 2; a < o; ++a) s[a] = u;
+                c = f + t, l = f
+            }
+            u = f
+        }
+        for (u = (l + u) / 2; a < o; ++a) s[a] = u;
+        return n ? UU(s, t + t / 4) : s
     }
 
-    function DO({
-        _intern: e,
-        _key: t
-    }, n) {
-        const i = t(n);
-        return e.has(i) && (n = e.get(i), e.delete(i)), n
+    function UU(e, t) {
+        const n = e.length;
+        let i = 0,
+            r = 1,
+            s, a;
+        for (; e[i] === e[r];) ++r;
+        for (; r < n;) {
+            for (s = r + 1; e[r] === e[s];) ++s;
+            if (e[r] - e[r - 1] < t) {
+                for (a = r + (i + s - r - r >> 1); a < r;) e[a++] = e[r];
+                for (; a > r;) e[a--] = e[i]
+            }
+            i = r, r = s
+        }
+        return e
     }
 
-    function NO(e) {
-        return e !== null && typeof e == "object" ? e.valueOf() : e
+    function WU(e) {
+        return function() {
+            return e = (1103515245 * e + 12345) % 2147483647, e / 2147483647
+        }
     }
 
-    function Sj(e, t) {
-        return Array.from(t, n => e[n])
+    function qU(e, t) {
+        t == null && (t = e, e = 0);
+        let n, i, r;
+        const s = {
+            min(a) {
+                return arguments.length ? (n = a || 0, r = i - n, s) : n
+            },
+            max(a) {
+                return arguments.length ? (i = a || 0, r = i - n, s) : i
+            },
+            sample() {
+                return n + Math.floor(r * Vi())
+            },
+            pdf(a) {
+                return a === Math.floor(a) && a >= n && a < i ? 1 / r : 0
+            },
+            cdf(a) {
+                const o = Math.floor(a);
+                return o < n ? 0 : o >= i ? 1 : (o - n + 1) / r
+            },
+            icdf(a) {
+                return a >= 0 && a <= 1 ? n - 1 + Math.floor(a * r) : NaN
+            }
+        };
+        return s.min(e).max(t)
     }
+    const OR = Math.sqrt(2 * Math.PI),
+        HU = Math.SQRT2;
+    let kf = NaN;
 
-    function Ej(e = Ts) {
-        if (e === Ts) return PO;
-        if (typeof e != "function") throw new TypeError("compare is not a function");
-        return (t, n) => {
-            const i = e(t, n);
-            return i || i === 0 ? i : (e(n, n) === 0) - (e(t, t) === 0)
+    function Q0(e, t) {
+        e = e || 0, t = t ?? 1;
+        let n = 0,
+            i = 0,
+            r, s;
+        if (kf === kf) n = kf, kf = NaN;
+        else {
+            do n = Vi() * 2 - 1, i = Vi() * 2 - 1, r = n * n + i * i; while (r === 0 || r > 1);
+            s = Math.sqrt(-2 * Math.log(r) / r), n *= s, kf = i * s
         }
+        return e + n * t
     }
 
-    function PO(e, t) {
-        return (e == null || !(e >= e)) - (t == null || !(t >= t)) || (e < t ? -1 : e > t ? 1 : 0)
+    function G_(e, t, n) {
+        n = n ?? 1;
+        const i = (e - (t || 0)) / n;
+        return Math.exp(-.5 * i * i) / (n * OR)
     }
-    const Cj = Math.sqrt(50),
-        kj = Math.sqrt(10),
-        Aj = Math.sqrt(2);
 
-    function Ep(e, t, n) {
-        const i = (t - e) / Math.max(0, n),
-            r = Math.floor(Math.log10(i)),
-            s = i / Math.pow(10, r),
-            a = s >= Cj ? 10 : s >= kj ? 5 : s >= Aj ? 2 : 1;
-        let o, l, u;
-        return r < 0 ? (u = Math.pow(10, -r) / a, o = Math.round(e * u), l = Math.round(t * u), o / u < e && ++o, l / u > t && --l, u = -u) : (u = Math.pow(10, r) * a, o = Math.round(e / u), l = Math.round(t / u), o * u < e && ++o, l * u > t && --l), l < o && .5 <= n && n < 2 ? Ep(e, t, n * 2) : [o, l, u]
+    function Z0(e, t, n) {
+        t = t || 0, n = n ?? 1;
+        const i = (e - t) / n,
+            r = Math.abs(i);
+        let s;
+        if (r > 37) s = 0;
+        else {
+            const a = Math.exp(-r * r / 2);
+            let o;
+            r < 7.07106781186547 ? (o = .0352624965998911 * r + .700383064443688, o = o * r + 6.37396220353165, o = o * r + 33.912866078383, o = o * r + 112.079291497871, o = o * r + 221.213596169931, o = o * r + 220.206867912376, s = a * o, o = .0883883476483184 * r + 1.75566716318264, o = o * r + 16.064177579207, o = o * r + 86.7807322029461, o = o * r + 296.564248779674, o = o * r + 637.333633378831, o = o * r + 793.826512519948, o = o * r + 440.413735824752, s = s / o) : (o = r + .65, o = r + 4 / o, o = r + 3 / o, o = r + 2 / o, o = r + 1 / o, s = a / o / 2.506628274631)
+        }
+        return i > 0 ? 1 - s : s
     }
 
-    function lb(e, t, n) {
-        if (t = +t, e = +e, n = +n, !(n > 0)) return [];
-        if (e === t) return [e];
-        const i = t < e,
-            [r, s, a] = i ? Ep(t, e, n) : Ep(e, t, n);
-        if (!(s >= r)) return [];
-        const o = s - r + 1,
-            l = new Array(o);
-        if (i)
-            if (a < 0)
-                for (let u = 0; u < o; ++u) l[u] = (s - u) / -a;
-            else
-                for (let u = 0; u < o; ++u) l[u] = (s - u) * a;
-        else if (a < 0)
-            for (let u = 0; u < o; ++u) l[u] = (r + u) / -a;
-        else
-            for (let u = 0; u < o; ++u) l[u] = (r + u) * a;
-        return l
+    function e1(e, t, n) {
+        return e < 0 || e > 1 ? NaN : (t || 0) + (n ?? 1) * HU * YU(2 * e - 1)
     }
 
-    function ub(e, t, n) {
-        return t = +t, e = +e, n = +n, Ep(e, t, n)[2]
+    function YU(e) {
+        let t = -Math.log((1 - e) * (1 + e)),
+            n;
+        return t < 6.25 ? (t -= 3.125, n = -364441206401782e-35, n = -16850591381820166e-35 + n * t, n = 128584807152564e-32 + n * t, n = 11157877678025181e-33 + n * t, n = -1333171662854621e-31 + n * t, n = 20972767875968562e-33 + n * t, n = 6637638134358324e-30 + n * t, n = -4054566272975207e-29 + n * t, n = -8151934197605472e-29 + n * t, n = 26335093153082323e-28 + n * t, n = -12975133253453532e-27 + n * t, n = -5415412054294628e-26 + n * t, n = 10512122733215323e-25 + n * t, n = -4112633980346984e-24 + n * t, n = -29070369957882005e-24 + n * t, n = 42347877827932404e-23 + n * t, n = -13654692000834679e-22 + n * t, n = -13882523362786469e-21 + n * t, n = .00018673420803405714 + n * t, n = -.000740702534166267 + n * t, n = -.006033670871430149 + n * t, n = .24015818242558962 + n * t, n = 1.6536545626831027 + n * t) : t < 16 ? (t = Math.sqrt(t) - 3.25, n = 22137376921775787e-25, n = 9075656193888539e-23 + n * t, n = -27517406297064545e-23 + n * t, n = 18239629214389228e-24 + n * t, n = 15027403968909828e-22 + n * t, n = -4013867526981546e-21 + n * t, n = 29234449089955446e-22 + n * t, n = 12475304481671779e-21 + n * t, n = -47318229009055734e-21 + n * t, n = 6828485145957318e-20 + n * t, n = 24031110387097894e-21 + n * t, n = -.0003550375203628475 + n * t, n = .0009532893797373805 + n * t, n = -.0016882755560235047 + n * t, n = .002491442096107851 + n * t, n = -.003751208507569241 + n * t, n = .005370914553590064 + n * t, n = 1.0052589676941592 + n * t, n = 3.0838856104922208 + n * t) : Number.isFinite(t) ? (t = Math.sqrt(t) - 5, n = -27109920616438573e-27, n = -2555641816996525e-25 + n * t, n = 15076572693500548e-25 + n * t, n = -3789465440126737e-24 + n * t, n = 761570120807834e-23 + n * t, n = -1496002662714924e-23 + n * t, n = 2914795345090108e-23 + n * t, n = -6771199775845234e-23 + n * t, n = 22900482228026655e-23 + n * t, n = -99298272942317e-20 + n * t, n = 4526062597223154e-21 + n * t, n = -1968177810553167e-20 + n * t, n = 7599527703001776e-20 + n * t, n = -.00021503011930044477 + n * t, n = -.00013871931833623122 + n * t, n = 1.0103004648645344 + n * t, n = 4.849906401408584 + n * t) : n = 1 / 0, n * e
     }
 
-    function Oa(e, t, n) {
-        t = +t, e = +e, n = +n;
-        const i = t < e,
-            r = i ? ub(t, e, n) : ub(e, t, n);
-        return (i ? -1 : 1) * (r < 0 ? 1 / -r : r)
+    function U_(e, t) {
+        let n, i;
+        const r = {
+            mean(s) {
+                return arguments.length ? (n = s || 0, r) : n
+            },
+            stdev(s) {
+                return arguments.length ? (i = s ?? 1, r) : i
+            },
+            sample: () => Q0(n, i),
+            pdf: s => G_(s, n, i),
+            cdf: s => Z0(s, n, i),
+            icdf: s => e1(s, n, i)
+        };
+        return r.mean(e).stdev(t)
     }
 
-    function jo(e, t) {
-        let n;
-        if (t === void 0)
-            for (const i of e) i != null && (n < i || n === void 0 && i >= i) && (n = i);
-        else {
-            let i = -1;
-            for (let r of e)(r = t(r, ++i, e)) != null && (n < r || n === void 0 && r >= r) && (n = r)
-        }
-        return n
+    function W_(e, t) {
+        const n = U_();
+        let i = 0;
+        const r = {
+            data(s) {
+                return arguments.length ? (e = s, i = s ? s.length : 0, r.bandwidth(t)) : e
+            },
+            bandwidth(s) {
+                return arguments.length ? (t = s, !t && e && (t = j_(e)), r) : t
+            },
+            sample() {
+                return e[~~(Vi() * i)] + t * n.sample()
+            },
+            pdf(s) {
+                let a = 0,
+                    o = 0;
+                for (; o < i; ++o) a += n.pdf((s - e[o]) / t);
+                return a / t / i
+            },
+            cdf(s) {
+                let a = 0,
+                    o = 0;
+                for (; o < i; ++o) a += n.cdf((s - e[o]) / t);
+                return a / i
+            },
+            icdf() {
+                throw Error("KDE icdf not supported.")
+            }
+        };
+        return r.data(e)
     }
 
-    function cb(e, t) {
-        let n;
-        if (t === void 0)
-            for (const i of e) i != null && (n > i || n === void 0 && i >= i) && (n = i);
-        else {
-            let i = -1;
-            for (let r of e)(r = t(r, ++i, e)) != null && (n > r || n === void 0 && r >= r) && (n = r)
-        }
-        return n
+    function q_(e, t) {
+        return e = e || 0, t = t ?? 1, Math.exp(e + Q0() * t)
     }
 
-    function LO(e, t, n = 0, i = 1 / 0, r) {
-        if (t = Math.floor(t), n = Math.floor(Math.max(0, n)), i = Math.floor(Math.min(e.length - 1, i)), !(n <= t && t <= i)) return e;
-        for (r = r === void 0 ? PO : Ej(r); i > n;) {
-            if (i - n > 600) {
-                const l = i - n + 1,
-                    u = t - n + 1,
-                    c = Math.log(l),
-                    f = .5 * Math.exp(2 * c / 3),
-                    h = .5 * Math.sqrt(c * f * (l - f) / l) * (u - l / 2 < 0 ? -1 : 1),
-                    d = Math.max(n, Math.floor(t - u * f / l + h)),
-                    g = Math.min(i, Math.floor(t + (l - u) * f / l + h));
-                LO(e, t, d, g, r)
-            }
-            const s = e[t];
-            let a = n,
-                o = i;
-            for (Wc(e, n, t), r(e[i], s) > 0 && Wc(e, n, i); a < o;) {
-                for (Wc(e, a, o), ++a, --o; r(e[a], s) < 0;) ++a;
-                for (; r(e[o], s) > 0;) --o
-            }
-            r(e[n], s) === 0 ? Wc(e, n, o) : (++o, Wc(e, o, i)), o <= t && (n = o + 1), t <= o && (i = o - 1)
-        }
-        return e
+    function H_(e, t, n) {
+        if (e <= 0) return 0;
+        t = t || 0, n = n ?? 1;
+        const i = (Math.log(e) - t) / n;
+        return Math.exp(-.5 * i * i) / (n * OR * e)
     }
 
-    function Wc(e, t, n) {
-        const i = e[t];
-        e[t] = e[n], e[n] = i
+    function Y_(e, t, n) {
+        return Z0(Math.log(e), t, n)
     }
 
-    function fb(e, t, n) {
-        if (e = Float64Array.from(bj(e, n)), !(!(i = e.length) || isNaN(t = +t))) {
-            if (t <= 0 || i < 2) return cb(e);
-            if (t >= 1) return jo(e);
-            var i, r = (i - 1) * t,
-                s = Math.floor(r),
-                a = jo(LO(e, s).subarray(0, s + 1)),
-                o = cb(e.subarray(s + 1));
-            return a + (o - a) * (r - s)
-        }
+    function X_(e, t, n) {
+        return Math.exp(e1(e, t, n))
     }
 
-    function IO(e, t, n = OO) {
-        if (!(!(i = e.length) || isNaN(t = +t))) {
-            if (t <= 0 || i < 2) return +n(e[0], 0, e);
-            if (t >= 1) return +n(e[i - 1], i - 1, e);
-            var i, r = (i - 1) * t,
-                s = Math.floor(r),
-                a = +n(e[s], s, e),
-                o = +n(e[s + 1], s + 1, e);
-            return a + (o - a) * (r - s)
-        }
+    function FR(e, t) {
+        let n, i;
+        const r = {
+            mean(s) {
+                return arguments.length ? (n = s || 0, r) : n
+            },
+            stdev(s) {
+                return arguments.length ? (i = s ?? 1, r) : i
+            },
+            sample: () => q_(n, i),
+            pdf: s => H_(s, n, i),
+            cdf: s => Y_(s, n, i),
+            icdf: s => X_(s, n, i)
+        };
+        return r.mean(e).stdev(t)
     }
 
-    function $j(e, t) {
+    function RR(e, t) {
         let n = 0,
-            i = 0;
-        if (t === void 0)
-            for (let r of e) r != null && (r = +r) >= r && (++n, i += r);
-        else {
-            let r = -1;
-            for (let s of e)(s = t(s, ++r, e)) != null && (s = +s) >= s && (++n, i += s)
+            i;
+
+        function r(a) {
+            const o = [];
+            let l = 0,
+                u;
+            for (u = 0; u < n; ++u) l += o[u] = a[u] == null ? 1 : +a[u];
+            for (u = 0; u < n; ++u) o[u] /= l;
+            return o
         }
-        if (n) return i / n
+        const s = {
+            weights(a) {
+                return arguments.length ? (i = r(t = a || []), s) : t
+            },
+            distributions(a) {
+                return arguments.length ? (a ? (n = a.length, e = a) : (n = 0, e = []), s.weights(t)) : e
+            },
+            sample() {
+                const a = Vi();
+                let o = e[n - 1],
+                    l = i[0],
+                    u = 0;
+                for (; u < n - 1; l += i[++u])
+                    if (a < l) {
+                        o = e[u];
+                        break
+                    } return o.sample()
+            },
+            pdf(a) {
+                let o = 0,
+                    l = 0;
+                for (; l < n; ++l) o += i[l] * e[l].pdf(a);
+                return o
+            },
+            cdf(a) {
+                let o = 0,
+                    l = 0;
+                for (; l < n; ++l) o += i[l] * e[l].cdf(a);
+                return o
+            },
+            icdf() {
+                throw Error("Mixture icdf not supported.")
+            }
+        };
+        return s.distributions(e).weights(t)
     }
 
-    function zO(e, t) {
-        return fb(e, .5, t)
+    function V_(e, t) {
+        return t == null && (t = e ?? 1, e = 0), e + (t - e) * Vi()
     }
 
-    function* Tj(e) {
-        for (const t of e) yield* t
+    function K_(e, t, n) {
+        return n == null && (n = t ?? 1, t = 0), e >= t && e <= n ? 1 / (n - t) : 0
     }
 
-    function BO(e) {
-        return Array.from(Tj(e))
+    function J_(e, t, n) {
+        return n == null && (n = t ?? 1, t = 0), e < t ? 0 : e > n ? 1 : (e - t) / (n - t)
     }
 
-    function gi(e, t, n) {
-        e = +e, t = +t, n = (r = arguments.length) < 2 ? (t = e, e = 0, 1) : r < 3 ? 1 : +n;
-        for (var i = -1, r = Math.max(0, Math.ceil((t - e) / n)) | 0, s = new Array(r); ++i < r;) s[i] = e + i * n;
-        return s
+    function Q_(e, t, n) {
+        return n == null && (n = t ?? 1, t = 0), e >= 0 && e <= 1 ? t + e * (n - t) : NaN
     }
 
-    function jO(e, t) {
-        let n = 0;
-        if (t === void 0)
-            for (let i of e)(i = +i) && (n += i);
-        else {
-            let i = -1;
-            for (let r of e)(r = +t(r, ++i, e)) && (n += r)
-        }
-        return n
+    function DR(e, t) {
+        let n, i;
+        const r = {
+            min(s) {
+                return arguments.length ? (n = s || 0, r) : n
+            },
+            max(s) {
+                return arguments.length ? (i = s ?? 1, r) : i
+            },
+            sample: () => V_(n, i),
+            pdf: s => K_(s, n, i),
+            cdf: s => J_(s, n, i),
+            icdf: s => Q_(s, n, i)
+        };
+        return t == null && (t = e ?? 1, e = 0), r.min(e).max(t)
     }
-    var Mj = {
-        value: () => {}
-    };
 
-    function UO() {
-        for (var e = 0, t = arguments.length, n = {}, i; e < t; ++e) {
-            if (!(i = arguments[e] + "") || i in n || /[\s.]/.test(i)) throw new Error("illegal type: " + i);
-            n[i] = []
+    function Z_(e, t, n) {
+        let i = 0,
+            r = 0;
+        for (const s of e) {
+            const a = n(s);
+            t(s) == null || a == null || isNaN(a) || (i += (a - i) / ++r)
+        }
+        return {
+            coef: [i],
+            predict: () => i,
+            rSquared: 0
         }
-        return new qg(n)
     }
 
-    function qg(e) {
-        this._ = e
+    function Td(e, t, n, i) {
+        const r = i - e * e,
+            s = Math.abs(r) < 1e-24 ? 0 : (n - e * t) / r;
+        return [t - s * e, s]
     }
 
-    function Oj(e, t) {
-        return e.trim().split(/^|\s+/).map(function(n) {
-            var i = "",
-                r = n.indexOf(".");
-            if (r >= 0 && (i = n.slice(r + 1), n = n.slice(0, r)), n && !t.hasOwnProperty(n)) throw new Error("unknown type: " + n);
-            return {
-                type: n,
-                name: i
-            }
-        })
+    function t1(e, t, n, i) {
+        e = e.filter(d => {
+            let g = t(d),
+                p = n(d);
+            return g != null && (g = +g) >= g && p != null && (p = +p) >= p
+        }), i && e.sort((d, g) => t(d) - t(g));
+        const r = e.length,
+            s = new Float64Array(r),
+            a = new Float64Array(r);
+        let o = 0,
+            l = 0,
+            u = 0,
+            c, f, h;
+        for (h of e) s[o] = c = +t(h), a[o] = f = +n(h), ++o, l += (c - l) / o, u += (f - u) / o;
+        for (o = 0; o < r; ++o) s[o] -= l, a[o] -= u;
+        return [s, a, l, u]
     }
-    qg.prototype = UO.prototype = {
-        constructor: qg,
-        on: function(e, t) {
-            var n = this._,
-                i = Oj(e + "", n),
-                r, s = -1,
-                a = i.length;
-            if (arguments.length < 2) {
-                for (; ++s < a;)
-                    if ((r = (e = i[s]).type) && (r = Fj(n[r], e.name))) return r;
-                return
-            }
-            if (t != null && typeof t != "function") throw new Error("invalid callback: " + t);
-            for (; ++s < a;)
-                if (r = (e = i[s]).type) n[r] = Ik(n[r], e.name, t);
-                else if (t == null)
-                for (r in n) n[r] = Ik(n[r], e.name, null);
-            return this
-        },
-        copy: function() {
-            var e = {},
-                t = this._;
-            for (var n in t) e[n] = t[n].slice();
-            return new qg(e)
-        },
-        call: function(e, t) {
-            if ((r = arguments.length - 2) > 0)
-                for (var n = new Array(r), i = 0, r, s; i < r; ++i) n[i] = arguments[i + 2];
-            if (!this._.hasOwnProperty(e)) throw new Error("unknown type: " + e);
-            for (s = this._[e], i = 0, r = s.length; i < r; ++i) s[i].value.apply(t, n)
-        },
-        apply: function(e, t, n) {
-            if (!this._.hasOwnProperty(e)) throw new Error("unknown type: " + e);
-            for (var i = this._[e], r = 0, s = i.length; r < s; ++r) i[r].value.apply(t, n)
-        }
-    };
 
-    function Fj(e, t) {
-        for (var n = 0, i = e.length, r; n < i; ++n)
-            if ((r = e[n]).name === t) return r.value
+    function Md(e, t, n, i) {
+        let r = -1,
+            s, a;
+        for (const o of e) s = t(o), a = n(o), s != null && (s = +s) >= s && a != null && (a = +a) >= a && i(s, a, ++r)
     }
 
-    function Ik(e, t, n) {
-        for (var i = 0, r = e.length; i < r; ++i)
-            if (e[i].name === t) {
-                e[i] = Mj, e = e.slice(0, i).concat(e.slice(i + 1));
-                break
-            } return n != null && e.push({
-            name: t,
-            value: n
-        }), e
+    function Xc(e, t, n, i, r) {
+        let s = 0,
+            a = 0;
+        return Md(e, t, n, (o, l) => {
+            const u = l - r(o),
+                c = l - i;
+            s += u * u, a += c * c
+        }), 1 - s / a
     }
-    var Fu = 0,
-        wf = 0,
-        qc = 0,
-        GO = 1e3,
-        Cp, Sf, kp = 0,
-        Jo = 0,
-        am = 0,
-        yh = typeof performance == "object" && performance.now ? performance : Date,
-        WO = typeof window == "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(e) {
-            setTimeout(e, 17)
-        };
 
-    function kx() {
-        return Jo || (WO(Rj), Jo = yh.now() + am)
+    function ew(e, t, n) {
+        let i = 0,
+            r = 0,
+            s = 0,
+            a = 0,
+            o = 0;
+        Md(e, t, n, (c, f) => {
+            ++o, i += (c - i) / o, r += (f - r) / o, s += (c * f - s) / o, a += (c * c - a) / o
+        });
+        const l = Td(i, r, s, a),
+            u = c => l[0] + l[1] * c;
+        return {
+            coef: l,
+            predict: u,
+            rSquared: Xc(e, t, n, r, u)
+        }
     }
 
-    function Rj() {
-        Jo = 0
+    function NR(e, t, n) {
+        let i = 0,
+            r = 0,
+            s = 0,
+            a = 0,
+            o = 0;
+        Md(e, t, n, (c, f) => {
+            ++o, c = Math.log(c), i += (c - i) / o, r += (f - r) / o, s += (c * f - s) / o, a += (c * c - a) / o
+        });
+        const l = Td(i, r, s, a),
+            u = c => l[0] + l[1] * Math.log(c);
+        return {
+            coef: l,
+            predict: u,
+            rSquared: Xc(e, t, n, r, u)
+        }
     }
 
-    function Ap() {
-        this._call = this._time = this._next = null
-    }
-    Ap.prototype = qO.prototype = {
-        constructor: Ap,
-        restart: function(e, t, n) {
-            if (typeof e != "function") throw new TypeError("callback is not a function");
-            n = (n == null ? kx() : +n) + (t == null ? 0 : +t), !this._next && Sf !== this && (Sf ? Sf._next = this : Cp = this, Sf = this), this._call = e, this._time = n, hb()
-        },
-        stop: function() {
-            this._call && (this._call = null, this._time = 1 / 0, hb())
+    function PR(e, t, n) {
+        const [i, r, s, a] = t1(e, t, n);
+        let o = 0,
+            l = 0,
+            u = 0,
+            c = 0,
+            f = 0,
+            h, d, g;
+        Md(e, t, n, (v, b) => {
+            h = i[f++], d = Math.log(b), g = h * b, o += (b * d - o) / f, l += (g - l) / f, u += (g * d - u) / f, c += (h * g - c) / f
+        });
+        const [p, m] = Td(l / a, o / a, u / a, c / a), y = v => Math.exp(p + m * (v - s));
+        return {
+            coef: [Math.exp(p - m * s), m],
+            predict: y,
+            rSquared: Xc(e, t, n, a, y)
         }
-    };
+    }
 
-    function qO(e, t, n) {
-        var i = new Ap;
-        return i.restart(e, t, n), i
+    function LR(e, t, n) {
+        let i = 0,
+            r = 0,
+            s = 0,
+            a = 0,
+            o = 0,
+            l = 0;
+        Md(e, t, n, (f, h) => {
+            const d = Math.log(f),
+                g = Math.log(h);
+            ++l, i += (d - i) / l, r += (g - r) / l, s += (d * g - s) / l, a += (d * d - a) / l, o += (h - o) / l
+        });
+        const u = Td(i, r, s, a),
+            c = f => u[0] * Math.pow(f, u[1]);
+        return u[0] = Math.exp(u[0]), {
+            coef: u,
+            predict: c,
+            rSquared: Xc(e, t, n, o, c)
+        }
     }
 
-    function Dj() {
-        kx(), ++Fu;
-        for (var e = Cp, t; e;)(t = Jo - e._time) >= 0 && e._call.call(void 0, t), e = e._next;
-        --Fu
+    function tw(e, t, n) {
+        const [i, r, s, a] = t1(e, t, n), o = i.length;
+        let l = 0,
+            u = 0,
+            c = 0,
+            f = 0,
+            h = 0,
+            d, g, p, m;
+        for (d = 0; d < o;) g = i[d], p = r[d++], m = g * g, l += (m - l) / d, u += (m * g - u) / d, c += (m * m - c) / d, f += (g * p - f) / d, h += (m * p - h) / d;
+        const y = c - l * l,
+            v = l * y - u * u,
+            b = (h * l - f * u) / v,
+            x = (f * y - h * u) / v,
+            _ = -b * l,
+            S = w => (w = w - s, b * w * w + x * w + _ + a);
+        return {
+            coef: [_ - x * s + b * s * s + a, x - 2 * b * s, b],
+            predict: S,
+            rSquared: Xc(e, t, n, a, S)
+        }
     }
 
-    function zk() {
-        Jo = (kp = yh.now()) + am, Fu = wf = 0;
-        try {
-            Dj()
-        } finally {
-            Fu = 0, Pj(), Jo = 0
+    function IR(e, t, n, i) {
+        if (i === 0) return Z_(e, t, n);
+        if (i === 1) return ew(e, t, n);
+        if (i === 2) return tw(e, t, n);
+        const [r, s, a, o] = t1(e, t, n), l = r.length, u = [], c = [], f = i + 1;
+        let h, d, g, p, m;
+        for (h = 0; h < f; ++h) {
+            for (g = 0, p = 0; g < l; ++g) p += Math.pow(r[g], h) * s[g];
+            for (u.push(p), m = new Float64Array(f), d = 0; d < f; ++d) {
+                for (g = 0, p = 0; g < l; ++g) p += Math.pow(r[g], h + d);
+                m[d] = p
+            }
+            c.push(m)
+        }
+        c.push(u);
+        const y = VU(c),
+            v = b => {
+                b -= a;
+                let x = o + y[0] + y[1] * b + y[2] * b * b;
+                for (h = 3; h < f; ++h) x += y[h] * Math.pow(b, h);
+                return x
+            };
+        return {
+            coef: XU(f, y, -a, o),
+            predict: v,
+            rSquared: Xc(e, t, n, o, v)
         }
     }
 
-    function Nj() {
-        var e = yh.now(),
-            t = e - kp;
-        t > GO && (am -= t, kp = e)
+    function XU(e, t, n, i) {
+        const r = Array(e);
+        let s, a, o, l;
+        for (s = 0; s < e; ++s) r[s] = 0;
+        for (s = e - 1; s >= 0; --s)
+            for (o = t[s], l = 1, r[s] += o, a = 1; a <= s; ++a) l *= (s + 1 - a) / a, r[s - a] += o * Math.pow(n, a) * l;
+        return r[0] += i, r
     }
 
-    function Pj() {
-        for (var e, t = Cp, n, i = 1 / 0; t;) t._call ? (i > t._time && (i = t._time), e = t, t = t._next) : (n = t._next, t._next = null, t = e ? e._next = n : Cp = n);
-        Sf = e, hb(i)
+    function VU(e) {
+        const t = e.length - 1,
+            n = [];
+        let i, r, s, a, o;
+        for (i = 0; i < t; ++i) {
+            for (a = i, r = i + 1; r < t; ++r) Math.abs(e[i][r]) > Math.abs(e[i][a]) && (a = r);
+            for (s = i; s < t + 1; ++s) o = e[s][i], e[s][i] = e[s][a], e[s][a] = o;
+            for (r = i + 1; r < t; ++r)
+                for (s = t; s >= i; s--) e[s][r] -= e[s][i] * e[i][r] / e[i][i]
+        }
+        for (r = t - 1; r >= 0; --r) {
+            for (o = 0, s = r + 1; s < t; ++s) o += e[s][r] * n[s];
+            n[r] = (e[t][r] - o) / e[r][r]
+        }
+        return n
     }
+    const NA = 2,
+        PA = 1e-12;
 
-    function hb(e) {
-        if (!Fu) {
-            wf && (wf = clearTimeout(wf));
-            var t = e - Jo;
-            t > 24 ? (e < 1 / 0 && (wf = setTimeout(zk, e - yh.now() - am)), qc && (qc = clearInterval(qc))) : (qc || (kp = yh.now(), qc = setInterval(Nj, GO)), Fu = 1, WO(zk))
+    function zR(e, t, n, i) {
+        const [r, s, a, o] = t1(e, t, n, !0), l = r.length, u = Math.max(2, ~~(i * l)), c = new Float64Array(l), f = new Float64Array(l), h = new Float64Array(l).fill(1);
+        for (let d = -1; ++d <= NA;) {
+            const g = [0, u - 1];
+            for (let m = 0; m < l; ++m) {
+                const y = r[m],
+                    v = g[0],
+                    b = g[1],
+                    x = y - r[v] > r[b] - y ? v : b;
+                let _ = 0,
+                    S = 0,
+                    w = 0,
+                    E = 0,
+                    C = 0;
+                const k = 1 / Math.abs(r[x] - y || 1);
+                for (let $ = v; $ <= b; ++$) {
+                    const T = r[$],
+                        M = s[$],
+                        R = KU(Math.abs(y - T) * k) * h[$],
+                        N = T * R;
+                    _ += R, S += N, w += M * R, E += M * N, C += T * N
+                }
+                const [A, F] = Td(S / _, w / _, E / _, C / _);
+                c[m] = A + F * y, f[m] = Math.abs(s[m] - c[m]), JU(r, m + 1, g)
+            }
+            if (d === NA) break;
+            const p = EF(f);
+            if (Math.abs(p) < PA) break;
+            for (let m = 0, y, v; m < l; ++m) y = f[m] / (6 * p), h[m] = y >= 1 ? PA : (v = 1 - y * y) * v
         }
+        return QU(r, c, a, o)
     }
 
-    function Lj(e, t, n) {
-        var i = new Ap,
-            r = t;
-        return t == null ? (i.restart(e, t, n), i) : (i._restart = i.restart, i.restart = function(s, a, o) {
-            a = +a, o = o == null ? kx() : +o, i._restart(function l(u) {
-                u += r, i._restart(l, r += a, o), s(u)
-            }, a, o)
-        }, i.restart(e, t, n), i)
+    function KU(e) {
+        return (e = 1 - e * e * e) * e * e
     }
-    const db = Math.PI,
-        gb = 2 * db,
-        Eo = 1e-6,
-        Ij = gb - Eo;
 
-    function HO(e) {
-        this._ += e[0];
-        for (let t = 1, n = e.length; t < n; ++t) this._ += arguments[t] + e[t]
+    function JU(e, t, n) {
+        const i = e[t];
+        let r = n[0],
+            s = n[1] + 1;
+        if (!(s >= e.length))
+            for (; t > r && e[s] - i <= i - e[r];) n[0] = ++r, n[1] = s, ++s
     }
 
-    function zj(e) {
-        let t = Math.floor(e);
-        if (!(t >= 0)) throw new Error(`invalid digits: ${e}`);
-        if (t > 15) return HO;
-        const n = 10 ** t;
-        return function(i) {
-            this._ += i[0];
-            for (let r = 1, s = i.length; r < s; ++r) this._ += Math.round(arguments[r] * n) / n + i[r]
-        }
+    function QU(e, t, n, i) {
+        const r = e.length,
+            s = [];
+        let a = 0,
+            o = 0,
+            l = [],
+            u;
+        for (; a < r; ++a) u = e[a] + n, l[0] === u ? l[1] += (t[a] - l[1]) / ++o : (o = 0, l[1] += i, l = [u, t[a]], s.push(l));
+        return l[1] += i, s
     }
-    let Ax = class {
-        constructor(t) {
-            this._x0 = this._y0 = this._x1 = this._y1 = null, this._ = "", this._append = t == null ? HO : zj(t)
+    const ZU = .5 * Math.PI / 180;
+
+    function n1(e, t, n, i) {
+        n = n || 25, i = Math.max(n, i || 200);
+        const r = p => [p, e(p)],
+            s = t[0],
+            a = t[1],
+            o = a - s,
+            l = o / i,
+            u = [r(s)],
+            c = [];
+        if (n === i) {
+            for (let p = 1; p < i; ++p) u.push(r(s + p / n * o));
+            return u.push(r(a)), u
+        } else {
+            c.push(r(a));
+            for (let p = n; --p > 0;) c.push(r(s + p / n * o))
         }
-        moveTo(t, n) {
-            this._append`M${this._x0=this._x1=+t},${this._y0=this._y1=+n}`
-        }
-        closePath() {
-            this._x1 !== null && (this._x1 = this._x0, this._y1 = this._y0, this._append`Z`)
-        }
-        lineTo(t, n) {
-            this._append`L${this._x1=+t},${this._y1=+n}`
-        }
-        quadraticCurveTo(t, n, i, r) {
-            this._append`Q${+t},${+n},${this._x1=+i},${this._y1=+r}`
-        }
-        bezierCurveTo(t, n, i, r, s, a) {
-            this._append`C${+t},${+n},${+i},${+r},${this._x1=+s},${this._y1=+a}`
-        }
-        arcTo(t, n, i, r, s) {
-            if (t = +t, n = +n, i = +i, r = +r, s = +s, s < 0) throw new Error(`negative radius: ${s}`);
-            let a = this._x1,
-                o = this._y1,
-                l = i - t,
-                u = r - n,
-                c = a - t,
-                f = o - n,
-                h = c * c + f * f;
-            if (this._x1 === null) this._append`M${this._x1=t},${this._y1=n}`;
-            else if (h > Eo)
-                if (!(Math.abs(f * l - u * c) > Eo) || !s) this._append`L${this._x1=t},${this._y1=n}`;
-                else {
-                    let d = i - a,
-                        g = r - o,
-                        p = l * l + u * u,
-                        m = d * d + g * g,
-                        y = Math.sqrt(p),
-                        v = Math.sqrt(h),
-                        b = s * Math.tan((db - Math.acos((p + h - m) / (2 * y * v))) / 2),
-                        x = b / v,
-                        _ = b / y;
-                    Math.abs(x - 1) > Eo && this._append`L${t+x*c},${n+x*f}`, this._append`A${s},${s},0,0,${+(f*d>c*g)},${this._x1=t+_*l},${this._y1=n+_*u}`
-                }
-        }
-        arc(t, n, i, r, s, a) {
-            if (t = +t, n = +n, i = +i, a = !!a, i < 0) throw new Error(`negative radius: ${i}`);
-            let o = i * Math.cos(r),
-                l = i * Math.sin(r),
-                u = t + o,
-                c = n + l,
-                f = 1 ^ a,
-                h = a ? r - s : s - r;
-            this._x1 === null ? this._append`M${u},${c}` : (Math.abs(this._x1 - u) > Eo || Math.abs(this._y1 - c) > Eo) && this._append`L${u},${c}`, i && (h < 0 && (h = h % gb + gb), h > Ij ? this._append`A${i},${i},0,1,${f},${t-o},${n-l}A${i},${i},0,1,${f},${this._x1=u},${this._y1=c}` : h > Eo && this._append`A${i},${i},0,${+(h>=db)},${f},${this._x1=t+i*Math.cos(s)},${this._y1=n+i*Math.sin(s)}`)
-        }
-        rect(t, n, i, r) {
-            this._append`M${this._x0=this._x1=+t},${this._y0=this._y1=+n}h${i=+i}v${+r}h${-i}Z`
-        }
-        toString() {
-            return this._
+        let f = u[0],
+            h = c[c.length - 1];
+        const d = 1 / o,
+            g = eW(f[1], c);
+        for (; h;) {
+            const p = r((f[0] + h[0]) / 2);
+            p[0] - f[0] >= l && tW(f, p, h, d, g) > ZU ? c.push(p) : (f = h, u.push(h), c.pop()), h = c[c.length - 1]
         }
-    };
-
-    function om() {
-        return new Ax
+        return u
     }
-    om.prototype = Ax.prototype;
-    const Ms = 11102230246251565e-32,
-        sn = 134217729,
-        Bj = (3 + 8 * Ms) * Ms;
 
-    function Ey(e, t, n, i, r) {
-        let s, a, o, l, u = t[0],
-            c = i[0],
-            f = 0,
-            h = 0;
-        c > u == c > -u ? (s = u, u = t[++f]) : (s = c, c = i[++h]);
-        let d = 0;
-        if (f < e && h < n)
-            for (c > u == c > -u ? (a = u + s, o = s - (a - u), u = t[++f]) : (a = c + s, o = s - (a - c), c = i[++h]), s = a, o !== 0 && (r[d++] = o); f < e && h < n;) c > u == c > -u ? (a = s + u, l = a - s, o = s - (a - l) + (u - l), u = t[++f]) : (a = s + c, l = a - s, o = s - (a - l) + (c - l), c = i[++h]), s = a, o !== 0 && (r[d++] = o);
-        for (; f < e;) a = s + u, l = a - s, o = s - (a - l) + (u - l), u = t[++f], s = a, o !== 0 && (r[d++] = o);
-        for (; h < n;) a = s + c, l = a - s, o = s - (a - l) + (c - l), c = i[++h], s = a, o !== 0 && (r[d++] = o);
-        return (s !== 0 || d === 0) && (r[d++] = s), d
+    function eW(e, t) {
+        let n = e,
+            i = e;
+        const r = t.length;
+        for (let s = 0; s < r; ++s) {
+            const a = t[s][1];
+            a < n && (n = a), a > i && (i = a)
+        }
+        return 1 / (i - n)
     }
 
-    function jj(e, t) {
-        let n = t[0];
-        for (let i = 1; i < e; i++) n += t[i];
-        return n
+    function tW(e, t, n, i, r) {
+        const s = Math.atan2(r * (n[1] - e[1]), i * (n[0] - e[0])),
+            a = Math.atan2(r * (t[1] - e[1]), i * (t[0] - e[0]));
+        return Math.abs(s - a)
     }
 
-    function ed(e) {
-        return new Float64Array(e)
+    function nW(e) {
+        return t => {
+            const n = e.length;
+            let i = 1,
+                r = String(e[0](t));
+            for (; i < n; ++i) r += "|" + e[i](t);
+            return r
+        }
     }
-    const Uj = (3 + 16 * Ms) * Ms,
-        Gj = (2 + 12 * Ms) * Ms,
-        Wj = (9 + 64 * Ms) * Ms * Ms,
-        ql = ed(4),
-        Bk = ed(8),
-        jk = ed(12),
-        Uk = ed(16),
-        En = ed(4);
 
-    function qj(e, t, n, i, r, s, a) {
-        let o, l, u, c, f, h, d, g, p, m, y, v, b, x, _, S, w, E;
-        const A = e - r,
-            C = n - r,
-            k = t - s,
-            R = i - s;
-        x = A * R, h = sn * A, d = h - (h - A), g = A - d, h = sn * R, p = h - (h - R), m = R - p, _ = g * m - (x - d * p - g * p - d * m), S = k * C, h = sn * k, d = h - (h - k), g = k - d, h = sn * C, p = h - (h - C), m = C - p, w = g * m - (S - d * p - g * p - d * m), y = _ - w, f = _ - y, ql[0] = _ - (y + f) + (f - w), v = x + y, f = v - x, b = x - (v - f) + (y - f), y = b - S, f = b - y, ql[1] = b - (y + f) + (f - S), E = v + y, f = E - v, ql[2] = v - (E - f) + (y - f), ql[3] = E;
-        let $ = jj(4, ql),
-            T = Gj * a;
-        if ($ >= T || -$ >= T || (f = e - A, o = e - (A + f) + (f - r), f = n - C, u = n - (C + f) + (f - r), f = t - k, l = t - (k + f) + (f - s), f = i - R, c = i - (R + f) + (f - s), o === 0 && l === 0 && u === 0 && c === 0) || (T = Wj * a + Bj * Math.abs($), $ += A * c + R * o - (k * u + C * l), $ >= T || -$ >= T)) return $;
-        x = o * R, h = sn * o, d = h - (h - o), g = o - d, h = sn * R, p = h - (h - R), m = R - p, _ = g * m - (x - d * p - g * p - d * m), S = l * C, h = sn * l, d = h - (h - l), g = l - d, h = sn * C, p = h - (h - C), m = C - p, w = g * m - (S - d * p - g * p - d * m), y = _ - w, f = _ - y, En[0] = _ - (y + f) + (f - w), v = x + y, f = v - x, b = x - (v - f) + (y - f), y = b - S, f = b - y, En[1] = b - (y + f) + (f - S), E = v + y, f = E - v, En[2] = v - (E - f) + (y - f), En[3] = E;
-        const M = Ey(4, ql, 4, En, Bk);
-        x = A * c, h = sn * A, d = h - (h - A), g = A - d, h = sn * c, p = h - (h - c), m = c - p, _ = g * m - (x - d * p - g * p - d * m), S = k * u, h = sn * k, d = h - (h - k), g = k - d, h = sn * u, p = h - (h - u), m = u - p, w = g * m - (S - d * p - g * p - d * m), y = _ - w, f = _ - y, En[0] = _ - (y + f) + (f - w), v = x + y, f = v - x, b = x - (v - f) + (y - f), y = b - S, f = b - y, En[1] = b - (y + f) + (f - S), E = v + y, f = E - v, En[2] = v - (E - f) + (y - f), En[3] = E;
-        const F = Ey(M, Bk, 4, En, jk);
-        x = o * c, h = sn * o, d = h - (h - o), g = o - d, h = sn * c, p = h - (h - c), m = c - p, _ = g * m - (x - d * p - g * p - d * m), S = l * u, h = sn * l, d = h - (h - l), g = l - d, h = sn * u, p = h - (h - u), m = u - p, w = g * m - (S - d * p - g * p - d * m), y = _ - w, f = _ - y, En[0] = _ - (y + f) + (f - w), v = x + y, f = v - x, b = x - (v - f) + (y - f), y = b - S, f = b - y, En[1] = b - (y + f) + (f - S), E = v + y, f = E - v, En[2] = v - (E - f) + (y - f), En[3] = E;
-        const N = Ey(F, jk, 4, En, Uk);
-        return Uk[N - 1]
+    function Zb(e) {
+        return !e || !e.length ? function() {
+            return ""
+        } : e.length === 1 ? e[0] : nW(e)
     }
 
-    function ng(e, t, n, i, r, s) {
-        const a = (t - s) * (n - r),
-            o = (e - r) * (i - s),
-            l = a - o,
-            u = Math.abs(a + o);
-        return Math.abs(l) >= Uj * u ? l : -qj(e, t, n, i, r, s, u)
+    function BR(e, t, n) {
+        return n || e + (t ? "_" + t : "")
     }
-    const Gk = Math.pow(2, -52),
-        ig = new Uint32Array(512);
-    class $p {
-        static from(t, n = Kj, i = Jj) {
-            const r = t.length,
-                s = new Float64Array(r * 2);
-            for (let a = 0; a < r; a++) {
-                const o = t[a];
-                s[2 * a] = n(o), s[2 * a + 1] = i(o)
-            }
-            return new $p(s)
-        }
-        constructor(t) {
-            const n = t.length >> 1;
-            if (n > 0 && typeof t[0] != "number") throw new Error("Expected coords to contain numbers.");
-            this.coords = t;
-            const i = Math.max(2 * n - 5, 0);
-            this._triangles = new Uint32Array(i * 3), this._halfedges = new Int32Array(i * 3), this._hashSize = Math.ceil(Math.sqrt(n)), this._hullPrev = new Uint32Array(n), this._hullNext = new Uint32Array(n), this._hullTri = new Uint32Array(n), this._hullHash = new Int32Array(this._hashSize).fill(-1), this._ids = new Uint32Array(n), this._dists = new Float64Array(n), this.update()
-        }
-        update() {
-            const {
-                coords: t,
-                _hullPrev: n,
-                _hullNext: i,
-                _hullTri: r,
-                _hullHash: s
-            } = this, a = t.length >> 1;
-            let o = 1 / 0,
-                l = 1 / 0,
-                u = -1 / 0,
-                c = -1 / 0;
-            for (let C = 0; C < a; C++) {
-                const k = t[2 * C],
-                    R = t[2 * C + 1];
-                k < o && (o = k), R < l && (l = R), k > u && (u = k), R > c && (c = R), this._ids[C] = C
-            }
-            const f = (o + u) / 2,
-                h = (l + c) / 2;
-            let d = 1 / 0,
-                g, p, m;
-            for (let C = 0; C < a; C++) {
-                const k = Cy(f, h, t[2 * C], t[2 * C + 1]);
-                k < d && (g = C, d = k)
-            }
-            const y = t[2 * g],
-                v = t[2 * g + 1];
-            d = 1 / 0;
-            for (let C = 0; C < a; C++) {
-                if (C === g) continue;
-                const k = Cy(y, v, t[2 * C], t[2 * C + 1]);
-                k < d && k > 0 && (p = C, d = k)
-            }
-            let b = t[2 * p],
-                x = t[2 * p + 1],
-                _ = 1 / 0;
-            for (let C = 0; C < a; C++) {
-                if (C === g || C === p) continue;
-                const k = Xj(y, v, b, x, t[2 * C], t[2 * C + 1]);
-                k < _ && (m = C, _ = k)
-            }
-            let S = t[2 * m],
-                w = t[2 * m + 1];
-            if (_ === 1 / 0) {
-                for (let R = 0; R < a; R++) this._dists[R] = t[2 * R] - t[0] || t[2 * R + 1] - t[1];
-                uu(this._ids, this._dists, 0, a - 1);
-                const C = new Uint32Array(a);
-                let k = 0;
-                for (let R = 0, $ = -1 / 0; R < a; R++) {
-                    const T = this._ids[R];
-                    this._dists[T] > $ && (C[k++] = T, $ = this._dists[T])
-                }
-                this.hull = C.subarray(0, k), this.triangles = new Uint32Array(0), this.halfedges = new Uint32Array(0);
-                return
-            }
-            if (ng(y, v, b, x, S, w) < 0) {
-                const C = p,
-                    k = b,
-                    R = x;
-                p = m, b = S, x = w, m = C, S = k, w = R
-            }
-            const E = Vj(y, v, b, x, S, w);
-            this._cx = E.x, this._cy = E.y;
-            for (let C = 0; C < a; C++) this._dists[C] = Cy(t[2 * C], t[2 * C + 1], E.x, E.y);
-            uu(this._ids, this._dists, 0, a - 1), this._hullStart = g;
-            let A = 3;
-            i[g] = n[m] = p, i[p] = n[g] = m, i[m] = n[p] = g, r[g] = 0, r[p] = 1, r[m] = 2, s.fill(-1), s[this._hashKey(y, v)] = g, s[this._hashKey(b, x)] = p, s[this._hashKey(S, w)] = m, this.trianglesLen = 0, this._addTriangle(g, p, m, -1, -1, -1);
-            for (let C = 0, k, R; C < this._ids.length; C++) {
-                const $ = this._ids[C],
-                    T = t[2 * $],
-                    M = t[2 * $ + 1];
-                if (C > 0 && Math.abs(T - k) <= Gk && Math.abs(M - R) <= Gk || (k = T, R = M, $ === g || $ === p || $ === m)) continue;
-                let F = 0;
-                for (let Q = 0, oe = this._hashKey(T, M); Q < this._hashSize && (F = s[(oe + Q) % this._hashSize], !(F !== -1 && F !== i[F])); Q++);
-                F = n[F];
-                let N = F,
-                    P;
-                for (; P = i[N], ng(T, M, t[2 * N], t[2 * N + 1], t[2 * P], t[2 * P + 1]) >= 0;)
-                    if (N = P, N === F) {
-                        N = -1;
-                        break
-                    } if (N === -1) continue;
-                let z = this._addTriangle(N, $, i[N], -1, -1, r[N]);
-                r[$] = this._legalize(z + 2), r[N] = z, A++;
-                let I = i[N];
-                for (; P = i[I], ng(T, M, t[2 * I], t[2 * I + 1], t[2 * P], t[2 * P + 1]) < 0;) z = this._addTriangle(I, $, P, r[$], -1, r[I]), r[$] = this._legalize(z + 2), i[I] = I, A--, I = P;
-                if (N === F)
-                    for (; P = n[N], ng(T, M, t[2 * P], t[2 * P + 1], t[2 * N], t[2 * N + 1]) < 0;) z = this._addTriangle(P, $, N, -1, r[N], r[P]), this._legalize(z + 2), r[P] = z, i[N] = N, A--, N = P;
-                this._hullStart = n[$] = N, i[N] = n[I] = $, i[$] = I, s[this._hashKey(T, M)] = $, s[this._hashKey(t[2 * N], t[2 * N + 1])] = N
-            }
-            this.hull = new Uint32Array(A);
-            for (let C = 0, k = this._hullStart; C < A; C++) this.hull[C] = k, k = i[k];
-            this.triangles = this._triangles.subarray(0, this.trianglesLen), this.halfedges = this._halfedges.subarray(0, this.trianglesLen)
-        }
-        _hashKey(t, n) {
-            return Math.floor(Hj(t - this._cx, n - this._cy) * this._hashSize) % this._hashSize
-        }
-        _legalize(t) {
-            const {
-                _triangles: n,
-                _halfedges: i,
-                coords: r
-            } = this;
-            let s = 0,
-                a = 0;
-            for (;;) {
-                const o = i[t],
-                    l = t - t % 3;
-                if (a = l + (t + 2) % 3, o === -1) {
-                    if (s === 0) break;
-                    t = ig[--s];
-                    continue
-                }
-                const u = o - o % 3,
-                    c = l + (t + 1) % 3,
-                    f = u + (o + 2) % 3,
-                    h = n[a],
-                    d = n[t],
-                    g = n[c],
-                    p = n[f];
-                if (Yj(r[2 * h], r[2 * h + 1], r[2 * d], r[2 * d + 1], r[2 * g], r[2 * g + 1], r[2 * p], r[2 * p + 1])) {
-                    n[t] = p, n[o] = h;
-                    const y = i[f];
-                    if (y === -1) {
-                        let b = this._hullStart;
-                        do {
-                            if (this._hullTri[b] === f) {
-                                this._hullTri[b] = t;
-                                break
-                            }
-                            b = this._hullPrev[b]
-                        } while (b !== this._hullStart)
-                    }
-                    this._link(t, y), this._link(o, i[a]), this._link(a, f);
-                    const v = u + (o + 1) % 3;
-                    s < ig.length && (ig[s++] = v)
-                } else {
-                    if (s === 0) break;
-                    t = ig[--s]
-                }
+    const rv = () => {},
+        iW = {
+            init: rv,
+            add: rv,
+            rem: rv,
+            idx: 0
+        },
+        Yh = {
+            values: {
+                init: e => e.cell.store = !0,
+                value: e => e.cell.data.values(),
+                idx: -1
+            },
+            count: {
+                value: e => e.cell.num
+            },
+            __count__: {
+                value: e => e.missing + e.valid
+            },
+            missing: {
+                value: e => e.missing
+            },
+            valid: {
+                value: e => e.valid
+            },
+            sum: {
+                init: e => e.sum = 0,
+                value: e => e.sum,
+                add: (e, t) => e.sum += +t,
+                rem: (e, t) => e.sum -= t
+            },
+            product: {
+                init: e => e.product = 1,
+                value: e => e.valid ? e.product : void 0,
+                add: (e, t) => e.product *= t,
+                rem: (e, t) => e.product /= t
+            },
+            mean: {
+                init: e => e.mean = 0,
+                value: e => e.valid ? e.mean : void 0,
+                add: (e, t) => (e.mean_d = t - e.mean, e.mean += e.mean_d / e.valid),
+                rem: (e, t) => (e.mean_d = t - e.mean, e.mean -= e.valid ? e.mean_d / e.valid : e.mean)
+            },
+            average: {
+                value: e => e.valid ? e.mean : void 0,
+                req: ["mean"],
+                idx: 1
+            },
+            variance: {
+                init: e => e.dev = 0,
+                value: e => e.valid > 1 ? e.dev / (e.valid - 1) : void 0,
+                add: (e, t) => e.dev += e.mean_d * (t - e.mean),
+                rem: (e, t) => e.dev -= e.mean_d * (t - e.mean),
+                req: ["mean"],
+                idx: 1
+            },
+            variancep: {
+                value: e => e.valid > 1 ? e.dev / e.valid : void 0,
+                req: ["variance"],
+                idx: 2
+            },
+            stdev: {
+                value: e => e.valid > 1 ? Math.sqrt(e.dev / (e.valid - 1)) : void 0,
+                req: ["variance"],
+                idx: 2
+            },
+            stdevp: {
+                value: e => e.valid > 1 ? Math.sqrt(e.dev / e.valid) : void 0,
+                req: ["variance"],
+                idx: 2
+            },
+            stderr: {
+                value: e => e.valid > 1 ? Math.sqrt(e.dev / (e.valid * (e.valid - 1))) : void 0,
+                req: ["variance"],
+                idx: 2
+            },
+            distinct: {
+                value: e => e.cell.data.distinct(e.get),
+                req: ["values"],
+                idx: 3
+            },
+            ci0: {
+                value: e => e.cell.data.ci0(e.get),
+                req: ["values"],
+                idx: 3
+            },
+            ci1: {
+                value: e => e.cell.data.ci1(e.get),
+                req: ["values"],
+                idx: 3
+            },
+            median: {
+                value: e => e.cell.data.q2(e.get),
+                req: ["values"],
+                idx: 3
+            },
+            q1: {
+                value: e => e.cell.data.q1(e.get),
+                req: ["values"],
+                idx: 3
+            },
+            q3: {
+                value: e => e.cell.data.q3(e.get),
+                req: ["values"],
+                idx: 3
+            },
+            min: {
+                init: e => e.min = void 0,
+                value: e => e.min = Number.isNaN(e.min) ? e.cell.data.min(e.get) : e.min,
+                add: (e, t) => {
+                    (t < e.min || e.min === void 0) && (e.min = t)
+                },
+                rem: (e, t) => {
+                    t <= e.min && (e.min = NaN)
+                },
+                req: ["values"],
+                idx: 4
+            },
+            max: {
+                init: e => e.max = void 0,
+                value: e => e.max = Number.isNaN(e.max) ? e.cell.data.max(e.get) : e.max,
+                add: (e, t) => {
+                    (t > e.max || e.max === void 0) && (e.max = t)
+                },
+                rem: (e, t) => {
+                    t >= e.max && (e.max = NaN)
+                },
+                req: ["values"],
+                idx: 4
+            },
+            argmin: {
+                init: e => e.argmin = void 0,
+                value: e => e.argmin || e.cell.data.argmin(e.get),
+                add: (e, t, n) => {
+                    t < e.min && (e.argmin = n)
+                },
+                rem: (e, t) => {
+                    t <= e.min && (e.argmin = void 0)
+                },
+                req: ["min", "values"],
+                idx: 3
+            },
+            argmax: {
+                init: e => e.argmax = void 0,
+                value: e => e.argmax || e.cell.data.argmax(e.get),
+                add: (e, t, n) => {
+                    t > e.max && (e.argmax = n)
+                },
+                rem: (e, t) => {
+                    t >= e.max && (e.argmax = void 0)
+                },
+                req: ["max", "values"],
+                idx: 3
             }
-            return a
-        }
-        _link(t, n) {
-            this._halfedges[t] = n, n !== -1 && (this._halfedges[n] = t)
-        }
-        _addTriangle(t, n, i, r, s, a) {
-            const o = this.trianglesLen;
-            return this._triangles[o] = t, this._triangles[o + 1] = n, this._triangles[o + 2] = i, this._link(o, r), this._link(o + 1, s), this._link(o + 2, a), this.trianglesLen += 3, o
-        }
-    }
+        },
+        Od = Object.keys(Yh).filter(e => e !== "__count__");
 
-    function Hj(e, t) {
-        const n = e / (Math.abs(e) + Math.abs(t));
-        return (t > 0 ? 3 - n : 1 + n) / 4
+    function rW(e, t) {
+        return n => Ne({
+            name: e,
+            out: n || e
+        }, iW, t)
+    } [...Od, "__count__"].forEach(e => {
+        Yh[e] = rW(e, Yh[e])
+    });
+
+    function jR(e, t) {
+        return Yh[e](t)
     }
 
-    function Cy(e, t, n, i) {
-        const r = e - n,
-            s = t - i;
-        return r * r + s * s
+    function GR(e, t) {
+        return e.idx - t.idx
     }
 
-    function Yj(e, t, n, i, r, s, a, o) {
-        const l = e - a,
-            u = t - o,
-            c = n - a,
-            f = i - o,
-            h = r - a,
-            d = s - o,
-            g = l * l + u * u,
-            p = c * c + f * f,
-            m = h * h + d * d;
-        return l * (f * m - p * d) - u * (c * m - p * h) + g * (c * d - f * h) < 0
+    function sW(e) {
+        const t = {};
+        e.forEach(i => t[i.name] = i);
+        const n = i => {
+            i.req && i.req.forEach(r => {
+                t[r] || n(t[r] = Yh[r]())
+            })
+        };
+        return e.forEach(n), Object.values(t).sort(GR)
     }
 
-    function Xj(e, t, n, i, r, s) {
-        const a = n - e,
-            o = i - t,
-            l = r - e,
-            u = s - t,
-            c = a * a + o * o,
-            f = l * l + u * u,
-            h = .5 / (a * u - o * l),
-            d = (u * c - o * f) * h,
-            g = (a * f - l * c) * h;
-        return d * d + g * g
+    function aW() {
+        this.valid = 0, this.missing = 0, this._ops.forEach(e => e.init(this))
     }
 
-    function Vj(e, t, n, i, r, s) {
-        const a = n - e,
-            o = i - t,
-            l = r - e,
-            u = s - t,
-            c = a * a + o * o,
-            f = l * l + u * u,
-            h = .5 / (a * u - o * l),
-            d = e + (u * c - o * f) * h,
-            g = t + (a * f - l * c) * h;
-        return {
-            x: d,
-            y: g
+    function oW(e, t) {
+        if (e == null || e === "") {
+            ++this.missing;
+            return
         }
+        e === e && (++this.valid, this._ops.forEach(n => n.add(this, e, t)))
     }
 
-    function uu(e, t, n, i) {
-        if (i - n <= 20)
-            for (let r = n + 1; r <= i; r++) {
-                const s = e[r],
-                    a = t[s];
-                let o = r - 1;
-                for (; o >= n && t[e[o]] > a;) e[o + 1] = e[o--];
-                e[o + 1] = s
-            } else {
-                const r = n + i >> 1;
-                let s = n + 1,
-                    a = i;
-                Hc(e, r, s), t[e[n]] > t[e[i]] && Hc(e, n, i), t[e[s]] > t[e[i]] && Hc(e, s, i), t[e[n]] > t[e[s]] && Hc(e, n, s);
-                const o = e[s],
-                    l = t[o];
-                for (;;) {
-                    do s++; while (t[e[s]] < l);
-                    do a--; while (t[e[a]] > l);
-                    if (a < s) break;
-                    Hc(e, s, a)
-                }
-                e[n + 1] = e[a], e[a] = o, i - s + 1 >= a - n ? (uu(e, t, s, i), uu(e, t, n, a - 1)) : (uu(e, t, n, a - 1), uu(e, t, s, i))
-            }
+    function lW(e, t) {
+        if (e == null || e === "") {
+            --this.missing;
+            return
+        }
+        e === e && (--this.valid, this._ops.forEach(n => n.rem(this, e, t)))
     }
 
-    function Hc(e, t, n) {
-        const i = e[t];
-        e[t] = e[n], e[n] = i
+    function uW(e) {
+        return this._out.forEach(t => e[t.out] = t.value(this)), e
     }
 
-    function Kj(e) {
-        return e[0]
-    }
+    function UR(e, t) {
+        const n = t || Pn,
+            i = sW(e),
+            r = e.slice().sort(GR);
 
-    function Jj(e) {
-        return e[1]
-    }
-    const Wk = 1e-6;
-    class No {
-        constructor() {
-            this._x0 = this._y0 = this._x1 = this._y1 = null, this._ = ""
-        }
-        moveTo(t, n) {
-            this._ += `M${this._x0=this._x1=+t},${this._y0=this._y1=+n}`
-        }
-        closePath() {
-            this._x1 !== null && (this._x1 = this._x0, this._y1 = this._y0, this._ += "Z")
-        }
-        lineTo(t, n) {
-            this._ += `L${this._x1=+t},${this._y1=+n}`
-        }
-        arc(t, n, i) {
-            t = +t, n = +n, i = +i;
-            const r = t + i,
-                s = n;
-            if (i < 0) throw new Error("negative radius");
-            this._x1 === null ? this._ += `M${r},${s}` : (Math.abs(this._x1 - r) > Wk || Math.abs(this._y1 - s) > Wk) && (this._ += "L" + r + "," + s), i && (this._ += `A${i},${i},0,1,1,${t-i},${n}A${i},${i},0,1,1,${this._x1=r},${this._y1=s}`)
-        }
-        rect(t, n, i, r) {
-            this._ += `M${this._x0=this._x1=+t},${this._y0=this._y1=+n}h${+i}v${+r}h${-i}Z`
-        }
-        value() {
-            return this._ || null
+        function s(a) {
+            this._ops = i, this._out = r, this.cell = a, this.init()
         }
+        return s.prototype.init = aW, s.prototype.add = oW, s.prototype.rem = lW, s.prototype.set = uW, s.prototype.get = n, s.fields = e.map(a => a.out), s
     }
-    class pb {
-        constructor() {
-            this._ = []
-        }
-        moveTo(t, n) {
-            this._.push([t, n])
-        }
-        closePath() {
-            this._.push(this._[0].slice())
-        }
-        lineTo(t, n) {
-            this._.push([t, n])
-        }
-        value() {
-            return this._.length ? this._ : null
-        }
+
+    function nw(e) {
+        this._key = e ? fi(e) : Ee, this.reset()
     }
-    let Qj = class {
-        constructor(t, [n, i, r, s] = [0, 0, 960, 500]) {
-            if (!((r = +r) >= (n = +n)) || !((s = +s) >= (i = +i))) throw new Error("invalid bounds");
-            this.delaunay = t, this._circumcenters = new Float64Array(t.points.length * 2), this.vectors = new Float64Array(t.points.length * 2), this.xmax = r, this.xmin = n, this.ymax = s, this.ymin = i, this._init()
-        }
-        update() {
-            return this.delaunay.update(), this._init(), this
-        }
-        _init() {
-            const {
-                delaunay: {
-                    points: t,
-                    hull: n,
-                    triangles: i
-                },
-                vectors: r
-            } = this;
-            let s, a;
-            const o = this.circumcenters = this._circumcenters.subarray(0, i.length / 3 * 2);
-            for (let p = 0, m = 0, y = i.length, v, b; p < y; p += 3, m += 2) {
-                const x = i[p] * 2,
-                    _ = i[p + 1] * 2,
-                    S = i[p + 2] * 2,
-                    w = t[x],
-                    E = t[x + 1],
-                    A = t[_],
-                    C = t[_ + 1],
-                    k = t[S],
-                    R = t[S + 1],
-                    $ = A - w,
-                    T = C - E,
-                    M = k - w,
-                    F = R - E,
-                    N = ($ * F - T * M) * 2;
-                if (Math.abs(N) < 1e-9) {
-                    if (s === void 0) {
-                        s = a = 0;
-                        for (const z of n) s += t[z * 2], a += t[z * 2 + 1];
-                        s /= n.length, a /= n.length
-                    }
-                    const P = 1e9 * Math.sign((s - w) * F - (a - E) * M);
-                    v = (w + k) / 2 - P * F, b = (E + R) / 2 + P * M
-                } else {
-                    const P = 1 / N,
-                        z = $ * $ + T * T,
-                        I = M * M + F * F;
-                    v = w + (F * z - T * I) * P, b = E + ($ * I - M * z) * P
-                }
-                o[m] = v, o[m + 1] = b
-            }
-            let l = n[n.length - 1],
-                u, c = l * 4,
-                f, h = t[2 * l],
-                d, g = t[2 * l + 1];
-            r.fill(0);
-            for (let p = 0; p < n.length; ++p) l = n[p], u = c, f = h, d = g, c = l * 4, h = t[2 * l], g = t[2 * l + 1], r[u + 2] = r[c] = d - g, r[u + 3] = r[c + 1] = h - f
-        }
-        render(t) {
-            const n = t == null ? t = new No : void 0,
-                {
-                    delaunay: {
-                        halfedges: i,
-                        inedges: r,
-                        hull: s
-                    },
-                    circumcenters: a,
-                    vectors: o
-                } = this;
-            if (s.length <= 1) return null;
-            for (let c = 0, f = i.length; c < f; ++c) {
-                const h = i[c];
-                if (h < c) continue;
-                const d = Math.floor(c / 3) * 2,
-                    g = Math.floor(h / 3) * 2,
-                    p = a[d],
-                    m = a[d + 1],
-                    y = a[g],
-                    v = a[g + 1];
-                this._renderSegment(p, m, y, v, t)
-            }
-            let l, u = s[s.length - 1];
-            for (let c = 0; c < s.length; ++c) {
-                l = u, u = s[c];
-                const f = Math.floor(r[u] / 3) * 2,
-                    h = a[f],
-                    d = a[f + 1],
-                    g = l * 4,
-                    p = this._project(h, d, o[g + 2], o[g + 3]);
-                p && this._renderSegment(h, d, p[0], p[1], t)
-            }
-            return n && n.value()
-        }
-        renderBounds(t) {
-            const n = t == null ? t = new No : void 0;
-            return t.rect(this.xmin, this.ymin, this.xmax - this.xmin, this.ymax - this.ymin), n && n.value()
-        }
-        renderCell(t, n) {
-            const i = n == null ? n = new No : void 0,
-                r = this._clip(t);
-            if (r === null || !r.length) return;
-            n.moveTo(r[0], r[1]);
-            let s = r.length;
-            for (; r[0] === r[s - 2] && r[1] === r[s - 1] && s > 1;) s -= 2;
-            for (let a = 2; a < s; a += 2)(r[a] !== r[a - 2] || r[a + 1] !== r[a - 1]) && n.lineTo(r[a], r[a + 1]);
-            return n.closePath(), i && i.value()
-        }* cellPolygons() {
-            const {
-                delaunay: {
-                    points: t
-                }
-            } = this;
-            for (let n = 0, i = t.length / 2; n < i; ++n) {
-                const r = this.cellPolygon(n);
-                r && (r.index = n, yield r)
-            }
-        }
-        cellPolygon(t) {
-            const n = new pb;
-            return this.renderCell(t, n), n.value()
-        }
-        _renderSegment(t, n, i, r, s) {
-            let a;
-            const o = this._regioncode(t, n),
-                l = this._regioncode(i, r);
-            o === 0 && l === 0 ? (s.moveTo(t, n), s.lineTo(i, r)) : (a = this._clipSegment(t, n, i, r, o, l)) && (s.moveTo(a[0], a[1]), s.lineTo(a[2], a[3]))
-        }
-        contains(t, n, i) {
-            return n = +n, n !== n || (i = +i, i !== i) ? !1 : this.delaunay._step(t, n, i) === t
-        }* neighbors(t) {
-            const n = this._clip(t);
-            if (n)
-                for (const i of this.delaunay.neighbors(t)) {
-                    const r = this._clip(i);
-                    if (r) {
-                        e: for (let s = 0, a = n.length; s < a; s += 2)
-                            for (let o = 0, l = r.length; o < l; o += 2)
-                                if (n[s] === r[o] && n[s + 1] === r[o + 1] && n[(s + 2) % a] === r[(o + l - 2) % l] && n[(s + 3) % a] === r[(o + l - 1) % l]) {
-                                    yield i;
-                                    break e
-                                }
-                    }
-                }
-        }
-        _cell(t) {
-            const {
-                circumcenters: n,
-                delaunay: {
-                    inedges: i,
-                    halfedges: r,
-                    triangles: s
-                }
-            } = this, a = i[t];
-            if (a === -1) return null;
-            const o = [];
-            let l = a;
-            do {
-                const u = Math.floor(l / 3);
-                if (o.push(n[u * 2], n[u * 2 + 1]), l = l % 3 === 2 ? l - 2 : l + 1, s[l] !== t) break;
-                l = r[l]
-            } while (l !== a && l !== -1);
-            return o
-        }
-        _clip(t) {
-            if (t === 0 && this.delaunay.hull.length === 1) return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
-            const n = this._cell(t);
-            if (n === null) return null;
-            const {
-                vectors: i
-            } = this, r = t * 4;
-            return this._simplify(i[r] || i[r + 1] ? this._clipInfinite(t, n, i[r], i[r + 1], i[r + 2], i[r + 3]) : this._clipFinite(t, n))
-        }
-        _clipFinite(t, n) {
-            const i = n.length;
-            let r = null,
-                s, a, o = n[i - 2],
-                l = n[i - 1],
-                u, c = this._regioncode(o, l),
-                f, h = 0;
-            for (let d = 0; d < i; d += 2)
-                if (s = o, a = l, o = n[d], l = n[d + 1], u = c, c = this._regioncode(o, l), u === 0 && c === 0) f = h, h = 0, r ? r.push(o, l) : r = [o, l];
-                else {
-                    let g, p, m, y, v;
-                    if (u === 0) {
-                        if ((g = this._clipSegment(s, a, o, l, u, c)) === null) continue;
-                        [p, m, y, v] = g
-                    } else {
-                        if ((g = this._clipSegment(o, l, s, a, c, u)) === null) continue;
-                        [y, v, p, m] = g, f = h, h = this._edgecode(p, m), f && h && this._edge(t, f, h, r, r.length), r ? r.push(p, m) : r = [p, m]
-                    }
-                    f = h, h = this._edgecode(y, v), f && h && this._edge(t, f, h, r, r.length), r ? r.push(y, v) : r = [y, v]
-                } if (r) f = h, h = this._edgecode(r[0], r[1]), f && h && this._edge(t, f, h, r, r.length);
-            else if (this.contains(t, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
-            return r
-        }
-        _clipSegment(t, n, i, r, s, a) {
-            const o = s < a;
-            for (o && ([t, n, i, r, s, a] = [i, r, t, n, a, s]);;) {
-                if (s === 0 && a === 0) return o ? [i, r, t, n] : [t, n, i, r];
-                if (s & a) return null;
-                let l, u, c = s || a;
-                c & 8 ? (l = t + (i - t) * (this.ymax - n) / (r - n), u = this.ymax) : c & 4 ? (l = t + (i - t) * (this.ymin - n) / (r - n), u = this.ymin) : c & 2 ? (u = n + (r - n) * (this.xmax - t) / (i - t), l = this.xmax) : (u = n + (r - n) * (this.xmin - t) / (i - t), l = this.xmin), s ? (t = l, n = u, s = this._regioncode(t, n)) : (i = l, r = u, a = this._regioncode(i, r))
-            }
-        }
-        _clipInfinite(t, n, i, r, s, a) {
-            let o = Array.from(n),
-                l;
-            if ((l = this._project(o[0], o[1], i, r)) && o.unshift(l[0], l[1]), (l = this._project(o[o.length - 2], o[o.length - 1], s, a)) && o.push(l[0], l[1]), o = this._clipFinite(t, o))
-                for (let u = 0, c = o.length, f, h = this._edgecode(o[c - 2], o[c - 1]); u < c; u += 2) f = h, h = this._edgecode(o[u], o[u + 1]), f && h && (u = this._edge(t, f, h, o, u), c = o.length);
-            else this.contains(t, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2) && (o = [this.xmin, this.ymin, this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax]);
-            return o
-        }
-        _edge(t, n, i, r, s) {
-            for (; n !== i;) {
-                let a, o;
-                switch (n) {
-                    case 5:
-                        n = 4;
-                        continue;
-                    case 4:
-                        n = 6, a = this.xmax, o = this.ymin;
-                        break;
-                    case 6:
-                        n = 2;
-                        continue;
-                    case 2:
-                        n = 10, a = this.xmax, o = this.ymax;
-                        break;
-                    case 10:
-                        n = 8;
-                        continue;
-                    case 8:
-                        n = 9, a = this.xmin, o = this.ymax;
-                        break;
-                    case 9:
-                        n = 1;
-                        continue;
-                    case 1:
-                        n = 5, a = this.xmin, o = this.ymin;
-                        break
-                }(r[s] !== a || r[s + 1] !== o) && this.contains(t, a, o) && (r.splice(s, 0, a, o), s += 2)
-            }
-            return s
-        }
-        _project(t, n, i, r) {
-            let s = 1 / 0,
-                a, o, l;
-            if (r < 0) {
-                if (n <= this.ymin) return null;
-                (a = (this.ymin - n) / r) < s && (l = this.ymin, o = t + (s = a) * i)
-            } else if (r > 0) {
-                if (n >= this.ymax) return null;
-                (a = (this.ymax - n) / r) < s && (l = this.ymax, o = t + (s = a) * i)
-            }
-            if (i > 0) {
-                if (t >= this.xmax) return null;
-                (a = (this.xmax - t) / i) < s && (o = this.xmax, l = n + (s = a) * r)
-            } else if (i < 0) {
-                if (t <= this.xmin) return null;
-                (a = (this.xmin - t) / i) < s && (o = this.xmin, l = n + (s = a) * r)
-            }
-            return [o, l]
-        }
-        _edgecode(t, n) {
-            return (t === this.xmin ? 1 : t === this.xmax ? 2 : 0) | (n === this.ymin ? 4 : n === this.ymax ? 8 : 0)
-        }
-        _regioncode(t, n) {
-            return (t < this.xmin ? 1 : t > this.xmax ? 2 : 0) | (n < this.ymin ? 4 : n > this.ymax ? 8 : 0)
-        }
-        _simplify(t) {
-            if (t && t.length > 4) {
-                for (let n = 0; n < t.length; n += 2) {
-                    const i = (n + 2) % t.length,
-                        r = (n + 4) % t.length;
-                    (t[n] === t[i] && t[i] === t[r] || t[n + 1] === t[i + 1] && t[i + 1] === t[r + 1]) && (t.splice(i, 2), n -= 2)
-                }
-                t.length || (t = null)
-            }
-            return t
+    const _n = nw.prototype;
+    _n.reset = function() {
+        this._add = [], this._rem = [], this._ext = null, this._get = null, this._q = null
+    };
+    _n.add = function(e) {
+        this._add.push(e)
+    };
+    _n.rem = function(e) {
+        this._rem.push(e)
+    };
+    _n.values = function() {
+        if (this._get = null, this._rem.length === 0) return this._add;
+        const e = this._add,
+            t = this._rem,
+            n = this._key,
+            i = e.length,
+            r = t.length,
+            s = Array(i - r),
+            a = {};
+        let o, l, u;
+        for (o = 0; o < r; ++o) a[n(t[o])] = 1;
+        for (o = 0, l = 0; o < i; ++o) a[n(u = e[o])] ? a[n(u)] = 0 : s[l++] = u;
+        return this._rem = [], this._add = s
+    };
+    _n.distinct = function(e) {
+        const t = this.values(),
+            n = {};
+        let i = t.length,
+            r = 0,
+            s;
+        for (; --i >= 0;) s = e(t[i]) + "", Ce(n, s) || (n[s] = 1, ++r);
+        return r
+    };
+    _n.extent = function(e) {
+        if (this._get !== e || !this._ext) {
+            const t = this.values(),
+                n = sF(t, e);
+            this._ext = [t[n[0]], t[n[1]]], this._get = e
         }
+        return this._ext
+    };
+    _n.argmin = function(e) {
+        return this.extent(e)[0] || {}
+    };
+    _n.argmax = function(e) {
+        return this.extent(e)[1] || {}
+    };
+    _n.min = function(e) {
+        const t = this.extent(e)[0];
+        return t != null ? e(t) : void 0
+    };
+    _n.max = function(e) {
+        const t = this.extent(e)[1];
+        return t != null ? e(t) : void 0
+    };
+    _n.quartile = function(e) {
+        return (this._get !== e || !this._q) && (this._q = B_(this.values(), e), this._get = e), this._q
+    };
+    _n.q1 = function(e) {
+        return this.quartile(e)[0]
+    };
+    _n.q2 = function(e) {
+        return this.quartile(e)[1]
+    };
+    _n.q3 = function(e) {
+        return this.quartile(e)[2]
+    };
+    _n.ci = function(e) {
+        return (this._get !== e || !this._ci) && (this._ci = TR(this.values(), 1e3, .05, e), this._get = e), this._ci
+    };
+    _n.ci0 = function(e) {
+        return this.ci(e)[0]
+    };
+    _n.ci1 = function(e) {
+        return this.ci(e)[1]
     };
-    const Zj = 2 * Math.PI,
-        Hl = Math.pow;
-
-    function eU(e) {
-        return e[0]
-    }
 
-    function tU(e) {
-        return e[1]
+    function Za(e) {
+        j.call(this, null, e), this._adds = [], this._mods = [], this._alen = 0, this._mlen = 0, this._drop = !0, this._cross = !1, this._dims = [], this._dnames = [], this._measures = [], this._countOnly = !1, this._counts = null, this._prev = null, this._inputs = null, this._outputs = null
     }
+    Za.Definition = {
+        type: "Aggregate",
+        metadata: {
+            generates: !0,
+            changes: !0
+        },
+        params: [{
+            name: "groupby",
+            type: "field",
+            array: !0
+        }, {
+            name: "ops",
+            type: "enum",
+            array: !0,
+            values: Od
+        }, {
+            name: "fields",
+            type: "field",
+            null: !0,
+            array: !0
+        }, {
+            name: "as",
+            type: "string",
+            null: !0,
+            array: !0
+        }, {
+            name: "drop",
+            type: "boolean",
+            default: !0
+        }, {
+            name: "cross",
+            type: "boolean",
+            default: !1
+        }, {
+            name: "key",
+            type: "field"
+        }]
+    };
+    ne(Za, j, {
+        transform(e, t) {
+            const n = this,
+                i = t.fork(t.NO_SOURCE | t.NO_FIELDS),
+                r = e.modified();
+            return n.stamp = i.stamp, n.value && (r || t.modified(n._inputs, !0)) ? (n._prev = n.value, n.value = r ? n.init(e) : Object.create(null), t.visit(t.SOURCE, s => n.add(s))) : (n.value = n.value || n.init(e), t.visit(t.REM, s => n.rem(s)), t.visit(t.ADD, s => n.add(s))), i.modifies(n._outputs), n._drop = e.drop !== !1, e.cross && n._dims.length > 1 && (n._drop = !1, n.cross()), t.clean() && n._drop && i.clean(!0).runAfter(() => this.clean()), n.changes(i)
+        },
+        cross() {
+            const e = this,
+                t = e.value,
+                n = e._dnames,
+                i = n.map(() => ({})),
+                r = n.length;
 
-    function nU(e) {
-        const {
-            triangles: t,
-            coords: n
-        } = e;
-        for (let i = 0; i < t.length; i += 3) {
-            const r = 2 * t[i],
-                s = 2 * t[i + 1],
-                a = 2 * t[i + 2];
-            if ((n[a] - n[r]) * (n[s + 1] - n[r + 1]) - (n[s] - n[r]) * (n[a + 1] - n[r + 1]) > 1e-10) return !1
-        }
-        return !0
-    }
+            function s(o) {
+                let l, u, c, f;
+                for (l in o)
+                    for (c = o[l].tuple, u = 0; u < r; ++u) i[u][f = c[n[u]]] = f
+            }
+            s(e._prev), s(t);
 
-    function iU(e, t, n) {
-        return [e + Math.sin(e + t) * n, t + Math.cos(e - t) * n]
-    }
-    class $x {
-        static from(t, n = eU, i = tU, r) {
-            return new $x("length" in t ? rU(t, n, i, r) : Float64Array.from(sU(t, n, i, r)))
-        }
-        constructor(t) {
-            this._delaunator = new $p(t), this.inedges = new Int32Array(t.length / 2), this._hullIndex = new Int32Array(t.length / 2), this.points = this._delaunator.coords, this._init()
-        }
-        update() {
-            return this._delaunator.update(), this._init(), this
-        }
-        _init() {
-            const t = this._delaunator,
-                n = this.points;
-            if (t.hull && t.hull.length > 2 && nU(t)) {
-                this.collinear = Int32Array.from({
-                    length: n.length / 2
-                }, (h, d) => d).sort((h, d) => n[2 * h] - n[2 * d] || n[2 * h + 1] - n[2 * d + 1]);
-                const l = this.collinear[0],
-                    u = this.collinear[this.collinear.length - 1],
-                    c = [n[2 * l], n[2 * l + 1], n[2 * u], n[2 * u + 1]],
-                    f = 1e-8 * Math.hypot(c[3] - c[1], c[2] - c[0]);
-                for (let h = 0, d = n.length / 2; h < d; ++h) {
-                    const g = iU(n[2 * h], n[2 * h + 1], f);
-                    n[2 * h] = g[0], n[2 * h + 1] = g[1]
+            function a(o, l, u) {
+                const c = n[u],
+                    f = i[u++];
+                for (const h in f) {
+                    const d = o ? o + "|" + h : h;
+                    l[c] = f[h], u < r ? a(d, l, u) : t[d] || e.cell(d, l)
                 }
-                this._delaunator = new $p(n)
-            } else delete this.collinear;
-            const i = this.halfedges = this._delaunator.halfedges,
-                r = this.hull = this._delaunator.hull,
-                s = this.triangles = this._delaunator.triangles,
-                a = this.inedges.fill(-1),
-                o = this._hullIndex.fill(-1);
-            for (let l = 0, u = i.length; l < u; ++l) {
-                const c = s[l % 3 === 2 ? l - 2 : l + 1];
-                (i[l] === -1 || a[c] === -1) && (a[c] = l)
             }
-            for (let l = 0, u = r.length; l < u; ++l) o[r[l]] = l;
-            r.length <= 2 && r.length > 0 && (this.triangles = new Int32Array(3).fill(-1), this.halfedges = new Int32Array(3).fill(-1), this.triangles[0] = r[0], a[r[0]] = 1, r.length === 2 && (a[r[1]] = 0, this.triangles[1] = r[1], this.triangles[2] = r[1]))
-        }
-        voronoi(t) {
-            return new Qj(this, t)
-        }* neighbors(t) {
-            const {
-                inedges: n,
-                hull: i,
-                _hullIndex: r,
-                halfedges: s,
-                triangles: a,
-                collinear: o
-            } = this;
-            if (o) {
-                const f = o.indexOf(t);
-                f > 0 && (yield o[f - 1]), f < o.length - 1 && (yield o[f + 1]);
-                return
+            a("", {}, 0)
+        },
+        init(e) {
+            const t = this._inputs = [],
+                n = this._outputs = [],
+                i = {};
+
+            function r(m) {
+                const y = ue(Fn(m)),
+                    v = y.length;
+                let b = 0,
+                    x;
+                for (; b < v; ++b) i[x = y[b]] || (i[x] = 1, t.push(x))
             }
-            const l = n[t];
-            if (l === -1) return;
-            let u = l,
-                c = -1;
-            do {
-                if (yield c = a[u], u = u % 3 === 2 ? u - 2 : u + 1, a[u] !== t) return;
-                if (u = s[u], u === -1) {
-                    const f = i[(r[t] + 1) % i.length];
-                    f !== c && (yield f);
-                    return
-                }
-            } while (u !== l)
-        }
-        find(t, n, i = 0) {
-            if (t = +t, t !== t || (n = +n, n !== n)) return -1;
-            const r = i;
-            let s;
-            for (;
-                (s = this._step(i, t, n)) >= 0 && s !== i && s !== r;) i = s;
-            return s
-        }
-        _step(t, n, i) {
-            const {
-                inedges: r,
-                hull: s,
-                _hullIndex: a,
-                halfedges: o,
-                triangles: l,
-                points: u
-            } = this;
-            if (r[t] === -1 || !u.length) return (t + 1) % (u.length >> 1);
-            let c = t,
-                f = Hl(n - u[t * 2], 2) + Hl(i - u[t * 2 + 1], 2);
-            const h = r[t];
-            let d = h;
-            do {
-                let g = l[d];
-                const p = Hl(n - u[g * 2], 2) + Hl(i - u[g * 2 + 1], 2);
-                if (p < f && (f = p, c = g), d = d % 3 === 2 ? d - 2 : d + 1, l[d] !== t) break;
-                if (d = o[d], d === -1) {
-                    if (d = s[(a[t] + 1) % s.length], d !== g && Hl(n - u[d * 2], 2) + Hl(i - u[d * 2 + 1], 2) < f) return d;
-                    break
+            this._dims = ue(e.groupby), this._dnames = this._dims.map(m => {
+                const y = Pt(m);
+                return r(m), n.push(y), y
+            }), this.cellkey = e.key ? e.key : Zb(this._dims), this._countOnly = !0, this._counts = [], this._measures = [];
+            const s = e.fields || [null],
+                a = e.ops || ["count"],
+                o = e.as || [],
+                l = s.length,
+                u = {};
+            let c, f, h, d, g, p;
+            for (l !== a.length && q("Unmatched number of fields and aggregate ops."), p = 0; p < l; ++p) {
+                if (c = s[p], f = a[p], c == null && f !== "count" && q("Null aggregate field specified."), d = Pt(c), g = BR(f, d, o[p]), n.push(g), f === "count") {
+                    this._counts.push(g);
+                    continue
                 }
-            } while (d !== h);
-            return c
-        }
-        render(t) {
-            const n = t == null ? t = new No : void 0,
-                {
-                    points: i,
-                    halfedges: r,
-                    triangles: s
-                } = this;
-            for (let a = 0, o = r.length; a < o; ++a) {
-                const l = r[a];
-                if (l < a) continue;
-                const u = s[a] * 2,
-                    c = s[l] * 2;
-                t.moveTo(i[u], i[u + 1]), t.lineTo(i[c], i[c + 1])
+                h = u[d], h || (r(c), h = u[d] = [], h.field = c, this._measures.push(h)), f !== "count" && (this._countOnly = !1), h.push(jR(f, g))
             }
-            return this.renderHull(t), n && n.value()
-        }
-        renderPoints(t, n) {
-            n === void 0 && (!t || typeof t.moveTo != "function") && (n = t, t = null), n = n == null ? 2 : +n;
-            const i = t == null ? t = new No : void 0,
-                {
-                    points: r
-                } = this;
-            for (let s = 0, a = r.length; s < a; s += 2) {
-                const o = r[s],
-                    l = r[s + 1];
-                t.moveTo(o + n, l), t.arc(o, l, n, 0, Zj)
+            return this._measures = this._measures.map(m => UR(m, m.field)), Object.create(null)
+        },
+        cellkey: Zb(),
+        cell(e, t) {
+            let n = this.value[e];
+            return n ? n.num === 0 && this._drop && n.stamp < this.stamp ? (n.stamp = this.stamp, this._adds[this._alen++] = n) : n.stamp < this.stamp && (n.stamp = this.stamp, this._mods[this._mlen++] = n) : (n = this.value[e] = this.newcell(e, t), this._adds[this._alen++] = n), n
+        },
+        newcell(e, t) {
+            const n = {
+                key: e,
+                num: 0,
+                agg: null,
+                tuple: this.newtuple(t, this._prev && this._prev[e]),
+                stamp: this.stamp,
+                store: !1
+            };
+            if (!this._countOnly) {
+                const i = this._measures,
+                    r = i.length;
+                n.agg = Array(r);
+                for (let s = 0; s < r; ++s) n.agg[s] = new i[s](n)
             }
-            return i && i.value()
-        }
-        renderHull(t) {
-            const n = t == null ? t = new No : void 0,
-                {
-                    hull: i,
-                    points: r
-                } = this,
-                s = i[0] * 2,
-                a = i.length;
-            t.moveTo(r[s], r[s + 1]);
-            for (let o = 1; o < a; ++o) {
-                const l = 2 * i[o];
-                t.lineTo(r[l], r[l + 1])
+            return n.store && (n.data = new nw), n
+        },
+        newtuple(e, t) {
+            const n = this._dnames,
+                i = this._dims,
+                r = i.length,
+                s = {};
+            for (let a = 0; a < r; ++a) s[n[a]] = i[a](e);
+            return t ? _R(t.tuple, s) : it(s)
+        },
+        clean() {
+            const e = this.value;
+            for (const t in e) e[t].num === 0 && delete e[t]
+        },
+        add(e) {
+            const t = this.cellkey(e),
+                n = this.cell(t, e);
+            if (n.num += 1, this._countOnly) return;
+            n.store && n.data.add(e);
+            const i = n.agg;
+            for (let r = 0, s = i.length; r < s; ++r) i[r].add(i[r].get(e), e)
+        },
+        rem(e) {
+            const t = this.cellkey(e),
+                n = this.cell(t, e);
+            if (n.num -= 1, this._countOnly) return;
+            n.store && n.data.rem(e);
+            const i = n.agg;
+            for (let r = 0, s = i.length; r < s; ++r) i[r].rem(i[r].get(e), e)
+        },
+        celltuple(e) {
+            const t = e.tuple,
+                n = this._counts;
+            e.store && e.data.values();
+            for (let i = 0, r = n.length; i < r; ++i) t[n[i]] = e.num;
+            if (!this._countOnly) {
+                const i = e.agg;
+                for (let r = 0, s = i.length; r < s; ++r) i[r].set(t)
             }
-            return t.closePath(), n && n.value()
-        }
-        hullPolygon() {
-            const t = new pb;
-            return this.renderHull(t), t.value()
+            return t
+        },
+        changes(e) {
+            const t = this._adds,
+                n = this._mods,
+                i = this._prev,
+                r = this._drop,
+                s = e.add,
+                a = e.rem,
+                o = e.mod;
+            let l, u, c, f;
+            if (i)
+                for (u in i) l = i[u], (!r || l.num) && a.push(l.tuple);
+            for (c = 0, f = this._alen; c < f; ++c) s.push(this.celltuple(t[c])), t[c] = null;
+            for (c = 0, f = this._mlen; c < f; ++c) l = n[c], (l.num === 0 && r ? a : o).push(this.celltuple(l)), n[c] = null;
+            return this._alen = this._mlen = 0, this._prev = null, e
         }
-        renderTriangle(t, n) {
-            const i = n == null ? n = new No : void 0,
-                {
-                    points: r,
-                    triangles: s
-                } = this,
-                a = s[t *= 3] * 2,
-                o = s[t + 1] * 2,
-                l = s[t + 2] * 2;
-            return n.moveTo(r[a], r[a + 1]), n.lineTo(r[o], r[o + 1]), n.lineTo(r[l], r[l + 1]), n.closePath(), i && i.value()
-        }* trianglePolygons() {
-            const {
-                triangles: t
-            } = this;
-            for (let n = 0, i = t.length / 3; n < i; ++n) yield this.trianglePolygon(n)
+    });
+    const cW = 1e-14;
+
+    function iw(e) {
+        j.call(this, null, e)
+    }
+    iw.Definition = {
+        type: "Bin",
+        metadata: {
+            modifies: !0
+        },
+        params: [{
+            name: "field",
+            type: "field",
+            required: !0
+        }, {
+            name: "interval",
+            type: "boolean",
+            default: !0
+        }, {
+            name: "anchor",
+            type: "number"
+        }, {
+            name: "maxbins",
+            type: "number",
+            default: 20
+        }, {
+            name: "base",
+            type: "number",
+            default: 10
+        }, {
+            name: "divide",
+            type: "number",
+            array: !0,
+            default: [5, 2]
+        }, {
+            name: "extent",
+            type: "number",
+            array: !0,
+            length: 2,
+            required: !0
+        }, {
+            name: "span",
+            type: "number"
+        }, {
+            name: "step",
+            type: "number"
+        }, {
+            name: "steps",
+            type: "number",
+            array: !0
+        }, {
+            name: "minstep",
+            type: "number",
+            default: 0
+        }, {
+            name: "nice",
+            type: "boolean",
+            default: !0
+        }, {
+            name: "name",
+            type: "string"
+        }, {
+            name: "as",
+            type: "string",
+            array: !0,
+            length: 2,
+            default: ["bin0", "bin1"]
+        }]
+    };
+    ne(iw, j, {
+        transform(e, t) {
+            const n = e.interval !== !1,
+                i = this._bins(e),
+                r = i.start,
+                s = i.step,
+                a = e.as || ["bin0", "bin1"],
+                o = a[0],
+                l = a[1];
+            let u;
+            return e.modified() ? (t = t.reflow(!0), u = t.SOURCE) : u = t.modified(Fn(e.field)) ? t.ADD_MOD : t.ADD, t.visit(u, n ? c => {
+                const f = i(c);
+                c[o] = f, c[l] = f == null ? null : r + s * (1 + (f - r) / s)
+            } : c => c[o] = i(c)), t.modifies(n ? a : o)
+        },
+        _bins(e) {
+            if (this.value && !e.modified()) return this.value;
+            const t = e.field,
+                n = $R(e),
+                i = n.step;
+            let r = n.start,
+                s = r + Math.ceil((n.stop - r) / i) * i,
+                a, o;
+            (a = e.anchor) != null && (o = a - (r + i * Math.floor((a - r) / i)), r += o, s += o);
+            const l = function(u) {
+                let c = Tn(t(u));
+                return c == null ? null : c < r ? -1 / 0 : c > s ? 1 / 0 : (c = Math.max(r, Math.min(c, s - i)), r + i * Math.floor(cW + (c - r) / i))
+            };
+            return l.start = r, l.stop = n.stop, l.step = i, this.value = vi(l, Fn(t), e.name || "bin_" + Pt(t))
         }
-        trianglePolygon(t) {
-            const n = new pb;
-            return this.renderTriangle(t, n), n.value()
+    });
+
+    function WR(e, t, n) {
+        const i = e;
+        let r = t || [],
+            s = n || [],
+            a = {},
+            o = 0;
+        return {
+            add: l => s.push(l),
+            remove: l => a[i(l)] = ++o,
+            size: () => r.length,
+            data: (l, u) => (o && (r = r.filter(c => !a[i(c)]), a = {}, o = 0), u && l && r.sort(l), s.length && (r = l ? fF(l, r, s.sort(l)) : r.concat(s), s = []), r)
         }
     }
 
-    function rU(e, t, n, i) {
-        const r = e.length,
-            s = new Float64Array(r * 2);
-        for (let a = 0; a < r; ++a) {
-            const o = e[a];
-            s[a * 2] = t.call(i, o, a, e), s[a * 2 + 1] = n.call(i, o, a, e)
+    function rw(e) {
+        j.call(this, [], e)
+    }
+    rw.Definition = {
+        type: "Collect",
+        metadata: {
+            source: !0
+        },
+        params: [{
+            name: "sort",
+            type: "compare"
+        }]
+    };
+    ne(rw, j, {
+        transform(e, t) {
+            const n = t.fork(t.ALL),
+                i = WR(Ee, this.value, n.materialize(n.ADD).add),
+                r = e.sort,
+                s = t.changed() || r && (e.modified("sort") || t.modified(r.fields));
+            return n.visit(n.REM, i.remove), this.modified(s), this.value = n.source = i.data(Yl(r), s), t.source && t.source.root && (this.value.root = t.source.root), n
         }
-        return s
+    });
+
+    function qR(e) {
+        dt.call(this, null, fW, e)
     }
+    ne(qR, dt);
 
-    function* sU(e, t, n, i) {
-        let r = 0;
-        for (const s of e) yield t.call(i, s, r, e), yield n.call(i, s, r, e), ++r
+    function fW(e) {
+        return this.value && !e.modified() ? this.value : v_(e.fields, e.orders)
     }
-    var qk = {},
-        ky = {},
-        Ay = 34,
-        Yc = 10,
-        $y = 13;
 
-    function YO(e) {
-        return new Function("d", "return {" + e.map(function(t, n) {
-            return JSON.stringify(t) + ": d[" + n + '] || ""'
-        }).join(",") + "}")
+    function sw(e) {
+        j.call(this, null, e)
     }
+    sw.Definition = {
+        type: "CountPattern",
+        metadata: {
+            generates: !0,
+            changes: !0
+        },
+        params: [{
+            name: "field",
+            type: "field",
+            required: !0
+        }, {
+            name: "case",
+            type: "enum",
+            values: ["upper", "lower", "mixed"],
+            default: "mixed"
+        }, {
+            name: "pattern",
+            type: "string",
+            default: '[\\w"]+'
+        }, {
+            name: "stopwords",
+            type: "string",
+            default: ""
+        }, {
+            name: "as",
+            type: "string",
+            array: !0,
+            length: 2,
+            default: ["text", "count"]
+        }]
+    };
 
-    function aU(e, t) {
-        var n = YO(e);
-        return function(i, r) {
-            return t(n(i), r, e)
+    function hW(e, t, n) {
+        switch (t) {
+            case "upper":
+                e = e.toUpperCase();
+                break;
+            case "lower":
+                e = e.toLowerCase();
+                break
         }
+        return e.match(n)
     }
+    ne(sw, j, {
+        transform(e, t) {
+            const n = f => h => {
+                    for (var d = hW(o(h), e.case, s) || [], g, p = 0, m = d.length; p < m; ++p) a.test(g = d[p]) || f(g)
+                },
+                i = this._parameterCheck(e, t),
+                r = this._counts,
+                s = this._match,
+                a = this._stop,
+                o = e.field,
+                l = e.as || ["text", "count"],
+                u = n(f => r[f] = 1 + (r[f] || 0)),
+                c = n(f => r[f] -= 1);
+            return i ? t.visit(t.SOURCE, u) : (t.visit(t.ADD, u), t.visit(t.REM, c)), this._finish(t, l)
+        },
+        _parameterCheck(e, t) {
+            let n = !1;
+            return (e.modified("stopwords") || !this._stop) && (this._stop = new RegExp("^" + (e.stopwords || "") + "$", "i"), n = !0), (e.modified("pattern") || !this._match) && (this._match = new RegExp(e.pattern || "[\\w']+", "g"), n = !0), (e.modified("field") || t.modified(e.field.fields)) && (n = !0), n && (this._counts = {}), n
+        },
+        _finish(e, t) {
+            const n = this._counts,
+                i = this._tuples || (this._tuples = {}),
+                r = t[0],
+                s = t[1],
+                a = e.fork(e.NO_SOURCE | e.NO_FIELDS);
+            let o, l, u;
+            for (o in n) l = i[o], u = n[o] || 0, !l && u ? (i[o] = l = it({}), l[r] = o, l[s] = u, a.add.push(l)) : u === 0 ? (l && a.rem.push(l), n[o] = null, i[o] = null) : l[s] !== u && (l[s] = u, a.mod.push(l));
+            return a.modifies(t)
+        }
+    });
 
-    function Hk(e) {
-        var t = Object.create(null),
-            n = [];
-        return e.forEach(function(i) {
-            for (var r in i) r in t || n.push(t[r] = r)
-        }), n
+    function aw(e) {
+        j.call(this, null, e)
     }
+    aw.Definition = {
+        type: "Cross",
+        metadata: {
+            generates: !0
+        },
+        params: [{
+            name: "filter",
+            type: "expr"
+        }, {
+            name: "as",
+            type: "string",
+            array: !0,
+            length: 2,
+            default: ["a", "b"]
+        }]
+    };
+    ne(aw, j, {
+        transform(e, t) {
+            const n = t.fork(t.NO_SOURCE),
+                i = e.as || ["a", "b"],
+                r = i[0],
+                s = i[1],
+                a = !this.value || t.changed(t.ADD_REM) || e.modified("as") || e.modified("filter");
+            let o = this.value;
+            return a ? (o && (n.rem = o), o = t.materialize(t.SOURCE).source, n.add = this.value = dW(o, r, s, e.filter || Yi)) : n.mod = o, n.source = this.value, n.modifies(i)
+        }
+    });
 
-    function Gn(e, t) {
-        var n = e + "",
-            i = n.length;
-        return i < t ? new Array(t - i + 1).join(0) + n : n
+    function dW(e, t, n, i) {
+        for (var r = [], s = {}, a = e.length, o = 0, l, u; o < a; ++o)
+            for (s[t] = u = e[o], l = 0; l < a; ++l) s[n] = e[l], i(s) && (r.push(it(s)), s = {}, s[t] = u);
+        return r
     }
-
-    function oU(e) {
-        return e < 0 ? "-" + Gn(-e, 6) : e > 9999 ? "+" + Gn(e, 6) : Gn(e, 4)
+    const LA = {
+            kde: W_,
+            mixture: RR,
+            normal: U_,
+            lognormal: FR,
+            uniform: DR
+        },
+        gW = "distributions",
+        IA = "function",
+        pW = "field";
+
+    function HR(e, t) {
+        const n = e[IA];
+        Ce(LA, n) || q("Unknown distribution function: " + n);
+        const i = LA[n]();
+        for (const r in e) r === pW ? i.data((e.from || t()).map(e[r])) : r === gW ? i[r](e[r].map(s => HR(s, t))) : typeof i[r] === IA && i[r](e[r]);
+        return i
     }
 
-    function lU(e) {
-        var t = e.getUTCHours(),
-            n = e.getUTCMinutes(),
-            i = e.getUTCSeconds(),
-            r = e.getUTCMilliseconds();
-        return isNaN(e) ? "Invalid Date" : oU(e.getUTCFullYear()) + "-" + Gn(e.getUTCMonth() + 1, 2) + "-" + Gn(e.getUTCDate(), 2) + (r ? "T" + Gn(t, 2) + ":" + Gn(n, 2) + ":" + Gn(i, 2) + "." + Gn(r, 3) + "Z" : i ? "T" + Gn(t, 2) + ":" + Gn(n, 2) + ":" + Gn(i, 2) + "Z" : n || t ? "T" + Gn(t, 2) + ":" + Gn(n, 2) + "Z" : "")
+    function ow(e) {
+        j.call(this, null, e)
     }
+    const YR = [{
+            key: {
+                function: "normal"
+            },
+            params: [{
+                name: "mean",
+                type: "number",
+                default: 0
+            }, {
+                name: "stdev",
+                type: "number",
+                default: 1
+            }]
+        }, {
+            key: {
+                function: "lognormal"
+            },
+            params: [{
+                name: "mean",
+                type: "number",
+                default: 0
+            }, {
+                name: "stdev",
+                type: "number",
+                default: 1
+            }]
+        }, {
+            key: {
+                function: "uniform"
+            },
+            params: [{
+                name: "min",
+                type: "number",
+                default: 0
+            }, {
+                name: "max",
+                type: "number",
+                default: 1
+            }]
+        }, {
+            key: {
+                function: "kde"
+            },
+            params: [{
+                name: "field",
+                type: "field",
+                required: !0
+            }, {
+                name: "from",
+                type: "data"
+            }, {
+                name: "bandwidth",
+                type: "number",
+                default: 0
+            }]
+        }],
+        mW = {
+            key: {
+                function: "mixture"
+            },
+            params: [{
+                name: "distributions",
+                type: "param",
+                array: !0,
+                params: YR
+            }, {
+                name: "weights",
+                type: "number",
+                array: !0
+            }]
+        };
+    ow.Definition = {
+        type: "Density",
+        metadata: {
+            generates: !0
+        },
+        params: [{
+            name: "extent",
+            type: "number",
+            array: !0,
+            length: 2
+        }, {
+            name: "steps",
+            type: "number"
+        }, {
+            name: "minsteps",
+            type: "number",
+            default: 25
+        }, {
+            name: "maxsteps",
+            type: "number",
+            default: 200
+        }, {
+            name: "method",
+            type: "string",
+            default: "pdf",
+            values: ["pdf", "cdf"]
+        }, {
+            name: "distribution",
+            type: "param",
+            params: YR.concat(mW)
+        }, {
+            name: "as",
+            type: "string",
+            array: !0,
+            default: ["value", "density"]
+        }]
+    };
+    ne(ow, j, {
+        transform(e, t) {
+            const n = t.fork(t.NO_SOURCE | t.NO_FIELDS);
+            if (!this.value || t.changed() || e.modified()) {
+                const i = HR(e.distribution, yW(t)),
+                    r = e.steps || e.minsteps || 25,
+                    s = e.steps || e.maxsteps || 200;
+                let a = e.method || "pdf";
+                a !== "pdf" && a !== "cdf" && q("Invalid density method: " + a), !e.extent && !i.data && q("Missing density extent parameter."), a = i[a];
+                const o = e.as || ["value", "density"],
+                    l = e.extent || ss(i.data()),
+                    u = n1(a, l, r, s).map(c => {
+                        const f = {};
+                        return f[o[0]] = c[0], f[o[1]] = c[1], it(f)
+                    });
+                this.value && (n.rem = this.value), this.value = n.add = n.source = u
+            }
+            return n
+        }
+    });
 
-    function uU(e) {
-        var t = new RegExp('["' + e + `
-\r]`),
-            n = e.charCodeAt(0);
+    function yW(e) {
+        return () => e.materialize(e.SOURCE).source
+    }
 
-        function i(f, h) {
-            var d, g, p = r(f, function(m, y) {
-                if (d) return d(m, y - 1);
-                g = m, d = h ? aU(m, h) : YO(m)
-            });
-            return p.columns = g || [], p
-        }
+    function XR(e, t) {
+        return e ? e.map((n, i) => t[i] || Pt(n)) : null
+    }
 
-        function r(f, h) {
-            var d = [],
-                g = f.length,
-                p = 0,
-                m = 0,
-                y, v = g <= 0,
-                b = !1;
-            f.charCodeAt(g - 1) === Yc && --g, f.charCodeAt(g - 1) === $y && --g;
+    function lw(e, t, n) {
+        const i = [],
+            r = f => f(l);
+        let s, a, o, l, u, c;
+        if (t == null) i.push(e.map(n));
+        else
+            for (s = {}, a = 0, o = e.length; a < o; ++a) l = e[a], u = t.map(r), c = s[u], c || (s[u] = c = [], c.dims = u, i.push(c)), c.push(n(l));
+        return i
+    }
+    const VR = "bin";
 
-            function x() {
-                if (v) return ky;
-                if (b) return b = !1, qk;
-                var S, w = p,
-                    E;
-                if (f.charCodeAt(w) === Ay) {
-                    for (; p++ < g && f.charCodeAt(p) !== Ay || f.charCodeAt(++p) === Ay;);
-                    return (S = p) >= g ? v = !0 : (E = f.charCodeAt(p++)) === Yc ? b = !0 : E === $y && (b = !0, f.charCodeAt(p) === Yc && ++p), f.slice(w + 1, S - 1).replace(/""/g, '"')
-                }
-                for (; p < g;) {
-                    if ((E = f.charCodeAt(S = p++)) === Yc) b = !0;
-                    else if (E === $y) b = !0, f.charCodeAt(p) === Yc && ++p;
-                    else if (E !== n) continue;
-                    return f.slice(w, S)
-                }
-                return v = !0, f.slice(w, g)
-            }
-            for (;
-                (y = x()) !== ky;) {
-                for (var _ = []; y !== qk && y !== ky;) _.push(y), y = x();
-                h && (_ = h(_, m++)) == null || d.push(_)
+    function uw(e) {
+        j.call(this, null, e)
+    }
+    uw.Definition = {
+        type: "DotBin",
+        metadata: {
+            modifies: !0
+        },
+        params: [{
+            name: "field",
+            type: "field",
+            required: !0
+        }, {
+            name: "groupby",
+            type: "field",
+            array: !0
+        }, {
+            name: "step",
+            type: "number"
+        }, {
+            name: "smooth",
+            type: "boolean",
+            default: !1
+        }, {
+            name: "as",
+            type: "string",
+            default: VR
+        }]
+    };
+    const vW = (e, t) => Cd(ss(e, t)) / 30;
+    ne(uw, j, {
+        transform(e, t) {
+            if (this.value && !(e.modified() || t.changed())) return t;
+            const n = t.materialize(t.SOURCE).source,
+                i = lw(t.source, e.groupby, Pn),
+                r = e.smooth || !1,
+                s = e.field,
+                a = e.step || vW(n, s),
+                o = Yl((g, p) => s(g) - s(p)),
+                l = e.as || VR,
+                u = i.length;
+            let c = 1 / 0,
+                f = -1 / 0,
+                h = 0,
+                d;
+            for (; h < u; ++h) {
+                const g = i[h].sort(o);
+                d = -1;
+                for (const p of MR(g, a, r, s)) p < c && (c = p), p > f && (f = p), g[++d][l] = p
             }
-            return d
-        }
-
-        function s(f, h) {
-            return f.map(function(d) {
-                return h.map(function(g) {
-                    return c(d[g])
-                }).join(e)
-            })
+            return this.value = {
+                start: c,
+                stop: f,
+                step: a
+            }, t.reflow(!0).modifies(l)
         }
+    });
 
-        function a(f, h) {
-            return h == null && (h = Hk(f)), [h.map(c).join(e)].concat(s(f, h)).join(`
-`)
-        }
+    function KR(e) {
+        dt.call(this, null, bW, e), this.modified(!0)
+    }
+    ne(KR, dt);
 
-        function o(f, h) {
-            return h == null && (h = Hk(f)), s(f, h).join(`
-`)
-        }
+    function bW(e) {
+        const t = e.expr;
+        return this.value && !e.modified("expr") ? this.value : vi(n => t(n, e), Fn(t), Pt(t))
+    }
 
-        function l(f) {
-            return f.map(u).join(`
-`)
+    function cw(e) {
+        j.call(this, [void 0, void 0], e)
+    }
+    cw.Definition = {
+        type: "Extent",
+        metadata: {},
+        params: [{
+            name: "field",
+            type: "field",
+            required: !0
+        }]
+    };
+    ne(cw, j, {
+        transform(e, t) {
+            const n = this.value,
+                i = e.field,
+                r = t.changed() || t.modified(i.fields) || e.modified("field");
+            let s = n[0],
+                a = n[1];
+            if ((r || s == null) && (s = 1 / 0, a = -1 / 0), t.visit(r ? t.SOURCE : t.ADD, o => {
+                    const l = Tn(i(o));
+                    l != null && (l < s && (s = l), l > a && (a = l))
+                }), !Number.isFinite(s) || !Number.isFinite(a)) {
+                let o = Pt(i);
+                o && (o = ` for field "${o}"`), t.dataflow.warn(`Infinite extent${o}: [${s}, ${a}]`), s = a = void 0
+            }
+            this.value = [s, a]
         }
+    });
 
-        function u(f) {
-            return f.map(c).join(e)
+    function fw(e, t) {
+        dt.call(this, e), this.parent = t, this.count = 0
+    }
+    ne(fw, dt, {
+        connect(e) {
+            return this.detachSubflow = e.detachSubflow, this.targets().add(e), e.source = this
+        },
+        add(e) {
+            this.count += 1, this.value.add.push(e)
+        },
+        rem(e) {
+            this.count -= 1, this.value.rem.push(e)
+        },
+        mod(e) {
+            this.value.mod.push(e)
+        },
+        init(e) {
+            this.value.init(e, e.NO_SOURCE)
+        },
+        evaluate() {
+            return this.value
         }
+    });
 
-        function c(f) {
-            return f == null ? "" : f instanceof Date ? lU(f) : t.test(f += "") ? '"' + f.replace(/"/g, '""') + '"' : f
-        }
-        return {
-            parse: i,
-            parseRows: r,
-            format: a,
-            formatBody: o,
-            formatRows: l,
-            formatRow: u,
-            formatValue: c
+    function i1(e) {
+        j.call(this, {}, e), this._keys = Uc();
+        const t = this._targets = [];
+        t.active = 0, t.forEach = n => {
+            for (let i = 0, r = t.active; i < r; ++i) n(t[i], i, t)
         }
     }
-
-    function cU(e, t) {
-        var n, i = 1;
-        e == null && (e = 0), t == null && (t = 0);
-
-        function r() {
-            var s, a = n.length,
-                o, l = 0,
-                u = 0;
-            for (s = 0; s < a; ++s) o = n[s], l += o.x, u += o.y;
-            for (l = (l / a - e) * i, u = (u / a - t) * i, s = 0; s < a; ++s) o = n[s], o.x -= l, o.y -= u
+    ne(i1, j, {
+        activate(e) {
+            this._targets[this._targets.active++] = e
+        },
+        subflow(e, t, n, i) {
+            const r = this.value;
+            let s = Ce(r, e) && r[e],
+                a, o;
+            return s ? s.value.stamp < n.stamp && (s.init(n), this.activate(s)) : (o = i || (o = this._group[e]) && o.tuple, a = n.dataflow, s = new fw(n.fork(n.NO_SOURCE), this), a.add(s).connect(t(a, e, o)), r[e] = s, this.activate(s)), s
+        },
+        clean() {
+            const e = this.value;
+            let t = 0;
+            for (const n in e)
+                if (e[n].count === 0) {
+                    const i = e[n].detachSubflow;
+                    i && i(), delete e[n], ++t
+                } if (t) {
+                const n = this._targets.filter(i => i && i.count > 0);
+                this.initTargets(n)
+            }
+        },
+        initTargets(e) {
+            const t = this._targets,
+                n = t.length,
+                i = e ? e.length : 0;
+            let r = 0;
+            for (; r < i; ++r) t[r] = e[r];
+            for (; r < n && t[r] != null; ++r) t[r] = null;
+            t.active = i
+        },
+        transform(e, t) {
+            const n = t.dataflow,
+                i = e.key,
+                r = e.subflow,
+                s = this._keys,
+                a = e.modified("key"),
+                o = l => this.subflow(l, r, t);
+            return this._group = e.group || {}, this.initTargets(), t.visit(t.REM, l => {
+                const u = Ee(l),
+                    c = s.get(u);
+                c !== void 0 && (s.delete(u), o(c).rem(l))
+            }), t.visit(t.ADD, l => {
+                const u = i(l);
+                s.set(Ee(l), u), o(u).add(l)
+            }), a || t.modified(i.fields) ? t.visit(t.MOD, l => {
+                const u = Ee(l),
+                    c = s.get(u),
+                    f = i(l);
+                c === f ? o(f).mod(l) : (s.set(u, f), o(c).rem(l), o(f).add(l))
+            }) : t.changed(t.MOD) && t.visit(t.MOD, l => {
+                o(s.get(Ee(l))).mod(l)
+            }), a && t.visit(t.REFLOW, l => {
+                const u = Ee(l),
+                    c = s.get(u),
+                    f = i(l);
+                c !== f && (s.set(u, f), o(c).rem(l), o(f).add(l))
+            }), t.clean() ? n.runAfter(() => {
+                this.clean(), s.clean()
+            }) : s.empty > n.cleanThreshold && n.runAfter(s.clean), t
         }
-        return r.initialize = function(s) {
-            n = s
-        }, r.x = function(s) {
-            return arguments.length ? (e = +s, r) : e
-        }, r.y = function(s) {
-            return arguments.length ? (t = +s, r) : t
-        }, r.strength = function(s) {
-            return arguments.length ? (i = +s, r) : i
-        }, r
-    }
+    });
 
-    function fU(e) {
-        const t = +this._x.call(null, e),
-            n = +this._y.call(null, e);
-        return XO(this.cover(t, n), t, n, e)
+    function JR(e) {
+        dt.call(this, null, xW, e)
     }
+    ne(JR, dt);
 
-    function XO(e, t, n, i) {
-        if (isNaN(t) || isNaN(n)) return e;
-        var r, s = e._root,
-            a = {
-                data: i
-            },
-            o = e._x0,
-            l = e._y0,
-            u = e._x1,
-            c = e._y1,
-            f, h, d, g, p, m, y, v;
-        if (!s) return e._root = a, e;
-        for (; s.length;)
-            if ((p = t >= (f = (o + u) / 2)) ? o = f : u = f, (m = n >= (h = (l + c) / 2)) ? l = h : c = h, r = s, !(s = s[y = m << 1 | p])) return r[y] = a, e;
-        if (d = +e._x.call(null, s.data), g = +e._y.call(null, s.data), t === d && n === g) return a.next = s, r ? r[y] = a : e._root = a, e;
-        do r = r ? r[y] = new Array(4) : e._root = new Array(4), (p = t >= (f = (o + u) / 2)) ? o = f : u = f, (m = n >= (h = (l + c) / 2)) ? l = h : c = h; while ((y = m << 1 | p) === (v = (g >= h) << 1 | d >= f));
-        return r[v] = s, r[y] = a, e
+    function xW(e) {
+        return this.value && !e.modified() ? this.value : H(e.name) ? ue(e.name).map(t => fi(t)) : fi(e.name, e.as)
     }
 
-    function hU(e) {
-        var t, n, i = e.length,
-            r, s, a = new Array(i),
-            o = new Array(i),
-            l = 1 / 0,
-            u = 1 / 0,
-            c = -1 / 0,
-            f = -1 / 0;
-        for (n = 0; n < i; ++n) isNaN(r = +this._x.call(null, t = e[n])) || isNaN(s = +this._y.call(null, t)) || (a[n] = r, o[n] = s, r < l && (l = r), r > c && (c = r), s < u && (u = s), s > f && (f = s));
-        if (l > c || u > f) return this;
-        for (this.cover(l, u).cover(c, f), n = 0; n < i; ++n) XO(this, a[n], o[n], e[n]);
-        return this
+    function hw(e) {
+        j.call(this, Uc(), e)
     }
+    hw.Definition = {
+        type: "Filter",
+        metadata: {
+            changes: !0
+        },
+        params: [{
+            name: "expr",
+            type: "expr",
+            required: !0
+        }]
+    };
+    ne(hw, j, {
+        transform(e, t) {
+            const n = t.dataflow,
+                i = this.value,
+                r = t.fork(),
+                s = r.add,
+                a = r.rem,
+                o = r.mod,
+                l = e.expr;
+            let u = !0;
+            t.visit(t.REM, f => {
+                const h = Ee(f);
+                i.has(h) ? i.delete(h) : a.push(f)
+            }), t.visit(t.ADD, f => {
+                l(f, e) ? s.push(f) : i.set(Ee(f), 1)
+            });
 
-    function dU(e, t) {
-        if (isNaN(e = +e) || isNaN(t = +t)) return this;
-        var n = this._x0,
-            i = this._y0,
-            r = this._x1,
-            s = this._y1;
-        if (isNaN(n)) r = (n = Math.floor(e)) + 1, s = (i = Math.floor(t)) + 1;
-        else {
-            for (var a = r - n || 1, o = this._root, l, u; n > e || e >= r || i > t || t >= s;) switch (u = (t < i) << 1 | e < n, l = new Array(4), l[u] = o, o = l, a *= 2, u) {
-                case 0:
-                    r = n + a, s = i + a;
-                    break;
-                case 1:
-                    n = r - a, s = i + a;
-                    break;
-                case 2:
-                    r = n + a, i = s - a;
-                    break;
-                case 3:
-                    n = r - a, i = s - a;
-                    break
+            function c(f) {
+                const h = Ee(f),
+                    d = l(f, e),
+                    g = i.get(h);
+                d && g ? (i.delete(h), s.push(f)) : !d && !g ? (i.set(h, 1), a.push(f)) : u && d && !g && o.push(f)
             }
-            this._root && this._root.length && (this._root = o)
+            return t.visit(t.MOD, c), e.modified() && (u = !1, t.visit(t.REFLOW, c)), i.empty > n.cleanThreshold && n.runAfter(i.clean), r
         }
-        return this._x0 = n, this._y0 = i, this._x1 = r, this._y1 = s, this
-    }
+    });
 
-    function gU() {
-        var e = [];
-        return this.visit(function(t) {
-            if (!t.length)
-                do e.push(t.data); while (t = t.next)
-        }), e
+    function dw(e) {
+        j.call(this, [], e)
     }
+    dw.Definition = {
+        type: "Flatten",
+        metadata: {
+            generates: !0
+        },
+        params: [{
+            name: "fields",
+            type: "field",
+            array: !0,
+            required: !0
+        }, {
+            name: "index",
+            type: "string"
+        }, {
+            name: "as",
+            type: "string",
+            array: !0
+        }]
+    };
+    ne(dw, j, {
+        transform(e, t) {
+            const n = t.fork(t.NO_SOURCE),
+                i = e.fields,
+                r = XR(i, e.as || []),
+                s = e.index || null,
+                a = r.length;
+            return n.rem = this.value, t.visit(t.SOURCE, o => {
+                const l = i.map(g => g(o)),
+                    u = l.reduce((g, p) => Math.max(g, p.length), 0);
+                let c = 0,
+                    f, h, d;
+                for (; c < u; ++c) {
+                    for (h = P_(o), f = 0; f < a; ++f) h[r[f]] = (d = l[f][c]) == null ? null : d;
+                    s && (h[s] = c), n.add.push(h)
+                }
+            }), this.value = n.source = n.add, s && n.modifies(s), n.modifies(r)
+        }
+    });
 
-    function pU(e) {
-        return arguments.length ? this.cover(+e[0][0], +e[0][1]).cover(+e[1][0], +e[1][1]) : isNaN(this._x0) ? void 0 : [
-            [this._x0, this._y0],
-            [this._x1, this._y1]
-        ]
+    function gw(e) {
+        j.call(this, [], e)
     }
+    gw.Definition = {
+        type: "Fold",
+        metadata: {
+            generates: !0
+        },
+        params: [{
+            name: "fields",
+            type: "field",
+            array: !0,
+            required: !0
+        }, {
+            name: "as",
+            type: "string",
+            array: !0,
+            length: 2,
+            default: ["key", "value"]
+        }]
+    };
+    ne(gw, j, {
+        transform(e, t) {
+            const n = t.fork(t.NO_SOURCE),
+                i = e.fields,
+                r = i.map(Pt),
+                s = e.as || ["key", "value"],
+                a = s[0],
+                o = s[1],
+                l = i.length;
+            return n.rem = this.value, t.visit(t.SOURCE, u => {
+                for (let c = 0, f; c < l; ++c) f = P_(u), f[a] = r[c], f[o] = i[c](u), n.add.push(f)
+            }), this.value = n.source = n.add, n.modifies(s)
+        }
+    });
 
-    function On(e, t, n, i, r) {
-        this.node = e, this.x0 = t, this.y0 = n, this.x1 = i, this.y1 = r
+    function pw(e) {
+        j.call(this, null, e)
     }
+    pw.Definition = {
+        type: "Formula",
+        metadata: {
+            modifies: !0
+        },
+        params: [{
+            name: "expr",
+            type: "expr",
+            required: !0
+        }, {
+            name: "as",
+            type: "string",
+            required: !0
+        }, {
+            name: "initonly",
+            type: "boolean"
+        }]
+    };
+    ne(pw, j, {
+        transform(e, t) {
+            const n = e.expr,
+                i = e.as,
+                r = e.modified(),
+                s = e.initonly ? t.ADD : r ? t.SOURCE : t.modified(n.fields) || t.modified(i) ? t.ADD_MOD : t.ADD;
+            return r && (t = t.materialize().reflow(!0)), e.initonly || t.modifies(i), t.visit(s, a => a[i] = n(a, e))
+        }
+    });
 
-    function mU(e, t, n) {
-        var i, r = this._x0,
-            s = this._y0,
-            a, o, l, u, c = this._x1,
-            f = this._y1,
-            h = [],
-            d = this._root,
-            g, p;
-        for (d && h.push(new On(d, r, s, c, f)), n == null ? n = 1 / 0 : (r = e - n, s = t - n, c = e + n, f = t + n, n *= n); g = h.pop();)
-            if (!(!(d = g.node) || (a = g.x0) > c || (o = g.y0) > f || (l = g.x1) < r || (u = g.y1) < s))
-                if (d.length) {
-                    var m = (a + l) / 2,
-                        y = (o + u) / 2;
-                    h.push(new On(d[3], m, y, l, u), new On(d[2], a, y, m, u), new On(d[1], m, o, l, y), new On(d[0], a, o, m, y)), (p = (t >= y) << 1 | e >= m) && (g = h[h.length - 1], h[h.length - 1] = h[h.length - 1 - p], h[h.length - 1 - p] = g)
-                } else {
-                    var v = e - +this._x.call(null, d.data),
-                        b = t - +this._y.call(null, d.data),
-                        x = v * v + b * b;
-                    if (x < n) {
-                        var _ = Math.sqrt(n = x);
-                        r = e - _, s = t - _, c = e + _, f = t + _, i = d.data
-                    }
-                } return i
+    function QR(e) {
+        j.call(this, [], e)
     }
+    ne(QR, j, {
+        transform(e, t) {
+            const n = t.fork(t.ALL),
+                i = e.generator;
+            let r = this.value,
+                s = e.size - r.length,
+                a, o, l;
+            if (s > 0) {
+                for (a = []; --s >= 0;) a.push(l = it(i(e))), r.push(l);
+                n.add = n.add.length ? n.materialize(n.ADD).add.concat(a) : a
+            } else o = r.slice(0, -s), n.rem = n.rem.length ? n.materialize(n.REM).rem.concat(o) : o, r = r.slice(-s);
+            return n.source = this.value = r, n
+        }
+    });
+    const Sg = {
+            value: "value",
+            median: EF,
+            mean: sj,
+            min: Gb,
+            max: cl
+        },
+        _W = [];
 
-    function yU(e) {
-        if (isNaN(c = +this._x.call(null, e)) || isNaN(f = +this._y.call(null, e))) return this;
-        var t, n = this._root,
-            i, r, s, a = this._x0,
-            o = this._y0,
-            l = this._x1,
-            u = this._y1,
-            c, f, h, d, g, p, m, y;
-        if (!n) return this;
-        if (n.length)
-            for (;;) {
-                if ((g = c >= (h = (a + l) / 2)) ? a = h : l = h, (p = f >= (d = (o + u) / 2)) ? o = d : u = d, t = n, !(n = n[m = p << 1 | g])) return this;
-                if (!n.length) break;
-                (t[m + 1 & 3] || t[m + 2 & 3] || t[m + 3 & 3]) && (i = t, y = m)
-            }
-        for (; n.data !== e;)
-            if (r = n, !(n = n.next)) return this;
-        return (s = n.next) && delete n.next, r ? (s ? r.next = s : delete r.next, this) : t ? (s ? t[m] = s : delete t[m], (n = t[0] || t[1] || t[2] || t[3]) && n === (t[3] || t[2] || t[1] || t[0]) && !n.length && (i ? i[y] = n : this._root = n), this) : (this._root = s, this)
+    function mw(e) {
+        j.call(this, [], e)
     }
+    mw.Definition = {
+        type: "Impute",
+        metadata: {
+            changes: !0
+        },
+        params: [{
+            name: "field",
+            type: "field",
+            required: !0
+        }, {
+            name: "key",
+            type: "field",
+            required: !0
+        }, {
+            name: "keyvals",
+            array: !0
+        }, {
+            name: "groupby",
+            type: "field",
+            array: !0
+        }, {
+            name: "method",
+            type: "enum",
+            default: "value",
+            values: ["value", "mean", "median", "max", "min"]
+        }, {
+            name: "value",
+            default: 0
+        }]
+    };
 
-    function vU(e) {
-        for (var t = 0, n = e.length; t < n; ++t) this.remove(e[t]);
-        return this
+    function wW(e) {
+        var t = e.method || Sg.value,
+            n;
+        if (Sg[t] == null) q("Unrecognized imputation method: " + t);
+        else return t === Sg.value ? (n = e.value !== void 0 ? e.value : 0, () => n) : Sg[t]
     }
 
-    function bU() {
-        return this._root
+    function SW(e) {
+        const t = e.field;
+        return n => n ? t(n) : NaN
     }
+    ne(mw, j, {
+        transform(e, t) {
+            var n = t.fork(t.ALL),
+                i = wW(e),
+                r = SW(e),
+                s = Pt(e.field),
+                a = Pt(e.key),
+                o = (e.groupby || []).map(Pt),
+                l = EW(t.source, e.groupby, e.key, e.keyvals),
+                u = [],
+                c = this.value,
+                f = l.domain.length,
+                h, d, g, p, m, y, v, b, x, _;
+            for (m = 0, b = l.length; m < b; ++m)
+                for (h = l[m], g = h.values, d = NaN, v = 0; v < f; ++v)
+                    if (h[v] == null) {
+                        for (p = l.domain[v], _ = {
+                                _impute: !0
+                            }, y = 0, x = g.length; y < x; ++y) _[o[y]] = g[y];
+                        _[a] = p, _[s] = Number.isNaN(d) ? d = i(h, r) : d, u.push(it(_))
+                    } return u.length && (n.add = n.materialize(n.ADD).add.concat(u)), c.length && (n.rem = n.materialize(n.REM).rem.concat(c)), this.value = u, n
+        }
+    });
 
-    function xU() {
-        var e = 0;
-        return this.visit(function(t) {
-            if (!t.length)
-                do ++e; while (t = t.next)
-        }), e
+    function EW(e, t, n, i) {
+        var r = y => y(m),
+            s = [],
+            a = i ? i.slice() : [],
+            o = {},
+            l = {},
+            u, c, f, h, d, g, p, m;
+        for (a.forEach((y, v) => o[y] = v + 1), h = 0, p = e.length; h < p; ++h) m = e[h], g = n(m), d = o[g] || (o[g] = a.push(g)), c = (u = t ? t.map(r) : _W) + "", (f = l[c]) || (f = l[c] = [], s.push(f), f.values = u), f[d - 1] = m;
+        return s.domain = a, s
     }
 
-    function _U(e) {
-        var t = [],
-            n, i = this._root,
-            r, s, a, o, l;
-        for (i && t.push(new On(i, this._x0, this._y0, this._x1, this._y1)); n = t.pop();)
-            if (!e(i = n.node, s = n.x0, a = n.y0, o = n.x1, l = n.y1) && i.length) {
-                var u = (s + o) / 2,
-                    c = (a + l) / 2;
-                (r = i[3]) && t.push(new On(r, u, c, o, l)), (r = i[2]) && t.push(new On(r, s, c, u, l)), (r = i[1]) && t.push(new On(r, u, a, o, c)), (r = i[0]) && t.push(new On(r, s, a, u, c))
-            } return this
+    function yw(e) {
+        Za.call(this, e)
     }
-
-    function wU(e) {
-        var t = [],
-            n = [],
-            i;
-        for (this._root && t.push(new On(this._root, this._x0, this._y0, this._x1, this._y1)); i = t.pop();) {
-            var r = i.node;
-            if (r.length) {
-                var s, a = i.x0,
-                    o = i.y0,
-                    l = i.x1,
-                    u = i.y1,
-                    c = (a + l) / 2,
-                    f = (o + u) / 2;
-                (s = r[0]) && t.push(new On(s, a, o, c, f)), (s = r[1]) && t.push(new On(s, c, o, l, f)), (s = r[2]) && t.push(new On(s, a, f, c, u)), (s = r[3]) && t.push(new On(s, c, f, l, u))
-            }
-            n.push(i)
+    yw.Definition = {
+        type: "JoinAggregate",
+        metadata: {
+            modifies: !0
+        },
+        params: [{
+            name: "groupby",
+            type: "field",
+            array: !0
+        }, {
+            name: "fields",
+            type: "field",
+            null: !0,
+            array: !0
+        }, {
+            name: "ops",
+            type: "enum",
+            array: !0,
+            values: Od
+        }, {
+            name: "as",
+            type: "string",
+            null: !0,
+            array: !0
+        }, {
+            name: "key",
+            type: "field"
+        }]
+    };
+    ne(yw, Za, {
+        transform(e, t) {
+            const n = this,
+                i = e.modified();
+            let r;
+            return n.value && (i || t.modified(n._inputs, !0)) ? (r = n.value = i ? n.init(e) : {}, t.visit(t.SOURCE, s => n.add(s))) : (r = n.value = n.value || this.init(e), t.visit(t.REM, s => n.rem(s)), t.visit(t.ADD, s => n.add(s))), n.changes(), t.visit(t.SOURCE, s => {
+                Ne(s, r[n.cellkey(s)].tuple)
+            }), t.reflow(i).modifies(this._outputs)
+        },
+        changes() {
+            const e = this._adds,
+                t = this._mods;
+            let n, i;
+            for (n = 0, i = this._alen; n < i; ++n) this.celltuple(e[n]), e[n] = null;
+            for (n = 0, i = this._mlen; n < i; ++n) this.celltuple(t[n]), t[n] = null;
+            this._alen = this._mlen = 0
         }
-        for (; i = n.pop();) e(i.node, i.x0, i.y0, i.x1, i.y1);
-        return this
-    }
+    });
 
-    function SU(e) {
-        return e[0]
+    function vw(e) {
+        j.call(this, null, e)
     }
+    vw.Definition = {
+        type: "KDE",
+        metadata: {
+            generates: !0
+        },
+        params: [{
+            name: "groupby",
+            type: "field",
+            array: !0
+        }, {
+            name: "field",
+            type: "field",
+            required: !0
+        }, {
+            name: "cumulative",
+            type: "boolean",
+            default: !1
+        }, {
+            name: "counts",
+            type: "boolean",
+            default: !1
+        }, {
+            name: "bandwidth",
+            type: "number",
+            default: 0
+        }, {
+            name: "extent",
+            type: "number",
+            array: !0,
+            length: 2
+        }, {
+            name: "resolve",
+            type: "enum",
+            values: ["shared", "independent"],
+            default: "independent"
+        }, {
+            name: "steps",
+            type: "number"
+        }, {
+            name: "minsteps",
+            type: "number",
+            default: 25
+        }, {
+            name: "maxsteps",
+            type: "number",
+            default: 200
+        }, {
+            name: "as",
+            type: "string",
+            array: !0,
+            default: ["value", "density"]
+        }]
+    };
+    ne(vw, j, {
+        transform(e, t) {
+            const n = t.fork(t.NO_SOURCE | t.NO_FIELDS);
+            if (!this.value || t.changed() || e.modified()) {
+                const i = t.materialize(t.SOURCE).source,
+                    r = lw(i, e.groupby, e.field),
+                    s = (e.groupby || []).map(Pt),
+                    a = e.bandwidth,
+                    o = e.cumulative ? "cdf" : "pdf",
+                    l = e.as || ["value", "density"],
+                    u = [];
+                let c = e.extent,
+                    f = e.steps || e.minsteps || 25,
+                    h = e.steps || e.maxsteps || 200;
+                o !== "pdf" && o !== "cdf" && q("Invalid density method: " + o), e.resolve === "shared" && (c || (c = ss(i, e.field)), f = h = e.steps || h), r.forEach(d => {
+                    const g = W_(d, a)[o],
+                        p = e.counts ? d.length : 1,
+                        m = c || ss(d);
+                    n1(g, m, f, h).forEach(y => {
+                        const v = {};
+                        for (let b = 0; b < s.length; ++b) v[s[b]] = d.dims[b];
+                        v[l[0]] = y[0], v[l[1]] = y[1] * p, u.push(it(v))
+                    })
+                }), this.value && (n.rem = this.value), this.value = n.add = n.source = u
+            }
+            return n
+        }
+    });
 
-    function EU(e) {
-        return arguments.length ? (this._x = e, this) : this._x
+    function ZR(e) {
+        dt.call(this, null, kW, e)
     }
+    ne(ZR, dt);
 
-    function CU(e) {
-        return e[1]
+    function kW(e) {
+        return this.value && !e.modified() ? this.value : x_(e.fields, e.flat)
     }
 
-    function kU(e) {
-        return arguments.length ? (this._y = e, this) : this._y
+    function eD(e) {
+        j.call(this, [], e), this._pending = null
     }
+    ne(eD, j, {
+        transform(e, t) {
+            const n = t.dataflow;
+            return this._pending ? sv(this, t, this._pending) : CW(e) ? t.StopPropagation : e.values ? sv(this, t, n.parse(e.values, e.format)) : e.async ? {
+                async: n.request(e.url, e.format).then(r => (this._pending = ue(r.data), s => s.touch(this)))
+            } : n.request(e.url, e.format).then(i => sv(this, t, ue(i.data)))
+        }
+    });
 
-    function Tx(e, t, n) {
-        var i = new Mx(t ?? SU, n ?? CU, NaN, NaN, NaN, NaN);
-        return e == null ? i : i.addAll(e)
+    function CW(e) {
+        return e.modified("async") && !(e.modified("values") || e.modified("url") || e.modified("format"))
     }
 
-    function Mx(e, t, n, i, r, s) {
-        this._x = e, this._y = t, this._x0 = n, this._y0 = i, this._x1 = r, this._y1 = s, this._root = void 0
+    function sv(e, t, n) {
+        n.forEach(it);
+        const i = t.fork(t.NO_FIELDS & t.NO_SOURCE);
+        return i.rem = e.value, e.value = i.source = i.add = n, e._pending = null, i.rem.length && i.clean(!0), i
     }
 
-    function Yk(e) {
-        for (var t = {
-                data: e.data
-            }, n = t; e = e.next;) n = n.next = {
-            data: e.data
-        };
-        return t
+    function bw(e) {
+        j.call(this, {}, e)
     }
-    var Bn = Tx.prototype = Mx.prototype;
-    Bn.copy = function() {
-        var e = new Mx(this._x, this._y, this._x0, this._y0, this._x1, this._y1),
-            t = this._root,
-            n, i;
-        if (!t) return e;
-        if (!t.length) return e._root = Yk(t), e;
-        for (n = [{
-                source: t,
-                target: e._root = new Array(4)
-            }]; t = n.pop();)
-            for (var r = 0; r < 4; ++r)(i = t.source[r]) && (i.length ? n.push({
-                source: i,
-                target: t.target[r] = new Array(4)
-            }) : t.target[r] = Yk(i));
-        return e
+    bw.Definition = {
+        type: "Lookup",
+        metadata: {
+            modifies: !0
+        },
+        params: [{
+            name: "index",
+            type: "index",
+            params: [{
+                name: "from",
+                type: "data",
+                required: !0
+            }, {
+                name: "key",
+                type: "field",
+                required: !0
+            }]
+        }, {
+            name: "values",
+            type: "field",
+            array: !0
+        }, {
+            name: "fields",
+            type: "field",
+            array: !0,
+            required: !0
+        }, {
+            name: "as",
+            type: "string",
+            array: !0
+        }, {
+            name: "default",
+            default: null
+        }]
     };
-    Bn.add = fU;
-    Bn.addAll = hU;
-    Bn.cover = dU;
-    Bn.data = gU;
-    Bn.extent = pU;
-    Bn.find = mU;
-    Bn.remove = yU;
-    Bn.removeAll = vU;
-    Bn.root = bU;
-    Bn.size = xU;
-    Bn.visit = _U;
-    Bn.visitAfter = wU;
-    Bn.x = EU;
-    Bn.y = kU;
-
-    function Fn(e) {
-        return function() {
-            return e
+    ne(bw, j, {
+        transform(e, t) {
+            const n = e.fields,
+                i = e.index,
+                r = e.values,
+                s = e.default == null ? null : e.default,
+                a = e.modified(),
+                o = n.length;
+            let l = a ? t.SOURCE : t.ADD,
+                u = t,
+                c = e.as,
+                f, h, d;
+            return r ? (h = r.length, o > 1 && !c && q('Multi-field lookup requires explicit "as" parameter.'), c && c.length !== o * h && q('The "as" parameter has too few output field names.'), c = c || r.map(Pt), f = function(g) {
+                for (var p = 0, m = 0, y, v; p < o; ++p)
+                    if (v = i.get(n[p](g)), v == null)
+                        for (y = 0; y < h; ++y, ++m) g[c[m]] = s;
+                    else
+                        for (y = 0; y < h; ++y, ++m) g[c[m]] = r[y](v)
+            }) : (c || q("Missing output field names."), f = function(g) {
+                for (var p = 0, m; p < o; ++p) m = i.get(n[p](g)), g[c[p]] = m ?? s
+            }), a ? u = t.reflow(!0) : (d = n.some(g => t.modified(g.fields)), l |= d ? t.MOD : 0), t.visit(l, f), u.modifies(c)
         }
-    }
+    });
 
-    function da(e) {
-        return (e() - .5) * 1e-6
+    function tD(e) {
+        dt.call(this, null, AW, e)
     }
+    ne(tD, dt);
 
-    function AU(e) {
-        return e.x + e.vx
+    function AW(e) {
+        if (this.value && !e.modified()) return this.value;
+        const t = e.extents,
+            n = t.length;
+        let i = 1 / 0,
+            r = -1 / 0,
+            s, a;
+        for (s = 0; s < n; ++s) a = t[s], a[0] < i && (i = a[0]), a[1] > r && (r = a[1]);
+        return [i, r]
     }
 
-    function $U(e) {
-        return e.y + e.vy
+    function nD(e) {
+        dt.call(this, null, $W, e)
     }
+    ne(nD, dt);
 
-    function TU(e) {
-        var t, n, i, r = 1,
-            s = 1;
-        typeof e != "function" && (e = Fn(e == null ? 1 : +e));
-
-        function a() {
-            for (var u, c = t.length, f, h, d, g, p, m, y = 0; y < s; ++y)
-                for (f = Tx(t, AU, $U).visitAfter(o), u = 0; u < c; ++u) h = t[u], p = n[h.index], m = p * p, d = h.x + h.vx, g = h.y + h.vy, f.visit(v);
+    function $W(e) {
+        return this.value && !e.modified() ? this.value : e.values.reduce((t, n) => t.concat(n), [])
+    }
 
-            function v(b, x, _, S, w) {
-                var E = b.data,
-                    A = b.r,
-                    C = p + A;
-                if (E) {
-                    if (E.index > h.index) {
-                        var k = d - E.x - E.vx,
-                            R = g - E.y - E.vy,
-                            $ = k * k + R * R;
-                        $ < C * C && (k === 0 && (k = da(i), $ += k * k), R === 0 && (R = da(i), $ += R * R), $ = (C - ($ = Math.sqrt($))) / $ * r, h.vx += (k *= $) * (C = (A *= A) / (m + A)), h.vy += (R *= $) * C, E.vx -= k * (C = 1 - C), E.vy -= R * C)
-                    }
-                    return
-                }
-                return x > d + C || S < d - C || _ > g + C || w < g - C
-            }
+    function iD(e) {
+        j.call(this, null, e)
+    }
+    ne(iD, j, {
+        transform(e, t) {
+            return this.modified(e.modified()), this.value = e, t.fork(t.NO_SOURCE | t.NO_FIELDS)
         }
+    });
 
-        function o(u) {
-            if (u.data) return u.r = n[u.data.index];
-            for (var c = u.r = 0; c < 4; ++c) u[c] && u[c].r > u.r && (u.r = u[c].r)
+    function xw(e) {
+        Za.call(this, e)
+    }
+    xw.Definition = {
+        type: "Pivot",
+        metadata: {
+            generates: !0,
+            changes: !0
+        },
+        params: [{
+            name: "groupby",
+            type: "field",
+            array: !0
+        }, {
+            name: "field",
+            type: "field",
+            required: !0
+        }, {
+            name: "value",
+            type: "field",
+            required: !0
+        }, {
+            name: "op",
+            type: "enum",
+            values: Od,
+            default: "sum"
+        }, {
+            name: "limit",
+            type: "number",
+            default: 0
+        }, {
+            name: "key",
+            type: "field"
+        }]
+    };
+    ne(xw, Za, {
+        _transform: Za.prototype.transform,
+        transform(e, t) {
+            return this._transform(TW(e, t), t)
         }
+    });
 
-        function l() {
-            if (t) {
-                var u, c = t.length,
-                    f;
-                for (n = new Array(c), u = 0; u < c; ++u) f = t[u], n[f.index] = +e(f, u, t)
-            }
+    function TW(e, t) {
+        const n = e.field,
+            i = e.value,
+            r = (e.op === "count" ? "__count__" : e.op) || "sum",
+            s = Fn(n).concat(Fn(i)),
+            a = OW(n, e.limit || 0, t);
+        return t.changed() && e.set("__pivot__", null, null, !0), {
+            key: e.key,
+            groupby: e.groupby,
+            ops: a.map(() => r),
+            fields: a.map(o => MW(o, n, i, s)),
+            as: a.map(o => o + ""),
+            modified: e.modified.bind(e)
         }
-        return a.initialize = function(u, c) {
-            t = u, i = c, l()
-        }, a.iterations = function(u) {
-            return arguments.length ? (s = +u, a) : s
-        }, a.strength = function(u) {
-            return arguments.length ? (r = +u, a) : r
-        }, a.radius = function(u) {
-            return arguments.length ? (e = typeof u == "function" ? u : Fn(+u), l(), a) : e
-        }, a
     }
 
-    function MU(e) {
-        return e.index
+    function MW(e, t, n, i) {
+        return vi(r => t(r) === e ? n(r) : NaN, i, e + "")
     }
 
-    function Xk(e, t) {
-        var n = e.get(t);
-        if (!n) throw new Error("node not found: " + t);
-        return n
+    function OW(e, t, n) {
+        const i = {},
+            r = [];
+        return n.visit(n.SOURCE, s => {
+            const a = e(s);
+            i[a] || (i[a] = 1, r.push(a))
+        }), r.sort(z0), t ? r.slice(0, t) : r
     }
 
-    function OU(e) {
-        var t = MU,
-            n = f,
-            i, r = Fn(30),
-            s, a, o, l, u, c = 1;
-        e == null && (e = []);
-
-        function f(m) {
-            return 1 / Math.min(o[m.source.index], o[m.target.index])
-        }
-
-        function h(m) {
-            for (var y = 0, v = e.length; y < c; ++y)
-                for (var b = 0, x, _, S, w, E, A, C; b < v; ++b) x = e[b], _ = x.source, S = x.target, w = S.x + S.vx - _.x - _.vx || da(u), E = S.y + S.vy - _.y - _.vy || da(u), A = Math.sqrt(w * w + E * E), A = (A - s[b]) / A * m * i[b], w *= A, E *= A, S.vx -= w * (C = l[b]), S.vy -= E * C, _.vx += w * (C = 1 - C), _.vy += E * C
-        }
-
-        function d() {
-            if (a) {
-                var m, y = a.length,
-                    v = e.length,
-                    b = new Map(a.map((_, S) => [t(_, S, a), _])),
-                    x;
-                for (m = 0, o = new Array(y); m < v; ++m) x = e[m], x.index = m, typeof x.source != "object" && (x.source = Xk(b, x.source)), typeof x.target != "object" && (x.target = Xk(b, x.target)), o[x.source.index] = (o[x.source.index] || 0) + 1, o[x.target.index] = (o[x.target.index] || 0) + 1;
-                for (m = 0, l = new Array(v); m < v; ++m) x = e[m], l[m] = o[x.source.index] / (o[x.source.index] + o[x.target.index]);
-                i = new Array(v), g(), s = new Array(v), p()
-            }
+    function rD(e) {
+        i1.call(this, e)
+    }
+    ne(rD, i1, {
+        transform(e, t) {
+            const n = e.subflow,
+                i = e.field,
+                r = s => this.subflow(Ee(s), n, t, s);
+            return (e.modified("field") || i && t.modified(Fn(i))) && q("PreFacet does not support field modification."), this.initTargets(), i ? (t.visit(t.MOD, s => {
+                const a = r(s);
+                i(s).forEach(o => a.mod(o))
+            }), t.visit(t.ADD, s => {
+                const a = r(s);
+                i(s).forEach(o => a.add(it(o)))
+            }), t.visit(t.REM, s => {
+                const a = r(s);
+                i(s).forEach(o => a.rem(o))
+            })) : (t.visit(t.MOD, s => r(s).mod(s)), t.visit(t.ADD, s => r(s).add(s)), t.visit(t.REM, s => r(s).rem(s))), t.clean() && t.runAfter(() => this.clean()), t
         }
+    });
 
-        function g() {
-            if (a)
-                for (var m = 0, y = e.length; m < y; ++m) i[m] = +n(e[m], m, e)
+    function _w(e) {
+        j.call(this, null, e)
+    }
+    _w.Definition = {
+        type: "Project",
+        metadata: {
+            generates: !0,
+            changes: !0
+        },
+        params: [{
+            name: "fields",
+            type: "field",
+            array: !0
+        }, {
+            name: "as",
+            type: "string",
+            null: !0,
+            array: !0
+        }]
+    };
+    ne(_w, j, {
+        transform(e, t) {
+            const n = t.fork(t.NO_SOURCE),
+                i = e.fields,
+                r = XR(e.fields, e.as || []),
+                s = i ? (o, l) => FW(o, l, i, r) : V0;
+            let a;
+            return this.value ? a = this.value : (t = t.addAll(), a = this.value = {}), t.visit(t.REM, o => {
+                const l = Ee(o);
+                n.rem.push(a[l]), a[l] = null
+            }), t.visit(t.ADD, o => {
+                const l = s(o, it({}));
+                a[Ee(o)] = l, n.add.push(l)
+            }), t.visit(t.MOD, o => {
+                n.mod.push(s(o, a[Ee(o)]))
+            }), n
         }
+    });
 
-        function p() {
-            if (a)
-                for (var m = 0, y = e.length; m < y; ++m) s[m] = +r(e[m], m, e)
-        }
-        return h.initialize = function(m, y) {
-            a = m, u = y, d()
-        }, h.links = function(m) {
-            return arguments.length ? (e = m, d(), h) : e
-        }, h.id = function(m) {
-            return arguments.length ? (t = m, h) : t
-        }, h.iterations = function(m) {
-            return arguments.length ? (c = +m, h) : c
-        }, h.strength = function(m) {
-            return arguments.length ? (n = typeof m == "function" ? m : Fn(+m), g(), h) : n
-        }, h.distance = function(m) {
-            return arguments.length ? (r = typeof m == "function" ? m : Fn(+m), p(), h) : r
-        }, h
+    function FW(e, t, n, i) {
+        for (let r = 0, s = n.length; r < s; ++r) t[i[r]] = n[r](e);
+        return t
     }
-    const FU = 1664525,
-        RU = 1013904223,
-        Vk = 4294967296;
 
-    function DU() {
-        let e = 1;
-        return () => (e = (FU * e + RU) % Vk) / Vk
+    function sD(e) {
+        j.call(this, null, e)
     }
+    ne(sD, j, {
+        transform(e, t) {
+            return this.value = e.value, e.modified("value") ? t.fork(t.NO_SOURCE | t.NO_FIELDS) : t.StopPropagation
+        }
+    });
 
-    function NU(e) {
-        return e.x
+    function ww(e) {
+        j.call(this, null, e)
     }
+    ww.Definition = {
+        type: "Quantile",
+        metadata: {
+            generates: !0,
+            changes: !0
+        },
+        params: [{
+            name: "groupby",
+            type: "field",
+            array: !0
+        }, {
+            name: "field",
+            type: "field",
+            required: !0
+        }, {
+            name: "probs",
+            type: "number",
+            array: !0
+        }, {
+            name: "step",
+            type: "number",
+            default: .01
+        }, {
+            name: "as",
+            type: "string",
+            array: !0,
+            default: ["prob", "value"]
+        }]
+    };
+    const RW = 1e-14;
+    ne(ww, j, {
+        transform(e, t) {
+            const n = t.fork(t.NO_SOURCE | t.NO_FIELDS),
+                i = e.as || ["prob", "value"];
+            if (this.value && !e.modified() && !t.changed()) return n.source = this.value, n;
+            const r = t.materialize(t.SOURCE).source,
+                s = lw(r, e.groupby, e.field),
+                a = (e.groupby || []).map(Pt),
+                o = [],
+                l = e.step || .01,
+                u = e.probs || $i(l / 2, 1 - RW, l),
+                c = u.length;
+            return s.forEach(f => {
+                const h = z_(f, u);
+                for (let d = 0; d < c; ++d) {
+                    const g = {};
+                    for (let p = 0; p < a.length; ++p) g[a[p]] = f.dims[p];
+                    g[i[0]] = u[d], g[i[1]] = h[d], o.push(it(g))
+                }
+            }), this.value && (n.rem = this.value), this.value = n.add = n.source = o, n
+        }
+    });
 
-    function PU(e) {
-        return e.y
+    function aD(e) {
+        j.call(this, null, e)
     }
-    var LU = 10,
-        IU = Math.PI * (3 - Math.sqrt(5));
-
-    function zU(e) {
-        var t, n = 1,
-            i = .001,
-            r = 1 - Math.pow(i, 1 / 300),
-            s = 0,
-            a = .6,
-            o = new Map,
-            l = qO(f),
-            u = UO("tick", "end"),
-            c = DU();
-        e == null && (e = []);
-
-        function f() {
-            h(), u.call("tick", t), n < i && (l.stop(), u.call("end", t))
+    ne(aD, j, {
+        transform(e, t) {
+            let n, i;
+            return this.value ? i = this.value : (n = t = t.addAll(), i = this.value = {}), e.derive && (n = t.fork(t.NO_SOURCE), t.visit(t.REM, r => {
+                const s = Ee(r);
+                n.rem.push(i[s]), i[s] = null
+            }), t.visit(t.ADD, r => {
+                const s = P_(r);
+                i[Ee(r)] = s, n.add.push(s)
+            }), t.visit(t.MOD, r => {
+                const s = i[Ee(r)];
+                for (const a in r) s[a] = r[a], n.modifies(a);
+                n.mod.push(s)
+            })), n
         }
+    });
 
-        function h(p) {
-            var m, y = e.length,
-                v;
-            p === void 0 && (p = 1);
-            for (var b = 0; b < p; ++b)
-                for (n += (s - n) * r, o.forEach(function(x) {
-                        x(n)
-                    }), m = 0; m < y; ++m) v = e[m], v.fx == null ? v.x += v.vx *= a : (v.x = v.fx, v.vx = 0), v.fy == null ? v.y += v.vy *= a : (v.y = v.fy, v.vy = 0);
-            return t
-        }
+    function Sw(e) {
+        j.call(this, [], e), this.count = 0
+    }
+    Sw.Definition = {
+        type: "Sample",
+        metadata: {},
+        params: [{
+            name: "size",
+            type: "number",
+            default: 1e3
+        }]
+    };
+    ne(Sw, j, {
+        transform(e, t) {
+            const n = t.fork(t.NO_SOURCE),
+                i = e.modified("size"),
+                r = e.size,
+                s = this.value.reduce((c, f) => (c[Ee(f)] = 1, c), {});
+            let a = this.value,
+                o = this.count,
+                l = 0;
 
-        function d() {
-            for (var p = 0, m = e.length, y; p < m; ++p) {
-                if (y = e[p], y.index = p, y.fx != null && (y.x = y.fx), y.fy != null && (y.y = y.fy), isNaN(y.x) || isNaN(y.y)) {
-                    var v = LU * Math.sqrt(.5 + p),
-                        b = p * IU;
-                    y.x = v * Math.cos(b), y.y = v * Math.sin(b)
-                }(isNaN(y.vx) || isNaN(y.vy)) && (y.vx = y.vy = 0)
+            function u(c) {
+                let f, h;
+                a.length < r ? a.push(c) : (h = ~~((o + 1) * Vi()), h < a.length && h >= l && (f = a[h], s[Ee(f)] && n.rem.push(f), a[h] = c)), ++o
             }
+            if (t.rem.length && (t.visit(t.REM, c => {
+                    const f = Ee(c);
+                    s[f] && (s[f] = -1, n.rem.push(c)), --o
+                }), a = a.filter(c => s[Ee(c)] !== -1)), (t.rem.length || i) && a.length < r && t.source && (l = o = a.length, t.visit(t.SOURCE, c => {
+                    s[Ee(c)] || u(c)
+                }), l = -1), i && a.length > r) {
+                const c = a.length - r;
+                for (let f = 0; f < c; ++f) s[Ee(a[f])] = -1, n.rem.push(a[f]);
+                a = a.slice(c)
+            }
+            return t.mod.length && t.visit(t.MOD, c => {
+                s[Ee(c)] && n.mod.push(c)
+            }), t.add.length && t.visit(t.ADD, u), (t.add.length || l < 0) && (n.add = a.filter(c => !s[Ee(c)])), this.count = o, this.value = n.source = a, n
         }
+    });
 
-        function g(p) {
-            return p.initialize && p.initialize(e, c), p
+    function Ew(e) {
+        j.call(this, null, e)
+    }
+    Ew.Definition = {
+        type: "Sequence",
+        metadata: {
+            generates: !0,
+            changes: !0
+        },
+        params: [{
+            name: "start",
+            type: "number",
+            required: !0
+        }, {
+            name: "stop",
+            type: "number",
+            required: !0
+        }, {
+            name: "step",
+            type: "number",
+            default: 1
+        }, {
+            name: "as",
+            type: "string",
+            default: "data"
+        }]
+    };
+    ne(Ew, j, {
+        transform(e, t) {
+            if (this.value && !e.modified()) return;
+            const n = t.materialize().fork(t.MOD),
+                i = e.as || "data";
+            return n.rem = this.value ? t.rem.concat(this.value) : t.rem, this.value = $i(e.start, e.stop, e.step || 1).map(r => {
+                const s = {};
+                return s[i] = r, it(s)
+            }), n.add = t.add.concat(this.value), n
         }
-        return d(), t = {
-            tick: h,
-            restart: function() {
-                return l.restart(f), t
-            },
-            stop: function() {
-                return l.stop(), t
-            },
-            nodes: function(p) {
-                return arguments.length ? (e = p, d(), o.forEach(g), t) : e
-            },
-            alpha: function(p) {
-                return arguments.length ? (n = +p, t) : n
-            },
-            alphaMin: function(p) {
-                return arguments.length ? (i = +p, t) : i
-            },
-            alphaDecay: function(p) {
-                return arguments.length ? (r = +p, t) : +r
-            },
-            alphaTarget: function(p) {
-                return arguments.length ? (s = +p, t) : s
-            },
-            velocityDecay: function(p) {
-                return arguments.length ? (a = 1 - p, t) : 1 - a
-            },
-            randomSource: function(p) {
-                return arguments.length ? (c = p, o.forEach(g), t) : c
-            },
-            force: function(p, m) {
-                return arguments.length > 1 ? (m == null ? o.delete(p) : o.set(p, g(m)), t) : o.get(p)
-            },
-            find: function(p, m, y) {
-                var v = 0,
-                    b = e.length,
-                    x, _, S, w, E;
-                for (y == null ? y = 1 / 0 : y *= y, v = 0; v < b; ++v) w = e[v], x = p - w.x, _ = m - w.y, S = x * x + _ * _, S < y && (E = w, y = S);
-                return E
-            },
-            on: function(p, m) {
-                return arguments.length > 1 ? (u.on(p, m), t) : u.on(p)
-            }
+    });
+
+    function oD(e) {
+        j.call(this, null, e), this.modified(!0)
+    }
+    ne(oD, j, {
+        transform(e, t) {
+            return this.value = t.source, t.changed() ? t.fork(t.NO_SOURCE | t.NO_FIELDS) : t.StopPropagation
         }
+    });
+
+    function kw(e) {
+        j.call(this, null, e)
     }
+    const lD = ["unit0", "unit1"];
+    kw.Definition = {
+        type: "TimeUnit",
+        metadata: {
+            modifies: !0
+        },
+        params: [{
+            name: "field",
+            type: "field",
+            required: !0
+        }, {
+            name: "interval",
+            type: "boolean",
+            default: !0
+        }, {
+            name: "units",
+            type: "enum",
+            values: A_,
+            array: !0
+        }, {
+            name: "step",
+            type: "number",
+            default: 1
+        }, {
+            name: "maxbins",
+            type: "number",
+            default: 40
+        }, {
+            name: "extent",
+            type: "date",
+            array: !0
+        }, {
+            name: "timezone",
+            type: "enum",
+            default: "local",
+            values: ["local", "utc"]
+        }, {
+            name: "as",
+            type: "string",
+            array: !0,
+            length: 2,
+            default: lD
+        }]
+    };
+    ne(kw, j, {
+        transform(e, t) {
+            const n = e.field,
+                i = e.interval !== !1,
+                r = e.timezone === "utc",
+                s = this._floor(e, t),
+                a = (r ? Yc : Hc)(s.unit).offset,
+                o = e.as || lD,
+                l = o[0],
+                u = o[1],
+                c = s.step;
+            let f = s.start || 1 / 0,
+                h = s.stop || -1 / 0,
+                d = t.ADD;
+            return (e.modified() || t.changed(t.REM) || t.modified(Fn(n))) && (t = t.reflow(!0), d = t.SOURCE, f = 1 / 0, h = -1 / 0), t.visit(d, g => {
+                const p = n(g);
+                let m, y;
+                p == null ? (g[l] = null, i && (g[u] = null)) : (g[l] = m = y = s(p), i && (g[u] = y = a(m, c)), m < f && (f = m), y > h && (h = y))
+            }), s.start = f, s.stop = h, t.modifies(i ? o : l)
+        },
+        _floor(e, t) {
+            const n = e.timezone === "utc",
+                {
+                    units: i,
+                    step: r
+                } = e.units ? {
+                    units: e.units,
+                    step: e.step || 1
+                } : QF({
+                    extent: e.extent || ss(t.materialize(t.SOURCE).source, e.field),
+                    maxbins: e.maxbins
+                }),
+                s = $_(i),
+                a = this.value || {},
+                o = (n ? UF : GF)(s, r);
+            return o.unit = We(s), o.units = s, o.step = r, o.start = a.start, o.stop = a.stop, this.value = o
+        }
+    });
 
-    function BU() {
-        var e, t, n, i, r = Fn(-30),
-            s, a = 1,
-            o = 1 / 0,
-            l = .81;
+    function uD(e) {
+        j.call(this, Uc(), e)
+    }
+    ne(uD, j, {
+        transform(e, t) {
+            const n = t.dataflow,
+                i = e.field,
+                r = this.value,
+                s = o => r.set(i(o), o);
+            let a = !0;
+            return e.modified("field") || t.modified(i.fields) ? (r.clear(), t.visit(t.SOURCE, s)) : t.changed() ? (t.visit(t.REM, o => r.delete(i(o))), t.visit(t.ADD, s)) : a = !1, this.modified(a), r.empty > n.cleanThreshold && n.runAfter(r.clean), t.fork()
+        }
+    });
 
-        function u(d) {
-            var g, p = e.length,
-                m = Tx(e, NU, PU).visitAfter(f);
-            for (i = d, g = 0; g < p; ++g) t = e[g], m.visit(h)
+    function cD(e) {
+        j.call(this, null, e)
+    }
+    ne(cD, j, {
+        transform(e, t) {
+            (!this.value || e.modified("field") || e.modified("sort") || t.changed() || e.sort && t.modified(e.sort.fields)) && (this.value = (e.sort ? t.source.slice().sort(Yl(e.sort)) : t.source).map(e.field))
         }
+    });
 
-        function c() {
-            if (e) {
-                var d, g = e.length,
-                    p;
-                for (s = new Array(g), d = 0; d < g; ++d) p = e[d], s[p.index] = +r(p, d, e)
+    function DW(e, t, n, i) {
+        const r = Xh[e](t, n);
+        return {
+            init: r.init || Ma,
+            update: function(s, a) {
+                a[i] = r.next(s)
             }
         }
-
-        function f(d) {
-            var g = 0,
-                p, m, y = 0,
-                v, b, x;
-            if (d.length) {
-                for (v = b = x = 0; x < 4; ++x)(p = d[x]) && (m = Math.abs(p.value)) && (g += p.value, y += m, v += m * p.x, b += m * p.y);
-                d.x = v / y, d.y = b / y
-            } else {
-                p = d, p.x = p.data.x, p.y = p.data.y;
-                do g += s[p.data.index]; while (p = p.next)
+    }
+    const Xh = {
+        row_number: function() {
+            return {
+                next: e => e.index + 1
+            }
+        },
+        rank: function() {
+            let e;
+            return {
+                init: () => e = 1,
+                next: t => {
+                    const n = t.index,
+                        i = t.data;
+                    return n && t.compare(i[n - 1], i[n]) ? e = n + 1 : e
+                }
+            }
+        },
+        dense_rank: function() {
+            let e;
+            return {
+                init: () => e = 1,
+                next: t => {
+                    const n = t.index,
+                        i = t.data;
+                    return n && t.compare(i[n - 1], i[n]) ? ++e : e
+                }
+            }
+        },
+        percent_rank: function() {
+            const e = Xh.rank(),
+                t = e.next;
+            return {
+                init: e.init,
+                next: n => (t(n) - 1) / (n.data.length - 1)
+            }
+        },
+        cume_dist: function() {
+            let e;
+            return {
+                init: () => e = 0,
+                next: t => {
+                    const n = t.data,
+                        i = t.compare;
+                    let r = t.index;
+                    if (e < r) {
+                        for (; r + 1 < n.length && !i(n[r], n[r + 1]);) ++r;
+                        e = r
+                    }
+                    return (1 + e) / n.length
+                }
+            }
+        },
+        ntile: function(e, t) {
+            t = +t, t > 0 || q("ntile num must be greater than zero.");
+            const n = Xh.cume_dist(),
+                i = n.next;
+            return {
+                init: n.init,
+                next: r => Math.ceil(t * i(r))
+            }
+        },
+        lag: function(e, t) {
+            return t = +t || 1, {
+                next: n => {
+                    const i = n.index - t;
+                    return i >= 0 ? e(n.data[i]) : null
+                }
+            }
+        },
+        lead: function(e, t) {
+            return t = +t || 1, {
+                next: n => {
+                    const i = n.index + t,
+                        r = n.data;
+                    return i < r.length ? e(r[i]) : null
+                }
+            }
+        },
+        first_value: function(e) {
+            return {
+                next: t => e(t.data[t.i0])
+            }
+        },
+        last_value: function(e) {
+            return {
+                next: t => e(t.data[t.i1 - 1])
+            }
+        },
+        nth_value: function(e, t) {
+            return t = +t, t > 0 || q("nth_value nth must be greater than zero."), {
+                next: n => {
+                    const i = n.i0 + (t - 1);
+                    return i < n.i1 ? e(n.data[i]) : null
+                }
+            }
+        },
+        prev_value: function(e) {
+            let t;
+            return {
+                init: () => t = null,
+                next: n => {
+                    const i = e(n.data[n.index]);
+                    return i != null ? t = i : t
+                }
+            }
+        },
+        next_value: function(e) {
+            let t, n;
+            return {
+                init: () => (t = null, n = -1),
+                next: i => {
+                    const r = i.data;
+                    return i.index <= n ? t : (n = NW(e, r, i.index)) < 0 ? (n = r.length, t = null) : t = e(r[n])
+                }
             }
-            d.value = g
         }
+    };
 
-        function h(d, g, p, m) {
-            if (!d.value) return !0;
-            var y = d.x - t.x,
-                v = d.y - t.y,
-                b = m - g,
-                x = y * y + v * v;
-            if (b * b / l < x) return x < o && (y === 0 && (y = da(n), x += y * y), v === 0 && (v = da(n), x += v * v), x < a && (x = Math.sqrt(a * x)), t.vx += y * d.value * i / x, t.vy += v * d.value * i / x), !0;
-            if (d.length || x >= o) return;
-            (d.data !== t || d.next) && (y === 0 && (y = da(n), x += y * y), v === 0 && (v = da(n), x += v * v), x < a && (x = Math.sqrt(a * x)));
-            do d.data !== t && (b = s[d.data.index] * i / x, t.vx += y * b, t.vy += v * b); while (d = d.next)
-        }
-        return u.initialize = function(d, g) {
-            e = d, n = g, c()
-        }, u.strength = function(d) {
-            return arguments.length ? (r = typeof d == "function" ? d : Fn(+d), c(), u) : r
-        }, u.distanceMin = function(d) {
-            return arguments.length ? (a = d * d, u) : Math.sqrt(a)
-        }, u.distanceMax = function(d) {
-            return arguments.length ? (o = d * d, u) : Math.sqrt(o)
-        }, u.theta = function(d) {
-            return arguments.length ? (l = d * d, u) : Math.sqrt(l)
-        }, u
+    function NW(e, t, n) {
+        for (let i = t.length; n < i; ++n)
+            if (e(t[n]) != null) return n;
+        return -1
     }
+    const PW = Object.keys(Xh);
 
-    function jU(e) {
-        var t = Fn(.1),
-            n, i, r;
-        typeof e != "function" && (e = Fn(e == null ? 0 : +e));
+    function fD(e) {
+        const t = ue(e.ops),
+            n = ue(e.fields),
+            i = ue(e.params),
+            r = ue(e.as),
+            s = this.outputs = [],
+            a = this.windows = [],
+            o = {},
+            l = {},
+            u = [],
+            c = [];
+        let f = !0;
 
-        function s(o) {
-            for (var l = 0, u = n.length, c; l < u; ++l) c = n[l], c.vx += (r[l] - c.x) * i[l] * o
+        function h(d) {
+            ue(Fn(d)).forEach(g => o[g] = 1)
         }
-
-        function a() {
-            if (n) {
-                var o, l = n.length;
-                for (i = new Array(l), r = new Array(l), o = 0; o < l; ++o) i[o] = isNaN(r[o] = +e(n[o], o, n)) ? 0 : +t(n[o], o, n)
+        h(e.sort), t.forEach((d, g) => {
+            const p = n[g],
+                m = Pt(p),
+                y = BR(d, m, r[g]);
+            if (h(p), s.push(y), Ce(Xh, d)) a.push(DW(d, n[g], i[g], y));
+            else {
+                if (p == null && d !== "count" && q("Null aggregate field specified."), d === "count") {
+                    u.push(y);
+                    return
+                }
+                f = !1;
+                let v = l[m];
+                v || (v = l[m] = [], v.field = p, c.push(v)), v.push(jR(d, y))
             }
-        }
-        return s.initialize = function(o) {
-            n = o, a()
-        }, s.strength = function(o) {
-            return arguments.length ? (t = typeof o == "function" ? o : Fn(+o), a(), s) : t
-        }, s.x = function(o) {
-            return arguments.length ? (e = typeof o == "function" ? o : Fn(+o), a(), s) : e
-        }, s
+        }), (u.length || c.length) && (this.cell = LW(c, u, f)), this.inputs = Object.keys(o)
     }
-
-    function UU(e) {
-        var t = Fn(.1),
-            n, i, r;
-        typeof e != "function" && (e = Fn(e == null ? 0 : +e));
-
-        function s(o) {
-            for (var l = 0, u = n.length, c; l < u; ++l) c = n[l], c.vy += (r[l] - c.y) * i[l] * o
+    const hD = fD.prototype;
+    hD.init = function() {
+        this.windows.forEach(e => e.init()), this.cell && this.cell.init()
+    };
+    hD.update = function(e, t) {
+        const n = this.cell,
+            i = this.windows,
+            r = e.data,
+            s = i && i.length;
+        let a;
+        if (n) {
+            for (a = e.p0; a < e.i0; ++a) n.rem(r[a]);
+            for (a = e.p1; a < e.i1; ++a) n.add(r[a]);
+            n.set(t)
         }
+        for (a = 0; a < s; ++a) i[a].update(e, t)
+    };
 
-        function a() {
-            if (n) {
-                var o, l = n.length;
-                for (i = new Array(l), r = new Array(l), o = 0; o < l; ++o) i[o] = isNaN(r[o] = +e(n[o], o, n)) ? 0 : +t(n[o], o, n)
+    function LW(e, t, n) {
+        e = e.map(l => UR(l, l.field));
+        const i = {
+            num: 0,
+            agg: null,
+            store: !1,
+            count: t
+        };
+        if (!n)
+            for (var r = e.length, s = i.agg = Array(r), a = 0; a < r; ++a) s[a] = new e[a](i);
+        if (i.store) var o = i.data = new nw;
+        return i.add = function(l) {
+            if (i.num += 1, !n) {
+                o && o.add(l);
+                for (let u = 0; u < r; ++u) s[u].add(s[u].get(l), l)
             }
-        }
-        return s.initialize = function(o) {
-            n = o, a()
-        }, s.strength = function(o) {
-            return arguments.length ? (t = typeof o == "function" ? o : Fn(+o), a(), s) : t
-        }, s.y = function(o) {
-            return arguments.length ? (e = typeof o == "function" ? o : Fn(+o), a(), s) : e
-        }, s
-    }
-
-    function GU(e) {
-        return Math.abs(e = Math.round(e)) >= 1e21 ? e.toLocaleString("en").replace(/,/g, "") : e.toString(10)
-    }
-
-    function Tp(e, t) {
-        if ((n = (e = t ? e.toExponential(t - 1) : e.toExponential()).indexOf("e")) < 0) return null;
-        var n, i = e.slice(0, n);
-        return [i.length > 1 ? i[0] + i.slice(2) : i, +e.slice(n + 1)]
+        }, i.rem = function(l) {
+            if (i.num -= 1, !n) {
+                o && o.rem(l);
+                for (let u = 0; u < r; ++u) s[u].rem(s[u].get(l), l)
+            }
+        }, i.set = function(l) {
+            let u, c;
+            for (o && o.values(), u = 0, c = t.length; u < c; ++u) l[t[u]] = i.num;
+            if (!n)
+                for (u = 0, c = s.length; u < c; ++u) s[u].set(l)
+        }, i.init = function() {
+            i.num = 0, o && o.reset();
+            for (let l = 0; l < r; ++l) s[l].init()
+        }, i
     }
 
-    function Ru(e) {
-        return e = Tp(Math.abs(e)), e ? e[1] : NaN
+    function Cw(e) {
+        j.call(this, {}, e), this._mlen = 0, this._mods = []
     }
-
-    function WU(e, t) {
-        return function(n, i) {
-            for (var r = n.length, s = [], a = 0, o = e[0], l = 0; r > 0 && o > 0 && (l + o + 1 > i && (o = Math.max(1, i - l)), s.push(n.substring(r -= o, r + o)), !((l += o + 1) > i));) o = e[a = (a + 1) % e.length];
-            return s.reverse().join(t)
+    Cw.Definition = {
+        type: "Window",
+        metadata: {
+            modifies: !0
+        },
+        params: [{
+            name: "sort",
+            type: "compare"
+        }, {
+            name: "groupby",
+            type: "field",
+            array: !0
+        }, {
+            name: "ops",
+            type: "enum",
+            array: !0,
+            values: PW.concat(Od)
+        }, {
+            name: "params",
+            type: "number",
+            null: !0,
+            array: !0
+        }, {
+            name: "fields",
+            type: "field",
+            null: !0,
+            array: !0
+        }, {
+            name: "as",
+            type: "string",
+            null: !0,
+            array: !0
+        }, {
+            name: "frame",
+            type: "number",
+            null: !0,
+            array: !0,
+            length: 2,
+            default: [null, 0]
+        }, {
+            name: "ignorePeers",
+            type: "boolean",
+            default: !1
+        }]
+    };
+    ne(Cw, j, {
+        transform(e, t) {
+            this.stamp = t.stamp;
+            const n = e.modified(),
+                i = Yl(e.sort),
+                r = Zb(e.groupby),
+                s = o => this.group(r(o));
+            let a = this.state;
+            (!a || n) && (a = this.state = new fD(e)), n || t.modified(a.inputs) ? (this.value = {}, t.visit(t.SOURCE, o => s(o).add(o))) : (t.visit(t.REM, o => s(o).remove(o)), t.visit(t.ADD, o => s(o).add(o)));
+            for (let o = 0, l = this._mlen; o < l; ++o) IW(this._mods[o], a, i, e);
+            return this._mlen = 0, this._mods = [], t.reflow(n).modifies(a.outputs)
+        },
+        group(e) {
+            let t = this.value[e];
+            return t || (t = this.value[e] = WR(Ee), t.stamp = -1), t.stamp < this.stamp && (t.stamp = this.stamp, this._mods[this._mlen++] = t), t
         }
-    }
+    });
 
-    function qU(e) {
-        return function(t) {
-            return t.replace(/[0-9]/g, function(n) {
-                return e[+n]
-            })
-        }
+    function IW(e, t, n, i) {
+        const r = i.sort,
+            s = r && !i.ignorePeers,
+            a = i.frame || [null, 0],
+            o = e.data(n),
+            l = o.length,
+            u = s ? Ad(r) : null,
+            c = {
+                i0: 0,
+                i1: 0,
+                p0: 0,
+                p1: 0,
+                index: 0,
+                data: o,
+                compare: r || Ln(-1)
+            };
+        t.init();
+        for (let f = 0; f < l; ++f) zW(c, a, f, l), s && BW(c, u), t.update(c, o[f])
     }
-    var HU = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
 
-    function Qo(e) {
-        if (!(t = HU.exec(e))) throw new Error("invalid format: " + e);
-        var t;
-        return new Ox({
-            fill: t[1],
-            align: t[2],
-            sign: t[3],
-            symbol: t[4],
-            zero: t[5],
-            width: t[6],
-            comma: t[7],
-            precision: t[8] && t[8].slice(1),
-            trim: t[9],
-            type: t[10]
-        })
+    function zW(e, t, n, i) {
+        e.p0 = e.i0, e.p1 = e.i1, e.i0 = t[0] == null ? 0 : Math.max(0, n - Math.abs(t[0])), e.i1 = t[1] == null ? i : Math.min(i, n + Math.abs(t[1]) + 1), e.index = n
     }
-    Qo.prototype = Ox.prototype;
 
-    function Ox(e) {
-        this.fill = e.fill === void 0 ? " " : e.fill + "", this.align = e.align === void 0 ? ">" : e.align + "", this.sign = e.sign === void 0 ? "-" : e.sign + "", this.symbol = e.symbol === void 0 ? "" : e.symbol + "", this.zero = !!e.zero, this.width = e.width === void 0 ? void 0 : +e.width, this.comma = !!e.comma, this.precision = e.precision === void 0 ? void 0 : +e.precision, this.trim = !!e.trim, this.type = e.type === void 0 ? "" : e.type + ""
+    function BW(e, t) {
+        const n = e.i0,
+            i = e.i1 - 1,
+            r = e.compare,
+            s = e.data,
+            a = s.length - 1;
+        n > 0 && !r(s[n], s[n - 1]) && (e.i0 = t.left(s, s[n])), i < a && !r(s[i], s[i + 1]) && (e.i1 = t.right(s, s[i]))
     }
-    Ox.prototype.toString = function() {
-        return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type
-    };
+    const jW = Object.freeze(Object.defineProperty({
+        __proto__: null,
+        aggregate: Za,
+        bin: iw,
+        collect: rw,
+        compare: qR,
+        countpattern: sw,
+        cross: aw,
+        density: ow,
+        dotbin: uw,
+        expression: KR,
+        extent: cw,
+        facet: i1,
+        field: JR,
+        filter: hw,
+        flatten: dw,
+        fold: gw,
+        formula: pw,
+        generate: QR,
+        impute: mw,
+        joinaggregate: yw,
+        kde: vw,
+        key: ZR,
+        load: eD,
+        lookup: bw,
+        multiextent: tD,
+        multivalues: nD,
+        params: iD,
+        pivot: xw,
+        prefacet: rD,
+        project: _w,
+        proxy: sD,
+        quantile: ww,
+        relay: aD,
+        sample: Sw,
+        sequence: Ew,
+        sieve: oD,
+        subflow: fw,
+        timeunit: kw,
+        tupleindex: uD,
+        values: cD,
+        window: Cw
+    }, Symbol.toStringTag, {
+        value: "Module"
+    }));
 
-    function YU(e) {
-        e: for (var t = e.length, n = 1, i = -1, r; n < t; ++n) switch (e[n]) {
-            case ".":
-                i = r = n;
-                break;
-            case "0":
-                i === 0 && (i = n), r = n;
-                break;
-            default:
-                if (!+e[n]) break e;
-                i > 0 && (i = 0);
-                break
+    function rt(e) {
+        return function() {
+            return e
         }
-        return i > 0 ? e.slice(0, i) + e.slice(r + 1) : e
     }
-    var VO;
+    const zA = Math.abs,
+        Sn = Math.atan2,
+        No = Math.cos,
+        GW = Math.max,
+        av = Math.min,
+        jr = Math.sin,
+        rl = Math.sqrt,
+        kn = 1e-12,
+        uc = Math.PI,
+        cm = uc / 2,
+        dD = 2 * uc;
 
-    function XU(e, t) {
-        var n = Tp(e, t);
-        if (!n) return e + "";
-        var i = n[0],
-            r = n[1],
-            s = r - (VO = Math.max(-8, Math.min(8, Math.floor(r / 3))) * 3) + 1,
-            a = i.length;
-        return s === a ? i : s > a ? i + new Array(s - a + 1).join("0") : s > 0 ? i.slice(0, s) + "." + i.slice(s) : "0." + new Array(1 - s).join("0") + Tp(e, Math.max(0, t + s - 1))[0]
+    function UW(e) {
+        return e > 1 ? 0 : e < -1 ? uc : Math.acos(e)
     }
 
-    function Kk(e, t) {
-        var n = Tp(e, t);
-        if (!n) return e + "";
-        var i = n[0],
-            r = n[1];
-        return r < 0 ? "0." + new Array(-r).join("0") + i : i.length > r + 1 ? i.slice(0, r + 1) + "." + i.slice(r + 1) : i + new Array(r - i.length + 2).join("0")
+    function BA(e) {
+        return e >= 1 ? cm : e <= -1 ? -cm : Math.asin(e)
     }
-    const Jk = {
-        "%": (e, t) => (e * 100).toFixed(t),
-        b: e => Math.round(e).toString(2),
-        c: e => e + "",
-        d: GU,
-        e: (e, t) => e.toExponential(t),
-        f: (e, t) => e.toFixed(t),
-        g: (e, t) => e.toPrecision(t),
-        o: e => Math.round(e).toString(8),
-        p: (e, t) => Kk(e * 100, t),
-        r: Kk,
-        s: XU,
-        X: e => Math.round(e).toString(16).toUpperCase(),
-        x: e => Math.round(e).toString(16)
-    };
+    const e2 = Math.PI,
+        t2 = 2 * e2,
+        Xo = 1e-6,
+        WW = t2 - Xo;
 
-    function Qk(e) {
-        return e
+    function gD(e) {
+        this._ += e[0];
+        for (let t = 1, n = e.length; t < n; ++t) this._ += arguments[t] + e[t]
     }
-    var Zk = Array.prototype.map,
-        eA = ["y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
-
-    function KO(e) {
-        var t = e.grouping === void 0 || e.thousands === void 0 ? Qk : WU(Zk.call(e.grouping, Number), e.thousands + ""),
-            n = e.currency === void 0 ? "" : e.currency[0] + "",
-            i = e.currency === void 0 ? "" : e.currency[1] + "",
-            r = e.decimal === void 0 ? "." : e.decimal + "",
-            s = e.numerals === void 0 ? Qk : qU(Zk.call(e.numerals, String)),
-            a = e.percent === void 0 ? "%" : e.percent + "",
-            o = e.minus === void 0 ? "−" : e.minus + "",
-            l = e.nan === void 0 ? "NaN" : e.nan + "";
-
-        function u(f) {
-            f = Qo(f);
-            var h = f.fill,
-                d = f.align,
-                g = f.sign,
-                p = f.symbol,
-                m = f.zero,
-                y = f.width,
-                v = f.comma,
-                b = f.precision,
-                x = f.trim,
-                _ = f.type;
-            _ === "n" ? (v = !0, _ = "g") : Jk[_] || (b === void 0 && (b = 12), x = !0, _ = "g"), (m || h === "0" && d === "=") && (m = !0, h = "0", d = "=");
-            var S = p === "$" ? n : p === "#" && /[boxX]/.test(_) ? "0" + _.toLowerCase() : "",
-                w = p === "$" ? i : /[%p]/.test(_) ? a : "",
-                E = Jk[_],
-                A = /[defgprs%]/.test(_);
-            b = b === void 0 ? 6 : /[gprs]/.test(_) ? Math.max(1, Math.min(21, b)) : Math.max(0, Math.min(20, b));
 
-            function C(k) {
-                var R = S,
-                    $ = w,
-                    T, M, F;
-                if (_ === "c") $ = E(k) + $, k = "";
+    function qW(e) {
+        let t = Math.floor(e);
+        if (!(t >= 0)) throw new Error(`invalid digits: ${e}`);
+        if (t > 15) return gD;
+        const n = 10 ** t;
+        return function(i) {
+            this._ += i[0];
+            for (let r = 1, s = i.length; r < s; ++r) this._ += Math.round(arguments[r] * n) / n + i[r]
+        }
+    }
+    let Aw = class {
+        constructor(t) {
+            this._x0 = this._y0 = this._x1 = this._y1 = null, this._ = "", this._append = t == null ? gD : qW(t)
+        }
+        moveTo(t, n) {
+            this._append`M${this._x0=this._x1=+t},${this._y0=this._y1=+n}`
+        }
+        closePath() {
+            this._x1 !== null && (this._x1 = this._x0, this._y1 = this._y0, this._append`Z`)
+        }
+        lineTo(t, n) {
+            this._append`L${this._x1=+t},${this._y1=+n}`
+        }
+        quadraticCurveTo(t, n, i, r) {
+            this._append`Q${+t},${+n},${this._x1=+i},${this._y1=+r}`
+        }
+        bezierCurveTo(t, n, i, r, s, a) {
+            this._append`C${+t},${+n},${+i},${+r},${this._x1=+s},${this._y1=+a}`
+        }
+        arcTo(t, n, i, r, s) {
+            if (t = +t, n = +n, i = +i, r = +r, s = +s, s < 0) throw new Error(`negative radius: ${s}`);
+            let a = this._x1,
+                o = this._y1,
+                l = i - t,
+                u = r - n,
+                c = a - t,
+                f = o - n,
+                h = c * c + f * f;
+            if (this._x1 === null) this._append`M${this._x1=t},${this._y1=n}`;
+            else if (h > Xo)
+                if (!(Math.abs(f * l - u * c) > Xo) || !s) this._append`L${this._x1=t},${this._y1=n}`;
                 else {
-                    k = +k;
-                    var N = k < 0 || 1 / k < 0;
-                    if (k = isNaN(k) ? l : E(Math.abs(k), b), x && (k = YU(k)), N && +k == 0 && g !== "+" && (N = !1), R = (N ? g === "(" ? g : o : g === "-" || g === "(" ? "" : g) + R, $ = (_ === "s" ? eA[8 + VO / 3] : "") + $ + (N && g === "(" ? ")" : ""), A) {
-                        for (T = -1, M = k.length; ++T < M;)
-                            if (F = k.charCodeAt(T), 48 > F || F > 57) {
-                                $ = (F === 46 ? r + k.slice(T + 1) : k.slice(T)) + $, k = k.slice(0, T);
-                                break
-                            }
-                    }
-                }
-                v && !m && (k = t(k, 1 / 0));
-                var P = R.length + k.length + $.length,
-                    z = P < y ? new Array(y - P + 1).join(h) : "";
-                switch (v && m && (k = t(z + k, z.length ? y - $.length : 1 / 0), z = ""), d) {
-                    case "<":
-                        k = R + k + $ + z;
-                        break;
-                    case "=":
-                        k = R + z + k + $;
-                        break;
-                    case "^":
-                        k = z.slice(0, P = z.length >> 1) + R + k + $ + z.slice(P);
-                        break;
-                    default:
-                        k = z + R + k + $;
-                        break
+                    let d = i - a,
+                        g = r - o,
+                        p = l * l + u * u,
+                        m = d * d + g * g,
+                        y = Math.sqrt(p),
+                        v = Math.sqrt(h),
+                        b = s * Math.tan((e2 - Math.acos((p + h - m) / (2 * y * v))) / 2),
+                        x = b / v,
+                        _ = b / y;
+                    Math.abs(x - 1) > Xo && this._append`L${t+x*c},${n+x*f}`, this._append`A${s},${s},0,0,${+(f*d>c*g)},${this._x1=t+_*l},${this._y1=n+_*u}`
                 }
-                return s(k)
-            }
-            return C.toString = function() {
-                return f + ""
-            }, C
         }
-
-        function c(f, h) {
-            var d = u((f = Qo(f), f.type = "f", f)),
-                g = Math.max(-8, Math.min(8, Math.floor(Ru(h) / 3))) * 3,
-                p = Math.pow(10, -g),
-                m = eA[8 + g / 3];
-            return function(y) {
-                return d(p * y) + m
-            }
+        arc(t, n, i, r, s, a) {
+            if (t = +t, n = +n, i = +i, a = !!a, i < 0) throw new Error(`negative radius: ${i}`);
+            let o = i * Math.cos(r),
+                l = i * Math.sin(r),
+                u = t + o,
+                c = n + l,
+                f = 1 ^ a,
+                h = a ? r - s : s - r;
+            this._x1 === null ? this._append`M${u},${c}` : (Math.abs(this._x1 - u) > Xo || Math.abs(this._y1 - c) > Xo) && this._append`L${u},${c}`, i && (h < 0 && (h = h % t2 + t2), h > WW ? this._append`A${i},${i},0,1,${f},${t-o},${n-l}A${i},${i},0,1,${f},${this._x1=u},${this._y1=c}` : h > Xo && this._append`A${i},${i},0,${+(h>=e2)},${f},${this._x1=t+i*Math.cos(s)},${this._y1=n+i*Math.sin(s)}`)
         }
-        return {
-            format: u,
-            formatPrefix: c
+        rect(t, n, i, r) {
+            this._append`M${this._x0=this._x1=+t},${this._y0=this._y1=+n}h${i=+i}v${+r}h${-i}Z`
+        }
+        toString() {
+            return this._
         }
+    };
+
+    function r1() {
+        return new Aw
     }
-    var rg, lm, Fx;
-    VU({
-        thousands: ",",
-        grouping: [3],
-        currency: ["$", ""]
-    });
+    r1.prototype = Aw.prototype;
 
-    function VU(e) {
-        return rg = KO(e), lm = rg.format, Fx = rg.formatPrefix, rg
+    function s1(e) {
+        let t = 3;
+        return e.digits = function(n) {
+            if (!arguments.length) return t;
+            if (n == null) t = null;
+            else {
+                const i = Math.floor(n);
+                if (!(i >= 0)) throw new RangeError(`invalid digits: ${n}`);
+                t = i
+            }
+            return e
+        }, () => new Aw(t)
     }
 
-    function JO(e) {
-        return Math.max(0, -Ru(Math.abs(e)))
+    function HW(e) {
+        return e.innerRadius
     }
 
-    function QO(e, t) {
-        return Math.max(0, Math.max(-8, Math.min(8, Math.floor(Ru(t) / 3))) * 3 - Ru(Math.abs(e)))
+    function YW(e) {
+        return e.outerRadius
     }
 
-    function ZO(e, t) {
-        return e = Math.abs(e), t = Math.abs(t) - e, Math.max(0, Ru(t) - Ru(e)) + 1
+    function XW(e) {
+        return e.startAngle
     }
-    var ve = 1e-6,
-        Mp = 1e-12,
-        Oe = Math.PI,
-        vt = Oe / 2,
-        Op = Oe / 4,
-        Ln = Oe * 2,
-        St = 180 / Oe,
-        Me = Oe / 180,
-        Re = Math.abs,
-        pc = Math.atan,
-        Fi = Math.atan2,
-        xe = Math.cos,
-        sg = Math.ceil,
-        eF = Math.exp,
-        mb = Math.hypot,
-        Fp = Math.log,
-        Ty = Math.pow,
-        pe = Math.sin,
-        ki = Math.sign || function(e) {
-            return e > 0 ? 1 : e < 0 ? -1 : 0
-        },
-        In = Math.sqrt,
-        Rx = Math.tan;
 
-    function tF(e) {
-        return e > 1 ? 0 : e < -1 ? Oe : Math.acos(e)
+    function VW(e) {
+        return e.endAngle
     }
 
-    function ti(e) {
-        return e > 1 ? vt : e < -1 ? -vt : Math.asin(e)
+    function KW(e) {
+        return e && e.padAngle
     }
 
-    function Vt() {}
+    function JW(e, t, n, i, r, s, a, o) {
+        var l = n - e,
+            u = i - t,
+            c = a - r,
+            f = o - s,
+            h = f * l - c * u;
+        if (!(h * h < kn)) return h = (c * (t - s) - f * (e - r)) / h, [e + h * l, t + h * u]
+    }
 
-    function Rp(e, t) {
-        e && nA.hasOwnProperty(e.type) && nA[e.type](e, t)
+    function Eg(e, t, n, i, r, s, a) {
+        var o = e - n,
+            l = t - i,
+            u = (a ? s : -s) / rl(o * o + l * l),
+            c = u * l,
+            f = -u * o,
+            h = e + c,
+            d = t + f,
+            g = n + c,
+            p = i + f,
+            m = (h + g) / 2,
+            y = (d + p) / 2,
+            v = g - h,
+            b = p - d,
+            x = v * v + b * b,
+            _ = r - s,
+            S = h * p - g * d,
+            w = (b < 0 ? -1 : 1) * rl(GW(0, _ * _ * x - S * S)),
+            E = (S * b - v * w) / x,
+            C = (-S * v - b * w) / x,
+            k = (S * b + v * w) / x,
+            A = (-S * v + b * w) / x,
+            F = E - m,
+            $ = C - y,
+            T = k - m,
+            M = A - y;
+        return F * F + $ * $ > T * T + M * M && (E = k, C = A), {
+            cx: E,
+            cy: C,
+            x01: -c,
+            y01: -f,
+            x11: E * (r / _ - 1),
+            y11: C * (r / _ - 1)
+        }
     }
-    var tA = {
-            Feature: function(e, t) {
-                Rp(e.geometry, t)
-            },
-            FeatureCollection: function(e, t) {
-                for (var n = e.features, i = -1, r = n.length; ++i < r;) Rp(n[i].geometry, t)
-            }
-        },
-        nA = {
-            Sphere: function(e, t) {
-                t.sphere()
-            },
-            Point: function(e, t) {
-                e = e.coordinates, t.point(e[0], e[1], e[2])
-            },
-            MultiPoint: function(e, t) {
-                for (var n = e.coordinates, i = -1, r = n.length; ++i < r;) e = n[i], t.point(e[0], e[1], e[2])
-            },
-            LineString: function(e, t) {
-                yb(e.coordinates, t, 0)
-            },
-            MultiLineString: function(e, t) {
-                for (var n = e.coordinates, i = -1, r = n.length; ++i < r;) yb(n[i], t, 0)
-            },
-            Polygon: function(e, t) {
-                iA(e.coordinates, t)
-            },
-            MultiPolygon: function(e, t) {
-                for (var n = e.coordinates, i = -1, r = n.length; ++i < r;) iA(n[i], t)
-            },
-            GeometryCollection: function(e, t) {
-                for (var n = e.geometries, i = -1, r = n.length; ++i < r;) Rp(n[i], t)
-            }
-        };
 
-    function yb(e, t, n) {
-        var i = -1,
-            r = e.length - n,
-            s;
-        for (t.lineStart(); ++i < r;) s = e[i], t.point(s[0], s[1], s[2]);
-        t.lineEnd()
+    function QW() {
+        var e = HW,
+            t = YW,
+            n = rt(0),
+            i = null,
+            r = XW,
+            s = VW,
+            a = KW,
+            o = null,
+            l = s1(u);
+
+        function u() {
+            var c, f, h = +e.apply(this, arguments),
+                d = +t.apply(this, arguments),
+                g = r.apply(this, arguments) - cm,
+                p = s.apply(this, arguments) - cm,
+                m = zA(p - g),
+                y = p > g;
+            if (o || (o = c = l()), d < h && (f = d, d = h, h = f), !(d > kn)) o.moveTo(0, 0);
+            else if (m > dD - kn) o.moveTo(d * No(g), d * jr(g)), o.arc(0, 0, d, g, p, !y), h > kn && (o.moveTo(h * No(p), h * jr(p)), o.arc(0, 0, h, p, g, y));
+            else {
+                var v = g,
+                    b = p,
+                    x = g,
+                    _ = p,
+                    S = m,
+                    w = m,
+                    E = a.apply(this, arguments) / 2,
+                    C = E > kn && (i ? +i.apply(this, arguments) : rl(h * h + d * d)),
+                    k = av(zA(d - h) / 2, +n.apply(this, arguments)),
+                    A = k,
+                    F = k,
+                    $, T;
+                if (C > kn) {
+                    var M = BA(C / h * jr(E)),
+                        R = BA(C / d * jr(E));
+                    (S -= M * 2) > kn ? (M *= y ? 1 : -1, x += M, _ -= M) : (S = 0, x = _ = (g + p) / 2), (w -= R * 2) > kn ? (R *= y ? 1 : -1, v += R, b -= R) : (w = 0, v = b = (g + p) / 2)
+                }
+                var N = d * No(v),
+                    L = d * jr(v),
+                    I = h * No(_),
+                    G = h * jr(_);
+                if (k > kn) {
+                    var ie = d * No(b),
+                        ge = d * jr(b),
+                        Re = h * No(x),
+                        Te = h * jr(x),
+                        tt;
+                    if (m < uc)
+                        if (tt = JW(N, L, Re, Te, ie, ge, I, G)) {
+                            var wn = N - tt[0],
+                                Pi = L - tt[1],
+                                xi = ie - tt[0],
+                                ae = ge - tt[1],
+                                _e = 1 / jr(UW((wn * xi + Pi * ae) / (rl(wn * wn + Pi * Pi) * rl(xi * xi + ae * ae))) / 2),
+                                Ae = rl(tt[0] * tt[0] + tt[1] * tt[1]);
+                            A = av(k, (h - Ae) / (_e - 1)), F = av(k, (d - Ae) / (_e + 1))
+                        } else A = F = 0
+                }
+                w > kn ? F > kn ? ($ = Eg(Re, Te, N, L, d, F, y), T = Eg(ie, ge, I, G, d, F, y), o.moveTo($.cx + $.x01, $.cy + $.y01), F < k ? o.arc($.cx, $.cy, F, Sn($.y01, $.x01), Sn(T.y01, T.x01), !y) : (o.arc($.cx, $.cy, F, Sn($.y01, $.x01), Sn($.y11, $.x11), !y), o.arc(0, 0, d, Sn($.cy + $.y11, $.cx + $.x11), Sn(T.cy + T.y11, T.cx + T.x11), !y), o.arc(T.cx, T.cy, F, Sn(T.y11, T.x11), Sn(T.y01, T.x01), !y))) : (o.moveTo(N, L), o.arc(0, 0, d, v, b, !y)) : o.moveTo(N, L), !(h > kn) || !(S > kn) ? o.lineTo(I, G) : A > kn ? ($ = Eg(I, G, ie, ge, h, -A, y), T = Eg(N, L, Re, Te, h, -A, y), o.lineTo($.cx + $.x01, $.cy + $.y01), A < k ? o.arc($.cx, $.cy, A, Sn($.y01, $.x01), Sn(T.y01, T.x01), !y) : (o.arc($.cx, $.cy, A, Sn($.y01, $.x01), Sn($.y11, $.x11), !y), o.arc(0, 0, h, Sn($.cy + $.y11, $.cx + $.x11), Sn(T.cy + T.y11, T.cx + T.x11), y), o.arc(T.cx, T.cy, A, Sn(T.y11, T.x11), Sn(T.y01, T.x01), !y))) : o.arc(0, 0, h, _, x, y)
+            }
+            if (o.closePath(), c) return o = null, c + "" || null
+        }
+        return u.centroid = function() {
+            var c = (+e.apply(this, arguments) + +t.apply(this, arguments)) / 2,
+                f = (+r.apply(this, arguments) + +s.apply(this, arguments)) / 2 - uc / 2;
+            return [No(f) * c, jr(f) * c]
+        }, u.innerRadius = function(c) {
+            return arguments.length ? (e = typeof c == "function" ? c : rt(+c), u) : e
+        }, u.outerRadius = function(c) {
+            return arguments.length ? (t = typeof c == "function" ? c : rt(+c), u) : t
+        }, u.cornerRadius = function(c) {
+            return arguments.length ? (n = typeof c == "function" ? c : rt(+c), u) : n
+        }, u.padRadius = function(c) {
+            return arguments.length ? (i = c == null ? null : typeof c == "function" ? c : rt(+c), u) : i
+        }, u.startAngle = function(c) {
+            return arguments.length ? (r = typeof c == "function" ? c : rt(+c), u) : r
+        }, u.endAngle = function(c) {
+            return arguments.length ? (s = typeof c == "function" ? c : rt(+c), u) : s
+        }, u.padAngle = function(c) {
+            return arguments.length ? (a = typeof c == "function" ? c : rt(+c), u) : a
+        }, u.context = function(c) {
+            return arguments.length ? (o = c ?? null, u) : o
+        }, u
     }
 
-    function iA(e, t) {
-        var n = -1,
-            i = e.length;
-        for (t.polygonStart(); ++n < i;) yb(e[n], t, 1);
-        t.polygonEnd()
+    function pD(e) {
+        return typeof e == "object" && "length" in e ? e : Array.from(e)
     }
 
-    function ws(e, t) {
-        e && tA.hasOwnProperty(e.type) ? tA[e.type](e, t) : Rp(e, t)
+    function mD(e) {
+        this._context = e
     }
-    var Dp = new Rn,
-        Np = new Rn,
-        nF, iF, vb, bb, xb, Gr = {
-            point: Vt,
-            lineStart: Vt,
-            lineEnd: Vt,
-            polygonStart: function() {
-                Dp = new Rn, Gr.lineStart = KU, Gr.lineEnd = JU
-            },
-            polygonEnd: function() {
-                var e = +Dp;
-                Np.add(e < 0 ? Ln + e : e), this.lineStart = this.lineEnd = this.point = Vt
-            },
-            sphere: function() {
-                Np.add(Ln)
+    mD.prototype = {
+        areaStart: function() {
+            this._line = 0
+        },
+        areaEnd: function() {
+            this._line = NaN
+        },
+        lineStart: function() {
+            this._point = 0
+        },
+        lineEnd: function() {
+            (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line
+        },
+        point: function(e, t) {
+            switch (e = +e, t = +t, this._point) {
+                case 0:
+                    this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
+                    break;
+                case 1:
+                    this._point = 2;
+                default:
+                    this._context.lineTo(e, t);
+                    break
             }
-        };
+        }
+    };
 
-    function KU() {
-        Gr.point = QU
+    function $w(e) {
+        return new mD(e)
     }
 
-    function JU() {
-        rF(nF, iF)
+    function yD(e) {
+        return e[0]
     }
 
-    function QU(e, t) {
-        Gr.point = rF, nF = e, iF = t, e *= Me, t *= Me, vb = e, bb = xe(t = t / 2 + Op), xb = pe(t)
+    function vD(e) {
+        return e[1]
     }
 
-    function rF(e, t) {
-        e *= Me, t *= Me, t = t / 2 + Op;
-        var n = e - vb,
-            i = n >= 0 ? 1 : -1,
-            r = i * n,
-            s = xe(t),
-            a = pe(t),
-            o = xb * a,
-            l = bb * s + o * xe(r),
-            u = o * i * pe(r);
-        Dp.add(Fi(u, l)), vb = e, bb = s, xb = a
-    }
+    function bD(e, t) {
+        var n = rt(!0),
+            i = null,
+            r = $w,
+            s = null,
+            a = s1(o);
+        e = typeof e == "function" ? e : e === void 0 ? yD : rt(e), t = typeof t == "function" ? t : t === void 0 ? vD : rt(t);
 
-    function ZU(e) {
-        return Np = new Rn, ws(e, Gr), Np * 2
+        function o(l) {
+            var u, c = (l = pD(l)).length,
+                f, h = !1,
+                d;
+            for (i == null && (s = r(d = a())), u = 0; u <= c; ++u) !(u < c && n(f = l[u], u, l)) === h && ((h = !h) ? s.lineStart() : s.lineEnd()), h && s.point(+e(f, u, l), +t(f, u, l));
+            if (d) return s = null, d + "" || null
+        }
+        return o.x = function(l) {
+            return arguments.length ? (e = typeof l == "function" ? l : rt(+l), o) : e
+        }, o.y = function(l) {
+            return arguments.length ? (t = typeof l == "function" ? l : rt(+l), o) : t
+        }, o.defined = function(l) {
+            return arguments.length ? (n = typeof l == "function" ? l : rt(!!l), o) : n
+        }, o.curve = function(l) {
+            return arguments.length ? (r = l, i != null && (s = r(i)), o) : r
+        }, o.context = function(l) {
+            return arguments.length ? (l == null ? i = s = null : s = r(i = l), o) : i
+        }, o
     }
 
-    function Pp(e) {
-        return [Fi(e[1], e[0]), ti(e[2])]
-    }
+    function xD(e, t, n) {
+        var i = null,
+            r = rt(!0),
+            s = null,
+            a = $w,
+            o = null,
+            l = s1(u);
+        e = typeof e == "function" ? e : e === void 0 ? yD : rt(+e), t = typeof t == "function" ? t : rt(t === void 0 ? 0 : +t), n = typeof n == "function" ? n : n === void 0 ? vD : rt(+n);
 
-    function Zo(e) {
-        var t = e[0],
-            n = e[1],
-            i = xe(n);
-        return [i * xe(t), i * pe(t), pe(n)]
+        function u(f) {
+            var h, d, g, p = (f = pD(f)).length,
+                m, y = !1,
+                v, b = new Array(p),
+                x = new Array(p);
+            for (s == null && (o = a(v = l())), h = 0; h <= p; ++h) {
+                if (!(h < p && r(m = f[h], h, f)) === y)
+                    if (y = !y) d = h, o.areaStart(), o.lineStart();
+                    else {
+                        for (o.lineEnd(), o.lineStart(), g = h - 1; g >= d; --g) o.point(b[g], x[g]);
+                        o.lineEnd(), o.areaEnd()
+                    } y && (b[h] = +e(m, h, f), x[h] = +t(m, h, f), o.point(i ? +i(m, h, f) : b[h], n ? +n(m, h, f) : x[h]))
+            }
+            if (v) return o = null, v + "" || null
+        }
+
+        function c() {
+            return bD().defined(r).curve(a).context(s)
+        }
+        return u.x = function(f) {
+            return arguments.length ? (e = typeof f == "function" ? f : rt(+f), i = null, u) : e
+        }, u.x0 = function(f) {
+            return arguments.length ? (e = typeof f == "function" ? f : rt(+f), u) : e
+        }, u.x1 = function(f) {
+            return arguments.length ? (i = f == null ? null : typeof f == "function" ? f : rt(+f), u) : i
+        }, u.y = function(f) {
+            return arguments.length ? (t = typeof f == "function" ? f : rt(+f), n = null, u) : t
+        }, u.y0 = function(f) {
+            return arguments.length ? (t = typeof f == "function" ? f : rt(+f), u) : t
+        }, u.y1 = function(f) {
+            return arguments.length ? (n = f == null ? null : typeof f == "function" ? f : rt(+f), u) : n
+        }, u.lineX0 = u.lineY0 = function() {
+            return c().x(e).y(t)
+        }, u.lineY1 = function() {
+            return c().x(e).y(n)
+        }, u.lineX1 = function() {
+            return c().x(i).y(t)
+        }, u.defined = function(f) {
+            return arguments.length ? (r = typeof f == "function" ? f : rt(!!f), u) : r
+        }, u.curve = function(f) {
+            return arguments.length ? (a = f, s != null && (o = a(s)), u) : a
+        }, u.context = function(f) {
+            return arguments.length ? (f == null ? s = o = null : o = a(s = f), u) : s
+        }, u
     }
+    const ZW = {
+        draw(e, t) {
+            const n = rl(t / uc);
+            e.moveTo(n, 0), e.arc(0, 0, n, 0, dD)
+        }
+    };
 
-    function ag(e, t) {
-        return e[0] * t[0] + e[1] * t[1] + e[2] * t[2]
+    function eq(e, t) {
+        let n = null,
+            i = s1(r);
+        e = typeof e == "function" ? e : rt(e || ZW), t = typeof t == "function" ? t : rt(t === void 0 ? 64 : +t);
+
+        function r() {
+            let s;
+            if (n || (n = s = i()), e.apply(this, arguments).draw(n, +t.apply(this, arguments)), s) return n = null, s + "" || null
+        }
+        return r.type = function(s) {
+            return arguments.length ? (e = typeof s == "function" ? s : rt(s), r) : e
+        }, r.size = function(s) {
+            return arguments.length ? (t = typeof s == "function" ? s : rt(+s), r) : t
+        }, r.context = function(s) {
+            return arguments.length ? (n = s ?? null, r) : n
+        }, r
     }
 
-    function Du(e, t) {
-        return [e[1] * t[2] - e[2] * t[1], e[2] * t[0] - e[0] * t[2], e[0] * t[1] - e[1] * t[0]]
+    function eo() {}
+
+    function fm(e, t, n) {
+        e._context.bezierCurveTo((2 * e._x0 + e._x1) / 3, (2 * e._y0 + e._y1) / 3, (e._x0 + 2 * e._x1) / 3, (e._y0 + 2 * e._y1) / 3, (e._x0 + 4 * e._x1 + t) / 6, (e._y0 + 4 * e._y1 + n) / 6)
     }
 
-    function My(e, t) {
-        e[0] += t[0], e[1] += t[1], e[2] += t[2]
+    function a1(e) {
+        this._context = e
     }
+    a1.prototype = {
+        areaStart: function() {
+            this._line = 0
+        },
+        areaEnd: function() {
+            this._line = NaN
+        },
+        lineStart: function() {
+            this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0
+        },
+        lineEnd: function() {
+            switch (this._point) {
+                case 3:
+                    fm(this, this._x1, this._y1);
+                case 2:
+                    this._context.lineTo(this._x1, this._y1);
+                    break
+            }(this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line
+        },
+        point: function(e, t) {
+            switch (e = +e, t = +t, this._point) {
+                case 0:
+                    this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
+                    break;
+                case 1:
+                    this._point = 2;
+                    break;
+                case 2:
+                    this._point = 3, this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
+                default:
+                    fm(this, e, t);
+                    break
+            }
+            this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t
+        }
+    };
 
-    function og(e, t) {
-        return [e[0] * t, e[1] * t, e[2] * t]
+    function tq(e) {
+        return new a1(e)
     }
 
-    function Lp(e) {
-        var t = In(e[0] * e[0] + e[1] * e[1] + e[2] * e[2]);
-        e[0] /= t, e[1] /= t, e[2] /= t
+    function _D(e) {
+        this._context = e
     }
-    var dt, qn, mt, hi, Co, sF, aF, _u, Kf, aa, Ls, bs = {
-        point: _b,
-        lineStart: rA,
-        lineEnd: sA,
-        polygonStart: function() {
-            bs.point = lF, bs.lineStart = eG, bs.lineEnd = tG, Kf = new Rn, Gr.polygonStart()
+    _D.prototype = {
+        areaStart: eo,
+        areaEnd: eo,
+        lineStart: function() {
+            this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN, this._point = 0
         },
-        polygonEnd: function() {
-            Gr.polygonEnd(), bs.point = _b, bs.lineStart = rA, bs.lineEnd = sA, Dp < 0 ? (dt = -(mt = 180), qn = -(hi = 90)) : Kf > ve ? hi = 90 : Kf < -ve && (qn = -90), Ls[0] = dt, Ls[1] = mt
+        lineEnd: function() {
+            switch (this._point) {
+                case 1: {
+                    this._context.moveTo(this._x2, this._y2), this._context.closePath();
+                    break
+                }
+                case 2: {
+                    this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3), this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3), this._context.closePath();
+                    break
+                }
+                case 3: {
+                    this.point(this._x2, this._y2), this.point(this._x3, this._y3), this.point(this._x4, this._y4);
+                    break
+                }
+            }
         },
-        sphere: function() {
-            dt = -(mt = 180), qn = -(hi = 90)
+        point: function(e, t) {
+            switch (e = +e, t = +t, this._point) {
+                case 0:
+                    this._point = 1, this._x2 = e, this._y2 = t;
+                    break;
+                case 1:
+                    this._point = 2, this._x3 = e, this._y3 = t;
+                    break;
+                case 2:
+                    this._point = 3, this._x4 = e, this._y4 = t, this._context.moveTo((this._x0 + 4 * this._x1 + e) / 6, (this._y0 + 4 * this._y1 + t) / 6);
+                    break;
+                default:
+                    fm(this, e, t);
+                    break
+            }
+            this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t
         }
     };
 
-    function _b(e, t) {
-        aa.push(Ls = [dt = e, mt = e]), t < qn && (qn = t), t > hi && (hi = t)
+    function nq(e) {
+        return new _D(e)
     }
 
-    function oF(e, t) {
-        var n = Zo([e * Me, t * Me]);
-        if (_u) {
-            var i = Du(_u, n),
-                r = [i[1], -i[0], 0],
-                s = Du(r, i);
-            Lp(s), s = Pp(s);
-            var a = e - Co,
-                o = a > 0 ? 1 : -1,
-                l = s[0] * St * o,
-                u, c = Re(a) > 180;
-            c ^ (o * Co < l && l < o * e) ? (u = s[1] * St, u > hi && (hi = u)) : (l = (l + 360) % 360 - 180, c ^ (o * Co < l && l < o * e) ? (u = -s[1] * St, u < qn && (qn = u)) : (t < qn && (qn = t), t > hi && (hi = t))), c ? e < Co ? fi(dt, e) > fi(dt, mt) && (mt = e) : fi(e, mt) > fi(dt, mt) && (dt = e) : mt >= dt ? (e < dt && (dt = e), e > mt && (mt = e)) : e > Co ? fi(dt, e) > fi(dt, mt) && (mt = e) : fi(e, mt) > fi(dt, mt) && (dt = e)
-        } else aa.push(Ls = [dt = e, mt = e]);
-        t < qn && (qn = t), t > hi && (hi = t), _u = n, Co = e
+    function wD(e) {
+        this._context = e
     }
+    wD.prototype = {
+        areaStart: function() {
+            this._line = 0
+        },
+        areaEnd: function() {
+            this._line = NaN
+        },
+        lineStart: function() {
+            this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0
+        },
+        lineEnd: function() {
+            (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line
+        },
+        point: function(e, t) {
+            switch (e = +e, t = +t, this._point) {
+                case 0:
+                    this._point = 1;
+                    break;
+                case 1:
+                    this._point = 2;
+                    break;
+                case 2:
+                    this._point = 3;
+                    var n = (this._x0 + 4 * this._x1 + e) / 6,
+                        i = (this._y0 + 4 * this._y1 + t) / 6;
+                    this._line ? this._context.lineTo(n, i) : this._context.moveTo(n, i);
+                    break;
+                case 3:
+                    this._point = 4;
+                default:
+                    fm(this, e, t);
+                    break
+            }
+            this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t
+        }
+    };
 
-    function rA() {
-        bs.point = oF
+    function iq(e) {
+        return new wD(e)
     }
 
-    function sA() {
-        Ls[0] = dt, Ls[1] = mt, bs.point = _b, _u = null
+    function SD(e, t) {
+        this._basis = new a1(e), this._beta = t
     }
+    SD.prototype = {
+        lineStart: function() {
+            this._x = [], this._y = [], this._basis.lineStart()
+        },
+        lineEnd: function() {
+            var e = this._x,
+                t = this._y,
+                n = e.length - 1;
+            if (n > 0)
+                for (var i = e[0], r = t[0], s = e[n] - i, a = t[n] - r, o = -1, l; ++o <= n;) l = o / n, this._basis.point(this._beta * e[o] + (1 - this._beta) * (i + l * s), this._beta * t[o] + (1 - this._beta) * (r + l * a));
+            this._x = this._y = null, this._basis.lineEnd()
+        },
+        point: function(e, t) {
+            this._x.push(+e), this._y.push(+t)
+        }
+    };
+    const rq = function e(t) {
+        function n(i) {
+            return t === 1 ? new a1(i) : new SD(i, t)
+        }
+        return n.beta = function(i) {
+            return e(+i)
+        }, n
+    }(.85);
 
-    function lF(e, t) {
-        if (_u) {
-            var n = e - Co;
-            Kf.add(Re(n) > 180 ? n + (n > 0 ? 360 : -360) : n)
-        } else sF = e, aF = t;
-        Gr.point(e, t), oF(e, t)
+    function hm(e, t, n) {
+        e._context.bezierCurveTo(e._x1 + e._k * (e._x2 - e._x0), e._y1 + e._k * (e._y2 - e._y0), e._x2 + e._k * (e._x1 - t), e._y2 + e._k * (e._y1 - n), e._x2, e._y2)
     }
 
-    function eG() {
-        Gr.lineStart()
+    function Tw(e, t) {
+        this._context = e, this._k = (1 - t) / 6
     }
+    Tw.prototype = {
+        areaStart: function() {
+            this._line = 0
+        },
+        areaEnd: function() {
+            this._line = NaN
+        },
+        lineStart: function() {
+            this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0
+        },
+        lineEnd: function() {
+            switch (this._point) {
+                case 2:
+                    this._context.lineTo(this._x2, this._y2);
+                    break;
+                case 3:
+                    hm(this, this._x1, this._y1);
+                    break
+            }(this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line
+        },
+        point: function(e, t) {
+            switch (e = +e, t = +t, this._point) {
+                case 0:
+                    this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
+                    break;
+                case 1:
+                    this._point = 2, this._x1 = e, this._y1 = t;
+                    break;
+                case 2:
+                    this._point = 3;
+                default:
+                    hm(this, e, t);
+                    break
+            }
+            this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t
+        }
+    };
+    const sq = function e(t) {
+        function n(i) {
+            return new Tw(i, t)
+        }
+        return n.tension = function(i) {
+            return e(+i)
+        }, n
+    }(0);
 
-    function tG() {
-        lF(sF, aF), Gr.lineEnd(), Re(Kf) > ve && (dt = -(mt = 180)), Ls[0] = dt, Ls[1] = mt, _u = null
+    function Mw(e, t) {
+        this._context = e, this._k = (1 - t) / 6
     }
+    Mw.prototype = {
+        areaStart: eo,
+        areaEnd: eo,
+        lineStart: function() {
+            this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._point = 0
+        },
+        lineEnd: function() {
+            switch (this._point) {
+                case 1: {
+                    this._context.moveTo(this._x3, this._y3), this._context.closePath();
+                    break
+                }
+                case 2: {
+                    this._context.lineTo(this._x3, this._y3), this._context.closePath();
+                    break
+                }
+                case 3: {
+                    this.point(this._x3, this._y3), this.point(this._x4, this._y4), this.point(this._x5, this._y5);
+                    break
+                }
+            }
+        },
+        point: function(e, t) {
+            switch (e = +e, t = +t, this._point) {
+                case 0:
+                    this._point = 1, this._x3 = e, this._y3 = t;
+                    break;
+                case 1:
+                    this._point = 2, this._context.moveTo(this._x4 = e, this._y4 = t);
+                    break;
+                case 2:
+                    this._point = 3, this._x5 = e, this._y5 = t;
+                    break;
+                default:
+                    hm(this, e, t);
+                    break
+            }
+            this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t
+        }
+    };
+    const aq = function e(t) {
+        function n(i) {
+            return new Mw(i, t)
+        }
+        return n.tension = function(i) {
+            return e(+i)
+        }, n
+    }(0);
 
-    function fi(e, t) {
-        return (t -= e) < 0 ? t + 360 : t
+    function Ow(e, t) {
+        this._context = e, this._k = (1 - t) / 6
     }
+    Ow.prototype = {
+        areaStart: function() {
+            this._line = 0
+        },
+        areaEnd: function() {
+            this._line = NaN
+        },
+        lineStart: function() {
+            this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0
+        },
+        lineEnd: function() {
+            (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line
+        },
+        point: function(e, t) {
+            switch (e = +e, t = +t, this._point) {
+                case 0:
+                    this._point = 1;
+                    break;
+                case 1:
+                    this._point = 2;
+                    break;
+                case 2:
+                    this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
+                    break;
+                case 3:
+                    this._point = 4;
+                default:
+                    hm(this, e, t);
+                    break
+            }
+            this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t
+        }
+    };
+    const oq = function e(t) {
+        function n(i) {
+            return new Ow(i, t)
+        }
+        return n.tension = function(i) {
+            return e(+i)
+        }, n
+    }(0);
 
-    function nG(e, t) {
-        return e[0] - t[0]
+    function Fw(e, t, n) {
+        var i = e._x1,
+            r = e._y1,
+            s = e._x2,
+            a = e._y2;
+        if (e._l01_a > kn) {
+            var o = 2 * e._l01_2a + 3 * e._l01_a * e._l12_a + e._l12_2a,
+                l = 3 * e._l01_a * (e._l01_a + e._l12_a);
+            i = (i * o - e._x0 * e._l12_2a + e._x2 * e._l01_2a) / l, r = (r * o - e._y0 * e._l12_2a + e._y2 * e._l01_2a) / l
+        }
+        if (e._l23_a > kn) {
+            var u = 2 * e._l23_2a + 3 * e._l23_a * e._l12_a + e._l12_2a,
+                c = 3 * e._l23_a * (e._l23_a + e._l12_a);
+            s = (s * u + e._x1 * e._l23_2a - t * e._l12_2a) / c, a = (a * u + e._y1 * e._l23_2a - n * e._l12_2a) / c
+        }
+        e._context.bezierCurveTo(i, r, s, a, e._x2, e._y2)
     }
 
-    function aA(e, t) {
-        return e[0] <= e[1] ? e[0] <= t && t <= e[1] : t < e[0] || e[1] < t
+    function ED(e, t) {
+        this._context = e, this._alpha = t
     }
+    ED.prototype = {
+        areaStart: function() {
+            this._line = 0
+        },
+        areaEnd: function() {
+            this._line = NaN
+        },
+        lineStart: function() {
+            this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0
+        },
+        lineEnd: function() {
+            switch (this._point) {
+                case 2:
+                    this._context.lineTo(this._x2, this._y2);
+                    break;
+                case 3:
+                    this.point(this._x2, this._y2);
+                    break
+            }(this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line
+        },
+        point: function(e, t) {
+            if (e = +e, t = +t, this._point) {
+                var n = this._x2 - e,
+                    i = this._y2 - t;
+                this._l23_a = Math.sqrt(this._l23_2a = Math.pow(n * n + i * i, this._alpha))
+            }
+            switch (this._point) {
+                case 0:
+                    this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
+                    break;
+                case 1:
+                    this._point = 2;
+                    break;
+                case 2:
+                    this._point = 3;
+                default:
+                    Fw(this, e, t);
+                    break
+            }
+            this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t
+        }
+    };
+    const lq = function e(t) {
+        function n(i) {
+            return t ? new ED(i, t) : new Tw(i, 0)
+        }
+        return n.alpha = function(i) {
+            return e(+i)
+        }, n
+    }(.5);
 
-    function iG(e) {
-        var t, n, i, r, s, a, o;
-        if (hi = mt = -(dt = qn = 1 / 0), aa = [], ws(e, bs), n = aa.length) {
-            for (aa.sort(nG), t = 1, i = aa[0], s = [i]; t < n; ++t) r = aa[t], aA(i, r[0]) || aA(i, r[1]) ? (fi(i[0], r[1]) > fi(i[0], i[1]) && (i[1] = r[1]), fi(r[0], i[1]) > fi(i[0], i[1]) && (i[0] = r[0])) : s.push(i = r);
-            for (a = -1 / 0, n = s.length - 1, t = 0, i = s[n]; t <= n; i = r, ++t) r = s[t], (o = fi(i[1], r[0])) > a && (a = o, dt = r[0], mt = i[1])
+    function kD(e, t) {
+        this._context = e, this._alpha = t
+    }
+    kD.prototype = {
+        areaStart: eo,
+        areaEnd: eo,
+        lineStart: function() {
+            this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0
+        },
+        lineEnd: function() {
+            switch (this._point) {
+                case 1: {
+                    this._context.moveTo(this._x3, this._y3), this._context.closePath();
+                    break
+                }
+                case 2: {
+                    this._context.lineTo(this._x3, this._y3), this._context.closePath();
+                    break
+                }
+                case 3: {
+                    this.point(this._x3, this._y3), this.point(this._x4, this._y4), this.point(this._x5, this._y5);
+                    break
+                }
+            }
+        },
+        point: function(e, t) {
+            if (e = +e, t = +t, this._point) {
+                var n = this._x2 - e,
+                    i = this._y2 - t;
+                this._l23_a = Math.sqrt(this._l23_2a = Math.pow(n * n + i * i, this._alpha))
+            }
+            switch (this._point) {
+                case 0:
+                    this._point = 1, this._x3 = e, this._y3 = t;
+                    break;
+                case 1:
+                    this._point = 2, this._context.moveTo(this._x4 = e, this._y4 = t);
+                    break;
+                case 2:
+                    this._point = 3, this._x5 = e, this._y5 = t;
+                    break;
+                default:
+                    Fw(this, e, t);
+                    break
+            }
+            this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t
         }
-        return aa = Ls = null, dt === 1 / 0 || qn === 1 / 0 ? [
-            [NaN, NaN],
-            [NaN, NaN]
-        ] : [
-            [dt, qn],
-            [mt, hi]
-        ]
+    };
+    const uq = function e(t) {
+        function n(i) {
+            return t ? new kD(i, t) : new Mw(i, 0)
+        }
+        return n.alpha = function(i) {
+            return e(+i)
+        }, n
+    }(.5);
+
+    function CD(e, t) {
+        this._context = e, this._alpha = t
     }
-    var Ef, Ip, zp, Bp, jp, Up, Gp, Wp, wb, Sb, Eb, uF, cF, $n, Tn, Mn, tr = {
-        sphere: Vt,
-        point: Dx,
-        lineStart: oA,
-        lineEnd: lA,
-        polygonStart: function() {
-            tr.lineStart = aG, tr.lineEnd = oG
+    CD.prototype = {
+        areaStart: function() {
+            this._line = 0
         },
-        polygonEnd: function() {
-            tr.lineStart = oA, tr.lineEnd = lA
+        areaEnd: function() {
+            this._line = NaN
+        },
+        lineStart: function() {
+            this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0
+        },
+        lineEnd: function() {
+            (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line
+        },
+        point: function(e, t) {
+            if (e = +e, t = +t, this._point) {
+                var n = this._x2 - e,
+                    i = this._y2 - t;
+                this._l23_a = Math.sqrt(this._l23_2a = Math.pow(n * n + i * i, this._alpha))
+            }
+            switch (this._point) {
+                case 0:
+                    this._point = 1;
+                    break;
+                case 1:
+                    this._point = 2;
+                    break;
+                case 2:
+                    this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
+                    break;
+                case 3:
+                    this._point = 4;
+                default:
+                    Fw(this, e, t);
+                    break
+            }
+            this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t
         }
     };
+    const cq = function e(t) {
+        function n(i) {
+            return t ? new CD(i, t) : new Ow(i, 0)
+        }
+        return n.alpha = function(i) {
+            return e(+i)
+        }, n
+    }(.5);
 
-    function Dx(e, t) {
-        e *= Me, t *= Me;
-        var n = xe(t);
-        td(n * xe(e), n * pe(e), pe(t))
+    function AD(e) {
+        this._context = e
     }
+    AD.prototype = {
+        areaStart: eo,
+        areaEnd: eo,
+        lineStart: function() {
+            this._point = 0
+        },
+        lineEnd: function() {
+            this._point && this._context.closePath()
+        },
+        point: function(e, t) {
+            e = +e, t = +t, this._point ? this._context.lineTo(e, t) : (this._point = 1, this._context.moveTo(e, t))
+        }
+    };
 
-    function td(e, t, n) {
-        ++Ef, zp += (e - zp) / Ef, Bp += (t - Bp) / Ef, jp += (n - jp) / Ef
+    function fq(e) {
+        return new AD(e)
     }
 
-    function oA() {
-        tr.point = rG
+    function jA(e) {
+        return e < 0 ? -1 : 1
     }
 
-    function rG(e, t) {
-        e *= Me, t *= Me;
-        var n = xe(t);
-        $n = n * xe(e), Tn = n * pe(e), Mn = pe(t), tr.point = sG, td($n, Tn, Mn)
+    function GA(e, t, n) {
+        var i = e._x1 - e._x0,
+            r = t - e._x1,
+            s = (e._y1 - e._y0) / (i || r < 0 && -0),
+            a = (n - e._y1) / (r || i < 0 && -0),
+            o = (s * r + a * i) / (i + r);
+        return (jA(s) + jA(a)) * Math.min(Math.abs(s), Math.abs(a), .5 * Math.abs(o)) || 0
     }
 
-    function sG(e, t) {
-        e *= Me, t *= Me;
-        var n = xe(t),
-            i = n * xe(e),
-            r = n * pe(e),
-            s = pe(t),
-            a = Fi(In((a = Tn * s - Mn * r) * a + (a = Mn * i - $n * s) * a + (a = $n * r - Tn * i) * a), $n * i + Tn * r + Mn * s);
-        Ip += a, Up += a * ($n + ($n = i)), Gp += a * (Tn + (Tn = r)), Wp += a * (Mn + (Mn = s)), td($n, Tn, Mn)
+    function UA(e, t) {
+        var n = e._x1 - e._x0;
+        return n ? (3 * (e._y1 - e._y0) / n - t) / 2 : t
     }
 
-    function lA() {
-        tr.point = Dx
+    function ov(e, t, n) {
+        var i = e._x0,
+            r = e._y0,
+            s = e._x1,
+            a = e._y1,
+            o = (s - i) / 3;
+        e._context.bezierCurveTo(i + o, r + o * t, s - o, a - o * n, s, a)
     }
 
-    function aG() {
-        tr.point = lG
+    function dm(e) {
+        this._context = e
     }
+    dm.prototype = {
+        areaStart: function() {
+            this._line = 0
+        },
+        areaEnd: function() {
+            this._line = NaN
+        },
+        lineStart: function() {
+            this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN, this._point = 0
+        },
+        lineEnd: function() {
+            switch (this._point) {
+                case 2:
+                    this._context.lineTo(this._x1, this._y1);
+                    break;
+                case 3:
+                    ov(this, this._t0, UA(this, this._t0));
+                    break
+            }(this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line
+        },
+        point: function(e, t) {
+            var n = NaN;
+            if (e = +e, t = +t, !(e === this._x1 && t === this._y1)) {
+                switch (this._point) {
+                    case 0:
+                        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
+                        break;
+                    case 1:
+                        this._point = 2;
+                        break;
+                    case 2:
+                        this._point = 3, ov(this, UA(this, n = GA(this, e, t)), n);
+                        break;
+                    default:
+                        ov(this, this._t0, n = GA(this, e, t));
+                        break
+                }
+                this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t, this._t0 = n
+            }
+        }
+    };
+
+    function $D(e) {
+        this._context = new TD(e)
+    }($D.prototype = Object.create(dm.prototype)).point = function(e, t) {
+        dm.prototype.point.call(this, t, e)
+    };
 
-    function oG() {
-        fF(uF, cF), tr.point = Dx
+    function TD(e) {
+        this._context = e
     }
+    TD.prototype = {
+        moveTo: function(e, t) {
+            this._context.moveTo(t, e)
+        },
+        closePath: function() {
+            this._context.closePath()
+        },
+        lineTo: function(e, t) {
+            this._context.lineTo(t, e)
+        },
+        bezierCurveTo: function(e, t, n, i, r, s) {
+            this._context.bezierCurveTo(t, e, i, n, s, r)
+        }
+    };
 
-    function lG(e, t) {
-        uF = e, cF = t, e *= Me, t *= Me, tr.point = fF;
-        var n = xe(t);
-        $n = n * xe(e), Tn = n * pe(e), Mn = pe(t), td($n, Tn, Mn)
-    }
-
-    function fF(e, t) {
-        e *= Me, t *= Me;
-        var n = xe(t),
-            i = n * xe(e),
-            r = n * pe(e),
-            s = pe(t),
-            a = Tn * s - Mn * r,
-            o = Mn * i - $n * s,
-            l = $n * r - Tn * i,
-            u = mb(a, o, l),
-            c = ti(u),
-            f = u && -c / u;
-        wb.add(f * a), Sb.add(f * o), Eb.add(f * l), Ip += c, Up += c * ($n + ($n = i)), Gp += c * (Tn + (Tn = r)), Wp += c * (Mn + (Mn = s)), td($n, Tn, Mn)
+    function hq(e) {
+        return new dm(e)
     }
 
-    function uG(e) {
-        Ef = Ip = zp = Bp = jp = Up = Gp = Wp = 0, wb = new Rn, Sb = new Rn, Eb = new Rn, ws(e, tr);
-        var t = +wb,
-            n = +Sb,
-            i = +Eb,
-            r = mb(t, n, i);
-        return r < Mp && (t = Up, n = Gp, i = Wp, Ip < ve && (t = zp, n = Bp, i = jp), r = mb(t, n, i), r < Mp) ? [NaN, NaN] : [Fi(n, t) * St, ti(i / r) * St]
+    function dq(e) {
+        return new $D(e)
     }
 
-    function Cb(e, t) {
-        function n(i, r) {
-            return i = e(i, r), t(i[0], i[1])
-        }
-        return e.invert && t.invert && (n.invert = function(i, r) {
-            return i = t.invert(i, r), i && e.invert(i[0], i[1])
-        }), n
+    function MD(e) {
+        this._context = e
     }
+    MD.prototype = {
+        areaStart: function() {
+            this._line = 0
+        },
+        areaEnd: function() {
+            this._line = NaN
+        },
+        lineStart: function() {
+            this._x = [], this._y = []
+        },
+        lineEnd: function() {
+            var e = this._x,
+                t = this._y,
+                n = e.length;
+            if (n)
+                if (this._line ? this._context.lineTo(e[0], t[0]) : this._context.moveTo(e[0], t[0]), n === 2) this._context.lineTo(e[1], t[1]);
+                else
+                    for (var i = WA(e), r = WA(t), s = 0, a = 1; a < n; ++s, ++a) this._context.bezierCurveTo(i[0][s], r[0][s], i[1][s], r[1][s], e[a], t[a]);
+            (this._line || this._line !== 0 && n === 1) && this._context.closePath(), this._line = 1 - this._line, this._x = this._y = null
+        },
+        point: function(e, t) {
+            this._x.push(+e), this._y.push(+t)
+        }
+    };
 
-    function kb(e, t) {
-        return Re(e) > Oe && (e -= Math.round(e / Ln) * Ln), [e, t]
+    function WA(e) {
+        var t, n = e.length - 1,
+            i, r = new Array(n),
+            s = new Array(n),
+            a = new Array(n);
+        for (r[0] = 0, s[0] = 2, a[0] = e[0] + 2 * e[1], t = 1; t < n - 1; ++t) r[t] = 1, s[t] = 4, a[t] = 4 * e[t] + 2 * e[t + 1];
+        for (r[n - 1] = 2, s[n - 1] = 7, a[n - 1] = 8 * e[n - 1] + e[n], t = 1; t < n; ++t) i = r[t] / s[t - 1], s[t] -= i, a[t] -= i * a[t - 1];
+        for (r[n - 1] = a[n - 1] / s[n - 1], t = n - 2; t >= 0; --t) r[t] = (a[t] - r[t + 1]) / s[t];
+        for (s[n - 1] = (e[n] + r[n - 1]) / 2, t = 0; t < n - 1; ++t) s[t] = 2 * e[t + 1] - r[t + 1];
+        return [r, s]
     }
-    kb.invert = kb;
 
-    function hF(e, t, n) {
-        return (e %= Ln) ? t || n ? Cb(cA(e), fA(t, n)) : cA(e) : t || n ? fA(t, n) : kb
+    function gq(e) {
+        return new MD(e)
     }
 
-    function uA(e) {
-        return function(t, n) {
-            return t += e, Re(t) > Oe && (t -= Math.round(t / Ln) * Ln), [t, n]
+    function o1(e, t) {
+        this._context = e, this._t = t
+    }
+    o1.prototype = {
+        areaStart: function() {
+            this._line = 0
+        },
+        areaEnd: function() {
+            this._line = NaN
+        },
+        lineStart: function() {
+            this._x = this._y = NaN, this._point = 0
+        },
+        lineEnd: function() {
+            0 < this._t && this._t < 1 && this._point === 2 && this._context.lineTo(this._x, this._y), (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line >= 0 && (this._t = 1 - this._t, this._line = 1 - this._line)
+        },
+        point: function(e, t) {
+            switch (e = +e, t = +t, this._point) {
+                case 0:
+                    this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
+                    break;
+                case 1:
+                    this._point = 2;
+                default: {
+                    if (this._t <= 0) this._context.lineTo(this._x, t), this._context.lineTo(e, t);
+                    else {
+                        var n = this._x * (1 - this._t) + e * this._t;
+                        this._context.lineTo(n, this._y), this._context.lineTo(n, t)
+                    }
+                    break
+                }
+            }
+            this._x = e, this._y = t
         }
+    };
+
+    function pq(e) {
+        return new o1(e, .5)
     }
 
-    function cA(e) {
-        var t = uA(e);
-        return t.invert = uA(-e), t
+    function mq(e) {
+        return new o1(e, 0)
     }
 
-    function fA(e, t) {
-        var n = xe(e),
-            i = pe(e),
-            r = xe(t),
-            s = pe(t);
+    function yq(e) {
+        return new o1(e, 1)
+    }
 
-        function a(o, l) {
-            var u = xe(l),
-                c = xe(o) * u,
-                f = pe(o) * u,
-                h = pe(l),
-                d = h * n + c * i;
-            return [Fi(f * r - d * s, c * n - h * i), ti(d * r + f * s)]
+    function Ha(e, t) {
+        if (typeof document < "u" && document.createElement) {
+            const n = document.createElement("canvas");
+            if (n && n.getContext) return n.width = e, n.height = t, n
         }
-        return a.invert = function(o, l) {
-            var u = xe(l),
-                c = xe(o) * u,
-                f = pe(o) * u,
-                h = pe(l),
-                d = h * r - f * s;
-            return [Fi(f * r + h * s, c * n + d * i), ti(d * n - c * i)]
-        }, a
+        return null
     }
+    const vq = () => typeof Image < "u" ? Image : null;
 
-    function cG(e) {
-        e = hF(e[0] * Me, e[1] * Me, e.length > 2 ? e[2] * Me : 0);
-
-        function t(n) {
-            return n = e(n[0] * Me, n[1] * Me), n[0] *= St, n[1] *= St, n
+    function ps(e, t) {
+        switch (arguments.length) {
+            case 0:
+                break;
+            case 1:
+                this.range(e);
+                break;
+            default:
+                this.range(t).domain(e);
+                break
         }
-        return t.invert = function(n) {
-            return n = e.invert(n[0] * Me, n[1] * Me), n[0] *= St, n[1] *= St, n
-        }, t
+        return this
     }
 
-    function fG(e, t, n, i, r, s) {
-        if (n) {
-            var a = xe(t),
-                o = pe(t),
-                l = i * n;
-            r == null ? (r = t + i * Ln, s = t - l / 2) : (r = hA(a, r), s = hA(a, s), (i > 0 ? r < s : r > s) && (r += i * Ln));
-            for (var u, c = r; i > 0 ? c > s : c < s; c -= l) u = Pp([a, -o * xe(c), -o * pe(c)]), e.point(u[0], u[1])
+    function yo(e, t) {
+        switch (arguments.length) {
+            case 0:
+                break;
+            case 1: {
+                typeof e == "function" ? this.interpolator(e) : this.range(e);
+                break
+            }
+            default: {
+                this.domain(e), typeof t == "function" ? this.interpolator(t) : this.range(t);
+                break
+            }
         }
+        return this
     }
+    const n2 = Symbol("implicit");
 
-    function hA(e, t) {
-        t = Zo(t), t[0] -= e, Lp(t);
-        var n = tF(-t[1]);
-        return ((-t[2] < 0 ? -n : n) + Ln - ve) % Ln
-    }
+    function l1() {
+        var e = new oA,
+            t = [],
+            n = [],
+            i = n2;
 
-    function dF() {
-        var e = [],
-            t;
-        return {
-            point: function(n, i, r) {
-                t.push([n, i, r])
-            },
-            lineStart: function() {
-                e.push(t = [])
-            },
-            lineEnd: Vt,
-            rejoin: function() {
-                e.length > 1 && e.push(e.pop().concat(e.shift()))
-            },
-            result: function() {
-                var n = e;
-                return e = [], t = null, n
+        function r(s) {
+            let a = e.get(s);
+            if (a === void 0) {
+                if (i !== n2) return i;
+                e.set(s, a = t.push(s) - 1)
             }
+            return n[a % n.length]
         }
+        return r.domain = function(s) {
+            if (!arguments.length) return t.slice();
+            t = [], e = new oA;
+            for (const a of s) e.has(a) || e.set(a, t.push(a) - 1);
+            return r
+        }, r.range = function(s) {
+            return arguments.length ? (n = Array.from(s), r) : n.slice()
+        }, r.unknown = function(s) {
+            return arguments.length ? (i = s, r) : i
+        }, r.copy = function() {
+            return l1(t, n).unknown(i)
+        }, ps.apply(r, arguments), r
     }
 
-    function Hg(e, t) {
-        return Re(e[0] - t[0]) < ve && Re(e[1] - t[1]) < ve
+    function Vc(e, t, n) {
+        e.prototype = t.prototype = n, n.constructor = e
     }
 
-    function lg(e, t, n, i) {
-        this.x = e, this.z = t, this.o = n, this.e = i, this.v = !1, this.n = this.p = null
+    function Fd(e, t) {
+        var n = Object.create(e.prototype);
+        for (var i in t) n[i] = t[i];
+        return n
     }
 
-    function gF(e, t, n, i, r) {
-        var s = [],
-            a = [],
-            o, l;
-        if (e.forEach(function(g) {
-                if (!((p = g.length - 1) <= 0)) {
-                    var p, m = g[0],
-                        y = g[p],
-                        v;
-                    if (Hg(m, y)) {
-                        if (!m[2] && !y[2]) {
-                            for (r.lineStart(), o = 0; o < p; ++o) r.point((m = g[o])[0], m[1]);
-                            r.lineEnd();
-                            return
-                        }
-                        y[0] += 2 * ve
-                    }
-                    s.push(v = new lg(m, g, null, !0)), a.push(v.o = new lg(m, null, v, !1)), s.push(v = new lg(y, g, null, !1)), a.push(v.o = new lg(y, null, v, !0))
-                }
-            }), !!s.length) {
-            for (a.sort(t), dA(s), dA(a), o = 0, l = a.length; o < l; ++o) a[o].e = n = !n;
-            for (var u = s[0], c, f;;) {
-                for (var h = u, d = !0; h.v;)
-                    if ((h = h.n) === u) return;
-                c = h.z, r.lineStart();
-                do {
-                    if (h.v = h.o.v = !0, h.e) {
-                        if (d)
-                            for (o = 0, l = c.length; o < l; ++o) r.point((f = c[o])[0], f[1]);
-                        else i(h.x, h.n.x, 1, r);
-                        h = h.n
-                    } else {
-                        if (d)
-                            for (c = h.p.z, o = c.length - 1; o >= 0; --o) r.point((f = c[o])[0], f[1]);
-                        else i(h.x, h.p.x, -1, r);
-                        h = h.p
-                    }
-                    h = h.o, c = h.z, d = !d
-                } while (!h.v);
-                r.lineEnd()
-            }
-        }
-    }
-
-    function dA(e) {
-        if (t = e.length) {
-            for (var t, n = 0, i = e[0], r; ++n < t;) i.n = r = e[n], r.p = i, i = r;
-            i.n = r = e[0], r.p = i
-        }
-    }
-
-    function Oy(e) {
-        return Re(e[0]) <= Oe ? e[0] : ki(e[0]) * ((Re(e[0]) + Oe) % Ln - Oe)
-    }
-
-    function hG(e, t) {
-        var n = Oy(t),
-            i = t[1],
-            r = pe(i),
-            s = [pe(n), -xe(n), 0],
-            a = 0,
-            o = 0,
-            l = new Rn;
-        r === 1 ? i = vt + ve : r === -1 && (i = -vt - ve);
-        for (var u = 0, c = e.length; u < c; ++u)
-            if (h = (f = e[u]).length)
-                for (var f, h, d = f[h - 1], g = Oy(d), p = d[1] / 2 + Op, m = pe(p), y = xe(p), v = 0; v < h; ++v, g = x, m = S, y = w, d = b) {
-                    var b = f[v],
-                        x = Oy(b),
-                        _ = b[1] / 2 + Op,
-                        S = pe(_),
-                        w = xe(_),
-                        E = x - g,
-                        A = E >= 0 ? 1 : -1,
-                        C = A * E,
-                        k = C > Oe,
-                        R = m * S;
-                    if (l.add(Fi(R * A * pe(C), y * w + R * xe(C))), a += k ? E + A * Ln : E, k ^ g >= n ^ x >= n) {
-                        var $ = Du(Zo(d), Zo(b));
-                        Lp($);
-                        var T = Du(s, $);
-                        Lp(T);
-                        var M = (k ^ E >= 0 ? -1 : 1) * ti(T[2]);
-                        (i > M || i === M && ($[0] || $[1])) && (o += k ^ E >= 0 ? 1 : -1)
-                    }
-                }
-        return (a < -ve || a < ve && l < -Mp) ^ o & 1
-    }
-
-    function pF(e, t, n, i) {
-        return function(r) {
-            var s = t(r),
-                a = dF(),
-                o = t(a),
-                l = !1,
-                u, c, f, h = {
-                    point: d,
-                    lineStart: p,
-                    lineEnd: m,
-                    polygonStart: function() {
-                        h.point = y, h.lineStart = v, h.lineEnd = b, c = [], u = []
-                    },
-                    polygonEnd: function() {
-                        h.point = d, h.lineStart = p, h.lineEnd = m, c = BO(c);
-                        var x = hG(u, i);
-                        c.length ? (l || (r.polygonStart(), l = !0), gF(c, gG, x, n, r)) : x && (l || (r.polygonStart(), l = !0), r.lineStart(), n(null, null, 1, r), r.lineEnd()), l && (r.polygonEnd(), l = !1), c = u = null
-                    },
-                    sphere: function() {
-                        r.polygonStart(), r.lineStart(), n(null, null, 1, r), r.lineEnd(), r.polygonEnd()
-                    }
-                };
-
-            function d(x, _) {
-                e(x, _) && r.point(x, _)
-            }
-
-            function g(x, _) {
-                s.point(x, _)
-            }
-
-            function p() {
-                h.point = g, s.lineStart()
-            }
-
-            function m() {
-                h.point = d, s.lineEnd()
-            }
-
-            function y(x, _) {
-                f.push([x, _]), o.point(x, _)
-            }
-
-            function v() {
-                o.lineStart(), f = []
-            }
-
-            function b() {
-                y(f[0][0], f[0][1]), o.lineEnd();
-                var x = o.clean(),
-                    _ = a.result(),
-                    S, w = _.length,
-                    E, A, C;
-                if (f.pop(), u.push(f), f = null, !!w) {
-                    if (x & 1) {
-                        if (A = _[0], (E = A.length - 1) > 0) {
-                            for (l || (r.polygonStart(), l = !0), r.lineStart(), S = 0; S < E; ++S) r.point((C = A[S])[0], C[1]);
-                            r.lineEnd()
-                        }
-                        return
-                    }
-                    w > 1 && x & 2 && _.push(_.pop().concat(_.shift())), c.push(_.filter(dG))
-                }
-            }
-            return h
-        }
-    }
-
-    function dG(e) {
-        return e.length > 1
-    }
-
-    function gG(e, t) {
-        return ((e = e.x)[0] < 0 ? e[1] - vt - ve : vt - e[1]) - ((t = t.x)[0] < 0 ? t[1] - vt - ve : vt - t[1])
-    }
-    const gA = pF(function() {
-        return !0
-    }, pG, yG, [-Oe, -vt]);
-
-    function pG(e) {
-        var t = NaN,
-            n = NaN,
-            i = NaN,
-            r;
-        return {
-            lineStart: function() {
-                e.lineStart(), r = 1
-            },
-            point: function(s, a) {
-                var o = s > 0 ? Oe : -Oe,
-                    l = Re(s - t);
-                Re(l - Oe) < ve ? (e.point(t, n = (n + a) / 2 > 0 ? vt : -vt), e.point(i, n), e.lineEnd(), e.lineStart(), e.point(o, n), e.point(s, n), r = 0) : i !== o && l >= Oe && (Re(t - i) < ve && (t -= i * ve), Re(s - o) < ve && (s -= o * ve), n = mG(t, n, s, a), e.point(i, n), e.lineEnd(), e.lineStart(), e.point(o, n), r = 0), e.point(t = s, n = a), i = o
-            },
-            lineEnd: function() {
-                e.lineEnd(), t = n = NaN
-            },
-            clean: function() {
-                return 2 - r
-            }
-        }
-    }
-
-    function mG(e, t, n, i) {
-        var r, s, a = pe(e - n);
-        return Re(a) > ve ? pc((pe(t) * (s = xe(i)) * pe(n) - pe(i) * (r = xe(t)) * pe(e)) / (r * s * a)) : (t + i) / 2
-    }
-
-    function yG(e, t, n, i) {
-        var r;
-        if (e == null) r = n * vt, i.point(-Oe, r), i.point(0, r), i.point(Oe, r), i.point(Oe, 0), i.point(Oe, -r), i.point(0, -r), i.point(-Oe, -r), i.point(-Oe, 0), i.point(-Oe, r);
-        else if (Re(e[0] - t[0]) > ve) {
-            var s = e[0] < t[0] ? Oe : -Oe;
-            r = n * s / 2, i.point(-s, r), i.point(0, r), i.point(s, r)
-        } else i.point(t[0], t[1])
-    }
-
-    function vG(e) {
-        var t = xe(e),
-            n = 6 * Me,
-            i = t > 0,
-            r = Re(t) > ve;
-
-        function s(c, f, h, d) {
-            fG(d, e, n, h, c, f)
-        }
-
-        function a(c, f) {
-            return xe(c) * xe(f) > t
-        }
-
-        function o(c) {
-            var f, h, d, g, p;
-            return {
-                lineStart: function() {
-                    g = d = !1, p = 1
-                },
-                point: function(m, y) {
-                    var v = [m, y],
-                        b, x = a(m, y),
-                        _ = i ? x ? 0 : u(m, y) : x ? u(m + (m < 0 ? Oe : -Oe), y) : 0;
-                    if (!f && (g = d = x) && c.lineStart(), x !== d && (b = l(f, v), (!b || Hg(f, b) || Hg(v, b)) && (v[2] = 1)), x !== d) p = 0, x ? (c.lineStart(), b = l(v, f), c.point(b[0], b[1])) : (b = l(f, v), c.point(b[0], b[1], 2), c.lineEnd()), f = b;
-                    else if (r && f && i ^ x) {
-                        var S;
-                        !(_ & h) && (S = l(v, f, !0)) && (p = 0, i ? (c.lineStart(), c.point(S[0][0], S[0][1]), c.point(S[1][0], S[1][1]), c.lineEnd()) : (c.point(S[1][0], S[1][1]), c.lineEnd(), c.lineStart(), c.point(S[0][0], S[0][1], 3)))
-                    }
-                    x && (!f || !Hg(f, v)) && c.point(v[0], v[1]), f = v, d = x, h = _
-                },
-                lineEnd: function() {
-                    d && c.lineEnd(), f = null
-                },
-                clean: function() {
-                    return p | (g && d) << 1
-                }
-            }
-        }
-
-        function l(c, f, h) {
-            var d = Zo(c),
-                g = Zo(f),
-                p = [1, 0, 0],
-                m = Du(d, g),
-                y = ag(m, m),
-                v = m[0],
-                b = y - v * v;
-            if (!b) return !h && c;
-            var x = t * y / b,
-                _ = -t * v / b,
-                S = Du(p, m),
-                w = og(p, x),
-                E = og(m, _);
-            My(w, E);
-            var A = S,
-                C = ag(w, A),
-                k = ag(A, A),
-                R = C * C - k * (ag(w, w) - 1);
-            if (!(R < 0)) {
-                var $ = In(R),
-                    T = og(A, (-C - $) / k);
-                if (My(T, w), T = Pp(T), !h) return T;
-                var M = c[0],
-                    F = f[0],
-                    N = c[1],
-                    P = f[1],
-                    z;
-                F < M && (z = M, M = F, F = z);
-                var I = F - M,
-                    Q = Re(I - Oe) < ve,
-                    oe = Q || I < ve;
-                if (!Q && P < N && (z = N, N = P, P = z), oe ? Q ? N + P > 0 ^ T[1] < (Re(T[0] - M) < ve ? N : P) : N <= T[1] && T[1] <= P : I > Oe ^ (M <= T[0] && T[0] <= F)) {
-                    var Se = og(A, (-C + $) / k);
-                    return My(Se, w), [T, Pp(Se)]
-                }
-            }
-        }
+    function vo() {}
+    var wl = .7,
+        cc = 1 / wl,
+        qu = "\\s*([+-]?\\d+)\\s*",
+        Vh = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*",
+        Zr = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
+        bq = /^#([0-9a-f]{3,8})$/,
+        xq = new RegExp(`^rgb\\(${qu},${qu},${qu}\\)$`),
+        _q = new RegExp(`^rgb\\(${Zr},${Zr},${Zr}\\)$`),
+        wq = new RegExp(`^rgba\\(${qu},${qu},${qu},${Vh}\\)$`),
+        Sq = new RegExp(`^rgba\\(${Zr},${Zr},${Zr},${Vh}\\)$`),
+        Eq = new RegExp(`^hsl\\(${Vh},${Zr},${Zr}\\)$`),
+        kq = new RegExp(`^hsla\\(${Vh},${Zr},${Zr},${Vh}\\)$`),
+        qA = {
+            aliceblue: 15792383,
+            antiquewhite: 16444375,
+            aqua: 65535,
+            aquamarine: 8388564,
+            azure: 15794175,
+            beige: 16119260,
+            bisque: 16770244,
+            black: 0,
+            blanchedalmond: 16772045,
+            blue: 255,
+            blueviolet: 9055202,
+            brown: 10824234,
+            burlywood: 14596231,
+            cadetblue: 6266528,
+            chartreuse: 8388352,
+            chocolate: 13789470,
+            coral: 16744272,
+            cornflowerblue: 6591981,
+            cornsilk: 16775388,
+            crimson: 14423100,
+            cyan: 65535,
+            darkblue: 139,
+            darkcyan: 35723,
+            darkgoldenrod: 12092939,
+            darkgray: 11119017,
+            darkgreen: 25600,
+            darkgrey: 11119017,
+            darkkhaki: 12433259,
+            darkmagenta: 9109643,
+            darkolivegreen: 5597999,
+            darkorange: 16747520,
+            darkorchid: 10040012,
+            darkred: 9109504,
+            darksalmon: 15308410,
+            darkseagreen: 9419919,
+            darkslateblue: 4734347,
+            darkslategray: 3100495,
+            darkslategrey: 3100495,
+            darkturquoise: 52945,
+            darkviolet: 9699539,
+            deeppink: 16716947,
+            deepskyblue: 49151,
+            dimgray: 6908265,
+            dimgrey: 6908265,
+            dodgerblue: 2003199,
+            firebrick: 11674146,
+            floralwhite: 16775920,
+            forestgreen: 2263842,
+            fuchsia: 16711935,
+            gainsboro: 14474460,
+            ghostwhite: 16316671,
+            gold: 16766720,
+            goldenrod: 14329120,
+            gray: 8421504,
+            green: 32768,
+            greenyellow: 11403055,
+            grey: 8421504,
+            honeydew: 15794160,
+            hotpink: 16738740,
+            indianred: 13458524,
+            indigo: 4915330,
+            ivory: 16777200,
+            khaki: 15787660,
+            lavender: 15132410,
+            lavenderblush: 16773365,
+            lawngreen: 8190976,
+            lemonchiffon: 16775885,
+            lightblue: 11393254,
+            lightcoral: 15761536,
+            lightcyan: 14745599,
+            lightgoldenrodyellow: 16448210,
+            lightgray: 13882323,
+            lightgreen: 9498256,
+            lightgrey: 13882323,
+            lightpink: 16758465,
+            lightsalmon: 16752762,
+            lightseagreen: 2142890,
+            lightskyblue: 8900346,
+            lightslategray: 7833753,
+            lightslategrey: 7833753,
+            lightsteelblue: 11584734,
+            lightyellow: 16777184,
+            lime: 65280,
+            limegreen: 3329330,
+            linen: 16445670,
+            magenta: 16711935,
+            maroon: 8388608,
+            mediumaquamarine: 6737322,
+            mediumblue: 205,
+            mediumorchid: 12211667,
+            mediumpurple: 9662683,
+            mediumseagreen: 3978097,
+            mediumslateblue: 8087790,
+            mediumspringgreen: 64154,
+            mediumturquoise: 4772300,
+            mediumvioletred: 13047173,
+            midnightblue: 1644912,
+            mintcream: 16121850,
+            mistyrose: 16770273,
+            moccasin: 16770229,
+            navajowhite: 16768685,
+            navy: 128,
+            oldlace: 16643558,
+            olive: 8421376,
+            olivedrab: 7048739,
+            orange: 16753920,
+            orangered: 16729344,
+            orchid: 14315734,
+            palegoldenrod: 15657130,
+            palegreen: 10025880,
+            paleturquoise: 11529966,
+            palevioletred: 14381203,
+            papayawhip: 16773077,
+            peachpuff: 16767673,
+            peru: 13468991,
+            pink: 16761035,
+            plum: 14524637,
+            powderblue: 11591910,
+            purple: 8388736,
+            rebeccapurple: 6697881,
+            red: 16711680,
+            rosybrown: 12357519,
+            royalblue: 4286945,
+            saddlebrown: 9127187,
+            salmon: 16416882,
+            sandybrown: 16032864,
+            seagreen: 3050327,
+            seashell: 16774638,
+            sienna: 10506797,
+            silver: 12632256,
+            skyblue: 8900331,
+            slateblue: 6970061,
+            slategray: 7372944,
+            slategrey: 7372944,
+            snow: 16775930,
+            springgreen: 65407,
+            steelblue: 4620980,
+            tan: 13808780,
+            teal: 32896,
+            thistle: 14204888,
+            tomato: 16737095,
+            turquoise: 4251856,
+            violet: 15631086,
+            wheat: 16113331,
+            white: 16777215,
+            whitesmoke: 16119285,
+            yellow: 16776960,
+            yellowgreen: 10145074
+        };
+    Vc(vo, Kh, {
+        copy(e) {
+            return Object.assign(new this.constructor, this, e)
+        },
+        displayable() {
+            return this.rgb().displayable()
+        },
+        hex: HA,
+        formatHex: HA,
+        formatHex8: Cq,
+        formatHsl: Aq,
+        formatRgb: YA,
+        toString: YA
+    });
 
-        function u(c, f) {
-            var h = i ? e : Oe - e,
-                d = 0;
-            return c < -h ? d |= 1 : c > h && (d |= 2), f < -h ? d |= 4 : f > h && (d |= 8), d
-        }
-        return pF(a, o, s, i ? [0, -e] : [-Oe, e - Oe])
+    function HA() {
+        return this.rgb().formatHex()
     }
 
-    function bG(e, t, n, i, r, s) {
-        var a = e[0],
-            o = e[1],
-            l = t[0],
-            u = t[1],
-            c = 0,
-            f = 1,
-            h = l - a,
-            d = u - o,
-            g;
-        if (g = n - a, !(!h && g > 0)) {
-            if (g /= h, h < 0) {
-                if (g < c) return;
-                g < f && (f = g)
-            } else if (h > 0) {
-                if (g > f) return;
-                g > c && (c = g)
-            }
-            if (g = r - a, !(!h && g < 0)) {
-                if (g /= h, h < 0) {
-                    if (g > f) return;
-                    g > c && (c = g)
-                } else if (h > 0) {
-                    if (g < c) return;
-                    g < f && (f = g)
-                }
-                if (g = i - o, !(!d && g > 0)) {
-                    if (g /= d, d < 0) {
-                        if (g < c) return;
-                        g < f && (f = g)
-                    } else if (d > 0) {
-                        if (g > f) return;
-                        g > c && (c = g)
-                    }
-                    if (g = s - o, !(!d && g < 0)) {
-                        if (g /= d, d < 0) {
-                            if (g > f) return;
-                            g > c && (c = g)
-                        } else if (d > 0) {
-                            if (g < c) return;
-                            g < f && (f = g)
-                        }
-                        return c > 0 && (e[0] = a + c * h, e[1] = o + c * d), f < 1 && (t[0] = a + f * h, t[1] = o + f * d), !0
-                    }
-                }
-            }
-        }
+    function Cq() {
+        return this.rgb().formatHex8()
     }
-    var Cf = 1e9,
-        ug = -Cf;
-
-    function mF(e, t, n, i) {
-        function r(u, c) {
-            return e <= u && u <= n && t <= c && c <= i
-        }
-
-        function s(u, c, f, h) {
-            var d = 0,
-                g = 0;
-            if (u == null || (d = a(u, f)) !== (g = a(c, f)) || l(u, c) < 0 ^ f > 0)
-                do h.point(d === 0 || d === 3 ? e : n, d > 1 ? i : t); while ((d = (d + f + 4) % 4) !== g);
-            else h.point(c[0], c[1])
-        }
-
-        function a(u, c) {
-            return Re(u[0] - e) < ve ? c > 0 ? 0 : 3 : Re(u[0] - n) < ve ? c > 0 ? 2 : 1 : Re(u[1] - t) < ve ? c > 0 ? 1 : 0 : c > 0 ? 3 : 2
-        }
-
-        function o(u, c) {
-            return l(u.x, c.x)
-        }
-
-        function l(u, c) {
-            var f = a(u, 1),
-                h = a(c, 1);
-            return f !== h ? f - h : f === 0 ? c[1] - u[1] : f === 1 ? u[0] - c[0] : f === 2 ? u[1] - c[1] : c[0] - u[0]
-        }
-        return function(u) {
-            var c = u,
-                f = dF(),
-                h, d, g, p, m, y, v, b, x, _, S, w = {
-                    point: E,
-                    lineStart: R,
-                    lineEnd: $,
-                    polygonStart: C,
-                    polygonEnd: k
-                };
-
-            function E(M, F) {
-                r(M, F) && c.point(M, F)
-            }
-
-            function A() {
-                for (var M = 0, F = 0, N = d.length; F < N; ++F)
-                    for (var P = d[F], z = 1, I = P.length, Q = P[0], oe, Se, ye = Q[0], Pe = Q[1]; z < I; ++z) oe = ye, Se = Pe, Q = P[z], ye = Q[0], Pe = Q[1], Se <= i ? Pe > i && (ye - oe) * (i - Se) > (Pe - Se) * (e - oe) && ++M : Pe <= i && (ye - oe) * (i - Se) < (Pe - Se) * (e - oe) && --M;
-                return M
-            }
-
-            function C() {
-                c = f, h = [], d = [], S = !0
-            }
-
-            function k() {
-                var M = A(),
-                    F = S && M,
-                    N = (h = BO(h)).length;
-                (F || N) && (u.polygonStart(), F && (u.lineStart(), s(null, null, 1, u), u.lineEnd()), N && gF(h, o, M, s, u), u.polygonEnd()), c = u, h = d = g = null
-            }
-
-            function R() {
-                w.point = T, d && d.push(g = []), _ = !0, x = !1, v = b = NaN
-            }
-
-            function $() {
-                h && (T(p, m), y && x && f.rejoin(), h.push(f.result())), w.point = E, x && c.lineEnd()
-            }
 
-            function T(M, F) {
-                var N = r(M, F);
-                if (d && g.push([M, F]), _) p = M, m = F, y = N, _ = !1, N && (c.lineStart(), c.point(M, F));
-                else if (N && x) c.point(M, F);
-                else {
-                    var P = [v = Math.max(ug, Math.min(Cf, v)), b = Math.max(ug, Math.min(Cf, b))],
-                        z = [M = Math.max(ug, Math.min(Cf, M)), F = Math.max(ug, Math.min(Cf, F))];
-                    bG(P, z, e, t, n, i) ? (x || (c.lineStart(), c.point(P[0], P[1])), c.point(z[0], z[1]), N || c.lineEnd(), S = !1) : N && (c.lineStart(), c.point(M, F), S = !1)
-                }
-                v = M, b = F, x = N
-            }
-            return w
-        }
+    function Aq() {
+        return OD(this).formatHsl()
     }
 
-    function pA(e, t, n) {
-        var i = gi(e, t - ve, n).concat(t);
-        return function(r) {
-            return i.map(function(s) {
-                return [r, s]
-            })
-        }
+    function YA() {
+        return this.rgb().formatRgb()
     }
 
-    function mA(e, t, n) {
-        var i = gi(e, t - ve, n).concat(t);
-        return function(r) {
-            return i.map(function(s) {
-                return [s, r]
-            })
-        }
+    function Kh(e) {
+        var t, n;
+        return e = (e + "").trim().toLowerCase(), (t = bq.exec(e)) ? (n = t[1].length, t = parseInt(t[1], 16), n === 6 ? XA(t) : n === 3 ? new en(t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, (t & 15) << 4 | t & 15, 1) : n === 8 ? kg(t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, (t & 255) / 255) : n === 4 ? kg(t >> 12 & 15 | t >> 8 & 240, t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, ((t & 15) << 4 | t & 15) / 255) : null) : (t = xq.exec(e)) ? new en(t[1], t[2], t[3], 1) : (t = _q.exec(e)) ? new en(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, 1) : (t = wq.exec(e)) ? kg(t[1], t[2], t[3], t[4]) : (t = Sq.exec(e)) ? kg(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, t[4]) : (t = Eq.exec(e)) ? JA(t[1], t[2] / 100, t[3] / 100, 1) : (t = kq.exec(e)) ? JA(t[1], t[2] / 100, t[3] / 100, t[4]) : qA.hasOwnProperty(e) ? XA(qA[e]) : e === "transparent" ? new en(NaN, NaN, NaN, 0) : null
     }
 
-    function xG() {
-        var e, t, n, i, r, s, a, o, l = 10,
-            u = l,
-            c = 90,
-            f = 360,
-            h, d, g, p, m = 2.5;
-
-        function y() {
-            return {
-                type: "MultiLineString",
-                coordinates: v()
-            }
-        }
-
-        function v() {
-            return gi(sg(i / c) * c, n, c).map(g).concat(gi(sg(o / f) * f, a, f).map(p)).concat(gi(sg(t / l) * l, e, l).filter(function(b) {
-                return Re(b % c) > ve
-            }).map(h)).concat(gi(sg(s / u) * u, r, u).filter(function(b) {
-                return Re(b % f) > ve
-            }).map(d))
-        }
-        return y.lines = function() {
-            return v().map(function(b) {
-                return {
-                    type: "LineString",
-                    coordinates: b
-                }
-            })
-        }, y.outline = function() {
-            return {
-                type: "Polygon",
-                coordinates: [g(i).concat(p(a).slice(1), g(n).reverse().slice(1), p(o).reverse().slice(1))]
-            }
-        }, y.extent = function(b) {
-            return arguments.length ? y.extentMajor(b).extentMinor(b) : y.extentMinor()
-        }, y.extentMajor = function(b) {
-            return arguments.length ? (i = +b[0][0], n = +b[1][0], o = +b[0][1], a = +b[1][1], i > n && (b = i, i = n, n = b), o > a && (b = o, o = a, a = b), y.precision(m)) : [
-                [i, o],
-                [n, a]
-            ]
-        }, y.extentMinor = function(b) {
-            return arguments.length ? (t = +b[0][0], e = +b[1][0], s = +b[0][1], r = +b[1][1], t > e && (b = t, t = e, e = b), s > r && (b = s, s = r, r = b), y.precision(m)) : [
-                [t, s],
-                [e, r]
-            ]
-        }, y.step = function(b) {
-            return arguments.length ? y.stepMajor(b).stepMinor(b) : y.stepMinor()
-        }, y.stepMajor = function(b) {
-            return arguments.length ? (c = +b[0], f = +b[1], y) : [c, f]
-        }, y.stepMinor = function(b) {
-            return arguments.length ? (l = +b[0], u = +b[1], y) : [l, u]
-        }, y.precision = function(b) {
-            return arguments.length ? (m = +b, h = pA(s, r, 90), d = mA(t, e, m), g = pA(o, a, 90), p = mA(i, n, m), y) : m
-        }, y.extentMajor([
-            [-180, -90 + ve],
-            [180, 90 - ve]
-        ]).extentMinor([
-            [-180, -80 - ve],
-            [180, 80 + ve]
-        ])
+    function XA(e) {
+        return new en(e >> 16 & 255, e >> 8 & 255, e & 255, 1)
     }
-    const vh = e => e;
-    var Fy = new Rn,
-        Ab = new Rn,
-        yF, vF, $b, Tb, fa = {
-            point: Vt,
-            lineStart: Vt,
-            lineEnd: Vt,
-            polygonStart: function() {
-                fa.lineStart = _G, fa.lineEnd = SG
-            },
-            polygonEnd: function() {
-                fa.lineStart = fa.lineEnd = fa.point = Vt, Fy.add(Re(Ab)), Ab = new Rn
-            },
-            result: function() {
-                var e = Fy / 2;
-                return Fy = new Rn, e
-            }
-        };
 
-    function _G() {
-        fa.point = wG
+    function kg(e, t, n, i) {
+        return i <= 0 && (e = t = n = NaN), new en(e, t, n, i)
     }
 
-    function wG(e, t) {
-        fa.point = bF, yF = $b = e, vF = Tb = t
+    function Rw(e) {
+        return e instanceof vo || (e = Kh(e)), e ? (e = e.rgb(), new en(e.r, e.g, e.b, e.opacity)) : new en
     }
 
-    function bF(e, t) {
-        Ab.add(Tb * e - $b * t), $b = e, Tb = t
+    function to(e, t, n, i) {
+        return arguments.length === 1 ? Rw(e) : new en(e, t, n, i ?? 1)
     }
 
-    function SG() {
-        bF(yF, vF)
-    }
-    const yA = fa;
-    var Nu = 1 / 0,
-        qp = Nu,
-        bh = -Nu,
-        Hp = bh,
-        EG = {
-            point: CG,
-            lineStart: Vt,
-            lineEnd: Vt,
-            polygonStart: Vt,
-            polygonEnd: Vt,
-            result: function() {
-                var e = [
-                    [Nu, qp],
-                    [bh, Hp]
-                ];
-                return bh = Hp = -(qp = Nu = 1 / 0), e
-            }
-        };
-
-    function CG(e, t) {
-        e < Nu && (Nu = e), e > bh && (bh = e), t < qp && (qp = t), t > Hp && (Hp = t)
+    function en(e, t, n, i) {
+        this.r = +e, this.g = +t, this.b = +n, this.opacity = +i
     }
-    const Yp = EG;
-    var Mb = 0,
-        Ob = 0,
-        kf = 0,
-        Xp = 0,
-        Vp = 0,
-        cu = 0,
-        Fb = 0,
-        Rb = 0,
-        Af = 0,
-        xF, _F, Fr, Rr, Qi = {
-            point: el,
-            lineStart: vA,
-            lineEnd: bA,
-            polygonStart: function() {
-                Qi.lineStart = $G, Qi.lineEnd = TG
-            },
-            polygonEnd: function() {
-                Qi.point = el, Qi.lineStart = vA, Qi.lineEnd = bA
-            },
-            result: function() {
-                var e = Af ? [Fb / Af, Rb / Af] : cu ? [Xp / cu, Vp / cu] : kf ? [Mb / kf, Ob / kf] : [NaN, NaN];
-                return Mb = Ob = kf = Xp = Vp = cu = Fb = Rb = Af = 0, e
-            }
-        };
+    Vc(en, to, Fd(vo, {
+        brighter(e) {
+            return e = e == null ? cc : Math.pow(cc, e), new en(this.r * e, this.g * e, this.b * e, this.opacity)
+        },
+        darker(e) {
+            return e = e == null ? wl : Math.pow(wl, e), new en(this.r * e, this.g * e, this.b * e, this.opacity)
+        },
+        rgb() {
+            return this
+        },
+        clamp() {
+            return new en(fl(this.r), fl(this.g), fl(this.b), gm(this.opacity))
+        },
+        displayable() {
+            return -.5 <= this.r && this.r < 255.5 && -.5 <= this.g && this.g < 255.5 && -.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1
+        },
+        hex: VA,
+        formatHex: VA,
+        formatHex8: $q,
+        formatRgb: KA,
+        toString: KA
+    }));
 
-    function el(e, t) {
-        Mb += e, Ob += t, ++kf
+    function VA() {
+        return `#${sl(this.r)}${sl(this.g)}${sl(this.b)}`
     }
 
-    function vA() {
-        Qi.point = kG
+    function $q() {
+        return `#${sl(this.r)}${sl(this.g)}${sl(this.b)}${sl((isNaN(this.opacity)?1:this.opacity)*255)}`
     }
 
-    function kG(e, t) {
-        Qi.point = AG, el(Fr = e, Rr = t)
+    function KA() {
+        const e = gm(this.opacity);
+        return `${e===1?"rgb(":"rgba("}${fl(this.r)}, ${fl(this.g)}, ${fl(this.b)}${e===1?")":`, ${e})`}`
     }
 
-    function AG(e, t) {
-        var n = e - Fr,
-            i = t - Rr,
-            r = In(n * n + i * i);
-        Xp += r * (Fr + e) / 2, Vp += r * (Rr + t) / 2, cu += r, el(Fr = e, Rr = t)
+    function gm(e) {
+        return isNaN(e) ? 1 : Math.max(0, Math.min(1, e))
     }
 
-    function bA() {
-        Qi.point = el
+    function fl(e) {
+        return Math.max(0, Math.min(255, Math.round(e) || 0))
     }
 
-    function $G() {
-        Qi.point = MG
+    function sl(e) {
+        return e = fl(e), (e < 16 ? "0" : "") + e.toString(16)
     }
 
-    function TG() {
-        wF(xF, _F)
+    function JA(e, t, n, i) {
+        return i <= 0 ? e = t = n = NaN : n <= 0 || n >= 1 ? e = t = NaN : t <= 0 && (e = NaN), new hr(e, t, n, i)
     }
 
-    function MG(e, t) {
-        Qi.point = wF, el(xF = Fr = e, _F = Rr = t)
+    function OD(e) {
+        if (e instanceof hr) return new hr(e.h, e.s, e.l, e.opacity);
+        if (e instanceof vo || (e = Kh(e)), !e) return new hr;
+        if (e instanceof hr) return e;
+        e = e.rgb();
+        var t = e.r / 255,
+            n = e.g / 255,
+            i = e.b / 255,
+            r = Math.min(t, n, i),
+            s = Math.max(t, n, i),
+            a = NaN,
+            o = s - r,
+            l = (s + r) / 2;
+        return o ? (t === s ? a = (n - i) / o + (n < i) * 6 : n === s ? a = (i - t) / o + 2 : a = (t - n) / o + 4, o /= l < .5 ? s + r : 2 - s - r, a *= 60) : o = l > 0 && l < 1 ? 0 : a, new hr(a, o, l, e.opacity)
     }
 
-    function wF(e, t) {
-        var n = e - Fr,
-            i = t - Rr,
-            r = In(n * n + i * i);
-        Xp += r * (Fr + e) / 2, Vp += r * (Rr + t) / 2, cu += r, r = Rr * e - Fr * t, Fb += r * (Fr + e), Rb += r * (Rr + t), Af += r * 3, el(Fr = e, Rr = t)
+    function pm(e, t, n, i) {
+        return arguments.length === 1 ? OD(e) : new hr(e, t, n, i ?? 1)
     }
-    const xA = Qi;
 
-    function SF(e) {
-        this._context = e
+    function hr(e, t, n, i) {
+        this.h = +e, this.s = +t, this.l = +n, this.opacity = +i
     }
-    SF.prototype = {
-        _radius: 4.5,
-        pointRadius: function(e) {
-            return this._radius = e, this
-        },
-        polygonStart: function() {
-            this._line = 0
+    Vc(hr, pm, Fd(vo, {
+        brighter(e) {
+            return e = e == null ? cc : Math.pow(cc, e), new hr(this.h, this.s, this.l * e, this.opacity)
         },
-        polygonEnd: function() {
-            this._line = NaN
+        darker(e) {
+            return e = e == null ? wl : Math.pow(wl, e), new hr(this.h, this.s, this.l * e, this.opacity)
         },
-        lineStart: function() {
-            this._point = 0
+        rgb() {
+            var e = this.h % 360 + (this.h < 0) * 360,
+                t = isNaN(e) || isNaN(this.s) ? 0 : this.s,
+                n = this.l,
+                i = n + (n < .5 ? n : 1 - n) * t,
+                r = 2 * n - i;
+            return new en(lv(e >= 240 ? e - 240 : e + 120, r, i), lv(e, r, i), lv(e < 120 ? e + 240 : e - 120, r, i), this.opacity)
         },
-        lineEnd: function() {
-            this._line === 0 && this._context.closePath(), this._point = NaN
+        clamp() {
+            return new hr(QA(this.h), Cg(this.s), Cg(this.l), gm(this.opacity))
         },
-        point: function(e, t) {
-            switch (this._point) {
-                case 0: {
-                    this._context.moveTo(e, t), this._point = 1;
-                    break
-                }
-                case 1: {
-                    this._context.lineTo(e, t);
-                    break
-                }
-                default: {
-                    this._context.moveTo(e + this._radius, t), this._context.arc(e, t, this._radius, 0, Ln);
-                    break
-                }
-            }
+        displayable() {
+            return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1
         },
-        result: Vt
-    };
-    var Db = new Rn,
-        Ry, EF, CF, $f, Tf, Kp = {
-            point: Vt,
-            lineStart: function() {
-                Kp.point = OG
-            },
-            lineEnd: function() {
-                Ry && kF(EF, CF), Kp.point = Vt
-            },
-            polygonStart: function() {
-                Ry = !0
-            },
-            polygonEnd: function() {
-                Ry = null
-            },
-            result: function() {
-                var e = +Db;
-                return Db = new Rn, e
-            }
-        };
+        formatHsl() {
+            const e = gm(this.opacity);
+            return `${e===1?"hsl(":"hsla("}${QA(this.h)}, ${Cg(this.s)*100}%, ${Cg(this.l)*100}%${e===1?")":`, ${e})`}`
+        }
+    }));
 
-    function OG(e, t) {
-        Kp.point = kF, EF = $f = e, CF = Tf = t
+    function QA(e) {
+        return e = (e || 0) % 360, e < 0 ? e + 360 : e
     }
 
-    function kF(e, t) {
-        $f -= e, Tf -= t, Db.add(In($f * $f + Tf * Tf)), $f = e, Tf = t
-    }
-    const _A = Kp;
-    let wA, Jp, SA, EA;
-    class CA {
-        constructor(t) {
-            this._append = t == null ? AF : FG(t), this._radius = 4.5, this._ = ""
-        }
-        pointRadius(t) {
-            return this._radius = +t, this
-        }
-        polygonStart() {
-            this._line = 0
-        }
-        polygonEnd() {
-            this._line = NaN
-        }
-        lineStart() {
-            this._point = 0
-        }
-        lineEnd() {
-            this._line === 0 && (this._ += "Z"), this._point = NaN
-        }
-        point(t, n) {
-            switch (this._point) {
-                case 0: {
-                    this._append`M${t},${n}`, this._point = 1;
-                    break
-                }
-                case 1: {
-                    this._append`L${t},${n}`;
-                    break
-                }
-                default: {
-                    if (this._append`M${t},${n}`, this._radius !== SA || this._append !== Jp) {
-                        const i = this._radius,
-                            r = this._;
-                        this._ = "", this._append`m0,${i}a${i},${i} 0 1,1 0,${-2*i}a${i},${i} 0 1,1 0,${2*i}z`, SA = i, Jp = this._append, EA = this._, this._ = r
-                    }
-                    this._ += EA;
-                    break
-                }
-            }
-        }
-        result() {
-            const t = this._;
-            return this._ = "", t.length ? t : null
-        }
+    function Cg(e) {
+        return Math.max(0, Math.min(1, e || 0))
     }
 
-    function AF(e) {
-        let t = 1;
-        this._ += e[0];
-        for (const n = e.length; t < n; ++t) this._ += arguments[t] + e[t]
+    function lv(e, t, n) {
+        return (e < 60 ? t + (n - t) * e / 60 : e < 180 ? n : e < 240 ? t + (n - t) * (240 - e) / 60 : t) * 255
     }
-
-    function FG(e) {
-        const t = Math.floor(e);
-        if (!(t >= 0)) throw new RangeError(`invalid digits: ${e}`);
-        if (t > 15) return AF;
-        if (t !== wA) {
-            const n = 10 ** t;
-            wA = t, Jp = function(r) {
-                let s = 1;
-                this._ += r[0];
-                for (const a = r.length; s < a; ++s) this._ += Math.round(arguments[s] * n) / n + r[s]
-            }
-        }
-        return Jp
+    const FD = Math.PI / 180,
+        RD = 180 / Math.PI,
+        mm = 18,
+        DD = .96422,
+        ND = 1,
+        PD = .82521,
+        LD = 4 / 29,
+        Hu = 6 / 29,
+        ID = 3 * Hu * Hu,
+        Tq = Hu * Hu * Hu;
+
+    function zD(e) {
+        if (e instanceof es) return new es(e.l, e.a, e.b, e.opacity);
+        if (e instanceof Us) return BD(e);
+        e instanceof en || (e = Rw(e));
+        var t = hv(e.r),
+            n = hv(e.g),
+            i = hv(e.b),
+            r = uv((.2225045 * t + .7168786 * n + .0606169 * i) / ND),
+            s, a;
+        return t === n && n === i ? s = a = r : (s = uv((.4360747 * t + .3850649 * n + .1430804 * i) / DD), a = uv((.0139322 * t + .0971045 * n + .7141733 * i) / PD)), new es(116 * r - 16, 500 * (s - r), 200 * (r - a), e.opacity)
     }
 
-    function $F(e, t) {
-        let n = 3,
-            i = 4.5,
-            r, s;
-
-        function a(o) {
-            return o && (typeof i == "function" && s.pointRadius(+i.apply(this, arguments)), ws(o, r(s))), s.result()
-        }
-        return a.area = function(o) {
-            return ws(o, r(yA)), yA.result()
-        }, a.measure = function(o) {
-            return ws(o, r(_A)), _A.result()
-        }, a.bounds = function(o) {
-            return ws(o, r(Yp)), Yp.result()
-        }, a.centroid = function(o) {
-            return ws(o, r(xA)), xA.result()
-        }, a.projection = function(o) {
-            return arguments.length ? (r = o == null ? (e = null, vh) : (e = o).stream, a) : e
-        }, a.context = function(o) {
-            return arguments.length ? (s = o == null ? (t = null, new CA(n)) : new SF(t = o), typeof i != "function" && s.pointRadius(i), a) : t
-        }, a.pointRadius = function(o) {
-            return arguments.length ? (i = typeof o == "function" ? o : (s.pointRadius(+o), +o), a) : i
-        }, a.digits = function(o) {
-            if (!arguments.length) return n;
-            if (o == null) n = null;
-            else {
-                const l = Math.floor(o);
-                if (!(l >= 0)) throw new RangeError(`invalid digits: ${o}`);
-                n = l
-            }
-            return t === null && (s = new CA(n)), a
-        }, a.projection(e).digits(n).context(t)
+    function ym(e, t, n, i) {
+        return arguments.length === 1 ? zD(e) : new es(e, t, n, i ?? 1)
     }
 
-    function um(e) {
-        return function(t) {
-            var n = new Nb;
-            for (var i in e) n[i] = e[i];
-            return n.stream = t, n
-        }
+    function es(e, t, n, i) {
+        this.l = +e, this.a = +t, this.b = +n, this.opacity = +i
     }
-
-    function Nb() {}
-    Nb.prototype = {
-        constructor: Nb,
-        point: function(e, t) {
-            this.stream.point(e, t)
-        },
-        sphere: function() {
-            this.stream.sphere()
-        },
-        lineStart: function() {
-            this.stream.lineStart()
-        },
-        lineEnd: function() {
-            this.stream.lineEnd()
+    Vc(es, ym, Fd(vo, {
+        brighter(e) {
+            return new es(this.l + mm * (e ?? 1), this.a, this.b, this.opacity)
         },
-        polygonStart: function() {
-            this.stream.polygonStart()
+        darker(e) {
+            return new es(this.l - mm * (e ?? 1), this.a, this.b, this.opacity)
         },
-        polygonEnd: function() {
-            this.stream.polygonEnd()
+        rgb() {
+            var e = (this.l + 16) / 116,
+                t = isNaN(this.a) ? e : e + this.a / 500,
+                n = isNaN(this.b) ? e : e - this.b / 200;
+            return t = DD * cv(t), e = ND * cv(e), n = PD * cv(n), new en(fv(3.1338561 * t - 1.6168667 * e - .4906146 * n), fv(-.9787684 * t + 1.9161415 * e + .033454 * n), fv(.0719453 * t - .2289914 * e + 1.4052427 * n), this.opacity)
         }
-    };
+    }));
 
-    function Nx(e, t, n) {
-        var i = e.clipExtent && e.clipExtent();
-        return e.scale(150).translate([0, 0]), i != null && e.clipExtent(null), ws(n, e.stream(Yp)), t(Yp.result()), i != null && e.clipExtent(i), e
+    function uv(e) {
+        return e > Tq ? Math.pow(e, 1 / 3) : e / ID + LD
     }
 
-    function cm(e, t, n) {
-        return Nx(e, function(i) {
-            var r = t[1][0] - t[0][0],
-                s = t[1][1] - t[0][1],
-                a = Math.min(r / (i[1][0] - i[0][0]), s / (i[1][1] - i[0][1])),
-                o = +t[0][0] + (r - a * (i[1][0] + i[0][0])) / 2,
-                l = +t[0][1] + (s - a * (i[1][1] + i[0][1])) / 2;
-            e.scale(150 * a).translate([o, l])
-        }, n)
+    function cv(e) {
+        return e > Hu ? e * e * e : ID * (e - LD)
     }
 
-    function Px(e, t, n) {
-        return cm(e, [
-            [0, 0], t
-        ], n)
+    function fv(e) {
+        return 255 * (e <= .0031308 ? 12.92 * e : 1.055 * Math.pow(e, 1 / 2.4) - .055)
     }
 
-    function Lx(e, t, n) {
-        return Nx(e, function(i) {
-            var r = +t,
-                s = r / (i[1][0] - i[0][0]),
-                a = (r - s * (i[1][0] + i[0][0])) / 2,
-                o = -s * i[0][1];
-            e.scale(150 * s).translate([a, o])
-        }, n)
+    function hv(e) {
+        return (e /= 255) <= .04045 ? e / 12.92 : Math.pow((e + .055) / 1.055, 2.4)
     }
 
-    function Ix(e, t, n) {
-        return Nx(e, function(i) {
-            var r = +t,
-                s = r / (i[1][1] - i[0][1]),
-                a = -s * i[0][0],
-                o = (r - s * (i[1][1] + i[0][1])) / 2;
-            e.scale(150 * s).translate([a, o])
-        }, n)
+    function Mq(e) {
+        if (e instanceof Us) return new Us(e.h, e.c, e.l, e.opacity);
+        if (e instanceof es || (e = zD(e)), e.a === 0 && e.b === 0) return new Us(NaN, 0 < e.l && e.l < 100 ? 0 : NaN, e.l, e.opacity);
+        var t = Math.atan2(e.b, e.a) * RD;
+        return new Us(t < 0 ? t + 360 : t, Math.sqrt(e.a * e.a + e.b * e.b), e.l, e.opacity)
     }
-    var kA = 16,
-        RG = xe(30 * Me);
 
-    function AA(e, t) {
-        return +t ? NG(e, t) : DG(e)
+    function vm(e, t, n, i) {
+        return arguments.length === 1 ? Mq(e) : new Us(e, t, n, i ?? 1)
     }
 
-    function DG(e) {
-        return um({
-            point: function(t, n) {
-                t = e(t, n), this.stream.point(t[0], t[1])
-            }
-        })
+    function Us(e, t, n, i) {
+        this.h = +e, this.c = +t, this.l = +n, this.opacity = +i
     }
 
-    function NG(e, t) {
-        function n(i, r, s, a, o, l, u, c, f, h, d, g, p, m) {
-            var y = u - i,
-                v = c - r,
-                b = y * y + v * v;
-            if (b > 4 * t && p--) {
-                var x = a + h,
-                    _ = o + d,
-                    S = l + g,
-                    w = In(x * x + _ * _ + S * S),
-                    E = ti(S /= w),
-                    A = Re(Re(S) - 1) < ve || Re(s - f) < ve ? (s + f) / 2 : Fi(_, x),
-                    C = e(A, E),
-                    k = C[0],
-                    R = C[1],
-                    $ = k - i,
-                    T = R - r,
-                    M = v * $ - y * T;
-                (M * M / b > t || Re((y * $ + v * T) / b - .5) > .3 || a * h + o * d + l * g < RG) && (n(i, r, s, a, o, l, k, R, A, x /= w, _ /= w, S, p, m), m.point(k, R), n(k, R, A, x, _, S, u, c, f, h, d, g, p, m))
-            }
-        }
-        return function(i) {
-            var r, s, a, o, l, u, c, f, h, d, g, p, m = {
-                point: y,
-                lineStart: v,
-                lineEnd: x,
-                polygonStart: function() {
-                    i.polygonStart(), m.lineStart = _
-                },
-                polygonEnd: function() {
-                    i.polygonEnd(), m.lineStart = v
-                }
-            };
-
-            function y(E, A) {
-                E = e(E, A), i.point(E[0], E[1])
-            }
-
-            function v() {
-                f = NaN, m.point = b, i.lineStart()
-            }
-
-            function b(E, A) {
-                var C = Zo([E, A]),
-                    k = e(E, A);
-                n(f, h, c, d, g, p, f = k[0], h = k[1], c = E, d = C[0], g = C[1], p = C[2], kA, i), i.point(f, h)
-            }
-
-            function x() {
-                m.point = y, i.lineEnd()
-            }
-
-            function _() {
-                v(), m.point = S, m.lineEnd = w
-            }
-
-            function S(E, A) {
-                b(r = E, A), s = f, a = h, o = d, l = g, u = p, m.point = b
-            }
-
-            function w() {
-                n(f, h, c, d, g, p, s, a, r, o, l, u, kA, i), m.lineEnd = x, x()
-            }
-            return m
-        }
+    function BD(e) {
+        if (isNaN(e.h)) return new es(e.l, 0, 0, e.opacity);
+        var t = e.h * FD;
+        return new es(e.l, Math.cos(t) * e.c, Math.sin(t) * e.c, e.opacity)
     }
-    var PG = um({
-        point: function(e, t) {
-            this.stream.point(e * Me, t * Me)
+    Vc(Us, vm, Fd(vo, {
+        brighter(e) {
+            return new Us(this.h, this.c, this.l + mm * (e ?? 1), this.opacity)
+        },
+        darker(e) {
+            return new Us(this.h, this.c, this.l - mm * (e ?? 1), this.opacity)
+        },
+        rgb() {
+            return BD(this).rgb()
         }
-    });
-
-    function LG(e) {
-        return um({
-            point: function(t, n) {
-                var i = e(t, n);
-                return this.stream.point(i[0], i[1])
-            }
-        })
-    }
+    }));
+    var jD = -.14861,
+        Dw = 1.78277,
+        Nw = -.29227,
+        u1 = -.90649,
+        Jh = 1.97294,
+        ZA = Jh * u1,
+        e$ = Jh * Dw,
+        t$ = Dw * Nw - u1 * jD;
 
-    function IG(e, t, n, i, r) {
-        function s(a, o) {
-            return a *= i, o *= r, [t + e * a, n - e * o]
-        }
-        return s.invert = function(a, o) {
-            return [(a - t) / e * i, (n - o) / e * r]
-        }, s
+    function Oq(e) {
+        if (e instanceof hl) return new hl(e.h, e.s, e.l, e.opacity);
+        e instanceof en || (e = Rw(e));
+        var t = e.r / 255,
+            n = e.g / 255,
+            i = e.b / 255,
+            r = (t$ * i + ZA * t - e$ * n) / (t$ + ZA - e$),
+            s = i - r,
+            a = (Jh * (n - r) - Nw * s) / u1,
+            o = Math.sqrt(a * a + s * s) / (Jh * r * (1 - r)),
+            l = o ? Math.atan2(a, s) * RD - 120 : NaN;
+        return new hl(l < 0 ? l + 360 : l, o, r, e.opacity)
     }
 
-    function $A(e, t, n, i, r, s) {
-        if (!s) return IG(e, t, n, i, r);
-        var a = xe(s),
-            o = pe(s),
-            l = a * e,
-            u = o * e,
-            c = a / e,
-            f = o / e,
-            h = (o * n - a * t) / e,
-            d = (o * t + a * n) / e;
-
-        function g(p, m) {
-            return p *= i, m *= r, [l * p - u * m + t, n - u * p - l * m]
-        }
-        return g.invert = function(p, m) {
-            return [i * (c * p - f * m + h), r * (d - f * p - c * m)]
-        }, g
+    function i2(e, t, n, i) {
+        return arguments.length === 1 ? Oq(e) : new hl(e, t, n, i ?? 1)
     }
 
-    function es(e) {
-        return TF(function() {
-            return e
-        })()
+    function hl(e, t, n, i) {
+        this.h = +e, this.s = +t, this.l = +n, this.opacity = +i
     }
-
-    function TF(e) {
-        var t, n = 150,
-            i = 480,
-            r = 250,
-            s = 0,
-            a = 0,
-            o = 0,
-            l = 0,
-            u = 0,
-            c, f = 0,
-            h = 1,
-            d = 1,
-            g = null,
-            p = gA,
-            m = null,
-            y, v, b, x = vh,
-            _ = .5,
-            S, w, E, A, C;
-
-        function k(M) {
-            return E(M[0] * Me, M[1] * Me)
-        }
-
-        function R(M) {
-            return M = E.invert(M[0], M[1]), M && [M[0] * St, M[1] * St]
-        }
-        k.stream = function(M) {
-            return A && C === M ? A : A = PG(LG(c)(p(S(x(C = M)))))
-        }, k.preclip = function(M) {
-            return arguments.length ? (p = M, g = void 0, T()) : p
-        }, k.postclip = function(M) {
-            return arguments.length ? (x = M, m = y = v = b = null, T()) : x
-        }, k.clipAngle = function(M) {
-            return arguments.length ? (p = +M ? vG(g = M * Me) : (g = null, gA), T()) : g * St
-        }, k.clipExtent = function(M) {
-            return arguments.length ? (x = M == null ? (m = y = v = b = null, vh) : mF(m = +M[0][0], y = +M[0][1], v = +M[1][0], b = +M[1][1]), T()) : m == null ? null : [
-                [m, y],
-                [v, b]
-            ]
-        }, k.scale = function(M) {
-            return arguments.length ? (n = +M, $()) : n
-        }, k.translate = function(M) {
-            return arguments.length ? (i = +M[0], r = +M[1], $()) : [i, r]
-        }, k.center = function(M) {
-            return arguments.length ? (s = M[0] % 360 * Me, a = M[1] % 360 * Me, $()) : [s * St, a * St]
-        }, k.rotate = function(M) {
-            return arguments.length ? (o = M[0] % 360 * Me, l = M[1] % 360 * Me, u = M.length > 2 ? M[2] % 360 * Me : 0, $()) : [o * St, l * St, u * St]
-        }, k.angle = function(M) {
-            return arguments.length ? (f = M % 360 * Me, $()) : f * St
-        }, k.reflectX = function(M) {
-            return arguments.length ? (h = M ? -1 : 1, $()) : h < 0
-        }, k.reflectY = function(M) {
-            return arguments.length ? (d = M ? -1 : 1, $()) : d < 0
-        }, k.precision = function(M) {
-            return arguments.length ? (S = AA(w, _ = M * M), T()) : In(_)
-        }, k.fitExtent = function(M, F) {
-            return cm(k, M, F)
-        }, k.fitSize = function(M, F) {
-            return Px(k, M, F)
-        }, k.fitWidth = function(M, F) {
-            return Lx(k, M, F)
-        }, k.fitHeight = function(M, F) {
-            return Ix(k, M, F)
-        };
-
-        function $() {
-            var M = $A(n, 0, 0, h, d, f).apply(null, t(s, a)),
-                F = $A(n, i - M[0], r - M[1], h, d, f);
-            return c = hF(o, l, u), w = Cb(t, F), E = Cb(c, w), S = AA(w, _), T()
-        }
-
-        function T() {
-            return A = C = null, k
-        }
-        return function() {
-            return t = e.apply(this, arguments), k.invert = t.invert && R, $()
+    Vc(hl, i2, Fd(vo, {
+        brighter(e) {
+            return e = e == null ? cc : Math.pow(cc, e), new hl(this.h, this.s, this.l * e, this.opacity)
+        },
+        darker(e) {
+            return e = e == null ? wl : Math.pow(wl, e), new hl(this.h, this.s, this.l * e, this.opacity)
+        },
+        rgb() {
+            var e = isNaN(this.h) ? 0 : (this.h + 120) * FD,
+                t = +this.l,
+                n = isNaN(this.s) ? 0 : this.s * t * (1 - t),
+                i = Math.cos(e),
+                r = Math.sin(e);
+            return new en(255 * (t + n * (jD * i + Dw * r)), 255 * (t + n * (Nw * i + u1 * r)), 255 * (t + n * (Jh * i)), this.opacity)
         }
-    }
-
-    function zx(e) {
-        var t = 0,
-            n = Oe / 3,
-            i = TF(e),
-            r = i(t, n);
-        return r.parallels = function(s) {
-            return arguments.length ? i(t = s[0] * Me, n = s[1] * Me) : [t * St, n * St]
-        }, r
-    }
-
-    function zG(e) {
-        var t = xe(e);
+    }));
 
-        function n(i, r) {
-            return [i * t, pe(r) / t]
-        }
-        return n.invert = function(i, r) {
-            return [i / t, ti(r * t)]
-        }, n
+    function GD(e, t, n, i, r) {
+        var s = e * e,
+            a = s * e;
+        return ((1 - 3 * e + 3 * s - a) * t + (4 - 6 * s + 3 * a) * n + (1 + 3 * e + 3 * s - 3 * a) * i + a * r) / 6
     }
 
-    function BG(e, t) {
-        var n = pe(e),
-            i = (n + pe(t)) / 2;
-        if (Re(i) < ve) return zG(e);
-        var r = 1 + n * (2 * i - n),
-            s = In(r) / i;
-
-        function a(o, l) {
-            var u = In(r - 2 * i * pe(l)) / i;
-            return [u * pe(o *= i), s - u * xe(o)]
+    function UD(e) {
+        var t = e.length - 1;
+        return function(n) {
+            var i = n <= 0 ? n = 0 : n >= 1 ? (n = 1, t - 1) : Math.floor(n * t),
+                r = e[i],
+                s = e[i + 1],
+                a = i > 0 ? e[i - 1] : 2 * r - s,
+                o = i < t - 1 ? e[i + 2] : 2 * s - r;
+            return GD((n - i / t) * t, a, r, s, o)
         }
-        return a.invert = function(o, l) {
-            var u = s - l,
-                c = Fi(o, Re(u)) * ki(u);
-            return u * i < 0 && (c -= Oe * ki(o) * ki(u)), [c / i, ti((r - (o * o + u * u) * i * i) / (2 * i))]
-        }, a
-    }
-
-    function Qp() {
-        return zx(BG).scale(155.424).center([0, 33.6442])
-    }
-
-    function MF() {
-        return Qp().parallels([29.5, 45.5]).scale(1070).translate([480, 250]).rotate([96, 0]).center([-.6, 38.7])
     }
 
-    function jG(e) {
+    function WD(e) {
         var t = e.length;
-        return {
-            point: function(n, i) {
-                for (var r = -1; ++r < t;) e[r].point(n, i)
-            },
-            sphere: function() {
-                for (var n = -1; ++n < t;) e[n].sphere()
-            },
-            lineStart: function() {
-                for (var n = -1; ++n < t;) e[n].lineStart()
-            },
-            lineEnd: function() {
-                for (var n = -1; ++n < t;) e[n].lineEnd()
-            },
-            polygonStart: function() {
-                for (var n = -1; ++n < t;) e[n].polygonStart()
-            },
-            polygonEnd: function() {
-                for (var n = -1; ++n < t;) e[n].polygonEnd()
-            }
-        }
-    }
-
-    function UG() {
-        var e, t, n = MF(),
-            i, r = Qp().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]),
-            s, a = Qp().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]),
-            o, l, u = {
-                point: function(h, d) {
-                    l = [h, d]
-                }
-            };
-
-        function c(h) {
-            var d = h[0],
-                g = h[1];
-            return l = null, i.point(d, g), l || (s.point(d, g), l) || (o.point(d, g), l)
-        }
-        c.invert = function(h) {
-            var d = n.scale(),
-                g = n.translate(),
-                p = (h[0] - g[0]) / d,
-                m = (h[1] - g[1]) / d;
-            return (m >= .12 && m < .234 && p >= -.425 && p < -.214 ? r : m >= .166 && m < .234 && p >= -.214 && p < -.115 ? a : n).invert(h)
-        }, c.stream = function(h) {
-            return e && t === h ? e : e = jG([n.stream(t = h), r.stream(h), a.stream(h)])
-        }, c.precision = function(h) {
-            return arguments.length ? (n.precision(h), r.precision(h), a.precision(h), f()) : n.precision()
-        }, c.scale = function(h) {
-            return arguments.length ? (n.scale(h), r.scale(h * .35), a.scale(h), c.translate(n.translate())) : n.scale()
-        }, c.translate = function(h) {
-            if (!arguments.length) return n.translate();
-            var d = n.scale(),
-                g = +h[0],
-                p = +h[1];
-            return i = n.translate(h).clipExtent([
-                [g - .455 * d, p - .238 * d],
-                [g + .455 * d, p + .238 * d]
-            ]).stream(u), s = r.translate([g - .307 * d, p + .201 * d]).clipExtent([
-                [g - .425 * d + ve, p + .12 * d + ve],
-                [g - .214 * d - ve, p + .234 * d - ve]
-            ]).stream(u), o = a.translate([g - .205 * d, p + .212 * d]).clipExtent([
-                [g - .214 * d + ve, p + .166 * d + ve],
-                [g - .115 * d - ve, p + .234 * d - ve]
-            ]).stream(u), f()
-        }, c.fitExtent = function(h, d) {
-            return cm(c, h, d)
-        }, c.fitSize = function(h, d) {
-            return Px(c, h, d)
-        }, c.fitWidth = function(h, d) {
-            return Lx(c, h, d)
-        }, c.fitHeight = function(h, d) {
-            return Ix(c, h, d)
-        };
-
-        function f() {
-            return e = t = null, c
-        }
-        return c.scale(1070)
-    }
-
-    function OF(e) {
-        return function(t, n) {
-            var i = xe(t),
-                r = xe(n),
-                s = e(i * r);
-            return s === 1 / 0 ? [2, 0] : [s * r * pe(t), s * pe(n)]
+        return function(n) {
+            var i = Math.floor(((n %= 1) < 0 ? ++n : n) * t),
+                r = e[(i + t - 1) % t],
+                s = e[i % t],
+                a = e[(i + 1) % t],
+                o = e[(i + 2) % t];
+            return GD((n - i / t) * t, r, s, a, o)
         }
     }
+    const c1 = e => () => e;
 
-    function nd(e) {
-        return function(t, n) {
-            var i = In(t * t + n * n),
-                r = e(i),
-                s = pe(r),
-                a = xe(r);
-            return [Fi(t * s, i * a), ti(i && n * s / i)]
+    function qD(e, t) {
+        return function(n) {
+            return e + n * t
         }
     }
-    var FF = OF(function(e) {
-        return In(2 / (1 + e))
-    });
-    FF.invert = nd(function(e) {
-        return 2 * ti(e / 2)
-    });
-
-    function GG() {
-        return es(FF).scale(124.75).clipAngle(180 - .001)
-    }
-    var RF = OF(function(e) {
-        return (e = tF(e)) && e / pe(e)
-    });
-    RF.invert = nd(function(e) {
-        return e
-    });
-
-    function WG() {
-        return es(RF).scale(79.4188).clipAngle(180 - .001)
-    }
-
-    function fm(e, t) {
-        return [e, Fp(Rx((vt + t) / 2))]
-    }
-    fm.invert = function(e, t) {
-        return [e, 2 * pc(eF(t)) - vt]
-    };
-
-    function qG() {
-        return DF(fm).scale(961 / Ln)
-    }
-
-    function DF(e) {
-        var t = es(e),
-            n = t.center,
-            i = t.scale,
-            r = t.translate,
-            s = t.clipExtent,
-            a = null,
-            o, l, u;
-        t.scale = function(f) {
-            return arguments.length ? (i(f), c()) : i()
-        }, t.translate = function(f) {
-            return arguments.length ? (r(f), c()) : r()
-        }, t.center = function(f) {
-            return arguments.length ? (n(f), c()) : n()
-        }, t.clipExtent = function(f) {
-            return arguments.length ? (f == null ? a = o = l = u = null : (a = +f[0][0], o = +f[0][1], l = +f[1][0], u = +f[1][1]), c()) : a == null ? null : [
-                [a, o],
-                [l, u]
-            ]
-        };
 
-        function c() {
-            var f = Oe * i(),
-                h = t(cG(t.rotate()).invert([0, 0]));
-            return s(a == null ? [
-                [h[0] - f, h[1] - f],
-                [h[0] + f, h[1] + f]
-            ] : e === fm ? [
-                [Math.max(h[0] - f, a), o],
-                [Math.min(h[0] + f, l), u]
-            ] : [
-                [a, Math.max(h[1] - f, o)],
-                [l, Math.min(h[1] + f, u)]
-            ])
-        }
-        return c()
+    function Fq(e, t, n) {
+        return e = Math.pow(e, n), t = Math.pow(t, n) - e, n = 1 / n,
+            function(i) {
+                return Math.pow(e + i * t, n)
+            }
     }
 
-    function cg(e) {
-        return Rx((vt + e) / 2)
+    function f1(e, t) {
+        var n = t - e;
+        return n ? qD(e, n > 180 || n < -180 ? n - 360 * Math.round(n / 360) : n) : c1(isNaN(e) ? t : e)
     }
 
-    function HG(e, t) {
-        var n = xe(e),
-            i = e === t ? pe(e) : Fp(n / xe(t)) / Fp(cg(t) / cg(e)),
-            r = n * Ty(cg(e), i) / i;
-        if (!i) return fm;
-
-        function s(a, o) {
-            r > 0 ? o < -vt + ve && (o = -vt + ve) : o > vt - ve && (o = vt - ve);
-            var l = r / Ty(cg(o), i);
-            return [l * pe(i * a), r - l * xe(i * a)]
+    function Rq(e) {
+        return (e = +e) == 1 ? tn : function(t, n) {
+            return n - t ? Fq(t, n, e) : c1(isNaN(t) ? n : t)
         }
-        return s.invert = function(a, o) {
-            var l = r - o,
-                u = ki(i) * In(a * a + l * l),
-                c = Fi(a, Re(l)) * ki(l);
-            return l * i < 0 && (c -= Oe * ki(a) * ki(l)), [c / i, 2 * pc(Ty(r / u, 1 / i)) - vt]
-        }, s
-    }
-
-    function YG() {
-        return zx(HG).scale(109.5).parallels([30, 30])
-    }
-
-    function Zp(e, t) {
-        return [e, t]
     }
-    Zp.invert = Zp;
 
-    function XG() {
-        return es(Zp).scale(152.63)
+    function tn(e, t) {
+        var n = t - e;
+        return n ? qD(e, n) : c1(isNaN(e) ? t : e)
     }
+    const r2 = function e(t) {
+        var n = Rq(t);
 
-    function VG(e, t) {
-        var n = xe(e),
-            i = e === t ? pe(e) : (n - xe(t)) / (t - e),
-            r = n / i + e;
-        if (Re(i) < ve) return Zp;
-
-        function s(a, o) {
-            var l = r - o,
-                u = i * a;
-            return [l * pe(u), r - l * xe(u)]
+        function i(r, s) {
+            var a = n((r = to(r)).r, (s = to(s)).r),
+                o = n(r.g, s.g),
+                l = n(r.b, s.b),
+                u = tn(r.opacity, s.opacity);
+            return function(c) {
+                return r.r = a(c), r.g = o(c), r.b = l(c), r.opacity = u(c), r + ""
+            }
         }
-        return s.invert = function(a, o) {
-            var l = r - o,
-                u = Fi(a, Re(l)) * ki(l);
-            return l * i < 0 && (u -= Oe * ki(a) * ki(l)), [u / i, r - ki(i) * In(a * a + l * l)]
-        }, s
-    }
-
-    function KG() {
-        return zx(VG).scale(131.154).center([0, 13.9389])
-    }
-    var Jf = 1.340264,
-        Qf = -.081106,
-        Zf = 893e-6,
-        eh = .003796,
-        e0 = In(3) / 2,
-        JG = 12;
-
-    function NF(e, t) {
-        var n = ti(e0 * pe(t)),
-            i = n * n,
-            r = i * i * i;
-        return [e * xe(n) / (e0 * (Jf + 3 * Qf * i + r * (7 * Zf + 9 * eh * i))), n * (Jf + Qf * i + r * (Zf + eh * i))]
-    }
-    NF.invert = function(e, t) {
-        for (var n = t, i = n * n, r = i * i * i, s = 0, a, o, l; s < JG && (o = n * (Jf + Qf * i + r * (Zf + eh * i)) - t, l = Jf + 3 * Qf * i + r * (7 * Zf + 9 * eh * i), n -= a = o / l, i = n * n, r = i * i * i, !(Re(a) < Mp)); ++s);
-        return [e0 * e * (Jf + 3 * Qf * i + r * (7 * Zf + 9 * eh * i)) / xe(n), ti(pe(n) / e0)]
-    };
-
-    function QG() {
-        return es(NF).scale(177.158)
-    }
-
-    function PF(e, t) {
-        var n = xe(t),
-            i = xe(e) * n;
-        return [n * pe(e) / i, pe(t) / i]
-    }
-    PF.invert = nd(pc);
-
-    function ZG() {
-        return es(PF).scale(144.049).clipAngle(60)
-    }
+        return i.gamma = e, i
+    }(1);
 
-    function eW() {
-        var e = 1,
-            t = 0,
-            n = 0,
-            i = 1,
-            r = 1,
-            s = 0,
-            a, o, l = null,
-            u, c, f, h = 1,
-            d = 1,
-            g = um({
-                point: function(x, _) {
-                    var S = b([x, _]);
-                    this.stream.point(S[0], S[1])
+    function HD(e) {
+        return function(t) {
+            var n = t.length,
+                i = new Array(n),
+                r = new Array(n),
+                s = new Array(n),
+                a, o;
+            for (a = 0; a < n; ++a) o = to(t[a]), i[a] = o.r || 0, r[a] = o.g || 0, s[a] = o.b || 0;
+            return i = e(i), r = e(r), s = e(s), o.opacity = 1,
+                function(l) {
+                    return o.r = i(l), o.g = r(l), o.b = s(l), o + ""
                 }
-            }),
-            p = vh,
-            m, y;
-
-        function v() {
-            return h = e * i, d = e * r, m = y = null, b
-        }
-
-        function b(x) {
-            var _ = x[0] * h,
-                S = x[1] * d;
-            if (s) {
-                var w = S * a - _ * o;
-                _ = _ * a + S * o, S = w
-            }
-            return [_ + t, S + n]
         }
-        return b.invert = function(x) {
-            var _ = x[0] - t,
-                S = x[1] - n;
-            if (s) {
-                var w = S * a + _ * o;
-                _ = _ * a - S * o, S = w
-            }
-            return [_ / h, S / d]
-        }, b.stream = function(x) {
-            return m && y === x ? m : m = g(p(y = x))
-        }, b.postclip = function(x) {
-            return arguments.length ? (p = x, l = u = c = f = null, v()) : p
-        }, b.clipExtent = function(x) {
-            return arguments.length ? (p = x == null ? (l = u = c = f = null, vh) : mF(l = +x[0][0], u = +x[0][1], c = +x[1][0], f = +x[1][1]), v()) : l == null ? null : [
-                [l, u],
-                [c, f]
-            ]
-        }, b.scale = function(x) {
-            return arguments.length ? (e = +x, v()) : e
-        }, b.translate = function(x) {
-            return arguments.length ? (t = +x[0], n = +x[1], v()) : [t, n]
-        }, b.angle = function(x) {
-            return arguments.length ? (s = x % 360 * Me, o = pe(s), a = xe(s), v()) : s * St
-        }, b.reflectX = function(x) {
-            return arguments.length ? (i = x ? -1 : 1, v()) : i < 0
-        }, b.reflectY = function(x) {
-            return arguments.length ? (r = x ? -1 : 1, v()) : r < 0
-        }, b.fitExtent = function(x, _) {
-            return cm(b, x, _)
-        }, b.fitSize = function(x, _) {
-            return Px(b, x, _)
-        }, b.fitWidth = function(x, _) {
-            return Lx(b, x, _)
-        }, b.fitHeight = function(x, _) {
-            return Ix(b, x, _)
-        }, b
     }
+    var Dq = HD(UD),
+        Nq = HD(WD);
 
-    function LF(e, t) {
-        var n = t * t,
-            i = n * n;
-        return [e * (.8707 - .131979 * n + i * (-.013791 + i * (.003971 * n - .001529 * i))), t * (1.007226 + n * (.015085 + i * (-.044475 + .028874 * n - .005916 * i)))]
-    }
-    LF.invert = function(e, t) {
-        var n = t,
-            i = 25,
+    function Pw(e, t) {
+        t || (t = []);
+        var n = e ? Math.min(t.length, e.length) : 0,
+            i = t.slice(),
             r;
-        do {
-            var s = n * n,
-                a = s * s;
-            n -= r = (n * (1.007226 + s * (.015085 + a * (-.044475 + .028874 * s - .005916 * a))) - t) / (1.007226 + s * (.015085 * 3 + a * (-.044475 * 7 + .028874 * 9 * s - .005916 * 11 * a)))
-        } while (Re(r) > ve && --i > 0);
-        return [e / (.8707 + (s = n * n) * (-.131979 + s * (-.013791 + s * s * s * (.003971 - .001529 * s)))), n]
-    };
-
-    function tW() {
-        return es(LF).scale(175.295)
-    }
-
-    function IF(e, t) {
-        return [xe(t) * pe(e), pe(t)]
-    }
-    IF.invert = nd(ti);
-
-    function nW() {
-        return es(IF).scale(249.5).clipAngle(90 + ve)
-    }
-
-    function zF(e, t) {
-        var n = xe(t),
-            i = 1 + xe(e) * n;
-        return [n * pe(e) / i, pe(t) / i]
-    }
-    zF.invert = nd(function(e) {
-        return 2 * pc(e)
-    });
-
-    function iW() {
-        return es(zF).scale(250).clipAngle(142)
-    }
-
-    function BF(e, t) {
-        return [Fp(Rx((vt + t) / 2)), -e]
-    }
-    BF.invert = function(e, t) {
-        return [-t, 2 * pc(eF(e)) - vt]
-    };
-
-    function rW() {
-        var e = DF(BF),
-            t = e.center,
-            n = e.rotate;
-        return e.center = function(i) {
-            return arguments.length ? t([-i[1], i[0]]) : (i = t(), [i[1], -i[0]])
-        }, e.rotate = function(i) {
-            return arguments.length ? n([i[0], i[1], i.length > 2 ? i[2] + 90 : 90]) : (i = n(), [i[0], i[1], i[2] - 90])
-        }, n([0, 0, 90]).scale(159.155)
-    }
-
-    function sW(e, t) {
-        return e.parent === t.parent ? 1 : 2
-    }
-
-    function aW(e) {
-        return e.reduce(oW, 0) / e.length
-    }
-
-    function oW(e, t) {
-        return e + t.x
-    }
-
-    function lW(e) {
-        return 1 + e.reduce(uW, 0)
-    }
-
-    function uW(e, t) {
-        return Math.max(e, t.y)
-    }
-
-    function cW(e) {
-        for (var t; t = e.children;) e = t[0];
-        return e
-    }
-
-    function fW(e) {
-        for (var t; t = e.children;) e = t[t.length - 1];
-        return e
-    }
-
-    function hW() {
-        var e = sW,
-            t = 1,
-            n = 1,
-            i = !1;
-
-        function r(s) {
-            var a, o = 0;
-            s.eachAfter(function(h) {
-                var d = h.children;
-                d ? (h.x = aW(d), h.y = lW(d)) : (h.x = a ? o += e(h, a) : 0, h.y = 0, a = h)
-            });
-            var l = cW(s),
-                u = fW(s),
-                c = l.x - e(l, u) / 2,
-                f = u.x + e(u, l) / 2;
-            return s.eachAfter(i ? function(h) {
-                h.x = (h.x - s.x) * t, h.y = (s.y - h.y) * n
-            } : function(h) {
-                h.x = (h.x - c) / (f - c) * t, h.y = (1 - (s.y ? h.y / s.y : 1)) * n
-            })
+        return function(s) {
+            for (r = 0; r < n; ++r) i[r] = e[r] * (1 - s) + t[r] * s;
+            return i
         }
-        return r.separation = function(s) {
-            return arguments.length ? (e = s, r) : e
-        }, r.size = function(s) {
-            return arguments.length ? (i = !1, t = +s[0], n = +s[1], r) : i ? null : [t, n]
-        }, r.nodeSize = function(s) {
-            return arguments.length ? (i = !0, t = +s[0], n = +s[1], r) : i ? [t, n] : null
-        }, r
-    }
-
-    function dW(e) {
-        var t = 0,
-            n = e.children,
-            i = n && n.length;
-        if (!i) t = 1;
-        else
-            for (; --i >= 0;) t += n[i].value;
-        e.value = t
-    }
-
-    function gW() {
-        return this.eachAfter(dW)
-    }
-
-    function pW(e, t) {
-        let n = -1;
-        for (const i of this) e.call(t, i, ++n, this);
-        return this
-    }
-
-    function mW(e, t) {
-        for (var n = this, i = [n], r, s, a = -1; n = i.pop();)
-            if (e.call(t, n, ++a, this), r = n.children)
-                for (s = r.length - 1; s >= 0; --s) i.push(r[s]);
-        return this
-    }
-
-    function yW(e, t) {
-        for (var n = this, i = [n], r = [], s, a, o, l = -1; n = i.pop();)
-            if (r.push(n), s = n.children)
-                for (a = 0, o = s.length; a < o; ++a) i.push(s[a]);
-        for (; n = r.pop();) e.call(t, n, ++l, this);
-        return this
-    }
-
-    function vW(e, t) {
-        let n = -1;
-        for (const i of this)
-            if (e.call(t, i, ++n, this)) return i
-    }
-
-    function bW(e) {
-        return this.eachAfter(function(t) {
-            for (var n = +e(t.data) || 0, i = t.children, r = i && i.length; --r >= 0;) n += i[r].value;
-            t.value = n
-        })
-    }
-
-    function xW(e) {
-        return this.eachBefore(function(t) {
-            t.children && t.children.sort(e)
-        })
-    }
-
-    function _W(e) {
-        for (var t = this, n = wW(t, e), i = [t]; t !== n;) t = t.parent, i.push(t);
-        for (var r = i.length; e !== n;) i.splice(r, 0, e), e = e.parent;
-        return i
-    }
-
-    function wW(e, t) {
-        if (e === t) return e;
-        var n = e.ancestors(),
-            i = t.ancestors(),
-            r = null;
-        for (e = n.pop(), t = i.pop(); e === t;) r = e, e = n.pop(), t = i.pop();
-        return r
-    }
-
-    function SW() {
-        for (var e = this, t = [e]; e = e.parent;) t.push(e);
-        return t
-    }
-
-    function EW() {
-        return Array.from(this)
-    }
-
-    function CW() {
-        var e = [];
-        return this.eachBefore(function(t) {
-            t.children || e.push(t)
-        }), e
-    }
-
-    function kW() {
-        var e = this,
-            t = [];
-        return e.each(function(n) {
-            n !== e && t.push({
-                source: n.parent,
-                target: n
-            })
-        }), t
-    }
-
-    function* AW() {
-        var e = this,
-            t, n = [e],
-            i, r, s;
-        do
-            for (t = n.reverse(), n = []; e = t.pop();)
-                if (yield e, i = e.children)
-                    for (r = 0, s = i.length; r < s; ++r) n.push(i[r]); while (n.length)
-    }
-
-    function Bx(e, t) {
-        e instanceof Map ? (e = [void 0, e], t === void 0 && (t = MW)) : t === void 0 && (t = TW);
-        for (var n = new Pu(e), i, r = [n], s, a, o, l; i = r.pop();)
-            if ((a = t(i.data)) && (l = (a = Array.from(a)).length))
-                for (i.children = a, o = l - 1; o >= 0; --o) r.push(s = a[o] = new Pu(a[o])), s.parent = i, s.depth = i.depth + 1;
-        return n.eachBefore(jF)
-    }
-
-    function $W() {
-        return Bx(this).eachBefore(OW)
-    }
-
-    function TW(e) {
-        return e.children
-    }
-
-    function MW(e) {
-        return Array.isArray(e) ? e[1] : null
-    }
-
-    function OW(e) {
-        e.data.value !== void 0 && (e.value = e.data.value), e.data = e.data.data
-    }
-
-    function jF(e) {
-        var t = 0;
-        do e.height = t; while ((e = e.parent) && e.height < ++t)
-    }
-
-    function Pu(e) {
-        this.data = e, this.depth = this.height = 0, this.parent = null
-    }
-    Pu.prototype = Bx.prototype = {
-        constructor: Pu,
-        count: gW,
-        each: pW,
-        eachAfter: yW,
-        eachBefore: mW,
-        find: vW,
-        sum: bW,
-        sort: xW,
-        path: _W,
-        ancestors: SW,
-        descendants: EW,
-        leaves: CW,
-        links: kW,
-        copy: $W,
-        [Symbol.iterator]: AW
-    };
-
-    function Yg(e) {
-        return e == null ? null : UF(e)
     }
 
-    function UF(e) {
-        if (typeof e != "function") throw new Error;
-        return e
+    function YD(e) {
+        return ArrayBuffer.isView(e) && !(e instanceof DataView)
     }
 
-    function Ao() {
-        return 0
+    function Pq(e, t) {
+        return (YD(t) ? Pw : XD)(e, t)
     }
 
-    function au(e) {
-        return function() {
-            return e
+    function XD(e, t) {
+        var n = t ? t.length : 0,
+            i = e ? Math.min(n, e.length) : 0,
+            r = new Array(i),
+            s = new Array(n),
+            a;
+        for (a = 0; a < i; ++a) r[a] = bo(e[a], t[a]);
+        for (; a < n; ++a) s[a] = t[a];
+        return function(o) {
+            for (a = 0; a < i; ++a) s[a] = r[a](o);
+            return s
         }
     }
-    const FW = 1664525,
-        RW = 1013904223,
-        TA = 4294967296;
-
-    function DW() {
-        let e = 1;
-        return () => (e = (FW * e + RW) % TA) / TA
-    }
-
-    function NW(e) {
-        return typeof e == "object" && "length" in e ? e : Array.from(e)
-    }
-
-    function PW(e, t) {
-        let n = e.length,
-            i, r;
-        for (; n;) r = t() * n-- | 0, i = e[n], e[n] = e[r], e[r] = i;
-        return e
-    }
-
-    function LW(e, t) {
-        for (var n = 0, i = (e = PW(Array.from(e), t)).length, r = [], s, a; n < i;) s = e[n], a && GF(a, s) ? ++n : (a = zW(r = IW(r, s)), n = 0);
-        return a
-    }
-
-    function IW(e, t) {
-        var n, i;
-        if (Dy(t, e)) return [t];
-        for (n = 0; n < e.length; ++n)
-            if (fg(t, e[n]) && Dy(Mf(e[n], t), e)) return [e[n], t];
-        for (n = 0; n < e.length - 1; ++n)
-            for (i = n + 1; i < e.length; ++i)
-                if (fg(Mf(e[n], e[i]), t) && fg(Mf(e[n], t), e[i]) && fg(Mf(e[i], t), e[n]) && Dy(WF(e[n], e[i], t), e)) return [e[n], e[i], t];
-        throw new Error
-    }
-
-    function fg(e, t) {
-        var n = e.r - t.r,
-            i = t.x - e.x,
-            r = t.y - e.y;
-        return n < 0 || n * n < i * i + r * r
-    }
 
-    function GF(e, t) {
-        var n = e.r - t.r + Math.max(e.r, t.r, 1) * 1e-9,
-            i = t.x - e.x,
-            r = t.y - e.y;
-        return n > 0 && n * n > i * i + r * r
-    }
-
-    function Dy(e, t) {
-        for (var n = 0; n < t.length; ++n)
-            if (!GF(e, t[n])) return !1;
-        return !0
+    function VD(e, t) {
+        var n = new Date;
+        return e = +e, t = +t,
+            function(i) {
+                return n.setTime(e * (1 - i) + t * i), n
+            }
     }
 
-    function zW(e) {
-        switch (e.length) {
-            case 1:
-                return BW(e[0]);
-            case 2:
-                return Mf(e[0], e[1]);
-            case 3:
-                return WF(e[0], e[1], e[2])
-        }
+    function cr(e, t) {
+        return e = +e, t = +t,
+            function(n) {
+                return e * (1 - n) + t * n
+            }
     }
 
-    function BW(e) {
-        return {
-            x: e.x,
-            y: e.y,
-            r: e.r
+    function KD(e, t) {
+        var n = {},
+            i = {},
+            r;
+        (e === null || typeof e != "object") && (e = {}), (t === null || typeof t != "object") && (t = {});
+        for (r in t) r in e ? n[r] = bo(e[r], t[r]) : i[r] = t[r];
+        return function(s) {
+            for (r in n) i[r] = n[r](s);
+            return i
         }
     }
+    var s2 = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
+        dv = new RegExp(s2.source, "g");
 
-    function Mf(e, t) {
-        var n = e.x,
-            i = e.y,
-            r = e.r,
-            s = t.x,
-            a = t.y,
-            o = t.r,
-            l = s - n,
-            u = a - i,
-            c = o - r,
-            f = Math.sqrt(l * l + u * u);
-        return {
-            x: (n + s + l / f * c) / 2,
-            y: (i + a + u / f * c) / 2,
-            r: (f + r + o) / 2
+    function Lq(e) {
+        return function() {
+            return e
         }
     }
 
-    function WF(e, t, n) {
-        var i = e.x,
-            r = e.y,
-            s = e.r,
-            a = t.x,
-            o = t.y,
-            l = t.r,
-            u = n.x,
-            c = n.y,
-            f = n.r,
-            h = i - a,
-            d = i - u,
-            g = r - o,
-            p = r - c,
-            m = l - s,
-            y = f - s,
-            v = i * i + r * r - s * s,
-            b = v - a * a - o * o + l * l,
-            x = v - u * u - c * c + f * f,
-            _ = d * g - h * p,
-            S = (g * x - p * b) / (_ * 2) - i,
-            w = (p * m - g * y) / _,
-            E = (d * b - h * x) / (_ * 2) - r,
-            A = (h * y - d * m) / _,
-            C = w * w + A * A - 1,
-            k = 2 * (s + S * w + E * A),
-            R = S * S + E * E - s * s,
-            $ = -(Math.abs(C) > 1e-6 ? (k + Math.sqrt(k * k - 4 * C * R)) / (2 * C) : R / k);
-        return {
-            x: i + S + w * $,
-            y: r + E + A * $,
-            r: $
+    function Iq(e) {
+        return function(t) {
+            return e(t) + ""
         }
     }
 
-    function MA(e, t, n) {
-        var i = e.x - t.x,
-            r, s, a = e.y - t.y,
-            o, l, u = i * i + a * a;
-        u ? (s = t.r + n.r, s *= s, l = e.r + n.r, l *= l, s > l ? (r = (u + l - s) / (2 * u), o = Math.sqrt(Math.max(0, l / u - r * r)), n.x = e.x - r * i - o * a, n.y = e.y - r * a + o * i) : (r = (u + s - l) / (2 * u), o = Math.sqrt(Math.max(0, s / u - r * r)), n.x = t.x + r * i - o * a, n.y = t.y + r * a + o * i)) : (n.x = t.x + n.r, n.y = t.y)
-    }
-
-    function OA(e, t) {
-        var n = e.r + t.r - 1e-6,
-            i = t.x - e.x,
-            r = t.y - e.y;
-        return n > 0 && n * n > i * i + r * r
-    }
-
-    function FA(e) {
-        var t = e._,
-            n = e.next._,
-            i = t.r + n.r,
-            r = (t.x * n.r + n.x * t.r) / i,
-            s = (t.y * n.r + n.y * t.r) / i;
-        return r * r + s * s
-    }
-
-    function hg(e) {
-        this._ = e, this.next = null, this.previous = null
-    }
-
-    function jW(e, t) {
-        if (!(s = (e = NW(e)).length)) return 0;
-        var n, i, r, s, a, o, l, u, c, f, h;
-        if (n = e[0], n.x = 0, n.y = 0, !(s > 1)) return n.r;
-        if (i = e[1], n.x = -i.r, i.x = n.r, i.y = 0, !(s > 2)) return n.r + i.r;
-        MA(i, n, r = e[2]), n = new hg(n), i = new hg(i), r = new hg(r), n.next = r.previous = i, i.next = n.previous = r, r.next = i.previous = n;
-        e: for (l = 3; l < s; ++l) {
-            MA(n._, i._, r = e[l]), r = new hg(r), u = i.next, c = n.previous, f = i._.r, h = n._.r;
-            do
-                if (f <= h) {
-                    if (OA(u._, r._)) {
-                        i = u, n.next = i, i.previous = n, --l;
-                        continue e
-                    }
-                    f += u._.r, u = u.next
-                } else {
-                    if (OA(c._, r._)) {
-                        n = c, n.next = i, i.previous = n, --l;
-                        continue e
-                    }
-                    h += c._.r, c = c.previous
-                } while (u !== c.next);
-            for (r.previous = n, r.next = i, n.next = i.previous = i = r, a = FA(n);
-                (r = r.next) !== i;)(o = FA(r)) < a && (n = r, a = o);
-            i = n.next
-        }
-        for (n = [i._], r = i;
-            (r = r.next) !== i;) n.push(r._);
-        for (r = LW(n, t), l = 0; l < s; ++l) n = e[l], n.x -= r.x, n.y -= r.y;
-        return r.r
+    function JD(e, t) {
+        var n = s2.lastIndex = dv.lastIndex = 0,
+            i, r, s, a = -1,
+            o = [],
+            l = [];
+        for (e = e + "", t = t + "";
+            (i = s2.exec(e)) && (r = dv.exec(t));)(s = r.index) > n && (s = t.slice(n, s), o[a] ? o[a] += s : o[++a] = s), (i = i[0]) === (r = r[0]) ? o[a] ? o[a] += r : o[++a] = r : (o[++a] = null, l.push({
+            i: a,
+            x: cr(i, r)
+        })), n = dv.lastIndex;
+        return n < t.length && (s = t.slice(n), o[a] ? o[a] += s : o[++a] = s), o.length < 2 ? l[0] ? Iq(l[0].x) : Lq(t) : (t = l.length, function(u) {
+            for (var c = 0, f; c < t; ++c) o[(f = l[c]).i] = f.x(u);
+            return o.join("")
+        })
     }
 
-    function UW(e) {
-        return Math.sqrt(e.value)
+    function bo(e, t) {
+        var n = typeof t,
+            i;
+        return t == null || n === "boolean" ? c1(t) : (n === "number" ? cr : n === "string" ? (i = Kh(t)) ? (t = i, r2) : JD : t instanceof Kh ? r2 : t instanceof Date ? VD : YD(t) ? Pw : Array.isArray(t) ? XD : typeof t.valueOf != "function" && typeof t.toString != "function" || isNaN(t) ? KD : cr)(e, t)
     }
 
-    function GW() {
-        var e = null,
-            t = 1,
-            n = 1,
-            i = Ao;
-
-        function r(s) {
-            const a = DW();
-            return s.x = t / 2, s.y = n / 2, e ? s.eachBefore(RA(e)).eachAfter(Ny(i, .5, a)).eachBefore(DA(1)) : s.eachBefore(RA(UW)).eachAfter(Ny(Ao, 1, a)).eachAfter(Ny(i, s.r / Math.min(t, n), a)).eachBefore(DA(Math.min(t, n) / (2 * s.r))), s
+    function zq(e) {
+        var t = e.length;
+        return function(n) {
+            return e[Math.max(0, Math.min(t - 1, Math.floor(n * t)))]
         }
-        return r.radius = function(s) {
-            return arguments.length ? (e = Yg(s), r) : e
-        }, r.size = function(s) {
-            return arguments.length ? (t = +s[0], n = +s[1], r) : [t, n]
-        }, r.padding = function(s) {
-            return arguments.length ? (i = typeof s == "function" ? s : au(+s), r) : i
-        }, r
     }
 
-    function RA(e) {
-        return function(t) {
-            t.children || (t.r = Math.max(0, +e(t) || 0))
+    function Bq(e, t) {
+        var n = f1(+e, +t);
+        return function(i) {
+            var r = n(i);
+            return r - 360 * Math.floor(r / 360)
         }
     }
 
-    function Ny(e, t, n) {
-        return function(i) {
-            if (r = i.children) {
-                var r, s, a = r.length,
-                    o = e(i) * t || 0,
-                    l;
-                if (o)
-                    for (s = 0; s < a; ++s) r[s].r += o;
-                if (l = jW(r, n), o)
-                    for (s = 0; s < a; ++s) r[s].r -= o;
-                i.r = l + o
+    function Rd(e, t) {
+        return e = +e, t = +t,
+            function(n) {
+                return Math.round(e * (1 - n) + t * n)
             }
-        }
     }
+    var n$ = 180 / Math.PI,
+        a2 = {
+            translateX: 0,
+            translateY: 0,
+            rotate: 0,
+            skewX: 0,
+            scaleX: 1,
+            scaleY: 1
+        };
 
-    function DA(e) {
-        return function(t) {
-            var n = t.parent;
-            t.r *= e, n && (t.x = n.x + e * t.x, t.y = n.y + e * t.y)
+    function QD(e, t, n, i, r, s) {
+        var a, o, l;
+        return (a = Math.sqrt(e * e + t * t)) && (e /= a, t /= a), (l = e * n + t * i) && (n -= e * l, i -= t * l), (o = Math.sqrt(n * n + i * i)) && (n /= o, i /= o, l /= o), e * i < t * n && (e = -e, t = -t, l = -l, a = -a), {
+            translateX: r,
+            translateY: s,
+            rotate: Math.atan2(t, e) * n$,
+            skewX: Math.atan(l) * n$,
+            scaleX: a,
+            scaleY: o
         }
     }
+    var Ag;
 
-    function qF(e) {
-        e.x0 = Math.round(e.x0), e.y0 = Math.round(e.y0), e.x1 = Math.round(e.x1), e.y1 = Math.round(e.y1)
+    function jq(e) {
+        const t = new(typeof DOMMatrix == "function" ? DOMMatrix : WebKitCSSMatrix)(e + "");
+        return t.isIdentity ? a2 : QD(t.a, t.b, t.c, t.d, t.e, t.f)
     }
 
-    function id(e, t, n, i, r) {
-        for (var s = e.children, a, o = -1, l = s.length, u = e.value && (i - t) / e.value; ++o < l;) a = s[o], a.y0 = n, a.y1 = r, a.x0 = t, a.x1 = t += a.value * u
+    function Gq(e) {
+        return e == null || (Ag || (Ag = document.createElementNS("http://www.w3.org/2000/svg", "g")), Ag.setAttribute("transform", e), !(e = Ag.transform.baseVal.consolidate())) ? a2 : (e = e.matrix, QD(e.a, e.b, e.c, e.d, e.e, e.f))
     }
 
-    function WW() {
-        var e = 1,
-            t = 1,
-            n = 0,
-            i = !1;
-
-        function r(a) {
-            var o = a.height + 1;
-            return a.x0 = a.y0 = n, a.x1 = e, a.y1 = t / o, a.eachBefore(s(t, o)), i && a.eachBefore(qF), a
+    function ZD(e, t, n, i) {
+        function r(u) {
+            return u.length ? u.pop() + " " : ""
         }
 
-        function s(a, o) {
-            return function(l) {
-                l.children && id(l, l.x0, a * (l.depth + 1) / o, l.x1, a * (l.depth + 2) / o);
-                var u = l.x0,
-                    c = l.y0,
-                    f = l.x1 - n,
-                    h = l.y1 - n;
-                f < u && (u = f = (u + f) / 2), h < c && (c = h = (c + h) / 2), l.x0 = u, l.y0 = c, l.x1 = f, l.y1 = h
-            }
+        function s(u, c, f, h, d, g) {
+            if (u !== f || c !== h) {
+                var p = d.push("translate(", null, t, null, n);
+                g.push({
+                    i: p - 4,
+                    x: cr(u, f)
+                }, {
+                    i: p - 2,
+                    x: cr(c, h)
+                })
+            } else(f || h) && d.push("translate(" + f + t + h + n)
         }
-        return r.round = function(a) {
-            return arguments.length ? (i = !!a, r) : i
-        }, r.size = function(a) {
-            return arguments.length ? (e = +a[0], t = +a[1], r) : [e, t]
-        }, r.padding = function(a) {
-            return arguments.length ? (n = +a, r) : n
-        }, r
-    }
-    var qW = {
-            depth: -1
-        },
-        NA = {},
-        Py = {};
-
-    function HW(e) {
-        return e.id
-    }
-
-    function YW(e) {
-        return e.parentId
-    }
-
-    function PA() {
-        var e = HW,
-            t = YW,
-            n;
 
-        function i(r) {
-            var s = Array.from(r),
-                a = e,
-                o = t,
-                l, u, c, f, h, d, g, p, m = new Map;
-            if (n != null) {
-                const y = s.map((x, _) => XW(n(x, _, r))),
-                    v = y.map(LA),
-                    b = new Set(y).add("");
-                for (const x of v) b.has(x) || (b.add(x), y.push(x), v.push(LA(x)), s.push(Py));
-                a = (x, _) => y[_], o = (x, _) => v[_]
-            }
-            for (c = 0, l = s.length; c < l; ++c) u = s[c], d = s[c] = new Pu(u), (g = a(u, c, r)) != null && (g += "") && (p = d.id = g, m.set(p, m.has(p) ? NA : d)), (g = o(u, c, r)) != null && (g += "") && (d.parent = g);
-            for (c = 0; c < l; ++c)
-                if (d = s[c], g = d.parent) {
-                    if (h = m.get(g), !h) throw new Error("missing: " + g);
-                    if (h === NA) throw new Error("ambiguous: " + g);
-                    h.children ? h.children.push(d) : h.children = [d], d.parent = h
-                } else {
-                    if (f) throw new Error("multiple roots");
-                    f = d
-                } if (!f) throw new Error("no root");
-            if (n != null) {
-                for (; f.data === Py && f.children.length === 1;) f = f.children[0], --l;
-                for (let y = s.length - 1; y >= 0 && (d = s[y], d.data === Py); --y) d.data = null
-            }
-            if (f.parent = qW, f.eachBefore(function(y) {
-                    y.depth = y.parent.depth + 1, --l
-                }).eachBefore(jF), f.parent = null, l > 0) throw new Error("cycle");
-            return f
+        function a(u, c, f, h) {
+            u !== c ? (u - c > 180 ? c += 360 : c - u > 180 && (u += 360), h.push({
+                i: f.push(r(f) + "rotate(", null, i) - 2,
+                x: cr(u, c)
+            })) : c && f.push(r(f) + "rotate(" + c + i)
         }
-        return i.id = function(r) {
-            return arguments.length ? (e = Yg(r), i) : e
-        }, i.parentId = function(r) {
-            return arguments.length ? (t = Yg(r), i) : t
-        }, i.path = function(r) {
-            return arguments.length ? (n = Yg(r), i) : n
-        }, i
-    }
 
-    function XW(e) {
-        e = `${e}`;
-        let t = e.length;
-        return Pb(e, t - 1) && !Pb(e, t - 2) && (e = e.slice(0, -1)), e[0] === "/" ? e : `/${e}`
-    }
-
-    function LA(e) {
-        let t = e.length;
-        if (t < 2) return "";
-        for (; --t > 1 && !Pb(e, t););
-        return e.slice(0, t)
-    }
-
-    function Pb(e, t) {
-        if (e[t] === "/") {
-            let n = 0;
-            for (; t > 0 && e[--t] === "\\";) ++n;
-            if (!(n & 1)) return !0
+        function o(u, c, f, h) {
+            u !== c ? h.push({
+                i: f.push(r(f) + "skewX(", null, i) - 2,
+                x: cr(u, c)
+            }) : c && f.push(r(f) + "skewX(" + c + i)
         }
-        return !1
-    }
-
-    function VW(e, t) {
-        return e.parent === t.parent ? 1 : 2
-    }
-
-    function Ly(e) {
-        var t = e.children;
-        return t ? t[0] : e.t
-    }
-
-    function Iy(e) {
-        var t = e.children;
-        return t ? t[t.length - 1] : e.t
-    }
 
-    function KW(e, t, n) {
-        var i = n / (t.i - e.i);
-        t.c -= i, t.s += n, e.c += i, t.z += n, t.m += n
-    }
-
-    function JW(e) {
-        for (var t = 0, n = 0, i = e.children, r = i.length, s; --r >= 0;) s = i[r], s.z += t, s.m += t, t += s.s + (n += s.c)
+        function l(u, c, f, h, d, g) {
+            if (u !== f || c !== h) {
+                var p = d.push(r(d) + "scale(", null, ",", null, ")");
+                g.push({
+                    i: p - 4,
+                    x: cr(u, f)
+                }, {
+                    i: p - 2,
+                    x: cr(c, h)
+                })
+            } else(f !== 1 || h !== 1) && d.push(r(d) + "scale(" + f + "," + h + ")")
+        }
+        return function(u, c) {
+            var f = [],
+                h = [];
+            return u = e(u), c = e(c), s(u.translateX, u.translateY, c.translateX, c.translateY, f, h), a(u.rotate, c.rotate, f, h), o(u.skewX, c.skewX, f, h), l(u.scaleX, u.scaleY, c.scaleX, c.scaleY, f, h), u = c = null,
+                function(d) {
+                    for (var g = -1, p = h.length, m; ++g < p;) f[(m = h[g]).i] = m.x(d);
+                    return f.join("")
+                }
+        }
     }
+    var Uq = ZD(jq, "px, ", "px)", "deg)"),
+        Wq = ZD(Gq, ", ", ")", ")"),
+        qq = 1e-12;
 
-    function QW(e, t, n) {
-        return e.a.parent === t.parent ? e.a : n
+    function i$(e) {
+        return ((e = Math.exp(e)) + 1 / e) / 2
     }
 
-    function Xg(e, t) {
-        this._ = e, this.parent = null, this.children = null, this.A = null, this.a = this, this.z = 0, this.m = 0, this.c = 0, this.s = 0, this.t = null, this.i = t
+    function Hq(e) {
+        return ((e = Math.exp(e)) - 1 / e) / 2
     }
-    Xg.prototype = Object.create(Pu.prototype);
 
-    function ZW(e) {
-        for (var t = new Xg(e, 0), n, i = [t], r, s, a, o; n = i.pop();)
-            if (s = n._.children)
-                for (n.children = new Array(o = s.length), a = o - 1; a >= 0; --a) i.push(r = n.children[a] = new Xg(s[a], a)), r.parent = n;
-        return (t.parent = new Xg(null, 0)).children = [t], t
+    function Yq(e) {
+        return ((e = Math.exp(2 * e)) - 1) / (e + 1)
     }
-
-    function eq() {
-        var e = VW,
-            t = 1,
-            n = 1,
-            i = null;
-
-        function r(u) {
-            var c = ZW(u);
-            if (c.eachAfter(s), c.parent.m = -c.z, c.eachBefore(a), i) u.eachBefore(l);
+    const Xq = function e(t, n, i) {
+        function r(s, a) {
+            var o = s[0],
+                l = s[1],
+                u = s[2],
+                c = a[0],
+                f = a[1],
+                h = a[2],
+                d = c - o,
+                g = f - l,
+                p = d * d + g * g,
+                m, y;
+            if (p < qq) y = Math.log(h / u) / t, m = function(w) {
+                return [o + w * d, l + w * g, u * Math.exp(t * w * y)]
+            };
             else {
-                var f = u,
-                    h = u,
-                    d = u;
-                u.eachBefore(function(v) {
-                    v.x < f.x && (f = v), v.x > h.x && (h = v), v.depth > d.depth && (d = v)
-                });
-                var g = f === h ? 1 : e(f, h) / 2,
-                    p = g - f.x,
-                    m = t / (h.x + g + p),
-                    y = n / (d.depth || 1);
-                u.eachBefore(function(v) {
-                    v.x = (v.x + p) * m, v.y = v.depth * y
-                })
-            }
-            return u
-        }
-
-        function s(u) {
-            var c = u.children,
-                f = u.parent.children,
-                h = u.i ? f[u.i - 1] : null;
-            if (c) {
-                JW(u);
-                var d = (c[0].z + c[c.length - 1].z) / 2;
-                h ? (u.z = h.z + e(u._, h._), u.m = u.z - d) : u.z = d
-            } else h && (u.z = h.z + e(u._, h._));
-            u.parent.A = o(u, h, u.parent.A || f[0])
-        }
-
-        function a(u) {
-            u._.x = u.z + u.parent.m, u.m += u.parent.m
-        }
-
-        function o(u, c, f) {
-            if (c) {
-                for (var h = u, d = u, g = c, p = h.parent.children[0], m = h.m, y = d.m, v = g.m, b = p.m, x; g = Iy(g), h = Ly(h), g && h;) p = Ly(p), d = Iy(d), d.a = u, x = g.z + v - h.z - m + e(g._, h._), x > 0 && (KW(QW(g, u, f), u, x), m += x, y += x), v += g.m, m += h.m, b += p.m, y += d.m;
-                g && !Iy(d) && (d.t = g, d.m += v - y), h && !Ly(p) && (p.t = h, p.m += m - b, f = u)
+                var v = Math.sqrt(p),
+                    b = (h * h - u * u + i * p) / (2 * u * n * v),
+                    x = (h * h - u * u - i * p) / (2 * h * n * v),
+                    _ = Math.log(Math.sqrt(b * b + 1) - b),
+                    S = Math.log(Math.sqrt(x * x + 1) - x);
+                y = (S - _) / t, m = function(w) {
+                    var E = w * y,
+                        C = i$(_),
+                        k = u / (n * v) * (C * Yq(t * E + _) - Hq(_));
+                    return [o + k * d, l + k * g, u * C / i$(t * E + _)]
+                }
             }
-            return f
-        }
-
-        function l(u) {
-            u.x *= t, u.y = u.depth * n
+            return m.duration = y * 1e3 * t / Math.SQRT2, m
         }
-        return r.separation = function(u) {
-            return arguments.length ? (e = u, r) : e
-        }, r.size = function(u) {
-            return arguments.length ? (i = !1, t = +u[0], n = +u[1], r) : i ? null : [t, n]
-        }, r.nodeSize = function(u) {
-            return arguments.length ? (i = !0, t = +u[0], n = +u[1], r) : i ? [t, n] : null
+        return r.rho = function(s) {
+            var a = Math.max(.001, +s),
+                o = a * a,
+                l = o * o;
+            return e(a, o, l)
         }, r
-    }
-
-    function hm(e, t, n, i, r) {
-        for (var s = e.children, a, o = -1, l = s.length, u = e.value && (r - n) / e.value; ++o < l;) a = s[o], a.x0 = t, a.x1 = i, a.y0 = n, a.y1 = n += a.value * u
-    }
-    var HF = (1 + Math.sqrt(5)) / 2;
+    }(Math.SQRT2, 2, 4);
 
-    function YF(e, t, n, i, r, s) {
-        for (var a = [], o = t.children, l, u, c = 0, f = 0, h = o.length, d, g, p = t.value, m, y, v, b, x, _, S; c < h;) {
-            d = r - n, g = s - i;
-            do m = o[f++].value; while (!m && f < h);
-            for (y = v = m, _ = Math.max(g / d, d / g) / (p * e), S = m * m * _, x = Math.max(v / S, S / y); f < h; ++f) {
-                if (m += u = o[f].value, u < y && (y = u), u > v && (v = u), S = m * m * _, b = Math.max(v / S, S / y), b > x) {
-                    m -= u;
-                    break
-                }
-                x = b
+    function eN(e) {
+        return function(t, n) {
+            var i = e((t = pm(t)).h, (n = pm(n)).h),
+                r = tn(t.s, n.s),
+                s = tn(t.l, n.l),
+                a = tn(t.opacity, n.opacity);
+            return function(o) {
+                return t.h = i(o), t.s = r(o), t.l = s(o), t.opacity = a(o), t + ""
             }
-            a.push(l = {
-                value: m,
-                dice: d < g,
-                children: o.slice(c, f)
-            }), l.dice ? id(l, n, i, r, p ? i += g * m / p : s) : hm(l, n, i, p ? n += d * m / p : r, s), p -= m, c = f
         }
-        return a
     }
-    const XF = function e(t) {
-        function n(i, r, s, a, o) {
-            YF(t, i, r, s, a, o)
-        }
-        return n.ratio = function(i) {
-            return e((i = +i) > 1 ? i : 1)
-        }, n
-    }(HF);
-
-    function tq() {
-        var e = XF,
-            t = !1,
-            n = 1,
-            i = 1,
-            r = [0],
-            s = Ao,
-            a = Ao,
-            o = Ao,
-            l = Ao,
-            u = Ao;
-
-        function c(h) {
-            return h.x0 = h.y0 = 0, h.x1 = n, h.y1 = i, h.eachBefore(f), r = [0], t && h.eachBefore(qF), h
-        }
+    const Vq = eN(f1);
+    var Kq = eN(tn);
 
-        function f(h) {
-            var d = r[h.depth],
-                g = h.x0 + d,
-                p = h.y0 + d,
-                m = h.x1 - d,
-                y = h.y1 - d;
-            m < g && (g = m = (g + m) / 2), y < p && (p = y = (p + y) / 2), h.x0 = g, h.y0 = p, h.x1 = m, h.y1 = y, h.children && (d = r[h.depth + 1] = s(h) / 2, g += u(h) - d, p += a(h) - d, m -= o(h) - d, y -= l(h) - d, m < g && (g = m = (g + m) / 2), y < p && (p = y = (p + y) / 2), e(h, g, p, m, y))
+    function Jq(e, t) {
+        var n = tn((e = ym(e)).l, (t = ym(t)).l),
+            i = tn(e.a, t.a),
+            r = tn(e.b, t.b),
+            s = tn(e.opacity, t.opacity);
+        return function(a) {
+            return e.l = n(a), e.a = i(a), e.b = r(a), e.opacity = s(a), e + ""
         }
-        return c.round = function(h) {
-            return arguments.length ? (t = !!h, c) : t
-        }, c.size = function(h) {
-            return arguments.length ? (n = +h[0], i = +h[1], c) : [n, i]
-        }, c.tile = function(h) {
-            return arguments.length ? (e = UF(h), c) : e
-        }, c.padding = function(h) {
-            return arguments.length ? c.paddingInner(h).paddingOuter(h) : c.paddingInner()
-        }, c.paddingInner = function(h) {
-            return arguments.length ? (s = typeof h == "function" ? h : au(+h), c) : s
-        }, c.paddingOuter = function(h) {
-            return arguments.length ? c.paddingTop(h).paddingRight(h).paddingBottom(h).paddingLeft(h) : c.paddingTop()
-        }, c.paddingTop = function(h) {
-            return arguments.length ? (a = typeof h == "function" ? h : au(+h), c) : a
-        }, c.paddingRight = function(h) {
-            return arguments.length ? (o = typeof h == "function" ? h : au(+h), c) : o
-        }, c.paddingBottom = function(h) {
-            return arguments.length ? (l = typeof h == "function" ? h : au(+h), c) : l
-        }, c.paddingLeft = function(h) {
-            return arguments.length ? (u = typeof h == "function" ? h : au(+h), c) : u
-        }, c
     }
 
-    function nq(e, t, n, i, r) {
-        var s = e.children,
-            a, o = s.length,
-            l, u = new Array(o + 1);
-        for (u[0] = l = a = 0; a < o; ++a) u[a + 1] = l += s[a].value;
-        c(0, o, e.value, t, n, i, r);
-
-        function c(f, h, d, g, p, m, y) {
-            if (f >= h - 1) {
-                var v = s[f];
-                v.x0 = g, v.y0 = p, v.x1 = m, v.y1 = y;
-                return
-            }
-            for (var b = u[f], x = d / 2 + b, _ = f + 1, S = h - 1; _ < S;) {
-                var w = _ + S >>> 1;
-                u[w] < x ? _ = w + 1 : S = w
-            }
-            x - u[_ - 1] < u[_] - x && f + 1 < _ && --_;
-            var E = u[_] - b,
-                A = d - E;
-            if (m - g > y - p) {
-                var C = d ? (g * A + m * E) / d : m;
-                c(f, _, E, g, p, C, y), c(_, h, A, C, p, m, y)
-            } else {
-                var k = d ? (p * A + y * E) / d : y;
-                c(f, _, E, g, p, m, k), c(_, h, A, g, k, m, y)
+    function tN(e) {
+        return function(t, n) {
+            var i = e((t = vm(t)).h, (n = vm(n)).h),
+                r = tn(t.c, n.c),
+                s = tn(t.l, n.l),
+                a = tn(t.opacity, n.opacity);
+            return function(o) {
+                return t.h = i(o), t.c = r(o), t.l = s(o), t.opacity = a(o), t + ""
             }
         }
     }
+    const Qq = tN(f1);
+    var Zq = tN(tn);
 
-    function iq(e, t, n, i, r) {
-        (e.depth & 1 ? hm : id)(e, t, n, i, r)
-    }
-    const rq = function e(t) {
-        function n(i, r, s, a, o) {
-            if ((l = i._squarify) && l.ratio === t)
-                for (var l, u, c, f, h = -1, d, g = l.length, p = i.value; ++h < g;) {
-                    for (u = l[h], c = u.children, f = u.value = 0, d = c.length; f < d; ++f) u.value += c[f].value;
-                    u.dice ? id(u, r, s, a, p ? s += (o - s) * u.value / p : o) : hm(u, r, s, p ? r += (a - r) * u.value / p : a, o), p -= u.value
-                } else i._squarify = l = YF(t, i, r, s, a, o), l.ratio = t
-        }
-        return n.ratio = function(i) {
-            return e((i = +i) > 1 ? i : 1)
-        }, n
-    }(HF);
+    function nN(e) {
+        return function t(n) {
+            n = +n;
 
-    function ts(e, t) {
-        switch (arguments.length) {
-            case 0:
-                break;
-            case 1:
-                this.range(e);
-                break;
-            default:
-                this.range(t).domain(e);
-                break
-        }
-        return this
+            function i(r, s) {
+                var a = e((r = i2(r)).h, (s = i2(s)).h),
+                    o = tn(r.s, s.s),
+                    l = tn(r.l, s.l),
+                    u = tn(r.opacity, s.opacity);
+                return function(c) {
+                    return r.h = a(c), r.s = o(c), r.l = l(Math.pow(c, n)), r.opacity = u(c), r + ""
+                }
+            }
+            return i.gamma = t, i
+        }(1)
     }
+    const eH = nN(f1);
+    var tH = nN(tn);
 
-    function Ja(e, t) {
-        switch (arguments.length) {
-            case 0:
-                break;
-            case 1: {
-                typeof e == "function" ? this.interpolator(e) : this.range(e);
-                break
-            }
-            default: {
-                this.domain(e), typeof t == "function" ? this.interpolator(t) : this.range(t);
-                break
-            }
+    function Lw(e, t) {
+        t === void 0 && (t = e, e = bo);
+        for (var n = 0, i = t.length - 1, r = t[0], s = new Array(i < 0 ? 0 : i); n < i;) s[n] = e(r, r = t[++n]);
+        return function(a) {
+            var o = Math.max(0, Math.min(i - 1, Math.floor(a *= i)));
+            return s[o](a - o)
         }
-        return this
     }
-    const Lb = Symbol("implicit");
-
-    function dm() {
-        var e = new Lk,
-            t = [],
-            n = [],
-            i = Lb;
 
-        function r(s) {
-            let a = e.get(s);
-            if (a === void 0) {
-                if (i !== Lb) return i;
-                e.set(s, a = t.push(s) - 1)
-            }
-            return n[a % n.length]
-        }
-        return r.domain = function(s) {
-            if (!arguments.length) return t.slice();
-            t = [], e = new Lk;
-            for (const a of s) e.has(a) || e.set(a, t.push(a) - 1);
-            return r
-        }, r.range = function(s) {
-            return arguments.length ? (n = Array.from(s), r) : n.slice()
-        }, r.unknown = function(s) {
-            return arguments.length ? (i = s, r) : i
-        }, r.copy = function() {
-            return dm(t, n).unknown(i)
-        }, ts.apply(r, arguments), r
+    function nH(e, t) {
+        for (var n = new Array(t), i = 0; i < t; ++i) n[i] = e(i / (t - 1));
+        return n
     }
+    const iH = Object.freeze(Object.defineProperty({
+        __proto__: null,
+        interpolate: bo,
+        interpolateArray: Pq,
+        interpolateBasis: UD,
+        interpolateBasisClosed: WD,
+        interpolateCubehelix: eH,
+        interpolateCubehelixLong: tH,
+        interpolateDate: VD,
+        interpolateDiscrete: zq,
+        interpolateHcl: Qq,
+        interpolateHclLong: Zq,
+        interpolateHsl: Vq,
+        interpolateHslLong: Kq,
+        interpolateHue: Bq,
+        interpolateLab: Jq,
+        interpolateNumber: cr,
+        interpolateNumberArray: Pw,
+        interpolateObject: KD,
+        interpolateRgb: r2,
+        interpolateRgbBasis: Dq,
+        interpolateRgbBasisClosed: Nq,
+        interpolateRound: Rd,
+        interpolateString: JD,
+        interpolateTransformCss: Uq,
+        interpolateTransformSvg: Wq,
+        interpolateZoom: Xq,
+        piecewise: Lw,
+        quantize: nH
+    }, Symbol.toStringTag, {
+        value: "Module"
+    }));
 
-    function sq(e) {
+    function rH(e) {
         return function() {
             return e
         }
     }
 
-    function Ib(e) {
+    function o2(e) {
         return +e
     }
-    var IA = [0, 1];
+    var r$ = [0, 1];
 
-    function Vn(e) {
+    function ai(e) {
         return e
     }
 
-    function zb(e, t) {
+    function l2(e, t) {
         return (t -= e = +e) ? function(n) {
             return (n - e) / t
-        } : sq(isNaN(t) ? NaN : .5)
+        } : rH(isNaN(t) ? NaN : .5)
     }
 
-    function aq(e, t) {
+    function sH(e, t) {
         var n;
         return e > t && (n = e, e = t, t = n),
             function(i) {
                 return Math.max(e, Math.min(t, i))
             }
     }
 
-    function oq(e, t, n) {
+    function aH(e, t, n) {
         var i = e[0],
             r = e[1],
             s = t[0],
             a = t[1];
-        return r < i ? (i = zb(r, i), s = n(a, s)) : (i = zb(i, r), s = n(s, a)),
+        return r < i ? (i = l2(r, i), s = n(a, s)) : (i = l2(i, r), s = n(s, a)),
             function(o) {
                 return s(i(o))
             }
     }
 
-    function lq(e, t, n) {
+    function oH(e, t, n) {
         var i = Math.min(e.length, t.length) - 1,
             r = new Array(i),
             s = new Array(i),
             a = -1;
-        for (e[i] < e[0] && (e = e.slice().reverse(), t = t.slice().reverse()); ++a < i;) r[a] = zb(e[a], e[a + 1]), s[a] = n(t[a], t[a + 1]);
+        for (e[i] < e[0] && (e = e.slice().reverse(), t = t.slice().reverse()); ++a < i;) r[a] = l2(e[a], e[a + 1]), s[a] = n(t[a], t[a + 1]);
         return function(o) {
-            var l = Zh(e, o, 1, i) - 1;
+            var l = $d(e, o, 1, i) - 1;
             return s[l](r[l](o))
         }
     }
 
-    function rd(e, t) {
+    function Dd(e, t) {
         return t.domain(e.domain()).range(e.range()).interpolate(e.interpolate()).clamp(e.clamp()).unknown(e.unknown())
     }
 
-    function gm() {
-        var e = IA,
-            t = IA,
-            n = Ka,
-            i, r, s, a = Vn,
+    function h1() {
+        var e = r$,
+            t = r$,
+            n = bo,
+            i, r, s, a = ai,
             o, l, u;
 
         function c() {
             var h = Math.min(e.length, t.length);
-            return a !== Vn && (a = aq(e[0], e[h - 1])), o = h > 2 ? lq : oq, l = u = null, f
+            return a !== ai && (a = sH(e[0], e[h - 1])), o = h > 2 ? oH : aH, l = u = null, f
         }
 
         function f(h) {
             return h == null || isNaN(h = +h) ? s : (l || (l = o(e.map(i), t, n)))(i(a(h)))
         }
         return f.invert = function(h) {
-                return a(r((u || (u = o(t, e.map(i), Xi)))(h)))
+                return a(r((u || (u = o(t, e.map(i), cr)))(h)))
             }, f.domain = function(h) {
-                return arguments.length ? (e = Array.from(h, Ib), c()) : e.slice()
+                return arguments.length ? (e = Array.from(h, o2), c()) : e.slice()
             }, f.range = function(h) {
                 return arguments.length ? (t = Array.from(h), c()) : t.slice()
             }, f.rangeRound = function(h) {
-                return t = Array.from(h), n = Jh, c()
+                return t = Array.from(h), n = Rd, c()
             }, f.clamp = function(h) {
-                return arguments.length ? (a = h ? !0 : Vn, c()) : a !== Vn
+                return arguments.length ? (a = h ? !0 : ai, c()) : a !== ai
             }, f.interpolate = function(h) {
                 return arguments.length ? (n = h, c()) : n
             }, f.unknown = function(h) {
                 return arguments.length ? (s = h, f) : s
             },
             function(h, d) {
                 return i = h, r = d, c()
             }
     }
 
-    function VF() {
-        return gm()(Vn, Vn)
+    function iN() {
+        return h1()(ai, ai)
     }
 
-    function KF(e, t, n, i) {
-        var r = Oa(e, t, n),
+    function rN(e, t, n, i) {
+        var r = Qa(e, t, n),
             s;
-        switch (i = Qo(i ?? ",f"), i.type) {
+        switch (i = _l(i ?? ",f"), i.type) {
             case "s": {
                 var a = Math.max(Math.abs(e), Math.abs(t));
-                return i.precision == null && !isNaN(s = QO(r, a)) && (i.precision = s), Fx(i, a)
+                return i.precision == null && !isNaN(s = MF(r, a)) && (i.precision = s), k_(i, a)
             }
             case "":
             case "e":
             case "g":
             case "p":
             case "r": {
-                i.precision == null && !isNaN(s = ZO(r, Math.max(Math.abs(e), Math.abs(t)))) && (i.precision = s - (i.type === "e"));
+                i.precision == null && !isNaN(s = OF(r, Math.max(Math.abs(e), Math.abs(t)))) && (i.precision = s - (i.type === "e"));
                 break
             }
             case "f":
             case "%": {
-                i.precision == null && !isNaN(s = JO(r)) && (i.precision = s - (i.type === "%") * 2);
+                i.precision == null && !isNaN(s = TF(r)) && (i.precision = s - (i.type === "%") * 2);
                 break
             }
         }
-        return lm(i)
+        return B0(i)
     }
 
-    function Cl(e) {
+    function Vl(e) {
         var t = e.domain;
         return e.ticks = function(n) {
             var i = t();
-            return lb(i[0], i[i.length - 1], n ?? 10)
+            return Bb(i[0], i[i.length - 1], n ?? 10)
         }, e.tickFormat = function(n, i) {
             var r = t();
-            return KF(r[0], r[r.length - 1], n ?? 10, i)
+            return rN(r[0], r[r.length - 1], n ?? 10, i)
         }, e.nice = function(n) {
             n == null && (n = 10);
             var i = t(),
                 r = 0,
                 s = i.length - 1,
                 a = i[r],
                 o = i[s],
                 l, u, c = 10;
             for (o < a && (u = a, a = o, o = u, u = r, r = s, s = u); c-- > 0;) {
-                if (u = ub(a, o, n), u === l) return i[r] = a, i[s] = o, t(i);
+                if (u = jb(a, o, n), u === l) return i[r] = a, i[s] = o, t(i);
                 if (u > 0) a = Math.floor(a / u) * u, o = Math.ceil(o / u) * u;
                 else if (u < 0) a = Math.ceil(a * u) / u, o = Math.floor(o * u) / u;
                 else break;
                 l = u
             }
             return e
         }, e
     }
 
-    function JF() {
-        var e = VF();
+    function sN() {
+        var e = iN();
         return e.copy = function() {
-            return rd(e, JF())
-        }, ts.apply(e, arguments), Cl(e)
+            return Dd(e, sN())
+        }, ps.apply(e, arguments), Vl(e)
     }
 
-    function QF(e) {
+    function aN(e) {
         var t;
 
         function n(i) {
             return i == null || isNaN(i = +i) ? t : i
         }
         return n.invert = n, n.domain = n.range = function(i) {
-            return arguments.length ? (e = Array.from(i, Ib), n) : e.slice()
+            return arguments.length ? (e = Array.from(i, o2), n) : e.slice()
         }, n.unknown = function(i) {
             return arguments.length ? (t = i, n) : t
         }, n.copy = function() {
-            return QF(e).unknown(t)
-        }, e = arguments.length ? Array.from(e, Ib) : [0, 1], Cl(n)
+            return aN(e).unknown(t)
+        }, e = arguments.length ? Array.from(e, o2) : [0, 1], Vl(n)
     }
 
-    function ZF(e, t) {
+    function oN(e, t) {
         e = e.slice();
         var n = 0,
             i = e.length - 1,
             r = e[n],
             s = e[i],
             a;
         return s < r && (a = n, n = i, i = a, a = r, r = s, s = a), e[n] = t.floor(r), e[i] = t.ceil(s), e
     }
 
-    function zA(e) {
+    function s$(e) {
         return Math.log(e)
     }
 
-    function BA(e) {
+    function a$(e) {
         return Math.exp(e)
     }
 
-    function uq(e) {
+    function lH(e) {
         return -Math.log(-e)
     }
 
-    function cq(e) {
+    function uH(e) {
         return -Math.exp(-e)
     }
 
-    function fq(e) {
+    function cH(e) {
         return isFinite(e) ? +("1e" + e) : e < 0 ? 0 : e
     }
 
-    function hq(e) {
-        return e === 10 ? fq : e === Math.E ? Math.exp : t => Math.pow(e, t)
+    function fH(e) {
+        return e === 10 ? cH : e === Math.E ? Math.exp : t => Math.pow(e, t)
     }
 
-    function dq(e) {
+    function hH(e) {
         return e === Math.E ? Math.log : e === 10 && Math.log10 || e === 2 && Math.log2 || (e = Math.log(e), t => Math.log(t) / e)
     }
 
-    function jA(e) {
+    function o$(e) {
         return (t, n) => -e(-t, n)
     }
 
-    function jx(e) {
-        const t = e(zA, BA),
+    function Iw(e) {
+        const t = e(s$, a$),
             n = t.domain;
         let i = 10,
             r, s;
 
         function a() {
-            return r = dq(i), s = hq(i), n()[0] < 0 ? (r = jA(r), s = jA(s), e(uq, cq)) : e(zA, BA), t
+            return r = hH(i), s = fH(i), n()[0] < 0 ? (r = o$(r), s = o$(s), e(lH, uH)) : e(s$, a$), t
         }
         return t.base = function(o) {
             return arguments.length ? (i = +o, a()) : i
         }, t.domain = function(o) {
             return arguments.length ? (n(o), a()) : n()
         }, t.ticks = o => {
             const l = n();
@@ -13607,144 +10707,144 @@
                             }
                 } else
                     for (; h <= d; ++h)
                         for (g = i - 1; g >= 1; --g)
                             if (p = h > 0 ? g / s(-h) : g * s(h), !(p < u)) {
                                 if (p > c) break;
                                 y.push(p)
-                            } y.length * 2 < m && (y = lb(u, c, m))
-            } else y = lb(h, d, Math.min(d - h, m)).map(s);
+                            } y.length * 2 < m && (y = Bb(u, c, m))
+            } else y = Bb(h, d, Math.min(d - h, m)).map(s);
             return f ? y.reverse() : y
         }, t.tickFormat = (o, l) => {
-            if (o == null && (o = 10), l == null && (l = i === 10 ? "s" : ","), typeof l != "function" && (!(i % 1) && (l = Qo(l)).precision == null && (l.trim = !0), l = lm(l)), o === 1 / 0) return l;
+            if (o == null && (o = 10), l == null && (l = i === 10 ? "s" : ","), typeof l != "function" && (!(i % 1) && (l = _l(l)).precision == null && (l.trim = !0), l = B0(l)), o === 1 / 0) return l;
             const u = Math.max(1, i * o / t.ticks().length);
             return c => {
                 let f = c / s(Math.round(r(c)));
                 return f * i < i - .5 && (f *= i), f <= u ? l(c) : ""
             }
-        }, t.nice = () => n(ZF(n(), {
+        }, t.nice = () => n(oN(n(), {
             floor: o => s(Math.floor(r(o))),
             ceil: o => s(Math.ceil(r(o)))
         })), t
     }
 
-    function eR() {
-        const e = jx(gm()).domain([1, 10]);
-        return e.copy = () => rd(e, eR()).base(e.base()), ts.apply(e, arguments), e
+    function lN() {
+        const e = Iw(h1()).domain([1, 10]);
+        return e.copy = () => Dd(e, lN()).base(e.base()), ps.apply(e, arguments), e
     }
 
-    function UA(e) {
+    function l$(e) {
         return function(t) {
             return Math.sign(t) * Math.log1p(Math.abs(t / e))
         }
     }
 
-    function GA(e) {
+    function u$(e) {
         return function(t) {
             return Math.sign(t) * Math.expm1(Math.abs(t)) * e
         }
     }
 
-    function Ux(e) {
+    function zw(e) {
         var t = 1,
-            n = e(UA(t), GA(t));
+            n = e(l$(t), u$(t));
         return n.constant = function(i) {
-            return arguments.length ? e(UA(t = +i), GA(t)) : t
-        }, Cl(n)
+            return arguments.length ? e(l$(t = +i), u$(t)) : t
+        }, Vl(n)
     }
 
-    function tR() {
-        var e = Ux(gm());
+    function uN() {
+        var e = zw(h1());
         return e.copy = function() {
-            return rd(e, tR()).constant(e.constant())
-        }, ts.apply(e, arguments)
+            return Dd(e, uN()).constant(e.constant())
+        }, ps.apply(e, arguments)
     }
 
-    function WA(e) {
+    function c$(e) {
         return function(t) {
             return t < 0 ? -Math.pow(-t, e) : Math.pow(t, e)
         }
     }
 
-    function gq(e) {
+    function dH(e) {
         return e < 0 ? -Math.sqrt(-e) : Math.sqrt(e)
     }
 
-    function pq(e) {
+    function gH(e) {
         return e < 0 ? -e * e : e * e
     }
 
-    function Gx(e) {
-        var t = e(Vn, Vn),
+    function Bw(e) {
+        var t = e(ai, ai),
             n = 1;
 
         function i() {
-            return n === 1 ? e(Vn, Vn) : n === .5 ? e(gq, pq) : e(WA(n), WA(1 / n))
+            return n === 1 ? e(ai, ai) : n === .5 ? e(dH, gH) : e(c$(n), c$(1 / n))
         }
         return t.exponent = function(r) {
             return arguments.length ? (n = +r, i()) : n
-        }, Cl(t)
+        }, Vl(t)
     }
 
-    function Wx() {
-        var e = Gx(gm());
+    function jw() {
+        var e = Bw(h1());
         return e.copy = function() {
-            return rd(e, Wx()).exponent(e.exponent())
-        }, ts.apply(e, arguments), e
+            return Dd(e, jw()).exponent(e.exponent())
+        }, ps.apply(e, arguments), e
     }
 
-    function mq() {
-        return Wx.apply(null, arguments).exponent(.5)
+    function pH() {
+        return jw.apply(null, arguments).exponent(.5)
     }
 
-    function nR() {
+    function cN() {
         var e = [],
             t = [],
             n = [],
             i;
 
         function r() {
             var a = 0,
                 o = Math.max(1, t.length);
-            for (n = new Array(o - 1); ++a < o;) n[a - 1] = IO(e, a / o);
+            for (n = new Array(o - 1); ++a < o;) n[a - 1] = SF(e, a / o);
             return s
         }
 
         function s(a) {
-            return a == null || isNaN(a = +a) ? i : t[Zh(n, a)]
+            return a == null || isNaN(a = +a) ? i : t[$d(n, a)]
         }
         return s.invertExtent = function(a) {
             var o = t.indexOf(a);
             return o < 0 ? [NaN, NaN] : [o > 0 ? n[o - 1] : e[0], o < n.length ? n[o] : e[e.length - 1]]
         }, s.domain = function(a) {
             if (!arguments.length) return e.slice();
             e = [];
             for (let o of a) o != null && !isNaN(o = +o) && e.push(o);
-            return e.sort(Ts), r()
+            return e.sort(Hs), r()
         }, s.range = function(a) {
             return arguments.length ? (t = Array.from(a), r()) : t.slice()
         }, s.unknown = function(a) {
             return arguments.length ? (i = a, s) : i
         }, s.quantiles = function() {
             return n.slice()
         }, s.copy = function() {
-            return nR().domain(e).range(t).unknown(i)
-        }, ts.apply(s, arguments)
+            return cN().domain(e).range(t).unknown(i)
+        }, ps.apply(s, arguments)
     }
 
-    function iR() {
+    function fN() {
         var e = 0,
             t = 1,
             n = 1,
             i = [.5],
             r = [0, 1],
             s;
 
         function a(l) {
-            return l != null && l <= l ? r[Zh(i, l, 0, n)] : s
+            return l != null && l <= l ? r[$d(i, l, 0, n)] : s
         }
 
         function o() {
             var l = -1;
             for (i = new Array(n); ++l < n;) i[l] = ((l + 1) * t - (l - n) * e) / (n + 1);
             return a
         }
@@ -13756,14349 +10856,9625 @@
             var u = r.indexOf(l);
             return u < 0 ? [NaN, NaN] : u < 1 ? [e, i[0]] : u >= n ? [i[n - 1], t] : [i[u - 1], i[u]]
         }, a.unknown = function(l) {
             return arguments.length && (s = l), a
         }, a.thresholds = function() {
             return i.slice()
         }, a.copy = function() {
-            return iR().domain([e, t]).range(r).unknown(s)
-        }, ts.apply(Cl(a), arguments)
+            return fN().domain([e, t]).range(r).unknown(s)
+        }, ps.apply(Vl(a), arguments)
     }
 
-    function rR() {
+    function hN() {
         var e = [.5],
             t = [0, 1],
             n, i = 1;
 
         function r(s) {
-            return s != null && s <= s ? t[Zh(e, s, 0, i)] : n
+            return s != null && s <= s ? t[$d(e, s, 0, i)] : n
         }
         return r.domain = function(s) {
             return arguments.length ? (e = Array.from(s), i = Math.min(e.length, t.length - 1), r) : e.slice()
         }, r.range = function(s) {
             return arguments.length ? (t = Array.from(s), i = Math.min(e.length, t.length - 1), r) : t.slice()
         }, r.invertExtent = function(s) {
             var a = t.indexOf(s);
             return [e[a - 1], e[a]]
         }, r.unknown = function(s) {
             return arguments.length ? (n = s, r) : n
         }, r.copy = function() {
-            return rR().domain(e).range(t).unknown(n)
-        }, ts.apply(r, arguments)
-    }
-    const zy = new Date,
-        By = new Date;
-
-    function Dt(e, t, n, i) {
-        function r(s) {
-            return e(s = arguments.length === 0 ? new Date : new Date(+s)), s
-        }
-        return r.floor = s => (e(s = new Date(+s)), s), r.ceil = s => (e(s = new Date(s - 1)), t(s, 1), e(s), s), r.round = s => {
-            const a = r(s),
-                o = r.ceil(s);
-            return s - a < o - s ? a : o
-        }, r.offset = (s, a) => (t(s = new Date(+s), a == null ? 1 : Math.floor(a)), s), r.range = (s, a, o) => {
-            const l = [];
-            if (s = r.ceil(s), o = o == null ? 1 : Math.floor(o), !(s < a) || !(o > 0)) return l;
-            let u;
-            do l.push(u = new Date(+s)), t(s, o), e(s); while (u < s && s < a);
-            return l
-        }, r.filter = s => Dt(a => {
-            if (a >= a)
-                for (; e(a), !s(a);) a.setTime(a - 1)
-        }, (a, o) => {
-            if (a >= a)
-                if (o < 0)
-                    for (; ++o <= 0;)
-                        for (; t(a, -1), !s(a););
-                else
-                    for (; --o >= 0;)
-                        for (; t(a, 1), !s(a););
-        }), n && (r.count = (s, a) => (zy.setTime(+s), By.setTime(+a), e(zy), e(By), Math.floor(n(zy, By))), r.every = s => (s = Math.floor(s), !isFinite(s) || !(s > 0) ? null : s > 1 ? r.filter(i ? a => i(a) % s === 0 : a => r.count(0, a) % s === 0) : r)), r
+            return hN().domain(e).range(t).unknown(n)
+        }, ps.apply(r, arguments)
     }
-    const Lu = Dt(() => {}, (e, t) => {
-        e.setTime(+e + t)
-    }, (e, t) => t - e);
-    Lu.every = e => (e = Math.floor(e), !isFinite(e) || !(e > 0) ? null : e > 1 ? Dt(t => {
-        t.setTime(Math.floor(t / e) * e)
-    }, (t, n) => {
-        t.setTime(+t + n * e)
-    }, (t, n) => (n - t) / e) : Lu);
-    Lu.range;
-    const Es = 1e3,
-        Ai = Es * 60,
-        Cs = Ai * 60,
-        Is = Cs * 24,
-        qx = Is * 7,
-        qA = Is * 30,
-        jy = Is * 365,
-        ks = Dt(e => {
-            e.setTime(e - e.getMilliseconds())
-        }, (e, t) => {
-            e.setTime(+e + t * Es)
-        }, (e, t) => (t - e) / Es, e => e.getUTCSeconds());
-    ks.range;
-    const pm = Dt(e => {
-        e.setTime(e - e.getMilliseconds() - e.getSeconds() * Es)
-    }, (e, t) => {
-        e.setTime(+e + t * Ai)
-    }, (e, t) => (t - e) / Ai, e => e.getMinutes());
-    pm.range;
-    const mm = Dt(e => {
-        e.setUTCSeconds(0, 0)
-    }, (e, t) => {
-        e.setTime(+e + t * Ai)
-    }, (e, t) => (t - e) / Ai, e => e.getUTCMinutes());
-    mm.range;
-    const ym = Dt(e => {
-        e.setTime(e - e.getMilliseconds() - e.getSeconds() * Es - e.getMinutes() * Ai)
-    }, (e, t) => {
-        e.setTime(+e + t * Cs)
-    }, (e, t) => (t - e) / Cs, e => e.getHours());
-    ym.range;
-    const vm = Dt(e => {
-        e.setUTCMinutes(0, 0, 0)
-    }, (e, t) => {
-        e.setTime(+e + t * Cs)
-    }, (e, t) => (t - e) / Cs, e => e.getUTCHours());
-    vm.range;
-    const Os = Dt(e => e.setHours(0, 0, 0, 0), (e, t) => e.setDate(e.getDate() + t), (e, t) => (t - e - (t.getTimezoneOffset() - e.getTimezoneOffset()) * Ai) / Is, e => e.getDate() - 1);
-    Os.range;
-    const Sa = Dt(e => {
-        e.setUTCHours(0, 0, 0, 0)
-    }, (e, t) => {
-        e.setUTCDate(e.getUTCDate() + t)
-    }, (e, t) => (t - e) / Is, e => e.getUTCDate() - 1);
-    Sa.range;
-    const sR = Dt(e => {
-        e.setUTCHours(0, 0, 0, 0)
-    }, (e, t) => {
-        e.setUTCDate(e.getUTCDate() + t)
-    }, (e, t) => (t - e) / Is, e => Math.floor(e / Is));
-    sR.range;
 
-    function kl(e) {
-        return Dt(t => {
-            t.setDate(t.getDate() - (t.getDay() + 7 - e) % 7), t.setHours(0, 0, 0, 0)
-        }, (t, n) => {
-            t.setDate(t.getDate() + n * 7)
-        }, (t, n) => (n - t - (n.getTimezoneOffset() - t.getTimezoneOffset()) * Ai) / qx)
+    function mH(e) {
+        return new Date(e)
     }
-    const mc = kl(0),
-        t0 = kl(1),
-        yq = kl(2),
-        vq = kl(3),
-        Iu = kl(4),
-        bq = kl(5),
-        xq = kl(6);
-    mc.range;
-    t0.range;
-    yq.range;
-    vq.range;
-    Iu.range;
-    bq.range;
-    xq.range;
 
-    function Al(e) {
-        return Dt(t => {
-            t.setUTCDate(t.getUTCDate() - (t.getUTCDay() + 7 - e) % 7), t.setUTCHours(0, 0, 0, 0)
-        }, (t, n) => {
-            t.setUTCDate(t.getUTCDate() + n * 7)
-        }, (t, n) => (n - t) / qx)
+    function yH(e) {
+        return e instanceof Date ? +e : +new Date(+e)
     }
-    const yc = Al(0),
-        n0 = Al(1),
-        _q = Al(2),
-        wq = Al(3),
-        zu = Al(4),
-        Sq = Al(5),
-        Eq = Al(6);
-    yc.range;
-    n0.range;
-    _q.range;
-    wq.range;
-    zu.range;
-    Sq.range;
-    Eq.range;
-    const xh = Dt(e => {
-        e.setDate(1), e.setHours(0, 0, 0, 0)
-    }, (e, t) => {
-        e.setMonth(e.getMonth() + t)
-    }, (e, t) => t.getMonth() - e.getMonth() + (t.getFullYear() - e.getFullYear()) * 12, e => e.getMonth());
-    xh.range;
-    const _h = Dt(e => {
-        e.setUTCDate(1), e.setUTCHours(0, 0, 0, 0)
-    }, (e, t) => {
-        e.setUTCMonth(e.getUTCMonth() + t)
-    }, (e, t) => t.getUTCMonth() - e.getUTCMonth() + (t.getUTCFullYear() - e.getUTCFullYear()) * 12, e => e.getUTCMonth());
-    _h.range;
-    const Wr = Dt(e => {
-        e.setMonth(0, 1), e.setHours(0, 0, 0, 0)
-    }, (e, t) => {
-        e.setFullYear(e.getFullYear() + t)
-    }, (e, t) => t.getFullYear() - e.getFullYear(), e => e.getFullYear());
-    Wr.every = e => !isFinite(e = Math.floor(e)) || !(e > 0) ? null : Dt(t => {
-        t.setFullYear(Math.floor(t.getFullYear() / e) * e), t.setMonth(0, 1), t.setHours(0, 0, 0, 0)
-    }, (t, n) => {
-        t.setFullYear(t.getFullYear() + n * e)
-    });
-    Wr.range;
-    const qr = Dt(e => {
-        e.setUTCMonth(0, 1), e.setUTCHours(0, 0, 0, 0)
-    }, (e, t) => {
-        e.setUTCFullYear(e.getUTCFullYear() + t)
-    }, (e, t) => t.getUTCFullYear() - e.getUTCFullYear(), e => e.getUTCFullYear());
-    qr.every = e => !isFinite(e = Math.floor(e)) || !(e > 0) ? null : Dt(t => {
-        t.setUTCFullYear(Math.floor(t.getUTCFullYear() / e) * e), t.setUTCMonth(0, 1), t.setUTCHours(0, 0, 0, 0)
-    }, (t, n) => {
-        t.setUTCFullYear(t.getUTCFullYear() + n * e)
-    });
-    qr.range;
 
-    function aR(e, t, n, i, r, s) {
-        const a = [
-            [ks, 1, Es],
-            [ks, 5, 5 * Es],
-            [ks, 15, 15 * Es],
-            [ks, 30, 30 * Es],
-            [s, 1, Ai],
-            [s, 5, 5 * Ai],
-            [s, 15, 15 * Ai],
-            [s, 30, 30 * Ai],
-            [r, 1, Cs],
-            [r, 3, 3 * Cs],
-            [r, 6, 6 * Cs],
-            [r, 12, 12 * Cs],
-            [i, 1, Is],
-            [i, 2, 2 * Is],
-            [n, 1, qx],
-            [t, 1, qA],
-            [t, 3, 3 * qA],
-            [e, 1, jy]
-        ];
+    function Gw(e, t, n, i, r, s, a, o, l, u) {
+        var c = iN(),
+            f = c.invert,
+            h = c.domain,
+            d = u(".%L"),
+            g = u(":%S"),
+            p = u("%I:%M"),
+            m = u("%I %p"),
+            y = u("%a %d"),
+            v = u("%b %d"),
+            b = u("%B"),
+            x = u("%Y");
 
-        function o(u, c, f) {
-            const h = c < u;
-            h && ([u, c] = [c, u]);
-            const d = f && typeof f.range == "function" ? f : l(u, c, f),
-                g = d ? d.range(u, +c + 1) : [];
-            return h ? g.reverse() : g
+        function _(S) {
+            return (l(S) < S ? d : o(S) < S ? g : a(S) < S ? p : s(S) < S ? m : i(S) < S ? r(S) < S ? y : v : n(S) < S ? b : x)(S)
         }
+        return c.invert = function(S) {
+            return new Date(f(S))
+        }, c.domain = function(S) {
+            return arguments.length ? h(Array.from(S, yH)) : h().map(mH)
+        }, c.ticks = function(S) {
+            var w = h();
+            return e(w[0], w[w.length - 1], S ?? 10)
+        }, c.tickFormat = function(S, w) {
+            return w == null ? _ : u(w)
+        }, c.nice = function(S) {
+            var w = h();
+            return (!S || typeof S.range != "function") && (S = t(w[0], w[w.length - 1], S ?? 10)), S ? h(oN(w, S)) : c
+        }, c.copy = function() {
+            return Dd(c, Gw(e, t, n, i, r, s, a, o, l, u))
+        }, c
+    }
 
-        function l(u, c, f) {
-            const h = Math.abs(c - u) / f,
-                d = Qh(([, , m]) => m).right(a, h);
-            if (d === a.length) return e.every(Oa(u / jy, c / jy, f));
-            if (d === 0) return Lu.every(Math.max(Oa(u, c, f), 1));
-            const [g, p] = a[h / a[d - 1][2] < a[d][2] / h ? d - 1 : d];
-            return g.every(p)
-        }
-        return [o, l]
+    function vH() {
+        return ps.apply(Gw(Ej, kj, as, Wh, Wc, Ys, U0, j0, Gs, M_).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments)
     }
-    const [Cq, kq] = aR(qr, _h, yc, sR, vm, mm), [Aq, $q] = aR(Wr, xh, mc, Os, ym, pm);
 
-    function Uy(e) {
-        if (0 <= e.y && e.y < 100) {
-            var t = new Date(-1, e.m, e.d, e.H, e.M, e.S, e.L);
-            return t.setFullYear(e.y), t
-        }
-        return new Date(e.y, e.m, e.d, e.H, e.M, e.S, e.L)
+    function bH() {
+        return ps.apply(Gw(wj, Sj, os, qh, qc, Wa, W0, G0, Gs, O_).domain([Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2)]), arguments)
     }
 
-    function Gy(e) {
-        if (0 <= e.y && e.y < 100) {
-            var t = new Date(Date.UTC(-1, e.m, e.d, e.H, e.M, e.S, e.L));
-            return t.setUTCFullYear(e.y), t
+    function d1() {
+        var e = 0,
+            t = 1,
+            n, i, r, s, a = ai,
+            o = !1,
+            l;
+
+        function u(f) {
+            return f == null || isNaN(f = +f) ? l : a(r === 0 ? .5 : (f = (s(f) - n) * r, o ? Math.max(0, Math.min(1, f)) : f))
         }
-        return new Date(Date.UTC(e.y, e.m, e.d, e.H, e.M, e.S, e.L))
-    }
+        u.domain = function(f) {
+            return arguments.length ? ([e, t] = f, n = s(e = +e), i = s(t = +t), r = n === i ? 0 : 1 / (i - n), u) : [e, t]
+        }, u.clamp = function(f) {
+            return arguments.length ? (o = !!f, u) : o
+        }, u.interpolator = function(f) {
+            return arguments.length ? (a = f, u) : a
+        };
 
-    function Xc(e, t, n) {
-        return {
-            y: e,
-            m: t,
-            d: n,
-            H: 0,
-            M: 0,
-            S: 0,
-            L: 0
+        function c(f) {
+            return function(h) {
+                var d, g;
+                return arguments.length ? ([d, g] = h, a = f(d, g), u) : [a(0), a(1)]
+            }
         }
+        return u.range = c(bo), u.rangeRound = c(Rd), u.unknown = function(f) {
+                return arguments.length ? (l = f, u) : l
+            },
+            function(f) {
+                return s = f, n = f(e), i = f(t), r = n === i ? 0 : 1 / (i - n), u
+            }
     }
 
-    function oR(e) {
-        var t = e.dateTime,
-            n = e.date,
-            i = e.time,
-            r = e.periods,
-            s = e.days,
-            a = e.shortDays,
-            o = e.months,
-            l = e.shortMonths,
-            u = Vc(r),
-            c = Kc(r),
-            f = Vc(s),
-            h = Kc(s),
-            d = Vc(a),
-            g = Kc(a),
-            p = Vc(o),
-            m = Kc(o),
-            y = Vc(l),
-            v = Kc(l),
-            b = {
-                a: N,
-                A: P,
-                b: z,
-                B: I,
-                c: null,
-                d: JA,
-                e: JA,
-                f: Jq,
-                g: oH,
-                G: uH,
-                H: Xq,
-                I: Vq,
-                j: Kq,
-                L: lR,
-                m: Qq,
-                M: Zq,
-                p: Q,
-                q: oe,
-                Q: e$,
-                s: t$,
-                S: eH,
-                u: tH,
-                U: nH,
-                V: iH,
-                w: rH,
-                W: sH,
-                x: null,
-                X: null,
-                y: aH,
-                Y: lH,
-                Z: cH,
-                "%": ZA
-            },
-            x = {
-                a: Se,
-                A: ye,
-                b: Pe,
-                B: xt,
-                c: null,
-                d: QA,
-                e: QA,
-                f: gH,
-                g: EH,
-                G: kH,
-                H: fH,
-                I: hH,
-                j: dH,
-                L: cR,
-                m: pH,
-                M: mH,
-                p: rn,
-                q: Un,
-                Q: e$,
-                s: t$,
-                S: yH,
-                u: vH,
-                U: bH,
-                V: xH,
-                w: _H,
-                W: wH,
-                x: null,
-                X: null,
-                y: SH,
-                Y: CH,
-                Z: AH,
-                "%": ZA
-            },
-            _ = {
-                a: C,
-                A: k,
-                b: R,
-                B: $,
-                c: T,
-                d: VA,
-                e: VA,
-                f: Wq,
-                g: XA,
-                G: YA,
-                H: KA,
-                I: KA,
-                j: Bq,
-                L: Gq,
-                m: zq,
-                M: jq,
-                p: A,
-                q: Iq,
-                Q: Hq,
-                s: Yq,
-                S: Uq,
-                u: Rq,
-                U: Dq,
-                V: Nq,
-                w: Fq,
-                W: Pq,
-                x: M,
-                X: F,
-                y: XA,
-                Y: YA,
-                Z: Lq,
-                "%": qq
-            };
-        b.x = S(n, b), b.X = S(i, b), b.c = S(t, b), x.x = S(n, x), x.X = S(i, x), x.c = S(t, x);
+    function xo(e, t) {
+        return t.domain(e.domain()).interpolator(e.interpolator()).clamp(e.clamp()).unknown(e.unknown())
+    }
 
-        function S(Y, ue) {
-            return function(be) {
-                var q = [],
-                    ze = -1,
-                    fe = 0,
-                    Be = Y.length,
-                    Sn, co, YC;
-                for (be instanceof Date || (be = new Date(+be)); ++ze < Be;) Y.charCodeAt(ze) === 37 && (q.push(Y.slice(fe, ze)), (co = HA[Sn = Y.charAt(++ze)]) != null ? Sn = Y.charAt(++ze) : co = Sn === "e" ? " " : "0", (YC = ue[Sn]) && (Sn = YC(be, co)), q.push(Sn), fe = ze + 1);
-                return q.push(Y.slice(fe, ze)), q.join("")
-            }
-        }
+    function Uw() {
+        var e = Vl(d1()(ai));
+        return e.copy = function() {
+            return xo(e, Uw())
+        }, yo.apply(e, arguments)
+    }
 
-        function w(Y, ue) {
-            return function(be) {
-                var q = Xc(1900, void 0, 1),
-                    ze = E(q, Y, be += "", 0),
-                    fe, Be;
-                if (ze != be.length) return null;
-                if ("Q" in q) return new Date(q.Q);
-                if ("s" in q) return new Date(q.s * 1e3 + ("L" in q ? q.L : 0));
-                if (ue && !("Z" in q) && (q.Z = 0), "p" in q && (q.H = q.H % 12 + q.p * 12), q.m === void 0 && (q.m = "q" in q ? q.q : 0), "V" in q) {
-                    if (q.V < 1 || q.V > 53) return null;
-                    "w" in q || (q.w = 1), "Z" in q ? (fe = Gy(Xc(q.y, 0, 1)), Be = fe.getUTCDay(), fe = Be > 4 || Be === 0 ? n0.ceil(fe) : n0(fe), fe = Sa.offset(fe, (q.V - 1) * 7), q.y = fe.getUTCFullYear(), q.m = fe.getUTCMonth(), q.d = fe.getUTCDate() + (q.w + 6) % 7) : (fe = Uy(Xc(q.y, 0, 1)), Be = fe.getDay(), fe = Be > 4 || Be === 0 ? t0.ceil(fe) : t0(fe), fe = Os.offset(fe, (q.V - 1) * 7), q.y = fe.getFullYear(), q.m = fe.getMonth(), q.d = fe.getDate() + (q.w + 6) % 7)
-                } else("W" in q || "U" in q) && ("w" in q || (q.w = "u" in q ? q.u % 7 : "W" in q ? 1 : 0), Be = "Z" in q ? Gy(Xc(q.y, 0, 1)).getUTCDay() : Uy(Xc(q.y, 0, 1)).getDay(), q.m = 0, q.d = "W" in q ? (q.w + 6) % 7 + q.W * 7 - (Be + 5) % 7 : q.w + q.U * 7 - (Be + 6) % 7);
-                return "Z" in q ? (q.H += q.Z / 100 | 0, q.M += q.Z % 100, Gy(q)) : Uy(q)
-            }
-        }
+    function dN() {
+        var e = Iw(d1()).domain([1, 10]);
+        return e.copy = function() {
+            return xo(e, dN()).base(e.base())
+        }, yo.apply(e, arguments)
+    }
 
-        function E(Y, ue, be, q) {
-            for (var ze = 0, fe = ue.length, Be = be.length, Sn, co; ze < fe;) {
-                if (q >= Be) return -1;
-                if (Sn = ue.charCodeAt(ze++), Sn === 37) {
-                    if (Sn = ue.charAt(ze++), co = _[Sn in HA ? ue.charAt(ze++) : Sn], !co || (q = co(Y, be, q)) < 0) return -1
-                } else if (Sn != be.charCodeAt(q++)) return -1
-            }
-            return q
-        }
+    function gN() {
+        var e = zw(d1());
+        return e.copy = function() {
+            return xo(e, gN()).constant(e.constant())
+        }, yo.apply(e, arguments)
+    }
 
-        function A(Y, ue, be) {
-            var q = u.exec(ue.slice(be));
-            return q ? (Y.p = c.get(q[0].toLowerCase()), be + q[0].length) : -1
-        }
+    function Ww() {
+        var e = Bw(d1());
+        return e.copy = function() {
+            return xo(e, Ww()).exponent(e.exponent())
+        }, yo.apply(e, arguments)
+    }
 
-        function C(Y, ue, be) {
-            var q = d.exec(ue.slice(be));
-            return q ? (Y.w = g.get(q[0].toLowerCase()), be + q[0].length) : -1
-        }
+    function xH() {
+        return Ww.apply(null, arguments).exponent(.5)
+    }
 
-        function k(Y, ue, be) {
-            var q = f.exec(ue.slice(be));
-            return q ? (Y.w = h.get(q[0].toLowerCase()), be + q[0].length) : -1
-        }
+    function g1() {
+        var e = 0,
+            t = .5,
+            n = 1,
+            i = 1,
+            r, s, a, o, l, u = ai,
+            c, f = !1,
+            h;
 
-        function R(Y, ue, be) {
-            var q = y.exec(ue.slice(be));
-            return q ? (Y.m = v.get(q[0].toLowerCase()), be + q[0].length) : -1
+        function d(p) {
+            return isNaN(p = +p) ? h : (p = .5 + ((p = +c(p)) - s) * (i * p < i * s ? o : l), u(f ? Math.max(0, Math.min(1, p)) : p))
         }
+        d.domain = function(p) {
+            return arguments.length ? ([e, t, n] = p, r = c(e = +e), s = c(t = +t), a = c(n = +n), o = r === s ? 0 : .5 / (s - r), l = s === a ? 0 : .5 / (a - s), i = s < r ? -1 : 1, d) : [e, t, n]
+        }, d.clamp = function(p) {
+            return arguments.length ? (f = !!p, d) : f
+        }, d.interpolator = function(p) {
+            return arguments.length ? (u = p, d) : u
+        };
 
-        function $(Y, ue, be) {
-            var q = p.exec(ue.slice(be));
-            return q ? (Y.m = m.get(q[0].toLowerCase()), be + q[0].length) : -1
+        function g(p) {
+            return function(m) {
+                var y, v, b;
+                return arguments.length ? ([y, v, b] = m, u = Lw(p, [y, v, b]), d) : [u(0), u(.5), u(1)]
+            }
         }
+        return d.range = g(bo), d.rangeRound = g(Rd), d.unknown = function(p) {
+                return arguments.length ? (h = p, d) : h
+            },
+            function(p) {
+                return c = p, r = p(e), s = p(t), a = p(n), o = r === s ? 0 : .5 / (s - r), l = s === a ? 0 : .5 / (a - s), i = s < r ? -1 : 1, d
+            }
+    }
 
-        function T(Y, ue, be) {
-            return E(Y, t, ue, be)
-        }
+    function pN() {
+        var e = Vl(g1()(ai));
+        return e.copy = function() {
+            return xo(e, pN())
+        }, yo.apply(e, arguments)
+    }
 
-        function M(Y, ue, be) {
-            return E(Y, n, ue, be)
-        }
+    function mN() {
+        var e = Iw(g1()).domain([.1, 1, 10]);
+        return e.copy = function() {
+            return xo(e, mN()).base(e.base())
+        }, yo.apply(e, arguments)
+    }
 
-        function F(Y, ue, be) {
-            return E(Y, i, ue, be)
-        }
+    function yN() {
+        var e = zw(g1());
+        return e.copy = function() {
+            return xo(e, yN()).constant(e.constant())
+        }, yo.apply(e, arguments)
+    }
 
-        function N(Y) {
-            return a[Y.getDay()]
-        }
+    function qw() {
+        var e = Bw(g1());
+        return e.copy = function() {
+            return xo(e, qw()).exponent(e.exponent())
+        }, yo.apply(e, arguments)
+    }
 
-        function P(Y) {
-            return s[Y.getDay()]
-        }
+    function _H() {
+        return qw.apply(null, arguments).exponent(.5)
+    }
 
-        function z(Y) {
-            return l[Y.getMonth()]
-        }
+    function Hw(e, t, n) {
+        const i = e - t + n * 2;
+        return e ? i > 0 ? i : 1 : 0
+    }
+    const wH = "identity",
+        fc = "linear",
+        ea = "log",
+        Nd = "pow",
+        Pd = "sqrt",
+        p1 = "symlog",
+        Sl = "time",
+        El = "utc",
+        ts = "sequential",
+        Kc = "diverging",
+        hc = "quantile",
+        m1 = "quantize",
+        y1 = "threshold",
+        Yw = "ordinal",
+        u2 = "point",
+        vN = "band",
+        Xw = "bin-ordinal",
+        Kt = "continuous",
+        Ld = "discrete",
+        Id = "discretizing",
+        tr = "interpolating",
+        Vw = "temporal";
 
-        function I(Y) {
-            return o[Y.getMonth()]
+    function SH(e) {
+        return function(t) {
+            let n = t[0],
+                i = t[1],
+                r;
+            return i < n && (r = n, n = i, i = r), [e.invert(n), e.invert(i)]
         }
+    }
 
-        function Q(Y) {
-            return r[+(Y.getHours() >= 12)]
+    function EH(e) {
+        return function(t) {
+            const n = e.range();
+            let i = t[0],
+                r = t[1],
+                s = -1,
+                a, o, l, u;
+            for (r < i && (o = i, i = r, r = o), l = 0, u = n.length; l < u; ++l) n[l] >= i && n[l] <= r && (s < 0 && (s = l), a = l);
+            if (!(s < 0)) return i = e.invertExtent(n[s]), r = e.invertExtent(n[a]), [i[0] === void 0 ? i[1] : i[0], r[1] === void 0 ? r[0] : r[1]]
         }
+    }
 
-        function oe(Y) {
-            return 1 + ~~(Y.getMonth() / 3)
-        }
+    function Kw() {
+        const e = l1().unknown(void 0),
+            t = e.domain,
+            n = e.range;
+        let i = [0, 1],
+            r, s, a = !1,
+            o = 0,
+            l = 0,
+            u = .5;
+        delete e.unknown;
 
-        function Se(Y) {
-            return a[Y.getUTCDay()]
+        function c() {
+            const f = t().length,
+                h = i[1] < i[0],
+                d = i[1 - h],
+                g = Hw(f, o, l);
+            let p = i[h - 0];
+            r = (d - p) / (g || 1), a && (r = Math.floor(r)), p += (d - p - r * (f - o)) * u, s = r * (1 - o), a && (p = Math.round(p), s = Math.round(s));
+            const m = $i(f).map(y => p + r * y);
+            return n(h ? m.reverse() : m)
         }
+        return e.domain = function(f) {
+            return arguments.length ? (t(f), c()) : t()
+        }, e.range = function(f) {
+            return arguments.length ? (i = [+f[0], +f[1]], c()) : i.slice()
+        }, e.rangeRound = function(f) {
+            return i = [+f[0], +f[1]], a = !0, c()
+        }, e.bandwidth = function() {
+            return s
+        }, e.step = function() {
+            return r
+        }, e.round = function(f) {
+            return arguments.length ? (a = !!f, c()) : a
+        }, e.padding = function(f) {
+            return arguments.length ? (l = Math.max(0, Math.min(1, f)), o = l, c()) : o
+        }, e.paddingInner = function(f) {
+            return arguments.length ? (o = Math.max(0, Math.min(1, f)), c()) : o
+        }, e.paddingOuter = function(f) {
+            return arguments.length ? (l = Math.max(0, Math.min(1, f)), c()) : l
+        }, e.align = function(f) {
+            return arguments.length ? (u = Math.max(0, Math.min(1, f)), c()) : u
+        }, e.invertRange = function(f) {
+            if (f[0] == null || f[1] == null) return;
+            const h = i[1] < i[0],
+                d = h ? n().reverse() : n(),
+                g = d.length - 1;
+            let p = +f[0],
+                m = +f[1],
+                y, v, b;
+            if (!(p !== p || m !== m) && (m < p && (b = p, p = m, m = b), !(m < d[0] || p > i[1 - h]))) return y = Math.max(0, nm(d, p) - 1), v = p === m ? y : nm(d, m) - 1, p - d[y] > s + 1e-10 && ++y, h && (b = y, y = g - v, v = g - b), y > v ? void 0 : t().slice(y, v + 1)
+        }, e.invert = function(f) {
+            const h = e.invertRange([f, f]);
+            return h && h[0]
+        }, e.copy = function() {
+            return Kw().domain(t()).range(i).round(a).paddingInner(o).paddingOuter(l).align(u)
+        }, c()
+    }
 
-        function ye(Y) {
-            return s[Y.getUTCDay()]
-        }
+    function bN(e) {
+        const t = e.copy;
+        return e.padding = e.paddingOuter, delete e.paddingInner, e.copy = function() {
+            return bN(t())
+        }, e
+    }
 
-        function Pe(Y) {
-            return l[Y.getUTCMonth()]
-        }
+    function kH() {
+        return bN(Kw().paddingInner(1))
+    }
+    var CH = Array.prototype.map;
 
-        function xt(Y) {
-            return o[Y.getUTCMonth()]
-        }
+    function AH(e) {
+        return CH.call(e, Tn)
+    }
+    const $H = Array.prototype.slice;
 
-        function rn(Y) {
-            return r[+(Y.getUTCHours() >= 12)]
-        }
+    function xN() {
+        let e = [],
+            t = [];
 
-        function Un(Y) {
-            return 1 + ~~(Y.getUTCMonth() / 3)
-        }
-        return {
-            format: function(Y) {
-                var ue = S(Y += "", b);
-                return ue.toString = function() {
-                    return Y
-                }, ue
-            },
-            parse: function(Y) {
-                var ue = w(Y += "", !1);
-                return ue.toString = function() {
-                    return Y
-                }, ue
-            },
-            utcFormat: function(Y) {
-                var ue = S(Y += "", x);
-                return ue.toString = function() {
-                    return Y
-                }, ue
-            },
-            utcParse: function(Y) {
-                var ue = w(Y += "", !0);
-                return ue.toString = function() {
-                    return Y
-                }, ue
-            }
+        function n(i) {
+            return i == null || i !== i ? void 0 : t[($d(e, i) - 1) % t.length]
         }
+        return n.domain = function(i) {
+            return arguments.length ? (e = AH(i), n) : e.slice()
+        }, n.range = function(i) {
+            return arguments.length ? (t = $H.call(i), n) : t.slice()
+        }, n.tickFormat = function(i, r) {
+            return rN(e[0], We(e), i ?? 10, r)
+        }, n.copy = function() {
+            return xN().domain(n.domain()).range(n.range())
+        }, n
     }
-    var HA = {
-            "-": "",
-            _: " ",
-            0: "0"
-        },
-        Ht = /^\s*\d+/,
-        Tq = /^%/,
-        Mq = /[\\^$*+?|[\]().{}]/g;
+    const bm = new Map,
+        _N = Symbol("vega_scale");
 
-    function Ge(e, t, n) {
-        var i = e < 0 ? "-" : "",
-            r = (i ? -e : e) + "",
-            s = r.length;
-        return i + (s < n ? new Array(n - s + 1).join(t) + r : r)
+    function wN(e) {
+        return e[_N] = !0, e
     }
 
-    function Oq(e) {
-        return e.replace(Mq, "\\$&")
+    function TH(e) {
+        return e && e[_N] === !0
     }
 
-    function Vc(e) {
-        return new RegExp("^(?:" + e.map(Oq).join("|") + ")", "i")
+    function MH(e, t, n) {
+        const i = function() {
+            const s = t();
+            return s.invertRange || (s.invertRange = s.invert ? SH(s) : s.invertExtent ? EH(s) : void 0), s.type = e, wN(s)
+        };
+        return i.metadata = Cr(ue(n)), i
     }
 
-    function Kc(e) {
-        return new Map(e.map((t, n) => [t.toLowerCase(), n]))
+    function Ze(e, t, n) {
+        return arguments.length > 1 ? (bm.set(e, MH(e, t, n)), this) : SN(e) ? bm.get(e) : void 0
     }
+    Ze(wH, aN);
+    Ze(fc, sN, Kt);
+    Ze(ea, lN, [Kt, ea]);
+    Ze(Nd, jw, Kt);
+    Ze(Pd, pH, Kt);
+    Ze(p1, uN, Kt);
+    Ze(Sl, vH, [Kt, Vw]);
+    Ze(El, bH, [Kt, Vw]);
+    Ze(ts, Uw, [Kt, tr]);
+    Ze(`${ts}-${fc}`, Uw, [Kt, tr]);
+    Ze(`${ts}-${ea}`, dN, [Kt, tr, ea]);
+    Ze(`${ts}-${Nd}`, Ww, [Kt, tr]);
+    Ze(`${ts}-${Pd}`, xH, [Kt, tr]);
+    Ze(`${ts}-${p1}`, gN, [Kt, tr]);
+    Ze(`${Kc}-${fc}`, pN, [Kt, tr]);
+    Ze(`${Kc}-${ea}`, mN, [Kt, tr, ea]);
+    Ze(`${Kc}-${Nd}`, qw, [Kt, tr]);
+    Ze(`${Kc}-${Pd}`, _H, [Kt, tr]);
+    Ze(`${Kc}-${p1}`, yN, [Kt, tr]);
+    Ze(hc, cN, [Id, hc]);
+    Ze(m1, fN, Id);
+    Ze(y1, hN, Id);
+    Ze(Xw, xN, [Ld, Id]);
+    Ze(Yw, l1, Ld);
+    Ze(vN, Kw, Ld);
+    Ze(u2, kH, Ld);
 
-    function Fq(e, t, n) {
-        var i = Ht.exec(t.slice(n, n + 1));
-        return i ? (e.w = +i[0], n + i[0].length) : -1
+    function SN(e) {
+        return bm.has(e)
     }
 
-    function Rq(e, t, n) {
-        var i = Ht.exec(t.slice(n, n + 1));
-        return i ? (e.u = +i[0], n + i[0].length) : -1
+    function Kl(e, t) {
+        const n = bm.get(e);
+        return n && n.metadata[t]
     }
 
-    function Dq(e, t, n) {
-        var i = Ht.exec(t.slice(n, n + 2));
-        return i ? (e.U = +i[0], n + i[0].length) : -1
+    function Jw(e) {
+        return Kl(e, Kt)
     }
 
-    function Nq(e, t, n) {
-        var i = Ht.exec(t.slice(n, n + 2));
-        return i ? (e.V = +i[0], n + i[0].length) : -1
+    function dc(e) {
+        return Kl(e, Ld)
     }
 
-    function Pq(e, t, n) {
-        var i = Ht.exec(t.slice(n, n + 2));
-        return i ? (e.W = +i[0], n + i[0].length) : -1
+    function c2(e) {
+        return Kl(e, Id)
     }
 
-    function YA(e, t, n) {
-        var i = Ht.exec(t.slice(n, n + 4));
-        return i ? (e.y = +i[0], n + i[0].length) : -1
+    function EN(e) {
+        return Kl(e, ea)
     }
 
-    function XA(e, t, n) {
-        var i = Ht.exec(t.slice(n, n + 2));
-        return i ? (e.y = +i[0] + (+i[0] > 68 ? 1900 : 2e3), n + i[0].length) : -1
+    function OH(e) {
+        return Kl(e, Vw)
     }
 
-    function Lq(e, t, n) {
-        var i = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(t.slice(n, n + 6));
-        return i ? (e.Z = i[1] ? 0 : -(i[2] + (i[3] || "00")), n + i[0].length) : -1
+    function kN(e) {
+        return Kl(e, tr)
     }
 
-    function Iq(e, t, n) {
-        var i = Ht.exec(t.slice(n, n + 1));
-        return i ? (e.q = i[0] * 3 - 3, n + i[0].length) : -1
+    function CN(e) {
+        return Kl(e, hc)
     }
+    const FH = ["clamp", "base", "constant", "exponent"];
 
-    function zq(e, t, n) {
-        var i = Ht.exec(t.slice(n, n + 2));
-        return i ? (e.m = i[0] - 1, n + i[0].length) : -1
+    function AN(e, t) {
+        const n = t[0],
+            i = We(t) - n;
+        return function(r) {
+            return e(n + r * i)
+        }
     }
 
-    function VA(e, t, n) {
-        var i = Ht.exec(t.slice(n, n + 2));
-        return i ? (e.d = +i[0], n + i[0].length) : -1
+    function v1(e, t, n) {
+        return Lw(Qw(t || "rgb", n), e)
     }
 
-    function Bq(e, t, n) {
-        var i = Ht.exec(t.slice(n, n + 3));
-        return i ? (e.m = 0, e.d = +i[0], n + i[0].length) : -1
+    function $N(e, t) {
+        const n = new Array(t),
+            i = t + 1;
+        for (let r = 0; r < t;) n[r] = e(++r / i);
+        return n
     }
 
-    function KA(e, t, n) {
-        var i = Ht.exec(t.slice(n, n + 2));
-        return i ? (e.H = +i[0], n + i[0].length) : -1
+    function TN(e, t, n) {
+        const i = n - t;
+        let r, s, a;
+        return !i || !Number.isFinite(i) ? Ln(.5) : (r = (s = e.type).indexOf("-"), s = r < 0 ? s : s.slice(r + 1), a = Ze(s)().domain([t, n]).range([0, 1]), FH.forEach(o => e[o] ? a[o](e[o]()) : 0), a)
     }
 
-    function jq(e, t, n) {
-        var i = Ht.exec(t.slice(n, n + 2));
-        return i ? (e.M = +i[0], n + i[0].length) : -1
+    function Qw(e, t) {
+        const n = iH[RH(e)];
+        return t != null && n && n.gamma ? n.gamma(t) : n
     }
 
-    function Uq(e, t, n) {
-        var i = Ht.exec(t.slice(n, n + 2));
-        return i ? (e.S = +i[0], n + i[0].length) : -1
+    function RH(e) {
+        return "interpolate" + e.toLowerCase().split("-").map(t => t[0].toUpperCase() + t.slice(1)).join("")
     }
+    const DH = {
+            blues: "cfe1f2bed8eca8cee58fc1de74b2d75ba3cf4592c63181bd206fb2125ca40a4a90",
+            greens: "d3eecdc0e6baabdda594d3917bc77d60ba6c46ab5e329a512089430e7735036429",
+            greys: "e2e2e2d4d4d4c4c4c4b1b1b19d9d9d8888887575756262624d4d4d3535351e1e1e",
+            oranges: "fdd8b3fdc998fdb87bfda55efc9244f87f2cf06b18e4580bd14904b93d029f3303",
+            purples: "e2e1efd4d4e8c4c5e0b4b3d6a3a0cc928ec3827cb97566ae684ea25c3696501f8c",
+            reds: "fdc9b4fcb49afc9e80fc8767fa7051f6573fec3f2fdc2a25c81b1db21218970b13",
+            blueGreen: "d5efedc1e8e0a7ddd18bd2be70c6a958ba9144ad77319c5d2089460e7736036429",
+            bluePurple: "ccddecbad0e4a8c2dd9ab0d4919cc98d85be8b6db28a55a6873c99822287730f71",
+            greenBlue: "d3eecec5e8c3b1e1bb9bd8bb82cec269c2ca51b2cd3c9fc7288abd1675b10b60a1",
+            orangeRed: "fddcaffdcf9bfdc18afdad77fb9562f67d53ee6545e24932d32d1ebf130da70403",
+            purpleBlue: "dbdaebc8cee4b1c3de97b7d87bacd15b9fc93a90c01e7fb70b70ab056199045281",
+            purpleBlueGreen: "dbd8eac8cee4b0c3de93b7d872acd1549fc83892bb1c88a3097f8702736b016353",
+            purpleRed: "dcc9e2d3b3d7ce9eccd186c0da6bb2e14da0e23189d91e6fc61159ab07498f023a",
+            redPurple: "fccfccfcbec0faa9b8f98faff571a5ec539ddb3695c41b8aa908808d0179700174",
+            yellowGreen: "e4f4acd1eca0b9e2949ed68880c97c62bb6e47aa5e3297502083440e723b036034",
+            yellowOrangeBrown: "feeaa1fedd84fecc63feb746fca031f68921eb7215db5e0bc54c05ab3d038f3204",
+            yellowOrangeRed: "fee087fed16ffebd59fea849fd903efc7335f9522bee3423de1b20ca0b22af0225",
+            blueOrange: "134b852f78b35da2cb9dcae1d2e5eff2f0ebfce0bafbbf74e8932fc5690d994a07",
+            brownBlueGreen: "704108a0651ac79548e3c78af3e6c6eef1eac9e9e48ed1c74da79e187a72025147",
+            purpleGreen: "5b1667834792a67fb6c9aed3e6d6e8eff0efd9efd5aedda971bb75368e490e5e29",
+            purpleOrange: "4114696647968f83b7b9b4d6dadbebf3eeeafce0bafbbf74e8932fc5690d994a07",
+            redBlue: "8c0d25bf363adf745ef4ae91fbdbc9f2efeed2e5ef9dcae15da2cb2f78b3134b85",
+            redGrey: "8c0d25bf363adf745ef4ae91fcdccbfaf4f1e2e2e2c0c0c0969696646464343434",
+            yellowGreenBlue: "eff9bddbf1b4bde5b594d5b969c5be45b4c22c9ec02182b82163aa23479c1c3185",
+            redYellowBlue: "a50026d4322cf16e43fcac64fedd90faf8c1dcf1ecabd6e875abd04a74b4313695",
+            redYellowGreen: "a50026d4322cf16e43fcac63fedd8df9f7aed7ee8ea4d86e64bc6122964f006837",
+            pinkYellowGreen: "8e0152c0267edd72adf0b3d6faddedf5f3efe1f2cab6de8780bb474f9125276419",
+            spectral: "9e0142d13c4bf0704afcac63fedd8dfbf8b0e0f3a1a9dda269bda94288b55e4fa2",
+            viridis: "440154470e61481a6c482575472f7d443a834144873d4e8a39568c35608d31688e2d708e2a788e27818e23888e21918d1f988b1fa08822a8842ab07f35b77943bf7154c56866cc5d7ad1518fd744a5db36bcdf27d2e21be9e51afde725",
+            magma: "0000040404130b0924150e3720114b2c11603b0f704a107957157e651a80721f817f24828c29819a2e80a8327db6377ac43c75d1426fde4968e95462f1605df76f5cfa7f5efc8f65fe9f6dfeaf78febf84fece91fddea0fcedaffcfdbf",
+            inferno: "0000040403130c0826170c3b240c4f330a5f420a68500d6c5d126e6b176e781c6d86216b932667a12b62ae305cbb3755c73e4cd24644dd513ae65c30ed6925f3771af8850ffb9506fca50afcb519fac62df6d645f2e661f3f484fcffa4",
+            plasma: "0d088723069033059742039d5002a25d01a66a00a87801a88405a7900da49c179ea72198b12a90ba3488c33d80cb4779d35171da5a69e16462e76e5bed7953f2834cf68f44fa9a3dfca636fdb32ffec029fcce25f9dc24f5ea27f0f921",
+            cividis: "00205100235800265d002961012b65042e670831690d346b11366c16396d1c3c6e213f6e26426e2c456e31476e374a6e3c4d6e42506e47536d4c566d51586e555b6e5a5e6e5e616e62646f66676f6a6a706e6d717270717573727976737c79747f7c75827f758682768985778c8877908b78938e789691789a94789e9778a19b78a59e77a9a177aea575b2a874b6ab73bbaf71c0b26fc5b66dc9b96acebd68d3c065d8c462ddc85fe2cb5ce7cf58ebd355f0d652f3da4ff7de4cfae249fce647",
+            rainbow: "6e40aa883eb1a43db3bf3cafd83fa4ee4395fe4b83ff576eff6659ff7847ff8c38f3a130e2b72fcfcc36bee044aff05b8ff4576ff65b52f6673af27828ea8d1ddfa319d0b81cbecb23abd82f96e03d82e14c6edb5a5dd0664dbf6e40aa",
+            sinebow: "ff4040fc582af47218e78d0bd5a703bfbf00a7d5038de70b72f41858fc2a40ff402afc5818f4720be78d03d5a700bfbf03a7d50b8de71872f42a58fc4040ff582afc7218f48d0be7a703d5bf00bfd503a7e70b8df41872fc2a58ff4040",
+            turbo: "23171b32204a3e2a71453493493eae4b49c54a53d7485ee44569ee4074f53c7ff8378af93295f72e9ff42ba9ef28b3e926bce125c5d925cdcf27d5c629dcbc2de3b232e9a738ee9d3ff39347f68950f9805afc7765fd6e70fe667cfd5e88fc5795fb51a1f84badf545b9f140c5ec3cd0e637dae034e4d931ecd12ef4c92bfac029ffb626ffad24ffa223ff9821ff8d1fff821dff771cfd6c1af76118f05616e84b14df4111d5380fcb2f0dc0260ab61f07ac1805a313029b0f00950c00910b00",
+            browns: "eedbbdecca96e9b97ae4a865dc9856d18954c7784cc0673fb85536ad44339f3632",
+            tealBlues: "bce4d89dd3d181c3cb65b3c245a2b9368fae347da0306a932c5985",
+            teals: "bbdfdfa2d4d58ac9c975bcbb61b0af4da5a43799982b8b8c1e7f7f127273006667",
+            warmGreys: "dcd4d0cec5c1c0b8b4b3aaa7a59c9998908c8b827f7e7673726866665c5a59504e",
+            goldGreen: "f4d166d5ca60b6c35c98bb597cb25760a6564b9c533f8f4f33834a257740146c36",
+            goldOrange: "f4d166f8be5cf8aa4cf5983bf3852aef701be2621fd65322c54923b142239e3a26",
+            goldRed: "f4d166f6be59f9aa51fc964ef6834bee734ae56249db5247cf4244c43141b71d3e",
+            lightGreyRed: "efe9e6e1dad7d5cbc8c8bdb9bbaea9cd967ddc7b43e15f19df4011dc000b",
+            lightGreyTeal: "e4eaead6dcddc8ced2b7c2c7a6b4bc64b0bf22a6c32295c11f85be1876bc",
+            lightMulti: "e0f1f2c4e9d0b0de9fd0e181f6e072f6c053f3993ef77440ef4a3c",
+            lightOrange: "f2e7daf7d5baf9c499fab184fa9c73f68967ef7860e8645bde515bd43d5b",
+            lightTealBlue: "e3e9e0c0dccf9aceca7abfc859afc0389fb9328dad2f7ca0276b95255988",
+            darkBlue: "3232322d46681a5c930074af008cbf05a7ce25c0dd38daed50f3faffffff",
+            darkGold: "3c3c3c584b37725e348c7631ae8b2bcfa424ecc31ef9de30fff184ffffff",
+            darkGreen: "3a3a3a215748006f4d048942489e4276b340a6c63dd2d836ffeb2cffffaa",
+            darkMulti: "3737371f5287197d8c29a86995ce3fffe800ffffff",
+            darkRed: "3434347036339e3c38cc4037e75d1eec8620eeab29f0ce32ffeb2c"
+        },
+        NH = {
+            category10: "1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf",
+            category20: "1f77b4aec7e8ff7f0effbb782ca02c98df8ad62728ff98969467bdc5b0d58c564bc49c94e377c2f7b6d27f7f7fc7c7c7bcbd22dbdb8d17becf9edae5",
+            category20b: "393b795254a36b6ecf9c9ede6379398ca252b5cf6bcedb9c8c6d31bd9e39e7ba52e7cb94843c39ad494ad6616be7969c7b4173a55194ce6dbdde9ed6",
+            category20c: "3182bd6baed69ecae1c6dbefe6550dfd8d3cfdae6bfdd0a231a35474c476a1d99bc7e9c0756bb19e9ac8bcbddcdadaeb636363969696bdbdbdd9d9d9",
+            tableau10: "4c78a8f58518e4575672b7b254a24beeca3bb279a2ff9da69d755dbab0ac",
+            tableau20: "4c78a89ecae9f58518ffbf7954a24b88d27ab79a20f2cf5b43989483bcb6e45756ff9d9879706ebab0acd67195fcbfd2b279a2d6a5c99e765fd8b5a5",
+            accent: "7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666",
+            dark2: "1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666",
+            paired: "a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928",
+            pastel1: "fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2",
+            pastel2: "b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc",
+            set1: "e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999",
+            set2: "66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3",
+            set3: "8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f"
+        };
 
-    function Gq(e, t, n) {
-        var i = Ht.exec(t.slice(n, n + 3));
-        return i ? (e.L = +i[0], n + i[0].length) : -1
+    function MN(e) {
+        const t = e.length / 6 | 0,
+            n = new Array(t);
+        for (let i = 0; i < t;) n[i] = "#" + e.slice(i * 6, ++i * 6);
+        return n
     }
 
-    function Wq(e, t, n) {
-        var i = Ht.exec(t.slice(n, n + 6));
-        return i ? (e.L = Math.floor(i[0] / 1e3), n + i[0].length) : -1
+    function ON(e, t) {
+        for (const n in e) Zw(n, t(e[n]))
     }
+    const f$ = {};
+    ON(NH, MN);
+    ON(DH, e => v1(MN(e)));
+
+    function Zw(e, t) {
+        return e = e && e.toLowerCase(), arguments.length > 1 ? (f$[e] = t, this) : f$[e]
+    }
+    const Ep = "symbol",
+        PH = "discrete",
+        LH = "gradient",
+        IH = e => H(e) ? e.map(t => String(t)) : String(e),
+        zH = (e, t) => e[1] - t[1],
+        BH = (e, t) => t[1] - e[1];
 
-    function qq(e, t, n) {
-        var i = Tq.exec(t.slice(n, n + 1));
-        return i ? n + i[0].length : -1
+    function eS(e, t, n) {
+        let i;
+        return lt(t) && (e.bins && (t = Math.max(t, e.bins.length)), n != null && (t = Math.min(t, Math.floor(Cd(e.domain()) / n || 1)))), ce(t) && (i = t.step, t = t.interval), le(t) && (t = e.type === Sl ? Hc(t) : e.type == El ? Yc(t) : q("Only time and utc scales accept interval strings."), i && (t = t.every(i))), t
     }
 
-    function Hq(e, t, n) {
-        var i = Ht.exec(t.slice(n));
-        return i ? (e.Q = +i[0], n + i[0].length) : -1
+    function FN(e, t, n) {
+        let i = e.range(),
+            r = i[0],
+            s = We(i),
+            a = zH;
+        if (r > s && (i = s, s = r, r = i, a = BH), r = Math.floor(r), s = Math.ceil(s), t = t.map(o => [o, e(o)]).filter(o => r <= o[1] && o[1] <= s).sort(a).map(o => o[0]), n > 0 && t.length > 1) {
+            const o = [t[0], We(t)];
+            for (; t.length > n && t.length >= 3;) t = t.filter((l, u) => !(u % 2));
+            t.length < 3 && (t = o)
+        }
+        return t
     }
 
-    function Yq(e, t, n) {
-        var i = Ht.exec(t.slice(n));
-        return i ? (e.s = +i[0], n + i[0].length) : -1
+    function tS(e, t) {
+        return e.bins ? FN(e, e.bins) : e.ticks ? e.ticks(t) : e.domain()
     }
 
-    function JA(e, t) {
-        return Ge(e.getDate(), t, 2)
+    function RN(e, t, n, i, r, s) {
+        const a = t.type;
+        let o = IH;
+        if (a === Sl || r === Sl) o = e.timeFormat(i);
+        else if (a === El || r === El) o = e.utcFormat(i);
+        else if (EN(a)) {
+            const l = e.formatFloat(i);
+            if (s || t.bins) o = l;
+            else {
+                const u = DN(t, n, !1);
+                o = c => u(c) ? l(c) : ""
+            }
+        } else if (t.tickFormat) {
+            const l = t.domain();
+            o = e.formatSpan(l[0], l[l.length - 1], n, i)
+        } else i && (o = e.format(i));
+        return o
     }
 
-    function Xq(e, t) {
-        return Ge(e.getHours(), t, 2)
+    function DN(e, t, n) {
+        const i = tS(e, t),
+            r = e.base(),
+            s = Math.log(r),
+            a = Math.max(1, r * t / i.length),
+            o = l => {
+                let u = l / Math.pow(r, Math.round(Math.log(l) / s));
+                return u * r < r - .5 && (u *= r), u <= a
+            };
+        return n ? i.filter(o) : o
     }
+    const f2 = {
+            [hc]: "quantiles",
+            [m1]: "thresholds",
+            [y1]: "domain"
+        },
+        NN = {
+            [hc]: "quantiles",
+            [m1]: "domain"
+        };
 
-    function Vq(e, t) {
-        return Ge(e.getHours() % 12 || 12, t, 2)
+    function PN(e, t) {
+        return e.bins ? UH(e.bins) : e.type === ea ? DN(e, t, !0) : f2[e.type] ? GH(e[f2[e.type]]()) : tS(e, t)
     }
 
-    function Kq(e, t) {
-        return Ge(1 + Os.count(Wr(e), e), t, 3)
+    function jH(e, t, n) {
+        const i = t[NN[t.type]](),
+            r = i.length;
+        let s = r > 1 ? i[1] - i[0] : i[0],
+            a;
+        for (a = 1; a < r; ++a) s = Math.min(s, i[a] - i[a - 1]);
+        return e.formatSpan(0, s, 3 * 10, n)
     }
 
-    function lR(e, t) {
-        return Ge(e.getMilliseconds(), t, 3)
+    function GH(e) {
+        const t = [-1 / 0].concat(e);
+        return t.max = 1 / 0, t
     }
 
-    function Jq(e, t) {
-        return lR(e, t) + "000"
+    function UH(e) {
+        const t = e.slice(0, -1);
+        return t.max = We(e), t
     }
+    const WH = e => f2[e.type] || e.bins;
 
-    function Qq(e, t) {
-        return Ge(e.getMonth() + 1, t, 2)
+    function LN(e, t, n, i, r, s, a) {
+        const o = NN[t.type] && s !== Sl && s !== El ? jH(e, t, r) : RN(e, t, n, r, s, a);
+        return i === Ep && WH(t) ? qH(o) : i === PH ? HH(o) : YH(o)
+    }
+    const qH = e => (t, n, i) => {
+            const r = h$(i[n + 1], h$(i.max, 1 / 0)),
+                s = d$(t, e),
+                a = d$(r, e);
+            return s && a ? s + " – " + a : a ? "< " + a : "≥ " + s
+        },
+        h$ = (e, t) => e ?? t,
+        HH = e => (t, n) => n ? e(t) : null,
+        YH = e => t => e(t),
+        d$ = (e, t) => Number.isFinite(e) ? t(e) : null;
+
+    function XH(e) {
+        const t = e.domain(),
+            n = t.length - 1;
+        let i = +t[0],
+            r = +We(t),
+            s = r - i;
+        if (e.type === y1) {
+            const a = n ? s / n : .1;
+            i -= a, r += a, s = r - i
+        }
+        return a => (a - i) / s
     }
 
-    function Zq(e, t) {
-        return Ge(e.getMinutes(), t, 2)
+    function VH(e, t, n, i) {
+        const r = i || t.type;
+        return le(n) && OH(r) && (n = n.replace(/%a/g, "%A").replace(/%b/g, "%B")), !n && r === Sl ? e.timeFormat("%A, %d %B %Y, %X") : !n && r === El ? e.utcFormat("%A, %d %B %Y, %X UTC") : LN(e, t, 5, null, n, i, !0)
     }
 
-    function eH(e, t) {
-        return Ge(e.getSeconds(), t, 2)
+    function IN(e, t, n) {
+        n = n || {};
+        const i = Math.max(3, n.maxlen || 7),
+            r = VH(e, t, n.format, n.formatType);
+        if (c2(t.type)) {
+            const s = PN(t).slice(1).map(r),
+                a = s.length;
+            return `${a} boundar${a===1?"y":"ies"}: ${s.join(", ")}`
+        } else if (dc(t.type)) {
+            const s = t.domain(),
+                a = s.length,
+                o = a > i ? s.slice(0, i - 2).map(r).join(", ") + ", ending with " + s.slice(-1).map(r) : s.map(r).join(", ");
+            return `${a} value${a===1?"":"s"}: ${o}`
+        } else {
+            const s = t.domain();
+            return `values from ${r(s[0])} to ${r(We(s))}`
+        }
     }
+    let zN = 0;
 
-    function tH(e) {
-        var t = e.getDay();
-        return t === 0 ? 7 : t
+    function KH() {
+        zN = 0
     }
+    const xm = "p_";
 
-    function nH(e, t) {
-        return Ge(mc.count(Wr(e) - 1, e), t, 2)
+    function nS(e) {
+        return e && e.gradient
     }
 
-    function uR(e) {
-        var t = e.getDay();
-        return t >= 4 || t === 0 ? Iu(e) : Iu.ceil(e)
+    function BN(e, t, n) {
+        const i = e.gradient;
+        let r = e.id,
+            s = i === "radial" ? xm : "";
+        return r || (r = e.id = "gradient_" + zN++, i === "radial" ? (e.x1 = Gr(e.x1, .5), e.y1 = Gr(e.y1, .5), e.r1 = Gr(e.r1, 0), e.x2 = Gr(e.x2, .5), e.y2 = Gr(e.y2, .5), e.r2 = Gr(e.r2, .5), s = xm) : (e.x1 = Gr(e.x1, 0), e.y1 = Gr(e.y1, 0), e.x2 = Gr(e.x2, 1), e.y2 = Gr(e.y2, 0))), t[r] = e, "url(" + (n || "") + "#" + s + r + ")"
     }
 
-    function iH(e, t) {
-        return e = uR(e), Ge(Iu.count(Wr(e), e) + (Wr(e).getDay() === 4), t, 2)
+    function Gr(e, t) {
+        return e ?? t
     }
 
-    function rH(e) {
-        return e.getDay()
+    function jN(e, t) {
+        var n = [],
+            i;
+        return i = {
+            gradient: "linear",
+            x1: e ? e[0] : 0,
+            y1: e ? e[1] : 0,
+            x2: t ? t[0] : 1,
+            y2: t ? t[1] : 0,
+            stops: n,
+            stop: function(r, s) {
+                return n.push({
+                    offset: r,
+                    color: s
+                }), i
+            }
+        }
     }
+    const g$ = {
+        basis: {
+            curve: tq
+        },
+        "basis-closed": {
+            curve: nq
+        },
+        "basis-open": {
+            curve: iq
+        },
+        bundle: {
+            curve: rq,
+            tension: "beta",
+            value: .85
+        },
+        cardinal: {
+            curve: sq,
+            tension: "tension",
+            value: 0
+        },
+        "cardinal-open": {
+            curve: oq,
+            tension: "tension",
+            value: 0
+        },
+        "cardinal-closed": {
+            curve: aq,
+            tension: "tension",
+            value: 0
+        },
+        "catmull-rom": {
+            curve: lq,
+            tension: "alpha",
+            value: .5
+        },
+        "catmull-rom-closed": {
+            curve: uq,
+            tension: "alpha",
+            value: .5
+        },
+        "catmull-rom-open": {
+            curve: cq,
+            tension: "alpha",
+            value: .5
+        },
+        linear: {
+            curve: $w
+        },
+        "linear-closed": {
+            curve: fq
+        },
+        monotone: {
+            horizontal: dq,
+            vertical: hq
+        },
+        natural: {
+            curve: gq
+        },
+        step: {
+            curve: pq
+        },
+        "step-after": {
+            curve: yq
+        },
+        "step-before": {
+            curve: mq
+        }
+    };
 
-    function sH(e, t) {
-        return Ge(t0.count(Wr(e) - 1, e), t, 2)
+    function iS(e, t, n) {
+        var i = Ce(g$, e) && g$[e],
+            r = null;
+        return i && (r = i.curve || i[t || "vertical"], i.tension && n != null && (r = r[i.tension](n))), r
     }
+    const JH = {
+            m: 2,
+            l: 2,
+            h: 1,
+            v: 1,
+            z: 0,
+            c: 6,
+            s: 4,
+            q: 4,
+            t: 2,
+            a: 7
+        },
+        QH = /[mlhvzcsqta]([^mlhvzcsqta]+|$)/gi,
+        ZH = /^[+-]?(([0-9]*\.[0-9]+)|([0-9]+\.)|([0-9]+))([eE][+-]?[0-9]+)?/,
+        eY = /^((\s+,?\s*)|(,\s*))/,
+        tY = /^[01]/;
 
-    function aH(e, t) {
-        return Ge(e.getFullYear() % 100, t, 2)
+    function gc(e) {
+        const t = [];
+        return (e.match(QH) || []).forEach(i => {
+            let r = i[0];
+            const s = r.toLowerCase(),
+                a = JH[s],
+                o = nY(s, a, i.slice(1).trim()),
+                l = o.length;
+            if (l < a || l && l % a !== 0) throw Error("Invalid SVG path, incorrect parameter count");
+            if (t.push([r, ...o.slice(0, a)]), l !== a) {
+                s === "m" && (r = r === "M" ? "L" : "l");
+                for (let u = a; u < l; u += a) t.push([r, ...o.slice(u, u + a)])
+            }
+        }), t
     }
 
-    function oH(e, t) {
-        return e = uR(e), Ge(e.getFullYear() % 100, t, 2)
+    function nY(e, t, n) {
+        const i = [];
+        for (let r = 0; t && r < n.length;)
+            for (let s = 0; s < t; ++s) {
+                const a = e === "a" && (s === 3 || s === 4) ? tY : ZH,
+                    o = n.slice(r).match(a);
+                if (o === null) throw Error("Invalid SVG path, incorrect parameter type");
+                r += o[0].length, i.push(+o[0]);
+                const l = n.slice(r).match(eY);
+                l !== null && (r += l[0].length)
+            }
+        return i
+    }
+    const no = Math.PI / 180,
+        iY = 1e-14,
+        Jo = Math.PI / 2,
+        Xr = Math.PI * 2,
+        yu = Math.sqrt(3) / 2;
+    var gv = {},
+        pv = {},
+        GN = [].join;
+
+    function rY(e, t, n, i, r, s, a, o, l) {
+        const u = GN.call(arguments);
+        if (gv[u]) return gv[u];
+        const c = a * no,
+            f = Math.sin(c),
+            h = Math.cos(c);
+        n = Math.abs(n), i = Math.abs(i);
+        const d = h * (o - e) * .5 + f * (l - t) * .5,
+            g = h * (l - t) * .5 - f * (o - e) * .5;
+        let p = d * d / (n * n) + g * g / (i * i);
+        p > 1 && (p = Math.sqrt(p), n *= p, i *= p);
+        const m = h / n,
+            y = f / n,
+            v = -f / i,
+            b = h / i,
+            x = m * o + y * l,
+            _ = v * o + b * l,
+            S = m * e + y * t,
+            w = v * e + b * t;
+        let C = 1 / ((S - x) * (S - x) + (w - _) * (w - _)) - .25;
+        C < 0 && (C = 0);
+        let k = Math.sqrt(C);
+        s == r && (k = -k);
+        const A = .5 * (x + S) - k * (w - _),
+            F = .5 * (_ + w) + k * (S - x),
+            $ = Math.atan2(_ - F, x - A);
+        let M = Math.atan2(w - F, S - A) - $;
+        M < 0 && s === 1 ? M += Xr : M > 0 && s === 0 && (M -= Xr);
+        const R = Math.ceil(Math.abs(M / (Jo + .001))),
+            N = [];
+        for (let L = 0; L < R; ++L) {
+            const I = $ + L * M / R,
+                G = $ + (L + 1) * M / R;
+            N[L] = [A, F, I, G, n, i, f, h]
+        }
+        return gv[u] = N
     }
 
-    function lH(e, t) {
-        return Ge(e.getFullYear() % 1e4, t, 4)
+    function sY(e) {
+        const t = GN.call(e);
+        if (pv[t]) return pv[t];
+        var n = e[0],
+            i = e[1],
+            r = e[2],
+            s = e[3],
+            a = e[4],
+            o = e[5],
+            l = e[6],
+            u = e[7];
+        const c = u * a,
+            f = -l * o,
+            h = l * a,
+            d = u * o,
+            g = Math.cos(r),
+            p = Math.sin(r),
+            m = Math.cos(s),
+            y = Math.sin(s),
+            v = .5 * (s - r),
+            b = Math.sin(v * .5),
+            x = 8 / 3 * b * b / Math.sin(v),
+            _ = n + g - x * p,
+            S = i + p + x * g,
+            w = n + m,
+            E = i + y,
+            C = w + x * y,
+            k = E - x * m;
+        return pv[t] = [c * _ + f * S, h * _ + d * S, c * C + f * k, h * C + d * k, c * w + f * E, h * w + d * E]
+    }
+    const Li = ["l", 0, 0, 0, 0, 0, 0, 0];
+
+    function aY(e, t, n) {
+        const i = Li[0] = e[0];
+        if (i === "a" || i === "A") Li[1] = t * e[1], Li[2] = n * e[2], Li[3] = e[3], Li[4] = e[4], Li[5] = e[5], Li[6] = t * e[6], Li[7] = n * e[7];
+        else if (i === "h" || i === "H") Li[1] = t * e[1];
+        else if (i === "v" || i === "V") Li[1] = n * e[1];
+        else
+            for (var r = 1, s = e.length; r < s; ++r) Li[r] = (r % 2 == 1 ? t : n) * e[r];
+        return Li
     }
 
-    function uH(e, t) {
-        var n = e.getDay();
-        return e = n >= 4 || n === 0 ? Iu(e) : Iu.ceil(e), Ge(e.getFullYear() % 1e4, t, 4)
+    function Qh(e, t, n, i, r, s) {
+        var a, o = null,
+            l = 0,
+            u = 0,
+            c = 0,
+            f = 0,
+            h, d, g, p, m = 0,
+            y = 0;
+        n == null && (n = 0), i == null && (i = 0), r == null && (r = 1), s == null && (s = r), e.beginPath && e.beginPath();
+        for (var v = 0, b = t.length; v < b; ++v) {
+            switch (a = t[v], (r !== 1 || s !== 1) && (a = aY(a, r, s)), a[0]) {
+                case "l":
+                    l += a[1], u += a[2], e.lineTo(l + n, u + i);
+                    break;
+                case "L":
+                    l = a[1], u = a[2], e.lineTo(l + n, u + i);
+                    break;
+                case "h":
+                    l += a[1], e.lineTo(l + n, u + i);
+                    break;
+                case "H":
+                    l = a[1], e.lineTo(l + n, u + i);
+                    break;
+                case "v":
+                    u += a[1], e.lineTo(l + n, u + i);
+                    break;
+                case "V":
+                    u = a[1], e.lineTo(l + n, u + i);
+                    break;
+                case "m":
+                    l += a[1], u += a[2], m = l, y = u, e.moveTo(l + n, u + i);
+                    break;
+                case "M":
+                    l = a[1], u = a[2], m = l, y = u, e.moveTo(l + n, u + i);
+                    break;
+                case "c":
+                    h = l + a[5], d = u + a[6], c = l + a[3], f = u + a[4], e.bezierCurveTo(l + a[1] + n, u + a[2] + i, c + n, f + i, h + n, d + i), l = h, u = d;
+                    break;
+                case "C":
+                    l = a[5], u = a[6], c = a[3], f = a[4], e.bezierCurveTo(a[1] + n, a[2] + i, c + n, f + i, l + n, u + i);
+                    break;
+                case "s":
+                    h = l + a[3], d = u + a[4], c = 2 * l - c, f = 2 * u - f, e.bezierCurveTo(c + n, f + i, l + a[1] + n, u + a[2] + i, h + n, d + i), c = l + a[1], f = u + a[2], l = h, u = d;
+                    break;
+                case "S":
+                    h = a[3], d = a[4], c = 2 * l - c, f = 2 * u - f, e.bezierCurveTo(c + n, f + i, a[1] + n, a[2] + i, h + n, d + i), l = h, u = d, c = a[1], f = a[2];
+                    break;
+                case "q":
+                    h = l + a[3], d = u + a[4], c = l + a[1], f = u + a[2], e.quadraticCurveTo(c + n, f + i, h + n, d + i), l = h, u = d;
+                    break;
+                case "Q":
+                    h = a[3], d = a[4], e.quadraticCurveTo(a[1] + n, a[2] + i, h + n, d + i), l = h, u = d, c = a[1], f = a[2];
+                    break;
+                case "t":
+                    h = l + a[1], d = u + a[2], o[0].match(/[QqTt]/) === null ? (c = l, f = u) : o[0] === "t" ? (c = 2 * l - g, f = 2 * u - p) : o[0] === "q" && (c = 2 * l - c, f = 2 * u - f), g = c, p = f, e.quadraticCurveTo(c + n, f + i, h + n, d + i), l = h, u = d, c = l + a[1], f = u + a[2];
+                    break;
+                case "T":
+                    h = a[1], d = a[2], c = 2 * l - c, f = 2 * u - f, e.quadraticCurveTo(c + n, f + i, h + n, d + i), l = h, u = d;
+                    break;
+                case "a":
+                    p$(e, l + n, u + i, [a[1], a[2], a[3], a[4], a[5], a[6] + l + n, a[7] + u + i]), l += a[6], u += a[7];
+                    break;
+                case "A":
+                    p$(e, l + n, u + i, [a[1], a[2], a[3], a[4], a[5], a[6] + n, a[7] + i]), l = a[6], u = a[7];
+                    break;
+                case "z":
+                case "Z":
+                    l = m, u = y, e.closePath();
+                    break
+            }
+            o = a
+        }
     }
 
-    function cH(e) {
-        var t = e.getTimezoneOffset();
-        return (t > 0 ? "-" : (t *= -1, "+")) + Ge(t / 60 | 0, "0", 2) + Ge(t % 60, "0", 2)
+    function p$(e, t, n, i) {
+        const r = rY(i[5], i[6], i[0], i[1], i[3], i[4], i[2], t, n);
+        for (let s = 0; s < r.length; ++s) {
+            const a = sY(r[s]);
+            e.bezierCurveTo(a[0], a[1], a[2], a[3], a[4], a[5])
+        }
     }
+    const m$ = .5773502691896257,
+        y$ = {
+            circle: {
+                draw: function(e, t) {
+                    const n = Math.sqrt(t) / 2;
+                    e.moveTo(n, 0), e.arc(0, 0, n, 0, Xr)
+                }
+            },
+            cross: {
+                draw: function(e, t) {
+                    var n = Math.sqrt(t) / 2,
+                        i = n / 2.5;
+                    e.moveTo(-n, -i), e.lineTo(-n, i), e.lineTo(-i, i), e.lineTo(-i, n), e.lineTo(i, n), e.lineTo(i, i), e.lineTo(n, i), e.lineTo(n, -i), e.lineTo(i, -i), e.lineTo(i, -n), e.lineTo(-i, -n), e.lineTo(-i, -i), e.closePath()
+                }
+            },
+            diamond: {
+                draw: function(e, t) {
+                    const n = Math.sqrt(t) / 2;
+                    e.moveTo(-n, 0), e.lineTo(0, -n), e.lineTo(n, 0), e.lineTo(0, n), e.closePath()
+                }
+            },
+            square: {
+                draw: function(e, t) {
+                    var n = Math.sqrt(t),
+                        i = -n / 2;
+                    e.rect(i, i, n, n)
+                }
+            },
+            arrow: {
+                draw: function(e, t) {
+                    var n = Math.sqrt(t) / 2,
+                        i = n / 7,
+                        r = n / 2.5,
+                        s = n / 8;
+                    e.moveTo(-i, n), e.lineTo(i, n), e.lineTo(i, -s), e.lineTo(r, -s), e.lineTo(0, -n), e.lineTo(-r, -s), e.lineTo(-i, -s), e.closePath()
+                }
+            },
+            wedge: {
+                draw: function(e, t) {
+                    var n = Math.sqrt(t) / 2,
+                        i = yu * n,
+                        r = i - n * m$,
+                        s = n / 4;
+                    e.moveTo(0, -i - r), e.lineTo(-s, i - r), e.lineTo(s, i - r), e.closePath()
+                }
+            },
+            triangle: {
+                draw: function(e, t) {
+                    var n = Math.sqrt(t) / 2,
+                        i = yu * n,
+                        r = i - n * m$;
+                    e.moveTo(0, -i - r), e.lineTo(-n, i - r), e.lineTo(n, i - r), e.closePath()
+                }
+            },
+            "triangle-up": {
+                draw: function(e, t) {
+                    var n = Math.sqrt(t) / 2,
+                        i = yu * n;
+                    e.moveTo(0, -i), e.lineTo(-n, i), e.lineTo(n, i), e.closePath()
+                }
+            },
+            "triangle-down": {
+                draw: function(e, t) {
+                    var n = Math.sqrt(t) / 2,
+                        i = yu * n;
+                    e.moveTo(0, i), e.lineTo(-n, -i), e.lineTo(n, -i), e.closePath()
+                }
+            },
+            "triangle-right": {
+                draw: function(e, t) {
+                    var n = Math.sqrt(t) / 2,
+                        i = yu * n;
+                    e.moveTo(i, 0), e.lineTo(-i, -n), e.lineTo(-i, n), e.closePath()
+                }
+            },
+            "triangle-left": {
+                draw: function(e, t) {
+                    var n = Math.sqrt(t) / 2,
+                        i = yu * n;
+                    e.moveTo(-i, 0), e.lineTo(i, -n), e.lineTo(i, n), e.closePath()
+                }
+            },
+            stroke: {
+                draw: function(e, t) {
+                    const n = Math.sqrt(t) / 2;
+                    e.moveTo(-n, 0), e.lineTo(n, 0)
+                }
+            }
+        };
 
-    function QA(e, t) {
-        return Ge(e.getUTCDate(), t, 2)
+    function UN(e) {
+        return Ce(y$, e) ? y$[e] : oY(e)
     }
+    var mv = {};
 
-    function fH(e, t) {
-        return Ge(e.getUTCHours(), t, 2)
+    function oY(e) {
+        if (!Ce(mv, e)) {
+            const t = gc(e);
+            mv[e] = {
+                draw: function(n, i) {
+                    Qh(n, t, 0, 0, Math.sqrt(i) / 2)
+                }
+            }
+        }
+        return mv[e]
     }
+    const xa = .448084975506;
 
-    function hH(e, t) {
-        return Ge(e.getUTCHours() % 12 || 12, t, 2)
+    function lY(e) {
+        return e.x
     }
 
-    function dH(e, t) {
-        return Ge(1 + Sa.count(qr(e), e), t, 3)
+    function uY(e) {
+        return e.y
     }
 
-    function cR(e, t) {
-        return Ge(e.getUTCMilliseconds(), t, 3)
+    function cY(e) {
+        return e.width
     }
 
-    function gH(e, t) {
-        return cR(e, t) + "000"
+    function fY(e) {
+        return e.height
     }
 
-    function pH(e, t) {
-        return Ge(e.getUTCMonth() + 1, t, 2)
+    function Ts(e) {
+        return typeof e == "function" ? e : () => +e
     }
 
-    function mH(e, t) {
-        return Ge(e.getUTCMinutes(), t, 2)
+    function $g(e, t, n) {
+        return Math.max(t, Math.min(e, n))
     }
 
-    function yH(e, t) {
-        return Ge(e.getUTCSeconds(), t, 2)
+    function WN() {
+        var e = lY,
+            t = uY,
+            n = cY,
+            i = fY,
+            r = Ts(0),
+            s = r,
+            a = r,
+            o = r,
+            l = null;
+
+        function u(c, f, h) {
+            var d, g = f ?? +e.call(this, c),
+                p = h ?? +t.call(this, c),
+                m = +n.call(this, c),
+                y = +i.call(this, c),
+                v = Math.min(m, y) / 2,
+                b = $g(+r.call(this, c), 0, v),
+                x = $g(+s.call(this, c), 0, v),
+                _ = $g(+a.call(this, c), 0, v),
+                S = $g(+o.call(this, c), 0, v);
+            if (l || (l = d = r1()), b <= 0 && x <= 0 && _ <= 0 && S <= 0) l.rect(g, p, m, y);
+            else {
+                var w = g + m,
+                    E = p + y;
+                l.moveTo(g + b, p), l.lineTo(w - x, p), l.bezierCurveTo(w - xa * x, p, w, p + xa * x, w, p + x), l.lineTo(w, E - S), l.bezierCurveTo(w, E - xa * S, w - xa * S, E, w - S, E), l.lineTo(g + _, E), l.bezierCurveTo(g + xa * _, E, g, E - xa * _, g, E - _), l.lineTo(g, p + b), l.bezierCurveTo(g, p + xa * b, g + xa * b, p, g + b, p), l.closePath()
+            }
+            if (d) return l = null, d + "" || null
+        }
+        return u.x = function(c) {
+            return arguments.length ? (e = Ts(c), u) : e
+        }, u.y = function(c) {
+            return arguments.length ? (t = Ts(c), u) : t
+        }, u.width = function(c) {
+            return arguments.length ? (n = Ts(c), u) : n
+        }, u.height = function(c) {
+            return arguments.length ? (i = Ts(c), u) : i
+        }, u.cornerRadius = function(c, f, h, d) {
+            return arguments.length ? (r = Ts(c), s = f != null ? Ts(f) : r, o = h != null ? Ts(h) : r, a = d != null ? Ts(d) : s, u) : r
+        }, u.context = function(c) {
+            return arguments.length ? (l = c ?? null, u) : l
+        }, u
     }
 
-    function vH(e) {
-        var t = e.getUTCDay();
-        return t === 0 ? 7 : t
+    function qN() {
+        var e, t, n, i, r = null,
+            s, a, o, l;
+
+        function u(f, h, d) {
+            const g = d / 2;
+            if (s) {
+                var p = o - h,
+                    m = f - a;
+                if (p || m) {
+                    var y = Math.sqrt(p * p + m * m),
+                        v = (p /= y) * l,
+                        b = (m /= y) * l,
+                        x = Math.atan2(m, p);
+                    r.moveTo(a - v, o - b), r.lineTo(f - p * g, h - m * g), r.arc(f, h, g, x - Math.PI, x), r.lineTo(a + v, o + b), r.arc(a, o, l, x, x + Math.PI)
+                } else r.arc(f, h, g, 0, Xr);
+                r.closePath()
+            } else s = 1;
+            a = f, o = h, l = g
+        }
+
+        function c(f) {
+            var h, d = f.length,
+                g, p = !1,
+                m;
+            for (r == null && (r = m = r1()), h = 0; h <= d; ++h) !(h < d && i(g = f[h], h, f)) === p && (p = !p) && (s = 0), p && u(+e(g, h, f), +t(g, h, f), +n(g, h, f));
+            if (m) return r = null, m + "" || null
+        }
+        return c.x = function(f) {
+            return arguments.length ? (e = f, c) : e
+        }, c.y = function(f) {
+            return arguments.length ? (t = f, c) : t
+        }, c.size = function(f) {
+            return arguments.length ? (n = f, c) : n
+        }, c.defined = function(f) {
+            return arguments.length ? (i = f, c) : i
+        }, c.context = function(f) {
+            return arguments.length ? (f == null ? r = null : r = f, c) : r
+        }, c
     }
 
-    function bH(e, t) {
-        return Ge(yc.count(qr(e) - 1, e), t, 2)
+    function zd(e, t) {
+        return e ?? t
     }
+    const Bd = e => e.x || 0,
+        jd = e => e.y || 0,
+        hY = e => e.width || 0,
+        dY = e => e.height || 0,
+        gY = e => (e.x || 0) + (e.width || 0),
+        pY = e => (e.y || 0) + (e.height || 0),
+        mY = e => e.startAngle || 0,
+        yY = e => e.endAngle || 0,
+        vY = e => e.padAngle || 0,
+        bY = e => e.innerRadius || 0,
+        xY = e => e.outerRadius || 0,
+        _Y = e => e.cornerRadius || 0,
+        wY = e => zd(e.cornerRadiusTopLeft, e.cornerRadius) || 0,
+        SY = e => zd(e.cornerRadiusTopRight, e.cornerRadius) || 0,
+        EY = e => zd(e.cornerRadiusBottomRight, e.cornerRadius) || 0,
+        kY = e => zd(e.cornerRadiusBottomLeft, e.cornerRadius) || 0,
+        CY = e => zd(e.size, 64),
+        AY = e => e.size || 1,
+        b1 = e => e.defined !== !1,
+        $Y = e => UN(e.shape || "circle"),
+        TY = QW().startAngle(mY).endAngle(yY).padAngle(vY).innerRadius(bY).outerRadius(xY).cornerRadius(_Y),
+        MY = xD().x(Bd).y1(jd).y0(pY).defined(b1),
+        OY = xD().y(jd).x1(Bd).x0(gY).defined(b1),
+        FY = bD().x(Bd).y(jd).defined(b1),
+        RY = WN().x(Bd).y(jd).width(hY).height(dY).cornerRadius(wY, SY, EY, kY),
+        DY = eq().type($Y).size(CY),
+        NY = qN().x(Bd).y(jd).defined(b1).size(AY);
 
-    function fR(e) {
-        var t = e.getUTCDay();
-        return t >= 4 || t === 0 ? zu(e) : zu.ceil(e)
+    function rS(e) {
+        return e.cornerRadius || e.cornerRadiusTopLeft || e.cornerRadiusTopRight || e.cornerRadiusBottomRight || e.cornerRadiusBottomLeft
     }
 
-    function xH(e, t) {
-        return e = fR(e), Ge(zu.count(qr(e), e) + (qr(e).getUTCDay() === 4), t, 2)
+    function PY(e, t) {
+        return TY.context(e)(t)
     }
 
-    function _H(e) {
-        return e.getUTCDay()
+    function LY(e, t) {
+        const n = t[0],
+            i = n.interpolate || "linear";
+        return (n.orient === "horizontal" ? OY : MY).curve(iS(i, n.orient, n.tension)).context(e)(t)
     }
 
-    function wH(e, t) {
-        return Ge(n0.count(qr(e) - 1, e), t, 2)
+    function IY(e, t) {
+        const n = t[0],
+            i = n.interpolate || "linear";
+        return FY.curve(iS(i, n.orient, n.tension)).context(e)(t)
     }
 
-    function SH(e, t) {
-        return Ge(e.getUTCFullYear() % 100, t, 2)
+    function Jc(e, t, n, i) {
+        return RY.context(e)(t, n, i)
     }
 
-    function EH(e, t) {
-        return e = fR(e), Ge(e.getUTCFullYear() % 100, t, 2)
+    function zY(e, t) {
+        return (t.mark.shape || t.shape).context(e)(t)
     }
 
-    function CH(e, t) {
-        return Ge(e.getUTCFullYear() % 1e4, t, 4)
+    function BY(e, t) {
+        return DY.context(e)(t)
     }
 
-    function kH(e, t) {
-        var n = e.getUTCDay();
-        return e = n >= 4 || n === 0 ? zu(e) : zu.ceil(e), Ge(e.getUTCFullYear() % 1e4, t, 4)
+    function jY(e, t) {
+        return NY.context(e)(t)
     }
+    var HN = 1;
 
-    function AH() {
-        return "+0000"
+    function YN() {
+        HN = 1
     }
 
-    function ZA() {
-        return "%"
+    function sS(e, t, n) {
+        var i = t.clip,
+            r = e._defs,
+            s = t.clip_id || (t.clip_id = "clip" + HN++),
+            a = r.clipping[s] || (r.clipping[s] = {
+                id: s
+            });
+        return Pe(i) ? a.path = i(null) : rS(n) ? a.path = Jc(null, n, 0, 0) : (a.width = n.width || 0, a.height = n.height || 0), "url(#" + s + ")"
     }
 
-    function e$(e) {
-        return +e
+    function Ut(e) {
+        this.clear(), e && this.union(e)
     }
+    Ut.prototype = {
+        clone() {
+            return new Ut(this)
+        },
+        clear() {
+            return this.x1 = +Number.MAX_VALUE, this.y1 = +Number.MAX_VALUE, this.x2 = -Number.MAX_VALUE, this.y2 = -Number.MAX_VALUE, this
+        },
+        empty() {
+            return this.x1 === +Number.MAX_VALUE && this.y1 === +Number.MAX_VALUE && this.x2 === -Number.MAX_VALUE && this.y2 === -Number.MAX_VALUE
+        },
+        equals(e) {
+            return this.x1 === e.x1 && this.y1 === e.y1 && this.x2 === e.x2 && this.y2 === e.y2
+        },
+        set(e, t, n, i) {
+            return n < e ? (this.x2 = e, this.x1 = n) : (this.x1 = e, this.x2 = n), i < t ? (this.y2 = t, this.y1 = i) : (this.y1 = t, this.y2 = i), this
+        },
+        add(e, t) {
+            return e < this.x1 && (this.x1 = e), t < this.y1 && (this.y1 = t), e > this.x2 && (this.x2 = e), t > this.y2 && (this.y2 = t), this
+        },
+        expand(e) {
+            return this.x1 -= e, this.y1 -= e, this.x2 += e, this.y2 += e, this
+        },
+        round() {
+            return this.x1 = Math.floor(this.x1), this.y1 = Math.floor(this.y1), this.x2 = Math.ceil(this.x2), this.y2 = Math.ceil(this.y2), this
+        },
+        scale(e) {
+            return this.x1 *= e, this.y1 *= e, this.x2 *= e, this.y2 *= e, this
+        },
+        translate(e, t) {
+            return this.x1 += e, this.x2 += e, this.y1 += t, this.y2 += t, this
+        },
+        rotate(e, t, n) {
+            const i = this.rotatedPoints(e, t, n);
+            return this.clear().add(i[0], i[1]).add(i[2], i[3]).add(i[4], i[5]).add(i[6], i[7])
+        },
+        rotatedPoints(e, t, n) {
+            var {
+                x1: i,
+                y1: r,
+                x2: s,
+                y2: a
+            } = this, o = Math.cos(e), l = Math.sin(e), u = t - t * o + n * l, c = n - t * l - n * o;
+            return [o * i - l * r + u, l * i + o * r + c, o * i - l * a + u, l * i + o * a + c, o * s - l * r + u, l * s + o * r + c, o * s - l * a + u, l * s + o * a + c]
+        },
+        union(e) {
+            return e.x1 < this.x1 && (this.x1 = e.x1), e.y1 < this.y1 && (this.y1 = e.y1), e.x2 > this.x2 && (this.x2 = e.x2), e.y2 > this.y2 && (this.y2 = e.y2), this
+        },
+        intersect(e) {
+            return e.x1 > this.x1 && (this.x1 = e.x1), e.y1 > this.y1 && (this.y1 = e.y1), e.x2 < this.x2 && (this.x2 = e.x2), e.y2 < this.y2 && (this.y2 = e.y2), this
+        },
+        encloses(e) {
+            return e && this.x1 <= e.x1 && this.x2 >= e.x2 && this.y1 <= e.y1 && this.y2 >= e.y2
+        },
+        alignsWith(e) {
+            return e && (this.x1 == e.x1 || this.x2 == e.x2 || this.y1 == e.y1 || this.y2 == e.y2)
+        },
+        intersects(e) {
+            return e && !(this.x2 < e.x1 || this.x1 > e.x2 || this.y2 < e.y1 || this.y1 > e.y2)
+        },
+        contains(e, t) {
+            return !(e < this.x1 || e > this.x2 || t < this.y1 || t > this.y2)
+        },
+        width() {
+            return this.x2 - this.x1
+        },
+        height() {
+            return this.y2 - this.y1
+        }
+    };
 
-    function t$(e) {
-        return Math.floor(+e / 1e3)
+    function x1(e) {
+        this.mark = e, this.bounds = this.bounds || new Ut
     }
-    var Yl, Hx, hR, Yx, dR;
-    $H({
-        dateTime: "%x, %X",
-        date: "%-m/%-d/%Y",
-        time: "%-I:%M:%S %p",
-        periods: ["AM", "PM"],
-        days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
-        shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
-        months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
-        shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
-    });
 
-    function $H(e) {
-        return Yl = oR(e), Hx = Yl.format, hR = Yl.parse, Yx = Yl.utcFormat, dR = Yl.utcParse, Yl
+    function _1(e) {
+        x1.call(this, e), this.items = this.items || []
     }
+    ne(_1, x1);
 
-    function TH(e) {
-        return new Date(e)
+    function aS(e) {
+        this._pending = 0, this._loader = e || H0()
     }
 
-    function MH(e) {
-        return e instanceof Date ? +e : +new Date(+e)
+    function v$(e) {
+        e._pending += 1
     }
 
-    function Xx(e, t, n, i, r, s, a, o, l, u) {
-        var c = VF(),
-            f = c.invert,
-            h = c.domain,
-            d = u(".%L"),
-            g = u(":%S"),
-            p = u("%I:%M"),
-            m = u("%I %p"),
-            y = u("%a %d"),
-            v = u("%b %d"),
-            b = u("%B"),
-            x = u("%Y");
+    function Cf(e) {
+        e._pending -= 1
+    }
+    aS.prototype = {
+        pending() {
+            return this._pending
+        },
+        sanitizeURL(e) {
+            const t = this;
+            return v$(t), t._loader.sanitize(e, {
+                context: "href"
+            }).then(n => (Cf(t), n)).catch(() => (Cf(t), null))
+        },
+        loadImage(e) {
+            const t = this,
+                n = vq();
+            return v$(t), t._loader.sanitize(e, {
+                context: "image"
+            }).then(i => {
+                const r = i.href;
+                if (!r || !n) throw {
+                    url: r
+                };
+                const s = new n,
+                    a = Ce(i, "crossOrigin") ? i.crossOrigin : "anonymous";
+                return a != null && (s.crossOrigin = a), s.onload = () => Cf(t), s.onerror = () => Cf(t), s.src = r, s
+            }).catch(i => (Cf(t), {
+                complete: !1,
+                width: 0,
+                height: 0,
+                src: i && i.url || ""
+            }))
+        },
+        ready() {
+            const e = this;
+            return new Promise(t => {
+                function n(i) {
+                    e.pending() ? setTimeout(() => {
+                        n(!0)
+                    }, 10) : t(i)
+                }
+                n(!1)
+            })
+        }
+    };
 
-        function _(S) {
-            return (l(S) < S ? d : o(S) < S ? g : a(S) < S ? p : s(S) < S ? m : i(S) < S ? r(S) < S ? y : v : n(S) < S ? b : x)(S)
+    function sa(e, t, n) {
+        if (t.stroke && t.opacity !== 0 && t.strokeOpacity !== 0) {
+            const i = t.strokeWidth != null ? +t.strokeWidth : 1;
+            e.expand(i + (n ? GY(t, i) : 0))
         }
-        return c.invert = function(S) {
-            return new Date(f(S))
-        }, c.domain = function(S) {
-            return arguments.length ? h(Array.from(S, MH)) : h().map(TH)
-        }, c.ticks = function(S) {
-            var w = h();
-            return e(w[0], w[w.length - 1], S ?? 10)
-        }, c.tickFormat = function(S, w) {
-            return w == null ? _ : u(w)
-        }, c.nice = function(S) {
-            var w = h();
-            return (!S || typeof S.range != "function") && (S = t(w[0], w[w.length - 1], S ?? 10)), S ? h(ZF(w, S)) : c
-        }, c.copy = function() {
-            return rd(c, Xx(e, t, n, i, r, s, a, o, l, u))
-        }, c
+        return e
     }
 
-    function OH() {
-        return ts.apply(Xx(Aq, $q, Wr, xh, mc, Os, ym, pm, ks, Hx).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments)
+    function GY(e, t) {
+        return e.strokeJoin && e.strokeJoin !== "miter" ? 0 : t
+    }
+    const UY = Xr - 1e-8;
+    let w1, kp, Cp, al, h2, Ap, d2, g2;
+    const Fa = (e, t) => w1.add(e, t),
+        $p = (e, t) => Fa(kp = e, Cp = t),
+        b$ = e => Fa(e, w1.y1),
+        x$ = e => Fa(w1.x1, e),
+        Qo = (e, t) => h2 * e + d2 * t,
+        Zo = (e, t) => Ap * e + g2 * t,
+        yv = (e, t) => Fa(Qo(e, t), Zo(e, t)),
+        vv = (e, t) => $p(Qo(e, t), Zo(e, t));
+
+    function Gd(e, t) {
+        return w1 = e, t ? (al = t * no, h2 = g2 = Math.cos(al), Ap = Math.sin(al), d2 = -Ap) : (h2 = g2 = 1, al = Ap = d2 = 0), WY
     }
+    const WY = {
+        beginPath() {},
+        closePath() {},
+        moveTo: vv,
+        lineTo: vv,
+        rect(e, t, n, i) {
+            al ? (yv(e + n, t), yv(e + n, t + i), yv(e, t + i), vv(e, t)) : (Fa(e + n, t + i), $p(e, t))
+        },
+        quadraticCurveTo(e, t, n, i) {
+            const r = Qo(e, t),
+                s = Zo(e, t),
+                a = Qo(n, i),
+                o = Zo(n, i);
+            _$(kp, r, a, b$), _$(Cp, s, o, x$), $p(a, o)
+        },
+        bezierCurveTo(e, t, n, i, r, s) {
+            const a = Qo(e, t),
+                o = Zo(e, t),
+                l = Qo(n, i),
+                u = Zo(n, i),
+                c = Qo(r, s),
+                f = Zo(r, s);
+            w$(kp, a, l, c, b$), w$(Cp, o, u, f, x$), $p(c, f)
+        },
+        arc(e, t, n, i, r, s) {
+            if (i += al, r += al, kp = n * Math.cos(r) + e, Cp = n * Math.sin(r) + t, Math.abs(r - i) > UY) Fa(e - n, t - n), Fa(e + n, t + n);
+            else {
+                const a = u => Fa(n * Math.cos(u) + e, n * Math.sin(u) + t);
+                let o, l;
+                if (a(i), a(r), r !== i)
+                    if (i = i % Xr, i < 0 && (i += Xr), r = r % Xr, r < 0 && (r += Xr), r < i && (s = !s, o = i, i = r, r = o), s)
+                        for (r -= Xr, o = i - i % Jo, l = 0; l < 4 && o > r; ++l, o -= Jo) a(o);
+                    else
+                        for (o = i - i % Jo + Jo, l = 0; l < 4 && o < r; ++l, o = o + Jo) a(o)
+            }
+        }
+    };
 
-    function FH() {
-        return ts.apply(Xx(Cq, kq, qr, _h, yc, Sa, vm, mm, ks, Yx).domain([Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2)]), arguments)
+    function _$(e, t, n, i) {
+        const r = (e - t) / (e + n - 2 * t);
+        0 < r && r < 1 && i(e + (t - e) * r)
     }
 
-    function bm() {
-        var e = 0,
-            t = 1,
-            n, i, r, s, a = Vn,
-            o = !1,
-            l;
+    function w$(e, t, n, i, r) {
+        const s = i - e + 3 * t - 3 * n,
+            a = e + n - 2 * t,
+            o = e - t;
+        let l = 0,
+            u = 0,
+            c;
+        Math.abs(s) > iY ? (c = a * a + o * s, c >= 0 && (c = Math.sqrt(c), l = (-a + c) / s, u = (-a - c) / s)) : l = .5 * o / a, 0 < l && l < 1 && r(S$(l, e, t, n, i)), 0 < u && u < 1 && r(S$(u, e, t, n, i))
+    }
 
-        function u(f) {
-            return f == null || isNaN(f = +f) ? l : a(r === 0 ? .5 : (f = (s(f) - n) * r, o ? Math.max(0, Math.min(1, f)) : f))
-        }
-        u.domain = function(f) {
-            return arguments.length ? ([e, t] = f, n = s(e = +e), i = s(t = +t), r = n === i ? 0 : 1 / (i - n), u) : [e, t]
-        }, u.clamp = function(f) {
-            return arguments.length ? (o = !!f, u) : o
-        }, u.interpolator = function(f) {
-            return arguments.length ? (a = f, u) : a
-        };
+    function S$(e, t, n, i, r) {
+        const s = 1 - e,
+            a = s * s,
+            o = e * e;
+        return a * s * t + 3 * a * e * n + 3 * s * o * i + o * e * r
+    }
+    var Ya = (Ya = Ha(1, 1)) ? Ya.getContext("2d") : null;
+    const p2 = new Ut;
 
-        function c(f) {
-            return function(h) {
-                var d, g;
-                return arguments.length ? ([d, g] = h, a = f(d, g), u) : [a(0), a(1)]
-            }
+    function oS(e) {
+        return function(t, n) {
+            if (!Ya) return !0;
+            e(Ya, t), p2.clear().union(t.bounds).intersect(n).round();
+            const {
+                x1: i,
+                y1: r,
+                x2: s,
+                y2: a
+            } = p2;
+            for (let o = r; o <= a; ++o)
+                for (let l = i; l <= s; ++l)
+                    if (Ya.isPointInPath(l, o)) return !0;
+            return !1
         }
-        return u.range = c(Ka), u.rangeRound = c(Jh), u.unknown = function(f) {
-                return arguments.length ? (l = f, u) : l
-            },
-            function(f) {
-                return s = f, n = f(e), i = f(t), r = n === i ? 0 : 1 / (i - n), u
-            }
     }
 
-    function Qa(e, t) {
-        return t.domain(e.domain()).interpolator(e.interpolator()).clamp(e.clamp()).unknown(e.unknown())
+    function lS(e, t) {
+        return t.contains(e.x || 0, e.y || 0)
     }
 
-    function Vx() {
-        var e = Cl(bm()(Vn));
-        return e.copy = function() {
-            return Qa(e, Vx())
-        }, Ja.apply(e, arguments)
+    function XN(e, t) {
+        const n = e.x || 0,
+            i = e.y || 0,
+            r = e.width || 0,
+            s = e.height || 0;
+        return t.intersects(p2.set(n, i, n + r, i + s))
     }
 
-    function gR() {
-        var e = jx(bm()).domain([1, 10]);
-        return e.copy = function() {
-            return Qa(e, gR()).base(e.base())
-        }, Ja.apply(e, arguments)
+    function VN(e, t) {
+        const n = e.x || 0,
+            i = e.y || 0,
+            r = e.x2 != null ? e.x2 : n,
+            s = e.y2 != null ? e.y2 : i;
+        return Lu(t, n, i, r, s)
     }
 
-    function pR() {
-        var e = Ux(bm());
-        return e.copy = function() {
-            return Qa(e, pR()).constant(e.constant())
-        }, Ja.apply(e, arguments)
+    function Lu(e, t, n, i, r) {
+        const {
+            x1: s,
+            y1: a,
+            x2: o,
+            y2: l
+        } = e, u = i - t, c = r - n;
+        let f = 0,
+            h = 1,
+            d, g, p, m;
+        for (m = 0; m < 4; ++m) {
+            if (m === 0 && (d = -u, g = -(s - t)), m === 1 && (d = u, g = o - t), m === 2 && (d = -c, g = -(a - n)), m === 3 && (d = c, g = l - n), Math.abs(d) < 1e-10 && g < 0) return !1;
+            if (p = g / d, d < 0) {
+                if (p > h) return !1;
+                p > f && (f = p)
+            } else if (d > 0) {
+                if (p < f) return !1;
+                p < h && (h = p)
+            }
+        }
+        return !0
     }
 
-    function Kx() {
-        var e = Gx(bm());
-        return e.copy = function() {
-            return Qa(e, Kx()).exponent(e.exponent())
-        }, Ja.apply(e, arguments)
+    function pc(e, t) {
+        e.globalCompositeOperation = t.blend || "source-over"
     }
 
-    function RH() {
-        return Kx.apply(null, arguments).exponent(.5)
+    function sr(e, t) {
+        return e ?? t
     }
 
-    function xm() {
-        var e = 0,
-            t = .5,
-            n = 1,
-            i = 1,
-            r, s, a, o, l, u = Vn,
-            c, f = !1,
-            h;
-
-        function d(p) {
-            return isNaN(p = +p) ? h : (p = .5 + ((p = +c(p)) - s) * (i * p < i * s ? o : l), u(f ? Math.max(0, Math.min(1, p)) : p))
-        }
-        d.domain = function(p) {
-            return arguments.length ? ([e, t, n] = p, r = c(e = +e), s = c(t = +t), a = c(n = +n), o = r === s ? 0 : .5 / (s - r), l = s === a ? 0 : .5 / (a - s), i = s < r ? -1 : 1, d) : [e, t, n]
-        }, d.clamp = function(p) {
-            return arguments.length ? (f = !!p, d) : f
-        }, d.interpolator = function(p) {
-            return arguments.length ? (u = p, d) : u
-        };
+    function E$(e, t) {
+        const n = t.length;
+        for (let i = 0; i < n; ++i) e.addColorStop(t[i].offset, t[i].color);
+        return e
+    }
 
-        function g(p) {
-            return function(m) {
-                var y, v, b;
-                return arguments.length ? ([y, v, b] = m, u = Cx(p, [y, v, b]), d) : [u(0), u(.5), u(1)]
+    function qY(e, t, n) {
+        const i = n.width(),
+            r = n.height();
+        let s;
+        if (t.gradient === "radial") s = e.createRadialGradient(n.x1 + sr(t.x1, .5) * i, n.y1 + sr(t.y1, .5) * r, Math.max(i, r) * sr(t.r1, 0), n.x1 + sr(t.x2, .5) * i, n.y1 + sr(t.y2, .5) * r, Math.max(i, r) * sr(t.r2, .5));
+        else {
+            const a = sr(t.x1, 0),
+                o = sr(t.y1, 0),
+                l = sr(t.x2, 1),
+                u = sr(t.y2, 0);
+            if (a === l || o === u || i === r) s = e.createLinearGradient(n.x1 + a * i, n.y1 + o * r, n.x1 + l * i, n.y1 + u * r);
+            else {
+                const c = Ha(Math.ceil(i), Math.ceil(r)),
+                    f = c.getContext("2d");
+                return f.scale(i, r), f.fillStyle = E$(f.createLinearGradient(a, o, l, u), t.stops), f.fillRect(0, 0, i, r), e.createPattern(c, "no-repeat")
             }
         }
-        return d.range = g(Ka), d.rangeRound = g(Jh), d.unknown = function(p) {
-                return arguments.length ? (h = p, d) : h
-            },
-            function(p) {
-                return c = p, r = p(e), s = p(t), a = p(n), o = r === s ? 0 : .5 / (s - r), l = s === a ? 0 : .5 / (a - s), i = s < r ? -1 : 1, d
-            }
+        return E$(s, t.stops)
     }
 
-    function mR() {
-        var e = Cl(xm()(Vn));
-        return e.copy = function() {
-            return Qa(e, mR())
-        }, Ja.apply(e, arguments)
+    function KN(e, t, n) {
+        return nS(n) ? qY(e, n, t.bounds) : n
     }
 
-    function yR() {
-        var e = jx(xm()).domain([.1, 1, 10]);
-        return e.copy = function() {
-            return Qa(e, yR()).base(e.base())
-        }, Ja.apply(e, arguments)
+    function _m(e, t, n) {
+        return n *= t.fillOpacity == null ? 1 : t.fillOpacity, n > 0 ? (e.globalAlpha = n, e.fillStyle = KN(e, t, t.fill), !0) : !1
     }
+    var HY = [];
 
-    function vR() {
-        var e = Ux(xm());
-        return e.copy = function() {
-            return Qa(e, vR()).constant(e.constant())
-        }, Ja.apply(e, arguments)
+    function mc(e, t, n) {
+        var i = (i = t.strokeWidth) != null ? i : 1;
+        return i <= 0 ? !1 : (n *= t.strokeOpacity == null ? 1 : t.strokeOpacity, n > 0 ? (e.globalAlpha = n, e.strokeStyle = KN(e, t, t.stroke), e.lineWidth = i, e.lineCap = t.strokeCap || "butt", e.lineJoin = t.strokeJoin || "miter", e.miterLimit = t.strokeMiterLimit || 10, e.setLineDash && (e.setLineDash(t.strokeDash || HY), e.lineDashOffset = t.strokeDashOffset || 0), !0) : !1)
     }
 
-    function Jx() {
-        var e = Gx(xm());
-        return e.copy = function() {
-            return Qa(e, Jx()).exponent(e.exponent())
-        }, Ja.apply(e, arguments)
+    function YY(e, t) {
+        return e.zindex - t.zindex || e.index - t.index
     }
 
-    function DH() {
-        return Jx.apply(null, arguments).exponent(.5)
+    function uS(e) {
+        if (!e.zdirty) return e.zitems;
+        var t = e.items,
+            n = [],
+            i, r, s;
+        for (r = 0, s = t.length; r < s; ++r) i = t[r], i.index = r, i.zindex && n.push(i);
+        return e.zdirty = !1, e.zitems = n.sort(YY)
     }
 
-    function Ye(e) {
-        return function() {
-            return e
+    function $r(e, t) {
+        var n = e.items,
+            i, r;
+        if (!n || !n.length) return;
+        const s = uS(e);
+        if (s && s.length) {
+            for (i = 0, r = n.length; i < r; ++i) n[i].zindex || t(n[i]);
+            n = s
         }
+        for (i = 0, r = n.length; i < r; ++i) t(n[i])
     }
-    const n$ = Math.abs,
-        an = Math.atan2,
-        ho = Math.cos,
-        NH = Math.max,
-        Wy = Math.min,
-        Cr = Math.sin,
-        Po = Math.sqrt,
-        on = 1e-12,
-        Bu = Math.PI,
-        i0 = Bu / 2,
-        bR = 2 * Bu;
 
-    function PH(e) {
-        return e > 1 ? 0 : e < -1 ? Bu : Math.acos(e)
+    function wm(e, t) {
+        var n = e.items,
+            i, r;
+        if (!n || !n.length) return null;
+        const s = uS(e);
+        for (s && s.length && (n = s), r = n.length; --r >= 0;)
+            if (i = t(n[r])) return i;
+        if (n === s) {
+            for (n = e.items, r = n.length; --r >= 0;)
+                if (!n[r].zindex && (i = t(n[r]))) return i
+        }
+        return null
     }
 
-    function i$(e) {
-        return e >= 1 ? i0 : e <= -1 ? -i0 : Math.asin(e)
+    function cS(e) {
+        return function(t, n, i) {
+            $r(n, r => {
+                (!i || i.intersects(r.bounds)) && JN(e, t, r, r)
+            })
+        }
     }
 
-    function _m(e) {
-        let t = 3;
-        return e.digits = function(n) {
-            if (!arguments.length) return t;
-            if (n == null) t = null;
-            else {
-                const i = Math.floor(n);
-                if (!(i >= 0)) throw new RangeError(`invalid digits: ${n}`);
-                t = i
-            }
-            return e
-        }, () => new Ax(t)
+    function XY(e) {
+        return function(t, n, i) {
+            n.items.length && (!i || i.intersects(n.bounds)) && JN(e, t, n.items[0], n.items)
+        }
     }
 
-    function LH(e) {
-        return e.innerRadius
+    function JN(e, t, n, i) {
+        var r = n.opacity == null ? 1 : n.opacity;
+        r !== 0 && (e(t, i) || (pc(t, n), n.fill && _m(t, n, r) && t.fill(), n.stroke && mc(t, n, r) && t.stroke()))
     }
 
-    function IH(e) {
-        return e.outerRadius
+    function S1(e) {
+        return e = e || Yi,
+            function(t, n, i, r, s, a) {
+                return i *= t.pixelRatio, r *= t.pixelRatio, wm(n, o => {
+                    const l = o.bounds;
+                    if (!(l && !l.contains(s, a) || !l) && e(t, o, i, r, s, a)) return o
+                })
+            }
     }
 
-    function zH(e) {
-        return e.startAngle
+    function Ud(e, t) {
+        return function(n, i, r, s) {
+            var a = Array.isArray(i) ? i[0] : i,
+                o = t ?? a.fill,
+                l = a.stroke && n.isPointInStroke,
+                u, c;
+            return l && (u = a.strokeWidth, c = a.strokeCap, n.lineWidth = u ?? 1, n.lineCap = c ?? "butt"), e(n, i) ? !1 : o && n.isPointInPath(r, s) || l && n.isPointInStroke(r, s)
+        }
     }
 
-    function BH(e) {
-        return e.endAngle
+    function fS(e) {
+        return S1(Ud(e))
     }
 
-    function jH(e) {
-        return e && e.padAngle
+    function dl(e, t) {
+        return "translate(" + e + "," + t + ")"
     }
 
-    function UH(e, t, n, i, r, s, a, o) {
-        var l = n - e,
-            u = i - t,
-            c = a - r,
-            f = o - s,
-            h = f * l - c * u;
-        if (!(h * h < on)) return h = (c * (t - s) - f * (e - r)) / h, [e + h * l, t + h * u]
+    function hS(e) {
+        return "rotate(" + e + ")"
     }
 
-    function dg(e, t, n, i, r, s, a) {
-        var o = e - n,
-            l = t - i,
-            u = (a ? s : -s) / Po(o * o + l * l),
-            c = u * l,
-            f = -u * o,
-            h = e + c,
-            d = t + f,
-            g = n + c,
-            p = i + f,
-            m = (h + g) / 2,
-            y = (d + p) / 2,
-            v = g - h,
-            b = p - d,
-            x = v * v + b * b,
-            _ = r - s,
-            S = h * p - g * d,
-            w = (b < 0 ? -1 : 1) * Po(NH(0, _ * _ * x - S * S)),
-            E = (S * b - v * w) / x,
-            A = (-S * v - b * w) / x,
-            C = (S * b + v * w) / x,
-            k = (-S * v + b * w) / x,
-            R = E - m,
-            $ = A - y,
-            T = C - m,
-            M = k - y;
-        return R * R + $ * $ > T * T + M * M && (E = C, A = k), {
-            cx: E,
-            cy: A,
-            x01: -c,
-            y01: -f,
-            x11: E * (r / _ - 1),
-            y11: A * (r / _ - 1)
-        }
+    function VY(e, t) {
+        return "scale(" + e + "," + t + ")"
     }
 
-    function GH() {
-        var e = LH,
-            t = IH,
-            n = Ye(0),
-            i = null,
-            r = zH,
-            s = BH,
-            a = jH,
-            o = null,
-            l = _m(u);
-
-        function u() {
-            var c, f, h = +e.apply(this, arguments),
-                d = +t.apply(this, arguments),
-                g = r.apply(this, arguments) - i0,
-                p = s.apply(this, arguments) - i0,
-                m = n$(p - g),
-                y = p > g;
-            if (o || (o = c = l()), d < h && (f = d, d = h, h = f), !(d > on)) o.moveTo(0, 0);
-            else if (m > bR - on) o.moveTo(d * ho(g), d * Cr(g)), o.arc(0, 0, d, g, p, !y), h > on && (o.moveTo(h * ho(p), h * Cr(p)), o.arc(0, 0, h, p, g, y));
-            else {
-                var v = g,
-                    b = p,
-                    x = g,
-                    _ = p,
-                    S = m,
-                    w = m,
-                    E = a.apply(this, arguments) / 2,
-                    A = E > on && (i ? +i.apply(this, arguments) : Po(h * h + d * d)),
-                    C = Wy(n$(d - h) / 2, +n.apply(this, arguments)),
-                    k = C,
-                    R = C,
-                    $, T;
-                if (A > on) {
-                    var M = i$(A / h * Cr(E)),
-                        F = i$(A / d * Cr(E));
-                    (S -= M * 2) > on ? (M *= y ? 1 : -1, x += M, _ -= M) : (S = 0, x = _ = (g + p) / 2), (w -= F * 2) > on ? (F *= y ? 1 : -1, v += F, b -= F) : (w = 0, v = b = (g + p) / 2)
-                }
-                var N = d * ho(v),
-                    P = d * Cr(v),
-                    z = h * ho(_),
-                    I = h * Cr(_);
-                if (C > on) {
-                    var Q = d * ho(b),
-                        oe = d * Cr(b),
-                        Se = h * ho(x),
-                        ye = h * Cr(x),
-                        Pe;
-                    if (m < Bu)
-                        if (Pe = UH(N, P, Se, ye, Q, oe, z, I)) {
-                            var xt = N - Pe[0],
-                                rn = P - Pe[1],
-                                Un = Q - Pe[0],
-                                Y = oe - Pe[1],
-                                ue = 1 / Cr(PH((xt * Un + rn * Y) / (Po(xt * xt + rn * rn) * Po(Un * Un + Y * Y))) / 2),
-                                be = Po(Pe[0] * Pe[0] + Pe[1] * Pe[1]);
-                            k = Wy(C, (h - be) / (ue - 1)), R = Wy(C, (d - be) / (ue + 1))
-                        } else k = R = 0
-                }
-                w > on ? R > on ? ($ = dg(Se, ye, N, P, d, R, y), T = dg(Q, oe, z, I, d, R, y), o.moveTo($.cx + $.x01, $.cy + $.y01), R < C ? o.arc($.cx, $.cy, R, an($.y01, $.x01), an(T.y01, T.x01), !y) : (o.arc($.cx, $.cy, R, an($.y01, $.x01), an($.y11, $.x11), !y), o.arc(0, 0, d, an($.cy + $.y11, $.cx + $.x11), an(T.cy + T.y11, T.cx + T.x11), !y), o.arc(T.cx, T.cy, R, an(T.y11, T.x11), an(T.y01, T.x01), !y))) : (o.moveTo(N, P), o.arc(0, 0, d, v, b, !y)) : o.moveTo(N, P), !(h > on) || !(S > on) ? o.lineTo(z, I) : k > on ? ($ = dg(z, I, Q, oe, h, -k, y), T = dg(N, P, Se, ye, h, -k, y), o.lineTo($.cx + $.x01, $.cy + $.y01), k < C ? o.arc($.cx, $.cy, k, an($.y01, $.x01), an(T.y01, T.x01), !y) : (o.arc($.cx, $.cy, k, an($.y01, $.x01), an($.y11, $.x11), !y), o.arc(0, 0, h, an($.cy + $.y11, $.cx + $.x11), an(T.cy + T.y11, T.cx + T.x11), y), o.arc(T.cx, T.cy, k, an(T.y11, T.x11), an(T.y01, T.x01), !y))) : o.arc(0, 0, h, _, x, y)
-            }
-            if (o.closePath(), c) return o = null, c + "" || null
-        }
-        return u.centroid = function() {
-            var c = (+e.apply(this, arguments) + +t.apply(this, arguments)) / 2,
-                f = (+r.apply(this, arguments) + +s.apply(this, arguments)) / 2 - Bu / 2;
-            return [ho(f) * c, Cr(f) * c]
-        }, u.innerRadius = function(c) {
-            return arguments.length ? (e = typeof c == "function" ? c : Ye(+c), u) : e
-        }, u.outerRadius = function(c) {
-            return arguments.length ? (t = typeof c == "function" ? c : Ye(+c), u) : t
-        }, u.cornerRadius = function(c) {
-            return arguments.length ? (n = typeof c == "function" ? c : Ye(+c), u) : n
-        }, u.padRadius = function(c) {
-            return arguments.length ? (i = c == null ? null : typeof c == "function" ? c : Ye(+c), u) : i
-        }, u.startAngle = function(c) {
-            return arguments.length ? (r = typeof c == "function" ? c : Ye(+c), u) : r
-        }, u.endAngle = function(c) {
-            return arguments.length ? (s = typeof c == "function" ? c : Ye(+c), u) : s
-        }, u.padAngle = function(c) {
-            return arguments.length ? (a = typeof c == "function" ? c : Ye(+c), u) : a
-        }, u.context = function(c) {
-            return arguments.length ? (o = c ?? null, u) : o
-        }, u
+    function QN(e) {
+        return dl(e.x || 0, e.y || 0)
     }
 
-    function xR(e) {
-        return typeof e == "object" && "length" in e ? e : Array.from(e)
+    function KY(e) {
+        return dl(e.x || 0, e.y || 0) + (e.angle ? " " + hS(e.angle) : "")
     }
 
-    function _R(e) {
-        this._context = e
+    function JY(e) {
+        return dl(e.x || 0, e.y || 0) + (e.angle ? " " + hS(e.angle) : "") + (e.scaleX || e.scaleY ? " " + VY(e.scaleX || 1, e.scaleY || 1) : "")
     }
-    _R.prototype = {
-        areaStart: function() {
-            this._line = 0
-        },
-        areaEnd: function() {
-            this._line = NaN
-        },
-        lineStart: function() {
-            this._point = 0
-        },
-        lineEnd: function() {
-            (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line
-        },
-        point: function(e, t) {
-            switch (e = +e, t = +t, this._point) {
-                case 0:
-                    this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
-                    break;
-                case 1:
-                    this._point = 2;
-                default:
-                    this._context.lineTo(e, t);
-                    break
-            }
+
+    function dS(e, t, n) {
+        function i(a, o) {
+            a("transform", KY(o)), a("d", t(null, o))
+        }
+
+        function r(a, o) {
+            return t(Gd(a, o.angle), o), sa(a, o).translate(o.x || 0, o.y || 0)
         }
-    };
 
-    function Qx(e) {
-        return new _R(e)
+        function s(a, o) {
+            var l = o.x || 0,
+                u = o.y || 0,
+                c = o.angle || 0;
+            a.translate(l, u), c && a.rotate(c *= no), a.beginPath(), t(a, o), c && a.rotate(-c), a.translate(-l, -u)
+        }
+        return {
+            type: e,
+            tag: "path",
+            nested: !1,
+            attr: i,
+            bound: r,
+            draw: cS(s),
+            pick: fS(s),
+            isect: n || oS(s)
+        }
     }
+    var QY = dS("arc", PY);
 
-    function wR(e) {
-        return e[0]
+    function ZY(e, t) {
+        for (var n = e[0].orient === "horizontal" ? t[1] : t[0], i = e[0].orient === "horizontal" ? "y" : "x", r = e.length, s = 1 / 0, a, o; --r >= 0;) e[r].defined !== !1 && (o = Math.abs(e[r][i] - n), o < s && (s = o, a = e[r]));
+        return a
     }
 
-    function SR(e) {
-        return e[1]
+    function eX(e, t) {
+        for (var n = Math.pow(e[0].strokeWidth || 1, 2), i = e.length, r, s, a; --i >= 0;)
+            if (e[i].defined !== !1 && (r = e[i].x - t[0], s = e[i].y - t[1], a = r * r + s * s, a < n)) return e[i];
+        return null
     }
 
-    function ER(e, t) {
-        var n = Ye(!0),
-            i = null,
-            r = Qx,
-            s = null,
-            a = _m(o);
-        e = typeof e == "function" ? e : e === void 0 ? wR : Ye(e), t = typeof t == "function" ? t : t === void 0 ? SR : Ye(t);
+    function tX(e, t) {
+        for (var n = e.length, i, r, s; --n >= 0;)
+            if (e[n].defined !== !1 && (i = e[n].x - t[0], r = e[n].y - t[1], s = i * i + r * r, i = e[n].size || 1, s < i * i)) return e[n];
+        return null
+    }
 
-        function o(l) {
-            var u, c = (l = xR(l)).length,
-                f, h = !1,
-                d;
-            for (i == null && (s = r(d = a())), u = 0; u <= c; ++u) !(u < c && n(f = l[u], u, l)) === h && ((h = !h) ? s.lineStart() : s.lineEnd()), h && s.point(+e(f, u, l), +t(f, u, l));
-            if (d) return s = null, d + "" || null
+    function gS(e, t, n) {
+        function i(l, u) {
+            var c = u.mark.items;
+            c.length && l("d", t(null, c))
         }
-        return o.x = function(l) {
-            return arguments.length ? (e = typeof l == "function" ? l : Ye(+l), o) : e
-        }, o.y = function(l) {
-            return arguments.length ? (t = typeof l == "function" ? l : Ye(+l), o) : t
-        }, o.defined = function(l) {
-            return arguments.length ? (n = typeof l == "function" ? l : Ye(!!l), o) : n
-        }, o.curve = function(l) {
-            return arguments.length ? (r = l, i != null && (s = r(i)), o) : r
-        }, o.context = function(l) {
-            return arguments.length ? (l == null ? i = s = null : s = r(i = l), o) : i
-        }, o
-    }
 
-    function CR(e, t, n) {
-        var i = null,
-            r = Ye(!0),
-            s = null,
-            a = Qx,
-            o = null,
-            l = _m(u);
-        e = typeof e == "function" ? e : e === void 0 ? wR : Ye(+e), t = typeof t == "function" ? t : Ye(t === void 0 ? 0 : +t), n = typeof n == "function" ? n : n === void 0 ? SR : Ye(+n);
+        function r(l, u) {
+            var c = u.items;
+            return c.length === 0 ? l : (t(Gd(l), c), sa(l, c[0]))
+        }
 
-        function u(f) {
-            var h, d, g, p = (f = xR(f)).length,
-                m, y = !1,
-                v, b = new Array(p),
-                x = new Array(p);
-            for (s == null && (o = a(v = l())), h = 0; h <= p; ++h) {
-                if (!(h < p && r(m = f[h], h, f)) === y)
-                    if (y = !y) d = h, o.areaStart(), o.lineStart();
-                    else {
-                        for (o.lineEnd(), o.lineStart(), g = h - 1; g >= d; --g) o.point(b[g], x[g]);
-                        o.lineEnd(), o.areaEnd()
-                    } y && (b[h] = +e(m, h, f), x[h] = +t(m, h, f), o.point(i ? +i(m, h, f) : b[h], n ? +n(m, h, f) : x[h]))
-            }
-            if (v) return o = null, v + "" || null
+        function s(l, u) {
+            l.beginPath(), t(l, u)
         }
+        const a = Ud(s);
 
-        function c() {
-            return ER().defined(r).curve(a).context(s)
+        function o(l, u, c, f, h, d) {
+            var g = u.items,
+                p = u.bounds;
+            return !g || !g.length || p && !p.contains(h, d) ? null : (c *= l.pixelRatio, f *= l.pixelRatio, a(l, g, c, f) ? g[0] : null)
         }
-        return u.x = function(f) {
-            return arguments.length ? (e = typeof f == "function" ? f : Ye(+f), i = null, u) : e
-        }, u.x0 = function(f) {
-            return arguments.length ? (e = typeof f == "function" ? f : Ye(+f), u) : e
-        }, u.x1 = function(f) {
-            return arguments.length ? (i = f == null ? null : typeof f == "function" ? f : Ye(+f), u) : i
-        }, u.y = function(f) {
-            return arguments.length ? (t = typeof f == "function" ? f : Ye(+f), n = null, u) : t
-        }, u.y0 = function(f) {
-            return arguments.length ? (t = typeof f == "function" ? f : Ye(+f), u) : t
-        }, u.y1 = function(f) {
-            return arguments.length ? (n = f == null ? null : typeof f == "function" ? f : Ye(+f), u) : n
-        }, u.lineX0 = u.lineY0 = function() {
-            return c().x(e).y(t)
-        }, u.lineY1 = function() {
-            return c().x(e).y(n)
-        }, u.lineX1 = function() {
-            return c().x(i).y(t)
-        }, u.defined = function(f) {
-            return arguments.length ? (r = typeof f == "function" ? f : Ye(!!f), u) : r
-        }, u.curve = function(f) {
-            return arguments.length ? (a = f, s != null && (o = a(s)), u) : a
-        }, u.context = function(f) {
-            return arguments.length ? (f == null ? s = o = null : o = a(s = f), u) : s
-        }, u
-    }
-    const WH = {
-        draw(e, t) {
-            const n = Po(t / Bu);
-            e.moveTo(n, 0), e.arc(0, 0, n, 0, bR)
+        return {
+            type: e,
+            tag: "path",
+            nested: !0,
+            attr: i,
+            bound: r,
+            draw: XY(s),
+            pick: o,
+            isect: lS,
+            tip: n
         }
-    };
+    }
+    var nX = gS("area", LY, ZY);
 
-    function qH(e, t) {
-        let n = null,
-            i = _m(r);
-        e = typeof e == "function" ? e : Ye(e || WH), t = typeof t == "function" ? t : Ye(t === void 0 ? 64 : +t);
+    function iX(e, t) {
+        var n = t.clip;
+        e.save(), Pe(n) ? (e.beginPath(), n(e), e.clip()) : ZN(e, t.group)
+    }
 
-        function r() {
-            let s;
-            if (n || (n = s = i()), e.apply(this, arguments).draw(n, +t.apply(this, arguments)), s) return n = null, s + "" || null
-        }
-        return r.type = function(s) {
-            return arguments.length ? (e = typeof s == "function" ? s : Ye(s), r) : e
-        }, r.size = function(s) {
-            return arguments.length ? (t = typeof s == "function" ? s : Ye(+s), r) : t
-        }, r.context = function(s) {
-            return arguments.length ? (n = s ?? null, r) : n
-        }, r
+    function ZN(e, t) {
+        e.beginPath(), rS(t) ? Jc(e, t, 0, 0) : e.rect(0, 0, t.width || 0, t.height || 0), e.clip()
     }
 
-    function Fa() {}
+    function eP(e) {
+        const t = sr(e.strokeWidth, 1);
+        return e.strokeOffset != null ? e.strokeOffset : e.stroke && t > .5 && t < 1.5 ? .5 - Math.abs(t - 1) : 0
+    }
 
-    function r0(e, t, n) {
-        e._context.bezierCurveTo((2 * e._x0 + e._x1) / 3, (2 * e._y0 + e._y1) / 3, (e._x0 + 2 * e._x1) / 3, (e._y0 + 2 * e._y1) / 3, (e._x0 + 4 * e._x1 + t) / 6, (e._y0 + 4 * e._y1 + n) / 6)
+    function rX(e, t) {
+        e("transform", QN(t))
     }
 
-    function wm(e) {
-        this._context = e
+    function tP(e, t) {
+        const n = eP(t);
+        e("d", Jc(null, t, n, n))
     }
-    wm.prototype = {
-        areaStart: function() {
-            this._line = 0
-        },
-        areaEnd: function() {
-            this._line = NaN
-        },
-        lineStart: function() {
-            this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0
-        },
-        lineEnd: function() {
-            switch (this._point) {
-                case 3:
-                    r0(this, this._x1, this._y1);
-                case 2:
-                    this._context.lineTo(this._x1, this._y1);
-                    break
-            }(this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line
-        },
-        point: function(e, t) {
-            switch (e = +e, t = +t, this._point) {
-                case 0:
-                    this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
-                    break;
-                case 1:
-                    this._point = 2;
-                    break;
-                case 2:
-                    this._point = 3, this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
-                default:
-                    r0(this, e, t);
-                    break
-            }
-            this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t
-        }
-    };
 
-    function HH(e) {
-        return new wm(e)
+    function sX(e, t) {
+        e("class", "background"), e("aria-hidden", !0), tP(e, t)
     }
 
-    function kR(e) {
-        this._context = e
+    function aX(e, t) {
+        e("class", "foreground"), e("aria-hidden", !0), t.strokeForeground ? tP(e, t) : e("d", "")
     }
-    kR.prototype = {
-        areaStart: Fa,
-        areaEnd: Fa,
-        lineStart: function() {
-            this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN, this._point = 0
-        },
-        lineEnd: function() {
-            switch (this._point) {
-                case 1: {
-                    this._context.moveTo(this._x2, this._y2), this._context.closePath();
-                    break
-                }
-                case 2: {
-                    this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3), this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3), this._context.closePath();
-                    break
-                }
-                case 3: {
-                    this.point(this._x2, this._y2), this.point(this._x3, this._y3), this.point(this._x4, this._y4);
-                    break
-                }
-            }
-        },
-        point: function(e, t) {
-            switch (e = +e, t = +t, this._point) {
-                case 0:
-                    this._point = 1, this._x2 = e, this._y2 = t;
-                    break;
-                case 1:
-                    this._point = 2, this._x3 = e, this._y3 = t;
-                    break;
-                case 2:
-                    this._point = 3, this._x4 = e, this._y4 = t, this._context.moveTo((this._x0 + 4 * this._x1 + e) / 6, (this._y0 + 4 * this._y1 + t) / 6);
-                    break;
-                default:
-                    r0(this, e, t);
-                    break
-            }
-            this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t
+
+    function oX(e, t, n) {
+        const i = t.clip ? sS(n, t, t) : null;
+        e("clip-path", i)
+    }
+
+    function lX(e, t) {
+        if (!t.clip && t.items) {
+            const n = t.items,
+                i = n.length;
+            for (let r = 0; r < i; ++r) e.union(n[r].bounds)
         }
-    };
+        return (t.clip || t.width || t.height) && !t.noBound && e.add(0, 0).add(t.width || 0, t.height || 0), sa(e, t), e.translate(t.x || 0, t.y || 0)
+    }
 
-    function YH(e) {
-        return new kR(e)
+    function Zh(e, t, n, i) {
+        const r = eP(t);
+        e.beginPath(), Jc(e, t, (n || 0) + r, (i || 0) + r)
     }
+    const uX = Ud(Zh),
+        cX = Ud(Zh, !1),
+        fX = Ud(Zh, !0);
 
-    function AR(e) {
-        this._context = e
+    function hX(e, t, n) {
+        $r(t, i => {
+            const r = i.x || 0,
+                s = i.y || 0,
+                a = i.strokeForeground,
+                o = i.opacity == null ? 1 : i.opacity;
+            (i.stroke || i.fill) && o && (Zh(e, i, r, s), pc(e, i), i.fill && _m(e, i, o) && e.fill(), i.stroke && !a && mc(e, i, o) && e.stroke()), e.save(), e.translate(r, s), i.clip && ZN(e, i), n && n.translate(-r, -s), $r(i, l => {
+                this.draw(e, l, n)
+            }), n && n.translate(r, s), e.restore(), a && i.stroke && o && (Zh(e, i, r, s), pc(e, i), mc(e, i, o) && e.stroke())
+        })
     }
-    AR.prototype = {
-        areaStart: function() {
-            this._line = 0
-        },
-        areaEnd: function() {
-            this._line = NaN
-        },
-        lineStart: function() {
-            this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0
-        },
-        lineEnd: function() {
-            (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line
-        },
-        point: function(e, t) {
-            switch (e = +e, t = +t, this._point) {
-                case 0:
-                    this._point = 1;
-                    break;
-                case 1:
-                    this._point = 2;
-                    break;
-                case 2:
-                    this._point = 3;
-                    var n = (this._x0 + 4 * this._x1 + e) / 6,
-                        i = (this._y0 + 4 * this._y1 + t) / 6;
-                    this._line ? this._context.lineTo(n, i) : this._context.moveTo(n, i);
-                    break;
-                case 3:
-                    this._point = 4;
-                default:
-                    r0(this, e, t);
-                    break
-            }
-            this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t
-        }
-    };
 
-    function XH(e) {
-        return new AR(e)
+    function dX(e, t, n, i, r, s) {
+        if (t.bounds && !t.bounds.contains(r, s) || !t.items) return null;
+        const a = n * e.pixelRatio,
+            o = i * e.pixelRatio;
+        return wm(t, l => {
+            let u, c, f;
+            const h = l.bounds;
+            if (h && !h.contains(r, s)) return;
+            c = l.x || 0, f = l.y || 0;
+            const d = c + (l.width || 0),
+                g = f + (l.height || 0),
+                p = l.clip;
+            if (p && (r < c || r > d || s < f || s > g)) return;
+            if (e.save(), e.translate(c, f), c = r - c, f = s - f, p && rS(l) && !fX(e, l, a, o)) return e.restore(), null;
+            const m = l.strokeForeground,
+                y = t.interactive !== !1;
+            return y && m && l.stroke && cX(e, l, a, o) ? (e.restore(), l) : (u = wm(l, v => gX(v, c, f) ? this.pick(v, n, i, c, f) : null), !u && y && (l.fill || !m && l.stroke) && uX(e, l, a, o) && (u = l), e.restore(), u || null)
+        })
     }
 
-    function $R(e, t) {
-        this._basis = new wm(e), this._beta = t
+    function gX(e, t, n) {
+        return (e.interactive !== !1 || e.marktype === "group") && e.bounds && e.bounds.contains(t, n)
     }
-    $R.prototype = {
-        lineStart: function() {
-            this._x = [], this._y = [], this._basis.lineStart()
-        },
-        lineEnd: function() {
-            var e = this._x,
-                t = this._y,
-                n = e.length - 1;
-            if (n > 0)
-                for (var i = e[0], r = t[0], s = e[n] - i, a = t[n] - r, o = -1, l; ++o <= n;) l = o / n, this._basis.point(this._beta * e[o] + (1 - this._beta) * (i + l * s), this._beta * t[o] + (1 - this._beta) * (r + l * a));
-            this._x = this._y = null, this._basis.lineEnd()
+    var pX = {
+            type: "group",
+            tag: "g",
+            nested: !1,
+            attr: rX,
+            bound: lX,
+            draw: hX,
+            pick: dX,
+            isect: XN,
+            content: oX,
+            background: sX,
+            foreground: aX
         },
-        point: function(e, t) {
-            this._x.push(+e), this._y.push(+t)
-        }
-    };
-    const VH = function e(t) {
-        function n(i) {
-            return t === 1 ? new wm(i) : new $R(i, t)
-        }
-        return n.beta = function(i) {
-            return e(+i)
-        }, n
-    }(.85);
+        ed = {
+            xmlns: "http://www.w3.org/2000/svg",
+            "xmlns:xlink": "http://www.w3.org/1999/xlink",
+            version: "1.1"
+        };
 
-    function s0(e, t, n) {
-        e._context.bezierCurveTo(e._x1 + e._k * (e._x2 - e._x0), e._y1 + e._k * (e._y2 - e._y0), e._x2 + e._k * (e._x1 - t), e._y2 + e._k * (e._y1 - n), e._x2, e._y2)
+    function pS(e, t) {
+        var n = e.image;
+        return (!n || e.url && e.url !== n.url) && (n = {
+            complete: !1,
+            width: 0,
+            height: 0
+        }, t.loadImage(e.url).then(i => {
+            e.image = i, e.image.url = e.url
+        })), n
     }
 
-    function Zx(e, t) {
-        this._context = e, this._k = (1 - t) / 6
+    function mS(e, t) {
+        return e.width != null ? e.width : !t || !t.width ? 0 : e.aspect !== !1 && e.height ? e.height * t.width / t.height : t.width
     }
-    Zx.prototype = {
-        areaStart: function() {
-            this._line = 0
-        },
-        areaEnd: function() {
-            this._line = NaN
-        },
-        lineStart: function() {
-            this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0
-        },
-        lineEnd: function() {
-            switch (this._point) {
-                case 2:
-                    this._context.lineTo(this._x2, this._y2);
-                    break;
-                case 3:
-                    s0(this, this._x1, this._y1);
-                    break
-            }(this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line
-        },
-        point: function(e, t) {
-            switch (e = +e, t = +t, this._point) {
-                case 0:
-                    this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
-                    break;
-                case 1:
-                    this._point = 2, this._x1 = e, this._y1 = t;
-                    break;
-                case 2:
-                    this._point = 3;
-                default:
-                    s0(this, e, t);
-                    break
-            }
-            this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t
-        }
-    };
-    const KH = function e(t) {
-        function n(i) {
-            return new Zx(i, t)
-        }
-        return n.tension = function(i) {
-            return e(+i)
-        }, n
-    }(0);
 
-    function e_(e, t) {
-        this._context = e, this._k = (1 - t) / 6
+    function yS(e, t) {
+        return e.height != null ? e.height : !t || !t.height ? 0 : e.aspect !== !1 && e.width ? e.width * t.height / t.width : t.height
     }
-    e_.prototype = {
-        areaStart: Fa,
-        areaEnd: Fa,
-        lineStart: function() {
-            this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._point = 0
-        },
-        lineEnd: function() {
-            switch (this._point) {
-                case 1: {
-                    this._context.moveTo(this._x3, this._y3), this._context.closePath();
-                    break
-                }
-                case 2: {
-                    this._context.lineTo(this._x3, this._y3), this._context.closePath();
-                    break
-                }
-                case 3: {
-                    this.point(this._x3, this._y3), this.point(this._x4, this._y4), this.point(this._x5, this._y5);
-                    break
-                }
-            }
-        },
-        point: function(e, t) {
-            switch (e = +e, t = +t, this._point) {
-                case 0:
-                    this._point = 1, this._x3 = e, this._y3 = t;
-                    break;
-                case 1:
-                    this._point = 2, this._context.moveTo(this._x4 = e, this._y4 = t);
-                    break;
-                case 2:
-                    this._point = 3, this._x5 = e, this._y5 = t;
-                    break;
-                default:
-                    s0(this, e, t);
-                    break
-            }
-            this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t
-        }
-    };
-    const JH = function e(t) {
-        function n(i) {
-            return new e_(i, t)
-        }
-        return n.tension = function(i) {
-            return e(+i)
-        }, n
-    }(0);
 
-    function t_(e, t) {
-        this._context = e, this._k = (1 - t) / 6
+    function E1(e, t) {
+        return e === "center" ? t / 2 : e === "right" ? t : 0
     }
-    t_.prototype = {
-        areaStart: function() {
-            this._line = 0
-        },
-        areaEnd: function() {
-            this._line = NaN
-        },
-        lineStart: function() {
-            this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0
-        },
-        lineEnd: function() {
-            (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line
-        },
-        point: function(e, t) {
-            switch (e = +e, t = +t, this._point) {
-                case 0:
-                    this._point = 1;
-                    break;
-                case 1:
-                    this._point = 2;
-                    break;
-                case 2:
-                    this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
-                    break;
-                case 3:
-                    this._point = 4;
-                default:
-                    s0(this, e, t);
-                    break
-            }
-            this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t
-        }
-    };
-    const QH = function e(t) {
-        function n(i) {
-            return new t_(i, t)
-        }
-        return n.tension = function(i) {
-            return e(+i)
-        }, n
-    }(0);
 
-    function n_(e, t, n) {
-        var i = e._x1,
-            r = e._y1,
-            s = e._x2,
-            a = e._y2;
-        if (e._l01_a > on) {
-            var o = 2 * e._l01_2a + 3 * e._l01_a * e._l12_a + e._l12_2a,
-                l = 3 * e._l01_a * (e._l01_a + e._l12_a);
-            i = (i * o - e._x0 * e._l12_2a + e._x2 * e._l01_2a) / l, r = (r * o - e._y0 * e._l12_2a + e._y2 * e._l01_2a) / l
-        }
-        if (e._l23_a > on) {
-            var u = 2 * e._l23_2a + 3 * e._l23_a * e._l12_a + e._l12_2a,
-                c = 3 * e._l23_a * (e._l23_a + e._l12_a);
-            s = (s * u + e._x1 * e._l23_2a - t * e._l12_2a) / c, a = (a * u + e._y1 * e._l23_2a - n * e._l12_2a) / c
-        }
-        e._context.bezierCurveTo(i, r, s, a, e._x2, e._y2)
+    function k1(e, t) {
+        return e === "middle" ? t / 2 : e === "bottom" ? t : 0
     }
 
-    function TR(e, t) {
-        this._context = e, this._alpha = t
+    function mX(e, t, n) {
+        const i = pS(t, n),
+            r = mS(t, i),
+            s = yS(t, i),
+            a = (t.x || 0) - E1(t.align, r),
+            o = (t.y || 0) - k1(t.baseline, s),
+            l = !i.src && i.toDataURL ? i.toDataURL() : i.src || "";
+        e("href", l, ed["xmlns:xlink"], "xlink:href"), e("transform", dl(a, o)), e("width", r), e("height", s), e("preserveAspectRatio", t.aspect === !1 ? "none" : "xMidYMid")
     }
-    TR.prototype = {
-        areaStart: function() {
-            this._line = 0
-        },
-        areaEnd: function() {
-            this._line = NaN
-        },
-        lineStart: function() {
-            this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0
-        },
-        lineEnd: function() {
-            switch (this._point) {
-                case 2:
-                    this._context.lineTo(this._x2, this._y2);
-                    break;
-                case 3:
-                    this.point(this._x2, this._y2);
-                    break
-            }(this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line
-        },
-        point: function(e, t) {
-            if (e = +e, t = +t, this._point) {
-                var n = this._x2 - e,
-                    i = this._y2 - t;
-                this._l23_a = Math.sqrt(this._l23_2a = Math.pow(n * n + i * i, this._alpha))
-            }
-            switch (this._point) {
-                case 0:
-                    this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
-                    break;
-                case 1:
-                    this._point = 2;
-                    break;
-                case 2:
-                    this._point = 3;
-                default:
-                    n_(this, e, t);
-                    break
-            }
-            this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t
-        }
-    };
-    const ZH = function e(t) {
-        function n(i) {
-            return t ? new TR(i, t) : new Zx(i, 0)
-        }
-        return n.alpha = function(i) {
-            return e(+i)
-        }, n
-    }(.5);
 
-    function MR(e, t) {
-        this._context = e, this._alpha = t
+    function yX(e, t) {
+        const n = t.image,
+            i = mS(t, n),
+            r = yS(t, n),
+            s = (t.x || 0) - E1(t.align, i),
+            a = (t.y || 0) - k1(t.baseline, r);
+        return e.set(s, a, s + i, a + r)
     }
-    MR.prototype = {
-        areaStart: Fa,
-        areaEnd: Fa,
-        lineStart: function() {
-            this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0
-        },
-        lineEnd: function() {
-            switch (this._point) {
-                case 1: {
-                    this._context.moveTo(this._x3, this._y3), this._context.closePath();
-                    break
-                }
-                case 2: {
-                    this._context.lineTo(this._x3, this._y3), this._context.closePath();
-                    break
-                }
-                case 3: {
-                    this.point(this._x3, this._y3), this.point(this._x4, this._y4), this.point(this._x5, this._y5);
-                    break
-                }
-            }
-        },
-        point: function(e, t) {
-            if (e = +e, t = +t, this._point) {
-                var n = this._x2 - e,
-                    i = this._y2 - t;
-                this._l23_a = Math.sqrt(this._l23_2a = Math.pow(n * n + i * i, this._alpha))
-            }
-            switch (this._point) {
-                case 0:
-                    this._point = 1, this._x3 = e, this._y3 = t;
-                    break;
-                case 1:
-                    this._point = 2, this._context.moveTo(this._x4 = e, this._y4 = t);
-                    break;
-                case 2:
-                    this._point = 3, this._x5 = e, this._y5 = t;
-                    break;
-                default:
-                    n_(this, e, t);
-                    break
-            }
-            this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t
-        }
-    };
-    const eY = function e(t) {
-        function n(i) {
-            return t ? new MR(i, t) : new e_(i, 0)
-        }
-        return n.alpha = function(i) {
-            return e(+i)
-        }, n
-    }(.5);
 
-    function OR(e, t) {
-        this._context = e, this._alpha = t
+    function vX(e, t, n) {
+        $r(t, i => {
+            if (n && !n.intersects(i.bounds)) return;
+            const r = pS(i, this);
+            let s = mS(i, r),
+                a = yS(i, r);
+            if (s === 0 || a === 0) return;
+            let o = (i.x || 0) - E1(i.align, s),
+                l = (i.y || 0) - k1(i.baseline, a),
+                u, c, f, h;
+            i.aspect !== !1 && (c = r.width / r.height, f = i.width / i.height, c === c && f === f && c !== f && (f < c ? (h = s / c, l += (a - h) / 2, a = h) : (h = a * c, o += (s - h) / 2, s = h))), (r.complete || r.toDataURL) && (pc(e, i), e.globalAlpha = (u = i.opacity) != null ? u : 1, e.imageSmoothingEnabled = i.smooth !== !1, e.drawImage(r, o, l, s, a))
+        })
     }
-    OR.prototype = {
-        areaStart: function() {
-            this._line = 0
-        },
-        areaEnd: function() {
-            this._line = NaN
-        },
-        lineStart: function() {
-            this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0
-        },
-        lineEnd: function() {
-            (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line
+    var bX = {
+            type: "image",
+            tag: "image",
+            nested: !1,
+            attr: mX,
+            bound: yX,
+            draw: vX,
+            pick: S1(),
+            isect: Yi,
+            get: pS,
+            xOffset: E1,
+            yOffset: k1
         },
-        point: function(e, t) {
-            if (e = +e, t = +t, this._point) {
-                var n = this._x2 - e,
-                    i = this._y2 - t;
-                this._l23_a = Math.sqrt(this._l23_2a = Math.pow(n * n + i * i, this._alpha))
-            }
-            switch (this._point) {
-                case 0:
-                    this._point = 1;
-                    break;
-                case 1:
-                    this._point = 2;
-                    break;
-                case 2:
-                    this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
-                    break;
-                case 3:
-                    this._point = 4;
-                default:
-                    n_(this, e, t);
-                    break
-            }
-            this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t
-        }
-    };
-    const tY = function e(t) {
-        function n(i) {
-            return t ? new OR(i, t) : new t_(i, 0)
-        }
-        return n.alpha = function(i) {
-            return e(+i)
-        }, n
-    }(.5);
+        xX = gS("line", IY, eX);
 
-    function FR(e) {
-        this._context = e
+    function _X(e, t) {
+        var n = t.scaleX || 1,
+            i = t.scaleY || 1;
+        (n !== 1 || i !== 1) && e("vector-effect", "non-scaling-stroke"), e("transform", JY(t)), e("d", t.path)
     }
-    FR.prototype = {
-        areaStart: Fa,
-        areaEnd: Fa,
-        lineStart: function() {
-            this._point = 0
-        },
-        lineEnd: function() {
-            this._point && this._context.closePath()
-        },
-        point: function(e, t) {
-            e = +e, t = +t, this._point ? this._context.lineTo(e, t) : (this._point = 1, this._context.moveTo(e, t))
-        }
+
+    function Tp(e, t) {
+        var n = t.path;
+        if (n == null) return !0;
+        var i = t.x || 0,
+            r = t.y || 0,
+            s = t.scaleX || 1,
+            a = t.scaleY || 1,
+            o = (t.angle || 0) * no,
+            l = t.pathCache;
+        (!l || l.path !== n) && ((t.pathCache = l = gc(n)).path = n), o && e.rotate && e.translate ? (e.translate(i, r), e.rotate(o), Qh(e, l, 0, 0, s, a), e.rotate(-o), e.translate(-i, -r)) : Qh(e, l, i, r, s, a)
+    }
+
+    function wX(e, t) {
+        return Tp(Gd(e, t.angle), t) ? e.set(0, 0, 0, 0) : sa(e, t, !0)
+    }
+    var SX = {
+        type: "path",
+        tag: "path",
+        nested: !1,
+        attr: _X,
+        bound: wX,
+        draw: cS(Tp),
+        pick: fS(Tp),
+        isect: oS(Tp)
     };
 
-    function nY(e) {
-        return new FR(e)
+    function EX(e, t) {
+        e("d", Jc(null, t))
     }
 
-    function r$(e) {
-        return e < 0 ? -1 : 1
+    function kX(e, t) {
+        var n, i;
+        return sa(e.set(n = t.x || 0, i = t.y || 0, n + t.width || 0, i + t.height || 0), t)
     }
 
-    function s$(e, t, n) {
-        var i = e._x1 - e._x0,
-            r = t - e._x1,
-            s = (e._y1 - e._y0) / (i || r < 0 && -0),
-            a = (n - e._y1) / (r || i < 0 && -0),
-            o = (s * r + a * i) / (i + r);
-        return (r$(s) + r$(a)) * Math.min(Math.abs(s), Math.abs(a), .5 * Math.abs(o)) || 0
+    function k$(e, t) {
+        e.beginPath(), Jc(e, t)
     }
+    var CX = {
+        type: "rect",
+        tag: "path",
+        nested: !1,
+        attr: EX,
+        bound: kX,
+        draw: cS(k$),
+        pick: fS(k$),
+        isect: XN
+    };
 
-    function a$(e, t) {
-        var n = e._x1 - e._x0;
-        return n ? (3 * (e._y1 - e._y0) / n - t) / 2 : t
+    function AX(e, t) {
+        e("transform", QN(t)), e("x2", t.x2 != null ? t.x2 - (t.x || 0) : 0), e("y2", t.y2 != null ? t.y2 - (t.y || 0) : 0)
     }
 
-    function qy(e, t, n) {
-        var i = e._x0,
-            r = e._y0,
-            s = e._x1,
-            a = e._y1,
-            o = (s - i) / 3;
-        e._context.bezierCurveTo(i + o, r + o * t, s - o, a - o * n, s, a)
+    function $X(e, t) {
+        var n, i;
+        return sa(e.set(n = t.x || 0, i = t.y || 0, t.x2 != null ? t.x2 : n, t.y2 != null ? t.y2 : i), t)
     }
 
-    function a0(e) {
-        this._context = e
+    function nP(e, t, n) {
+        var i, r, s, a;
+        return t.stroke && mc(e, t, n) ? (i = t.x || 0, r = t.y || 0, s = t.x2 != null ? t.x2 : i, a = t.y2 != null ? t.y2 : r, e.beginPath(), e.moveTo(i, r), e.lineTo(s, a), !0) : !1
     }
-    a0.prototype = {
-        areaStart: function() {
-            this._line = 0
-        },
-        areaEnd: function() {
-            this._line = NaN
-        },
-        lineStart: function() {
-            this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN, this._point = 0
-        },
-        lineEnd: function() {
-            switch (this._point) {
-                case 2:
-                    this._context.lineTo(this._x1, this._y1);
-                    break;
-                case 3:
-                    qy(this, this._t0, a$(this, this._t0));
-                    break
-            }(this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line
-        },
-        point: function(e, t) {
-            var n = NaN;
-            if (e = +e, t = +t, !(e === this._x1 && t === this._y1)) {
-                switch (this._point) {
-                    case 0:
-                        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
-                        break;
-                    case 1:
-                        this._point = 2;
-                        break;
-                    case 2:
-                        this._point = 3, qy(this, a$(this, n = s$(this, e, t)), n);
-                        break;
-                    default:
-                        qy(this, this._t0, n = s$(this, e, t));
-                        break
-                }
-                this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t, this._t0 = n
+
+    function TX(e, t, n) {
+        $r(t, i => {
+            if (!(n && !n.intersects(i.bounds))) {
+                var r = i.opacity == null ? 1 : i.opacity;
+                r && nP(e, i, r) && (pc(e, i), e.stroke())
             }
-        }
-    };
+        })
+    }
 
-    function RR(e) {
-        this._context = new DR(e)
-    }(RR.prototype = Object.create(a0.prototype)).point = function(e, t) {
-        a0.prototype.point.call(this, t, e)
+    function MX(e, t, n, i) {
+        return e.isPointInStroke ? nP(e, t, 1) && e.isPointInStroke(n, i) : !1
+    }
+    var OX = {
+            type: "rule",
+            tag: "line",
+            nested: !1,
+            attr: AX,
+            bound: $X,
+            draw: TX,
+            pick: S1(MX),
+            isect: VN
+        },
+        FX = dS("shape", zY),
+        RX = dS("symbol", BY, lS);
+    const C$ = cF();
+    var wr = {
+        height: ms,
+        measureWidth: vS,
+        estimateWidth: m2,
+        width: m2,
+        canvas: iP
     };
+    iP(!0);
 
-    function DR(e) {
-        this._context = e
+    function iP(e) {
+        wr.width = e && Ya ? vS : m2
     }
-    DR.prototype = {
-        moveTo: function(e, t) {
-            this._context.moveTo(t, e)
-        },
-        closePath: function() {
-            this._context.closePath()
-        },
-        lineTo: function(e, t) {
-            this._context.lineTo(t, e)
-        },
-        bezierCurveTo: function(e, t, n, i, r, s) {
-            this._context.bezierCurveTo(t, e, i, n, s, r)
-        }
-    };
 
-    function iY(e) {
-        return new a0(e)
+    function m2(e, t) {
+        return rP(ro(e, t), ms(e))
     }
 
-    function rY(e) {
-        return new RR(e)
+    function rP(e, t) {
+        return ~~(.8 * e.length * t)
     }
 
-    function NR(e) {
-        this._context = e
+    function vS(e, t) {
+        return ms(e) <= 0 || !(t = ro(e, t)) ? 0 : sP(t, C1(e))
     }
-    NR.prototype = {
-        areaStart: function() {
-            this._line = 0
-        },
-        areaEnd: function() {
-            this._line = NaN
-        },
-        lineStart: function() {
-            this._x = [], this._y = []
-        },
-        lineEnd: function() {
-            var e = this._x,
-                t = this._y,
-                n = e.length;
-            if (n)
-                if (this._line ? this._context.lineTo(e[0], t[0]) : this._context.moveTo(e[0], t[0]), n === 2) this._context.lineTo(e[1], t[1]);
-                else
-                    for (var i = o$(e), r = o$(t), s = 0, a = 1; a < n; ++s, ++a) this._context.bezierCurveTo(i[0][s], r[0][s], i[1][s], r[1][s], e[a], t[a]);
-            (this._line || this._line !== 0 && n === 1) && this._context.closePath(), this._line = 1 - this._line, this._x = this._y = null
-        },
-        point: function(e, t) {
-            this._x.push(+e), this._y.push(+t)
-        }
-    };
 
-    function o$(e) {
-        var t, n = e.length - 1,
-            i, r = new Array(n),
-            s = new Array(n),
-            a = new Array(n);
-        for (r[0] = 0, s[0] = 2, a[0] = e[0] + 2 * e[1], t = 1; t < n - 1; ++t) r[t] = 1, s[t] = 4, a[t] = 4 * e[t] + 2 * e[t + 1];
-        for (r[n - 1] = 2, s[n - 1] = 7, a[n - 1] = 8 * e[n - 1] + e[n], t = 1; t < n; ++t) i = r[t] / s[t - 1], s[t] -= i, a[t] -= i * a[t - 1];
-        for (r[n - 1] = a[n - 1] / s[n - 1], t = n - 2; t >= 0; --t) r[t] = (a[t] - r[t + 1]) / s[t];
-        for (s[n - 1] = (e[n] + r[n - 1]) / 2, t = 0; t < n - 1; ++t) s[t] = 2 * e[t + 1] - r[t + 1];
-        return [r, s]
+    function sP(e, t) {
+        const n = `(${t}) ${e}`;
+        let i = C$.get(n);
+        return i === void 0 && (Ya.font = t, i = Ya.measureText(e).width, C$.set(n, i)), i
     }
 
-    function sY(e) {
-        return new NR(e)
+    function ms(e) {
+        return e.fontSize != null ? +e.fontSize || 0 : 11
     }
 
-    function Sm(e, t) {
-        this._context = e, this._t = t
+    function io(e) {
+        return e.lineHeight != null ? e.lineHeight : ms(e) + 2
     }
-    Sm.prototype = {
-        areaStart: function() {
-            this._line = 0
-        },
-        areaEnd: function() {
-            this._line = NaN
-        },
-        lineStart: function() {
-            this._x = this._y = NaN, this._point = 0
-        },
-        lineEnd: function() {
-            0 < this._t && this._t < 1 && this._point === 2 && this._context.lineTo(this._x, this._y), (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line >= 0 && (this._t = 1 - this._t, this._line = 1 - this._line)
-        },
-        point: function(e, t) {
-            switch (e = +e, t = +t, this._point) {
-                case 0:
-                    this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
-                    break;
-                case 1:
-                    this._point = 2;
-                default: {
-                    if (this._t <= 0) this._context.lineTo(this._x, t), this._context.lineTo(e, t);
-                    else {
-                        var n = this._x * (1 - this._t) + e * this._t;
-                        this._context.lineTo(n, this._y), this._context.lineTo(n, t)
-                    }
-                    break
-                }
-            }
-            this._x = e, this._y = t
-        }
-    };
 
-    function aY(e) {
-        return new Sm(e, .5)
+    function DX(e) {
+        return H(e) ? e.length > 1 ? e : e[0] : e
     }
 
-    function oY(e) {
-        return new Sm(e, 0)
+    function Wd(e) {
+        return DX(e.lineBreak && e.text && !H(e.text) ? e.text.split(e.lineBreak) : e.text)
     }
 
-    function lY(e) {
-        return new Sm(e, 1)
+    function bS(e) {
+        const t = Wd(e);
+        return (H(t) ? t.length - 1 : 0) * io(e)
     }
 
-    function Of(e, t, n) {
-        this.k = e, this.x = t, this.y = n
+    function ro(e, t) {
+        const n = t == null ? "" : (t + "").trim();
+        return e.limit > 0 && n.length ? PX(e, n) : n
     }
-    Of.prototype = {
-        constructor: Of,
-        scale: function(e) {
-            return e === 1 ? this : new Of(this.k * e, this.x, this.y)
-        },
-        translate: function(e, t) {
-            return e === 0 & t === 0 ? this : new Of(this.k, this.x + this.k * e, this.y + this.k * t)
-        },
-        apply: function(e) {
-            return [e[0] * this.k + this.x, e[1] * this.k + this.y]
-        },
-        applyX: function(e) {
-            return e * this.k + this.x
-        },
-        applyY: function(e) {
-            return e * this.k + this.y
-        },
-        invert: function(e) {
-            return [(e[0] - this.x) / this.k, (e[1] - this.y) / this.k]
-        },
-        invertX: function(e) {
-            return (e - this.x) / this.k
-        },
-        invertY: function(e) {
-            return (e - this.y) / this.k
-        },
-        rescaleX: function(e) {
-            return e.copy().domain(e.range().map(this.invertX, this).map(e.invert, e))
-        },
-        rescaleY: function(e) {
-            return e.copy().domain(e.range().map(this.invertY, this).map(e.invert, e))
-        },
-        toString: function() {
-            return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")"
-        }
-    };
-    Of.prototype;
-    /**
-    @copyright CEA-LIST/DIASI/SIALV/LVA (2023)
-    @author CEA-LIST/DIASI/SIALV/LVA <pixano@cea.fr>
-    @license CECILL-C
 
-    This software is a collaborative computer program whose purpose is to
-    generate and explore labeled data for computer vision applications.
-    This software is governed by the CeCILL-C license under French law and
-    abiding by the rules of distribution of free software. You can use, 
-    modify and/ or redistribute the software under the terms of the CeCILL-C
-    license as circulated by CEA, CNRS and INRIA at the following URL
-
-    http://www.cecill.info
-    */
-    function uY(e) {
-        return dm().domain(e).range(OB)
+    function NX(e) {
+        if (wr.width === vS) {
+            const t = C1(e);
+            return n => sP(n, t)
+        } else {
+            const t = ms(e);
+            return n => rP(n, t)
+        }
     }
 
-    function l$(e, t, n) {
-        const i = e.slice();
-        return i[23] = t[n], i
+    function PX(e, t) {
+        var n = +e.limit,
+            i = NX(e);
+        if (i(t) < n) return t;
+        var r = e.ellipsis || "…",
+            s = e.dir === "rtl",
+            a = 0,
+            o = t.length,
+            l;
+        if (n -= i(r), s) {
+            for (; a < o;) l = a + o >>> 1, i(t.slice(l)) > n ? a = l + 1 : o = l;
+            return r + t.slice(a)
+        } else {
+            for (; a < o;) l = 1 + (a + o >>> 1), i(t.slice(0, l)) < n ? a = l : o = l - 1;
+            return t.slice(0, a) + r
+        }
     }
 
-    function u$(e, t, n) {
-        const i = e.slice();
-        return i[26] = t[n], i
+    function qd(e, t) {
+        var n = e.font;
+        return (t && n ? String(n).replace(/"/g, "'") : n) || "sans-serif"
     }
 
-    function c$(e) {
-        let t, n, i, r, s = e[0].id + "",
-            a;
-        return {
-            c() {
-                t = J("div"), n = J("span"), n.textContent = "Id :", i = Ee(), r = J("span"), a = Je(s), j(n, "class", "font-bold")
-            },
-            m(o, l) {
-                we(o, t, l), G(t, n), G(t, i), G(t, r), G(r, a)
-            },
-            p(o, l) {
-                l & 1 && s !== (s = o[0].id + "") && Ot(a, s)
-            },
-            d(o) {
-                o && _e(t)
-            }
-        }
+    function C1(e, t) {
+        return (e.fontStyle ? e.fontStyle + " " : "") + (e.fontVariant ? e.fontVariant + " " : "") + (e.fontWeight ? e.fontWeight + " " : "") + ms(e) + "px " + qd(e, t)
     }
 
-    function f$(e) {
-        let t, n, i, r, s = e[0].filename + "",
-            a;
-        return {
-            c() {
-                t = J("div"), n = J("span"), n.textContent = "Filename :", i = Ee(), r = J("span"), a = Je(s), j(n, "class", "font-bold")
-            },
-            m(o, l) {
-                we(o, t, l), G(t, n), G(t, i), G(t, r), G(r, a)
-            },
-            p(o, l) {
-                l & 1 && s !== (s = o[0].filename + "") && Ot(a, s)
-            },
-            d(o) {
-                o && _e(t)
-            }
-        }
+    function xS(e) {
+        var t = e.baseline,
+            n = ms(e);
+        return Math.round(t === "top" ? .79 * n : t === "middle" ? .3 * n : t === "bottom" ? -.21 * n : t === "line-top" ? .29 * n + .5 * io(e) : t === "line-bottom" ? .29 * n - .5 * io(e) : 0)
     }
+    const LX = {
+            left: "start",
+            center: "middle",
+            right: "end"
+        },
+        Eh = new Ut;
 
-    function h$(e) {
-        let t, n, i, r, s = e[0].width + "",
-            a, o, l = e[0].height + "",
-            u, c;
-        return {
-            c() {
-                t = J("div"), n = J("span"), n.textContent = "Size :", i = Ee(), r = J("span"), a = Je(s), o = Je("x"), u = Je(l), c = Je("px"), j(n, "class", "font-bold")
-            },
-            m(f, h) {
-                we(f, t, h), G(t, n), G(t, i), G(t, r), G(r, a), G(r, o), G(r, u), G(r, c)
-            },
-            p(f, h) {
-                h & 1 && s !== (s = f[0].width + "") && Ot(a, s), h & 1 && l !== (l = f[0].height + "") && Ot(u, l)
-            },
-            d(f) {
-                f && _e(t)
-            }
-        }
+    function A1(e) {
+        var t = e.x || 0,
+            n = e.y || 0,
+            i = e.radius || 0,
+            r;
+        return i && (r = (e.theta || 0) - Jo, t += i * Math.cos(r), n += i * Math.sin(r)), Eh.x1 = t, Eh.y1 = n, Eh
     }
 
-    function d$(e) {
-        let t, n = e[0].categoryStats,
-            i = [];
-        for (let r = 0; r < n.length; r += 1) i[r] = p$(u$(e, n, r));
-        return {
-            c() {
-                for (let r = 0; r < i.length; r += 1) i[r].c();
-                t = bl()
-            },
-            m(r, s) {
-                for (let a = 0; a < i.length; a += 1) i[a] && i[a].m(r, s);
-                we(r, t, s)
-            },
-            p(r, s) {
-                if (s & 67) {
-                    n = r[0].categoryStats;
-                    let a;
-                    for (a = 0; a < n.length; a += 1) {
-                        const o = u$(r, n, a);
-                        i[a] ? i[a].p(o, s) : (i[a] = p$(o), i[a].c(), i[a].m(t.parentNode, t))
-                    }
-                    for (; a < i.length; a += 1) i[a].d(1);
-                    i.length = n.length
-                }
-            },
-            d(r) {
-                Vo(i, r), r && _e(t)
-            }
-        }
+    function IX(e, t) {
+        var n = t.dx || 0,
+            i = (t.dy || 0) + xS(t),
+            r = A1(t),
+            s = r.x1,
+            a = r.y1,
+            o = t.angle || 0,
+            l;
+        e("text-anchor", LX[t.align] || "start"), o ? (l = dl(s, a) + " " + hS(o), (n || i) && (l += " " + dl(n, i))) : l = dl(s + n, a + i), e("transform", l)
     }
 
-    function g$(e) {
-        let t, n = e[26].count + "",
-            i;
-        return {
-            c() {
-                t = J("span"), i = Je(n), j(t, "class", "block absolute -right-3 -top-2 h-fit px-1 text-xs rounded-full bg-rose-500 text-white font-bold")
-            },
-            m(r, s) {
-                we(r, t, s), G(t, i)
-            },
-            p(r, s) {
-                s & 1 && n !== (n = r[26].count + "") && Ot(i, n)
-            },
-            d(r) {
-                r && _e(t)
-            }
-        }
+    function _S(e, t, n) {
+        var i = wr.height(t),
+            r = t.align,
+            s = A1(t),
+            a = s.x1,
+            o = s.y1,
+            l = t.dx || 0,
+            u = (t.dy || 0) + xS(t) - Math.round(.8 * i),
+            c = Wd(t),
+            f;
+        if (H(c) ? (i += io(t) * (c.length - 1), f = c.reduce((h, d) => Math.max(h, wr.width(t, d)), 0)) : f = wr.width(t, c), r === "center" ? l -= f / 2 : r === "right" && (l -= f), e.set(l += a, u += o, l + f, u + i), t.angle && !n) e.rotate(t.angle * no, a, o);
+        else if (n === 2) return e.rotatedPoints(t.angle * no, a, o);
+        return e
     }
 
-    function p$(e) {
-        let t, n = e[26].name + "",
-            i, r, s, a, o, l, u = e[26].count != 1 && g$(e);
-
-        function c() {
-            return e[14](e[26])
-        }
-        return {
-            c() {
-                t = J("button"), i = Je(n), r = Ee(), u && u.c(), s = Ee(), j(t, "class", "relative px-1 mb-2 mr-4 rounded-lg text-sm text-zinc-900 font-bold border-2 border-transparent hover:border-rose-500"), KC(t, "background-color", e[1](e[26].id)), j(t, "id", a = "cat-" + e[26].id)
-            },
-            m(f, h) {
-                we(f, t, h), G(t, i), G(t, r), u && u.m(t, null), G(t, s), o || (l = wt(t, "click", c), o = !0)
-            },
-            p(f, h) {
-                e = f, h & 1 && n !== (n = e[26].name + "") && Ot(i, n), e[26].count != 1 ? u ? u.p(e, h) : (u = g$(e), u.c(), u.m(t, s)) : u && (u.d(1), u = null), h & 3 && KC(t, "background-color", e[1](e[26].id)), h & 1 && a !== (a = "cat-" + e[26].id) && j(t, "id", a)
-            },
-            d(f) {
-                f && _e(t), u && u.d(), o = !1, l()
+    function zX(e, t, n) {
+        $r(t, i => {
+            var r = i.opacity == null ? 1 : i.opacity,
+                s, a, o, l, u, c, f;
+            if (!(n && !n.intersects(i.bounds) || r === 0 || i.fontSize <= 0 || i.text == null || i.text.length === 0)) {
+                if (e.font = C1(i), e.textAlign = i.align || "left", s = A1(i), a = s.x1, o = s.y1, i.angle && (e.save(), e.translate(a, o), e.rotate(i.angle * no), a = o = 0), a += i.dx || 0, o += (i.dy || 0) + xS(i), c = Wd(i), pc(e, i), H(c))
+                    for (u = io(i), l = 0; l < c.length; ++l) f = ro(i, c[l]), i.fill && _m(e, i, r) && e.fillText(f, a, o), i.stroke && mc(e, i, r) && e.strokeText(f, a, o), o += u;
+                else f = ro(i, c), i.fill && _m(e, i, r) && e.fillText(f, a, o), i.stroke && mc(e, i, r) && e.strokeText(f, a, o);
+                i.angle && e.restore()
             }
-        }
+        })
     }
 
-    function m$(e) {
-        let t, n, i, r, s, a, o, l, u, c, f, h, d, g = e[1] != null && y$(e);
-        return {
-            c() {
-                t = J("div"), n = J("span"), n.textContent = "Views", i = Ee(), r = J("div"), s = J("input"), a = Ee(), o = J("label"), o.textContent = "Show all views", l = Ee(), u = J("span"), u.textContent = "Views :", c = Ee(), f = J("div"), g && g.c(), j(n, "class", "mb-2 self-center text-center text-sm text-zinc-500 font-medium uppercase dark:text-zinc-400"), j(s, "class", "cursor-pointer checked:accent-rose-500"), j(s, "type", "checkbox"), j(s, "id", "toggle-views"), s.checked = !0, j(o, "class", "font-bold cursor-pointer"), j(o, "for", "toggle-views"), j(r, "class", "mb-2 flex items-center space-x-2"), j(t, "class", "mt-2 pt-2 flex flex-col border-t dark:border-zinc-700"), j(u, "class", "font-bold"), j(f, "class", "flex flex-col")
-            },
-            m(p, m) {
-                we(p, t, m), G(t, n), G(t, i), G(t, r), G(r, s), G(r, a), G(r, o), we(p, l, m), we(p, u, m), we(p, c, m), we(p, f, m), g && g.m(f, null), h || (d = wt(s, "change", e[9]), h = !0)
-            },
-            p(p, m) {
-                p[1] != null ? g ? g.p(p, m) : (g = y$(p), g.c(), g.m(f, null)) : g && (g.d(1), g = null)
-            },
-            d(p) {
-                p && _e(t), p && _e(l), p && _e(u), p && _e(c), p && _e(f), g && g.d(), h = !1, d()
-            }
-        }
+    function BX(e, t, n, i, r, s) {
+        if (t.fontSize <= 0) return !1;
+        if (!t.angle) return !0;
+        var a = A1(t),
+            o = a.x1,
+            l = a.y1,
+            u = _S(Eh, t, 1),
+            c = -t.angle * no,
+            f = Math.cos(c),
+            h = Math.sin(c),
+            d = f * r - h * s + (o - f * o + h * l),
+            g = h * r + f * s + (l - h * o - f * l);
+        return u.contains(d, g)
     }
 
-    function y$(e) {
-        let t, n = Object.keys(e[0].views),
-            i = [];
-        for (let r = 0; r < n.length; r += 1) i[r] = v$(l$(e, n, r));
-        return {
-            c() {
-                for (let r = 0; r < i.length; r += 1) i[r].c();
-                t = bl()
-            },
-            m(r, s) {
-                for (let a = 0; a < i.length; a += 1) i[a] && i[a].m(r, s);
-                we(r, t, s)
-            },
-            p(r, s) {
-                if (s & 257) {
-                    n = Object.keys(r[0].views);
-                    let a;
-                    for (a = 0; a < n.length; a += 1) {
-                        const o = l$(r, n, a);
-                        i[a] ? i[a].p(o, s) : (i[a] = v$(o), i[a].c(), i[a].m(t.parentNode, t))
-                    }
-                    for (; a < i.length; a += 1) i[a].d(1);
-                    i.length = n.length
-                }
-            },
-            d(r) {
-                Vo(i, r), r && _e(t)
-            }
-        }
+    function jX(e, t) {
+        const n = _S(Eh, e, 2);
+        return Lu(t, n[0], n[1], n[2], n[3]) || Lu(t, n[0], n[1], n[4], n[5]) || Lu(t, n[4], n[5], n[6], n[7]) || Lu(t, n[2], n[3], n[6], n[7])
     }
+    var GX = {
+            type: "text",
+            tag: "text",
+            nested: !1,
+            attr: IX,
+            bound: _S,
+            draw: zX,
+            pick: S1(BX),
+            isect: jX
+        },
+        UX = gS("trail", jY, tX),
+        Ri = {
+            arc: QY,
+            area: nX,
+            group: pX,
+            image: bX,
+            line: xX,
+            path: SX,
+            rect: CX,
+            rule: OX,
+            shape: FX,
+            symbol: RX,
+            text: GX,
+            trail: UX
+        };
 
-    function v$(e) {
-        let t, n, i, r, s, a = e[23] + "",
-            o, l, u, c, f;
-
-        function h() {
-            return e[15](e[23])
-        }
-        return {
-            c() {
-                t = J("div"), n = J("input"), r = Ee(), s = J("label"), o = Je(a), u = Ee(), j(n, "class", "cursor-pointer checked:accent-rose-500"), j(n, "type", "checkbox"), j(n, "id", i = "view-" + e[23]), n.checked = !0, j(s, "class", "font-medium cursor-pointer"), j(s, "for", l = "view-" + e[23]), j(t, "class", "ml-1 flex items-center space-x-2")
-            },
-            m(d, g) {
-                we(d, t, g), G(t, n), G(t, r), G(t, s), G(s, o), G(t, u), c || (f = wt(n, "change", h), c = !0)
-            },
-            p(d, g) {
-                e = d, g & 1 && i !== (i = "view-" + e[23]) && j(n, "id", i), g & 1 && a !== (a = e[23] + "") && Ot(o, a), g & 1 && l !== (l = "view-" + e[23]) && j(s, "for", l)
-            },
-            d(d) {
-                d && _e(t), c = !1, f()
-            }
-        }
+    function y2(e, t, n) {
+        var i = Ri[e.mark.marktype],
+            r = t || i.bound;
+        return i.nested && (e = e.mark), r(e.bounds || (e.bounds = new Ut), e, n)
     }
+    var A$ = {
+        mark: null
+    };
 
-    function cY(e) {
-        let t, n, i, r, s, a, o, l, u, c, f, h, d, g, p, m, y, v, b, x, _, S, w, E, A, C = e[3] * 100 + "",
-            k, R, $, T, M, F, N, P, z, I, Q, oe, Se, ye, Pe, xt = Object.keys(e[0].views).length != 1,
-            rn, Un, Y = e[0].id && c$(e),
-            ue = e[0].filename && f$(e),
-            be = e[0].width && e[0].height && h$(e),
-            q = e[1] != null && d$(e),
-            ze = xt && m$(e);
-        return {
-            c() {
-                t = J("div"), n = Ee(), i = J("div"), r = J("div"), s = J("span"), s.textContent = "Data", a = Ee(), o = J("div"), Y && Y.c(), l = Ee(), ue && ue.c(), u = Ee(), be && be.c(), c = Ee(), f = J("div"), h = J("span"), h.textContent = "Tools", d = Ee(), g = J("div"), p = J("input"), m = Ee(), y = J("label"), y.textContent = "Show all items", v = Ee(), b = J("div"), x = J("input"), _ = Ee(), S = J("label"), S.textContent = "Show boxes", w = Ee(), E = J("label"), A = Je("Mask opacity : "), k = Je(C), R = Je("%"), $ = Ee(), T = J("input"), M = Ee(), F = J("label"), N = Je("Minimum confidence : "), P = Je(e[4]), z = Ee(), I = J("input"), Q = Ee(), oe = J("span"), oe.textContent = "Categories :", Se = Ee(), ye = J("div"), q && q.c(), Pe = Ee(), ze && ze.c(), j(t, "class", "absolute top-0 left-0 w-full h-full bg-white dark:bg-zinc-800"), j(t, "id", "canvas"), j(s, "class", "mb-2 self-center text-sm text-zinc-500 font-medium uppercase dark:text-zinc-400"), j(o, "class", "flex flex-col"), j(r, "class", "flex flex-col"), j(h, "class", "mb-2 self-center text-center text-sm text-zinc-500 font-medium uppercase dark:text-zinc-400"), j(p, "class", "cursor-pointer checked:accent-rose-500"), j(p, "type", "checkbox"), j(p, "id", "toggle-items"), p.checked = !0, j(y, "class", "font-bold cursor-pointer"), j(y, "for", "toggle-items"), j(g, "class", "mb-2 flex items-center space-x-2"), j(x, "class", "cursor-pointer checked:accent-rose-500"), j(x, "type", "checkbox"), j(x, "id", "toggle-boxes"), j(S, "class", "font-bold cursor-pointer"), j(S, "for", "toggle-boxes"), j(b, "class", "mb-2 flex items-center space-x-2"), j(E, "class", "font-bold mt-2 mb-1"), j(E, "for", "slider"), j(T, "class", "cursor-pointer"), j(T, "type", "range"), j(T, "id", "slider"), j(T, "min", "0"), j(T, "max", "1"), j(T, "step", "0.1"), j(F, "class", "font-bold mt-2 mb-1"), j(F, "for", "slider"), j(I, "class", "cursor-pointer"), j(I, "type", "range"), j(I, "id", "slider"), j(I, "min", "0"), j(I, "max", "1"), j(I, "step", "0.01"), j(f, "class", "mt-2 pt-2 flex flex-col border-t dark:border-zinc-700"), j(oe, "class", "font-bold mb-2 mt-2"), j(ye, "class", "flex flex-wrap"), j(i, "class", "absolute w-64 top-1/2 -translate-y-1/2 right-6 py-2 px-4 flex flex-col bg-white text-zinc-900 border rounded-lg shadow dark:text-zinc-300 dark:bg-zinc-900 dark:border-zinc-500")
-            },
-            m(fe, Be) {
-                we(fe, t, Be), we(fe, n, Be), we(fe, i, Be), G(i, r), G(r, s), G(r, a), G(r, o), Y && Y.m(o, null), G(o, l), ue && ue.m(o, null), G(o, u), be && be.m(o, null), G(i, c), G(i, f), G(f, h), G(f, d), G(f, g), G(g, p), G(g, m), G(g, y), G(f, v), G(f, b), G(b, x), x.checked = e[2], G(b, _), G(b, S), G(f, w), G(f, E), G(E, A), G(E, k), G(E, R), G(f, $), G(f, T), jd(T, e[3]), G(f, M), G(f, F), G(F, N), G(F, P), G(f, z), G(f, I), jd(I, e[4]), G(i, Q), G(i, oe), G(i, Se), G(i, ye), q && q.m(ye, null), G(i, Pe), ze && ze.m(i, null), rn || (Un = [wt(p, "change", e[7]), wt(x, "change", e[11]), wt(x, "change", e[10]), wt(T, "change", e[12]), wt(T, "input", e[12]), wt(T, "input", e[5]), wt(I, "change", e[13]), wt(I, "input", e[13]), wt(I, "input", e[10])], rn = !0)
-            },
-            p(fe, [Be]) {
-                fe[0].id ? Y ? Y.p(fe, Be) : (Y = c$(fe), Y.c(), Y.m(o, l)) : Y && (Y.d(1), Y = null), fe[0].filename ? ue ? ue.p(fe, Be) : (ue = f$(fe), ue.c(), ue.m(o, u)) : ue && (ue.d(1), ue = null), fe[0].width && fe[0].height ? be ? be.p(fe, Be) : (be = h$(fe), be.c(), be.m(o, null)) : be && (be.d(1), be = null), Be & 4 && (x.checked = fe[2]), Be & 8 && C !== (C = fe[3] * 100 + "") && Ot(k, C), Be & 8 && jd(T, fe[3]), Be & 16 && Ot(P, fe[4]), Be & 16 && jd(I, fe[4]), fe[1] != null ? q ? q.p(fe, Be) : (q = d$(fe), q.c(), q.m(ye, null)) : q && (q.d(1), q = null), Be & 1 && (xt = Object.keys(fe[0].views).length != 1), xt ? ze ? ze.p(fe, Be) : (ze = m$(fe), ze.c(), ze.m(i, null)) : ze && (ze.d(1), ze = null)
-            },
-            i: Ve,
-            o: Ve,
-            d(fe) {
-                fe && _e(t), fe && _e(n), fe && _e(i), Y && Y.d(), ue && ue.d(), be && be.d(), q && q.d(), ze && ze.d(), rn = !1, js(Un)
-            }
-        }
+    function aP(e, t, n) {
+        var i = Ri[e.marktype],
+            r = i.bound,
+            s = e.items,
+            a = s && s.length,
+            o, l, u, c;
+        if (i.nested) return a ? u = s[0] : (A$.mark = e, u = A$), c = y2(u, r, n), t = t && t.union(c) || c, t;
+        if (t = t || e.bounds && e.bounds.clear() || new Ut, a)
+            for (o = 0, l = s.length; o < l; ++o) t.union(y2(s[o], r, n));
+        return e.bounds = t
     }
+    const WX = ["marktype", "name", "role", "interactive", "clip", "items", "zindex", "x", "y", "width", "height", "align", "baseline", "fill", "fillOpacity", "opacity", "blend", "stroke", "strokeOpacity", "strokeWidth", "strokeCap", "strokeDash", "strokeDashOffset", "strokeForeground", "strokeOffset", "startAngle", "endAngle", "innerRadius", "outerRadius", "cornerRadius", "padAngle", "cornerRadiusTopLeft", "cornerRadiusTopRight", "cornerRadiusBottomLeft", "cornerRadiusBottomRight", "interpolate", "tension", "orient", "defined", "url", "aspect", "smooth", "path", "scaleX", "scaleY", "x2", "y2", "size", "shape", "text", "angle", "theta", "radius", "dir", "dx", "dy", "ellipsis", "limit", "lineBreak", "lineHeight", "font", "fontSize", "fontWeight", "fontStyle", "fontVariant", "description", "aria", "ariaRole", "ariaRoleDescription"];
 
-    function fY(e, t, n) {
-        let {
-            features: i
-        } = t, r, s = null, a, o = {
-            rows: 0,
-            cols: 0
-        }, l = !0, u = .5, c = .5, f = [], h = [];
-
-        function d() {
-            a.children.forEach(C => {
-                for (const k of C.children) k.name() === "masks" && $B(k, u)
-            })
-        }
-
-        function g(C) {
-            if (f.includes(C)) {
-                const k = f.indexOf(C);
-                k > -1 && f.splice(k, 1)
-            } else f.push(C);
-            v()
-        }
-
-        function p() {
-            f.length == 0 ? i.categoryStats.forEach(C => f.push(C.id)) : f = [], v()
-        }
-
-        function m(C) {
-            if (h.includes(C)) {
-                const k = h.indexOf(C);
-                k > -1 && h.splice(k, 1)
-            } else h.push(C);
-            v()
-        }
-
-        function y() {
-            h.length == 0 ? Object.keys(i.views).forEach(C => h.push(C)) : h = [], v()
-        }
+    function oP(e, t) {
+        return JSON.stringify(e, WX, t)
+    }
 
-        function v() {
-            a.children.forEach(C => {
-                h.includes(C.name()) ? C.hide() : C.show(), C.children.forEach(k => {
-                    (k.name() == "boxes" || k.name() == "tooltips") && (l ? k.show() : k.hide()), k.children.forEach(R => {
-                        let $ = R.id(),
-                            T = parseInt($.replace("category-", "")),
-                            M = parseFloat($.replace("category-" + T + "-", ""));
-                        f.includes(T) || M < c ? R.hide() : R.show()
-                    })
-                })
-            }), b()
-        }
+    function lP(e) {
+        const t = typeof e == "string" ? JSON.parse(e) : e;
+        return uP(t)
+    }
 
-        function b() {
-            document.getElementById("toggle-items").checked = f.length == 0, Object.keys(i.views).length > 1 && (document.getElementById("toggle-views").checked = h.length == 0, Object.keys(i.views).forEach(C => {
-                document.getElementById(`view-${C}`).checked = !h.includes(C)
-            })), i.categoryStats.forEach(C => {
-                let k = document.getElementById(`cat-${C.id}`);
-                f.includes(C.id) ? k.classList.add("grayscale") : k.classList.remove("grayscale")
-            })
-        }
+    function uP(e) {
+        var t = e.marktype,
+            n = e.items,
+            i, r, s;
+        if (n)
+            for (r = 0, s = n.length; r < s; ++r) i = t ? "mark" : "group", n[r][i] = e, n[r].zindex && (n[r][i].zdirty = !0), (t || i) === "group" && uP(n[r]);
+        return t && aP(e), e
+    }
 
-        function x() {
-            wB(a);
-            let C = window.innerWidth / o.cols,
-                k = window.innerHeight / o.rows,
-                R = {
-                    col: 0,
-                    row: 0
-                };
-            for (const [$, T] of Object.entries(i.views)) {
-                let M;
-                for (const Q of a.children) $ === Q.name() && (M = Q);
-                let F = new cn.Group({
-                        name: "images"
-                    }),
-                    N = new cn.Group({
-                        name: "boxes"
-                    }),
-                    P = new cn.Group({
-                        name: "masks"
-                    }),
-                    z = new cn.Group({
-                        name: "tooltips"
-                    });
-                const I = new Image;
-                I.onload = () => {
-                    let Q = C / I.width,
-                        oe = k / I.height,
-                        Se = Math.min(Q, oe),
-                        ye = {
-                            width: I.width * Se,
-                            height: I.height * Se
-                        },
-                        Pe = {
-                            x: C * R.col + (C - I.width * Se) / 2,
-                            y: k * R.row + (k - I.height * Se) / 2
-                        };
-                    kB(F, I, Pe, Se);
-                    for (let xt = 0; xt < T.objects.boundingBox.length; ++xt) {
-                        let rn = T.objects.category[xt],
-                            Un = `category-${rn.id}-`;
-                        if (T.objects.boundingBox[xt]) {
-                            let Y = T.objects.boundingBox[xt];
-                            if (Y.width != 0 && Y.height != 0) {
-                                let ue = xB(Y, ye, Pe);
-                                EB(Un + (Y.is_predict ? Y.confidence : 1), N, ue, s(rn.id), Y.is_predict), SB(Un + (Y.is_predict ? Y.confidence : 1), z, rn.name + (Y.is_predict ? " " + Y.confidence.toString() : ""), {
-                                    x: ue.x,
-                                    y: ue.y
-                                }, s(rn.id))
-                            }
-                        }
-                        if (T.objects.segmentation[xt]) {
-                            let Y = T.objects.segmentation[xt],
-                                ue = _B(Y, ye, Pe);
-                            CB(Un + 1, P, ue, s(rn.id))
-                        }
-                    }
-                    M.add(F), M.add(N), M.add(z), M.add(P), AB(M, $, Pe), a.draw(), R.col == o.cols - 1 ? (R.col = 0, R.row++) : R.col++, v()
-                }, I.src = T.image
-            }
+    function wS(e) {
+        arguments.length ? this.root = lP(e) : (this.root = cP({
+            marktype: "group",
+            name: "root",
+            role: "frame"
+        }), this.root.items = [new _1(this.root)])
+    }
+    wS.prototype = {
+        toJSON(e) {
+            return oP(this.root, e || 0)
+        },
+        mark(e, t, n) {
+            t = t || this.root.items[0];
+            const i = cP(e, t);
+            return t.items[n] = i, i.zindex && (i.group.zdirty = !0), i
         }
-        Z0(() => {
-            a = new cn.Stage({
-                height: window.innerHeight,
-                width: window.innerWidth,
-                container: "canvas"
-            }), Object.keys(i.views).forEach(C => {
-                let k = new cn.Layer({
-                    name: C,
-                    draggable: !0
-                });
-                k.on("dblclick", k.moveToTop), k.on("mouseenter", () => a.container().style.cursor = "move"), k.on("mouseleave", () => a.container().style.cursor = "default"), a.add(k)
-            }), a.on("wheel", C => {
-                C.evt.preventDefault();
-                let k = C.evt.deltaY < 0 ? 1 : -1;
-                C.evt.ctrlKey && (k = -k), TB(a, k)
-            })
-        }), j8(() => {
-            if (i.id != r) {
-                n(1, s = uY(i.categoryStats.map(k => k.id)));
-                let C = Object.keys(i.views).length;
-                o.cols = Math.ceil(Math.sqrt(C)), o.rows = Math.ceil(C / o.cols)
-            }
-        }), U8(() => {
-            i.id != r && (r = i.id, x())
-        });
+    };
 
-        function _() {
-            l = this.checked, n(2, l)
-        }
+    function cP(e, t) {
+        const n = {
+            bounds: new Ut,
+            clip: !!e.clip,
+            group: t,
+            interactive: e.interactive !== !1,
+            items: [],
+            marktype: e.marktype,
+            name: e.name || void 0,
+            role: e.role || void 0,
+            zindex: e.zindex || 0
+        };
+        return e.aria != null && (n.aria = e.aria), e.description && (n.description = e.description), n
+    }
 
-        function S() {
-            u = VC(this.value), n(3, u)
-        }
+    function Ra(e, t, n) {
+        return !e && typeof document < "u" && document.createElement && (e = document), e ? n ? e.createElementNS(n, t) : e.createElement(t) : null
+    }
 
-        function w() {
-            c = VC(this.value), n(4, c)
-        }
-        const E = C => g(C.id),
-            A = C => m(C);
-        return e.$$set = C => {
-            "features" in C && n(0, i = C.features)
-        }, [i, s, l, u, c, d, g, p, m, y, v, _, S, w, E, A]
+    function SS(e, t) {
+        t = t.toLowerCase();
+        for (var n = e.childNodes, i = 0, r = n.length; i < r; ++i)
+            if (n[i].tagName.toLowerCase() === t) return n[i]
     }
-    class hY extends wn {
-        constructor(t) {
-            super(), _n(this, t, fY, cY, tn, {
-                features: 0
-            })
-        }
+
+    function ri(e, t, n, i) {
+        var r = e.childNodes[t],
+            s;
+        return (!r || r.tagName.toLowerCase() !== n.toLowerCase()) && (s = r || null, r = Ra(e.ownerDocument, n, i), e.insertBefore(r, s)), r
     }
 
-    function dY(e) {
-        let t, n;
-        return {
-            c() {
-                t = J("div"), n = Je(e[0]), j(t, "class", "pl-2 text-zinc-900 dark:text-zinc-50")
-            },
-            m(i, r) {
-                we(i, t, r), G(t, n)
-            },
-            p(i, [r]) {
-                r & 1 && Ot(n, i[0])
-            },
-            i: Ve,
-            o: Ve,
-            d(i) {
-                i && _e(t)
-            }
-        }
+    function dr(e, t) {
+        for (var n = e.childNodes, i = n.length; i > t;) e.removeChild(n[--i]);
+        return e
     }
 
-    function gY(e, t, n) {
-        let {
-            value: i
-        } = t;
-        return e.$$set = r => {
-            "value" in r && n(0, i = r.value)
-        }, [i]
+    function fP(e) {
+        return "mark-" + e.marktype + (e.role ? " role-" + e.role : "") + (e.name ? " " + e.name : "")
     }
-    class pY extends wn {
-        constructor(t) {
-            super(), _n(this, t, gY, dY, tn, {
-                value: 0
-            })
-        }
+
+    function $1(e, t) {
+        const n = t.getBoundingClientRect();
+        return [e.clientX - n.left - (t.clientLeft || 0), e.clientY - n.top - (t.clientTop || 0)]
     }
 
-    function mY(e) {
-        let t, n;
-        return {
-            c() {
-                t = J("div"), n = Je(e[0]), j(t, "class", "pl-2 text-zinc-900 dark:text-zinc-50")
-            },
-            m(i, r) {
-                we(i, t, r), G(t, n)
-            },
-            p(i, [r]) {
-                r & 1 && Ot(n, i[0])
-            },
-            i: Ve,
-            o: Ve,
-            d(i) {
-                i && _e(t)
-            }
+    function qX(e, t, n, i) {
+        var r = e && e.mark,
+            s, a;
+        if (r && (s = Ri[r.marktype]).tip) {
+            for (a = $1(t, n), a[0] -= i[0], a[1] -= i[1]; e = e.mark.group;) a[0] -= e.x || 0, a[1] -= e.y || 0;
+            e = s.tip(r.items, a)
         }
+        return e
     }
 
-    function yY(e, t, n) {
-        let {
-            value: i
-        } = t;
-        return e.$$set = r => {
-            "value" in r && n(0, i = r.value)
-        }, [i]
-    }
-    class vY extends wn {
-        constructor(t) {
-            super(), _n(this, t, yY, mY, tn, {
-                value: 0
-            })
-        }
+    function so(e, t) {
+        this._active = null, this._handlers = {}, this._loader = e || H0(), this._tooltip = t || HX
     }
 
-    function bY(e) {
-        let t, n;
-        return {
-            c() {
-                t = J("img"), j(t, "class", "px-2 h-56 w-56 min-w-[14rem] object-cover"), fh(t.src, n = e[0]) || j(t, "src", n), j(t, "alt", e[0])
-            },
-            m(i, r) {
-                we(i, t, r)
-            },
-            p(i, [r]) {
-                r & 1 && !fh(t.src, n = i[0]) && j(t, "src", n), r & 1 && j(t, "alt", i[0])
-            },
-            i: Ve,
-            o: Ve,
-            d(i) {
-                i && _e(t)
+    function HX(e, t, n, i) {
+        e.element().setAttribute("title", i || "")
+    }
+    so.prototype = {
+        initialize(e, t, n) {
+            return this._el = e, this._obj = n || null, this.origin(t)
+        },
+        element() {
+            return this._el
+        },
+        canvas() {
+            return this._el && this._el.firstChild
+        },
+        origin(e) {
+            return arguments.length ? (this._origin = e || [0, 0], this) : this._origin.slice()
+        },
+        scene(e) {
+            return arguments.length ? (this._scene = e, this) : this._scene
+        },
+        on() {},
+        off() {},
+        _handlerIndex(e, t, n) {
+            for (let i = e ? e.length : 0; --i >= 0;)
+                if (e[i].type === t && (!n || e[i].handler === n)) return i;
+            return -1
+        },
+        handlers(e) {
+            const t = this._handlers,
+                n = [];
+            if (e) n.push(...t[this.eventName(e)]);
+            else
+                for (const i in t) n.push(...t[i]);
+            return n
+        },
+        eventName(e) {
+            const t = e.indexOf(".");
+            return t < 0 ? e : e.slice(0, t)
+        },
+        handleHref(e, t, n) {
+            this._loader.sanitize(n, {
+                context: "href"
+            }).then(i => {
+                const r = new MouseEvent(e.type, e),
+                    s = Ra(null, "a");
+                for (const a in i) s.setAttribute(a, i[a]);
+                s.dispatchEvent(r)
+            }).catch(() => {})
+        },
+        handleTooltip(e, t, n) {
+            if (t && t.tooltip != null) {
+                t = qX(t, e, this.canvas(), this._origin);
+                const i = n && t && t.tooltip || null;
+                this._tooltip.call(this._obj, this, e, t, i)
+            }
+        },
+        getItemBoundingClientRect(e) {
+            const t = this.canvas();
+            if (!t) return;
+            const n = t.getBoundingClientRect(),
+                i = this._origin,
+                r = e.bounds,
+                s = r.width(),
+                a = r.height();
+            let o = r.x1 + i[0] + n.left,
+                l = r.y1 + i[1] + n.top;
+            for (; e.mark && (e = e.mark.group);) o += e.x || 0, l += e.y || 0;
+            return {
+                x: o,
+                y: l,
+                width: s,
+                height: a,
+                left: o,
+                top: l,
+                right: o + s,
+                bottom: l + a
             }
         }
-    }
+    };
 
-    function xY(e, t, n) {
-        let {
-            value: i
-        } = t;
-        return e.$$set = r => {
-            "value" in r && n(0, i = r.value)
-        }, [i]
+    function ys(e) {
+        this._el = null, this._bgcolor = null, this._loader = new aS(e)
     }
-    class _Y extends wn {
-        constructor(t) {
-            super(), _n(this, t, xY, bY, tn, {
-                value: 0
-            })
+    ys.prototype = {
+        initialize(e, t, n, i, r) {
+            return this._el = e, this.resize(t, n, i, r)
+        },
+        element() {
+            return this._el
+        },
+        canvas() {
+            return this._el && this._el.firstChild
+        },
+        background(e) {
+            return arguments.length === 0 ? this._bgcolor : (this._bgcolor = e, this)
+        },
+        resize(e, t, n, i) {
+            return this._width = e, this._height = t, this._origin = n || [0, 0], this._scale = i || 1, this
+        },
+        dirty() {},
+        render(e) {
+            const t = this;
+            return t._call = function() {
+                t._render(e)
+            }, t._call(), t._call = null, t
+        },
+        _render() {},
+        renderAsync(e) {
+            const t = this.render(e);
+            return this._ready ? this._ready.then(() => t) : Promise.resolve(t)
+        },
+        _load(e, t) {
+            var n = this,
+                i = n._loader[e](t);
+            if (!n._ready) {
+                const r = n._call;
+                n._ready = n._loader.ready().then(s => {
+                    s && r(), n._ready = null
+                })
+            }
+            return i
+        },
+        sanitizeURL(e) {
+            return this._load("sanitizeURL", e)
+        },
+        loadImage(e) {
+            return this._load("loadImage", e)
         }
+    };
+    const YX = "keydown",
+        XX = "keypress",
+        VX = "keyup",
+        hP = "dragenter",
+        Mp = "dragleave",
+        dP = "dragover",
+        v2 = "mousedown",
+        KX = "mouseup",
+        Sm = "mousemove",
+        kh = "mouseout",
+        gP = "mouseover",
+        Em = "click",
+        JX = "dblclick",
+        QX = "wheel",
+        pP = "mousewheel",
+        km = "touchstart",
+        Cm = "touchmove",
+        Am = "touchend",
+        ZX = [YX, XX, VX, hP, Mp, dP, v2, KX, Sm, kh, gP, Em, JX, QX, pP, km, Cm, Am],
+        b2 = Sm,
+        td = kh,
+        x2 = Em;
+
+    function Hd(e, t) {
+        so.call(this, e, t), this._down = null, this._touch = null, this._first = !0, this._events = {}
     }
-    /*!
-     * https://github.com/Starcounter-Jack/JSON-Patch
-     * (c) 2017-2022 Joachim Wester
-     * MIT licensed
-     */
-    var wY = globalThis && globalThis.__extends || function() {
-            var e = function(t, n) {
-                return e = Object.setPrototypeOf || {
-                    __proto__: []
-                }
-                instanceof Array && function(i, r) {
-                    i.__proto__ = r
-                } || function(i, r) {
-                    for (var s in r) r.hasOwnProperty(s) && (i[s] = r[s])
-                }, e(t, n)
-            };
-            return function(t, n) {
-                e(t, n);
+    const eV = e => e === km || e === Cm || e === Am ? [km, Cm, Am] : [e];
 
-                function i() {
-                    this.constructor = t
-                }
-                t.prototype = n === null ? Object.create(n) : (i.prototype = n.prototype, new i)
-            }
-        }(),
-        SY = Object.prototype.hasOwnProperty;
+    function $$(e, t) {
+        eV(t).forEach(n => tV(e, n))
+    }
 
-    function Bb(e, t) {
-        return SY.call(e, t)
+    function tV(e, t) {
+        const n = e.canvas();
+        n && !e._events[t] && (e._events[t] = 1, n.addEventListener(t, e[t] ? i => e[t](i) : i => e.fire(t, i)))
     }
 
-    function jb(e) {
-        if (Array.isArray(e)) {
-            for (var t = new Array(e.length), n = 0; n < t.length; n++) t[n] = "" + n;
-            return t
+    function T$(e, t, n) {
+        return function(i) {
+            const r = this._active,
+                s = this.pickEvent(i);
+            s === r ? this.fire(e, i) : ((!r || !r.exit) && this.fire(n, i), this._active = s, this.fire(t, i), this.fire(e, i))
         }
-        if (Object.keys) return Object.keys(e);
-        var i = [];
-        for (var r in e) Bb(e, r) && i.push(r);
-        return i
     }
 
-    function pi(e) {
-        switch (typeof e) {
-            case "object":
-                return JSON.parse(JSON.stringify(e));
-            case "undefined":
-                return null;
-            default:
-                return e
+    function M$(e) {
+        return function(t) {
+            this.fire(e, t), this._active = null
         }
     }
-
-    function Ub(e) {
-        for (var t = 0, n = e.length, i; t < n;) {
-            if (i = e.charCodeAt(t), i >= 48 && i <= 57) {
-                t++;
-                continue
-            }
-            return !1
+    ne(Hd, so, {
+        initialize(e, t, n) {
+            return this._canvas = e && SS(e, "canvas"), [Em, v2, Sm, kh, Mp].forEach(i => $$(this, i)), so.prototype.initialize.call(this, e, t, n)
+        },
+        canvas() {
+            return this._canvas
+        },
+        context() {
+            return this._canvas.getContext("2d")
+        },
+        events: ZX,
+        DOMMouseScroll(e) {
+            this.fire(pP, e)
+        },
+        mousemove: T$(Sm, gP, kh),
+        dragover: T$(dP, hP, Mp),
+        mouseout: M$(kh),
+        dragleave: M$(Mp),
+        mousedown(e) {
+            this._down = this._active, this.fire(v2, e)
+        },
+        click(e) {
+            this._down === this._active && (this.fire(Em, e), this._down = null)
+        },
+        touchstart(e) {
+            this._touch = this.pickEvent(e.changedTouches[0]), this._first && (this._active = this._touch, this._first = !1), this.fire(km, e, !0)
+        },
+        touchmove(e) {
+            this.fire(Cm, e, !0)
+        },
+        touchend(e) {
+            this.fire(Am, e, !0), this._touch = null
+        },
+        fire(e, t, n) {
+            const i = n ? this._touch : this._active,
+                r = this._handlers[e];
+            if (t.vegaType = e, e === x2 && i && i.href ? this.handleHref(t, i, i.href) : (e === b2 || e === td) && this.handleTooltip(t, i, e !== td), r)
+                for (let s = 0, a = r.length; s < a; ++s) r[s].handler.call(this._obj, t, i)
+        },
+        on(e, t) {
+            const n = this.eventName(e),
+                i = this._handlers;
+            return this._handlerIndex(i[n], e, t) < 0 && ($$(this, e), (i[n] || (i[n] = [])).push({
+                type: e,
+                handler: t
+            })), this
+        },
+        off(e, t) {
+            const n = this.eventName(e),
+                i = this._handlers[n],
+                r = this._handlerIndex(i, e, t);
+            return r >= 0 && i.splice(r, 1), this
+        },
+        pickEvent(e) {
+            const t = $1(e, this._canvas),
+                n = this._origin;
+            return this.pick(this._scene, t[0], t[1], t[0] - n[0], t[1] - n[1])
+        },
+        pick(e, t, n, i, r) {
+            const s = this.context();
+            return Ri[e.marktype].pick.call(this, s, e, t, n, i, r)
         }
-        return !0
+    });
+
+    function nV() {
+        return typeof window < "u" && window.devicePixelRatio || 1
     }
+    var iV = nV();
 
-    function ko(e) {
-        return e.indexOf("/") === -1 && e.indexOf("~") === -1 ? e : e.replace(/~/g, "~0").replace(/\//g, "~1")
+    function rV(e, t, n, i, r, s) {
+        const a = typeof HTMLElement < "u" && e instanceof HTMLElement && e.parentNode != null,
+            o = e.getContext("2d"),
+            l = a ? iV : r;
+        e.width = t * l, e.height = n * l;
+        for (const u in s) o[u] = s[u];
+        return a && l !== 1 && (e.style.width = t + "px", e.style.height = n + "px"), o.pixelRatio = l, o.setTransform(l, 0, 0, l, l * i[0], l * i[1]), e
     }
 
-    function PR(e) {
-        return e.replace(/~1/g, "/").replace(/~0/g, "~")
+    function $m(e) {
+        ys.call(this, e), this._options = {}, this._redraw = !1, this._dirty = new Ut, this._tempb = new Ut
     }
+    const O$ = ys.prototype,
+        sV = (e, t, n) => new Ut().set(0, 0, t, n).translate(-e[0], -e[1]);
 
-    function Gb(e) {
-        if (e === void 0) return !0;
-        if (e) {
-            if (Array.isArray(e)) {
-                for (var t = 0, n = e.length; t < n; t++)
-                    if (Gb(e[t])) return !0
-            } else if (typeof e == "object") {
-                for (var i = jb(e), r = i.length, s = 0; s < r; s++)
-                    if (Gb(e[i[s]])) return !0
+    function aV(e, t, n) {
+        return t.expand(1).round(), e.pixelRatio % 1 && t.scale(e.pixelRatio).round().scale(1 / e.pixelRatio), t.translate(-(n[0] % 1), -(n[1] % 1)), e.beginPath(), e.rect(t.x1, t.y1, t.width(), t.height()), e.clip(), t
+    }
+    ne($m, ys, {
+        initialize(e, t, n, i, r, s) {
+            return this._options = s || {}, this._canvas = this._options.externalContext ? null : Ha(1, 1, this._options.type), e && this._canvas && (dr(e, 0).appendChild(this._canvas), this._canvas.setAttribute("class", "marks")), O$.initialize.call(this, e, t, n, i, r)
+        },
+        resize(e, t, n, i) {
+            if (O$.resize.call(this, e, t, n, i), this._canvas) rV(this._canvas, this._width, this._height, this._origin, this._scale, this._options.context);
+            else {
+                const r = this._options.externalContext;
+                r || q("CanvasRenderer is missing a valid canvas or context"), r.scale(this._scale, this._scale), r.translate(this._origin[0], this._origin[1])
             }
+            return this._redraw = !0, this
+        },
+        canvas() {
+            return this._canvas
+        },
+        context() {
+            return this._options.externalContext || (this._canvas ? this._canvas.getContext("2d") : null)
+        },
+        dirty(e) {
+            const t = this._tempb.clear().union(e.bounds);
+            let n = e.mark.group;
+            for (; n;) t.translate(n.x || 0, n.y || 0), n = n.mark.group;
+            this._dirty.union(t)
+        },
+        _render(e) {
+            const t = this.context(),
+                n = this._origin,
+                i = this._width,
+                r = this._height,
+                s = this._dirty,
+                a = sV(n, i, r);
+            t.save();
+            const o = this._redraw || s.empty() ? (this._redraw = !1, a.expand(1)) : aV(t, a.intersect(s), n);
+            return this.clear(-n[0], -n[1], i, r), this.draw(t, e, o), t.restore(), s.clear(), this
+        },
+        draw(e, t, n) {
+            const i = Ri[t.marktype];
+            t.clip && iX(e, t), i.draw.call(this, e, t, n), t.clip && e.restore()
+        },
+        clear(e, t, n, i) {
+            const r = this._options,
+                s = this.context();
+            r.type !== "pdf" && !r.externalContext && s.clearRect(e, t, n, i), this._bgcolor != null && (s.fillStyle = this._bgcolor, s.fillRect(e, t, n, i))
         }
-        return !1
-    }
+    });
 
-    function b$(e, t) {
-        var n = [e];
-        for (var i in t) {
-            var r = typeof t[i] == "object" ? JSON.stringify(t[i], null, 2) : t[i];
-            typeof r < "u" && n.push(i + ": " + r)
-        }
-        return n.join(`
-`)
+    function ES(e, t) {
+        so.call(this, e, t);
+        const n = this;
+        n._hrefHandler = _2(n, (i, r) => {
+            r && r.href && n.handleHref(i, r, r.href)
+        }), n._tooltipHandler = _2(n, (i, r) => {
+            n.handleTooltip(i, r, i.type !== td)
+        })
     }
-    var LR = function(e) {
-            wY(t, e);
-
-            function t(n, i, r, s, a) {
-                var o = this.constructor,
-                    l = e.call(this, b$(n, {
-                        name: i,
-                        index: r,
-                        operation: s,
-                        tree: a
-                    })) || this;
-                return l.name = i, l.index = r, l.operation = s, l.tree = a, Object.setPrototypeOf(l, o.prototype), l.message = b$(n, {
-                    name: i,
-                    index: r,
-                    operation: s,
-                    tree: a
-                }), l
+    const _2 = (e, t) => n => {
+        let i = n.target.__data__;
+        i = Array.isArray(i) ? i[0] : i, n.vegaType = n.type, t.call(e._obj, n, i)
+    };
+    ne(ES, so, {
+        initialize(e, t, n) {
+            let i = this._svg;
+            return i && (i.removeEventListener(x2, this._hrefHandler), i.removeEventListener(b2, this._tooltipHandler), i.removeEventListener(td, this._tooltipHandler)), this._svg = i = e && SS(e, "svg"), i && (i.addEventListener(x2, this._hrefHandler), i.addEventListener(b2, this._tooltipHandler), i.addEventListener(td, this._tooltipHandler)), so.prototype.initialize.call(this, e, t, n)
+        },
+        canvas() {
+            return this._svg
+        },
+        on(e, t) {
+            const n = this.eventName(e),
+                i = this._handlers;
+            if (this._handlerIndex(i[n], e, t) < 0) {
+                const s = {
+                    type: e,
+                    handler: t,
+                    listener: _2(this, t)
+                };
+                (i[n] || (i[n] = [])).push(s), this._svg && this._svg.addEventListener(n, s.listener)
             }
-            return t
-        }(Error),
-        yt = LR,
-        EY = pi,
-        fu = {
-            add: function(e, t, n) {
-                return e[t] = this.value, {
-                    newDocument: n
-                }
-            },
-            remove: function(e, t, n) {
-                var i = e[t];
-                return delete e[t], {
-                    newDocument: n,
-                    removed: i
-                }
-            },
-            replace: function(e, t, n) {
-                var i = e[t];
-                return e[t] = this.value, {
-                    newDocument: n,
-                    removed: i
-                }
-            },
-            move: function(e, t, n) {
-                var i = o0(n, this.path);
-                i && (i = pi(i));
-                var r = Uo(n, {
-                    op: "remove",
-                    path: this.from
-                }).removed;
-                return Uo(n, {
-                    op: "add",
-                    path: this.path,
-                    value: r
-                }), {
-                    newDocument: n,
-                    removed: i
-                }
+            return this
+        },
+        off(e, t) {
+            const n = this.eventName(e),
+                i = this._handlers[n],
+                r = this._handlerIndex(i, e, t);
+            return r >= 0 && (this._svg && this._svg.removeEventListener(n, i[r].listener), i.splice(r, 1)), this
+        }
+    });
+    const mP = "aria-hidden",
+        kS = "aria-label",
+        CS = "role",
+        AS = "aria-roledescription",
+        yP = "graphics-object",
+        $S = "graphics-symbol",
+        vP = (e, t, n) => ({
+            [CS]: e,
+            [AS]: t,
+            [kS]: n || void 0
+        }),
+        oV = Cr(["axis-domain", "axis-grid", "axis-label", "axis-tick", "axis-title", "legend-band", "legend-entry", "legend-gradient", "legend-label", "legend-title", "legend-symbol", "title"]),
+        F$ = {
+            axis: {
+                desc: "axis",
+                caption: cV
             },
-            copy: function(e, t, n) {
-                var i = o0(n, this.from);
-                return Uo(n, {
-                    op: "add",
-                    path: this.path,
-                    value: pi(i)
-                }), {
-                    newDocument: n
-                }
+            legend: {
+                desc: "legend",
+                caption: fV
             },
-            test: function(e, t, n) {
-                return {
-                    newDocument: n,
-                    test: wh(e[t], this.value)
-                }
+            "title-text": {
+                desc: "title",
+                caption: e => `Title text '${D$(e)}'`
             },
-            _get: function(e, t, n) {
-                return this.value = e[t], {
-                    newDocument: n
-                }
+            "title-subtitle": {
+                desc: "subtitle",
+                caption: e => `Subtitle text '${D$(e)}'`
             }
         },
-        CY = {
-            add: function(e, t, n) {
-                return Ub(t) ? e.splice(t, 0, this.value) : e[t] = this.value, {
-                    newDocument: n,
-                    index: t
-                }
-            },
-            remove: function(e, t, n) {
-                var i = e.splice(t, 1);
-                return {
-                    newDocument: n,
-                    removed: i[0]
-                }
-            },
-            replace: function(e, t, n) {
-                var i = e[t];
-                return e[t] = this.value, {
-                    newDocument: n,
-                    removed: i
-                }
-            },
-            move: fu.move,
-            copy: fu.copy,
-            test: fu.test,
-            _get: fu._get
+        R$ = {
+            ariaRole: CS,
+            ariaRoleDescription: AS,
+            description: kS
         };
 
-    function o0(e, t) {
-        if (t == "") return e;
-        var n = {
-            op: "_get",
-            path: t
-        };
-        return Uo(e, n), n.value
+    function bP(e, t) {
+        const n = t.aria === !1;
+        if (e(mP, n || void 0), n || t.description == null)
+            for (const i in R$) e(R$[i], void 0);
+        else {
+            const i = t.mark.marktype;
+            e(kS, t.description), e(CS, t.ariaRole || (i === "group" ? yP : $S)), e(AS, t.ariaRoleDescription || `${i} mark`)
+        }
     }
 
-    function Uo(e, t, n, i, r, s) {
-        if (n === void 0 && (n = !1), i === void 0 && (i = !0), r === void 0 && (r = !0), s === void 0 && (s = 0), n && (typeof n == "function" ? n(t, 0, e, t.path) : l0(t, 0)), t.path === "") {
-            var a = {
-                newDocument: e
-            };
-            if (t.op === "add") return a.newDocument = t.value, a;
-            if (t.op === "replace") return a.newDocument = t.value, a.removed = e, a;
-            if (t.op === "move" || t.op === "copy") return a.newDocument = o0(e, t.from), t.op === "move" && (a.removed = e), a;
-            if (t.op === "test") {
-                if (a.test = wh(e, t.value), a.test === !1) throw new yt("Test operation failed", "TEST_OPERATION_FAILED", s, t, e);
-                return a.newDocument = e, a
-            } else {
-                if (t.op === "remove") return a.removed = e, a.newDocument = null, a;
-                if (t.op === "_get") return t.value = e, a;
-                if (n) throw new yt("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", s, t, e);
-                return a
-            }
-        } else {
-            i || (e = pi(e));
-            var o = t.path || "",
-                l = o.split("/"),
-                u = e,
-                c = 1,
-                f = l.length,
-                h = void 0,
-                d = void 0,
-                g = void 0;
-            for (typeof n == "function" ? g = n : g = l0;;) {
-                if (d = l[c], d && d.indexOf("~") != -1 && (d = PR(d)), r && (d == "__proto__" || d == "prototype" && c > 0 && l[c - 1] == "constructor")) throw new TypeError("JSON-Patch: modifying `__proto__` or `constructor/prototype` prop is banned for security reasons, if this was on purpose, please set `banPrototypeModifications` flag false and pass it to this function. More info in fast-json-patch README");
-                if (n && h === void 0 && (u[d] === void 0 ? h = l.slice(0, c).join("/") : c == f - 1 && (h = t.path), h !== void 0 && g(t, 0, e, h)), c++, Array.isArray(u)) {
-                    if (d === "-") d = u.length;
-                    else {
-                        if (n && !Ub(d)) throw new yt("Expected an unsigned base-10 integer value, making the new referenced value the array element with the zero-based index", "OPERATION_PATH_ILLEGAL_ARRAY_INDEX", s, t, e);
-                        Ub(d) && (d = ~~d)
-                    }
-                    if (c >= f) {
-                        if (n && t.op === "add" && d > u.length) throw new yt("The specified index MUST NOT be greater than the number of elements in the array", "OPERATION_VALUE_OUT_OF_BOUNDS", s, t, e);
-                        var a = CY[t.op].call(t, u, d, e);
-                        if (a.test === !1) throw new yt("Test operation failed", "TEST_OPERATION_FAILED", s, t, e);
-                        return a
-                    }
-                } else if (c >= f) {
-                    var a = fu[t.op].call(t, u, d, e);
-                    if (a.test === !1) throw new yt("Test operation failed", "TEST_OPERATION_FAILED", s, t, e);
-                    return a
-                }
-                if (u = u[d], n && c < f && (!u || typeof u != "object")) throw new yt("Cannot perform operation at the desired path", "OPERATION_PATH_UNRESOLVABLE", s, t, e)
-            }
-        }
+    function xP(e) {
+        return e.aria === !1 ? {
+            [mP]: !0
+        } : oV[e.role] ? null : F$[e.role] ? uV(e, F$[e.role]) : lV(e)
     }
 
-    function Em(e, t, n, i, r) {
-        if (i === void 0 && (i = !0), r === void 0 && (r = !0), n && !Array.isArray(t)) throw new yt("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
-        i || (e = pi(e));
-        for (var s = new Array(t.length), a = 0, o = t.length; a < o; a++) s[a] = Uo(e, t[a], n, !0, r, a), e = s[a].newDocument;
-        return s.newDocument = e, s
+    function lV(e) {
+        const t = e.marktype,
+            n = t === "group" || t === "text" || e.items.some(i => i.description != null && i.aria !== !1);
+        return vP(n ? yP : $S, `${t} mark container`, e.description)
     }
 
-    function kY(e, t, n) {
-        var i = Uo(e, t);
-        if (i.test === !1) throw new yt("Test operation failed", "TEST_OPERATION_FAILED", n, t, e);
-        return i.newDocument
+    function uV(e, t) {
+        try {
+            const n = e.items[0],
+                i = t.caption || (() => "");
+            return vP(t.role || $S, t.desc, n.description || i(n))
+        } catch {
+            return null
+        }
     }
 
-    function l0(e, t, n, i) {
-        if (typeof e != "object" || e === null || Array.isArray(e)) throw new yt("Operation is not an object", "OPERATION_NOT_AN_OBJECT", t, e, n);
-        if (fu[e.op]) {
-            if (typeof e.path != "string") throw new yt("Operation `path` property is not a string", "OPERATION_PATH_INVALID", t, e, n);
-            if (e.path.indexOf("/") !== 0 && e.path.length > 0) throw new yt('Operation `path` property must start with "/"', "OPERATION_PATH_INVALID", t, e, n);
-            if ((e.op === "move" || e.op === "copy") && typeof e.from != "string") throw new yt("Operation `from` property is not present (applicable in `move` and `copy` operations)", "OPERATION_FROM_REQUIRED", t, e, n);
-            if ((e.op === "add" || e.op === "replace" || e.op === "test") && e.value === void 0) throw new yt("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_REQUIRED", t, e, n);
-            if ((e.op === "add" || e.op === "replace" || e.op === "test") && Gb(e.value)) throw new yt("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_CANNOT_CONTAIN_UNDEFINED", t, e, n);
-            if (n) {
-                if (e.op == "add") {
-                    var r = e.path.split("/").length,
-                        s = i.split("/").length;
-                    if (r !== s + 1 && r !== s) throw new yt("Cannot perform an `add` operation at the desired path", "OPERATION_PATH_CANNOT_ADD", t, e, n)
-                } else if (e.op === "replace" || e.op === "remove" || e.op === "_get") {
-                    if (e.path !== i) throw new yt("Cannot perform the operation at a path that does not exist", "OPERATION_PATH_UNRESOLVABLE", t, e, n)
-                } else if (e.op === "move" || e.op === "copy") {
-                    var a = {
-                            op: "_get",
-                            path: e.from,
-                            value: void 0
-                        },
-                        o = IR([a], n);
-                    if (o && o.name === "OPERATION_PATH_UNRESOLVABLE") throw new yt("Cannot perform the operation from a path that does not exist", "OPERATION_FROM_UNRESOLVABLE", t, e, n)
-                }
-            }
-        } else throw new yt("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", t, e, n)
+    function D$(e) {
+        return ue(e.text).join(" ")
     }
 
-    function IR(e, t, n) {
-        try {
-            if (!Array.isArray(e)) throw new yt("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
-            if (t) Em(pi(t), pi(e), n || !0);
-            else {
-                n = n || l0;
-                for (var i = 0; i < e.length; i++) n(e[i], i, t, void 0)
-            }
-        } catch (r) {
-            if (r instanceof yt) return r;
-            throw r
-        }
+    function cV(e) {
+        const t = e.datum,
+            n = e.orient,
+            i = t.title ? _P(e) : null,
+            r = e.context,
+            s = r.scales[t.scale].value,
+            a = r.dataflow.locale(),
+            o = s.type;
+        return `${n==="left"||n==="right"?"Y":"X"}-axis` + (i ? ` titled '${i}'` : "") + ` for a ${dc(o)?"discrete":o} scale with ${IN(a,s,e)}`
     }
 
-    function wh(e, t) {
-        if (e === t) return !0;
-        if (e && t && typeof e == "object" && typeof t == "object") {
-            var n = Array.isArray(e),
-                i = Array.isArray(t),
-                r, s, a;
-            if (n && i) {
-                if (s = e.length, s != t.length) return !1;
-                for (r = s; r-- !== 0;)
-                    if (!wh(e[r], t[r])) return !1;
-                return !0
-            }
-            if (n != i) return !1;
-            var o = Object.keys(e);
-            if (s = o.length, s !== Object.keys(t).length) return !1;
-            for (r = s; r-- !== 0;)
-                if (!t.hasOwnProperty(o[r])) return !1;
-            for (r = s; r-- !== 0;)
-                if (a = o[r], !wh(e[a], t[a])) return !1;
-            return !0
-        }
-        return e !== e && t !== t
+    function fV(e) {
+        const t = e.datum,
+            n = t.title ? _P(e) : null,
+            i = `${t.type||""} legend`.trim(),
+            r = t.scales,
+            s = Object.keys(r),
+            a = e.context,
+            o = a.scales[r[s[0]]].value,
+            l = a.dataflow.locale();
+        return dV(i) + (n ? ` titled '${n}'` : "") + ` for ${hV(s)} with ${IN(l,o,e)}`
     }
-    const AY = Object.freeze(Object.defineProperty({
-        __proto__: null,
-        JsonPatchError: yt,
-        _areEquals: wh,
-        applyOperation: Uo,
-        applyPatch: Em,
-        applyReducer: kY,
-        deepClone: EY,
-        getValueByPointer: o0,
-        validate: IR,
-        validator: l0
-    }, Symbol.toStringTag, {
-        value: "Module"
-    }));
-    /*!
-     * https://github.com/Starcounter-Jack/JSON-Patch
-     * (c) 2017-2021 Joachim Wester
-     * MIT license
-     */
-    var i_ = new WeakMap,
-        $Y = function() {
-            function e(t) {
-                this.observers = new Map, this.obj = t
-            }
-            return e
-        }(),
-        TY = function() {
-            function e(t, n) {
-                this.callback = t, this.observer = n
-            }
-            return e
-        }();
 
-    function MY(e) {
-        return i_.get(e)
+    function _P(e) {
+        try {
+            return ue(We(e.items).items[0].text).join(" ")
+        } catch {
+            return null
+        }
     }
 
-    function OY(e, t) {
-        return e.observers.get(t)
+    function hV(e) {
+        return e = e.map(t => t + (t === "fill" || t === "stroke" ? " color" : "")), e.length < 2 ? e[0] : e.slice(0, -1).join(", ") + " and " + We(e)
     }
 
-    function FY(e, t) {
-        e.observers.delete(t.callback)
+    function dV(e) {
+        return e.length ? e[0].toUpperCase() + e.slice(1) : e
     }
+    const wP = e => (e + "").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;"),
+        gV = e => wP(e).replace(/"/g, "&quot;").replace(/\t/g, "&#x9;").replace(/\n/g, "&#xA;").replace(/\r/g, "&#xD;");
 
-    function RY(e, t) {
-        t.unobserve()
+    function TS() {
+        let e = "",
+            t = "",
+            n = "";
+        const i = [],
+            r = () => t = n = "",
+            s = l => {
+                t && (e += `${t}>${n}`, r()), i.push(l)
+            },
+            a = (l, u) => (u != null && (t += ` ${l}="${gV(u)}"`), o),
+            o = {
+                open(l) {
+                    s(l), t = "<" + l;
+                    for (var u = arguments.length, c = new Array(u > 1 ? u - 1 : 0), f = 1; f < u; f++) c[f - 1] = arguments[f];
+                    for (const h of c)
+                        for (const d in h) a(d, h[d]);
+                    return o
+                },
+                close() {
+                    const l = i.pop();
+                    return t ? e += t + (n ? `>${n}</${l}>` : "/>") : e += `</${l}>`, r(), o
+                },
+                attr: a,
+                text: l => (n += wP(l), o),
+                toString: () => e
+            };
+        return o
     }
+    const SP = e => EP(TS(), e) + "";
 
-    function DY(e, t) {
-        var n = [],
-            i, r = MY(e);
-        if (!r) r = new $Y(e), i_.set(e, r);
-        else {
-            var s = OY(r, t);
-            i = s && s.observer
+    function EP(e, t) {
+        if (e.open(t.tagName), t.hasAttributes()) {
+            const n = t.attributes,
+                i = n.length;
+            for (let r = 0; r < i; ++r) e.attr(n[r].name, n[r].value)
         }
-        if (i) return i;
-        if (i = {}, r.value = pi(e), t) {
-            i.callback = t, i.next = null;
-            var a = function() {
-                    Wb(i)
-                },
-                o = function() {
-                    clearTimeout(i.next), i.next = setTimeout(a)
-                };
-            typeof window < "u" && (window.addEventListener("mouseup", o), window.addEventListener("keyup", o), window.addEventListener("mousedown", o), window.addEventListener("keydown", o), window.addEventListener("change", o))
+        if (t.hasChildNodes()) {
+            const n = t.childNodes;
+            for (const i of n) i.nodeType === 3 ? e.text(i.nodeValue) : EP(e, i)
         }
-        return i.patches = n, i.object = e, i.unobserve = function() {
-            Wb(i), clearTimeout(i.next), FY(r, i), typeof window < "u" && (window.removeEventListener("mouseup", o), window.removeEventListener("keyup", o), window.removeEventListener("mousedown", o), window.removeEventListener("keydown", o), window.removeEventListener("change", o))
-        }, r.observers.set(t, new TY(t, i)), i
+        return e.close()
     }
+    const Tm = {
+            fill: "fill",
+            fillOpacity: "fill-opacity",
+            stroke: "stroke",
+            strokeOpacity: "stroke-opacity",
+            strokeWidth: "stroke-width",
+            strokeCap: "stroke-linecap",
+            strokeJoin: "stroke-linejoin",
+            strokeDash: "stroke-dasharray",
+            strokeDashOffset: "stroke-dashoffset",
+            strokeMiterLimit: "stroke-miterlimit",
+            opacity: "opacity"
+        },
+        Mm = {
+            blend: "mix-blend-mode"
+        },
+        kP = {
+            fill: "none",
+            "stroke-miterlimit": 10
+        },
+        Af = 0,
+        N$ = "http://www.w3.org/2000/xmlns/",
+        qt = ed.xmlns;
 
-    function Wb(e, t) {
-        t === void 0 && (t = !1);
-        var n = i_.get(e.object);
-        r_(n.value, e.object, e.patches, "", t), e.patches.length && Em(n.value, e.patches);
-        var i = e.patches;
-        return i.length > 0 && (e.patches = [], e.callback && e.callback(i)), i
+    function MS(e) {
+        ys.call(this, e), this._dirtyID = 0, this._dirty = [], this._svg = null, this._root = null, this._defs = null
     }
-
-    function r_(e, t, n, i, r) {
-        if (t !== e) {
-            typeof t.toJSON == "function" && (t = t.toJSON());
-            for (var s = jb(t), a = jb(e), o = !1, l = a.length - 1; l >= 0; l--) {
-                var u = a[l],
-                    c = e[u];
-                if (Bb(t, u) && !(t[u] === void 0 && c !== void 0 && Array.isArray(t) === !1)) {
-                    var f = t[u];
-                    typeof c == "object" && c != null && typeof f == "object" && f != null && Array.isArray(c) === Array.isArray(f) ? r_(c, f, n, i + "/" + ko(u), r) : c !== f && (r && n.push({
-                        op: "test",
-                        path: i + "/" + ko(u),
-                        value: pi(c)
-                    }), n.push({
-                        op: "replace",
-                        path: i + "/" + ko(u),
-                        value: pi(f)
-                    }))
-                } else Array.isArray(e) === Array.isArray(t) ? (r && n.push({
-                    op: "test",
-                    path: i + "/" + ko(u),
-                    value: pi(c)
-                }), n.push({
-                    op: "remove",
-                    path: i + "/" + ko(u)
-                }), o = !0) : (r && n.push({
-                    op: "test",
-                    path: i,
-                    value: e
-                }), n.push({
-                    op: "replace",
-                    path: i,
-                    value: t
-                }))
-            }
-            if (!(!o && s.length == a.length))
-                for (var l = 0; l < s.length; l++) {
-                    var u = s[l];
-                    !Bb(e, u) && t[u] !== void 0 && n.push({
-                        op: "add",
-                        path: i + "/" + ko(u),
-                        value: pi(t[u])
-                    })
+    const bv = ys.prototype;
+    ne(MS, ys, {
+        initialize(e, t, n, i, r) {
+            return this._defs = {}, this._clearDefs(), e && (this._svg = ri(e, 0, "svg", qt), this._svg.setAttributeNS(N$, "xmlns", qt), this._svg.setAttributeNS(N$, "xmlns:xlink", ed["xmlns:xlink"]), this._svg.setAttribute("version", ed.version), this._svg.setAttribute("class", "marks"), dr(e, 1), this._root = ri(this._svg, Af, "g", qt), Da(this._root, kP), dr(this._svg, Af + 1)), this.background(this._bgcolor), bv.initialize.call(this, e, t, n, i, r)
+        },
+        background(e) {
+            return arguments.length && this._svg && this._svg.style.setProperty("background-color", e), bv.background.apply(this, arguments)
+        },
+        resize(e, t, n, i) {
+            return bv.resize.call(this, e, t, n, i), this._svg && (Da(this._svg, {
+                width: this._width * this._scale,
+                height: this._height * this._scale,
+                viewBox: `0 0 ${this._width} ${this._height}`
+            }), this._root.setAttribute("transform", `translate(${this._origin})`)), this._dirty = [], this
+        },
+        canvas() {
+            return this._svg
+        },
+        svg() {
+            const e = this._svg,
+                t = this._bgcolor;
+            if (!e) return null;
+            let n;
+            t && (e.removeAttribute("style"), n = ri(e, Af, "rect", qt), Da(n, {
+                width: this._width,
+                height: this._height,
+                fill: t
+            }));
+            const i = SP(e);
+            return t && (e.removeChild(n), this._svg.style.setProperty("background-color", t)), i
+        },
+        _render(e) {
+            return this._dirtyCheck() && (this._dirtyAll && this._clearDefs(), this.mark(this._root, e), dr(this._root, 1)), this.defs(), this._dirty = [], ++this._dirtyID, this
+        },
+        dirty(e) {
+            e.dirty !== this._dirtyID && (e.dirty = this._dirtyID, this._dirty.push(e))
+        },
+        isDirty(e) {
+            return this._dirtyAll || !e._svg || !e._svg.ownerSVGElement || e.dirty === this._dirtyID
+        },
+        _dirtyCheck() {
+            this._dirtyAll = !0;
+            const e = this._dirty;
+            if (!e.length || !this._dirtyID) return !0;
+            const t = ++this._dirtyID;
+            let n, i, r, s, a, o, l;
+            for (a = 0, o = e.length; a < o; ++a)
+                if (n = e[a], i = n.mark, i.marktype !== r && (r = i.marktype, s = Ri[r]), i.zdirty && i.dirty !== t && (this._dirtyAll = !1, P$(n, t), i.items.forEach(u => {
+                        u.dirty = t
+                    })), !i.zdirty) {
+                    if (n.exit) {
+                        s.nested && i.items.length ? (l = i.items[0], l._svg && this._update(s, l._svg, l)) : n._svg && (l = n._svg.parentNode, l && l.removeChild(n._svg)), n._svg = null;
+                        continue
+                    }
+                    n = s.nested ? i.items[0] : n, n._update !== t && (!n._svg || !n._svg.ownerSVGElement ? (this._dirtyAll = !1, P$(n, t)) : this._update(s, n._svg, n), n._update = t)
+                } return !this._dirtyAll
+        },
+        mark(e, t, n) {
+            if (!this.isDirty(t)) return t._svg;
+            const i = this._svg,
+                r = Ri[t.marktype],
+                s = t.interactive === !1 ? "none" : null,
+                a = r.tag === "g",
+                o = L$(t, e, n, "g", i);
+            o.setAttribute("class", fP(t));
+            const l = xP(t);
+            for (const h in l) Bn(o, h, l[h]);
+            a || Bn(o, "pointer-events", s), Bn(o, "clip-path", t.clip ? sS(this, t, t.group) : null);
+            let u = null,
+                c = 0;
+            const f = h => {
+                const d = this.isDirty(h),
+                    g = L$(h, o, u, r.tag, i);
+                d && (this._update(r, g, h), a && yV(this, g, h)), u = g, ++c
+            };
+            return r.nested ? t.items.length && f(t.items[0]) : $r(t, f), dr(o, c), o
+        },
+        _update(e, t, n) {
+            Ws = t, An = t.__values__, bP(Ch, n), e.attr(Ch, n, this);
+            const i = bV[e.type];
+            i && i.call(this, e, t, n), Ws && this.style(Ws, n)
+        },
+        style(e, t) {
+            if (t != null) {
+                for (const n in Tm) {
+                    let i = n === "font" ? qd(t) : t[n];
+                    if (i === An[n]) continue;
+                    const r = Tm[n];
+                    i == null ? e.removeAttribute(r) : (nS(i) && (i = BN(i, this._defs.gradient, CP())), e.setAttribute(r, i + "")), An[n] = i
                 }
+                for (const n in Mm) Op(e, Mm[n], t[n])
+            }
+        },
+        defs() {
+            const e = this._svg,
+                t = this._defs;
+            let n = t.el,
+                i = 0;
+            for (const r in t.gradient) n || (t.el = n = ri(e, Af + 1, "defs", qt)), i = pV(n, t.gradient[r], i);
+            for (const r in t.clipping) n || (t.el = n = ri(e, Af + 1, "defs", qt)), i = mV(n, t.clipping[r], i);
+            n && (i === 0 ? (e.removeChild(n), t.el = null) : dr(n, i))
+        },
+        _clearDefs() {
+            const e = this._defs;
+            e.gradient = {}, e.clipping = {}
         }
-    }
+    });
 
-    function NY(e, t, n) {
-        n === void 0 && (n = !1);
-        var i = [];
-        return r_(e, t, i, "", n), i
+    function P$(e, t) {
+        for (; e && e.dirty !== t; e = e.mark.group)
+            if (e.dirty = t, e.mark && e.mark.dirty !== t) e.mark.dirty = t;
+            else return
     }
-    const PY = Object.freeze(Object.defineProperty({
-        __proto__: null,
-        compare: NY,
-        generate: Wb,
-        observe: DY,
-        unobserve: RY
-    }, Symbol.toStringTag, {
-        value: "Module"
-    }));
-    Object.assign({}, AY, PY, {
-        JsonPatchError: LR,
-        deepClone: pi,
-        escapePathComponent: ko,
-        unescapePathComponent: PR
-    });
 
-    function Cm(e) {
-        return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e
+    function pV(e, t, n) {
+        let i, r, s;
+        if (t.gradient === "radial") {
+            let a = ri(e, n++, "pattern", qt);
+            Da(a, {
+                id: xm + t.id,
+                viewBox: "0,0,1,1",
+                width: "100%",
+                height: "100%",
+                preserveAspectRatio: "xMidYMid slice"
+            }), a = ri(a, 0, "rect", qt), Da(a, {
+                width: 1,
+                height: 1,
+                fill: `url(${CP()}#${t.id})`
+            }), e = ri(e, n++, "radialGradient", qt), Da(e, {
+                id: t.id,
+                fx: t.x1,
+                fy: t.y1,
+                fr: t.r1,
+                cx: t.x2,
+                cy: t.y2,
+                r: t.r2
+            })
+        } else e = ri(e, n++, "linearGradient", qt), Da(e, {
+            id: t.id,
+            x1: t.x1,
+            x2: t.x2,
+            y1: t.y1,
+            y2: t.y2
+        });
+        for (i = 0, r = t.stops.length; i < r; ++i) s = ri(e, i, "stop", qt), s.setAttribute("offset", t.stops[i].offset), s.setAttribute("stop-color", t.stops[i].color);
+        return dr(e, i), n
     }
-    var LY = /("(?:[^\\"]|\\.)*")|[:,]/g,
-        IY = function(t, n) {
-            var i, r, s;
-            return n = n || {}, i = JSON.stringify([1], void 0, n.indent === void 0 ? 2 : n.indent).slice(2, -3), r = i === "" ? 1 / 0 : n.maxLength === void 0 ? 80 : n.maxLength, s = n.replacer,
-                function a(o, l, u) {
-                    var c, f, h, d, g, p, m, y, v, b, x, _;
-                    if (o && typeof o.toJSON == "function" && (o = o.toJSON()), x = JSON.stringify(o, s), x === void 0) return x;
-                    if (m = r - l.length - u, x.length <= m && (v = x.replace(LY, function(S, w) {
-                            return w || S + " "
-                        }), v.length <= m)) return v;
-                    if (s != null && (o = JSON.parse(x), s = void 0), typeof o == "object" && o !== null) {
-                        if (y = l + i, h = [], f = 0, Array.isArray(o))
-                            for (b = "[", c = "]", m = o.length; f < m; f++) h.push(a(o[f], y, f === m - 1 ? 0 : 1) || "null");
-                        else
-                            for (b = "{", c = "}", p = Object.keys(o), m = p.length; f < m; f++) d = p[f], g = JSON.stringify(d) + ": ", _ = a(o[d], y, g.length + (f === m - 1 ? 0 : 1)), _ !== void 0 && h.push(g + _);
-                        if (h.length > 0) return [b, i + h.join(`,
-` + y), c].join(`
-` + l)
-                    }
-                    return x
-                }(t, "", 0)
-        };
-    const Hy = Cm(IY);
 
-    function li(e, t, n) {
-        return e.fields = t || [], e.fname = n, e
+    function mV(e, t, n) {
+        let i;
+        return e = ri(e, n, "clipPath", qt), e.setAttribute("id", t.id), t.path ? (i = ri(e, 0, "path", qt), i.setAttribute("d", t.path)) : (i = ri(e, 0, "rect", qt), Da(i, {
+            x: 0,
+            y: 0,
+            width: t.width,
+            height: t.height
+        })), dr(e, 1), n + 1
     }
 
-    function bt(e) {
-        return e == null ? null : e.fname
+    function yV(e, t, n) {
+        t = t.lastChild.previousSibling;
+        let i, r = 0;
+        $r(n, s => {
+            i = e.mark(t, s, i), ++r
+        }), dr(t, 1 + r)
     }
 
-    function pn(e) {
-        return e == null ? null : e.fields
+    function L$(e, t, n, i, r) {
+        let s = e._svg,
+            a;
+        if (!s && (a = t.ownerDocument, s = Ra(a, i, qt), e._svg = s, e.mark && (s.__data__ = e, s.__values__ = {
+                fill: "default"
+            }, i === "g"))) {
+            const o = Ra(a, "path", qt);
+            s.appendChild(o), o.__data__ = e;
+            const l = Ra(a, "g", qt);
+            s.appendChild(l), l.__data__ = e;
+            const u = Ra(a, "path", qt);
+            s.appendChild(u), u.__data__ = e, u.__values__ = {
+                fill: "default"
+            }
+        }
+        return (s.ownerSVGElement !== r || vV(s, n)) && t.insertBefore(s, n ? n.nextSibling : t.firstChild), s
     }
 
-    function zR(e) {
-        return e.length === 1 ? zY(e[0]) : BY(e)
+    function vV(e, t) {
+        return e.parentNode && e.parentNode.childNodes.length > 1 && e.previousSibling != t
     }
-    const zY = e => function(t) {
-            return t[e]
+    let Ws = null,
+        An = null;
+    const bV = {
+        group(e, t, n) {
+            const i = Ws = t.childNodes[2];
+            An = i.__values__, e.foreground(Ch, n, this), An = t.__values__, Ws = t.childNodes[1], e.content(Ch, n, this);
+            const r = Ws = t.childNodes[0];
+            e.background(Ch, n, this);
+            const s = n.mark.interactive === !1 ? "none" : null;
+            if (s !== An.events && (Bn(i, "pointer-events", s), Bn(r, "pointer-events", s), An.events = s), n.strokeForeground && n.stroke) {
+                const a = n.fill;
+                Bn(i, "display", null), this.style(r, n), Bn(r, "stroke", null), a && (n.fill = null), An = i.__values__, this.style(i, n), a && (n.fill = a), Ws = null
+            } else Bn(i, "display", "none")
         },
-        BY = e => {
-            const t = e.length;
-            return function(n) {
-                for (let i = 0; i < t; ++i) n = n[e[i]];
-                return n
-            }
-        };
+        image(e, t, n) {
+            n.smooth === !1 ? (Op(t, "image-rendering", "optimizeSpeed"), Op(t, "image-rendering", "pixelated")) : Op(t, "image-rendering", null)
+        },
+        text(e, t, n) {
+            const i = Wd(n);
+            let r, s, a, o;
+            H(i) ? (s = i.map(l => ro(n, l)), r = s.join(`
+`), r !== An.text && (dr(t, 0), a = t.ownerDocument, o = io(n), s.forEach((l, u) => {
+                const c = Ra(a, "tspan", qt);
+                c.__data__ = n, c.textContent = l, u && (c.setAttribute("x", 0), c.setAttribute("dy", o)), t.appendChild(c)
+            }), An.text = r)) : (s = ro(n, i), s !== An.text && (t.textContent = s, An.text = s)), Bn(t, "font-family", qd(n)), Bn(t, "font-size", ms(n) + "px"), Bn(t, "font-style", n.fontStyle), Bn(t, "font-variant", n.fontVariant), Bn(t, "font-weight", n.fontWeight)
+        }
+    };
 
-    function U(e) {
-        throw Error(e)
+    function Ch(e, t, n) {
+        t !== An[e] && (n ? xV(Ws, e, t, n) : Bn(Ws, e, t), An[e] = t)
     }
 
-    function ns(e) {
-        const t = [],
-            n = e.length;
-        let i = null,
-            r = 0,
-            s = "",
-            a, o, l;
-        e = e + "";
-
-        function u() {
-            t.push(s + e.substring(a, o)), s = "", a = o + 1
-        }
-        for (a = o = 0; o < n; ++o)
-            if (l = e[o], l === "\\") s += e.substring(a, o++), a = o;
-            else if (l === i) u(), i = null, r = -1;
-        else {
-            if (i) continue;
-            a === r && l === '"' || a === r && l === "'" ? (a = o + 1, i = l) : l === "." && !r ? o > a ? u() : a = o + 1 : l === "[" ? (o > a && u(), r = a = o + 1) : l === "]" && (r || U("Access path missing open bracket: " + e), r > 0 && u(), r = 0, a = o + 1)
-        }
-        return r && U("Access path missing closing bracket: " + e), i && U("Access path missing closing quote: " + e), o > a && (o++, u()), t
+    function Op(e, t, n) {
+        n !== An[t] && (n == null ? e.style.removeProperty(t) : e.style.setProperty(t, n + ""), An[t] = n)
     }
 
-    function ni(e, t, n) {
-        const i = ns(e);
-        return e = i.length === 1 ? i[0] : e, li((n && n.get || zR)(i), [e], t || e)
+    function Da(e, t) {
+        for (const n in t) Bn(e, n, t[n])
     }
-    const sd = ni("id"),
-        bn = li(e => e, [], "identity"),
-        ha = li(() => 0, [], "zero"),
-        vc = li(() => 1, [], "one"),
-        Ri = li(() => !0, [], "true"),
-        ia = li(() => !1, [], "false");
 
-    function jY(e, t, n) {
-        const i = [t].concat([].slice.call(n));
-        console[e].apply(console, i)
-    }
-    const BR = 0,
-        s_ = 1,
-        a_ = 2,
-        jR = 3,
-        UR = 4;
-
-    function o_(e, t) {
-        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : jY,
-            i = e || BR;
-        return {
-            level(r) {
-                return arguments.length ? (i = +r, this) : i
-            },
-            error() {
-                return i >= s_ && n(t || "error", "ERROR", arguments), this
-            },
-            warn() {
-                return i >= a_ && n(t || "warn", "WARN", arguments), this
-            },
-            info() {
-                return i >= jR && n(t || "log", "INFO", arguments), this
-            },
-            debug() {
-                return i >= UR && n(t || "log", "DEBUG", arguments), this
-            }
-        }
+    function Bn(e, t, n) {
+        n != null ? e.setAttribute(t, n) : e.removeAttribute(t)
     }
-    var W = Array.isArray;
 
-    function ae(e) {
-        return e === Object(e)
+    function xV(e, t, n, i) {
+        n != null ? e.setAttributeNS(i, t, n) : e.removeAttributeNS(i, t)
     }
-    const x$ = e => e !== "__proto__";
 
-    function bc() {
-        for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
-        return t.reduce((i, r) => {
-            for (const s in r)
-                if (s === "signals") i.signals = UY(i.signals, r.signals);
-                else {
-                    const a = s === "legend" ? {
-                        layout: 1
-                    } : s === "style" ? !0 : null;
-                    xc(i, s, r[s], a)
-                } return i
-        }, {})
+    function CP() {
+        let e;
+        return typeof window > "u" ? "" : (e = window.location).hash ? e.href.slice(0, -e.hash.length) : e.href
     }
 
-    function xc(e, t, n, i) {
-        if (!x$(t)) return;
-        let r, s;
-        if (ae(n) && !W(n)) {
-            s = ae(e[t]) ? e[t] : e[t] = {};
-            for (r in n) i && (i === !0 || i[r]) ? xc(s, r, n[r]) : x$(r) && (s[r] = n[r])
-        } else e[t] = n
+    function OS(e) {
+        ys.call(this, e), this._text = null, this._defs = {
+            gradient: {},
+            clipping: {}
+        }
     }
+    ne(OS, ys, {
+        svg() {
+            return this._text
+        },
+        _render(e) {
+            const t = TS();
+            t.open("svg", Ne({}, ed, {
+                class: "marks",
+                width: this._width * this._scale,
+                height: this._height * this._scale,
+                viewBox: `0 0 ${this._width} ${this._height}`
+            }));
+            const n = this._bgcolor;
+            return n && n !== "transparent" && n !== "none" && t.open("rect", {
+                width: this._width,
+                height: this._height,
+                fill: n
+            }).close(), t.open("g", kP, {
+                transform: "translate(" + this._origin + ")"
+            }), this.mark(t, e), t.close(), this.defs(t), this._text = t.close() + "", this
+        },
+        mark(e, t) {
+            const n = Ri[t.marktype],
+                i = n.tag,
+                r = [bP, n.attr];
+            e.open("g", {
+                class: fP(t),
+                "clip-path": t.clip ? sS(this, t, t.group) : null
+            }, xP(t), {
+                "pointer-events": i !== "g" && t.interactive === !1 ? "none" : null
+            });
+            const s = a => {
+                const o = this.href(a);
+                if (o && e.open("a", o), e.open(i, this.attr(t, a, r, i !== "g" ? i : null)), i === "text") {
+                    const l = Wd(a);
+                    if (H(l)) {
+                        const u = {
+                            x: 0,
+                            dy: io(a)
+                        };
+                        for (let c = 0; c < l.length; ++c) e.open("tspan", c ? u : null).text(ro(a, l[c])).close()
+                    } else e.text(ro(a, l))
+                } else if (i === "g") {
+                    const l = a.strokeForeground,
+                        u = a.fill,
+                        c = a.stroke;
+                    l && c && (a.stroke = null), e.open("path", this.attr(t, a, n.background, "bgrect")).close(), e.open("g", this.attr(t, a, n.content)), $r(a, f => this.mark(e, f)), e.close(), l && c ? (u && (a.fill = null), a.stroke = c, e.open("path", this.attr(t, a, n.foreground, "bgrect")).close(), u && (a.fill = u)) : e.open("path", this.attr(t, a, n.foreground, "bgfore")).close()
+                }
+                e.close(), o && e.close()
+            };
+            return n.nested ? t.items && t.items.length && s(t.items[0]) : $r(t, s), e.close()
+        },
+        href(e) {
+            const t = e.href;
+            let n;
+            if (t) {
+                if (n = this._hrefs && this._hrefs[t]) return n;
+                this.sanitizeURL(t).then(i => {
+                    i["xlink:href"] = i.href, i.href = null, (this._hrefs || (this._hrefs = {}))[t] = i
+                })
+            }
+            return null
+        },
+        attr(e, t, n, i) {
+            const r = {},
+                s = (a, o, l, u) => {
+                    r[u || a] = o
+                };
+            return Array.isArray(n) ? n.forEach(a => a(s, t, this)) : n(s, t, this), i && _V(r, t, e, i, this._defs), r
+        },
+        defs(e) {
+            const t = this._defs.gradient,
+                n = this._defs.clipping;
+            if (Object.keys(t).length + Object.keys(n).length !== 0) {
+                e.open("defs");
+                for (const r in t) {
+                    const s = t[r],
+                        a = s.stops;
+                    s.gradient === "radial" ? (e.open("pattern", {
+                        id: xm + r,
+                        viewBox: "0,0,1,1",
+                        width: "100%",
+                        height: "100%",
+                        preserveAspectRatio: "xMidYMid slice"
+                    }), e.open("rect", {
+                        width: "1",
+                        height: "1",
+                        fill: "url(#" + r + ")"
+                    }).close(), e.close(), e.open("radialGradient", {
+                        id: r,
+                        fx: s.x1,
+                        fy: s.y1,
+                        fr: s.r1,
+                        cx: s.x2,
+                        cy: s.y2,
+                        r: s.r2
+                    })) : e.open("linearGradient", {
+                        id: r,
+                        x1: s.x1,
+                        x2: s.x2,
+                        y1: s.y1,
+                        y2: s.y2
+                    });
+                    for (let o = 0; o < a.length; ++o) e.open("stop", {
+                        offset: a[o].offset,
+                        "stop-color": a[o].color
+                    }).close();
+                    e.close()
+                }
+                for (const r in n) {
+                    const s = n[r];
+                    e.open("clipPath", {
+                        id: r
+                    }), s.path ? e.open("path", {
+                        d: s.path
+                    }).close() : e.open("rect", {
+                        x: 0,
+                        y: 0,
+                        width: s.width,
+                        height: s.height
+                    }).close(), e.close()
+                }
+                e.close()
+            }
+        }
+    });
 
-    function UY(e, t) {
-        if (e == null) return t;
-        const n = {},
-            i = [];
-
-        function r(s) {
-            n[s.name] || (n[s.name] = 1, i.push(s))
+    function _V(e, t, n, i, r) {
+        let s;
+        if (t == null || (i === "bgrect" && n.interactive === !1 && (e["pointer-events"] = "none"), i === "bgfore" && (n.interactive === !1 && (e["pointer-events"] = "none"), e.display = "none", t.fill !== null))) return e;
+        i === "image" && t.smooth === !1 && (s = ["image-rendering: optimizeSpeed;", "image-rendering: pixelated;"]), i === "text" && (e["font-family"] = qd(t), e["font-size"] = ms(t) + "px", e["font-style"] = t.fontStyle, e["font-variant"] = t.fontVariant, e["font-weight"] = t.fontWeight);
+        for (const a in Tm) {
+            let o = t[a];
+            const l = Tm[a];
+            o === "transparent" && (l === "fill" || l === "stroke") || o != null && (nS(o) && (o = BN(o, r.gradient, "")), e[l] = o)
         }
-        return t.forEach(r), e.forEach(r), i
+        for (const a in Mm) {
+            const o = t[a];
+            o != null && (s = s || [], s.push(`${Mm[a]}: ${o};`))
+        }
+        return s && (e.style = s.join(" ")), e
     }
+    const AP = "canvas",
+        $P = "png",
+        TP = "svg",
+        MP = "none",
+        Na = {
+            Canvas: AP,
+            PNG: $P,
+            SVG: TP,
+            None: MP
+        },
+        yc = {};
+    yc[AP] = yc[$P] = {
+        renderer: $m,
+        headless: $m,
+        handler: Hd
+    };
+    yc[TP] = {
+        renderer: MS,
+        headless: OS,
+        handler: ES
+    };
+    yc[MP] = {};
 
-    function De(e) {
-        return e[e.length - 1]
+    function T1(e, t) {
+        return e = String(e || "").toLowerCase(), arguments.length > 1 ? (yc[e] = t, this) : yc[e]
     }
 
-    function hn(e) {
-        return e == null || e === "" ? null : +e
+    function OP(e, t, n) {
+        const i = [],
+            r = new Ut().union(t),
+            s = e.marktype;
+        return s ? FP(e, r, n, i) : s === "group" ? RP(e, r, n, i) : q("Intersect scene must be mark node or group item.")
     }
-    const GR = e => t => e * Math.exp(t),
-        WR = e => t => Math.log(e * t),
-        qR = e => t => Math.sign(t) * Math.log1p(Math.abs(t / e)),
-        HR = e => t => Math.sign(t) * Math.expm1(Math.abs(t)) * e,
-        u0 = e => t => t < 0 ? -Math.pow(-t, e) : Math.pow(t, e);
 
-    function km(e, t, n, i) {
-        const r = n(e[0]),
-            s = n(De(e)),
-            a = (s - r) * t;
-        return [i(r - a), i(s - a)]
+    function FP(e, t, n, i) {
+        if (wV(e, t, n)) {
+            const r = e.items,
+                s = e.marktype,
+                a = r.length;
+            let o = 0;
+            if (s === "group")
+                for (; o < a; ++o) RP(r[o], t, n, i);
+            else
+                for (const l = Ri[s].isect; o < a; ++o) {
+                    const u = r[o];
+                    DP(u, t, l) && i.push(u)
+                }
+        }
+        return i
     }
 
-    function YR(e, t) {
-        return km(e, t, hn, bn)
+    function wV(e, t, n) {
+        return e.bounds && t.intersects(e.bounds) && (e.marktype === "group" || e.interactive !== !1 && (!n || n(e)))
     }
 
-    function XR(e, t) {
-        var n = Math.sign(e[0]);
-        return km(e, t, WR(n), GR(n))
+    function RP(e, t, n, i) {
+        n && n(e.mark) && DP(e, t, Ri.group.isect) && i.push(e);
+        const r = e.items,
+            s = r && r.length;
+        if (s) {
+            const a = e.x || 0,
+                o = e.y || 0;
+            t.translate(-a, -o);
+            for (let l = 0; l < s; ++l) FP(r[l], t, n, i);
+            t.translate(a, o)
+        }
+        return i
     }
 
-    function VR(e, t, n) {
-        return km(e, t, u0(n), u0(1 / n))
+    function DP(e, t, n) {
+        const i = e.bounds;
+        return t.encloses(i) || t.intersects(i) && n(e, t)
     }
+    const xv = new Ut;
 
-    function KR(e, t, n) {
-        return km(e, t, qR(n), HR(n))
+    function NP(e) {
+        const t = e.clip;
+        if (Pe(t)) t(Gd(xv.clear()));
+        else if (t) xv.set(0, 0, e.group.width, e.group.height);
+        else return;
+        e.bounds.intersect(xv)
     }
+    const SV = 1e-9;
 
-    function Am(e, t, n, i, r) {
-        const s = i(e[0]),
-            a = i(De(e)),
-            o = t != null ? i(t) : (s + a) / 2;
-        return [r(o + (s - o) * n), r(o + (a - o) * n)]
+    function FS(e, t, n) {
+        return e === t ? !0 : n === "path" ? PP(e, t) : e instanceof Date && t instanceof Date ? +e == +t : lt(e) && lt(t) ? Math.abs(e - t) <= SV : !e || !t || !ce(e) && !ce(t) ? e == t : EV(e, t)
     }
 
-    function l_(e, t, n) {
-        return Am(e, t, n, hn, bn)
+    function PP(e, t) {
+        return FS(gc(e), gc(t))
     }
 
-    function u_(e, t, n) {
-        const i = Math.sign(e[0]);
-        return Am(e, t, n, WR(i), GR(i))
+    function EV(e, t) {
+        var n = Object.keys(e),
+            i = Object.keys(t),
+            r, s;
+        if (n.length !== i.length) return !1;
+        for (n.sort(), i.sort(), s = n.length - 1; s >= 0; s--)
+            if (n[s] != i[s]) return !1;
+        for (s = n.length - 1; s >= 0; s--)
+            if (r = n[s], !FS(e[r], t[r], r)) return !1;
+        return typeof e == typeof t
     }
 
-    function c0(e, t, n, i) {
-        return Am(e, t, n, u0(i), u0(1 / i))
+    function kV() {
+        YN(), KH()
     }
+    const vc = "top",
+        gr = "left",
+        yr = "right",
+        ao = "bottom",
+        CV = "top-left",
+        AV = "top-right",
+        $V = "bottom-left",
+        TV = "bottom-right",
+        RS = "start",
+        w2 = "middle",
+        jn = "end",
+        MV = "x",
+        OV = "y",
+        M1 = "group",
+        DS = "axis",
+        NS = "title",
+        FV = "frame",
+        RV = "scope",
+        PS = "legend",
+        LP = "row-header",
+        IP = "row-footer",
+        zP = "row-title",
+        BP = "column-header",
+        jP = "column-footer",
+        GP = "column-title",
+        DV = "padding",
+        NV = "symbol",
+        UP = "fit",
+        WP = "fit-x",
+        qP = "fit-y",
+        PV = "pad",
+        LS = "none",
+        Tg = "all",
+        S2 = "each",
+        IS = "flush",
+        Pa = "column",
+        La = "row";
 
-    function c_(e, t, n, i) {
-        return Am(e, t, n, qR(i), HR(i))
+    function HP(e) {
+        j.call(this, null, e)
     }
+    ne(HP, j, {
+        transform(e, t) {
+            const n = t.dataflow,
+                i = e.mark,
+                r = i.marktype,
+                s = Ri[r],
+                a = s.bound;
+            let o = i.bounds,
+                l;
+            if (s.nested) i.items.length && n.dirty(i.items[0]), o = Mg(i, a), i.items.forEach(u => {
+                u.bounds.clear().union(o)
+            });
+            else if (r === M1 || e.modified()) switch (t.visit(t.MOD, u => n.dirty(u)), o.clear(), i.items.forEach(u => o.union(Mg(u, a))), i.role) {
+                case DS:
+                case PS:
+                case NS:
+                    t.reflow()
+            } else l = t.changed(t.REM), t.visit(t.ADD, u => {
+                o.union(Mg(u, a))
+            }), t.visit(t.MOD, u => {
+                l = l || o.alignsWith(u.bounds), n.dirty(u), o.union(Mg(u, a))
+            }), l && (o.clear(), i.items.forEach(u => o.union(u.bounds)));
+            return NP(i), t.modifies("bounds")
+        }
+    });
 
-    function JR(e) {
-        return 1 + ~~(new Date(e).getMonth() / 3)
+    function Mg(e, t, n) {
+        return t(e.bounds.clear(), e, n)
     }
+    const I$ = ":vega_identifier:";
 
-    function QR(e) {
-        return 1 + ~~(new Date(e).getUTCMonth() / 3)
+    function zS(e) {
+        j.call(this, 0, e)
     }
+    zS.Definition = {
+        type: "Identifier",
+        metadata: {
+            modifies: !0
+        },
+        params: [{
+            name: "as",
+            type: "string",
+            required: !0
+        }]
+    };
+    ne(zS, j, {
+        transform(e, t) {
+            const n = LV(t.dataflow),
+                i = e.as;
+            let r = n.value;
+            return t.visit(t.ADD, s => s[i] = s[i] || ++r), n.set(this.value = r), t
+        }
+    });
 
-    function se(e) {
-        return e != null ? W(e) ? e : [e] : []
+    function LV(e) {
+        return e._signals[I$] || (e._signals[I$] = e.add(0))
     }
 
-    function ZR(e, t, n) {
-        let i = e[0],
-            r = e[1],
-            s;
-        return r < i && (s = r, r = i, i = s), s = r - i, s >= n - t ? [t, n] : [i = Math.min(Math.max(i, t), n - s), i + s]
+    function YP(e) {
+        j.call(this, null, e)
     }
+    ne(YP, j, {
+        transform(e, t) {
+            let n = this.value;
+            n || (n = t.dataflow.scenegraph().mark(e.markdef, IV(e), e.index), n.group.context = e.context, e.context.group || (e.context.group = n.group), n.source = this.source, n.clip = e.clip, n.interactive = e.interactive, this.value = n);
+            const i = n.marktype === M1 ? _1 : x1;
+            return t.visit(t.ADD, r => i.call(r, n)), (e.modified("clip") || e.modified("interactive")) && (n.clip = e.clip, n.interactive = !!e.interactive, n.zdirty = !0, t.reflow()), n.items = t.source, t
+        }
+    });
 
-    function $e(e) {
-        return typeof e == "function"
+    function IV(e) {
+        const t = e.groups,
+            n = e.parent;
+        return t && t.size === 1 ? t.get(Object.keys(t.object)[0]) : t && n ? t.lookup(n) : null
     }
-    const GY = "descending";
 
-    function f_(e, t, n) {
-        n = n || {}, t = se(t) || [];
-        const i = [],
-            r = [],
-            s = {},
-            a = n.comparator || WY;
-        return se(e).forEach((o, l) => {
-            o != null && (i.push(t[l] === GY ? -1 : 1), r.push(o = $e(o) ? o : ni(o, null, n)), (pn(o) || []).forEach(u => s[u] = 1))
-        }), r.length === 0 ? null : li(a(r, i), Object.keys(s))
-    }
-    const $m = (e, t) => (e < t || e == null) && t != null ? -1 : (e > t || t == null) && e != null ? 1 : (t = t instanceof Date ? +t : t, (e = e instanceof Date ? +e : e) !== e && t === t ? -1 : t !== t && e === e ? 1 : 0),
-        WY = (e, t) => e.length === 1 ? qY(e[0], t[0]) : HY(e, t, e.length),
-        qY = (e, t) => function(n, i) {
-            return $m(e(n), e(i)) * t
+    function XP(e) {
+        j.call(this, null, e)
+    }
+    const z$ = {
+            parity: e => e.filter((t, n) => n % 2 ? t.opacity = 0 : 1),
+            greedy: (e, t) => {
+                let n;
+                return e.filter((i, r) => !r || !VP(n.bounds, i.bounds, t) ? (n = i, 1) : i.opacity = 0)
+            }
         },
-        HY = (e, t, n) => (t.push(0), function(i, r) {
-            let s, a = 0,
-                o = -1;
-            for (; a === 0 && ++o < n;) s = e[o], a = $m(s(i), s(r));
-            return a * t[o]
-        });
+        VP = (e, t, n) => n > Math.max(t.x1 - e.x2, e.x1 - t.x2, t.y1 - e.y2, e.y1 - t.y2),
+        B$ = (e, t) => {
+            for (var n = 1, i = e.length, r = e[0].bounds, s; n < i; r = s, ++n)
+                if (VP(r, s = e[n].bounds, t)) return !0
+        },
+        zV = e => {
+            const t = e.bounds;
+            return t.width() > 1 && t.height() > 1
+        },
+        BV = (e, t, n) => {
+            var i = e.range(),
+                r = new Ut;
+            return t === vc || t === ao ? r.set(i[0], -1 / 0, i[1], 1 / 0) : r.set(-1 / 0, i[0], 1 / 0, i[1]), r.expand(n || 1), s => r.encloses(s.bounds)
+        },
+        j$ = e => (e.forEach(t => t.opacity = 1), e),
+        G$ = (e, t) => e.reflow(t.modified()).modifies("opacity");
+    ne(XP, j, {
+        transform(e, t) {
+            const n = z$[e.method] || z$.parity,
+                i = e.separation || 0;
+            let r = t.materialize(t.SOURCE).source,
+                s, a;
+            if (!r || !r.length) return;
+            if (!e.method) return e.modified("method") && (j$(r), t = G$(t, e)), t;
+            if (r = r.filter(zV), !r.length) return;
+            if (e.sort && (r = r.slice().sort(e.sort)), s = j$(r), t = G$(t, e), s.length >= 3 && B$(s, i)) {
+                do s = n(s, i); while (s.length >= 3 && B$(s, i));
+                s.length < 3 && !We(r).opacity && (s.length > 1 && (We(s).opacity = 0), We(r).opacity = 1)
+            }
+            e.boundScale && e.boundTolerance >= 0 && (a = BV(e.boundScale, e.boundOrient, +e.boundTolerance), r.forEach(l => {
+                a(l) || (l.opacity = 0)
+            }));
+            const o = s[0].mark.bounds.clear();
+            return r.forEach(l => {
+                l.opacity && o.union(l.bounds)
+            }), t
+        }
+    });
 
-    function xn(e) {
-        return $e(e) ? e : () => e
+    function KP(e) {
+        j.call(this, null, e)
     }
-
-    function h_(e, t) {
-        let n;
-        return i => {
-            n && clearTimeout(n), n = setTimeout(() => (t(i), n = null), e)
+    ne(KP, j, {
+        transform(e, t) {
+            const n = t.dataflow;
+            if (t.visit(t.ALL, i => n.dirty(i)), t.fields && t.fields.zindex) {
+                const i = t.source && t.source[0];
+                i && (i.mark.zdirty = !0)
+            }
         }
-    }
+    });
+    const Cn = new Ut;
 
-    function Ae(e) {
-        for (let t, n, i = 1, r = arguments.length; i < r; ++i) {
-            t = arguments[i];
-            for (n in t) e[n] = t[n]
-        }
-        return e
+    function Iu(e, t, n) {
+        return e[t] === n ? 0 : (e[t] = n, 1)
     }
 
-    function Hr(e, t) {
-        let n = 0,
-            i, r, s, a;
-        if (e && (i = e.length))
-            if (t == null) {
-                for (r = e[n]; n < i && (r == null || r !== r); r = e[++n]);
-                for (s = a = r; n < i; ++n) r = e[n], r != null && (r < s && (s = r), r > a && (a = r))
-            } else {
-                for (r = t(e[n]); n < i && (r == null || r !== r); r = t(e[++n]));
-                for (s = a = r; n < i; ++n) r = t(e[n]), r != null && (r < s && (s = r), r > a && (a = r))
-            } return [s, a]
+    function jV(e) {
+        var t = e.items[0].orient;
+        return t === gr || t === yr
     }
 
-    function eD(e, t) {
-        const n = e.length;
-        let i = -1,
-            r, s, a, o, l;
-        if (t == null) {
-            for (; ++i < n;)
-                if (s = e[i], s != null && s >= s) {
-                    r = a = s;
-                    break
-                } if (i === n) return [-1, -1];
-            for (o = l = i; ++i < n;) s = e[i], s != null && (r > s && (r = s, o = i), a < s && (a = s, l = i))
-        } else {
-            for (; ++i < n;)
-                if (s = t(e[i], i, e), s != null && s >= s) {
-                    r = a = s;
-                    break
-                } if (i === n) return [-1, -1];
-            for (o = l = i; ++i < n;) s = t(e[i], i, e), s != null && (r > s && (r = s, o = i), a < s && (a = s, l = i))
-        }
-        return [o, l]
+    function GV(e) {
+        let t = +e.grid;
+        return [e.ticks ? t++ : -1, e.labels ? t++ : -1, t + +e.domain]
     }
-    const YY = Object.prototype.hasOwnProperty;
 
-    function me(e, t) {
-        return YY.call(e, t)
+    function UV(e, t, n, i) {
+        var r = t.items[0],
+            s = r.datum,
+            a = r.translate != null ? r.translate : .5,
+            o = r.orient,
+            l = GV(s),
+            u = r.range,
+            c = r.offset,
+            f = r.position,
+            h = r.minExtent,
+            d = r.maxExtent,
+            g = s.title && r.items[l[2]].items[0],
+            p = r.titlePadding,
+            m = r.bounds,
+            y = g && bS(g),
+            v = 0,
+            b = 0,
+            x, _;
+        switch (Cn.clear().union(m), m.clear(), (x = l[0]) > -1 && m.union(r.items[x].bounds), (x = l[1]) > -1 && m.union(r.items[x].bounds), o) {
+            case vc:
+                v = f || 0, b = -c, _ = Math.max(h, Math.min(d, -m.y1)), m.add(0, -_).add(u, 0), g && Og(e, g, _, p, y, 0, -1, m);
+                break;
+            case gr:
+                v = -c, b = f || 0, _ = Math.max(h, Math.min(d, -m.x1)), m.add(-_, 0).add(0, u), g && Og(e, g, _, p, y, 1, -1, m);
+                break;
+            case yr:
+                v = n + c, b = f || 0, _ = Math.max(h, Math.min(d, m.x2)), m.add(0, 0).add(_, u), g && Og(e, g, _, p, y, 1, 1, m);
+                break;
+            case ao:
+                v = f || 0, b = i + c, _ = Math.max(h, Math.min(d, m.y2)), m.add(0, 0).add(u, _), g && Og(e, g, _, p, 0, 0, 1, m);
+                break;
+            default:
+                v = r.x, b = r.y
+        }
+        return sa(m.translate(v, b), r), Iu(r, "x", v + a) | Iu(r, "y", b + a) && (r.bounds = Cn, e.dirty(r), r.bounds = m, e.dirty(r)), r.mark.bounds.clear().union(m)
     }
-    const gg = {};
 
-    function _c(e) {
-        let t = {},
-            n;
-
-        function i(s) {
-            return me(t, s) && t[s] !== gg
+    function Og(e, t, n, i, r, s, a, o) {
+        const l = t.bounds;
+        if (t.auto) {
+            const u = a * (n + r + i);
+            let c = 0,
+                f = 0;
+            e.dirty(t), s ? c = (t.x || 0) - (t.x = u) : f = (t.y || 0) - (t.y = u), t.mark.bounds.clear().union(l.translate(-c, -f)), e.dirty(t)
         }
-        const r = {
-            size: 0,
-            empty: 0,
-            object: t,
-            has: i,
-            get(s) {
-                return i(s) ? t[s] : void 0
-            },
-            set(s, a) {
-                return i(s) || (++r.size, t[s] === gg && --r.empty), t[s] = a, this
-            },
-            delete(s) {
-                return i(s) && (--r.size, ++r.empty, t[s] = gg), this
-            },
-            clear() {
-                r.size = r.empty = 0, r.object = t = {}
-            },
-            test(s) {
-                return arguments.length ? (n = s, r) : n
-            },
-            clean() {
-                const s = {};
-                let a = 0;
-                for (const o in t) {
-                    const l = t[o];
-                    l !== gg && (!n || !n(l)) && (s[o] = l, ++a)
-                }
-                r.size = a, r.empty = 0, r.object = t = s
-            }
-        };
-        return e && Object.keys(e).forEach(s => {
-            r.set(s, e[s])
-        }), r
+        o.union(l)
     }
+    const U$ = (e, t) => Math.floor(Math.min(e, t)),
+        W$ = (e, t) => Math.ceil(Math.max(e, t));
 
-    function tD(e, t, n, i, r, s) {
-        if (!n && n !== 0) return s;
-        const a = +n;
-        let o = e[0],
-            l = De(e),
-            u;
-        l < o && (u = o, o = l, l = u), u = Math.abs(t - o);
-        const c = Math.abs(l - t);
-        return u < c && u <= a ? i : c <= a ? r : s
+    function WV(e) {
+        var t = e.items,
+            n = t.length,
+            i = 0,
+            r, s;
+        const a = {
+            marks: [],
+            rowheaders: [],
+            rowfooters: [],
+            colheaders: [],
+            colfooters: [],
+            rowtitle: null,
+            coltitle: null
+        };
+        for (; i < n; ++i)
+            if (r = t[i], s = r.items, r.marktype === M1) switch (r.role) {
+                case DS:
+                case PS:
+                case NS:
+                    break;
+                case LP:
+                    a.rowheaders.push(...s);
+                    break;
+                case IP:
+                    a.rowfooters.push(...s);
+                    break;
+                case BP:
+                    a.colheaders.push(...s);
+                    break;
+                case jP:
+                    a.colfooters.push(...s);
+                    break;
+                case zP:
+                    a.rowtitle = s[0];
+                    break;
+                case GP:
+                    a.coltitle = s[0];
+                    break;
+                default:
+                    a.marks.push(...s)
+            }
+        return a
     }
 
-    function ee(e, t, n) {
-        const i = e.prototype = Object.create(t.prototype);
-        return Object.defineProperty(i, "constructor", {
-            value: e,
-            writable: !0,
-            enumerable: !0,
-            configurable: !0
-        }), Ae(i, n)
+    function qV(e) {
+        return new Ut().set(0, 0, e.width || 0, e.height || 0)
     }
 
-    function hu(e, t, n, i) {
-        let r = t[0],
-            s = t[t.length - 1],
-            a;
-        return r > s && (a = r, r = s, s = a), n = n === void 0 || n, i = i === void 0 || i, (n ? r <= e : r < e) && (i ? e <= s : e < s)
+    function HV(e) {
+        const t = e.bounds.clone();
+        return t.empty() ? t.set(0, 0, 0, 0) : t.translate(-(e.x || 0), -(e.y || 0))
     }
 
-    function Za(e) {
-        return typeof e == "boolean"
+    function wt(e, t, n) {
+        const i = ce(e) ? e[t] : e;
+        return i ?? (n !== void 0 ? n : 0)
     }
 
-    function Ea(e) {
-        return Object.prototype.toString.call(e) === "[object Date]"
+    function q$(e) {
+        return e < 0 ? Math.ceil(-e) : 0
     }
 
-    function nD(e) {
-        return e && $e(e[Symbol.iterator])
+    function JP(e, t, n) {
+        var i = !n.nodirty,
+            r = n.bounds === IS ? qV : HV,
+            s = Cn.set(0, 0, 0, 0),
+            a = wt(n.align, Pa),
+            o = wt(n.align, La),
+            l = wt(n.padding, Pa),
+            u = wt(n.padding, La),
+            c = n.columns || t.length,
+            f = c <= 0 ? 1 : Math.ceil(t.length / c),
+            h = t.length,
+            d = Array(h),
+            g = Array(c),
+            p = 0,
+            m = Array(h),
+            y = Array(f),
+            v = 0,
+            b = Array(h),
+            x = Array(h),
+            _ = Array(h),
+            S, w, E, C, k, A, F, $, T, M, R;
+        for (w = 0; w < c; ++w) g[w] = 0;
+        for (w = 0; w < f; ++w) y[w] = 0;
+        for (w = 0; w < h; ++w) A = t[w], k = _[w] = r(A), A.x = A.x || 0, b[w] = 0, A.y = A.y || 0, x[w] = 0, E = w % c, C = ~~(w / c), p = Math.max(p, F = Math.ceil(k.x2)), v = Math.max(v, $ = Math.ceil(k.y2)), g[E] = Math.max(g[E], F), y[C] = Math.max(y[C], $), d[w] = l + q$(k.x1), m[w] = u + q$(k.y1), i && e.dirty(t[w]);
+        for (w = 0; w < h; ++w) w % c === 0 && (d[w] = 0), w < c && (m[w] = 0);
+        if (a === S2)
+            for (E = 1; E < c; ++E) {
+                for (R = 0, w = E; w < h; w += c) R < d[w] && (R = d[w]);
+                for (w = E; w < h; w += c) d[w] = R + g[E - 1]
+            } else if (a === Tg) {
+                for (R = 0, w = 0; w < h; ++w) w % c && R < d[w] && (R = d[w]);
+                for (w = 0; w < h; ++w) w % c && (d[w] = R + p)
+            } else
+                for (a = !1, E = 1; E < c; ++E)
+                    for (w = E; w < h; w += c) d[w] += g[E - 1];
+        if (o === S2)
+            for (C = 1; C < f; ++C) {
+                for (R = 0, w = C * c, S = w + c; w < S; ++w) R < m[w] && (R = m[w]);
+                for (w = C * c; w < S; ++w) m[w] = R + y[C - 1]
+            } else if (o === Tg) {
+                for (R = 0, w = c; w < h; ++w) R < m[w] && (R = m[w]);
+                for (w = c; w < h; ++w) m[w] = R + v
+            } else
+                for (o = !1, C = 1; C < f; ++C)
+                    for (w = C * c, S = w + c; w < S; ++w) m[w] += y[C - 1];
+        for (T = 0, w = 0; w < h; ++w) T = d[w] + (w % c ? T : 0), b[w] += T - t[w].x;
+        for (E = 0; E < c; ++E)
+            for (M = 0, w = E; w < h; w += c) M += m[w], x[w] += M - t[w].y;
+        if (a && wt(n.center, Pa) && f > 1)
+            for (w = 0; w < h; ++w) k = a === Tg ? p : g[w % c], T = k - _[w].x2 - t[w].x - b[w], T > 0 && (b[w] += T / 2);
+        if (o && wt(n.center, La) && c !== 1)
+            for (w = 0; w < h; ++w) k = o === Tg ? v : y[~~(w / c)], M = k - _[w].y2 - t[w].y - x[w], M > 0 && (x[w] += M / 2);
+        for (w = 0; w < h; ++w) s.union(_[w].translate(b[w], x[w]));
+        switch (T = wt(n.anchor, MV), M = wt(n.anchor, OV), wt(n.anchor, Pa)) {
+            case jn:
+                T -= s.width();
+                break;
+            case w2:
+                T -= s.width() / 2
+        }
+        switch (wt(n.anchor, La)) {
+            case jn:
+                M -= s.height();
+                break;
+            case w2:
+                M -= s.height() / 2
+        }
+        for (T = Math.round(T), M = Math.round(M), s.clear(), w = 0; w < h; ++w) t[w].mark.bounds.clear();
+        for (w = 0; w < h; ++w) A = t[w], A.x += b[w] += T, A.y += x[w] += M, s.union(A.mark.bounds.union(A.bounds.translate(b[w], x[w]))), i && e.dirty(A);
+        return s
     }
 
-    function Ze(e) {
-        return typeof e == "number"
+    function YV(e, t, n) {
+        var i = WV(t),
+            r = i.marks,
+            s = n.bounds === IS ? XV : VV,
+            a = n.offset,
+            o = n.columns || r.length,
+            l = o <= 0 ? 1 : Math.ceil(r.length / o),
+            u = l * o,
+            c, f, h, d, g, p, m;
+        const y = JP(e, r, n);
+        y.empty() && y.set(0, 0, 0, 0), i.rowheaders && (p = wt(n.headerBand, La, null), c = Fg(e, i.rowheaders, r, o, l, -wt(a, "rowHeader"), U$, 0, s, "x1", 0, o, 1, p)), i.colheaders && (p = wt(n.headerBand, Pa, null), f = Fg(e, i.colheaders, r, o, o, -wt(a, "columnHeader"), U$, 1, s, "y1", 0, 1, o, p)), i.rowfooters && (p = wt(n.footerBand, La, null), h = Fg(e, i.rowfooters, r, o, l, wt(a, "rowFooter"), W$, 0, s, "x2", o - 1, o, 1, p)), i.colfooters && (p = wt(n.footerBand, Pa, null), d = Fg(e, i.colfooters, r, o, o, wt(a, "columnFooter"), W$, 1, s, "y2", u - o, 1, o, p)), i.rowtitle && (g = wt(n.titleAnchor, La), m = wt(a, "rowTitle"), m = g === jn ? h + m : c - m, p = wt(n.titleBand, La, .5), H$(e, i.rowtitle, m, 0, y, p)), i.coltitle && (g = wt(n.titleAnchor, Pa), m = wt(a, "columnTitle"), m = g === jn ? d + m : f - m, p = wt(n.titleBand, Pa, .5), H$(e, i.coltitle, m, 1, y, p))
     }
 
-    function iD(e) {
-        return Object.prototype.toString.call(e) === "[object RegExp]"
+    function XV(e, t) {
+        return t === "x1" ? e.x || 0 : t === "y1" ? e.y || 0 : t === "x2" ? (e.x || 0) + (e.width || 0) : t === "y2" ? (e.y || 0) + (e.height || 0) : void 0
     }
 
-    function re(e) {
-        return typeof e == "string"
+    function VV(e, t) {
+        return e.bounds[t]
     }
 
-    function d_(e, t, n) {
-        e && (e = t ? se(e).map(o => o.replace(/\\(.)/g, "$1")) : se(e));
-        const i = e && e.length,
-            r = n && n.get || zR,
-            s = o => r(t ? [o] : ns(o));
-        let a;
-        if (!i) a = function() {
-            return ""
-        };
-        else if (i === 1) {
-            const o = s(e[0]);
-            a = function(l) {
-                return "" + o(l)
-            }
-        } else {
-            const o = e.map(s);
-            a = function(l) {
-                let u = "" + o[0](l),
-                    c = 0;
-                for (; ++c < i;) u += "|" + o[c](l);
-                return u
-            }
+    function Fg(e, t, n, i, r, s, a, o, l, u, c, f, h, d) {
+        var g = n.length,
+            p = 0,
+            m = 0,
+            y, v, b, x, _, S, w, E, C;
+        if (!g) return p;
+        for (y = c; y < g; y += f) n[y] && (p = a(p, l(n[y], u)));
+        if (!t.length) return p;
+        for (t.length > r && (e.warn("Grid headers exceed limit: " + r), t = t.slice(0, r)), p += s, v = 0, x = t.length; v < x; ++v) e.dirty(t[v]), t[v].mark.bounds.clear();
+        for (y = c, v = 0, x = t.length; v < x; ++v, y += f) {
+            for (S = t[v], _ = S.mark.bounds, b = y; b >= 0 && (w = n[b]) == null; b -= h);
+            o ? (E = d == null ? w.x : Math.round(w.bounds.x1 + d * w.bounds.width()), C = p) : (E = p, C = d == null ? w.y : Math.round(w.bounds.y1 + d * w.bounds.height())), _.union(S.bounds.translate(E - (S.x || 0), C - (S.y || 0))), S.x = E, S.y = C, e.dirty(S), m = a(m, _[u])
         }
-        return li(a, e, "key")
-    }
-
-    function rD(e, t) {
-        const n = e[0],
-            i = De(e),
-            r = +t;
-        return r ? r === 1 ? i : n + r * (i - n) : n
+        return m
     }
-    const XY = 1e4;
 
-    function sD(e) {
-        e = +e || XY;
-        let t, n, i;
-        const r = () => {
-                t = {}, n = {}, i = 0
-            },
-            s = (a, o) => (++i > e && (n = t, t = {}, i = 1), t[a] = o);
-        return r(), {
-            clear: r,
-            has: a => me(t, a) || me(n, a),
-            get: a => me(t, a) ? t[a] : me(n, a) ? s(a, n[a]) : void 0,
-            set: (a, o) => me(t, a) ? t[a] = o : s(a, o)
+    function H$(e, t, n, i, r, s) {
+        if (t) {
+            e.dirty(t);
+            var a = n,
+                o = n;
+            i ? a = Math.round(r.x1 + s * r.width()) : o = Math.round(r.y1 + s * r.height()), t.bounds.translate(a - (t.x || 0), o - (t.y || 0)), t.mark.bounds.clear().union(t.bounds), t.x = a, t.y = o, e.dirty(t)
         }
     }
 
-    function aD(e, t, n, i) {
-        const r = t.length,
-            s = n.length;
-        if (!s) return t;
-        if (!r) return n;
-        const a = i || new t.constructor(r + s);
-        let o = 0,
-            l = 0,
-            u = 0;
-        for (; o < r && l < s; ++u) a[u] = e(t[o], n[l]) > 0 ? n[l++] : t[o++];
-        for (; o < r; ++o, ++u) a[u] = t[o];
-        for (; l < s; ++l, ++u) a[u] = n[l];
-        return a
+    function KV(e, t) {
+        const n = e[t] || {};
+        return (i, r) => n[i] != null ? n[i] : e[i] != null ? e[i] : r
     }
 
-    function Ff(e, t) {
-        let n = "";
-        for (; --t >= 0;) n += e;
-        return n
+    function JV(e, t) {
+        let n = -1 / 0;
+        return e.forEach(i => {
+            i.offset != null && (n = Math.max(n, i.offset))
+        }), n > -1 / 0 ? n : t
     }
 
-    function oD(e, t, n, i) {
-        const r = n || " ",
-            s = e + "",
-            a = t - s.length;
-        return a <= 0 ? s : i === "left" ? Ff(r, a) + s : i === "center" ? Ff(r, ~~(a / 2)) + s + Ff(r, Math.ceil(a / 2)) : s + Ff(r, a)
+    function QV(e, t, n, i, r, s, a) {
+        const o = KV(n, t),
+            l = JV(e, o("offset", 0)),
+            u = o("anchor", RS),
+            c = u === jn ? 1 : u === w2 ? .5 : 0,
+            f = {
+                align: S2,
+                bounds: o("bounds", IS),
+                columns: o("direction") === "vertical" ? 1 : e.length,
+                padding: o("margin", 8),
+                center: o("center"),
+                nodirty: !0
+            };
+        switch (t) {
+            case gr:
+                f.anchor = {
+                    x: Math.floor(i.x1) - l,
+                    column: jn,
+                    y: c * (a || i.height() + 2 * i.y1),
+                    row: u
+                };
+                break;
+            case yr:
+                f.anchor = {
+                    x: Math.ceil(i.x2) + l,
+                    y: c * (a || i.height() + 2 * i.y1),
+                    row: u
+                };
+                break;
+            case vc:
+                f.anchor = {
+                    y: Math.floor(r.y1) - l,
+                    row: jn,
+                    x: c * (s || r.width() + 2 * r.x1),
+                    column: u
+                };
+                break;
+            case ao:
+                f.anchor = {
+                    y: Math.ceil(r.y2) + l,
+                    x: c * (s || r.width() + 2 * r.x1),
+                    column: u
+                };
+                break;
+            case CV:
+                f.anchor = {
+                    x: l,
+                    y: l
+                };
+                break;
+            case AV:
+                f.anchor = {
+                    x: s - l,
+                    y: l,
+                    column: jn
+                };
+                break;
+            case $V:
+                f.anchor = {
+                    x: l,
+                    y: a - l,
+                    row: jn
+                };
+                break;
+            case TV:
+                f.anchor = {
+                    x: s - l,
+                    y: a - l,
+                    column: jn,
+                    row: jn
+                };
+                break
+        }
+        return f
     }
 
-    function ad(e) {
-        return e && De(e) - e[0] || 0
+    function ZV(e, t) {
+        var n = t.items[0],
+            i = n.datum,
+            r = n.orient,
+            s = n.bounds,
+            a = n.x,
+            o = n.y,
+            l, u;
+        return n._bounds ? n._bounds.clear().union(s) : n._bounds = s.clone(), s.clear(), tK(e, n, n.items[0].items[0]), s = eK(n, s), l = 2 * n.padding, u = 2 * n.padding, s.empty() || (l = Math.ceil(s.width() + l), u = Math.ceil(s.height() + u)), i.type === NV && nK(n.items[0].items[0].items[0].items), r !== LS && (n.x = a = 0, n.y = o = 0), n.width = l, n.height = u, sa(s.set(a, o, a + l, o + u), n), n.mark.bounds.clear().union(s), n
     }
 
-    function Z(e) {
-        return W(e) ? "[" + e.map(Z) + "]" : ae(e) || re(e) ? JSON.stringify(e).replace("\u2028", "\\u2028").replace("\u2029", "\\u2029") : e
+    function eK(e, t) {
+        return e.items.forEach(n => t.union(n.bounds)), t.x1 = e.padding, t.y1 = e.padding, t
     }
 
-    function g_(e) {
-        return e == null || e === "" ? null : !e || e === "false" || e === "0" ? !1 : !!e
+    function tK(e, t, n) {
+        var i = t.padding,
+            r = i - n.x,
+            s = i - n.y;
+        if (!t.datum.title)(r || s) && $f(e, n, r, s);
+        else {
+            var a = t.items[1].items[0],
+                o = a.anchor,
+                l = t.titlePadding || 0,
+                u = i - a.x,
+                c = i - a.y;
+            switch (a.orient) {
+                case gr:
+                    r += Math.ceil(a.bounds.width()) + l;
+                    break;
+                case yr:
+                case ao:
+                    break;
+                default:
+                    s += a.bounds.height() + l
+            }
+            switch ((r || s) && $f(e, n, r, s), a.orient) {
+                case gr:
+                    c += vu(t, n, a, o, 1, 1);
+                    break;
+                case yr:
+                    u += vu(t, n, a, jn, 0, 0) + l, c += vu(t, n, a, o, 1, 1);
+                    break;
+                case ao:
+                    u += vu(t, n, a, o, 0, 0), c += vu(t, n, a, jn, -1, 0, 1) + l;
+                    break;
+                default:
+                    u += vu(t, n, a, o, 0, 0)
+            }(u || c) && $f(e, a, u, c), (u = Math.round(a.bounds.x1 - i)) < 0 && ($f(e, n, -u, 0), $f(e, a, -u, 0))
+        }
     }
-    const VY = e => Ze(e) || Ea(e) ? e : Date.parse(e);
 
-    function p_(e, t) {
-        return t = t || VY, e == null || e === "" ? null : t(e)
+    function vu(e, t, n, i, r, s, a) {
+        const o = e.datum.type !== "symbol",
+            l = n.datum.vgrad,
+            u = o && (s || !l) && !a ? t.items[0] : t,
+            c = u.bounds[r ? "y2" : "x2"] - e.padding,
+            f = l && s ? c : 0,
+            h = l && s ? 0 : c,
+            d = r <= 0 ? 0 : bS(n);
+        return Math.round(i === RS ? f : i === jn ? h - d : .5 * (c - d))
     }
 
-    function m_(e) {
-        return e == null || e === "" ? null : e + ""
+    function $f(e, t, n, i) {
+        t.x += n, t.y += i, t.bounds.translate(n, i), t.mark.bounds.translate(n, i), e.dirty(t)
     }
 
-    function fr(e) {
-        const t = {},
-            n = e.length;
-        for (let i = 0; i < n; ++i) t[e[i]] = !0;
-        return t
+    function nK(e) {
+        const t = e.reduce((n, i) => (n[i.column] = Math.max(i.bounds.x2 - i.x, n[i.column] || 0), n), {});
+        e.forEach(n => {
+            n.width = t[n.column], n.height = n.bounds.y2 - n.y
+        })
     }
 
-    function lD(e, t, n, i) {
-        const r = i ?? "…",
-            s = e + "",
-            a = s.length,
-            o = Math.max(0, t - r.length);
-        return a <= t ? s : n === "left" ? r + s.slice(a - o) : n === "center" ? s.slice(0, Math.ceil(o / 2)) + r + s.slice(a - ~~(o / 2)) : s.slice(0, o) + r
+    function iK(e, t, n, i, r) {
+        var s = t.items[0],
+            a = s.frame,
+            o = s.orient,
+            l = s.anchor,
+            u = s.offset,
+            c = s.padding,
+            f = s.items[0].items[0],
+            h = s.items[1] && s.items[1].items[0],
+            d = o === gr || o === yr ? i : n,
+            g = 0,
+            p = 0,
+            m = 0,
+            y = 0,
+            v = 0,
+            b;
+        if (a !== M1 ? o === gr ? (g = r.y2, d = r.y1) : o === yr ? (g = r.y1, d = r.y2) : (g = r.x1, d = r.x2) : o === gr && (g = i, d = 0), b = l === RS ? g : l === jn ? d : (g + d) / 2, h && h.text) {
+            switch (o) {
+                case vc:
+                case ao:
+                    v = f.bounds.height() + c;
+                    break;
+                case gr:
+                    y = f.bounds.width() + c;
+                    break;
+                case yr:
+                    y = -f.bounds.width() - c;
+                    break
+            }
+            Cn.clear().union(h.bounds), Cn.translate(y - (h.x || 0), v - (h.y || 0)), Iu(h, "x", y) | Iu(h, "y", v) && (e.dirty(h), h.bounds.clear().union(Cn), h.mark.bounds.clear().union(Cn), e.dirty(h)), Cn.clear().union(h.bounds)
+        } else Cn.clear();
+        switch (Cn.union(f.bounds), o) {
+            case vc:
+                p = b, m = r.y1 - Cn.height() - u;
+                break;
+            case gr:
+                p = r.x1 - Cn.width() - u, m = b;
+                break;
+            case yr:
+                p = r.x2 + Cn.width() + u, m = b;
+                break;
+            case ao:
+                p = b, m = r.y2 + u;
+                break;
+            default:
+                p = s.x, m = s.y
+        }
+        return Iu(s, "x", p) | Iu(s, "y", m) && (Cn.translate(p, m), e.dirty(s), s.bounds.clear().union(Cn), t.bounds.clear().union(Cn), e.dirty(s)), s.bounds
     }
 
-    function oa(e, t, n) {
-        if (e)
-            if (t) {
-                const i = e.length;
-                for (let r = 0; r < i; ++r) {
-                    const s = t(e[r]);
-                    s && n(s, r, e)
-                }
-            } else e.forEach(n)
+    function QP(e) {
+        j.call(this, null, e)
     }
+    ne(QP, j, {
+        transform(e, t) {
+            const n = t.dataflow;
+            return e.mark.items.forEach(i => {
+                e.layout && YV(n, i, e.layout), sK(n, i, e)
+            }), rK(e.mark.group) ? t.reflow() : t
+        }
+    });
 
-    function KY(e) {
-        return e
+    function rK(e) {
+        return e && e.mark.role !== "legend-entry"
     }
 
-    function JY(e) {
-        if (e == null) return KY;
-        var t, n, i = e.scale[0],
-            r = e.scale[1],
-            s = e.translate[0],
-            a = e.translate[1];
-        return function(o, l) {
-            l || (t = n = 0);
-            var u = 2,
-                c = o.length,
-                f = new Array(c);
-            for (f[0] = (t += o[0]) * i + s, f[1] = (n += o[1]) * r + a; u < c;) f[u] = o[u], ++u;
-            return f
+    function sK(e, t, n) {
+        var i = t.items,
+            r = Math.max(0, t.width || 0),
+            s = Math.max(0, t.height || 0),
+            a = new Ut().set(0, 0, r, s),
+            o = a.clone(),
+            l = a.clone(),
+            u = [],
+            c, f, h, d, g, p;
+        for (g = 0, p = i.length; g < p; ++g) switch (f = i[g], f.role) {
+            case DS:
+                d = jV(f) ? o : l, d.union(UV(e, f, r, s));
+                break;
+            case NS:
+                c = f;
+                break;
+            case PS:
+                u.push(ZV(e, f));
+                break;
+            case FV:
+            case RV:
+            case LP:
+            case IP:
+            case zP:
+            case BP:
+            case jP:
+            case GP:
+                o.union(f.bounds), l.union(f.bounds);
+                break;
+            default:
+                a.union(f.bounds)
+        }
+        if (u.length) {
+            const m = {};
+            u.forEach(y => {
+                h = y.orient || yr, h !== LS && (m[h] || (m[h] = [])).push(y)
+            });
+            for (const y in m) {
+                const v = m[y];
+                JP(e, v, QV(v, y, n.legends, o, l, r, s))
+            }
+            u.forEach(y => {
+                const v = y.bounds;
+                if (v.equals(y._bounds) || (y.bounds = y._bounds, e.dirty(y), y.bounds = v, e.dirty(y)), n.autosize && (n.autosize.type === UP || n.autosize.type === WP || n.autosize.type === qP)) switch (y.orient) {
+                    case gr:
+                    case yr:
+                        a.add(v.x1, 0).add(v.x2, 0);
+                        break;
+                    case vc:
+                    case ao:
+                        a.add(0, v.y1).add(0, v.y2)
+                } else a.union(v)
+            })
         }
+        a.union(o).union(l), c && a.union(iK(e, c, r, s, a)), t.clip && a.set(0, 0, t.width || 0, t.height || 0), aK(e, t, a, n)
     }
 
-    function QY(e, t) {
-        for (var n, i = e.length, r = i - t; r < --i;) n = e[r], e[r++] = e[i], e[i] = n
+    function aK(e, t, n, i) {
+        const r = i.autosize || {},
+            s = r.type;
+        if (e._autosize < 1 || !s) return;
+        let a = e._width,
+            o = e._height,
+            l = Math.max(0, t.width || 0),
+            u = Math.max(0, Math.ceil(-n.x1)),
+            c = Math.max(0, t.height || 0),
+            f = Math.max(0, Math.ceil(-n.y1));
+        const h = Math.max(0, Math.ceil(n.x2 - l)),
+            d = Math.max(0, Math.ceil(n.y2 - c));
+        if (r.contains === DV) {
+            const g = e.padding();
+            a -= g.left + g.right, o -= g.top + g.bottom
+        }
+        s === LS ? (u = 0, f = 0, l = a, c = o) : s === UP ? (l = Math.max(0, a - u - h), c = Math.max(0, o - f - d)) : s === WP ? (l = Math.max(0, a - u - h), o = c + f + d) : s === qP ? (a = l + u + h, c = Math.max(0, o - f - d)) : s === PV && (a = l + u + h, o = c + f + d), e._resizeView(a, o, l, c, [u, f], r.resize)
     }
+    const oK = Object.freeze(Object.defineProperty({
+        __proto__: null,
+        bound: HP,
+        identifier: zS,
+        mark: YP,
+        overlap: XP,
+        render: KP,
+        viewlayout: QP
+    }, Symbol.toStringTag, {
+        value: "Module"
+    }));
 
-    function ZY(e, t) {
-        return typeof t == "string" && (t = e.objects[t]), t.type === "GeometryCollection" ? {
-            type: "FeatureCollection",
-            features: t.geometries.map(function(n) {
-                return _$(e, n)
-            })
-        } : _$(e, t)
+    function ZP(e) {
+        j.call(this, null, e)
     }
-
-    function _$(e, t) {
-        var n = t.id,
-            i = t.bbox,
-            r = t.properties == null ? {} : t.properties,
-            s = uD(e, t);
-        return n == null && i == null ? {
-            type: "Feature",
-            properties: r,
-            geometry: s
-        } : i == null ? {
-            type: "Feature",
-            id: n,
-            properties: r,
-            geometry: s
-        } : {
-            type: "Feature",
-            id: n,
-            bbox: i,
-            properties: r,
-            geometry: s
+    ne(ZP, j, {
+        transform(e, t) {
+            if (this.value && !e.modified()) return t.StopPropagation;
+            var n = t.dataflow.locale(),
+                i = t.fork(t.NO_SOURCE | t.NO_FIELDS),
+                r = this.value,
+                s = e.scale,
+                a = e.count == null ? e.values ? e.values.length : 10 : e.count,
+                o = eS(s, a, e.minstep),
+                l = e.format || RN(n, s, o, e.formatSpecifier, e.formatType, !!e.values),
+                u = e.values ? FN(s, e.values, o) : tS(s, o);
+            return r && (i.rem = r), r = u.map((c, f) => it({
+                index: f / (u.length - 1 || 1),
+                value: c,
+                label: l(c)
+            })), e.extra && r.length && r.push(it({
+                index: -1,
+                extra: {
+                    value: r[0].value
+                },
+                label: ""
+            })), i.source = r, i.add = r, this.value = r, i
         }
+    });
+
+    function e4(e) {
+        j.call(this, null, e)
     }
 
-    function uD(e, t) {
-        var n = JY(e.transform),
-            i = e.arcs;
+    function lK() {
+        return it({})
+    }
 
-        function r(c, f) {
-            f.length && f.pop();
-            for (var h = i[c < 0 ? ~c : c], d = 0, g = h.length; d < g; ++d) f.push(n(h[d], d));
-            c < 0 && QY(f, g)
+    function uK(e) {
+        const t = Uc().test(n => n.exit);
+        return t.lookup = n => t.get(e(n)), t
+    }
+    ne(e4, j, {
+        transform(e, t) {
+            var n = t.dataflow,
+                i = t.fork(t.NO_SOURCE | t.NO_FIELDS),
+                r = e.item || lK,
+                s = e.key || Ee,
+                a = this.value;
+            return H(i.encode) && (i.encode = null), a && (e.modified("key") || t.modified(s)) && q("DataJoin does not support modified key function or fields."), a || (t = t.addAll(), this.value = a = uK(s)), t.visit(t.ADD, o => {
+                const l = s(o);
+                let u = a.get(l);
+                u ? u.exit ? (a.empty--, i.add.push(u)) : i.mod.push(u) : (u = r(o), a.set(l, u), i.add.push(u)), u.datum = o, u.exit = !1
+            }), t.visit(t.MOD, o => {
+                const l = s(o),
+                    u = a.get(l);
+                u && (u.datum = o, i.mod.push(u))
+            }), t.visit(t.REM, o => {
+                const l = s(o),
+                    u = a.get(l);
+                o === u.datum && !u.exit && (i.rem.push(u), u.exit = !0, ++a.empty)
+            }), t.changed(t.ADD_MOD) && i.modifies("datum"), (t.clean() || e.clean && a.empty > n.cleanThreshold) && n.runAfter(a.clean), i
         }
+    });
 
-        function s(c) {
-            return n(c)
+    function t4(e) {
+        j.call(this, null, e)
+    }
+    ne(t4, j, {
+        transform(e, t) {
+            var n = t.fork(t.ADD_REM),
+                i = e.mod || !1,
+                r = e.encoders,
+                s = t.encode;
+            if (H(s))
+                if (n.changed() || s.every(f => r[f])) s = s[0], n.encode = null;
+                else return t.StopPropagation;
+            var a = s === "enter",
+                o = r.update || _a,
+                l = r.enter || _a,
+                u = r.exit || _a,
+                c = (s && !a ? r[s] : o) || _a;
+            if (t.changed(t.ADD) && (t.visit(t.ADD, f => {
+                    l(f, e), o(f, e)
+                }), n.modifies(l.output), n.modifies(o.output), c !== _a && c !== o && (t.visit(t.ADD, f => {
+                    c(f, e)
+                }), n.modifies(c.output))), t.changed(t.REM) && u !== _a && (t.visit(t.REM, f => {
+                    u(f, e)
+                }), n.modifies(u.output)), a || c !== _a) {
+                const f = t.MOD | (e.modified() ? t.REFLOW : 0);
+                a ? (t.visit(f, h => {
+                    const d = l(h, e) || i;
+                    (c(h, e) || d) && n.mod.push(h)
+                }), n.mod.length && n.modifies(l.output)) : t.visit(f, h => {
+                    (c(h, e) || i) && n.mod.push(h)
+                }), n.mod.length && n.modifies(c.output)
+            }
+            return n.changed() ? n : t.StopPropagation
         }
+    });
 
-        function a(c) {
-            for (var f = [], h = 0, d = c.length; h < d; ++h) r(c[h], f);
-            return f.length < 2 && f.push(f[0]), f
+    function n4(e) {
+        j.call(this, [], e)
+    }
+    ne(n4, j, {
+        transform(e, t) {
+            if (this.value != null && !e.modified()) return t.StopPropagation;
+            var n = t.dataflow.locale(),
+                i = t.fork(t.NO_SOURCE | t.NO_FIELDS),
+                r = this.value,
+                s = e.type || Ep,
+                a = e.scale,
+                o = +e.limit,
+                l = eS(a, e.count == null ? 5 : e.count, e.minstep),
+                u = !!e.values || s === Ep,
+                c = e.format || LN(n, a, l, s, e.formatSpecifier, e.formatType, u),
+                f = e.values || PN(a, l),
+                h, d, g, p, m;
+            return r && (i.rem = r), s === Ep ? (o && f.length > o ? (t.dataflow.warn("Symbol legend count exceeds limit, filtering items."), r = f.slice(0, o - 1), m = !0) : r = f, Pe(g = e.size) ? (!e.values && a(r[0]) === 0 && (r = r.slice(1)), p = r.reduce((y, v) => Math.max(y, g(v, e)), 0)) : g = Ln(p = g || 8), r = r.map((y, v) => it({
+                index: v,
+                label: c(y, v, r),
+                value: y,
+                offset: p,
+                size: g(y, e)
+            })), m && (m = f[r.length], r.push(it({
+                index: r.length,
+                label: `…${f.length-r.length} entries`,
+                value: m,
+                offset: p,
+                size: g(m, e)
+            })))) : s === LH ? (h = a.domain(), d = TN(a, h[0], We(h)), f.length < 3 && !e.values && h[0] !== We(h) && (f = [h[0], We(h)]), r = f.map((y, v) => it({
+                index: v,
+                label: c(y, v, f),
+                value: y,
+                perc: d(y)
+            }))) : (g = f.length - 1, d = XH(a), r = f.map((y, v) => it({
+                index: v,
+                label: c(y, v, f),
+                value: y,
+                perc: v ? d(y) : 0,
+                perc2: v === g ? 1 : d(f[v + 1])
+            }))), i.source = r, i.add = r, this.value = r, i
         }
+    });
+    const cK = e => e.source.x,
+        fK = e => e.source.y,
+        hK = e => e.target.x,
+        dK = e => e.target.y;
 
-        function o(c) {
-            for (var f = a(c); f.length < 4;) f.push(f[0]);
-            return f
+    function BS(e) {
+        j.call(this, {}, e)
+    }
+    BS.Definition = {
+        type: "LinkPath",
+        metadata: {
+            modifies: !0
+        },
+        params: [{
+            name: "sourceX",
+            type: "field",
+            default: "source.x"
+        }, {
+            name: "sourceY",
+            type: "field",
+            default: "source.y"
+        }, {
+            name: "targetX",
+            type: "field",
+            default: "target.x"
+        }, {
+            name: "targetY",
+            type: "field",
+            default: "target.y"
+        }, {
+            name: "orient",
+            type: "enum",
+            default: "vertical",
+            values: ["horizontal", "vertical", "radial"]
+        }, {
+            name: "shape",
+            type: "enum",
+            default: "line",
+            values: ["line", "arc", "curve", "diagonal", "orthogonal"]
+        }, {
+            name: "require",
+            type: "signal"
+        }, {
+            name: "as",
+            type: "string",
+            default: "path"
+        }]
+    };
+    ne(BS, j, {
+        transform(e, t) {
+            var n = e.sourceX || cK,
+                i = e.sourceY || fK,
+                r = e.targetX || hK,
+                s = e.targetY || dK,
+                a = e.as || "path",
+                o = e.orient || "vertical",
+                l = e.shape || "line",
+                u = Y$.get(l + "-" + o) || Y$.get(l);
+            return u || q("LinkPath unsupported type: " + e.shape + (e.orient ? "-" + e.orient : "")), t.visit(t.SOURCE, c => {
+                c[a] = u(n(c), i(c), r(c), s(c))
+            }), t.reflow(e.modified()).modifies(a)
         }
+    });
+    const i4 = (e, t, n, i) => "M" + e + "," + t + "L" + n + "," + i,
+        gK = (e, t, n, i) => i4(t * Math.cos(e), t * Math.sin(e), i * Math.cos(n), i * Math.sin(n)),
+        r4 = (e, t, n, i) => {
+            var r = n - e,
+                s = i - t,
+                a = Math.hypot(r, s) / 2,
+                o = 180 * Math.atan2(s, r) / Math.PI;
+            return "M" + e + "," + t + "A" + a + "," + a + " " + o + " 0 1 " + n + "," + i
+        },
+        pK = (e, t, n, i) => r4(t * Math.cos(e), t * Math.sin(e), i * Math.cos(n), i * Math.sin(n)),
+        s4 = (e, t, n, i) => {
+            const r = n - e,
+                s = i - t,
+                a = .2 * (r + s),
+                o = .2 * (s - r);
+            return "M" + e + "," + t + "C" + (e + a) + "," + (t + o) + " " + (n + o) + "," + (i - a) + " " + n + "," + i
+        },
+        mK = (e, t, n, i) => s4(t * Math.cos(e), t * Math.sin(e), i * Math.cos(n), i * Math.sin(n)),
+        yK = (e, t, n, i) => "M" + e + "," + t + "V" + i + "H" + n,
+        vK = (e, t, n, i) => "M" + e + "," + t + "H" + n + "V" + i,
+        bK = (e, t, n, i) => {
+            const r = Math.cos(e),
+                s = Math.sin(e),
+                a = Math.cos(n),
+                o = Math.sin(n),
+                l = Math.abs(n - e) > Math.PI ? n <= e : n > e;
+            return "M" + t * r + "," + t * s + "A" + t + "," + t + " 0 0," + (l ? 1 : 0) + " " + t * a + "," + t * o + "L" + i * a + "," + i * o
+        },
+        xK = (e, t, n, i) => {
+            const r = (e + n) / 2;
+            return "M" + e + "," + t + "C" + r + "," + t + " " + r + "," + i + " " + n + "," + i
+        },
+        _K = (e, t, n, i) => {
+            const r = (t + i) / 2;
+            return "M" + e + "," + t + "C" + e + "," + r + " " + n + "," + r + " " + n + "," + i
+        },
+        wK = (e, t, n, i) => {
+            const r = Math.cos(e),
+                s = Math.sin(e),
+                a = Math.cos(n),
+                o = Math.sin(n),
+                l = (t + i) / 2;
+            return "M" + t * r + "," + t * s + "C" + l * r + "," + l * s + " " + l * a + "," + l * o + " " + i * a + "," + i * o
+        },
+        Y$ = Uc({
+            line: i4,
+            "line-radial": gK,
+            arc: r4,
+            "arc-radial": pK,
+            curve: s4,
+            "curve-radial": mK,
+            "orthogonal-horizontal": yK,
+            "orthogonal-vertical": vK,
+            "orthogonal-radial": bK,
+            "diagonal-horizontal": xK,
+            "diagonal-vertical": _K,
+            "diagonal-radial": wK
+        });
 
-        function l(c) {
-            return c.map(o)
+    function jS(e) {
+        j.call(this, null, e)
+    }
+    jS.Definition = {
+        type: "Pie",
+        metadata: {
+            modifies: !0
+        },
+        params: [{
+            name: "field",
+            type: "field"
+        }, {
+            name: "startAngle",
+            type: "number",
+            default: 0
+        }, {
+            name: "endAngle",
+            type: "number",
+            default: 6.283185307179586
+        }, {
+            name: "sort",
+            type: "boolean",
+            default: !1
+        }, {
+            name: "as",
+            type: "string",
+            array: !0,
+            length: 2,
+            default: ["startAngle", "endAngle"]
+        }]
+    };
+    ne(jS, j, {
+        transform(e, t) {
+            var n = e.as || ["startAngle", "endAngle"],
+                i = n[0],
+                r = n[1],
+                s = e.field || Bc,
+                a = e.startAngle || 0,
+                o = e.endAngle != null ? e.endAngle : 2 * Math.PI,
+                l = t.source,
+                u = l.map(s),
+                c = u.length,
+                f = a,
+                h = (o - a) / CF(u),
+                d = $i(c),
+                g, p, m;
+            for (e.sort && d.sort((y, v) => u[y] - u[v]), g = 0; g < c; ++g) m = u[d[g]], p = l[d[g]], p[i] = f, p[r] = f += m * h;
+            return this.value = u, t.reflow(e.modified()).modifies(n)
         }
+    });
+    const SK = 5;
 
-        function u(c) {
-            var f = c.type,
-                h;
-            switch (f) {
-                case "GeometryCollection":
-                    return {
-                        type: f, geometries: c.geometries.map(u)
-                    };
-                case "Point":
-                    h = s(c.coordinates);
-                    break;
-                case "MultiPoint":
-                    h = c.coordinates.map(s);
-                    break;
-                case "LineString":
-                    h = a(c.arcs);
-                    break;
-                case "MultiLineString":
-                    h = c.arcs.map(a);
-                    break;
-                case "Polygon":
-                    h = l(c.arcs);
-                    break;
-                case "MultiPolygon":
-                    h = c.arcs.map(l);
-                    break;
-                default:
-                    return null
-            }
-            return {
-                type: f,
-                coordinates: h
-            }
-        }
-        return u(t)
+    function EK(e) {
+        const t = e.type;
+        return !e.bins && (t === fc || t === Nd || t === Pd)
     }
 
-    function eX(e, t) {
-        var n = {},
-            i = {},
-            r = {},
-            s = [],
-            a = -1;
-        t.forEach(function(u, c) {
-            var f = e.arcs[u < 0 ? ~u : u],
-                h;
-            f.length < 3 && !f[1][0] && !f[1][1] && (h = t[++a], t[a] = u, t[c] = h)
-        }), t.forEach(function(u) {
-            var c = o(u),
-                f = c[0],
-                h = c[1],
-                d, g;
-            if (d = r[f])
-                if (delete r[d.end], d.push(u), d.end = h, g = i[h]) {
-                    delete i[g.start];
-                    var p = g === d ? d : d.concat(g);
-                    i[p.start = d.start] = r[p.end = g.end] = p
-                } else i[d.start] = r[d.end] = d;
-            else if (d = i[h])
-                if (delete i[d.start], d.unshift(u), d.start = f, g = r[f]) {
-                    delete r[g.end];
-                    var m = g === d ? d : g.concat(d);
-                    i[m.start = g.start] = r[m.end = d.end] = m
-                } else i[d.start] = r[d.end] = d;
-            else d = [u], i[d.start = f] = r[d.end = h] = d
-        });
+    function a4(e) {
+        return Jw(e) && e !== ts
+    }
+    const kK = Cr(["set", "modified", "clear", "type", "scheme", "schemeExtent", "schemeCount", "domain", "domainMin", "domainMid", "domainMax", "domainRaw", "domainImplicit", "nice", "zero", "bins", "range", "rangeStep", "round", "reverse", "interpolate", "interpolateGamma"]);
 
-        function o(u) {
-            var c = e.arcs[u < 0 ? ~u : u],
-                f = c[0],
-                h;
-            return e.transform ? (h = [0, 0], c.forEach(function(d) {
-                h[0] += d[0], h[1] += d[1]
-            })) : h = c[c.length - 1], u < 0 ? [h, f] : [f, h]
+    function o4(e) {
+        j.call(this, null, e), this.modified(!0)
+    }
+    ne(o4, j, {
+        transform(e, t) {
+            var n = t.dataflow,
+                i = this.value,
+                r = CK(e);
+            (!i || r !== i.type) && (this.value = i = Ze(r)());
+            for (r in e)
+                if (!kK[r]) {
+                    if (r === "padding" && a4(i.type)) continue;
+                    Pe(i[r]) ? i[r](e[r]) : n.warn("Unsupported scale property: " + r)
+                } return FK(i, e, OK(i, e, $K(i, e, n))), t.fork(t.NO_SOURCE | t.NO_FIELDS)
         }
+    });
 
-        function l(u, c) {
-            for (var f in u) {
-                var h = u[f];
-                delete c[h.start], delete h.start, delete h.end, h.forEach(function(d) {
-                    n[d < 0 ? ~d : d] = 1
-                }), s.push(h)
-            }
-        }
-        return l(r, i), l(i, r), t.forEach(function(u) {
-            n[u < 0 ? ~u : u] || s.push([u])
-        }), s
+    function CK(e) {
+        var t = e.type,
+            n = "",
+            i;
+        return t === ts ? ts + "-" + fc : (AK(e) && (i = e.rawDomain ? e.rawDomain.length : e.domain ? e.domain.length + +(e.domainMid != null) : 0, n = i === 2 ? ts + "-" : i === 3 ? Kc + "-" : ""), (n + t || fc).toLowerCase())
     }
 
-    function tX(e) {
-        return uD(e, nX.apply(this, arguments))
+    function AK(e) {
+        const t = e.type;
+        return Jw(t) && t !== Sl && t !== El && (e.scheme || e.range && e.range.length && e.range.every(le))
     }
 
-    function nX(e, t, n) {
-        var i, r, s;
-        if (arguments.length > 1) i = iX(e, t, n);
-        else
-            for (r = 0, i = new Array(s = e.arcs.length); r < s; ++r) i[r] = r;
-        return {
-            type: "MultiLineString",
-            arcs: eX(e, i)
+    function $K(e, t, n) {
+        const i = TK(e, t.domainRaw, n);
+        if (i > -1) return i;
+        var r = t.domain,
+            s = e.type,
+            a = t.zero || t.zero === void 0 && EK(e),
+            o, l;
+        if (!r) return 0;
+        if (a4(s) && t.padding && r[0] !== We(r) && (r = MK(s, r, t.range, t.padding, t.exponent, t.constant)), (a || t.domainMin != null || t.domainMax != null || t.domainMid != null) && (o = (r = r.slice()).length - 1 || 1, a && (r[0] > 0 && (r[0] = 0), r[o] < 0 && (r[o] = 0)), t.domainMin != null && (r[0] = t.domainMin), t.domainMax != null && (r[o] = t.domainMax), t.domainMid != null)) {
+            l = t.domainMid;
+            const u = l > r[o] ? o + 1 : l < r[0] ? 0 : o;
+            u !== o && n.warn("Scale domainMid exceeds domain min or max.", l), r.splice(u, 0, l)
         }
+        return e.domain(l4(s, r, n)), s === Yw && e.unknown(t.domainImplicit ? n2 : void 0), t.nice && e.nice && e.nice(t.nice !== !0 && eS(e, t.nice) || null), r.length
     }
 
-    function iX(e, t, n) {
-        var i = [],
-            r = [],
-            s;
-
-        function a(f) {
-            var h = f < 0 ? ~f : f;
-            (r[h] || (r[h] = [])).push({
-                i: f,
-                g: s
-            })
-        }
+    function TK(e, t, n) {
+        return t ? (e.domain(l4(e.type, t, n)), t.length) : -1
+    }
 
-        function o(f) {
-            f.forEach(a)
-        }
+    function MK(e, t, n, i, r, s) {
+        var a = Math.abs(We(n) - n[0]),
+            o = a / (a - 2 * i),
+            l = e === ea ? m_(t, null, o) : e === Pd ? tm(t, null, o, .5) : e === Nd ? tm(t, null, o, r || 1) : e === p1 ? y_(t, null, o, s || 1) : p_(t, null, o);
+        return t = t.slice(), t[0] = l[0], t[t.length - 1] = l[1], t
+    }
 
-        function l(f) {
-            f.forEach(o)
+    function l4(e, t, n) {
+        if (EN(e)) {
+            var i = Math.abs(t.reduce((r, s) => r + (s < 0 ? -1 : s > 0 ? 1 : 0), 0));
+            i !== t.length && n.warn("Log scale domain includes zero: " + te(t))
         }
+        return t
+    }
 
-        function u(f) {
-            f.forEach(l)
+    function OK(e, t, n) {
+        let i = t.bins;
+        if (i && !H(i)) {
+            const r = e.domain(),
+                s = r[0],
+                a = We(r),
+                o = i.step;
+            let l = i.start == null ? s : i.start,
+                u = i.stop == null ? a : i.stop;
+            o || q("Scale bins parameter missing step property."), l < s && (l = o * Math.ceil(s / o)), u > a && (u = o * Math.floor(a / o)), i = $i(l, u + o / 2, o)
         }
+        return i ? e.bins = i : e.bins && delete e.bins, e.type === Xw && (i ? !t.domain && !t.domainRaw && (e.domain(i), n = i.length) : e.bins = e.domain()), n
+    }
 
-        function c(f) {
-            switch (s = f, f.type) {
-                case "GeometryCollection":
-                    f.geometries.forEach(c);
-                    break;
-                case "LineString":
-                    o(f.arcs);
-                    break;
-                case "MultiLineString":
-                case "Polygon":
-                    l(f.arcs);
-                    break;
-                case "MultiPolygon":
-                    u(f.arcs);
-                    break
-            }
+    function FK(e, t, n) {
+        var i = e.type,
+            r = t.round || !1,
+            s = t.range;
+        if (t.rangeStep != null) s = RK(i, t, n);
+        else if (t.scheme && (s = DK(i, t, n), Pe(s))) {
+            if (e.interpolator) return e.interpolator(s);
+            q(`Scale type ${i} does not support interpolating color schemes.`)
         }
-        return c(t), r.forEach(n == null ? function(f) {
-            i.push(f[0].i)
-        } : function(f) {
-            n(f[0].g, f[f.length - 1].g) && i.push(f[0].i)
-        }), i
+        if (s && kN(i)) return e.interpolator(v1(E2(s, t.reverse), t.interpolate, t.interpolateGamma));
+        s && t.interpolate && e.interpolate ? e.interpolate(Qw(t.interpolate, t.interpolateGamma)) : Pe(e.round) ? e.round(r) : Pe(e.rangeRound) && e.interpolate(r ? Rd : bo), s && e.range(E2(s, t.reverse))
     }
-    const Jt = "year",
-        ii = "quarter",
-        mn = "month",
-        Tt = "week",
-        ri = "date",
-        fn = "day",
-        Yr = "dayofyear",
-        vi = "hours",
-        bi = "minutes",
-        Di = "seconds",
-        hr = "milliseconds",
-        y_ = [Jt, ii, mn, Tt, ri, fn, Yr, vi, bi, Di, hr],
-        Yy = y_.reduce((e, t, n) => (e[t] = 1 + n, e), {});
 
-    function v_(e) {
-        const t = se(e).slice(),
-            n = {};
-        return t.length || U("Missing time unit."), t.forEach(r => {
-            me(Yy, r) ? n[r] = 1 : U(`Invalid time unit: ${r}.`)
-        }), (n[Tt] || n[fn] ? 1 : 0) + (n[ii] || n[mn] || n[ri] ? 1 : 0) + (n[Yr] ? 1 : 0) > 1 && U(`Incompatible time units: ${e}`), t.sort((r, s) => Yy[r] - Yy[s]), t
-    }
-    const rX = {
-        [Jt]: "%Y ",
-        [ii]: "Q%q ",
-        [mn]: "%b ",
-        [ri]: "%d ",
-        [Tt]: "W%U ",
-        [fn]: "%a ",
-        [Yr]: "%j ",
-        [vi]: "%H:00",
-        [bi]: "00:%M",
-        [Di]: ":%S",
-        [hr]: ".%L",
-        [`${Jt}-${mn}`]: "%Y-%m ",
-        [`${Jt}-${mn}-${ri}`]: "%Y-%m-%d ",
-        [`${vi}-${bi}`]: "%H:%M"
-    };
-
-    function cD(e, t) {
-        const n = Ae({}, rX, t),
-            i = v_(e),
-            r = i.length;
-        let s = "",
-            a = 0,
-            o, l;
-        for (a = 0; a < r;)
-            for (o = i.length; o > a; --o)
-                if (l = i.slice(a, o).join("-"), n[l] != null) {
-                    s += n[l], a = o;
-                    break
-                } return s.trim()
+    function RK(e, t, n) {
+        e !== vN && e !== u2 && q("Only band and point scales support rangeStep.");
+        var i = (t.paddingOuter != null ? t.paddingOuter : t.padding) || 0,
+            r = e === u2 ? 1 : (t.paddingInner != null ? t.paddingInner : t.padding) || 0;
+        return [0, t.rangeStep * Hw(n, r, i)]
     }
-    const $o = new Date;
 
-    function b_(e) {
-        return $o.setFullYear(e), $o.setMonth(0), $o.setDate(1), $o.setHours(0, 0, 0, 0), $o
+    function DK(e, t, n) {
+        var i = t.schemeExtent,
+            r, s;
+        return H(t.scheme) ? s = v1(t.scheme, t.interpolate, t.interpolateGamma) : (r = t.scheme.toLowerCase(), s = Zw(r), s || q(`Unrecognized scheme name: ${t.scheme}`)), n = e === y1 ? n + 1 : e === Xw ? n - 1 : e === hc || e === m1 ? +t.schemeCount || SK : n, kN(e) ? X$(s, i, t.reverse) : Pe(s) ? $N(X$(s, i), n) : e === Yw ? s : s.slice(0, n)
     }
 
-    function fD(e) {
-        return dD(new Date(e))
+    function X$(e, t, n) {
+        return Pe(e) && (t || n) ? AN(e, E2(t || [0, 1], n)) : e
     }
 
-    function hD(e) {
-        return qb(new Date(e))
+    function E2(e, t) {
+        return t ? e.slice().reverse() : e
     }
 
-    function dD(e) {
-        return Os.count(b_(e.getFullYear()) - 1, e)
+    function u4(e) {
+        j.call(this, null, e)
     }
+    ne(u4, j, {
+        transform(e, t) {
+            const n = e.modified("sort") || t.changed(t.ADD) || t.modified(e.sort.fields) || t.modified("datum");
+            return n && t.source.sort(Yl(e.sort)), this.modified(n), t
+        }
+    });
+    const V$ = "zero",
+        c4 = "center",
+        f4 = "normalize",
+        h4 = ["y0", "y1"];
 
-    function qb(e) {
-        return mc.count(b_(e.getFullYear()) - 1, e)
+    function GS(e) {
+        j.call(this, null, e)
     }
+    GS.Definition = {
+        type: "Stack",
+        metadata: {
+            modifies: !0
+        },
+        params: [{
+            name: "field",
+            type: "field"
+        }, {
+            name: "groupby",
+            type: "field",
+            array: !0
+        }, {
+            name: "sort",
+            type: "compare"
+        }, {
+            name: "offset",
+            type: "enum",
+            default: V$,
+            values: [V$, c4, f4]
+        }, {
+            name: "as",
+            type: "string",
+            array: !0,
+            length: 2,
+            default: h4
+        }]
+    };
+    ne(GS, j, {
+        transform(e, t) {
+            var n = e.as || h4,
+                i = n[0],
+                r = n[1],
+                s = Yl(e.sort),
+                a = e.field || Bc,
+                o = e.offset === c4 ? NK : e.offset === f4 ? PK : LK,
+                l, u, c, f;
+            for (l = IK(t.source, e.groupby, s, a), u = 0, c = l.length, f = l.max; u < c; ++u) o(l[u], f, a, i, r);
+            return t.reflow(e.modified()).modifies(n)
+        }
+    });
 
-    function Hb(e) {
-        return b_(e).getDay()
+    function NK(e, t, n, i, r) {
+        for (var s = (t - e.sum) / 2, a = e.length, o = 0, l; o < a; ++o) l = e[o], l[i] = s, l[r] = s += Math.abs(n(l))
     }
 
-    function sX(e, t, n, i, r, s, a) {
-        if (0 <= e && e < 100) {
-            const o = new Date(-1, t, n, i, r, s, a);
-            return o.setFullYear(e), o
-        }
-        return new Date(e, t, n, i, r, s, a)
+    function PK(e, t, n, i, r) {
+        for (var s = 1 / e.sum, a = 0, o = e.length, l = 0, u = 0, c; l < o; ++l) c = e[l], c[i] = a, c[r] = a = s * (u += Math.abs(n(c)))
     }
 
-    function gD(e) {
-        return mD(new Date(e))
+    function LK(e, t, n, i, r) {
+        for (var s = 0, a = 0, o = e.length, l = 0, u, c; l < o; ++l) c = e[l], u = +n(c), u < 0 ? (c[i] = a, c[r] = a += u) : (c[i] = s, c[r] = s += u)
     }
 
-    function pD(e) {
-        return Yb(new Date(e))
+    function IK(e, t, n, i) {
+        var r = [],
+            s = p => p(c),
+            a, o, l, u, c, f, h, d, g;
+        if (t == null) r.push(e.slice());
+        else
+            for (a = {}, o = 0, l = e.length; o < l; ++o) c = e[o], f = t.map(s), h = a[f], h || (a[f] = h = [], r.push(h)), h.push(c);
+        for (f = 0, g = 0, u = r.length; f < u; ++f) {
+            for (h = r[f], o = 0, d = 0, l = h.length; o < l; ++o) d += Math.abs(i(h[o]));
+            h.sum = d, d > g && (g = d), n && h.sort(n)
+        }
+        return r.max = g, r
     }
+    const zK = Object.freeze(Object.defineProperty({
+        __proto__: null,
+        axisticks: ZP,
+        datajoin: e4,
+        encode: t4,
+        legendentries: n4,
+        linkpath: BS,
+        pie: jS,
+        scale: o4,
+        sortitems: u4,
+        stack: GS
+    }, Symbol.toStringTag, {
+        value: "Module"
+    }));
+    var $e = 1e-6,
+        Om = 1e-12,
+        Ie = Math.PI,
+        Nt = Ie / 2,
+        Fm = Ie / 4,
+        Vn = Ie * 2,
+        Bt = 180 / Ie,
+        Le = Ie / 180,
+        Ge = Math.abs,
+        Qc = Math.atan,
+        Ki = Math.atan2,
+        Me = Math.cos,
+        Rg = Math.ceil,
+        d4 = Math.exp,
+        k2 = Math.hypot,
+        Rm = Math.log,
+        _v = Math.pow,
+        ke = Math.sin,
+        ji = Math.sign || function(e) {
+            return e > 0 ? 1 : e < 0 ? -1 : 0
+        },
+        Kn = Math.sqrt,
+        US = Math.tan;
 
-    function mD(e) {
-        const t = Date.UTC(e.getUTCFullYear(), 0, 1);
-        return Sa.count(t - 1, e)
+    function g4(e) {
+        return e > 1 ? 0 : e < -1 ? Ie : Math.acos(e)
     }
 
-    function Yb(e) {
-        const t = Date.UTC(e.getUTCFullYear(), 0, 1);
-        return yc.count(t - 1, e)
+    function gi(e) {
+        return e > 1 ? Nt : e < -1 ? -Nt : Math.asin(e)
     }
 
-    function Xb(e) {
-        return $o.setTime(Date.UTC(e, 0, 1)), $o.getUTCDay()
-    }
+    function mn() {}
 
-    function aX(e, t, n, i, r, s, a) {
-        if (0 <= e && e < 100) {
-            const o = new Date(Date.UTC(-1, t, n, i, r, s, a));
-            return o.setUTCFullYear(n.y), o
-        }
-        return new Date(Date.UTC(e, t, n, i, r, s, a))
+    function Dm(e, t) {
+        e && J$.hasOwnProperty(e.type) && J$[e.type](e, t)
     }
+    var K$ = {
+            Feature: function(e, t) {
+                Dm(e.geometry, t)
+            },
+            FeatureCollection: function(e, t) {
+                for (var n = e.features, i = -1, r = n.length; ++i < r;) Dm(n[i].geometry, t)
+            }
+        },
+        J$ = {
+            Sphere: function(e, t) {
+                t.sphere()
+            },
+            Point: function(e, t) {
+                e = e.coordinates, t.point(e[0], e[1], e[2])
+            },
+            MultiPoint: function(e, t) {
+                for (var n = e.coordinates, i = -1, r = n.length; ++i < r;) e = n[i], t.point(e[0], e[1], e[2])
+            },
+            LineString: function(e, t) {
+                C2(e.coordinates, t, 0)
+            },
+            MultiLineString: function(e, t) {
+                for (var n = e.coordinates, i = -1, r = n.length; ++i < r;) C2(n[i], t, 0)
+            },
+            Polygon: function(e, t) {
+                Q$(e.coordinates, t)
+            },
+            MultiPolygon: function(e, t) {
+                for (var n = e.coordinates, i = -1, r = n.length; ++i < r;) Q$(n[i], t)
+            },
+            GeometryCollection: function(e, t) {
+                for (var n = e.geometries, i = -1, r = n.length; ++i < r;) Dm(n[i], t)
+            }
+        };
 
-    function yD(e, t, n, i, r) {
-        const s = t || 1,
-            a = De(e),
-            o = (y, v, b) => (b = b || y, oX(n[b], i[b], y === a && s, v)),
-            l = new Date,
-            u = fr(e),
-            c = u[Jt] ? o(Jt) : xn(2012),
-            f = u[mn] ? o(mn) : u[ii] ? o(ii) : ha,
-            h = u[Tt] && u[fn] ? o(fn, 1, Tt + fn) : u[Tt] ? o(Tt, 1) : u[fn] ? o(fn, 1) : u[ri] ? o(ri, 1) : u[Yr] ? o(Yr, 1) : vc,
-            d = u[vi] ? o(vi) : ha,
-            g = u[bi] ? o(bi) : ha,
-            p = u[Di] ? o(Di) : ha,
-            m = u[hr] ? o(hr) : ha;
-        return function(y) {
-            l.setTime(+y);
-            const v = c(l);
-            return r(v, f(l), h(l, v), d(l), g(l), p(l), m(l))
-        }
+    function C2(e, t, n) {
+        var i = -1,
+            r = e.length - n,
+            s;
+        for (t.lineStart(); ++i < r;) s = e[i], t.point(s[0], s[1], s[2]);
+        t.lineEnd()
     }
 
-    function oX(e, t, n, i) {
-        const r = n <= 1 ? e : i ? (s, a) => i + n * Math.floor((e(s, a) - i) / n) : (s, a) => n * Math.floor(e(s, a) / n);
-        return t ? (s, a) => t(r(s, a), a) : r
+    function Q$(e, t) {
+        var n = -1,
+            i = e.length;
+        for (t.polygonStart(); ++n < i;) C2(e[n], t, 1);
+        t.polygonEnd()
     }
 
-    function ju(e, t, n) {
-        return t + e * 7 - (n + 6) % 7
+    function zs(e, t) {
+        e && K$.hasOwnProperty(e.type) ? K$[e.type](e, t) : Dm(e, t)
     }
-    const lX = {
-            [Jt]: e => e.getFullYear(),
-            [ii]: e => Math.floor(e.getMonth() / 3),
-            [mn]: e => e.getMonth(),
-            [ri]: e => e.getDate(),
-            [vi]: e => e.getHours(),
-            [bi]: e => e.getMinutes(),
-            [Di]: e => e.getSeconds(),
-            [hr]: e => e.getMilliseconds(),
-            [Yr]: e => dD(e),
-            [Tt]: e => qb(e),
-            [Tt + fn]: (e, t) => ju(qb(e), e.getDay(), Hb(t)),
-            [fn]: (e, t) => ju(1, e.getDay(), Hb(t))
-        },
-        uX = {
-            [ii]: e => 3 * e,
-            [Tt]: (e, t) => ju(e, 0, Hb(t))
-        };
-
-    function vD(e, t) {
-        return yD(e, t || 1, lX, uX, sX)
-    }
-    const cX = {
-            [Jt]: e => e.getUTCFullYear(),
-            [ii]: e => Math.floor(e.getUTCMonth() / 3),
-            [mn]: e => e.getUTCMonth(),
-            [ri]: e => e.getUTCDate(),
-            [vi]: e => e.getUTCHours(),
-            [bi]: e => e.getUTCMinutes(),
-            [Di]: e => e.getUTCSeconds(),
-            [hr]: e => e.getUTCMilliseconds(),
-            [Yr]: e => mD(e),
-            [Tt]: e => Yb(e),
-            [fn]: (e, t) => ju(1, e.getUTCDay(), Xb(t)),
-            [Tt + fn]: (e, t) => ju(Yb(e), e.getUTCDay(), Xb(t))
-        },
-        fX = {
-            [ii]: e => 3 * e,
-            [Tt]: (e, t) => ju(e, 0, Xb(t))
+    var Nm = new Yn,
+        Pm = new Yn,
+        p4, m4, A2, $2, T2, us = {
+            point: mn,
+            lineStart: mn,
+            lineEnd: mn,
+            polygonStart: function() {
+                Nm = new Yn, us.lineStart = BK, us.lineEnd = jK
+            },
+            polygonEnd: function() {
+                var e = +Nm;
+                Pm.add(e < 0 ? Vn + e : e), this.lineStart = this.lineEnd = this.point = mn
+            },
+            sphere: function() {
+                Pm.add(Vn)
+            }
         };
 
-    function bD(e, t) {
-        return yD(e, t || 1, cX, fX, aX)
+    function BK() {
+        us.point = GK
     }
-    const hX = {
-            [Jt]: Wr,
-            [ii]: xh.every(3),
-            [mn]: xh,
-            [Tt]: mc,
-            [ri]: Os,
-            [fn]: Os,
-            [Yr]: Os,
-            [vi]: ym,
-            [bi]: pm,
-            [Di]: ks,
-            [hr]: Lu
-        },
-        dX = {
-            [Jt]: qr,
-            [ii]: _h.every(3),
-            [mn]: _h,
-            [Tt]: yc,
-            [ri]: Sa,
-            [fn]: Sa,
-            [Yr]: Sa,
-            [vi]: vm,
-            [bi]: mm,
-            [Di]: ks,
-            [hr]: Lu
-        };
 
-    function wc(e) {
-        return hX[e]
+    function jK() {
+        y4(p4, m4)
     }
 
-    function Sc(e) {
-        return dX[e]
+    function GK(e, t) {
+        us.point = y4, p4 = e, m4 = t, e *= Le, t *= Le, A2 = e, $2 = Me(t = t / 2 + Fm), T2 = ke(t)
     }
 
-    function xD(e, t, n) {
-        return e ? e.offset(t, n) : void 0
+    function y4(e, t) {
+        e *= Le, t *= Le, t = t / 2 + Fm;
+        var n = e - A2,
+            i = n >= 0 ? 1 : -1,
+            r = i * n,
+            s = Me(t),
+            a = ke(t),
+            o = T2 * a,
+            l = $2 * s + o * Me(r),
+            u = o * i * ke(r);
+        Nm.add(Ki(u, l)), A2 = e, $2 = s, T2 = a
     }
 
-    function _D(e, t, n) {
-        return xD(wc(e), t, n)
+    function UK(e) {
+        return Pm = new Yn, zs(e, us), Pm * 2
     }
 
-    function wD(e, t, n) {
-        return xD(Sc(e), t, n)
+    function Lm(e) {
+        return [Ki(e[1], e[0]), gi(e[2])]
     }
 
-    function SD(e, t, n, i) {
-        return e ? e.range(t, n, i) : void 0
+    function kl(e) {
+        var t = e[0],
+            n = e[1],
+            i = Me(n);
+        return [i * Me(t), i * ke(t), ke(n)]
     }
 
-    function ED(e, t, n, i) {
-        return SD(wc(e), t, n, i)
+    function Dg(e, t) {
+        return e[0] * t[0] + e[1] * t[1] + e[2] * t[2]
     }
 
-    function CD(e, t, n, i) {
-        return SD(Sc(e), t, n, i)
+    function bc(e, t) {
+        return [e[1] * t[2] - e[2] * t[1], e[2] * t[0] - e[0] * t[2], e[0] * t[1] - e[1] * t[0]]
     }
-    const Rf = 1e3,
-        Df = Rf * 60,
-        Nf = Df * 60,
-        Tm = Nf * 24,
-        gX = Tm * 7,
-        w$ = Tm * 30,
-        Vb = Tm * 365,
-        kD = [Jt, mn, ri, vi, bi, Di, hr],
-        Pf = kD.slice(0, -1),
-        Lf = Pf.slice(0, -1),
-        If = Lf.slice(0, -1),
-        pX = If.slice(0, -1),
-        mX = [Jt, Tt],
-        S$ = [Jt, mn],
-        AD = [Jt],
-        Jc = [
-            [Pf, 1, Rf],
-            [Pf, 5, 5 * Rf],
-            [Pf, 15, 15 * Rf],
-            [Pf, 30, 30 * Rf],
-            [Lf, 1, Df],
-            [Lf, 5, 5 * Df],
-            [Lf, 15, 15 * Df],
-            [Lf, 30, 30 * Df],
-            [If, 1, Nf],
-            [If, 3, 3 * Nf],
-            [If, 6, 6 * Nf],
-            [If, 12, 12 * Nf],
-            [pX, 1, Tm],
-            [mX, 1, gX],
-            [S$, 1, w$],
-            [S$, 3, 3 * w$],
-            [AD, 1, Vb]
-        ];
 
-    function $D(e) {
-        const t = e.extent,
-            n = e.maxbins || 40,
-            i = Math.abs(ad(t)) / n;
-        let r = Qh(o => o[2]).right(Jc, i),
-            s, a;
-        return r === Jc.length ? (s = AD, a = Oa(t[0] / Vb, t[1] / Vb, n)) : r ? (r = Jc[i / Jc[r - 1][2] < Jc[r][2] / i ? r - 1 : r], s = r[0], a = r[1]) : (s = kD, a = Math.max(Oa(t[0], t[1], n), 1)), {
-            units: s,
-            step: a
-        }
+    function wv(e, t) {
+        e[0] += t[0], e[1] += t[1], e[2] += t[2]
     }
 
-    function zf(e) {
-        const t = {};
-        return n => t[n] || (t[n] = e(n))
+    function Ng(e, t) {
+        return [e[0] * t, e[1] * t, e[2] * t]
     }
 
-    function yX(e, t) {
-        return n => {
-            const i = e(n),
-                r = i.indexOf(t);
-            if (r < 0) return i;
-            let s = vX(i, r);
-            const a = s < i.length ? i.slice(s) : "";
-            for (; --s > r;)
-                if (i[s] !== "0") {
-                    ++s;
-                    break
-                } return i.slice(0, s) + a
-        }
+    function Im(e) {
+        var t = Kn(e[0] * e[0] + e[1] * e[1] + e[2] * e[2]);
+        e[0] /= t, e[1] /= t, e[2] /= t
     }
+    var Ct, ni, Ft, ki, Vo, v4, b4, Yu, Ah, Aa, ta, Ps = {
+        point: M2,
+        lineStart: Z$,
+        lineEnd: eT,
+        polygonStart: function() {
+            Ps.point = _4, Ps.lineStart = WK, Ps.lineEnd = qK, Ah = new Yn, us.polygonStart()
+        },
+        polygonEnd: function() {
+            us.polygonEnd(), Ps.point = M2, Ps.lineStart = Z$, Ps.lineEnd = eT, Nm < 0 ? (Ct = -(Ft = 180), ni = -(ki = 90)) : Ah > $e ? ki = 90 : Ah < -$e && (ni = -90), ta[0] = Ct, ta[1] = Ft
+        },
+        sphere: function() {
+            Ct = -(Ft = 180), ni = -(ki = 90)
+        }
+    };
 
-    function vX(e, t) {
-        let n = e.lastIndexOf("e"),
-            i;
-        if (n > 0) return n;
-        for (n = e.length; --n > t;)
-            if (i = e.charCodeAt(n), i >= 48 && i <= 57) return n + 1
+    function M2(e, t) {
+        Aa.push(ta = [Ct = e, Ft = e]), t < ni && (ni = t), t > ki && (ki = t)
     }
 
-    function TD(e) {
-        const t = zf(e.format),
-            n = e.formatPrefix;
-        return {
-            format: t,
-            formatPrefix: n,
-            formatFloat(i) {
-                const r = Qo(i || ",");
-                if (r.precision == null) {
-                    switch (r.precision = 12, r.type) {
-                        case "%":
-                            r.precision -= 2;
-                            break;
-                        case "e":
-                            r.precision -= 1;
-                            break
-                    }
-                    return yX(t(r), t(".1f")(1)[1])
-                } else return t(r)
-            },
-            formatSpan(i, r, s, a) {
-                a = Qo(a ?? ",f");
-                const o = Oa(i, r, s),
-                    l = Math.max(Math.abs(i), Math.abs(r));
-                let u;
-                if (a.precision == null) switch (a.type) {
-                    case "s":
-                        return isNaN(u = QO(o, l)) || (a.precision = u), n(a, l);
-                    case "":
-                    case "e":
-                    case "g":
-                    case "p":
-                    case "r": {
-                        isNaN(u = ZO(o, l)) || (a.precision = u - (a.type === "e"));
-                        break
-                    }
-                    case "f":
-                    case "%": {
-                        isNaN(u = JO(o)) || (a.precision = u - (a.type === "%") * 2);
-                        break
-                    }
-                }
-                return t(a)
-            }
-        }
+    function x4(e, t) {
+        var n = kl([e * Le, t * Le]);
+        if (Yu) {
+            var i = bc(Yu, n),
+                r = [i[1], -i[0], 0],
+                s = bc(r, i);
+            Im(s), s = Lm(s);
+            var a = e - Vo,
+                o = a > 0 ? 1 : -1,
+                l = s[0] * Bt * o,
+                u, c = Ge(a) > 180;
+            c ^ (o * Vo < l && l < o * e) ? (u = s[1] * Bt, u > ki && (ki = u)) : (l = (l + 360) % 360 - 180, c ^ (o * Vo < l && l < o * e) ? (u = -s[1] * Bt, u < ni && (ni = u)) : (t < ni && (ni = t), t > ki && (ki = t))), c ? e < Vo ? Ei(Ct, e) > Ei(Ct, Ft) && (Ft = e) : Ei(e, Ft) > Ei(Ct, Ft) && (Ct = e) : Ft >= Ct ? (e < Ct && (Ct = e), e > Ft && (Ft = e)) : e > Vo ? Ei(Ct, e) > Ei(Ct, Ft) && (Ft = e) : Ei(e, Ft) > Ei(Ct, Ft) && (Ct = e)
+        } else Aa.push(ta = [Ct = e, Ft = e]);
+        t < ni && (ni = t), t > ki && (ki = t), Yu = n, Vo = e
     }
-    let Kb;
-    MD();
 
-    function MD() {
-        return Kb = TD({
-            format: lm,
-            formatPrefix: Fx
-        })
+    function Z$() {
+        Ps.point = x4
     }
 
-    function OD(e) {
-        return TD(KO(e))
+    function eT() {
+        ta[0] = Ct, ta[1] = Ft, Ps.point = M2, Yu = null
     }
 
-    function f0(e) {
-        return arguments.length ? Kb = OD(e) : Kb
+    function _4(e, t) {
+        if (Yu) {
+            var n = e - Vo;
+            Ah.add(Ge(n) > 180 ? n + (n > 0 ? 360 : -360) : n)
+        } else v4 = e, b4 = t;
+        us.point(e, t), x4(e, t)
     }
 
-    function E$(e, t, n) {
-        n = n || {}, ae(n) || U(`Invalid time multi-format specifier: ${n}`);
-        const i = t(Di),
-            r = t(bi),
-            s = t(vi),
-            a = t(ri),
-            o = t(Tt),
-            l = t(mn),
-            u = t(ii),
-            c = t(Jt),
-            f = e(n[hr] || ".%L"),
-            h = e(n[Di] || ":%S"),
-            d = e(n[bi] || "%I:%M"),
-            g = e(n[vi] || "%I %p"),
-            p = e(n[ri] || n[fn] || "%a %d"),
-            m = e(n[Tt] || "%b %d"),
-            y = e(n[mn] || "%B"),
-            v = e(n[ii] || "%B"),
-            b = e(n[Jt] || "%Y");
-        return x => (i(x) < x ? f : r(x) < x ? h : s(x) < x ? d : a(x) < x ? g : l(x) < x ? o(x) < x ? p : m : c(x) < x ? u(x) < x ? y : v : b)(x)
+    function WK() {
+        us.lineStart()
     }
 
-    function FD(e) {
-        const t = zf(e.format),
-            n = zf(e.utcFormat);
-        return {
-            timeFormat: i => re(i) ? t(i) : E$(t, wc, i),
-            utcFormat: i => re(i) ? n(i) : E$(n, Sc, i),
-            timeParse: zf(e.parse),
-            utcParse: zf(e.utcParse)
-        }
-    }
-    let Jb;
-    RD();
-
-    function RD() {
-        return Jb = FD({
-            format: Hx,
-            parse: hR,
-            utcFormat: Yx,
-            utcParse: dR
-        })
+    function qK() {
+        _4(v4, b4), us.lineEnd(), Ge(Ah) > $e && (Ct = -(Ft = 180)), ta[0] = Ct, ta[1] = Ft, Yu = null
     }
 
-    function DD(e) {
-        return FD(oR(e))
+    function Ei(e, t) {
+        return (t -= e) < 0 ? t + 360 : t
     }
 
-    function Sh(e) {
-        return arguments.length ? Jb = DD(e) : Jb
+    function HK(e, t) {
+        return e[0] - t[0]
     }
-    const Qb = (e, t) => Ae({}, e, t);
 
-    function ND(e, t) {
-        const n = e ? OD(e) : f0(),
-            i = t ? DD(t) : Sh();
-        return Qb(n, i)
+    function tT(e, t) {
+        return e[0] <= e[1] ? e[0] <= t && t <= e[1] : t < e[0] || e[1] < t
     }
 
-    function x_(e, t) {
-        const n = arguments.length;
-        return n && n !== 2 && U("defaultLocale expects either zero or two arguments."), n ? Qb(f0(e), Sh(t)) : Qb(f0(), Sh())
+    function YK(e) {
+        var t, n, i, r, s, a, o;
+        if (ki = Ft = -(Ct = ni = 1 / 0), Aa = [], zs(e, Ps), n = Aa.length) {
+            for (Aa.sort(HK), t = 1, i = Aa[0], s = [i]; t < n; ++t) r = Aa[t], tT(i, r[0]) || tT(i, r[1]) ? (Ei(i[0], r[1]) > Ei(i[0], i[1]) && (i[1] = r[1]), Ei(r[0], i[1]) > Ei(i[0], i[1]) && (i[0] = r[0])) : s.push(i = r);
+            for (a = -1 / 0, n = s.length - 1, t = 0, i = s[n]; t <= n; i = r, ++t) r = s[t], (o = Ei(i[1], r[0])) > a && (a = o, Ct = r[0], Ft = i[1])
+        }
+        return Aa = ta = null, Ct === 1 / 0 || ni === 1 / 0 ? [
+            [NaN, NaN],
+            [NaN, NaN]
+        ] : [
+            [Ct, ni],
+            [Ft, ki]
+        ]
     }
+    var nh, zm, Bm, jm, Gm, Um, Wm, qm, O2, F2, R2, w4, S4, Gn, Un, Wn, vr = {
+        sphere: mn,
+        point: WS,
+        lineStart: nT,
+        lineEnd: iT,
+        polygonStart: function() {
+            vr.lineStart = KK, vr.lineEnd = JK
+        },
+        polygonEnd: function() {
+            vr.lineStart = nT, vr.lineEnd = iT
+        }
+    };
 
-    function bX() {
-        return MD(), RD(), x_()
+    function WS(e, t) {
+        e *= Le, t *= Le;
+        var n = Me(t);
+        Yd(n * Me(e), n * ke(e), ke(t))
     }
-    const xX = /^(data:|([A-Za-z]+:)?\/\/)/,
-        _X = /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp|file|data):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i,
-        wX = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205f\u3000]/g,
-        C$ = "file://";
 
-    function SX(e, t) {
-        return n => ({
-            options: n || {},
-            sanitize: CX,
-            load: EX,
-            fileAccess: !!t,
-            file: kX(t),
-            http: $X(e)
-        })
+    function Yd(e, t, n) {
+        ++nh, Bm += (e - Bm) / nh, jm += (t - jm) / nh, Gm += (n - Gm) / nh
     }
-    async function EX(e, t) {
-        const n = await this.sanitize(e, t),
-            i = n.href;
-        return n.localFile ? this.file(i) : this.http(i, t)
+
+    function nT() {
+        vr.point = XK
     }
-    async function CX(e, t) {
-        t = Ae({}, this.options, t);
-        const n = this.fileAccess,
-            i = {
-                href: null
-            };
-        let r, s, a;
-        const o = _X.test(e.replace(wX, ""));
-        (e == null || typeof e != "string" || !o) && U("Sanitize failure, invalid URI: " + Z(e));
-        const l = xX.test(e);
-        return (a = t.baseURL) && !l && (!e.startsWith("/") && !a.endsWith("/") && (e = "/" + e), e = a + e), s = (r = e.startsWith(C$)) || t.mode === "file" || t.mode !== "http" && !l && n, r ? e = e.slice(C$.length) : e.startsWith("//") && (t.defaultProtocol === "file" ? (e = e.slice(2), s = !0) : e = (t.defaultProtocol || "http") + ":" + e), Object.defineProperty(i, "localFile", {
-            value: !!s
-        }), i.href = e, t.target && (i.target = t.target + ""), t.rel && (i.rel = t.rel + ""), t.context === "image" && t.crossOrigin && (i.crossOrigin = t.crossOrigin + ""), i
+
+    function XK(e, t) {
+        e *= Le, t *= Le;
+        var n = Me(t);
+        Gn = n * Me(e), Un = n * ke(e), Wn = ke(t), vr.point = VK, Yd(Gn, Un, Wn)
     }
 
-    function kX(e) {
-        return e ? t => new Promise((n, i) => {
-            e.readFile(t, (r, s) => {
-                r ? i(r) : n(s)
-            })
-        }) : AX
+    function VK(e, t) {
+        e *= Le, t *= Le;
+        var n = Me(t),
+            i = n * Me(e),
+            r = n * ke(e),
+            s = ke(t),
+            a = Ki(Kn((a = Un * s - Wn * r) * a + (a = Wn * i - Gn * s) * a + (a = Gn * r - Un * i) * a), Gn * i + Un * r + Wn * s);
+        zm += a, Um += a * (Gn + (Gn = i)), Wm += a * (Un + (Un = r)), qm += a * (Wn + (Wn = s)), Yd(Gn, Un, Wn)
     }
-    async function AX() {
-        U("No file system access.")
+
+    function iT() {
+        vr.point = WS
     }
 
-    function $X(e) {
-        return e ? async function(t, n) {
-            const i = Ae({}, this.options.http, n),
-                r = n && n.response,
-                s = await e(t, i);
-            return s.ok ? $e(s[r]) ? s[r]() : s.text() : U(s.status + "" + s.statusText)
-        }: TX
+    function KK() {
+        vr.point = QK
     }
-    async function TX() {
-        U("No HTTP fetch method available.")
+
+    function JK() {
+        E4(w4, S4), vr.point = WS
     }
-    const MX = e => e != null && e === e,
-        OX = e => e === "true" || e === "false" || e === !0 || e === !1,
-        FX = e => !Number.isNaN(Date.parse(e)),
-        PD = e => !Number.isNaN(+e) && !(e instanceof Date),
-        RX = e => PD(e) && Number.isInteger(+e),
-        Zb = {
-            boolean: g_,
-            integer: hn,
-            number: hn,
-            date: p_,
-            string: m_,
-            unknown: bn
-        },
-        pg = [OX, RX, PD, FX],
-        DX = ["boolean", "integer", "number", "date"];
 
-    function LD(e, t) {
-        if (!e || !e.length) return "unknown";
-        const n = e.length,
-            i = pg.length,
-            r = pg.map((s, a) => a + 1);
-        for (let s = 0, a = 0, o, l; s < n; ++s)
-            for (l = t ? e[s][t] : e[s], o = 0; o < i; ++o)
-                if (r[o] && MX(l) && !pg[o](l) && (r[o] = 0, ++a, a === pg.length)) return "string";
-        return DX[r.reduce((s, a) => s === 0 ? a : s, 0) - 1]
+    function QK(e, t) {
+        w4 = e, S4 = t, e *= Le, t *= Le, vr.point = E4;
+        var n = Me(t);
+        Gn = n * Me(e), Un = n * ke(e), Wn = ke(t), Yd(Gn, Un, Wn)
     }
 
-    function ID(e, t) {
-        return t.reduce((n, i) => (n[i] = LD(e, i), n), {})
+    function E4(e, t) {
+        e *= Le, t *= Le;
+        var n = Me(t),
+            i = n * Me(e),
+            r = n * ke(e),
+            s = ke(t),
+            a = Un * s - Wn * r,
+            o = Wn * i - Gn * s,
+            l = Gn * r - Un * i,
+            u = k2(a, o, l),
+            c = gi(u),
+            f = u && -c / u;
+        O2.add(f * a), F2.add(f * o), R2.add(f * l), zm += c, Um += c * (Gn + (Gn = i)), Wm += c * (Un + (Un = r)), qm += c * (Wn + (Wn = s)), Yd(Gn, Un, Wn)
     }
 
-    function k$(e) {
-        const t = function(n, i) {
-            const r = {
-                delimiter: e
-            };
-            return __(n, i ? Ae(i, r) : r)
-        };
-        return t.responseType = "text", t
+    function ZK(e) {
+        nh = zm = Bm = jm = Gm = Um = Wm = qm = 0, O2 = new Yn, F2 = new Yn, R2 = new Yn, zs(e, vr);
+        var t = +O2,
+            n = +F2,
+            i = +R2,
+            r = k2(t, n, i);
+        return r < Om && (t = Um, n = Wm, i = qm, zm < $e && (t = Bm, n = jm, i = Gm), r = k2(t, n, i), r < Om) ? [NaN, NaN] : [Ki(n, t) * Bt, gi(i / r) * Bt]
     }
 
-    function __(e, t) {
-        return t.header && (e = t.header.map(Z).join(t.delimiter) + `
-` + e), uU(t.delimiter).parse(e + "")
+    function D2(e, t) {
+        function n(i, r) {
+            return i = e(i, r), t(i[0], i[1])
+        }
+        return e.invert && t.invert && (n.invert = function(i, r) {
+            return i = t.invert(i, r), i && e.invert(i[0], i[1])
+        }), n
     }
-    __.responseType = "text";
 
-    function NX(e) {
-        return typeof Buffer == "function" && $e(Buffer.isBuffer) ? Buffer.isBuffer(e) : !1
+    function N2(e, t) {
+        return Ge(e) > Ie && (e -= Math.round(e / Vn) * Vn), [e, t]
     }
+    N2.invert = N2;
 
-    function w_(e, t) {
-        const n = t && t.property ? ni(t.property) : bn;
-        return ae(e) && !NX(e) ? PX(n(e), t) : n(JSON.parse(e))
+    function k4(e, t, n) {
+        return (e %= Vn) ? t || n ? D2(sT(e), aT(t, n)) : sT(e) : t || n ? aT(t, n) : N2
     }
-    w_.responseType = "json";
 
-    function PX(e, t) {
-        return !W(e) && nD(e) && (e = [...e]), t && t.copy ? JSON.parse(JSON.stringify(e)) : e
+    function rT(e) {
+        return function(t, n) {
+            return t += e, Ge(t) > Ie && (t -= Math.round(t / Vn) * Vn), [t, n]
+        }
     }
-    const LX = {
-        interior: (e, t) => e !== t,
-        exterior: (e, t) => e === t
-    };
 
-    function zD(e, t) {
-        let n, i, r, s;
-        return e = w_(e, t), t && t.feature ? (n = ZY, r = t.feature) : t && t.mesh ? (n = tX, r = t.mesh, s = LX[t.filter]) : U("Missing TopoJSON feature or mesh parameter."), i = (i = e.objects[r]) ? n(e, i, s) : U("Invalid TopoJSON object: " + r), i && i.features || [i]
+    function sT(e) {
+        var t = rT(e);
+        return t.invert = rT(-e), t
     }
-    zD.responseType = "json";
-    const Vg = {
-        dsv: __,
-        csv: k$(","),
-        tsv: k$("	"),
-        json: w_,
-        topojson: zD
-    };
 
-    function S_(e, t) {
-        return arguments.length > 1 ? (Vg[e] = t, this) : me(Vg, e) ? Vg[e] : null
+    function aT(e, t) {
+        var n = Me(e),
+            i = ke(e),
+            r = Me(t),
+            s = ke(t);
+
+        function a(o, l) {
+            var u = Me(l),
+                c = Me(o) * u,
+                f = ke(o) * u,
+                h = ke(l),
+                d = h * n + c * i;
+            return [Ki(f * r - d * s, c * n - h * i), gi(d * r + f * s)]
+        }
+        return a.invert = function(o, l) {
+            var u = Me(l),
+                c = Me(o) * u,
+                f = ke(o) * u,
+                h = ke(l),
+                d = h * r - f * s;
+            return [Ki(f * r + h * s, c * n + d * i), gi(d * n - c * i)]
+        }, a
     }
 
-    function BD(e) {
-        const t = S_(e);
-        return t && t.responseType || "text"
+    function eJ(e) {
+        e = k4(e[0] * Le, e[1] * Le, e.length > 2 ? e[2] * Le : 0);
+
+        function t(n) {
+            return n = e(n[0] * Le, n[1] * Le), n[0] *= Bt, n[1] *= Bt, n
+        }
+        return t.invert = function(n) {
+            return n = e.invert(n[0] * Le, n[1] * Le), n[0] *= Bt, n[1] *= Bt, n
+        }, t
     }
 
-    function jD(e, t, n, i) {
-        t = t || {};
-        const r = S_(t.type || "json");
-        return r || U("Unknown data format type: " + t.type), e = r(e, t), t.parse && IX(e, t.parse, n, i), me(e, "columns") && delete e.columns, e
+    function tJ(e, t, n, i, r, s) {
+        if (n) {
+            var a = Me(t),
+                o = ke(t),
+                l = i * n;
+            r == null ? (r = t + i * Vn, s = t - l / 2) : (r = oT(a, r), s = oT(a, s), (i > 0 ? r < s : r > s) && (r += i * Vn));
+            for (var u, c = r; i > 0 ? c > s : c < s; c -= l) u = Lm([a, -o * Me(c), -o * ke(c)]), e.point(u[0], u[1])
+        }
     }
 
-    function IX(e, t, n, i) {
-        if (!e.length) return;
-        const r = Sh();
-        n = n || r.timeParse, i = i || r.utcParse;
-        let s = e.columns || Object.keys(e[0]),
-            a, o, l, u, c, f;
-        t === "auto" && (t = ID(e, s)), s = Object.keys(t);
-        const h = s.map(d => {
-            const g = t[d];
-            let p, m;
-            if (g && (g.startsWith("date:") || g.startsWith("utc:"))) return p = g.split(/:(.+)?/, 2), m = p[1], (m[0] === "'" && m[m.length - 1] === "'" || m[0] === '"' && m[m.length - 1] === '"') && (m = m.slice(1, -1)), (p[0] === "utc" ? i : n)(m);
-            if (!Zb[g]) throw Error("Illegal format pattern: " + d + ":" + g);
-            return Zb[g]
-        });
-        for (l = 0, c = e.length, f = s.length; l < c; ++l)
-            for (a = e[l], u = 0; u < f; ++u) o = s[u], a[o] = h[u](a[o])
+    function oT(e, t) {
+        t = kl(t), t[0] -= e, Im(t);
+        var n = g4(-t[1]);
+        return ((-t[2] < 0 ? -n : n) + Vn - $e) % Vn
     }
-    const Mm = SX(typeof fetch < "u" && fetch, null);
 
-    function Om(e) {
-        const t = e || bn,
-            n = [],
-            i = {};
-        return n.add = r => {
-            const s = t(r);
-            return i[s] || (i[s] = 1, n.push(r)), n
-        }, n.remove = r => {
-            const s = t(r);
-            if (i[s]) {
-                i[s] = 0;
-                const a = n.indexOf(r);
-                a >= 0 && n.splice(a, 1)
+    function C4() {
+        var e = [],
+            t;
+        return {
+            point: function(n, i, r) {
+                t.push([n, i, r])
+            },
+            lineStart: function() {
+                e.push(t = [])
+            },
+            lineEnd: mn,
+            rejoin: function() {
+                e.length > 1 && e.push(e.pop().concat(e.shift()))
+            },
+            result: function() {
+                var n = e;
+                return e = [], t = null, n
             }
-            return n
-        }, n
-    }
-    async function Kg(e, t) {
-        try {
-            await t(e)
-        } catch (n) {
-            e.error(n)
         }
     }
-    const UD = Symbol("vega_id");
-    let zX = 1;
 
-    function Fm(e) {
-        return !!(e && ge(e))
+    function Fp(e, t) {
+        return Ge(e[0] - t[0]) < $e && Ge(e[1] - t[1]) < $e
     }
 
-    function ge(e) {
-        return e[UD]
+    function Pg(e, t, n, i) {
+        this.x = e, this.z = t, this.o = n, this.e = i, this.v = !1, this.n = this.p = null
     }
 
-    function GD(e, t) {
-        return e[UD] = t, e
+    function A4(e, t, n, i, r) {
+        var s = [],
+            a = [],
+            o, l;
+        if (e.forEach(function(g) {
+                if (!((p = g.length - 1) <= 0)) {
+                    var p, m = g[0],
+                        y = g[p],
+                        v;
+                    if (Fp(m, y)) {
+                        if (!m[2] && !y[2]) {
+                            for (r.lineStart(), o = 0; o < p; ++o) r.point((m = g[o])[0], m[1]);
+                            r.lineEnd();
+                            return
+                        }
+                        y[0] += 2 * $e
+                    }
+                    s.push(v = new Pg(m, g, null, !0)), a.push(v.o = new Pg(m, null, v, !1)), s.push(v = new Pg(y, g, null, !1)), a.push(v.o = new Pg(y, null, v, !0))
+                }
+            }), !!s.length) {
+            for (a.sort(t), lT(s), lT(a), o = 0, l = a.length; o < l; ++o) a[o].e = n = !n;
+            for (var u = s[0], c, f;;) {
+                for (var h = u, d = !0; h.v;)
+                    if ((h = h.n) === u) return;
+                c = h.z, r.lineStart();
+                do {
+                    if (h.v = h.o.v = !0, h.e) {
+                        if (d)
+                            for (o = 0, l = c.length; o < l; ++o) r.point((f = c[o])[0], f[1]);
+                        else i(h.x, h.n.x, 1, r);
+                        h = h.n
+                    } else {
+                        if (d)
+                            for (c = h.p.z, o = c.length - 1; o >= 0; --o) r.point((f = c[o])[0], f[1]);
+                        else i(h.x, h.p.x, -1, r);
+                        h = h.p
+                    }
+                    h = h.o, c = h.z, d = !d
+                } while (!h.v);
+                r.lineEnd()
+            }
+        }
     }
 
-    function He(e) {
-        const t = e === Object(e) ? e : {
-            data: e
-        };
-        return ge(t) ? t : GD(t, zX++)
+    function lT(e) {
+        if (t = e.length) {
+            for (var t, n = 0, i = e[0], r; ++n < t;) i.n = r = e[n], r.p = i, i = r;
+            i.n = r = e[0], r.p = i
+        }
     }
 
-    function E_(e) {
-        return Rm(e, He({}))
+    function Sv(e) {
+        return Ge(e[0]) <= Ie ? e[0] : ji(e[0]) * ((Ge(e[0]) + Ie) % Vn - Ie)
     }
 
-    function Rm(e, t) {
-        for (const n in e) t[n] = e[n];
-        return t
+    function nJ(e, t) {
+        var n = Sv(t),
+            i = t[1],
+            r = ke(i),
+            s = [ke(n), -Me(n), 0],
+            a = 0,
+            o = 0,
+            l = new Yn;
+        r === 1 ? i = Nt + $e : r === -1 && (i = -Nt - $e);
+        for (var u = 0, c = e.length; u < c; ++u)
+            if (h = (f = e[u]).length)
+                for (var f, h, d = f[h - 1], g = Sv(d), p = d[1] / 2 + Fm, m = ke(p), y = Me(p), v = 0; v < h; ++v, g = x, m = S, y = w, d = b) {
+                    var b = f[v],
+                        x = Sv(b),
+                        _ = b[1] / 2 + Fm,
+                        S = ke(_),
+                        w = Me(_),
+                        E = x - g,
+                        C = E >= 0 ? 1 : -1,
+                        k = C * E,
+                        A = k > Ie,
+                        F = m * S;
+                    if (l.add(Ki(F * C * ke(k), y * w + F * Me(k))), a += A ? E + C * Vn : E, A ^ g >= n ^ x >= n) {
+                        var $ = bc(kl(d), kl(b));
+                        Im($);
+                        var T = bc(s, $);
+                        Im(T);
+                        var M = (A ^ E >= 0 ? -1 : 1) * gi(T[2]);
+                        (i > M || i === M && ($[0] || $[1])) && (o += A ^ E >= 0 ? 1 : -1)
+                    }
+                }
+        return (a < -$e || a < $e && l < -Om) ^ o & 1
     }
 
-    function WD(e, t) {
-        return GD(t, ge(e))
+    function $4(e, t, n, i) {
+        return function(r) {
+            var s = t(r),
+                a = C4(),
+                o = t(a),
+                l = !1,
+                u, c, f, h = {
+                    point: d,
+                    lineStart: p,
+                    lineEnd: m,
+                    polygonStart: function() {
+                        h.point = y, h.lineStart = v, h.lineEnd = b, c = [], u = []
+                    },
+                    polygonEnd: function() {
+                        h.point = d, h.lineStart = p, h.lineEnd = m, c = kF(c);
+                        var x = nJ(u, i);
+                        c.length ? (l || (r.polygonStart(), l = !0), A4(c, rJ, x, n, r)) : x && (l || (r.polygonStart(), l = !0), r.lineStart(), n(null, null, 1, r), r.lineEnd()), l && (r.polygonEnd(), l = !1), c = u = null
+                    },
+                    sphere: function() {
+                        r.polygonStart(), r.lineStart(), n(null, null, 1, r), r.lineEnd(), r.polygonEnd()
+                    }
+                };
+
+            function d(x, _) {
+                e(x, _) && r.point(x, _)
+            }
+
+            function g(x, _) {
+                s.point(x, _)
+            }
+
+            function p() {
+                h.point = g, s.lineStart()
+            }
+
+            function m() {
+                h.point = d, s.lineEnd()
+            }
+
+            function y(x, _) {
+                f.push([x, _]), o.point(x, _)
+            }
+
+            function v() {
+                o.lineStart(), f = []
+            }
+
+            function b() {
+                y(f[0][0], f[0][1]), o.lineEnd();
+                var x = o.clean(),
+                    _ = a.result(),
+                    S, w = _.length,
+                    E, C, k;
+                if (f.pop(), u.push(f), f = null, !!w) {
+                    if (x & 1) {
+                        if (C = _[0], (E = C.length - 1) > 0) {
+                            for (l || (r.polygonStart(), l = !0), r.lineStart(), S = 0; S < E; ++S) r.point((k = C[S])[0], k[1]);
+                            r.lineEnd()
+                        }
+                        return
+                    }
+                    w > 1 && x & 2 && _.push(_.pop().concat(_.shift())), c.push(_.filter(iJ))
+                }
+            }
+            return h
+        }
     }
 
-    function $l(e, t) {
-        return e ? t ? (n, i) => e(n, i) || ge(t(n)) - ge(t(i)) : (n, i) => e(n, i) || ge(n) - ge(i) : null
+    function iJ(e) {
+        return e.length > 1
     }
 
-    function qD(e) {
-        return e && e.constructor === Tl
+    function rJ(e, t) {
+        return ((e = e.x)[0] < 0 ? e[1] - Nt - $e : Nt - e[1]) - ((t = t.x)[0] < 0 ? t[1] - Nt - $e : Nt - t[1])
     }
+    const uT = $4(function() {
+        return !0
+    }, sJ, oJ, [-Ie, -Nt]);
 
-    function Tl() {
-        const e = [],
-            t = [],
-            n = [],
-            i = [],
-            r = [];
-        let s = null,
-            a = !1;
+    function sJ(e) {
+        var t = NaN,
+            n = NaN,
+            i = NaN,
+            r;
         return {
-            constructor: Tl,
-            insert(o) {
-                const l = se(o),
-                    u = l.length;
-                for (let c = 0; c < u; ++c) e.push(l[c]);
-                return this
-            },
-            remove(o) {
-                const l = $e(o) ? i : t,
-                    u = se(o),
-                    c = u.length;
-                for (let f = 0; f < c; ++f) l.push(u[f]);
-                return this
-            },
-            modify(o, l, u) {
-                const c = {
-                    field: l,
-                    value: xn(u)
-                };
-                return $e(o) ? (c.filter = o, r.push(c)) : (c.tuple = o, n.push(c)), this
-            },
-            encode(o, l) {
-                return $e(o) ? r.push({
-                    filter: o,
-                    field: l
-                }) : n.push({
-                    tuple: o,
-                    field: l
-                }), this
+            lineStart: function() {
+                e.lineStart(), r = 1
             },
-            clean(o) {
-                return s = o, this
+            point: function(s, a) {
+                var o = s > 0 ? Ie : -Ie,
+                    l = Ge(s - t);
+                Ge(l - Ie) < $e ? (e.point(t, n = (n + a) / 2 > 0 ? Nt : -Nt), e.point(i, n), e.lineEnd(), e.lineStart(), e.point(o, n), e.point(s, n), r = 0) : i !== o && l >= Ie && (Ge(t - i) < $e && (t -= i * $e), Ge(s - o) < $e && (s -= o * $e), n = aJ(t, n, s, a), e.point(i, n), e.lineEnd(), e.lineStart(), e.point(o, n), r = 0), e.point(t = s, n = a), i = o
             },
-            reflow() {
-                return a = !0, this
+            lineEnd: function() {
+                e.lineEnd(), t = n = NaN
             },
-            pulse(o, l) {
-                const u = {},
-                    c = {};
-                let f, h, d, g, p, m;
-                for (f = 0, h = l.length; f < h; ++f) u[ge(l[f])] = 1;
-                for (f = 0, h = t.length; f < h; ++f) p = t[f], u[ge(p)] = -1;
-                for (f = 0, h = i.length; f < h; ++f) g = i[f], l.forEach(v => {
-                    g(v) && (u[ge(v)] = -1)
-                });
-                for (f = 0, h = e.length; f < h; ++f) p = e[f], m = ge(p), u[m] ? u[m] = 1 : o.add.push(He(e[f]));
-                for (f = 0, h = l.length; f < h; ++f) p = l[f], u[ge(p)] < 0 && o.rem.push(p);
-
-                function y(v, b, x) {
-                    x ? v[b] = x(v) : o.encode = b, a || (c[ge(v)] = v)
-                }
-                for (f = 0, h = n.length; f < h; ++f) d = n[f], p = d.tuple, g = d.field, m = u[ge(p)], m > 0 && (y(p, g, d.value), o.modifies(g));
-                for (f = 0, h = r.length; f < h; ++f) d = r[f], g = d.filter, l.forEach(v => {
-                    g(v) && u[ge(v)] > 0 && y(v, d.field, d.value)
-                }), o.modifies(d.field);
-                if (a) o.mod = t.length || i.length ? l.filter(v => u[ge(v)] > 0) : l.slice();
-                else
-                    for (m in c) o.mod.push(c[m]);
-                return (s || s == null && (t.length || i.length)) && o.clean(!0), o
+            clean: function() {
+                return 2 - r
             }
         }
     }
-    const Jg = "_:mod:_";
 
-    function Dm() {
-        Object.defineProperty(this, Jg, {
-            writable: !0,
-            value: {}
-        })
+    function aJ(e, t, n, i) {
+        var r, s, a = ke(e - n);
+        return Ge(a) > $e ? Qc((ke(t) * (s = Me(i)) * ke(n) - ke(i) * (r = Me(t)) * ke(e)) / (r * s * a)) : (t + i) / 2
     }
-    Dm.prototype = {
-        set(e, t, n, i) {
-            const r = this,
-                s = r[e],
-                a = r[Jg];
-            return t != null && t >= 0 ? (s[t] !== n || i) && (s[t] = n, a[t + ":" + e] = -1, a[e] = -1) : (s !== n || i) && (r[e] = n, a[e] = W(n) ? 1 + n.length : -1), r
-        },
-        modified(e, t) {
-            const n = this[Jg];
-            if (arguments.length) {
-                if (W(e)) {
-                    for (let i = 0; i < e.length; ++i)
-                        if (n[e[i]]) return !0;
-                    return !1
+
+    function oJ(e, t, n, i) {
+        var r;
+        if (e == null) r = n * Nt, i.point(-Ie, r), i.point(0, r), i.point(Ie, r), i.point(Ie, 0), i.point(Ie, -r), i.point(0, -r), i.point(-Ie, -r), i.point(-Ie, 0), i.point(-Ie, r);
+        else if (Ge(e[0] - t[0]) > $e) {
+            var s = e[0] < t[0] ? Ie : -Ie;
+            r = n * s / 2, i.point(-s, r), i.point(0, r), i.point(s, r)
+        } else i.point(t[0], t[1])
+    }
+
+    function lJ(e) {
+        var t = Me(e),
+            n = 6 * Le,
+            i = t > 0,
+            r = Ge(t) > $e;
+
+        function s(c, f, h, d) {
+            tJ(d, e, n, h, c, f)
+        }
+
+        function a(c, f) {
+            return Me(c) * Me(f) > t
+        }
+
+        function o(c) {
+            var f, h, d, g, p;
+            return {
+                lineStart: function() {
+                    g = d = !1, p = 1
+                },
+                point: function(m, y) {
+                    var v = [m, y],
+                        b, x = a(m, y),
+                        _ = i ? x ? 0 : u(m, y) : x ? u(m + (m < 0 ? Ie : -Ie), y) : 0;
+                    if (!f && (g = d = x) && c.lineStart(), x !== d && (b = l(f, v), (!b || Fp(f, b) || Fp(v, b)) && (v[2] = 1)), x !== d) p = 0, x ? (c.lineStart(), b = l(v, f), c.point(b[0], b[1])) : (b = l(f, v), c.point(b[0], b[1], 2), c.lineEnd()), f = b;
+                    else if (r && f && i ^ x) {
+                        var S;
+                        !(_ & h) && (S = l(v, f, !0)) && (p = 0, i ? (c.lineStart(), c.point(S[0][0], S[0][1]), c.point(S[1][0], S[1][1]), c.lineEnd()) : (c.point(S[1][0], S[1][1]), c.lineEnd(), c.lineStart(), c.point(S[0][0], S[0][1], 3)))
+                    }
+                    x && (!f || !Fp(f, v)) && c.point(v[0], v[1]), f = v, d = x, h = _
+                },
+                lineEnd: function() {
+                    d && c.lineEnd(), f = null
+                },
+                clean: function() {
+                    return p | (g && d) << 1
                 }
-            } else {
-                for (const i in n)
-                    if (n[i]) return !0;
-                return !1
             }
-            return t != null && t >= 0 ? t + 1 < n[e] || !!n[t + ":" + e] : !!n[e]
-        },
-        clear() {
-            return this[Jg] = {}, this
         }
-    };
-    let BX = 0;
-    const jX = "pulse",
-        UX = new Dm,
-        GX = 1,
-        WX = 2;
 
-    function it(e, t, n, i) {
-        this.id = ++BX, this.value = e, this.stamp = -1, this.rank = -1, this.qrank = -1, this.flags = 0, t && (this._update = t), n && this.parameters(n, i)
-    }
+        function l(c, f, h) {
+            var d = kl(c),
+                g = kl(f),
+                p = [1, 0, 0],
+                m = bc(d, g),
+                y = Dg(m, m),
+                v = m[0],
+                b = y - v * v;
+            if (!b) return !h && c;
+            var x = t * y / b,
+                _ = -t * v / b,
+                S = bc(p, m),
+                w = Ng(p, x),
+                E = Ng(m, _);
+            wv(w, E);
+            var C = S,
+                k = Dg(w, C),
+                A = Dg(C, C),
+                F = k * k - A * (Dg(w, w) - 1);
+            if (!(F < 0)) {
+                var $ = Kn(F),
+                    T = Ng(C, (-k - $) / A);
+                if (wv(T, w), T = Lm(T), !h) return T;
+                var M = c[0],
+                    R = f[0],
+                    N = c[1],
+                    L = f[1],
+                    I;
+                R < M && (I = M, M = R, R = I);
+                var G = R - M,
+                    ie = Ge(G - Ie) < $e,
+                    ge = ie || G < $e;
+                if (!ie && L < N && (I = N, N = L, L = I), ge ? ie ? N + L > 0 ^ T[1] < (Ge(T[0] - M) < $e ? N : L) : N <= T[1] && T[1] <= L : G > Ie ^ (M <= T[0] && T[0] <= R)) {
+                    var Re = Ng(C, (-k + $) / A);
+                    return wv(Re, w), [T, Lm(Re)]
+                }
+            }
+        }
 
-    function A$(e) {
-        return function(t) {
-            const n = this.flags;
-            return arguments.length === 0 ? !!(n & e) : (this.flags = t ? n | e : n & ~e, this)
+        function u(c, f) {
+            var h = i ? e : Ie - e,
+                d = 0;
+            return c < -h ? d |= 1 : c > h && (d |= 2), f < -h ? d |= 4 : f > h && (d |= 8), d
         }
+        return $4(a, o, s, i ? [0, -e] : [-Ie, e - Ie])
     }
-    it.prototype = {
-        targets() {
-            return this._targets || (this._targets = Om(sd))
-        },
-        set(e) {
-            return this.value !== e ? (this.value = e, 1) : 0
-        },
-        skip: A$(GX),
-        modified: A$(WX),
-        parameters(e, t, n) {
-            t = t !== !1;
-            const i = this._argval = this._argval || new Dm,
-                r = this._argops = this._argops || [],
-                s = [];
-            let a, o, l, u;
-            const c = (f, h, d) => {
-                d instanceof it ? (d !== this && (t && d.targets().add(this), s.push(d)), r.push({
-                    op: d,
-                    name: f,
-                    index: h
-                })) : i.set(f, h, d)
-            };
-            for (a in e)
-                if (o = e[a], a === jX) se(o).forEach(f => {
-                    f instanceof it ? f !== this && (f.targets().add(this), s.push(f)) : U("Pulse parameters must be operator instances.")
-                }), this.source = o;
-                else if (W(o))
-                for (i.set(a, -1, Array(l = o.length)), u = 0; u < l; ++u) c(a, u, o[u]);
-            else c(a, -1, o);
-            return this.marshall().clear(), n && (r.initonly = !0), s
-        },
-        marshall(e) {
-            const t = this._argval || UX,
-                n = this._argops;
-            let i, r, s, a;
-            if (n) {
-                const o = n.length;
-                for (r = 0; r < o; ++r) i = n[r], s = i.op, a = s.modified() && s.stamp === e, t.set(i.name, i.index, s.value, a);
-                if (n.initonly) {
-                    for (r = 0; r < o; ++r) i = n[r], i.op.targets().remove(this);
-                    this._argops = null, this._update = null
-                }
+
+    function uJ(e, t, n, i, r, s) {
+        var a = e[0],
+            o = e[1],
+            l = t[0],
+            u = t[1],
+            c = 0,
+            f = 1,
+            h = l - a,
+            d = u - o,
+            g;
+        if (g = n - a, !(!h && g > 0)) {
+            if (g /= h, h < 0) {
+                if (g < c) return;
+                g < f && (f = g)
+            } else if (h > 0) {
+                if (g > f) return;
+                g > c && (c = g)
             }
-            return t
-        },
-        detach() {
-            const e = this._argops;
-            let t, n, i, r;
-            if (e)
-                for (t = 0, n = e.length; t < n; ++t) i = e[t], r = i.op, r._targets && r._targets.remove(this);
-            this.pulse = null, this.source = null
-        },
-        evaluate(e) {
-            const t = this._update;
-            if (t) {
-                const n = this.marshall(e.stamp),
-                    i = t.call(this, n, e);
-                if (n.clear(), i !== this.value) this.value = i;
-                else if (!this.modified()) return e.StopPropagation
+            if (g = r - a, !(!h && g < 0)) {
+                if (g /= h, h < 0) {
+                    if (g > f) return;
+                    g > c && (c = g)
+                } else if (h > 0) {
+                    if (g < c) return;
+                    g < f && (f = g)
+                }
+                if (g = i - o, !(!d && g > 0)) {
+                    if (g /= d, d < 0) {
+                        if (g < c) return;
+                        g < f && (f = g)
+                    } else if (d > 0) {
+                        if (g > f) return;
+                        g > c && (c = g)
+                    }
+                    if (g = s - o, !(!d && g < 0)) {
+                        if (g /= d, d < 0) {
+                            if (g > f) return;
+                            g > c && (c = g)
+                        } else if (d > 0) {
+                            if (g < c) return;
+                            g < f && (f = g)
+                        }
+                        return c > 0 && (e[0] = a + c * h, e[1] = o + c * d), f < 1 && (t[0] = a + f * h, t[1] = o + f * d), !0
+                    }
+                }
             }
-        },
-        run(e) {
-            if (e.stamp < this.stamp) return e.StopPropagation;
-            let t;
-            return this.skip() ? (this.skip(!1), t = 0) : t = this.evaluate(e), this.pulse = t || e
         }
-    };
-
-    function qX(e, t, n, i) {
-        let r = 1,
-            s;
-        return e instanceof it ? s = e : e && e.prototype instanceof it ? s = new e : $e(e) ? s = new it(null, e) : (r = 0, s = new it(e, t)), this.rank(s), r && (i = n, n = t), n && this.connect(s, s.parameters(n, i)), this.touch(s), s
     }
+    var ih = 1e9,
+        Lg = -ih;
 
-    function HX(e, t) {
-        const n = e.rank,
-            i = t.length;
-        for (let r = 0; r < i; ++r)
-            if (n < t[r].rank) {
-                this.rerank(e);
-                return
+    function T4(e, t, n, i) {
+        function r(u, c) {
+            return e <= u && u <= n && t <= c && c <= i
+        }
+
+        function s(u, c, f, h) {
+            var d = 0,
+                g = 0;
+            if (u == null || (d = a(u, f)) !== (g = a(c, f)) || l(u, c) < 0 ^ f > 0)
+                do h.point(d === 0 || d === 3 ? e : n, d > 1 ? i : t); while ((d = (d + f + 4) % 4) !== g);
+            else h.point(c[0], c[1])
+        }
+
+        function a(u, c) {
+            return Ge(u[0] - e) < $e ? c > 0 ? 0 : 3 : Ge(u[0] - n) < $e ? c > 0 ? 2 : 1 : Ge(u[1] - t) < $e ? c > 0 ? 1 : 0 : c > 0 ? 3 : 2
+        }
+
+        function o(u, c) {
+            return l(u.x, c.x)
+        }
+
+        function l(u, c) {
+            var f = a(u, 1),
+                h = a(c, 1);
+            return f !== h ? f - h : f === 0 ? c[1] - u[1] : f === 1 ? u[0] - c[0] : f === 2 ? u[1] - c[1] : c[0] - u[0]
+        }
+        return function(u) {
+            var c = u,
+                f = C4(),
+                h, d, g, p, m, y, v, b, x, _, S, w = {
+                    point: E,
+                    lineStart: F,
+                    lineEnd: $,
+                    polygonStart: k,
+                    polygonEnd: A
+                };
+
+            function E(M, R) {
+                r(M, R) && c.point(M, R)
+            }
+
+            function C() {
+                for (var M = 0, R = 0, N = d.length; R < N; ++R)
+                    for (var L = d[R], I = 1, G = L.length, ie = L[0], ge, Re, Te = ie[0], tt = ie[1]; I < G; ++I) ge = Te, Re = tt, ie = L[I], Te = ie[0], tt = ie[1], Re <= i ? tt > i && (Te - ge) * (i - Re) > (tt - Re) * (e - ge) && ++M : tt <= i && (Te - ge) * (i - Re) < (tt - Re) * (e - ge) && --M;
+                return M
+            }
+
+            function k() {
+                c = f, h = [], d = [], S = !0
+            }
+
+            function A() {
+                var M = C(),
+                    R = S && M,
+                    N = (h = kF(h)).length;
+                (R || N) && (u.polygonStart(), R && (u.lineStart(), s(null, null, 1, u), u.lineEnd()), N && A4(h, o, M, s, u), u.polygonEnd()), c = u, h = d = g = null
+            }
+
+            function F() {
+                w.point = T, d && d.push(g = []), _ = !0, x = !1, v = b = NaN
+            }
+
+            function $() {
+                h && (T(p, m), y && x && f.rejoin(), h.push(f.result())), w.point = E, x && c.lineEnd()
+            }
+
+            function T(M, R) {
+                var N = r(M, R);
+                if (d && g.push([M, R]), _) p = M, m = R, y = N, _ = !1, N && (c.lineStart(), c.point(M, R));
+                else if (N && x) c.point(M, R);
+                else {
+                    var L = [v = Math.max(Lg, Math.min(ih, v)), b = Math.max(Lg, Math.min(ih, b))],
+                        I = [M = Math.max(Lg, Math.min(ih, M)), R = Math.max(Lg, Math.min(ih, R))];
+                    uJ(L, I, e, t, n, i) ? (x || (c.lineStart(), c.point(L[0], L[1])), c.point(I[0], I[1]), N || c.lineEnd(), S = !1) : N && (c.lineStart(), c.point(M, R), S = !1)
+                }
+                v = M, b = R, x = N
             }
+            return w
+        }
     }
-    let YX = 0;
 
-    function Nm(e, t, n) {
-        this.id = ++YX, this.value = null, n && (this.receive = n), e && (this._filter = e), t && (this._apply = t)
+    function cT(e, t, n) {
+        var i = $i(e, t - $e, n).concat(t);
+        return function(r) {
+            return i.map(function(s) {
+                return [r, s]
+            })
+        }
     }
 
-    function ra(e, t, n) {
-        return new Nm(e, t, n)
+    function fT(e, t, n) {
+        var i = $i(e, t - $e, n).concat(t);
+        return function(r) {
+            return i.map(function(s) {
+                return [s, r]
+            })
+        }
     }
-    Nm.prototype = {
-        _filter: Ri,
-        _apply: bn,
-        targets() {
-            return this._targets || (this._targets = Om(sd))
-        },
-        consume(e) {
-            return arguments.length ? (this._consume = !!e, this) : !!this._consume
-        },
-        receive(e) {
-            if (this._filter(e)) {
-                const t = this.value = this._apply(e),
-                    n = this._targets,
-                    i = n ? n.length : 0;
-                for (let r = 0; r < i; ++r) n[r].receive(t);
-                this._consume && (e.preventDefault(), e.stopPropagation())
+
+    function cJ() {
+        var e, t, n, i, r, s, a, o, l = 10,
+            u = l,
+            c = 90,
+            f = 360,
+            h, d, g, p, m = 2.5;
+
+        function y() {
+            return {
+                type: "MultiLineString",
+                coordinates: v()
             }
-        },
-        filter(e) {
-            const t = ra(e);
-            return this.targets().add(t), t
-        },
-        apply(e) {
-            const t = ra(null, e);
-            return this.targets().add(t), t
-        },
-        merge() {
-            const e = ra();
-            this.targets().add(e);
-            for (let t = 0, n = arguments.length; t < n; ++t) arguments[t].targets().add(e);
-            return e
-        },
-        throttle(e) {
-            let t = -1;
-            return this.filter(() => {
-                const n = Date.now();
-                return n - t > e ? (t = n, 1) : 0
-            })
-        },
-        debounce(e) {
-            const t = ra();
-            return this.targets().add(ra(null, null, h_(e, n => {
-                const i = n.dataflow;
-                t.receive(n), i && i.run && i.run()
-            }))), t
-        },
-        between(e, t) {
-            let n = !1;
-            return e.targets().add(ra(null, null, () => n = !0)), t.targets().add(ra(null, null, () => n = !1)), this.filter(() => n)
-        },
-        detach() {
-            this._filter = Ri, this._targets = null
         }
-    };
 
-    function XX(e, t, n, i) {
-        const r = this,
-            s = ra(n, i),
-            a = function(u) {
-                u.dataflow = r;
-                try {
-                    s.receive(u)
-                } catch (c) {
-                    r.error(c)
-                } finally {
-                    r.run()
+        function v() {
+            return $i(Rg(i / c) * c, n, c).map(g).concat($i(Rg(o / f) * f, a, f).map(p)).concat($i(Rg(t / l) * l, e, l).filter(function(b) {
+                return Ge(b % c) > $e
+            }).map(h)).concat($i(Rg(s / u) * u, r, u).filter(function(b) {
+                return Ge(b % f) > $e
+            }).map(d))
+        }
+        return y.lines = function() {
+            return v().map(function(b) {
+                return {
+                    type: "LineString",
+                    coordinates: b
                 }
-            };
-        let o;
-        typeof e == "string" && typeof document < "u" ? o = document.querySelectorAll(e) : o = se(e);
-        const l = o.length;
-        for (let u = 0; u < l; ++u) o[u].addEventListener(t, a);
-        return s
+            })
+        }, y.outline = function() {
+            return {
+                type: "Polygon",
+                coordinates: [g(i).concat(p(a).slice(1), g(n).reverse().slice(1), p(o).reverse().slice(1))]
+            }
+        }, y.extent = function(b) {
+            return arguments.length ? y.extentMajor(b).extentMinor(b) : y.extentMinor()
+        }, y.extentMajor = function(b) {
+            return arguments.length ? (i = +b[0][0], n = +b[1][0], o = +b[0][1], a = +b[1][1], i > n && (b = i, i = n, n = b), o > a && (b = o, o = a, a = b), y.precision(m)) : [
+                [i, o],
+                [n, a]
+            ]
+        }, y.extentMinor = function(b) {
+            return arguments.length ? (t = +b[0][0], e = +b[1][0], s = +b[0][1], r = +b[1][1], t > e && (b = t, t = e, e = b), s > r && (b = s, s = r, r = b), y.precision(m)) : [
+                [t, s],
+                [e, r]
+            ]
+        }, y.step = function(b) {
+            return arguments.length ? y.stepMajor(b).stepMinor(b) : y.stepMinor()
+        }, y.stepMajor = function(b) {
+            return arguments.length ? (c = +b[0], f = +b[1], y) : [c, f]
+        }, y.stepMinor = function(b) {
+            return arguments.length ? (l = +b[0], u = +b[1], y) : [l, u]
+        }, y.precision = function(b) {
+            return arguments.length ? (m = +b, h = cT(s, r, 90), d = fT(t, e, m), g = cT(o, a, 90), p = fT(i, n, m), y) : m
+        }, y.extentMajor([
+            [-180, -90 + $e],
+            [180, 90 - $e]
+        ]).extentMinor([
+            [-180, -80 - $e],
+            [180, 80 + $e]
+        ])
     }
+    const nd = e => e;
+    var Ev = new Yn,
+        P2 = new Yn,
+        M4, O4, L2, I2, Oa = {
+            point: mn,
+            lineStart: mn,
+            lineEnd: mn,
+            polygonStart: function() {
+                Oa.lineStart = fJ, Oa.lineEnd = dJ
+            },
+            polygonEnd: function() {
+                Oa.lineStart = Oa.lineEnd = Oa.point = mn, Ev.add(Ge(P2)), P2 = new Yn
+            },
+            result: function() {
+                var e = Ev / 2;
+                return Ev = new Yn, e
+            }
+        };
 
-    function VX(e, t) {
-        const n = this.locale();
-        return jD(e, t, n.timeParse, n.utcParse)
+    function fJ() {
+        Oa.point = hJ
     }
 
-    function KX(e, t, n) {
-        return t = this.parse(t, n), this.pulse(e, this.changeset().insert(t))
+    function hJ(e, t) {
+        Oa.point = F4, M4 = L2 = e, O4 = I2 = t
     }
-    async function JX(e, t) {
-        const n = this;
-        let i = 0,
-            r;
-        try {
-            r = await n.loader().load(e, {
-                context: "dataflow",
-                response: BD(t && t.type)
-            });
-            try {
-                r = n.parse(r, t)
-            } catch (s) {
-                i = -2, n.warn("Data ingestion failed", e, s)
-            }
-        } catch (s) {
-            i = -1, n.warn("Loading failed", e, s)
-        }
-        return {
-            data: r,
-            status: i
-        }
+
+    function F4(e, t) {
+        P2.add(I2 * e - L2 * t), L2 = e, I2 = t
     }
-    async function QX(e, t, n) {
-        const i = this,
-            r = i._pending || ZX(i);
-        r.requests += 1;
-        const s = await i.request(t, n);
-        return i.pulse(e, i.changeset().remove(Ri).insert(s.data || [])), r.done(), s
+
+    function dJ() {
+        F4(M4, O4)
     }
+    const hT = Oa;
+    var xc = 1 / 0,
+        Hm = xc,
+        id = -xc,
+        Ym = id,
+        gJ = {
+            point: pJ,
+            lineStart: mn,
+            lineEnd: mn,
+            polygonStart: mn,
+            polygonEnd: mn,
+            result: function() {
+                var e = [
+                    [xc, Hm],
+                    [id, Ym]
+                ];
+                return id = Ym = -(Hm = xc = 1 / 0), e
+            }
+        };
 
-    function ZX(e) {
-        let t;
-        const n = new Promise(i => t = i);
-        return n.requests = 0, n.done = () => {
-            --n.requests === 0 && (e._pending = null, t(e))
-        }, e._pending = n
+    function pJ(e, t) {
+        e < xc && (xc = e), e > id && (id = e), t < Hm && (Hm = t), t > Ym && (Ym = t)
     }
-    const eV = {
-        skip: !0
-    };
+    const Xm = gJ;
+    var z2 = 0,
+        B2 = 0,
+        rh = 0,
+        Vm = 0,
+        Km = 0,
+        zu = 0,
+        j2 = 0,
+        G2 = 0,
+        sh = 0,
+        R4, D4, Vr, Kr, pr = {
+            point: Cl,
+            lineStart: dT,
+            lineEnd: gT,
+            polygonStart: function() {
+                pr.lineStart = vJ, pr.lineEnd = bJ
+            },
+            polygonEnd: function() {
+                pr.point = Cl, pr.lineStart = dT, pr.lineEnd = gT
+            },
+            result: function() {
+                var e = sh ? [j2 / sh, G2 / sh] : zu ? [Vm / zu, Km / zu] : rh ? [z2 / rh, B2 / rh] : [NaN, NaN];
+                return z2 = B2 = rh = Vm = Km = zu = j2 = G2 = sh = 0, e
+            }
+        };
 
-    function tV(e, t, n, i, r) {
-        return (e instanceof it ? iV : nV)(this, e, t, n, i, r), this
+    function Cl(e, t) {
+        z2 += e, B2 += t, ++rh
     }
 
-    function nV(e, t, n, i, r, s) {
-        const a = Ae({}, s, eV);
-        let o, l;
-        $e(n) || (n = xn(n)), i === void 0 ? o = u => e.touch(n(u)) : $e(i) ? (l = new it(null, i, r, !1), o = u => {
-            l.evaluate(u);
-            const c = n(u),
-                f = l.value;
-            qD(f) ? e.pulse(c, f, s) : e.update(c, f, a)
-        }) : o = u => e.update(n(u), i, a), t.apply(o)
+    function dT() {
+        pr.point = mJ
     }
 
-    function iV(e, t, n, i, r, s) {
-        if (i === void 0) t.targets().add(n);
-        else {
-            const a = s || {},
-                o = new it(null, rV(n, i), r, !1);
-            o.modified(a.force), o.rank = t.rank, t.targets().add(o), n && (o.skip(!0), o.value = n.value, o.targets().add(n), e.connect(n, [o]))
-        }
+    function mJ(e, t) {
+        pr.point = yJ, Cl(Vr = e, Kr = t)
     }
 
-    function rV(e, t) {
-        return t = $e(t) ? t : xn(t), e ? function(n, i) {
-            const r = t(n, i);
-            return e.skip() || (e.skip(r !== this.value).value = r), r
-        } : t
+    function yJ(e, t) {
+        var n = e - Vr,
+            i = t - Kr,
+            r = Kn(n * n + i * i);
+        Vm += r * (Vr + e) / 2, Km += r * (Kr + t) / 2, zu += r, Cl(Vr = e, Kr = t)
     }
 
-    function sV(e) {
-        e.rank = ++this._rank
+    function gT() {
+        pr.point = Cl
     }
 
-    function aV(e) {
-        const t = [e];
-        let n, i, r;
-        for (; t.length;)
-            if (this.rank(n = t.pop()), i = n._targets)
-                for (r = i.length; --r >= 0;) t.push(n = i[r]), n === e && U("Cycle detected in dataflow graph.")
+    function vJ() {
+        pr.point = xJ
     }
-    const h0 = {},
-        Tr = 1,
-        la = 2,
-        ys = 4,
-        oV = Tr | la,
-        $$ = Tr | ys,
-        Xl = Tr | la | ys,
-        T$ = 8,
-        Qc = 16,
-        M$ = 32,
-        O$ = 64;
 
-    function Ca(e, t, n) {
-        this.dataflow = e, this.stamp = t ?? -1, this.add = [], this.rem = [], this.mod = [], this.fields = null, this.encode = n || null
+    function bJ() {
+        N4(R4, D4)
     }
 
-    function Xy(e, t) {
-        const n = [];
-        return oa(e, t, i => n.push(i)), n
+    function xJ(e, t) {
+        pr.point = N4, Cl(R4 = Vr = e, D4 = Kr = t)
     }
 
-    function F$(e, t) {
-        const n = {};
-        return e.visit(t, i => {
-            n[ge(i)] = 1
-        }), i => n[ge(i)] ? null : i
+    function N4(e, t) {
+        var n = e - Vr,
+            i = t - Kr,
+            r = Kn(n * n + i * i);
+        Vm += r * (Vr + e) / 2, Km += r * (Kr + t) / 2, zu += r, r = Kr * e - Vr * t, j2 += r * (Vr + e), G2 += r * (Kr + t), sh += r * 3, Cl(Vr = e, Kr = t)
     }
+    const pT = pr;
 
-    function mg(e, t) {
-        return e ? (n, i) => e(n, i) && t(n, i) : t
+    function P4(e) {
+        this._context = e
     }
-    Ca.prototype = {
-        StopPropagation: h0,
-        ADD: Tr,
-        REM: la,
-        MOD: ys,
-        ADD_REM: oV,
-        ADD_MOD: $$,
-        ALL: Xl,
-        REFLOW: T$,
-        SOURCE: Qc,
-        NO_SOURCE: M$,
-        NO_FIELDS: O$,
-        fork(e) {
-            return new Ca(this.dataflow).init(this, e)
-        },
-        clone() {
-            const e = this.fork(Xl);
-            return e.add = e.add.slice(), e.rem = e.rem.slice(), e.mod = e.mod.slice(), e.source && (e.source = e.source.slice()), e.materialize(Xl | Qc)
-        },
-        addAll() {
-            let e = this;
-            return !e.source || e.add === e.rem || !e.rem.length && e.source.length === e.add.length || (e = new Ca(this.dataflow).init(this), e.add = e.source, e.rem = []), e
-        },
-        init(e, t) {
-            const n = this;
-            return n.stamp = e.stamp, n.encode = e.encode, e.fields && !(t & O$) && (n.fields = e.fields), t & Tr ? (n.addF = e.addF, n.add = e.add) : (n.addF = null, n.add = []), t & la ? (n.remF = e.remF, n.rem = e.rem) : (n.remF = null, n.rem = []), t & ys ? (n.modF = e.modF, n.mod = e.mod) : (n.modF = null, n.mod = []), t & M$ ? (n.srcF = null, n.source = null) : (n.srcF = e.srcF, n.source = e.source, e.cleans && (n.cleans = e.cleans)), n
-        },
-        runAfter(e) {
-            this.dataflow.runAfter(e)
-        },
-        changed(e) {
-            const t = e || Xl;
-            return t & Tr && this.add.length || t & la && this.rem.length || t & ys && this.mod.length
-        },
-        reflow(e) {
-            if (e) return this.fork(Xl).reflow();
-            const t = this.add.length,
-                n = this.source && this.source.length;
-            return n && n !== t && (this.mod = this.source, t && this.filter(ys, F$(this, Tr))), this
-        },
-        clean(e) {
-            return arguments.length ? (this.cleans = !!e, this) : this.cleans
+    P4.prototype = {
+        _radius: 4.5,
+        pointRadius: function(e) {
+            return this._radius = e, this
         },
-        modifies(e) {
-            const t = this.fields || (this.fields = {});
-            return W(e) ? e.forEach(n => t[n] = !0) : t[e] = !0, this
+        polygonStart: function() {
+            this._line = 0
         },
-        modified(e, t) {
-            const n = this.fields;
-            return (t || this.mod.length) && n ? arguments.length ? W(e) ? e.some(i => n[i]) : n[e] : !!n : !1
+        polygonEnd: function() {
+            this._line = NaN
         },
-        filter(e, t) {
-            const n = this;
-            return e & Tr && (n.addF = mg(n.addF, t)), e & la && (n.remF = mg(n.remF, t)), e & ys && (n.modF = mg(n.modF, t)), e & Qc && (n.srcF = mg(n.srcF, t)), n
+        lineStart: function() {
+            this._point = 0
         },
-        materialize(e) {
-            e = e || Xl;
-            const t = this;
-            return e & Tr && t.addF && (t.add = Xy(t.add, t.addF), t.addF = null), e & la && t.remF && (t.rem = Xy(t.rem, t.remF), t.remF = null), e & ys && t.modF && (t.mod = Xy(t.mod, t.modF), t.modF = null), e & Qc && t.srcF && (t.source = t.source.filter(t.srcF), t.srcF = null), t
+        lineEnd: function() {
+            this._line === 0 && this._context.closePath(), this._point = NaN
         },
-        visit(e, t) {
-            const n = this,
-                i = t;
-            if (e & Qc) return oa(n.source, n.srcF, i), n;
-            e & Tr && oa(n.add, n.addF, i), e & la && oa(n.rem, n.remF, i), e & ys && oa(n.mod, n.modF, i);
-            const r = n.source;
-            if (e & T$ && r) {
-                const s = n.add.length + n.mod.length;
-                s === r.length || (s ? oa(r, F$(n, $$), i) : oa(r, n.srcF, i))
+        point: function(e, t) {
+            switch (this._point) {
+                case 0: {
+                    this._context.moveTo(e, t), this._point = 1;
+                    break
+                }
+                case 1: {
+                    this._context.lineTo(e, t);
+                    break
+                }
+                default: {
+                    this._context.moveTo(e + this._radius, t), this._context.arc(e, t, this._radius, 0, Vn);
+                    break
+                }
             }
-            return n
-        }
+        },
+        result: mn
     };
+    var U2 = new Yn,
+        kv, L4, I4, ah, oh, Jm = {
+            point: mn,
+            lineStart: function() {
+                Jm.point = _J
+            },
+            lineEnd: function() {
+                kv && z4(L4, I4), Jm.point = mn
+            },
+            polygonStart: function() {
+                kv = !0
+            },
+            polygonEnd: function() {
+                kv = null
+            },
+            result: function() {
+                var e = +U2;
+                return U2 = new Yn, e
+            }
+        };
 
-    function C_(e, t, n, i) {
-        const r = this;
-        let s = 0;
-        this.dataflow = e, this.stamp = t, this.fields = null, this.encode = i || null, this.pulses = n;
-        for (const a of n)
-            if (a.stamp === t) {
-                if (a.fields) {
-                    const o = r.fields || (r.fields = {});
-                    for (const l in a.fields) o[l] = 1
-                }
-                a.changed(r.ADD) && (s |= r.ADD), a.changed(r.REM) && (s |= r.REM), a.changed(r.MOD) && (s |= r.MOD)
-            } this.changes = s
+    function _J(e, t) {
+        Jm.point = z4, L4 = ah = e, I4 = oh = t
     }
-    ee(C_, Ca, {
-        fork(e) {
-            const t = new Ca(this.dataflow).init(this, e & this.NO_FIELDS);
-            return e !== void 0 && (e & t.ADD && this.visit(t.ADD, n => t.add.push(n)), e & t.REM && this.visit(t.REM, n => t.rem.push(n)), e & t.MOD && this.visit(t.MOD, n => t.mod.push(n))), t
-        },
-        changed(e) {
-            return this.changes & e
-        },
-        modified(e) {
-            const t = this,
-                n = t.fields;
-            return n && t.changes & t.MOD ? W(e) ? e.some(i => n[i]) : n[e] : 0
-        },
-        filter() {
-            U("MultiPulse does not support filtering.")
-        },
-        materialize() {
-            U("MultiPulse does not support materialization.")
-        },
-        visit(e, t) {
-            const n = this,
-                i = n.pulses,
-                r = i.length;
-            let s = 0;
-            if (e & n.SOURCE)
-                for (; s < r; ++s) i[s].visit(e, t);
-            else
-                for (; s < r; ++s) i[s].stamp === n.stamp && i[s].visit(e, t);
-            return n
+
+    function z4(e, t) {
+        ah -= e, oh -= t, U2.add(Kn(ah * ah + oh * oh)), ah = e, oh = t
+    }
+    const mT = Jm;
+    let yT, Qm, vT, bT;
+    class xT {
+        constructor(t) {
+            this._append = t == null ? B4 : wJ(t), this._radius = 4.5, this._ = ""
         }
-    });
-    async function lV(e, t, n) {
-        const i = this,
-            r = [];
-        if (i._pulse) return HD(i);
-        if (i._pending && await i._pending, t && await Kg(i, t), !i._touched.length) return i.debug("Dataflow invoked, but nothing to do."), i;
-        const s = ++i._clock;
-        i._pulse = new Ca(i, s, e), i._touched.forEach(c => i._enqueue(c, !0)), i._touched = Om(sd);
-        let a = 0,
-            o, l, u;
-        try {
-            for (; i._heap.size() > 0;) {
-                if (o = i._heap.pop(), o.rank !== o.qrank) {
-                    i._enqueue(o, !0);
-                    continue
+        pointRadius(t) {
+            return this._radius = +t, this
+        }
+        polygonStart() {
+            this._line = 0
+        }
+        polygonEnd() {
+            this._line = NaN
+        }
+        lineStart() {
+            this._point = 0
+        }
+        lineEnd() {
+            this._line === 0 && (this._ += "Z"), this._point = NaN
+        }
+        point(t, n) {
+            switch (this._point) {
+                case 0: {
+                    this._append`M${t},${n}`, this._point = 1;
+                    break
+                }
+                case 1: {
+                    this._append`L${t},${n}`;
+                    break
+                }
+                default: {
+                    if (this._append`M${t},${n}`, this._radius !== vT || this._append !== Qm) {
+                        const i = this._radius,
+                            r = this._;
+                        this._ = "", this._append`m0,${i}a${i},${i} 0 1,1 0,${-2*i}a${i},${i} 0 1,1 0,${2*i}z`, vT = i, Qm = this._append, bT = this._, this._ = r
+                    }
+                    this._ += bT;
+                    break
                 }
-                l = o.run(i._getPulse(o, e)), l.then ? l = await l : l.async && (r.push(l.async), l = h0), l !== h0 && o._targets && o._targets.forEach(c => i._enqueue(c)), ++a
             }
-        } catch (c) {
-            i._heap.clear(), u = c
         }
-        if (i._input = {}, i._pulse = null, i.debug(`Pulse ${s}: ${a} operators`), u && (i._postrun = [], i.error(u)), i._postrun.length) {
-            const c = i._postrun.sort((f, h) => h.priority - f.priority);
-            i._postrun = [];
-            for (let f = 0; f < c.length; ++f) await Kg(i, c[f].callback)
+        result() {
+            const t = this._;
+            return this._ = "", t.length ? t : null
         }
-        return n && await Kg(i, n), r.length && Promise.all(r).then(c => i.runAsync(null, () => {
-            c.forEach(f => {
-                try {
-                    f(i)
-                } catch (h) {
-                    i.error(h)
-                }
-            })
-        })), i
     }
-    async function uV(e, t, n) {
-        for (; this._running;) await this._running;
-        const i = () => this._running = null;
-        return (this._running = this.evaluate(e, t, n)).then(i, i), this._running
+
+    function B4(e) {
+        let t = 1;
+        this._ += e[0];
+        for (const n = e.length; t < n; ++t) this._ += arguments[t] + e[t]
     }
 
-    function cV(e, t, n) {
-        return this._pulse ? HD(this) : (this.evaluate(e, t, n), this)
+    function wJ(e) {
+        const t = Math.floor(e);
+        if (!(t >= 0)) throw new RangeError(`invalid digits: ${e}`);
+        if (t > 15) return B4;
+        if (t !== yT) {
+            const n = 10 ** t;
+            yT = t, Qm = function(r) {
+                let s = 1;
+                this._ += r[0];
+                for (const a = r.length; s < a; ++s) this._ += Math.round(arguments[s] * n) / n + r[s]
+            }
+        }
+        return Qm
     }
 
-    function fV(e, t, n) {
-        if (this._pulse || t) this._postrun.push({
-            priority: n || 0,
-            callback: e
-        });
-        else try {
-            e(this)
-        } catch (i) {
-            this.error(i)
+    function j4(e, t) {
+        let n = 3,
+            i = 4.5,
+            r, s;
+
+        function a(o) {
+            return o && (typeof i == "function" && s.pointRadius(+i.apply(this, arguments)), zs(o, r(s))), s.result()
         }
+        return a.area = function(o) {
+            return zs(o, r(hT)), hT.result()
+        }, a.measure = function(o) {
+            return zs(o, r(mT)), mT.result()
+        }, a.bounds = function(o) {
+            return zs(o, r(Xm)), Xm.result()
+        }, a.centroid = function(o) {
+            return zs(o, r(pT)), pT.result()
+        }, a.projection = function(o) {
+            return arguments.length ? (r = o == null ? (e = null, nd) : (e = o).stream, a) : e
+        }, a.context = function(o) {
+            return arguments.length ? (s = o == null ? (t = null, new xT(n)) : new P4(t = o), typeof i != "function" && s.pointRadius(i), a) : t
+        }, a.pointRadius = function(o) {
+            return arguments.length ? (i = typeof o == "function" ? o : (s.pointRadius(+o), +o), a) : i
+        }, a.digits = function(o) {
+            if (!arguments.length) return n;
+            if (o == null) n = null;
+            else {
+                const l = Math.floor(o);
+                if (!(l >= 0)) throw new RangeError(`invalid digits: ${o}`);
+                n = l
+            }
+            return t === null && (s = new xT(n)), a
+        }, a.projection(e).digits(n).context(t)
     }
 
-    function HD(e) {
-        return e.error("Dataflow already running. Use runAsync() to chain invocations."), e
+    function O1(e) {
+        return function(t) {
+            var n = new W2;
+            for (var i in e) n[i] = e[i];
+            return n.stream = t, n
+        }
     }
 
-    function hV(e, t) {
-        const n = e.stamp < this._clock;
-        n && (e.stamp = this._clock), (n || t) && (e.qrank = e.rank, this._heap.push(e))
+    function W2() {}
+    W2.prototype = {
+        constructor: W2,
+        point: function(e, t) {
+            this.stream.point(e, t)
+        },
+        sphere: function() {
+            this.stream.sphere()
+        },
+        lineStart: function() {
+            this.stream.lineStart()
+        },
+        lineEnd: function() {
+            this.stream.lineEnd()
+        },
+        polygonStart: function() {
+            this.stream.polygonStart()
+        },
+        polygonEnd: function() {
+            this.stream.polygonEnd()
+        }
+    };
+
+    function qS(e, t, n) {
+        var i = e.clipExtent && e.clipExtent();
+        return e.scale(150).translate([0, 0]), i != null && e.clipExtent(null), zs(n, e.stream(Xm)), t(Xm.result()), i != null && e.clipExtent(i), e
     }
 
-    function dV(e, t) {
-        const n = e.source,
-            i = this._clock;
-        return n && W(n) ? new C_(this, i, n.map(r => r.pulse), t) : this._input[e.id] || gV(this._pulse, n && n.pulse)
+    function F1(e, t, n) {
+        return qS(e, function(i) {
+            var r = t[1][0] - t[0][0],
+                s = t[1][1] - t[0][1],
+                a = Math.min(r / (i[1][0] - i[0][0]), s / (i[1][1] - i[0][1])),
+                o = +t[0][0] + (r - a * (i[1][0] + i[0][0])) / 2,
+                l = +t[0][1] + (s - a * (i[1][1] + i[0][1])) / 2;
+            e.scale(150 * a).translate([o, l])
+        }, n)
     }
 
-    function gV(e, t) {
-        return t && t.stamp === e.stamp ? t : (e = e.fork(), t && t !== h0 && (e.source = t.source), e)
+    function HS(e, t, n) {
+        return F1(e, [
+            [0, 0], t
+        ], n)
     }
-    const k_ = {
-        skip: !1,
-        force: !1
-    };
 
-    function pV(e, t) {
-        const n = t || k_;
-        return this._pulse ? this._enqueue(e) : this._touched.add(e), n.skip && e.skip(!0), this
+    function YS(e, t, n) {
+        return qS(e, function(i) {
+            var r = +t,
+                s = r / (i[1][0] - i[0][0]),
+                a = (r - s * (i[1][0] + i[0][0])) / 2,
+                o = -s * i[0][1];
+            e.scale(150 * s).translate([a, o])
+        }, n)
     }
 
-    function mV(e, t, n) {
-        const i = n || k_;
-        return (e.set(t) || i.force) && this.touch(e, i), this
+    function XS(e, t, n) {
+        return qS(e, function(i) {
+            var r = +t,
+                s = r / (i[1][1] - i[0][1]),
+                a = -s * i[0][0],
+                o = (r - s * (i[1][1] + i[0][1])) / 2;
+            e.scale(150 * s).translate([a, o])
+        }, n)
     }
+    var _T = 16,
+        SJ = Me(30 * Le);
 
-    function yV(e, t, n) {
-        this.touch(e, n || k_);
-        const i = new Ca(this, this._clock + (this._pulse ? 0 : 1)),
-            r = e.pulse && e.pulse.source || [];
-        return i.target = e, this._input[e.id] = t.pulse(i, r), this
+    function wT(e, t) {
+        return +t ? kJ(e, t) : EJ(e)
     }
 
-    function vV(e) {
-        let t = [];
-        return {
-            clear: () => t = [],
-            size: () => t.length,
-            peek: () => t[0],
-            push: n => (t.push(n), YD(t, 0, t.length - 1, e)),
-            pop: () => {
-                const n = t.pop();
-                let i;
-                return t.length ? (i = t[0], t[0] = n, bV(t, 0, e)) : i = n, i
+    function EJ(e) {
+        return O1({
+            point: function(t, n) {
+                t = e(t, n), this.stream.point(t[0], t[1])
             }
-        }
+        })
     }
 
-    function YD(e, t, n, i) {
-        let r, s;
-        const a = e[n];
-        for (; n > t;) {
-            if (s = n - 1 >> 1, r = e[s], i(a, r) < 0) {
-                e[n] = r, n = s;
-                continue
+    function kJ(e, t) {
+        function n(i, r, s, a, o, l, u, c, f, h, d, g, p, m) {
+            var y = u - i,
+                v = c - r,
+                b = y * y + v * v;
+            if (b > 4 * t && p--) {
+                var x = a + h,
+                    _ = o + d,
+                    S = l + g,
+                    w = Kn(x * x + _ * _ + S * S),
+                    E = gi(S /= w),
+                    C = Ge(Ge(S) - 1) < $e || Ge(s - f) < $e ? (s + f) / 2 : Ki(_, x),
+                    k = e(C, E),
+                    A = k[0],
+                    F = k[1],
+                    $ = A - i,
+                    T = F - r,
+                    M = v * $ - y * T;
+                (M * M / b > t || Ge((y * $ + v * T) / b - .5) > .3 || a * h + o * d + l * g < SJ) && (n(i, r, s, a, o, l, A, F, C, x /= w, _ /= w, S, p, m), m.point(A, F), n(A, F, C, x, _, S, u, c, f, h, d, g, p, m))
             }
-            break
         }
-        return e[n] = a
-    }
+        return function(i) {
+            var r, s, a, o, l, u, c, f, h, d, g, p, m = {
+                point: y,
+                lineStart: v,
+                lineEnd: x,
+                polygonStart: function() {
+                    i.polygonStart(), m.lineStart = _
+                },
+                polygonEnd: function() {
+                    i.polygonEnd(), m.lineStart = v
+                }
+            };
 
-    function bV(e, t, n) {
-        const i = t,
-            r = e.length,
-            s = e[t];
-        let a = (t << 1) + 1,
-            o;
-        for (; a < r;) o = a + 1, o < r && n(e[a], e[o]) >= 0 && (a = o), e[t] = e[a], t = a, a = (t << 1) + 1;
-        return e[t] = s, YD(e, i, t, n)
-    }
+            function y(E, C) {
+                E = e(E, C), i.point(E[0], E[1])
+            }
 
-    function wu() {
-        this.logger(o_()), this.logLevel(s_), this._clock = 0, this._rank = 0, this._locale = x_();
-        try {
-            this._loader = Mm()
-        } catch {}
-        this._touched = Om(sd), this._input = {}, this._pulse = null, this._heap = vV((e, t) => e.qrank - t.qrank), this._postrun = []
-    }
+            function v() {
+                f = NaN, m.point = b, i.lineStart()
+            }
 
-    function Zc(e) {
-        return function() {
-            return this._log[e].apply(this, arguments)
-        }
-    }
-    wu.prototype = {
-        stamp() {
-            return this._clock
-        },
-        loader(e) {
-            return arguments.length ? (this._loader = e, this) : this._loader
-        },
-        locale(e) {
-            return arguments.length ? (this._locale = e, this) : this._locale
-        },
-        logger(e) {
-            return arguments.length ? (this._log = e, this) : this._log
-        },
-        error: Zc("error"),
-        warn: Zc("warn"),
-        info: Zc("info"),
-        debug: Zc("debug"),
-        logLevel: Zc("level"),
-        cleanThreshold: 1e4,
-        add: qX,
-        connect: HX,
-        rank: sV,
-        rerank: aV,
-        pulse: yV,
-        touch: pV,
-        update: mV,
-        changeset: Tl,
-        ingest: KX,
-        parse: VX,
-        preload: QX,
-        request: JX,
-        events: XX,
-        on: tV,
-        evaluate: lV,
-        run: cV,
-        runAsync: uV,
-        runAfter: fV,
-        _enqueue: hV,
-        _getPulse: dV
-    };
+            function b(E, C) {
+                var k = kl([E, C]),
+                    A = e(E, C);
+                n(f, h, c, d, g, p, f = A[0], h = A[1], c = E, d = k[0], g = k[1], p = k[2], _T, i), i.point(f, h)
+            }
+
+            function x() {
+                m.point = y, i.lineEnd()
+            }
 
-    function L(e, t) {
-        it.call(this, e, null, t)
+            function _() {
+                v(), m.point = S, m.lineEnd = w
+            }
+
+            function S(E, C) {
+                b(r = E, C), s = f, a = h, o = d, l = g, u = p, m.point = b
+            }
+
+            function w() {
+                n(f, h, c, d, g, p, s, a, r, o, l, u, _T, i), m.lineEnd = x, x()
+            }
+            return m
+        }
     }
-    ee(L, it, {
-        run(e) {
-            if (e.stamp < this.stamp) return e.StopPropagation;
-            let t;
-            return this.skip() ? this.skip(!1) : t = this.evaluate(e), t = t || e, t.then ? t = t.then(n => this.pulse = n) : t !== e.StopPropagation && (this.pulse = t), t
-        },
-        evaluate(e) {
-            const t = this.marshall(e.stamp),
-                n = this.transform(t, e);
-            return t.clear(), n
-        },
-        transform() {}
+    var CJ = O1({
+        point: function(e, t) {
+            this.stream.point(e * Le, t * Le)
+        }
     });
-    const Uu = {};
 
-    function XD(e) {
-        const t = VD(e);
-        return t && t.Definition || null
+    function AJ(e) {
+        return O1({
+            point: function(t, n) {
+                var i = e(t, n);
+                return this.stream.point(i[0], i[1])
+            }
+        })
     }
 
-    function VD(e) {
-        return e = e && e.toLowerCase(), me(Uu, e) ? Uu[e] : null
+    function $J(e, t, n, i, r) {
+        function s(a, o) {
+            return a *= i, o *= r, [t + e * a, n - e * o]
+        }
+        return s.invert = function(a, o) {
+            return [(a - t) / e * i, (n - o) / e * r]
+        }, s
     }
 
-    function* KD(e, t) {
-        if (t == null)
-            for (let n of e) n != null && n !== "" && (n = +n) >= n && (yield n);
-        else {
-            let n = -1;
-            for (let i of e) i = t(i, ++n, e), i != null && i !== "" && (i = +i) >= i && (yield i)
+    function ST(e, t, n, i, r, s) {
+        if (!s) return $J(e, t, n, i, r);
+        var a = Me(s),
+            o = ke(s),
+            l = a * e,
+            u = o * e,
+            c = a / e,
+            f = o / e,
+            h = (o * n - a * t) / e,
+            d = (o * t + a * n) / e;
+
+        function g(p, m) {
+            return p *= i, m *= r, [l * p - u * m + t, n - u * p - l * m]
         }
+        return g.invert = function(p, m) {
+            return [i * (c * p - f * m + h), r * (d - f * p - c * m)]
+        }, g
     }
 
-    function A_(e, t, n) {
-        const i = Float64Array.from(KD(e, n));
-        return i.sort(Ts), t.map(r => IO(i, r))
+    function vs(e) {
+        return G4(function() {
+            return e
+        })()
     }
 
-    function $_(e, t) {
-        return A_(e, [.25, .5, .75], t)
-    }
+    function G4(e) {
+        var t, n = 150,
+            i = 480,
+            r = 250,
+            s = 0,
+            a = 0,
+            o = 0,
+            l = 0,
+            u = 0,
+            c, f = 0,
+            h = 1,
+            d = 1,
+            g = null,
+            p = uT,
+            m = null,
+            y, v, b, x = nd,
+            _ = .5,
+            S, w, E, C, k;
 
-    function T_(e, t) {
-        const n = e.length,
-            i = wj(e, t),
-            r = $_(e, t),
-            s = (r[2] - r[0]) / 1.34;
-        return 1.06 * (Math.min(i, s) || i || Math.abs(r[0]) || 1) * Math.pow(n, -.2)
-    }
+        function A(M) {
+            return E(M[0] * Le, M[1] * Le)
+        }
 
-    function JD(e) {
-        const t = e.maxbins || 20,
-            n = e.base || 10,
-            i = Math.log(n),
-            r = e.divide || [5, 2];
-        let s = e.extent[0],
-            a = e.extent[1],
-            o, l, u, c, f, h;
-        const d = e.span || a - s || Math.abs(s) || 1;
-        if (e.step) o = e.step;
-        else if (e.steps) {
-            for (c = d / t, f = 0, h = e.steps.length; f < h && e.steps[f] < c; ++f);
-            o = e.steps[Math.max(0, f - 1)]
-        } else {
-            for (l = Math.ceil(Math.log(t) / i), u = e.minstep || 0, o = Math.max(u, Math.pow(n, Math.round(Math.log(d) / i) - l)); Math.ceil(d / o) > t;) o *= n;
-            for (f = 0, h = r.length; f < h; ++f) c = o / r[f], c >= u && d / c <= t && (o = c)
+        function F(M) {
+            return M = E.invert(M[0], M[1]), M && [M[0] * Bt, M[1] * Bt]
         }
-        c = Math.log(o);
-        const g = c >= 0 ? 0 : ~~(-c / i) + 1,
-            p = Math.pow(n, -g - 1);
-        return (e.nice || e.nice === void 0) && (c = Math.floor(s / o + p) * o, s = s < c ? c - o : c, a = Math.ceil(a / o) * o), {
-            start: s,
-            stop: a === s ? s + o : a,
-            step: o
+        A.stream = function(M) {
+            return C && k === M ? C : C = CJ(AJ(c)(p(S(x(k = M)))))
+        }, A.preclip = function(M) {
+            return arguments.length ? (p = M, g = void 0, T()) : p
+        }, A.postclip = function(M) {
+            return arguments.length ? (x = M, m = y = v = b = null, T()) : x
+        }, A.clipAngle = function(M) {
+            return arguments.length ? (p = +M ? lJ(g = M * Le) : (g = null, uT), T()) : g * Bt
+        }, A.clipExtent = function(M) {
+            return arguments.length ? (x = M == null ? (m = y = v = b = null, nd) : T4(m = +M[0][0], y = +M[0][1], v = +M[1][0], b = +M[1][1]), T()) : m == null ? null : [
+                [m, y],
+                [v, b]
+            ]
+        }, A.scale = function(M) {
+            return arguments.length ? (n = +M, $()) : n
+        }, A.translate = function(M) {
+            return arguments.length ? (i = +M[0], r = +M[1], $()) : [i, r]
+        }, A.center = function(M) {
+            return arguments.length ? (s = M[0] % 360 * Le, a = M[1] % 360 * Le, $()) : [s * Bt, a * Bt]
+        }, A.rotate = function(M) {
+            return arguments.length ? (o = M[0] % 360 * Le, l = M[1] % 360 * Le, u = M.length > 2 ? M[2] % 360 * Le : 0, $()) : [o * Bt, l * Bt, u * Bt]
+        }, A.angle = function(M) {
+            return arguments.length ? (f = M % 360 * Le, $()) : f * Bt
+        }, A.reflectX = function(M) {
+            return arguments.length ? (h = M ? -1 : 1, $()) : h < 0
+        }, A.reflectY = function(M) {
+            return arguments.length ? (d = M ? -1 : 1, $()) : d < 0
+        }, A.precision = function(M) {
+            return arguments.length ? (S = wT(w, _ = M * M), T()) : Kn(_)
+        }, A.fitExtent = function(M, R) {
+            return F1(A, M, R)
+        }, A.fitSize = function(M, R) {
+            return HS(A, M, R)
+        }, A.fitWidth = function(M, R) {
+            return YS(A, M, R)
+        }, A.fitHeight = function(M, R) {
+            return XS(A, M, R)
+        };
+
+        function $() {
+            var M = ST(n, 0, 0, h, d, f).apply(null, t(s, a)),
+                R = ST(n, i - M[0], r - M[1], h, d, f);
+            return c = k4(o, l, u), w = D2(t, R), E = D2(c, w), S = wT(w, _), T()
+        }
+
+        function T() {
+            return C = k = null, A
+        }
+        return function() {
+            return t = e.apply(this, arguments), A.invert = t.invert && F, $()
         }
     }
-    var Ni = Math.random;
 
-    function xV(e) {
-        Ni = e
+    function VS(e) {
+        var t = 0,
+            n = Ie / 3,
+            i = G4(e),
+            r = i(t, n);
+        return r.parallels = function(s) {
+            return arguments.length ? i(t = s[0] * Le, n = s[1] * Le) : [t * Bt, n * Bt]
+        }, r
     }
 
-    function QD(e, t, n, i) {
-        if (!e.length) return [void 0, void 0];
-        const r = Float64Array.from(KD(e, i)),
-            s = r.length,
-            a = t;
-        let o, l, u, c;
-        for (u = 0, c = Array(a); u < a; ++u) {
-            for (o = 0, l = 0; l < s; ++l) o += r[~~(Ni() * s)];
-            c[u] = o / s
+    function TJ(e) {
+        var t = Me(e);
+
+        function n(i, r) {
+            return [i * t, ke(r) / t]
         }
-        return c.sort(Ts), [fb(c, n / 2), fb(c, 1 - n / 2)]
+        return n.invert = function(i, r) {
+            return [i / t, gi(r * t)]
+        }, n
     }
 
-    function ZD(e, t, n, i) {
-        i = i || (h => h);
-        const r = e.length,
-            s = new Float64Array(r);
-        let a = 0,
-            o = 1,
-            l = i(e[0]),
-            u = l,
-            c = l + t,
-            f;
-        for (; o < r; ++o) {
-            if (f = i(e[o]), f >= c) {
-                for (u = (l + u) / 2; a < o; ++a) s[a] = u;
-                c = f + t, l = f
-            }
-            u = f
+    function MJ(e, t) {
+        var n = ke(e),
+            i = (n + ke(t)) / 2;
+        if (Ge(i) < $e) return TJ(e);
+        var r = 1 + n * (2 * i - n),
+            s = Kn(r) / i;
+
+        function a(o, l) {
+            var u = Kn(r - 2 * i * ke(l)) / i;
+            return [u * ke(o *= i), s - u * Me(o)]
         }
-        for (u = (l + u) / 2; a < o; ++a) s[a] = u;
-        return n ? _V(s, t + t / 4) : s
+        return a.invert = function(o, l) {
+            var u = s - l,
+                c = Ki(o, Ge(u)) * ji(u);
+            return u * i < 0 && (c -= Ie * ji(o) * ji(u)), [c / i, gi((r - (o * o + u * u) * i * i) / (2 * i))]
+        }, a
     }
 
-    function _V(e, t) {
-        const n = e.length;
-        let i = 0,
-            r = 1,
-            s, a;
-        for (; e[i] === e[r];) ++r;
-        for (; r < n;) {
-            for (s = r + 1; e[r] === e[s];) ++s;
-            if (e[r] - e[r - 1] < t) {
-                for (a = r + (i + s - r - r >> 1); a < r;) e[a++] = e[r];
-                for (; a > r;) e[a--] = e[i]
-            }
-            i = r, r = s
-        }
-        return e
+    function Zm() {
+        return VS(MJ).scale(155.424).center([0, 33.6442])
     }
 
-    function wV(e) {
-        return function() {
-            return e = (1103515245 * e + 12345) % 2147483647, e / 2147483647
-        }
+    function U4() {
+        return Zm().parallels([29.5, 45.5]).scale(1070).translate([480, 250]).rotate([96, 0]).center([-.6, 38.7])
     }
 
-    function SV(e, t) {
-        t == null && (t = e, e = 0);
-        let n, i, r;
-        const s = {
-            min(a) {
-                return arguments.length ? (n = a || 0, r = i - n, s) : n
+    function OJ(e) {
+        var t = e.length;
+        return {
+            point: function(n, i) {
+                for (var r = -1; ++r < t;) e[r].point(n, i)
             },
-            max(a) {
-                return arguments.length ? (i = a || 0, r = i - n, s) : i
+            sphere: function() {
+                for (var n = -1; ++n < t;) e[n].sphere()
             },
-            sample() {
-                return n + Math.floor(r * Ni())
+            lineStart: function() {
+                for (var n = -1; ++n < t;) e[n].lineStart()
             },
-            pdf(a) {
-                return a === Math.floor(a) && a >= n && a < i ? 1 / r : 0
+            lineEnd: function() {
+                for (var n = -1; ++n < t;) e[n].lineEnd()
             },
-            cdf(a) {
-                const o = Math.floor(a);
-                return o < n ? 0 : o >= i ? 1 : (o - n + 1) / r
+            polygonStart: function() {
+                for (var n = -1; ++n < t;) e[n].polygonStart()
             },
-            icdf(a) {
-                return a >= 0 && a <= 1 ? n - 1 + Math.floor(a * r) : NaN
+            polygonEnd: function() {
+                for (var n = -1; ++n < t;) e[n].polygonEnd()
             }
-        };
-        return s.min(e).max(t)
+        }
     }
-    const eN = Math.sqrt(2 * Math.PI),
-        EV = Math.SQRT2;
-    let ef = NaN;
 
-    function Pm(e, t) {
-        e = e || 0, t = t ?? 1;
-        let n = 0,
-            i = 0,
-            r, s;
-        if (ef === ef) n = ef, ef = NaN;
-        else {
-            do n = Ni() * 2 - 1, i = Ni() * 2 - 1, r = n * n + i * i; while (r === 0 || r > 1);
-            s = Math.sqrt(-2 * Math.log(r) / r), n *= s, ef = i * s
+    function FJ() {
+        var e, t, n = U4(),
+            i, r = Zm().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]),
+            s, a = Zm().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]),
+            o, l, u = {
+                point: function(h, d) {
+                    l = [h, d]
+                }
+            };
+
+        function c(h) {
+            var d = h[0],
+                g = h[1];
+            return l = null, i.point(d, g), l || (s.point(d, g), l) || (o.point(d, g), l)
         }
-        return e + n * t
+        c.invert = function(h) {
+            var d = n.scale(),
+                g = n.translate(),
+                p = (h[0] - g[0]) / d,
+                m = (h[1] - g[1]) / d;
+            return (m >= .12 && m < .234 && p >= -.425 && p < -.214 ? r : m >= .166 && m < .234 && p >= -.214 && p < -.115 ? a : n).invert(h)
+        }, c.stream = function(h) {
+            return e && t === h ? e : e = OJ([n.stream(t = h), r.stream(h), a.stream(h)])
+        }, c.precision = function(h) {
+            return arguments.length ? (n.precision(h), r.precision(h), a.precision(h), f()) : n.precision()
+        }, c.scale = function(h) {
+            return arguments.length ? (n.scale(h), r.scale(h * .35), a.scale(h), c.translate(n.translate())) : n.scale()
+        }, c.translate = function(h) {
+            if (!arguments.length) return n.translate();
+            var d = n.scale(),
+                g = +h[0],
+                p = +h[1];
+            return i = n.translate(h).clipExtent([
+                [g - .455 * d, p - .238 * d],
+                [g + .455 * d, p + .238 * d]
+            ]).stream(u), s = r.translate([g - .307 * d, p + .201 * d]).clipExtent([
+                [g - .425 * d + $e, p + .12 * d + $e],
+                [g - .214 * d - $e, p + .234 * d - $e]
+            ]).stream(u), o = a.translate([g - .205 * d, p + .212 * d]).clipExtent([
+                [g - .214 * d + $e, p + .166 * d + $e],
+                [g - .115 * d - $e, p + .234 * d - $e]
+            ]).stream(u), f()
+        }, c.fitExtent = function(h, d) {
+            return F1(c, h, d)
+        }, c.fitSize = function(h, d) {
+            return HS(c, h, d)
+        }, c.fitWidth = function(h, d) {
+            return YS(c, h, d)
+        }, c.fitHeight = function(h, d) {
+            return XS(c, h, d)
+        };
+
+        function f() {
+            return e = t = null, c
+        }
+        return c.scale(1070)
     }
 
-    function M_(e, t, n) {
-        n = n ?? 1;
-        const i = (e - (t || 0)) / n;
-        return Math.exp(-.5 * i * i) / (n * eN)
+    function W4(e) {
+        return function(t, n) {
+            var i = Me(t),
+                r = Me(n),
+                s = e(i * r);
+            return s === 1 / 0 ? [2, 0] : [s * r * ke(t), s * ke(n)]
+        }
     }
 
-    function Lm(e, t, n) {
-        t = t || 0, n = n ?? 1;
-        const i = (e - t) / n,
-            r = Math.abs(i);
-        let s;
-        if (r > 37) s = 0;
-        else {
-            const a = Math.exp(-r * r / 2);
-            let o;
-            r < 7.07106781186547 ? (o = .0352624965998911 * r + .700383064443688, o = o * r + 6.37396220353165, o = o * r + 33.912866078383, o = o * r + 112.079291497871, o = o * r + 221.213596169931, o = o * r + 220.206867912376, s = a * o, o = .0883883476483184 * r + 1.75566716318264, o = o * r + 16.064177579207, o = o * r + 86.7807322029461, o = o * r + 296.564248779674, o = o * r + 637.333633378831, o = o * r + 793.826512519948, o = o * r + 440.413735824752, s = s / o) : (o = r + .65, o = r + 4 / o, o = r + 3 / o, o = r + 2 / o, o = r + 1 / o, s = a / o / 2.506628274631)
+    function Xd(e) {
+        return function(t, n) {
+            var i = Kn(t * t + n * n),
+                r = e(i),
+                s = ke(r),
+                a = Me(r);
+            return [Ki(t * s, i * a), gi(i && n * s / i)]
         }
-        return i > 0 ? 1 - s : s
     }
+    var q4 = W4(function(e) {
+        return Kn(2 / (1 + e))
+    });
+    q4.invert = Xd(function(e) {
+        return 2 * gi(e / 2)
+    });
 
-    function Im(e, t, n) {
-        return e < 0 || e > 1 ? NaN : (t || 0) + (n ?? 1) * EV * CV(2 * e - 1)
+    function RJ() {
+        return vs(q4).scale(124.75).clipAngle(180 - .001)
     }
+    var H4 = W4(function(e) {
+        return (e = g4(e)) && e / ke(e)
+    });
+    H4.invert = Xd(function(e) {
+        return e
+    });
 
-    function CV(e) {
-        let t = -Math.log((1 - e) * (1 + e)),
-            n;
-        return t < 6.25 ? (t -= 3.125, n = -364441206401782e-35, n = -16850591381820166e-35 + n * t, n = 128584807152564e-32 + n * t, n = 11157877678025181e-33 + n * t, n = -1333171662854621e-31 + n * t, n = 20972767875968562e-33 + n * t, n = 6637638134358324e-30 + n * t, n = -4054566272975207e-29 + n * t, n = -8151934197605472e-29 + n * t, n = 26335093153082323e-28 + n * t, n = -12975133253453532e-27 + n * t, n = -5415412054294628e-26 + n * t, n = 10512122733215323e-25 + n * t, n = -4112633980346984e-24 + n * t, n = -29070369957882005e-24 + n * t, n = 42347877827932404e-23 + n * t, n = -13654692000834679e-22 + n * t, n = -13882523362786469e-21 + n * t, n = .00018673420803405714 + n * t, n = -.000740702534166267 + n * t, n = -.006033670871430149 + n * t, n = .24015818242558962 + n * t, n = 1.6536545626831027 + n * t) : t < 16 ? (t = Math.sqrt(t) - 3.25, n = 22137376921775787e-25, n = 9075656193888539e-23 + n * t, n = -27517406297064545e-23 + n * t, n = 18239629214389228e-24 + n * t, n = 15027403968909828e-22 + n * t, n = -4013867526981546e-21 + n * t, n = 29234449089955446e-22 + n * t, n = 12475304481671779e-21 + n * t, n = -47318229009055734e-21 + n * t, n = 6828485145957318e-20 + n * t, n = 24031110387097894e-21 + n * t, n = -.0003550375203628475 + n * t, n = .0009532893797373805 + n * t, n = -.0016882755560235047 + n * t, n = .002491442096107851 + n * t, n = -.003751208507569241 + n * t, n = .005370914553590064 + n * t, n = 1.0052589676941592 + n * t, n = 3.0838856104922208 + n * t) : Number.isFinite(t) ? (t = Math.sqrt(t) - 5, n = -27109920616438573e-27, n = -2555641816996525e-25 + n * t, n = 15076572693500548e-25 + n * t, n = -3789465440126737e-24 + n * t, n = 761570120807834e-23 + n * t, n = -1496002662714924e-23 + n * t, n = 2914795345090108e-23 + n * t, n = -6771199775845234e-23 + n * t, n = 22900482228026655e-23 + n * t, n = -99298272942317e-20 + n * t, n = 4526062597223154e-21 + n * t, n = -1968177810553167e-20 + n * t, n = 7599527703001776e-20 + n * t, n = -.00021503011930044477 + n * t, n = -.00013871931833623122 + n * t, n = 1.0103004648645344 + n * t, n = 4.849906401408584 + n * t) : n = 1 / 0, n * e
+    function DJ() {
+        return vs(H4).scale(79.4188).clipAngle(180 - .001)
     }
 
-    function O_(e, t) {
-        let n, i;
-        const r = {
-            mean(s) {
-                return arguments.length ? (n = s || 0, r) : n
-            },
-            stdev(s) {
-                return arguments.length ? (i = s ?? 1, r) : i
-            },
-            sample: () => Pm(n, i),
-            pdf: s => M_(s, n, i),
-            cdf: s => Lm(s, n, i),
-            icdf: s => Im(s, n, i)
-        };
-        return r.mean(e).stdev(t)
+    function R1(e, t) {
+        return [e, Rm(US((Nt + t) / 2))]
     }
+    R1.invert = function(e, t) {
+        return [e, 2 * Qc(d4(t)) - Nt]
+    };
 
-    function F_(e, t) {
-        const n = O_();
-        let i = 0;
-        const r = {
-            data(s) {
-                return arguments.length ? (e = s, i = s ? s.length : 0, r.bandwidth(t)) : e
-            },
-            bandwidth(s) {
-                return arguments.length ? (t = s, !t && e && (t = T_(e)), r) : t
-            },
-            sample() {
-                return e[~~(Ni() * i)] + t * n.sample()
-            },
-            pdf(s) {
-                let a = 0,
-                    o = 0;
-                for (; o < i; ++o) a += n.pdf((s - e[o]) / t);
-                return a / t / i
-            },
-            cdf(s) {
-                let a = 0,
-                    o = 0;
-                for (; o < i; ++o) a += n.cdf((s - e[o]) / t);
-                return a / i
-            },
-            icdf() {
-                throw Error("KDE icdf not supported.")
-            }
-        };
-        return r.data(e)
-    }
-
-    function R_(e, t) {
-        return e = e || 0, t = t ?? 1, Math.exp(e + Pm() * t)
-    }
-
-    function D_(e, t, n) {
-        if (e <= 0) return 0;
-        t = t || 0, n = n ?? 1;
-        const i = (Math.log(e) - t) / n;
-        return Math.exp(-.5 * i * i) / (n * eN * e)
+    function NJ() {
+        return Y4(R1).scale(961 / Vn)
     }
 
-    function N_(e, t, n) {
-        return Lm(Math.log(e), t, n)
-    }
+    function Y4(e) {
+        var t = vs(e),
+            n = t.center,
+            i = t.scale,
+            r = t.translate,
+            s = t.clipExtent,
+            a = null,
+            o, l, u;
+        t.scale = function(f) {
+            return arguments.length ? (i(f), c()) : i()
+        }, t.translate = function(f) {
+            return arguments.length ? (r(f), c()) : r()
+        }, t.center = function(f) {
+            return arguments.length ? (n(f), c()) : n()
+        }, t.clipExtent = function(f) {
+            return arguments.length ? (f == null ? a = o = l = u = null : (a = +f[0][0], o = +f[0][1], l = +f[1][0], u = +f[1][1]), c()) : a == null ? null : [
+                [a, o],
+                [l, u]
+            ]
+        };
 
-    function P_(e, t, n) {
-        return Math.exp(Im(e, t, n))
+        function c() {
+            var f = Ie * i(),
+                h = t(eJ(t.rotate()).invert([0, 0]));
+            return s(a == null ? [
+                [h[0] - f, h[1] - f],
+                [h[0] + f, h[1] + f]
+            ] : e === R1 ? [
+                [Math.max(h[0] - f, a), o],
+                [Math.min(h[0] + f, l), u]
+            ] : [
+                [a, Math.max(h[1] - f, o)],
+                [l, Math.min(h[1] + f, u)]
+            ])
+        }
+        return c()
     }
 
-    function tN(e, t) {
-        let n, i;
-        const r = {
-            mean(s) {
-                return arguments.length ? (n = s || 0, r) : n
-            },
-            stdev(s) {
-                return arguments.length ? (i = s ?? 1, r) : i
-            },
-            sample: () => R_(n, i),
-            pdf: s => D_(s, n, i),
-            cdf: s => N_(s, n, i),
-            icdf: s => P_(s, n, i)
-        };
-        return r.mean(e).stdev(t)
+    function Ig(e) {
+        return US((Nt + e) / 2)
     }
 
-    function nN(e, t) {
-        let n = 0,
-            i;
+    function PJ(e, t) {
+        var n = Me(e),
+            i = e === t ? ke(e) : Rm(n / Me(t)) / Rm(Ig(t) / Ig(e)),
+            r = n * _v(Ig(e), i) / i;
+        if (!i) return R1;
 
-        function r(a) {
-            const o = [];
-            let l = 0,
-                u;
-            for (u = 0; u < n; ++u) l += o[u] = a[u] == null ? 1 : +a[u];
-            for (u = 0; u < n; ++u) o[u] /= l;
-            return o
+        function s(a, o) {
+            r > 0 ? o < -Nt + $e && (o = -Nt + $e) : o > Nt - $e && (o = Nt - $e);
+            var l = r / _v(Ig(o), i);
+            return [l * ke(i * a), r - l * Me(i * a)]
         }
-        const s = {
-            weights(a) {
-                return arguments.length ? (i = r(t = a || []), s) : t
-            },
-            distributions(a) {
-                return arguments.length ? (a ? (n = a.length, e = a) : (n = 0, e = []), s.weights(t)) : e
-            },
-            sample() {
-                const a = Ni();
-                let o = e[n - 1],
-                    l = i[0],
-                    u = 0;
-                for (; u < n - 1; l += i[++u])
-                    if (a < l) {
-                        o = e[u];
-                        break
-                    } return o.sample()
-            },
-            pdf(a) {
-                let o = 0,
-                    l = 0;
-                for (; l < n; ++l) o += i[l] * e[l].pdf(a);
-                return o
-            },
-            cdf(a) {
-                let o = 0,
-                    l = 0;
-                for (; l < n; ++l) o += i[l] * e[l].cdf(a);
-                return o
-            },
-            icdf() {
-                throw Error("Mixture icdf not supported.")
-            }
-        };
-        return s.distributions(e).weights(t)
+        return s.invert = function(a, o) {
+            var l = r - o,
+                u = ji(i) * Kn(a * a + l * l),
+                c = Ki(a, Ge(l)) * ji(l);
+            return l * i < 0 && (c -= Ie * ji(a) * ji(l)), [c / i, 2 * Qc(_v(r / u, 1 / i)) - Nt]
+        }, s
     }
 
-    function L_(e, t) {
-        return t == null && (t = e ?? 1, e = 0), e + (t - e) * Ni()
+    function LJ() {
+        return VS(PJ).scale(109.5).parallels([30, 30])
     }
 
-    function I_(e, t, n) {
-        return n == null && (n = t ?? 1, t = 0), e >= t && e <= n ? 1 / (n - t) : 0
+    function e0(e, t) {
+        return [e, t]
     }
+    e0.invert = e0;
 
-    function z_(e, t, n) {
-        return n == null && (n = t ?? 1, t = 0), e < t ? 0 : e > n ? 1 : (e - t) / (n - t)
+    function IJ() {
+        return vs(e0).scale(152.63)
     }
 
-    function B_(e, t, n) {
-        return n == null && (n = t ?? 1, t = 0), e >= 0 && e <= 1 ? t + e * (n - t) : NaN
-    }
+    function zJ(e, t) {
+        var n = Me(e),
+            i = e === t ? ke(e) : (n - Me(t)) / (t - e),
+            r = n / i + e;
+        if (Ge(i) < $e) return e0;
 
-    function iN(e, t) {
-        let n, i;
-        const r = {
-            min(s) {
-                return arguments.length ? (n = s || 0, r) : n
-            },
-            max(s) {
-                return arguments.length ? (i = s ?? 1, r) : i
-            },
-            sample: () => L_(n, i),
-            pdf: s => I_(s, n, i),
-            cdf: s => z_(s, n, i),
-            icdf: s => B_(s, n, i)
-        };
-        return t == null && (t = e ?? 1, e = 0), r.min(e).max(t)
+        function s(a, o) {
+            var l = r - o,
+                u = i * a;
+            return [l * ke(u), r - l * Me(u)]
+        }
+        return s.invert = function(a, o) {
+            var l = r - o,
+                u = Ki(a, Ge(l)) * ji(l);
+            return l * i < 0 && (u -= Ie * ji(a) * ji(l)), [u / i, r - ji(i) * Kn(a * a + l * l)]
+        }, s
     }
 
-    function j_(e, t, n) {
-        let i = 0,
-            r = 0;
-        for (const s of e) {
-            const a = n(s);
-            t(s) == null || a == null || isNaN(a) || (i += (a - i) / ++r)
-        }
-        return {
-            coef: [i],
-            predict: () => i,
-            rSquared: 0
-        }
+    function BJ() {
+        return VS(zJ).scale(131.154).center([0, 13.9389])
     }
+    var $h = 1.340264,
+        Th = -.081106,
+        Mh = 893e-6,
+        Oh = .003796,
+        t0 = Kn(3) / 2,
+        jJ = 12;
 
-    function od(e, t, n, i) {
-        const r = i - e * e,
-            s = Math.abs(r) < 1e-24 ? 0 : (n - e * t) / r;
-        return [t - s * e, s]
+    function X4(e, t) {
+        var n = gi(t0 * ke(t)),
+            i = n * n,
+            r = i * i * i;
+        return [e * Me(n) / (t0 * ($h + 3 * Th * i + r * (7 * Mh + 9 * Oh * i))), n * ($h + Th * i + r * (Mh + Oh * i))]
     }
+    X4.invert = function(e, t) {
+        for (var n = t, i = n * n, r = i * i * i, s = 0, a, o, l; s < jJ && (o = n * ($h + Th * i + r * (Mh + Oh * i)) - t, l = $h + 3 * Th * i + r * (7 * Mh + 9 * Oh * i), n -= a = o / l, i = n * n, r = i * i * i, !(Ge(a) < Om)); ++s);
+        return [t0 * e * ($h + 3 * Th * i + r * (7 * Mh + 9 * Oh * i)) / Me(n), gi(ke(n) / t0)]
+    };
 
-    function zm(e, t, n, i) {
-        e = e.filter(d => {
-            let g = t(d),
-                p = n(d);
-            return g != null && (g = +g) >= g && p != null && (p = +p) >= p
-        }), i && e.sort((d, g) => t(d) - t(g));
-        const r = e.length,
-            s = new Float64Array(r),
-            a = new Float64Array(r);
-        let o = 0,
-            l = 0,
-            u = 0,
-            c, f, h;
-        for (h of e) s[o] = c = +t(h), a[o] = f = +n(h), ++o, l += (c - l) / o, u += (f - u) / o;
-        for (o = 0; o < r; ++o) s[o] -= l, a[o] -= u;
-        return [s, a, l, u]
+    function GJ() {
+        return vs(X4).scale(177.158)
     }
 
-    function ld(e, t, n, i) {
-        let r = -1,
-            s, a;
-        for (const o of e) s = t(o), a = n(o), s != null && (s = +s) >= s && a != null && (a = +a) >= a && i(s, a, ++r)
+    function V4(e, t) {
+        var n = Me(t),
+            i = Me(e) * n;
+        return [n * ke(e) / i, ke(t) / i]
     }
+    V4.invert = Xd(Qc);
 
-    function Ec(e, t, n, i, r) {
-        let s = 0,
-            a = 0;
-        return ld(e, t, n, (o, l) => {
-            const u = l - r(o),
-                c = l - i;
-            s += u * u, a += c * c
-        }), 1 - s / a
+    function UJ() {
+        return vs(V4).scale(144.049).clipAngle(60)
     }
 
-    function U_(e, t, n) {
-        let i = 0,
-            r = 0,
+    function WJ() {
+        var e = 1,
+            t = 0,
+            n = 0,
+            i = 1,
+            r = 1,
             s = 0,
-            a = 0,
-            o = 0;
-        ld(e, t, n, (c, f) => {
-            ++o, i += (c - i) / o, r += (f - r) / o, s += (c * f - s) / o, a += (c * c - a) / o
-        });
-        const l = od(i, r, s, a),
-            u = c => l[0] + l[1] * c;
-        return {
-            coef: l,
-            predict: u,
-            rSquared: Ec(e, t, n, r, u)
+            a, o, l = null,
+            u, c, f, h = 1,
+            d = 1,
+            g = O1({
+                point: function(x, _) {
+                    var S = b([x, _]);
+                    this.stream.point(S[0], S[1])
+                }
+            }),
+            p = nd,
+            m, y;
+
+        function v() {
+            return h = e * i, d = e * r, m = y = null, b
         }
-    }
 
-    function rN(e, t, n) {
-        let i = 0,
-            r = 0,
-            s = 0,
-            a = 0,
-            o = 0;
-        ld(e, t, n, (c, f) => {
-            ++o, c = Math.log(c), i += (c - i) / o, r += (f - r) / o, s += (c * f - s) / o, a += (c * c - a) / o
-        });
-        const l = od(i, r, s, a),
-            u = c => l[0] + l[1] * Math.log(c);
-        return {
-            coef: l,
-            predict: u,
-            rSquared: Ec(e, t, n, r, u)
+        function b(x) {
+            var _ = x[0] * h,
+                S = x[1] * d;
+            if (s) {
+                var w = S * a - _ * o;
+                _ = _ * a + S * o, S = w
+            }
+            return [_ + t, S + n]
         }
+        return b.invert = function(x) {
+            var _ = x[0] - t,
+                S = x[1] - n;
+            if (s) {
+                var w = S * a + _ * o;
+                _ = _ * a - S * o, S = w
+            }
+            return [_ / h, S / d]
+        }, b.stream = function(x) {
+            return m && y === x ? m : m = g(p(y = x))
+        }, b.postclip = function(x) {
+            return arguments.length ? (p = x, l = u = c = f = null, v()) : p
+        }, b.clipExtent = function(x) {
+            return arguments.length ? (p = x == null ? (l = u = c = f = null, nd) : T4(l = +x[0][0], u = +x[0][1], c = +x[1][0], f = +x[1][1]), v()) : l == null ? null : [
+                [l, u],
+                [c, f]
+            ]
+        }, b.scale = function(x) {
+            return arguments.length ? (e = +x, v()) : e
+        }, b.translate = function(x) {
+            return arguments.length ? (t = +x[0], n = +x[1], v()) : [t, n]
+        }, b.angle = function(x) {
+            return arguments.length ? (s = x % 360 * Le, o = ke(s), a = Me(s), v()) : s * Bt
+        }, b.reflectX = function(x) {
+            return arguments.length ? (i = x ? -1 : 1, v()) : i < 0
+        }, b.reflectY = function(x) {
+            return arguments.length ? (r = x ? -1 : 1, v()) : r < 0
+        }, b.fitExtent = function(x, _) {
+            return F1(b, x, _)
+        }, b.fitSize = function(x, _) {
+            return HS(b, x, _)
+        }, b.fitWidth = function(x, _) {
+            return YS(b, x, _)
+        }, b.fitHeight = function(x, _) {
+            return XS(b, x, _)
+        }, b
     }
 
-    function sN(e, t, n) {
-        const [i, r, s, a] = zm(e, t, n);
-        let o = 0,
-            l = 0,
-            u = 0,
-            c = 0,
-            f = 0,
-            h, d, g;
-        ld(e, t, n, (v, b) => {
-            h = i[f++], d = Math.log(b), g = h * b, o += (b * d - o) / f, l += (g - l) / f, u += (g * d - u) / f, c += (h * g - c) / f
-        });
-        const [p, m] = od(l / a, o / a, u / a, c / a), y = v => Math.exp(p + m * (v - s));
-        return {
-            coef: [Math.exp(p - m * s), m],
-            predict: y,
-            rSquared: Ec(e, t, n, a, y)
-        }
+    function K4(e, t) {
+        var n = t * t,
+            i = n * n;
+        return [e * (.8707 - .131979 * n + i * (-.013791 + i * (.003971 * n - .001529 * i))), t * (1.007226 + n * (.015085 + i * (-.044475 + .028874 * n - .005916 * i)))]
     }
+    K4.invert = function(e, t) {
+        var n = t,
+            i = 25,
+            r;
+        do {
+            var s = n * n,
+                a = s * s;
+            n -= r = (n * (1.007226 + s * (.015085 + a * (-.044475 + .028874 * s - .005916 * a))) - t) / (1.007226 + s * (.015085 * 3 + a * (-.044475 * 7 + .028874 * 9 * s - .005916 * 11 * a)))
+        } while (Ge(r) > $e && --i > 0);
+        return [e / (.8707 + (s = n * n) * (-.131979 + s * (-.013791 + s * s * s * (.003971 - .001529 * s)))), n]
+    };
 
-    function aN(e, t, n) {
-        let i = 0,
-            r = 0,
-            s = 0,
-            a = 0,
-            o = 0,
-            l = 0;
-        ld(e, t, n, (f, h) => {
-            const d = Math.log(f),
-                g = Math.log(h);
-            ++l, i += (d - i) / l, r += (g - r) / l, s += (d * g - s) / l, a += (d * d - a) / l, o += (h - o) / l
-        });
-        const u = od(i, r, s, a),
-            c = f => u[0] * Math.pow(f, u[1]);
-        return u[0] = Math.exp(u[0]), {
-            coef: u,
-            predict: c,
-            rSquared: Ec(e, t, n, o, c)
-        }
+    function qJ() {
+        return vs(K4).scale(175.295)
     }
 
-    function G_(e, t, n) {
-        const [i, r, s, a] = zm(e, t, n), o = i.length;
-        let l = 0,
-            u = 0,
-            c = 0,
-            f = 0,
-            h = 0,
-            d, g, p, m;
-        for (d = 0; d < o;) g = i[d], p = r[d++], m = g * g, l += (m - l) / d, u += (m * g - u) / d, c += (m * m - c) / d, f += (g * p - f) / d, h += (m * p - h) / d;
-        const y = c - l * l,
-            v = l * y - u * u,
-            b = (h * l - f * u) / v,
-            x = (f * y - h * u) / v,
-            _ = -b * l,
-            S = w => (w = w - s, b * w * w + x * w + _ + a);
-        return {
-            coef: [_ - x * s + b * s * s + a, x - 2 * b * s, b],
-            predict: S,
-            rSquared: Ec(e, t, n, a, S)
-        }
+    function J4(e, t) {
+        return [Me(t) * ke(e), ke(t)]
     }
+    J4.invert = Xd(gi);
 
-    function oN(e, t, n, i) {
-        if (i === 0) return j_(e, t, n);
-        if (i === 1) return U_(e, t, n);
-        if (i === 2) return G_(e, t, n);
-        const [r, s, a, o] = zm(e, t, n), l = r.length, u = [], c = [], f = i + 1;
-        let h, d, g, p, m;
-        for (h = 0; h < f; ++h) {
-            for (g = 0, p = 0; g < l; ++g) p += Math.pow(r[g], h) * s[g];
-            for (u.push(p), m = new Float64Array(f), d = 0; d < f; ++d) {
-                for (g = 0, p = 0; g < l; ++g) p += Math.pow(r[g], h + d);
-                m[d] = p
-            }
-            c.push(m)
-        }
-        c.push(u);
-        const y = AV(c),
-            v = b => {
-                b -= a;
-                let x = o + y[0] + y[1] * b + y[2] * b * b;
-                for (h = 3; h < f; ++h) x += y[h] * Math.pow(b, h);
-                return x
-            };
-        return {
-            coef: kV(f, y, -a, o),
-            predict: v,
-            rSquared: Ec(e, t, n, o, v)
-        }
+    function HJ() {
+        return vs(J4).scale(249.5).clipAngle(90 + $e)
     }
 
-    function kV(e, t, n, i) {
-        const r = Array(e);
-        let s, a, o, l;
-        for (s = 0; s < e; ++s) r[s] = 0;
-        for (s = e - 1; s >= 0; --s)
-            for (o = t[s], l = 1, r[s] += o, a = 1; a <= s; ++a) l *= (s + 1 - a) / a, r[s - a] += o * Math.pow(n, a) * l;
-        return r[0] += i, r
+    function Q4(e, t) {
+        var n = Me(t),
+            i = 1 + Me(e) * n;
+        return [n * ke(e) / i, ke(t) / i]
     }
+    Q4.invert = Xd(function(e) {
+        return 2 * Qc(e)
+    });
 
-    function AV(e) {
-        const t = e.length - 1,
-            n = [];
-        let i, r, s, a, o;
-        for (i = 0; i < t; ++i) {
-            for (a = i, r = i + 1; r < t; ++r) Math.abs(e[i][r]) > Math.abs(e[i][a]) && (a = r);
-            for (s = i; s < t + 1; ++s) o = e[s][i], e[s][i] = e[s][a], e[s][a] = o;
-            for (r = i + 1; r < t; ++r)
-                for (s = t; s >= i; s--) e[s][r] -= e[s][i] * e[i][r] / e[i][i]
-        }
-        for (r = t - 1; r >= 0; --r) {
-            for (o = 0, s = r + 1; s < t; ++s) o += e[s][r] * n[s];
-            n[r] = (e[t][r] - o) / e[r][r]
-        }
-        return n
+    function YJ() {
+        return vs(Q4).scale(250).clipAngle(142)
     }
-    const R$ = 2,
-        D$ = 1e-12;
 
-    function lN(e, t, n, i) {
-        const [r, s, a, o] = zm(e, t, n, !0), l = r.length, u = Math.max(2, ~~(i * l)), c = new Float64Array(l), f = new Float64Array(l), h = new Float64Array(l).fill(1);
-        for (let d = -1; ++d <= R$;) {
-            const g = [0, u - 1];
-            for (let m = 0; m < l; ++m) {
-                const y = r[m],
-                    v = g[0],
-                    b = g[1],
-                    x = y - r[v] > r[b] - y ? v : b;
-                let _ = 0,
-                    S = 0,
-                    w = 0,
-                    E = 0,
-                    A = 0;
-                const C = 1 / Math.abs(r[x] - y || 1);
-                for (let $ = v; $ <= b; ++$) {
-                    const T = r[$],
-                        M = s[$],
-                        F = $V(Math.abs(y - T) * C) * h[$],
-                        N = T * F;
-                    _ += F, S += N, w += M * F, E += M * N, A += T * N
-                }
-                const [k, R] = od(S / _, w / _, E / _, A / _);
-                c[m] = k + R * y, f[m] = Math.abs(s[m] - c[m]), TV(r, m + 1, g)
-            }
-            if (d === R$) break;
-            const p = zO(f);
-            if (Math.abs(p) < D$) break;
-            for (let m = 0, y, v; m < l; ++m) y = f[m] / (6 * p), h[m] = y >= 1 ? D$ : (v = 1 - y * y) * v
-        }
-        return MV(r, c, a, o)
+    function Z4(e, t) {
+        return [Rm(US((Nt + t) / 2)), -e]
     }
+    Z4.invert = function(e, t) {
+        return [-t, 2 * Qc(d4(e)) - Nt]
+    };
 
-    function $V(e) {
-        return (e = 1 - e * e * e) * e * e
+    function XJ() {
+        var e = Y4(Z4),
+            t = e.center,
+            n = e.rotate;
+        return e.center = function(i) {
+            return arguments.length ? t([-i[1], i[0]]) : (i = t(), [i[1], -i[0]])
+        }, e.rotate = function(i) {
+            return arguments.length ? n([i[0], i[1], i.length > 2 ? i[2] + 90 : 90]) : (i = n(), [i[0], i[1], i[2] - 90])
+        }, n([0, 0, 90]).scale(159.155)
     }
+    var VJ = Math.abs,
+        q2 = Math.cos,
+        n0 = Math.sin,
+        KJ = 1e-6,
+        eL = Math.PI,
+        H2 = eL / 2,
+        ET = JJ(2);
 
-    function TV(e, t, n) {
-        const i = e[t];
-        let r = n[0],
-            s = n[1] + 1;
-        if (!(s >= e.length))
-            for (; t > r && e[s] - i <= i - e[r];) n[0] = ++r, n[1] = s, ++s
+    function kT(e) {
+        return e > 1 ? H2 : e < -1 ? -H2 : Math.asin(e)
     }
 
-    function MV(e, t, n, i) {
-        const r = e.length,
-            s = [];
-        let a = 0,
-            o = 0,
-            l = [],
-            u;
-        for (; a < r; ++a) u = e[a] + n, l[0] === u ? l[1] += (t[a] - l[1]) / ++o : (o = 0, l[1] += i, l = [u, t[a]], s.push(l));
-        return l[1] += i, s
+    function JJ(e) {
+        return e > 0 ? Math.sqrt(e) : 0
     }
-    const OV = .5 * Math.PI / 180;
 
-    function Bm(e, t, n, i) {
-        n = n || 25, i = Math.max(n, i || 200);
-        const r = p => [p, e(p)],
-            s = t[0],
-            a = t[1],
-            o = a - s,
-            l = o / i,
-            u = [r(s)],
-            c = [];
-        if (n === i) {
-            for (let p = 1; p < i; ++p) u.push(r(s + p / n * o));
-            return u.push(r(a)), u
-        } else {
-            c.push(r(a));
-            for (let p = n; --p > 0;) c.push(r(s + p / n * o))
-        }
-        let f = u[0],
-            h = c[c.length - 1];
-        const d = 1 / o,
-            g = FV(f[1], c);
-        for (; h;) {
-            const p = r((f[0] + h[0]) / 2);
-            p[0] - f[0] >= l && RV(f, p, h, d, g) > OV ? c.push(p) : (f = h, u.push(h), c.pop()), h = c[c.length - 1]
-        }
-        return u
+    function QJ(e, t) {
+        var n = e * n0(t),
+            i = 30,
+            r;
+        do t -= r = (t + n0(t) - n) / (1 + q2(t)); while (VJ(r) > KJ && --i > 0);
+        return t / 2
     }
 
-    function FV(e, t) {
-        let n = e,
-            i = e;
-        const r = t.length;
-        for (let s = 0; s < r; ++s) {
-            const a = t[s][1];
-            a < n && (n = a), a > i && (i = a)
+    function ZJ(e, t, n) {
+        function i(r, s) {
+            return [e * r * q2(s = QJ(n, s)), t * n0(s)]
         }
-        return 1 / (i - n)
+        return i.invert = function(r, s) {
+            return s = kT(s / t), [r / (e * q2(s)), kT((2 * s + n0(2 * s)) / n)]
+        }, i
     }
+    var eQ = ZJ(ET / H2, ET, eL);
 
-    function RV(e, t, n, i, r) {
-        const s = Math.atan2(r * (n[1] - e[1]), i * (n[0] - e[0])),
-            a = Math.atan2(r * (t[1] - e[1]), i * (t[0] - e[0]));
-        return Math.abs(s - a)
+    function tQ() {
+        return vs(eQ).scale(169.529)
     }
+    const nQ = j4(),
+        Y2 = ["clipAngle", "clipExtent", "scale", "translate", "center", "rotate", "parallels", "precision", "reflectX", "reflectY", "coefficient", "distance", "fraction", "lobes", "parallel", "radius", "ratio", "spacing", "tilt"];
 
-    function DV(e) {
-        return t => {
-            const n = e.length;
-            let i = 1,
-                r = String(e[0](t));
-            for (; i < n; ++i) r += "|" + e[i](t);
-            return r
+    function iQ(e, t) {
+        return function n() {
+            const i = t();
+            return i.type = e, i.path = j4().projection(i), i.copy = i.copy || function() {
+                const r = n();
+                return Y2.forEach(s => {
+                    i[s] && r[s](i[s]())
+                }), r.path.pointRadius(i.path.pointRadius()), r
+            }, wN(i)
         }
     }
 
-    function e2(e) {
-        return !e || !e.length ? function() {
-            return ""
-        } : e.length === 1 ? e[0] : DV(e)
+    function KS(e, t) {
+        if (!e || typeof e != "string") throw new Error("Projection type must be a name string.");
+        return e = e.toLowerCase(), arguments.length > 1 ? (i0[e] = iQ(e, t), this) : i0[e] || null
     }
 
-    function uN(e, t, n) {
-        return n || e + (t ? "_" + t : "")
+    function tL(e) {
+        return e && e.path || nQ
     }
-    const Vy = () => {},
-        NV = {
-            init: Vy,
-            add: Vy,
-            rem: Vy,
-            idx: 0
-        },
-        Eh = {
-            values: {
-                init: e => e.cell.store = !0,
-                value: e => e.cell.data.values(),
-                idx: -1
-            },
-            count: {
-                value: e => e.cell.num
-            },
-            __count__: {
-                value: e => e.missing + e.valid
-            },
-            missing: {
-                value: e => e.missing
-            },
-            valid: {
-                value: e => e.valid
-            },
-            sum: {
-                init: e => e.sum = 0,
-                value: e => e.sum,
-                add: (e, t) => e.sum += +t,
-                rem: (e, t) => e.sum -= t
-            },
-            product: {
-                init: e => e.product = 1,
-                value: e => e.valid ? e.product : void 0,
-                add: (e, t) => e.product *= t,
-                rem: (e, t) => e.product /= t
-            },
-            mean: {
-                init: e => e.mean = 0,
-                value: e => e.valid ? e.mean : void 0,
-                add: (e, t) => (e.mean_d = t - e.mean, e.mean += e.mean_d / e.valid),
-                rem: (e, t) => (e.mean_d = t - e.mean, e.mean -= e.valid ? e.mean_d / e.valid : e.mean)
-            },
-            average: {
-                value: e => e.valid ? e.mean : void 0,
-                req: ["mean"],
-                idx: 1
-            },
-            variance: {
-                init: e => e.dev = 0,
-                value: e => e.valid > 1 ? e.dev / (e.valid - 1) : void 0,
-                add: (e, t) => e.dev += e.mean_d * (t - e.mean),
-                rem: (e, t) => e.dev -= e.mean_d * (t - e.mean),
-                req: ["mean"],
-                idx: 1
-            },
-            variancep: {
-                value: e => e.valid > 1 ? e.dev / e.valid : void 0,
-                req: ["variance"],
-                idx: 2
-            },
-            stdev: {
-                value: e => e.valid > 1 ? Math.sqrt(e.dev / (e.valid - 1)) : void 0,
-                req: ["variance"],
-                idx: 2
-            },
-            stdevp: {
-                value: e => e.valid > 1 ? Math.sqrt(e.dev / e.valid) : void 0,
-                req: ["variance"],
-                idx: 2
-            },
-            stderr: {
-                value: e => e.valid > 1 ? Math.sqrt(e.dev / (e.valid * (e.valid - 1))) : void 0,
-                req: ["variance"],
-                idx: 2
-            },
-            distinct: {
-                value: e => e.cell.data.distinct(e.get),
-                req: ["values"],
-                idx: 3
-            },
-            ci0: {
-                value: e => e.cell.data.ci0(e.get),
-                req: ["values"],
-                idx: 3
-            },
-            ci1: {
-                value: e => e.cell.data.ci1(e.get),
-                req: ["values"],
-                idx: 3
-            },
-            median: {
-                value: e => e.cell.data.q2(e.get),
-                req: ["values"],
-                idx: 3
-            },
-            q1: {
-                value: e => e.cell.data.q1(e.get),
-                req: ["values"],
-                idx: 3
-            },
-            q3: {
-                value: e => e.cell.data.q3(e.get),
-                req: ["values"],
-                idx: 3
-            },
-            min: {
-                init: e => e.min = void 0,
-                value: e => e.min = Number.isNaN(e.min) ? e.cell.data.min(e.get) : e.min,
-                add: (e, t) => {
-                    (t < e.min || e.min === void 0) && (e.min = t)
-                },
-                rem: (e, t) => {
-                    t <= e.min && (e.min = NaN)
-                },
-                req: ["values"],
-                idx: 4
-            },
-            max: {
-                init: e => e.max = void 0,
-                value: e => e.max = Number.isNaN(e.max) ? e.cell.data.max(e.get) : e.max,
-                add: (e, t) => {
-                    (t > e.max || e.max === void 0) && (e.max = t)
-                },
-                rem: (e, t) => {
-                    t >= e.max && (e.max = NaN)
-                },
-                req: ["values"],
-                idx: 4
-            },
-            argmin: {
-                init: e => e.argmin = void 0,
-                value: e => e.argmin || e.cell.data.argmin(e.get),
-                add: (e, t, n) => {
-                    t < e.min && (e.argmin = n)
-                },
-                rem: (e, t) => {
-                    t <= e.min && (e.argmin = void 0)
-                },
-                req: ["min", "values"],
-                idx: 3
-            },
-            argmax: {
-                init: e => e.argmax = void 0,
-                value: e => e.argmax || e.cell.data.argmax(e.get),
-                add: (e, t, n) => {
-                    t > e.max && (e.argmax = n)
-                },
-                rem: (e, t) => {
-                    t >= e.max && (e.argmax = void 0)
-                },
-                req: ["max", "values"],
-                idx: 3
+    const i0 = {
+        albers: U4,
+        albersusa: FJ,
+        azimuthalequalarea: RJ,
+        azimuthalequidistant: DJ,
+        conicconformal: LJ,
+        conicequalarea: Zm,
+        conicequidistant: BJ,
+        equalEarth: GJ,
+        equirectangular: IJ,
+        gnomonic: UJ,
+        identity: WJ,
+        mercator: NJ,
+        mollweide: tQ,
+        naturalEarth1: qJ,
+        orthographic: HJ,
+        stereographic: YJ,
+        transversemercator: XJ
+    };
+    for (const e in i0) KS(e, i0[e]);
+
+    function rQ() {}
+    const Ms = [
+        [],
+        [
+            [
+                [1, 1.5],
+                [.5, 1]
+            ]
+        ],
+        [
+            [
+                [1.5, 1],
+                [1, 1.5]
+            ]
+        ],
+        [
+            [
+                [1.5, 1],
+                [.5, 1]
+            ]
+        ],
+        [
+            [
+                [1, .5],
+                [1.5, 1]
+            ]
+        ],
+        [
+            [
+                [1, 1.5],
+                [.5, 1]
+            ],
+            [
+                [1, .5],
+                [1.5, 1]
+            ]
+        ],
+        [
+            [
+                [1, .5],
+                [1, 1.5]
+            ]
+        ],
+        [
+            [
+                [1, .5],
+                [.5, 1]
+            ]
+        ],
+        [
+            [
+                [.5, 1],
+                [1, .5]
+            ]
+        ],
+        [
+            [
+                [1, 1.5],
+                [1, .5]
+            ]
+        ],
+        [
+            [
+                [.5, 1],
+                [1, .5]
+            ],
+            [
+                [1.5, 1],
+                [1, 1.5]
+            ]
+        ],
+        [
+            [
+                [1.5, 1],
+                [1, .5]
+            ]
+        ],
+        [
+            [
+                [.5, 1],
+                [1.5, 1]
+            ]
+        ],
+        [
+            [
+                [1, 1.5],
+                [1.5, 1]
+            ]
+        ],
+        [
+            [
+                [.5, 1],
+                [1, 1.5]
+            ]
+        ],
+        []
+    ];
+
+    function nL() {
+        var e = 1,
+            t = 1,
+            n = o;
+
+        function i(l, u) {
+            return u.map(c => r(l, c))
+        }
+
+        function r(l, u) {
+            var c = [],
+                f = [];
+            return s(l, u, h => {
+                n(h, l, u), sQ(h) > 0 ? c.push([h]) : f.push(h)
+            }), f.forEach(h => {
+                for (var d = 0, g = c.length, p; d < g; ++d)
+                    if (aQ((p = c[d])[0], h) !== -1) {
+                        p.push(h);
+                        return
+                    }
+            }), {
+                type: "MultiPolygon",
+                value: u,
+                coordinates: c
             }
-        },
-        ud = Object.keys(Eh).filter(e => e !== "__count__");
+        }
 
-    function PV(e, t) {
-        return n => Ae({
-            name: e,
-            out: n || e
-        }, NV, t)
-    } [...ud, "__count__"].forEach(e => {
-        Eh[e] = PV(e, Eh[e])
-    });
+        function s(l, u, c) {
+            var f = new Array,
+                h = new Array,
+                d, g, p, m, y, v;
+            for (d = g = -1, m = l[0] >= u, Ms[m << 1].forEach(b); ++d < e - 1;) p = m, m = l[d + 1] >= u, Ms[p | m << 1].forEach(b);
+            for (Ms[m << 0].forEach(b); ++g < t - 1;) {
+                for (d = -1, m = l[g * e + e] >= u, y = l[g * e] >= u, Ms[m << 1 | y << 2].forEach(b); ++d < e - 1;) p = m, m = l[g * e + e + d + 1] >= u, v = y, y = l[g * e + d + 1] >= u, Ms[p | m << 1 | y << 2 | v << 3].forEach(b);
+                Ms[m | y << 3].forEach(b)
+            }
+            for (d = -1, y = l[g * e] >= u, Ms[y << 2].forEach(b); ++d < e - 1;) v = y, y = l[g * e + d + 1] >= u, Ms[y << 2 | v << 3].forEach(b);
+            Ms[y << 3].forEach(b);
 
-    function cN(e, t) {
-        return Eh[e](t)
-    }
+            function b(x) {
+                var _ = [x[0][0] + d, x[0][1] + g],
+                    S = [x[1][0] + d, x[1][1] + g],
+                    w = a(_),
+                    E = a(S),
+                    C, k;
+                (C = h[w]) ? (k = f[E]) ? (delete h[C.end], delete f[k.start], C === k ? (C.ring.push(S), c(C.ring)) : f[C.start] = h[k.end] = {
+                    start: C.start,
+                    end: k.end,
+                    ring: C.ring.concat(k.ring)
+                }) : (delete h[C.end], C.ring.push(S), h[C.end = E] = C) : (C = f[E]) ? (k = h[w]) ? (delete f[C.start], delete h[k.end], C === k ? (C.ring.push(S), c(C.ring)) : f[k.start] = h[C.end] = {
+                    start: k.start,
+                    end: C.end,
+                    ring: k.ring.concat(C.ring)
+                }) : (delete f[C.start], C.ring.unshift(_), f[C.start = w] = C) : f[w] = h[E] = {
+                    start: w,
+                    end: E,
+                    ring: [_, S]
+                }
+            }
+        }
 
-    function fN(e, t) {
-        return e.idx - t.idx
-    }
+        function a(l) {
+            return l[0] * 2 + l[1] * (e + 1) * 4
+        }
 
-    function LV(e) {
-        const t = {};
-        e.forEach(i => t[i.name] = i);
-        const n = i => {
-            i.req && i.req.forEach(r => {
-                t[r] || n(t[r] = Eh[r]())
+        function o(l, u, c) {
+            l.forEach(f => {
+                var h = f[0],
+                    d = f[1],
+                    g = h | 0,
+                    p = d | 0,
+                    m, y = u[p * e + g];
+                h > 0 && h < e && g === h && (m = u[p * e + g - 1], f[0] = h + (c - m) / (y - m) - .5), d > 0 && d < t && p === d && (m = u[(p - 1) * e + g], f[1] = d + (c - m) / (y - m) - .5)
             })
-        };
-        return e.forEach(n), Object.values(t).sort(fN)
+        }
+        return i.contour = r, i.size = function(l) {
+            if (!arguments.length) return [e, t];
+            var u = Math.floor(l[0]),
+                c = Math.floor(l[1]);
+            return u >= 0 && c >= 0 || q("invalid size"), e = u, t = c, i
+        }, i.smooth = function(l) {
+            return arguments.length ? (n = l ? o : rQ, i) : n === o
+        }, i
     }
 
-    function IV() {
-        this.valid = 0, this.missing = 0, this._ops.forEach(e => e.init(this))
+    function sQ(e) {
+        for (var t = 0, n = e.length, i = e[n - 1][1] * e[0][0] - e[n - 1][0] * e[0][1]; ++t < n;) i += e[t - 1][1] * e[t][0] - e[t - 1][0] * e[t][1];
+        return i
     }
 
-    function zV(e, t) {
-        if (e == null || e === "") {
-            ++this.missing;
-            return
-        }
-        e === e && (++this.valid, this._ops.forEach(n => n.add(this, e, t)))
+    function aQ(e, t) {
+        for (var n = -1, i = t.length, r; ++n < i;)
+            if (r = oQ(e, t[n])) return r;
+        return 0
     }
 
-    function BV(e, t) {
-        if (e == null || e === "") {
-            --this.missing;
-            return
+    function oQ(e, t) {
+        for (var n = t[0], i = t[1], r = -1, s = 0, a = e.length, o = a - 1; s < a; o = s++) {
+            var l = e[s],
+                u = l[0],
+                c = l[1],
+                f = e[o],
+                h = f[0],
+                d = f[1];
+            if (lQ(l, f, t)) return 0;
+            c > i != d > i && n < (h - u) * (i - c) / (d - c) + u && (r = -r)
         }
-        e === e && (--this.valid, this._ops.forEach(n => n.rem(this, e, t)))
+        return r
     }
 
-    function jV(e) {
-        return this._out.forEach(t => e[t.out] = t.value(this)), e
+    function lQ(e, t, n) {
+        var i;
+        return uQ(e, t, n) && cQ(e[i = +(e[0] === t[0])], n[i], t[i])
     }
 
-    function hN(e, t) {
-        const n = t || bn,
-            i = LV(e),
-            r = e.slice().sort(fN);
-
-        function s(a) {
-            this._ops = i, this._out = r, this.cell = a, this.init()
-        }
-        return s.prototype.init = IV, s.prototype.add = zV, s.prototype.rem = BV, s.prototype.set = jV, s.prototype.get = n, s.fields = e.map(a => a.out), s
+    function uQ(e, t, n) {
+        return (t[0] - e[0]) * (n[1] - e[1]) === (n[0] - e[0]) * (t[1] - e[1])
     }
 
-    function W_(e) {
-        this._key = e ? ni(e) : ge, this.reset()
+    function cQ(e, t, n) {
+        return e <= t && t <= n || n <= t && t <= e
     }
-    const nn = W_.prototype;
-    nn.reset = function() {
-        this._add = [], this._rem = [], this._ext = null, this._get = null, this._q = null
-    };
-    nn.add = function(e) {
-        this._add.push(e)
-    };
-    nn.rem = function(e) {
-        this._rem.push(e)
-    };
-    nn.values = function() {
-        if (this._get = null, this._rem.length === 0) return this._add;
-        const e = this._add,
-            t = this._rem,
-            n = this._key,
-            i = e.length,
-            r = t.length,
-            s = Array(i - r),
-            a = {};
-        let o, l, u;
-        for (o = 0; o < r; ++o) a[n(t[o])] = 1;
-        for (o = 0, l = 0; o < i; ++o) a[n(u = e[o])] ? a[n(u)] = 0 : s[l++] = u;
-        return this._rem = [], this._add = s
-    };
-    nn.distinct = function(e) {
-        const t = this.values(),
-            n = {};
-        let i = t.length,
-            r = 0,
-            s;
-        for (; --i >= 0;) s = e(t[i]) + "", me(n, s) || (n[s] = 1, ++r);
-        return r
-    };
-    nn.extent = function(e) {
-        if (this._get !== e || !this._ext) {
-            const t = this.values(),
-                n = eD(t, e);
-            this._ext = [t[n[0]], t[n[1]]], this._get = e
+
+    function iL(e, t, n) {
+        return function(i) {
+            var r = ss(i),
+                s = n ? Math.min(r[0], 0) : r[0],
+                a = r[1],
+                o = a - s,
+                l = t ? Qa(s, a, e) : o / (e + 1);
+            return $i(s + l, a, l)
         }
-        return this._ext
-    };
-    nn.argmin = function(e) {
-        return this.extent(e)[0] || {}
-    };
-    nn.argmax = function(e) {
-        return this.extent(e)[1] || {}
-    };
-    nn.min = function(e) {
-        const t = this.extent(e)[0];
-        return t != null ? e(t) : void 0
-    };
-    nn.max = function(e) {
-        const t = this.extent(e)[1];
-        return t != null ? e(t) : void 0
-    };
-    nn.quartile = function(e) {
-        return (this._get !== e || !this._q) && (this._q = $_(this.values(), e), this._get = e), this._q
-    };
-    nn.q1 = function(e) {
-        return this.quartile(e)[0]
-    };
-    nn.q2 = function(e) {
-        return this.quartile(e)[1]
-    };
-    nn.q3 = function(e) {
-        return this.quartile(e)[2]
-    };
-    nn.ci = function(e) {
-        return (this._get !== e || !this._ci) && (this._ci = QD(this.values(), 1e3, .05, e), this._get = e), this._ci
-    };
-    nn.ci0 = function(e) {
-        return this.ci(e)[0]
-    };
-    nn.ci1 = function(e) {
-        return this.ci(e)[1]
-    };
+    }
 
-    function Ra(e) {
-        L.call(this, null, e), this._adds = [], this._mods = [], this._alen = 0, this._mlen = 0, this._drop = !0, this._cross = !1, this._dims = [], this._dnames = [], this._measures = [], this._countOnly = !1, this._counts = null, this._prev = null, this._inputs = null, this._outputs = null
+    function JS(e) {
+        j.call(this, null, e)
     }
-    Ra.Definition = {
-        type: "Aggregate",
+    JS.Definition = {
+        type: "Isocontour",
         metadata: {
-            generates: !0,
-            changes: !0
+            generates: !0
         },
         params: [{
-            name: "groupby",
-            type: "field",
-            array: !0
-        }, {
-            name: "ops",
-            type: "enum",
-            array: !0,
-            values: ud
-        }, {
-            name: "fields",
-            type: "field",
-            null: !0,
-            array: !0
+            name: "field",
+            type: "field"
         }, {
-            name: "as",
-            type: "string",
-            null: !0,
+            name: "thresholds",
+            type: "number",
             array: !0
         }, {
-            name: "drop",
-            type: "boolean",
-            default: !0
+            name: "levels",
+            type: "number"
         }, {
-            name: "cross",
+            name: "nice",
             type: "boolean",
             default: !1
         }, {
-            name: "key",
-            type: "field"
-        }]
-    };
-    ee(Ra, L, {
-        transform(e, t) {
-            const n = this,
-                i = t.fork(t.NO_SOURCE | t.NO_FIELDS),
-                r = e.modified();
-            return n.stamp = i.stamp, n.value && (r || t.modified(n._inputs, !0)) ? (n._prev = n.value, n.value = r ? n.init(e) : Object.create(null), t.visit(t.SOURCE, s => n.add(s))) : (n.value = n.value || n.init(e), t.visit(t.REM, s => n.rem(s)), t.visit(t.ADD, s => n.add(s))), i.modifies(n._outputs), n._drop = e.drop !== !1, e.cross && n._dims.length > 1 && (n._drop = !1, n.cross()), t.clean() && n._drop && i.clean(!0).runAfter(() => this.clean()), n.changes(i)
-        },
-        cross() {
-            const e = this,
-                t = e.value,
-                n = e._dnames,
-                i = n.map(() => ({})),
-                r = n.length;
-
-            function s(o) {
-                let l, u, c, f;
-                for (l in o)
-                    for (c = o[l].tuple, u = 0; u < r; ++u) i[u][f = c[n[u]]] = f
-            }
-            s(e._prev), s(t);
-
-            function a(o, l, u) {
-                const c = n[u],
-                    f = i[u++];
-                for (const h in f) {
-                    const d = o ? o + "|" + h : h;
-                    l[c] = f[h], u < r ? a(d, l, u) : t[d] || e.cell(d, l)
-                }
-            }
-            a("", {}, 0)
-        },
-        init(e) {
-            const t = this._inputs = [],
-                n = this._outputs = [],
-                i = {};
-
-            function r(m) {
-                const y = se(pn(m)),
-                    v = y.length;
-                let b = 0,
-                    x;
-                for (; b < v; ++b) i[x = y[b]] || (i[x] = 1, t.push(x))
-            }
-            this._dims = se(e.groupby), this._dnames = this._dims.map(m => {
-                const y = bt(m);
-                return r(m), n.push(y), y
-            }), this.cellkey = e.key ? e.key : e2(this._dims), this._countOnly = !0, this._counts = [], this._measures = [];
-            const s = e.fields || [null],
-                a = e.ops || ["count"],
-                o = e.as || [],
-                l = s.length,
-                u = {};
-            let c, f, h, d, g, p;
-            for (l !== a.length && U("Unmatched number of fields and aggregate ops."), p = 0; p < l; ++p) {
-                if (c = s[p], f = a[p], c == null && f !== "count" && U("Null aggregate field specified."), d = bt(c), g = uN(f, d, o[p]), n.push(g), f === "count") {
-                    this._counts.push(g);
-                    continue
-                }
-                h = u[d], h || (r(c), h = u[d] = [], h.field = c, this._measures.push(h)), f !== "count" && (this._countOnly = !1), h.push(cN(f, g))
-            }
-            return this._measures = this._measures.map(m => hN(m, m.field)), Object.create(null)
-        },
-        cellkey: e2(),
-        cell(e, t) {
-            let n = this.value[e];
-            return n ? n.num === 0 && this._drop && n.stamp < this.stamp ? (n.stamp = this.stamp, this._adds[this._alen++] = n) : n.stamp < this.stamp && (n.stamp = this.stamp, this._mods[this._mlen++] = n) : (n = this.value[e] = this.newcell(e, t), this._adds[this._alen++] = n), n
-        },
-        newcell(e, t) {
-            const n = {
-                key: e,
-                num: 0,
-                agg: null,
-                tuple: this.newtuple(t, this._prev && this._prev[e]),
-                stamp: this.stamp,
-                store: !1
-            };
-            if (!this._countOnly) {
-                const i = this._measures,
-                    r = i.length;
-                n.agg = Array(r);
-                for (let s = 0; s < r; ++s) n.agg[s] = new i[s](n)
-            }
-            return n.store && (n.data = new W_), n
-        },
-        newtuple(e, t) {
-            const n = this._dnames,
-                i = this._dims,
-                r = i.length,
-                s = {};
-            for (let a = 0; a < r; ++a) s[n[a]] = i[a](e);
-            return t ? WD(t.tuple, s) : He(s)
-        },
-        clean() {
-            const e = this.value;
-            for (const t in e) e[t].num === 0 && delete e[t]
-        },
-        add(e) {
-            const t = this.cellkey(e),
-                n = this.cell(t, e);
-            if (n.num += 1, this._countOnly) return;
-            n.store && n.data.add(e);
-            const i = n.agg;
-            for (let r = 0, s = i.length; r < s; ++r) i[r].add(i[r].get(e), e)
-        },
-        rem(e) {
-            const t = this.cellkey(e),
-                n = this.cell(t, e);
-            if (n.num -= 1, this._countOnly) return;
-            n.store && n.data.rem(e);
-            const i = n.agg;
-            for (let r = 0, s = i.length; r < s; ++r) i[r].rem(i[r].get(e), e)
-        },
-        celltuple(e) {
-            const t = e.tuple,
-                n = this._counts;
-            e.store && e.data.values();
-            for (let i = 0, r = n.length; i < r; ++i) t[n[i]] = e.num;
-            if (!this._countOnly) {
-                const i = e.agg;
-                for (let r = 0, s = i.length; r < s; ++r) i[r].set(t)
-            }
-            return t
-        },
-        changes(e) {
-            const t = this._adds,
-                n = this._mods,
-                i = this._prev,
-                r = this._drop,
-                s = e.add,
-                a = e.rem,
-                o = e.mod;
-            let l, u, c, f;
-            if (i)
-                for (u in i) l = i[u], (!r || l.num) && a.push(l.tuple);
-            for (c = 0, f = this._alen; c < f; ++c) s.push(this.celltuple(t[c])), t[c] = null;
-            for (c = 0, f = this._mlen; c < f; ++c) l = n[c], (l.num === 0 && r ? a : o).push(this.celltuple(l)), n[c] = null;
-            return this._alen = this._mlen = 0, this._prev = null, e
-        }
-    });
-    const UV = 1e-14;
-
-    function q_(e) {
-        L.call(this, null, e)
-    }
-    q_.Definition = {
-        type: "Bin",
-        metadata: {
-            modifies: !0
-        },
-        params: [{
-            name: "field",
-            type: "field",
-            required: !0
+            name: "resolve",
+            type: "enum",
+            values: ["shared", "independent"],
+            default: "independent"
         }, {
-            name: "interval",
+            name: "zero",
             type: "boolean",
             default: !0
         }, {
-            name: "anchor",
-            type: "number"
-        }, {
-            name: "maxbins",
-            type: "number",
-            default: 20
-        }, {
-            name: "base",
-            type: "number",
-            default: 10
+            name: "smooth",
+            type: "boolean",
+            default: !0
         }, {
-            name: "divide",
+            name: "scale",
             type: "number",
-            array: !0,
-            default: [5, 2]
+            expr: !0
         }, {
-            name: "extent",
+            name: "translate",
             type: "number",
             array: !0,
-            length: 2,
-            required: !0
-        }, {
-            name: "span",
-            type: "number"
-        }, {
-            name: "step",
-            type: "number"
-        }, {
-            name: "steps",
-            type: "number",
-            array: !0
-        }, {
-            name: "minstep",
-            type: "number",
-            default: 0
-        }, {
-            name: "nice",
-            type: "boolean",
-            default: !0
-        }, {
-            name: "name",
-            type: "string"
+            expr: !0
         }, {
             name: "as",
             type: "string",
-            array: !0,
-            length: 2,
-            default: ["bin0", "bin1"]
+            null: !0,
+            default: "contour"
         }]
     };
-    ee(q_, L, {
+    ne(JS, j, {
         transform(e, t) {
-            const n = e.interval !== !1,
-                i = this._bins(e),
-                r = i.start,
-                s = i.step,
-                a = e.as || ["bin0", "bin1"],
-                o = a[0],
-                l = a[1];
-            let u;
-            return e.modified() ? (t = t.reflow(!0), u = t.SOURCE) : u = t.modified(pn(e.field)) ? t.ADD_MOD : t.ADD, t.visit(u, n ? c => {
-                const f = i(c);
-                c[o] = f, c[l] = f == null ? null : r + s * (1 + (f - r) / s)
-            } : c => c[o] = i(c)), t.modifies(n ? a : o)
-        },
-        _bins(e) {
-            if (this.value && !e.modified()) return this.value;
-            const t = e.field,
-                n = JD(e),
-                i = n.step;
-            let r = n.start,
-                s = r + Math.ceil((n.stop - r) / i) * i,
-                a, o;
-            (a = e.anchor) != null && (o = a - (r + i * Math.floor((a - r) / i)), r += o, s += o);
-            const l = function(u) {
-                let c = hn(t(u));
-                return c == null ? null : c < r ? -1 / 0 : c > s ? 1 / 0 : (c = Math.max(r, Math.min(c, s - i)), r + i * Math.floor(UV + (c - r) / i))
-            };
-            return l.start = r, l.stop = n.stop, l.step = i, this.value = li(l, pn(t), e.name || "bin_" + bt(t))
+            if (this.value && !t.changed() && !e.modified()) return t.StopPropagation;
+            var n = t.fork(t.NO_SOURCE | t.NO_FIELDS),
+                i = t.materialize(t.SOURCE).source,
+                r = e.field || Pn,
+                s = nL().smooth(e.smooth !== !1),
+                a = e.thresholds || fQ(i, r, e),
+                o = e.as === null ? null : e.as || "contour",
+                l = [];
+            return i.forEach(u => {
+                const c = r(u),
+                    f = s.size([c.width, c.height])(c.values, H(a) ? a : a(c.values));
+                hQ(f, c, u, e), f.forEach(h => {
+                    l.push(V0(u, it(o != null ? {
+                        [o]: h
+                    } : h)))
+                })
+            }), this.value && (n.rem = this.value), this.value = n.source = n.add = l, n
         }
     });
 
-    function dN(e, t, n) {
-        const i = e;
-        let r = t || [],
-            s = n || [],
-            a = {},
-            o = 0;
-        return {
-            add: l => s.push(l),
-            remove: l => a[i(l)] = ++o,
-            size: () => r.length,
-            data: (l, u) => (o && (r = r.filter(c => !a[i(c)]), a = {}, o = 0), u && l && r.sort(l), s.length && (r = l ? aD(l, r, s.sort(l)) : r.concat(s), s = []), r)
-        }
+    function fQ(e, t, n) {
+        const i = iL(n.levels || 10, n.nice, n.zero !== !1);
+        return n.resolve !== "shared" ? i : i(e.map(r => cl(t(r).values)))
     }
 
-    function H_(e) {
-        L.call(this, [], e)
+    function hQ(e, t, n, i) {
+        let r = i.scale || t.scale,
+            s = i.translate || t.translate;
+        if (Pe(r) && (r = r(n, i)), Pe(s) && (s = s(n, i)), (r === 1 || r == null) && !s) return;
+        const a = (lt(r) ? r : r[0]) || 1,
+            o = (lt(r) ? r : r[1]) || 1,
+            l = s && s[0] || 0,
+            u = s && s[1] || 0;
+        e.forEach(rL(t, a, o, l, u))
     }
-    H_.Definition = {
-        type: "Collect",
-        metadata: {
-            source: !0
-        },
-        params: [{
-            name: "sort",
-            type: "compare"
-        }]
-    };
-    ee(H_, L, {
-        transform(e, t) {
-            const n = t.fork(t.ALL),
-                i = dN(ge, this.value, n.materialize(n.ADD).add),
-                r = e.sort,
-                s = t.changed() || r && (e.modified("sort") || t.modified(r.fields));
-            return n.visit(n.REM, i.remove), this.modified(s), this.value = n.source = i.data($l(r), s), t.source && t.source.root && (this.value.root = t.source.root), n
+
+    function rL(e, t, n, i, r) {
+        const s = e.x1 || 0,
+            a = e.y1 || 0,
+            o = t * n < 0;
+
+        function l(f) {
+            f.forEach(u)
+        }
+
+        function u(f) {
+            o && f.reverse(), f.forEach(c)
         }
-    });
 
-    function gN(e) {
-        it.call(this, null, GV, e)
+        function c(f) {
+            f[0] = (f[0] - s) * t + i, f[1] = (f[1] - a) * n + r
+        }
+        return function(f) {
+            return f.coordinates.forEach(l), f
+        }
     }
-    ee(gN, it);
 
-    function GV(e) {
-        return this.value && !e.modified() ? this.value : f_(e.fields, e.orders)
+    function CT(e, t, n) {
+        const i = e >= 0 ? e : j_(t, n);
+        return Math.round((Math.sqrt(4 * i * i + 1) - 1) / 2)
     }
 
-    function Y_(e) {
-        L.call(this, null, e)
+    function Cv(e) {
+        return Pe(e) ? e : Ln(+e)
     }
-    Y_.Definition = {
-        type: "CountPattern",
-        metadata: {
-            generates: !0,
-            changes: !0
-        },
-        params: [{
-            name: "field",
-            type: "field",
-            required: !0
-        }, {
-            name: "case",
-            type: "enum",
-            values: ["upper", "lower", "mixed"],
-            default: "mixed"
-        }, {
-            name: "pattern",
-            type: "string",
-            default: '[\\w"]+'
-        }, {
-            name: "stopwords",
-            type: "string",
-            default: ""
-        }, {
-            name: "as",
-            type: "string",
-            array: !0,
-            length: 2,
-            default: ["text", "count"]
-        }]
-    };
 
-    function WV(e, t, n) {
-        switch (t) {
-            case "upper":
-                e = e.toUpperCase();
-                break;
-            case "lower":
-                e = e.toLowerCase();
-                break
+    function sL() {
+        var e = l => l[0],
+            t = l => l[1],
+            n = Bc,
+            i = [-1, -1],
+            r = 960,
+            s = 500,
+            a = 2;
+
+        function o(l, u) {
+            const c = CT(i[0], l, e) >> a,
+                f = CT(i[1], l, t) >> a,
+                h = c ? c + 2 : 0,
+                d = f ? f + 2 : 0,
+                g = 2 * h + (r >> a),
+                p = 2 * d + (s >> a),
+                m = new Float32Array(g * p),
+                y = new Float32Array(g * p);
+            let v = m;
+            l.forEach(x => {
+                const _ = h + (+e(x) >> a),
+                    S = d + (+t(x) >> a);
+                _ >= 0 && _ < g && S >= 0 && S < p && (m[_ + S * g] += +n(x))
+            }), c > 0 && f > 0 ? (bu(g, p, m, y, c), xu(g, p, y, m, f), bu(g, p, m, y, c), xu(g, p, y, m, f), bu(g, p, m, y, c), xu(g, p, y, m, f)) : c > 0 ? (bu(g, p, m, y, c), bu(g, p, y, m, c), bu(g, p, m, y, c), v = y) : f > 0 && (xu(g, p, m, y, f), xu(g, p, y, m, f), xu(g, p, m, y, f), v = y);
+            const b = u ? Math.pow(2, -2 * a) : 1 / CF(v);
+            for (let x = 0, _ = g * p; x < _; ++x) v[x] *= b;
+            return {
+                values: v,
+                scale: 1 << a,
+                width: g,
+                height: p,
+                x1: h,
+                y1: d,
+                x2: h + (r >> a),
+                y2: d + (s >> a)
+            }
         }
-        return e.match(n)
+        return o.x = function(l) {
+            return arguments.length ? (e = Cv(l), o) : e
+        }, o.y = function(l) {
+            return arguments.length ? (t = Cv(l), o) : t
+        }, o.weight = function(l) {
+            return arguments.length ? (n = Cv(l), o) : n
+        }, o.size = function(l) {
+            if (!arguments.length) return [r, s];
+            var u = +l[0],
+                c = +l[1];
+            return u >= 0 && c >= 0 || q("invalid size"), r = u, s = c, o
+        }, o.cellSize = function(l) {
+            return arguments.length ? ((l = +l) >= 1 || q("invalid cell size"), a = Math.floor(Math.log(l) / Math.LN2), o) : 1 << a
+        }, o.bandwidth = function(l) {
+            return arguments.length ? (l = ue(l), l.length === 1 && (l = [+l[0], +l[0]]), l.length !== 2 && q("invalid bandwidth"), i = l, o) : i
+        }, o
     }
-    ee(Y_, L, {
-        transform(e, t) {
-            const n = f => h => {
-                    for (var d = WV(o(h), e.case, s) || [], g, p = 0, m = d.length; p < m; ++p) a.test(g = d[p]) || f(g)
-                },
-                i = this._parameterCheck(e, t),
-                r = this._counts,
-                s = this._match,
-                a = this._stop,
-                o = e.field,
-                l = e.as || ["text", "count"],
-                u = n(f => r[f] = 1 + (r[f] || 0)),
-                c = n(f => r[f] -= 1);
-            return i ? t.visit(t.SOURCE, u) : (t.visit(t.ADD, u), t.visit(t.REM, c)), this._finish(t, l)
-        },
-        _parameterCheck(e, t) {
-            let n = !1;
-            return (e.modified("stopwords") || !this._stop) && (this._stop = new RegExp("^" + (e.stopwords || "") + "$", "i"), n = !0), (e.modified("pattern") || !this._match) && (this._match = new RegExp(e.pattern || "[\\w']+", "g"), n = !0), (e.modified("field") || t.modified(e.field.fields)) && (n = !0), n && (this._counts = {}), n
-        },
-        _finish(e, t) {
-            const n = this._counts,
-                i = this._tuples || (this._tuples = {}),
-                r = t[0],
-                s = t[1],
-                a = e.fork(e.NO_SOURCE | e.NO_FIELDS);
-            let o, l, u;
-            for (o in n) l = i[o], u = n[o] || 0, !l && u ? (i[o] = l = He({}), l[r] = o, l[s] = u, a.add.push(l)) : u === 0 ? (l && a.rem.push(l), n[o] = null, i[o] = null) : l[s] !== u && (l[s] = u, a.mod.push(l));
-            return a.modifies(t)
-        }
-    });
 
-    function X_(e) {
-        L.call(this, null, e)
+    function bu(e, t, n, i, r) {
+        const s = (r << 1) + 1;
+        for (let a = 0; a < t; ++a)
+            for (let o = 0, l = 0; o < e + r; ++o) o < e && (l += n[o + a * e]), o >= r && (o >= s && (l -= n[o - s + a * e]), i[o - r + a * e] = l / Math.min(o + 1, e - 1 + s - o, s))
     }
-    X_.Definition = {
-        type: "Cross",
-        metadata: {
-            generates: !0
-        },
-        params: [{
-            name: "filter",
-            type: "expr"
-        }, {
-            name: "as",
-            type: "string",
-            array: !0,
-            length: 2,
-            default: ["a", "b"]
-        }]
-    };
-    ee(X_, L, {
-        transform(e, t) {
-            const n = t.fork(t.NO_SOURCE),
-                i = e.as || ["a", "b"],
-                r = i[0],
-                s = i[1],
-                a = !this.value || t.changed(t.ADD_REM) || e.modified("as") || e.modified("filter");
-            let o = this.value;
-            return a ? (o && (n.rem = o), o = t.materialize(t.SOURCE).source, n.add = this.value = qV(o, r, s, e.filter || Ri)) : n.mod = o, n.source = this.value, n.modifies(i)
-        }
-    });
 
-    function qV(e, t, n, i) {
-        for (var r = [], s = {}, a = e.length, o = 0, l, u; o < a; ++o)
-            for (s[t] = u = e[o], l = 0; l < a; ++l) s[n] = e[l], i(s) && (r.push(He(s)), s = {}, s[t] = u);
-        return r
-    }
-    const N$ = {
-            kde: F_,
-            mixture: nN,
-            normal: O_,
-            lognormal: tN,
-            uniform: iN
-        },
-        HV = "distributions",
-        P$ = "function",
-        YV = "field";
-
-    function pN(e, t) {
-        const n = e[P$];
-        me(N$, n) || U("Unknown distribution function: " + n);
-        const i = N$[n]();
-        for (const r in e) r === YV ? i.data((e.from || t()).map(e[r])) : r === HV ? i[r](e[r].map(s => pN(s, t))) : typeof i[r] === P$ && i[r](e[r]);
-        return i
+    function xu(e, t, n, i, r) {
+        const s = (r << 1) + 1;
+        for (let a = 0; a < e; ++a)
+            for (let o = 0, l = 0; o < t + r; ++o) o < t && (l += n[a + o * e]), o >= r && (o >= s && (l -= n[a + (o - s) * e]), i[a + (o - r) * e] = l / Math.min(o + 1, t - 1 + s - o, s))
     }
 
-    function V_(e) {
-        L.call(this, null, e)
+    function QS(e) {
+        j.call(this, null, e)
     }
-    const mN = [{
-            key: {
-                function: "normal"
-            },
-            params: [{
-                name: "mean",
-                type: "number",
-                default: 0
-            }, {
-                name: "stdev",
-                type: "number",
-                default: 1
-            }]
-        }, {
-            key: {
-                function: "lognormal"
-            },
-            params: [{
-                name: "mean",
-                type: "number",
-                default: 0
-            }, {
-                name: "stdev",
-                type: "number",
-                default: 1
-            }]
-        }, {
-            key: {
-                function: "uniform"
-            },
-            params: [{
-                name: "min",
-                type: "number",
-                default: 0
-            }, {
-                name: "max",
-                type: "number",
-                default: 1
-            }]
-        }, {
-            key: {
-                function: "kde"
-            },
-            params: [{
-                name: "field",
-                type: "field",
-                required: !0
-            }, {
-                name: "from",
-                type: "data"
-            }, {
-                name: "bandwidth",
-                type: "number",
-                default: 0
-            }]
-        }],
-        XV = {
-            key: {
-                function: "mixture"
-            },
-            params: [{
-                name: "distributions",
-                type: "param",
-                array: !0,
-                params: mN
-            }, {
-                name: "weights",
-                type: "number",
-                array: !0
-            }]
-        };
-    V_.Definition = {
-        type: "Density",
+    QS.Definition = {
+        type: "KDE2D",
         metadata: {
             generates: !0
         },
         params: [{
-            name: "extent",
+            name: "size",
             type: "number",
             array: !0,
-            length: 2
+            length: 2,
+            required: !0
         }, {
-            name: "steps",
-            type: "number"
+            name: "x",
+            type: "field",
+            required: !0
         }, {
-            name: "minsteps",
-            type: "number",
-            default: 25
+            name: "y",
+            type: "field",
+            required: !0
         }, {
-            name: "maxsteps",
-            type: "number",
-            default: 200
+            name: "weight",
+            type: "field"
         }, {
-            name: "method",
-            type: "string",
-            default: "pdf",
-            values: ["pdf", "cdf"]
+            name: "groupby",
+            type: "field",
+            array: !0
         }, {
-            name: "distribution",
-            type: "param",
-            params: mN.concat(XV)
+            name: "cellSize",
+            type: "number"
+        }, {
+            name: "bandwidth",
+            type: "number",
+            array: !0,
+            length: 2
+        }, {
+            name: "counts",
+            type: "boolean",
+            default: !1
         }, {
             name: "as",
             type: "string",
-            array: !0,
-            default: ["value", "density"]
+            default: "grid"
         }]
     };
-    ee(V_, L, {
+    const dQ = ["x", "y", "weight", "size", "cellSize", "bandwidth"];
+
+    function aL(e, t) {
+        return dQ.forEach(n => t[n] != null ? e[n](t[n]) : 0), e
+    }
+    ne(QS, j, {
         transform(e, t) {
-            const n = t.fork(t.NO_SOURCE | t.NO_FIELDS);
-            if (!this.value || t.changed() || e.modified()) {
-                const i = pN(e.distribution, VV(t)),
-                    r = e.steps || e.minsteps || 25,
-                    s = e.steps || e.maxsteps || 200;
-                let a = e.method || "pdf";
-                a !== "pdf" && a !== "cdf" && U("Invalid density method: " + a), !e.extent && !i.data && U("Missing density extent parameter."), a = i[a];
-                const o = e.as || ["value", "density"],
-                    l = e.extent || Hr(i.data()),
-                    u = Bm(a, l, r, s).map(c => {
-                        const f = {};
-                        return f[o[0]] = c[0], f[o[1]] = c[1], He(f)
-                    });
-                this.value && (n.rem = this.value), this.value = n.add = n.source = u
+            if (this.value && !t.changed() && !e.modified()) return t.StopPropagation;
+            var n = t.fork(t.NO_SOURCE | t.NO_FIELDS),
+                i = t.materialize(t.SOURCE).source,
+                r = gQ(i, e.groupby),
+                s = (e.groupby || []).map(Pt),
+                a = aL(sL(), e),
+                o = e.as || "grid",
+                l = [];
+
+            function u(c, f) {
+                for (let h = 0; h < s.length; ++h) c[s[h]] = f[h];
+                return c
             }
-            return n
+            return l = r.map(c => it(u({
+                [o]: a(c, e.counts)
+            }, c.dims))), this.value && (n.rem = this.value), this.value = n.source = n.add = l, n
         }
     });
 
-    function VV(e) {
-        return () => e.materialize(e.SOURCE).source
-    }
-
-    function yN(e, t) {
-        return e ? e.map((n, i) => t[i] || bt(n)) : null
-    }
-
-    function K_(e, t, n) {
-        const i = [],
-            r = f => f(l);
-        let s, a, o, l, u, c;
-        if (t == null) i.push(e.map(n));
+    function gQ(e, t) {
+        var n = [],
+            i = c => c(o),
+            r, s, a, o, l, u;
+        if (t == null) n.push(e);
         else
-            for (s = {}, a = 0, o = e.length; a < o; ++a) l = e[a], u = t.map(r), c = s[u], c || (s[u] = c = [], c.dims = u, i.push(c)), c.push(n(l));
-        return i
+            for (r = {}, s = 0, a = e.length; s < a; ++s) o = e[s], l = t.map(i), u = r[l], u || (r[l] = u = [], u.dims = l, n.push(u)), u.push(o);
+        return n
     }
-    const vN = "bin";
 
-    function J_(e) {
-        L.call(this, null, e)
+    function ZS(e) {
+        j.call(this, null, e)
     }
-    J_.Definition = {
-        type: "DotBin",
+    ZS.Definition = {
+        type: "Contour",
         metadata: {
-            modifies: !0
+            generates: !0
         },
         params: [{
-            name: "field",
-            type: "field",
+            name: "size",
+            type: "number",
+            array: !0,
+            length: 2,
             required: !0
         }, {
-            name: "groupby",
-            type: "field",
+            name: "values",
+            type: "number",
             array: !0
         }, {
-            name: "step",
+            name: "x",
+            type: "field"
+        }, {
+            name: "y",
+            type: "field"
+        }, {
+            name: "weight",
+            type: "field"
+        }, {
+            name: "cellSize",
             type: "number"
         }, {
-            name: "smooth",
+            name: "bandwidth",
+            type: "number"
+        }, {
+            name: "count",
+            type: "number"
+        }, {
+            name: "nice",
             type: "boolean",
             default: !1
         }, {
-            name: "as",
-            type: "string",
-            default: vN
+            name: "thresholds",
+            type: "number",
+            array: !0
+        }, {
+            name: "smooth",
+            type: "boolean",
+            default: !0
         }]
     };
-    const KV = (e, t) => ad(Hr(e, t)) / 30;
-    ee(J_, L, {
+    ne(ZS, j, {
         transform(e, t) {
-            if (this.value && !(e.modified() || t.changed())) return t;
-            const n = t.materialize(t.SOURCE).source,
-                i = K_(t.source, e.groupby, bn),
-                r = e.smooth || !1,
-                s = e.field,
-                a = e.step || KV(n, s),
-                o = $l((g, p) => s(g) - s(p)),
-                l = e.as || vN,
-                u = i.length;
-            let c = 1 / 0,
-                f = -1 / 0,
-                h = 0,
-                d;
-            for (; h < u; ++h) {
-                const g = i[h].sort(o);
-                d = -1;
-                for (const p of ZD(g, a, r, s)) p < c && (c = p), p > f && (f = p), g[++d][l] = p
-            }
-            return this.value = {
-                start: c,
-                stop: f,
-                step: a
-            }, t.reflow(!0).modifies(l)
+            if (this.value && !t.changed() && !e.modified()) return t.StopPropagation;
+            var n = t.fork(t.NO_SOURCE | t.NO_FIELDS),
+                i = nL().smooth(e.smooth !== !1),
+                r = e.values,
+                s = e.thresholds || iL(e.count || 10, e.nice, !!r),
+                a = e.size,
+                o, l;
+            return r || (r = t.materialize(t.SOURCE).source, o = aL(sL(), e)(r, !0), l = rL(o, o.scale || 1, o.scale || 1, 0, 0), a = [o.width, o.height], r = o.values), s = H(s) ? s : s(r), r = i.size(a)(r, s), l && r.forEach(l), this.value && (n.rem = this.value), this.value = n.source = n.add = (r || []).map(it), n
         }
     });
+    const X2 = "Feature",
+        eE = "FeatureCollection",
+        pQ = "MultiPoint";
 
-    function bN(e) {
-        it.call(this, null, JV, e), this.modified(!0)
-    }
-    ee(bN, it);
-
-    function JV(e) {
-        const t = e.expr;
-        return this.value && !e.modified("expr") ? this.value : li(n => t(n, e), pn(t), bt(t))
-    }
-
-    function Q_(e) {
-        L.call(this, [void 0, void 0], e)
+    function tE(e) {
+        j.call(this, null, e)
     }
-    Q_.Definition = {
-        type: "Extent",
+    tE.Definition = {
+        type: "GeoJSON",
         metadata: {},
         params: [{
-            name: "field",
+            name: "fields",
             type: "field",
-            required: !0
-        }]
-    };
-    ee(Q_, L, {
-        transform(e, t) {
-            const n = this.value,
-                i = e.field,
-                r = t.changed() || t.modified(i.fields) || e.modified("field");
-            let s = n[0],
-                a = n[1];
-            if ((r || s == null) && (s = 1 / 0, a = -1 / 0), t.visit(r ? t.SOURCE : t.ADD, o => {
-                    const l = hn(i(o));
-                    l != null && (l < s && (s = l), l > a && (a = l))
-                }), !Number.isFinite(s) || !Number.isFinite(a)) {
-                let o = bt(i);
-                o && (o = ` for field "${o}"`), t.dataflow.warn(`Infinite extent${o}: [${s}, ${a}]`), s = a = void 0
-            }
-            this.value = [s, a]
-        }
-    });
-
-    function Z_(e, t) {
-        it.call(this, e), this.parent = t, this.count = 0
-    }
-    ee(Z_, it, {
-        connect(e) {
-            return this.detachSubflow = e.detachSubflow, this.targets().add(e), e.source = this
-        },
-        add(e) {
-            this.count += 1, this.value.add.push(e)
-        },
-        rem(e) {
-            this.count -= 1, this.value.rem.push(e)
-        },
-        mod(e) {
-            this.value.mod.push(e)
-        },
-        init(e) {
-            this.value.init(e, e.NO_SOURCE)
-        },
-        evaluate() {
-            return this.value
-        }
-    });
-
-    function jm(e) {
-        L.call(this, {}, e), this._keys = _c();
-        const t = this._targets = [];
-        t.active = 0, t.forEach = n => {
-            for (let i = 0, r = t.active; i < r; ++i) n(t[i], i, t)
-        }
-    }
-    ee(jm, L, {
-        activate(e) {
-            this._targets[this._targets.active++] = e
-        },
-        subflow(e, t, n, i) {
-            const r = this.value;
-            let s = me(r, e) && r[e],
-                a, o;
-            return s ? s.value.stamp < n.stamp && (s.init(n), this.activate(s)) : (o = i || (o = this._group[e]) && o.tuple, a = n.dataflow, s = new Z_(n.fork(n.NO_SOURCE), this), a.add(s).connect(t(a, e, o)), r[e] = s, this.activate(s)), s
-        },
-        clean() {
-            const e = this.value;
-            let t = 0;
-            for (const n in e)
-                if (e[n].count === 0) {
-                    const i = e[n].detachSubflow;
-                    i && i(), delete e[n], ++t
-                } if (t) {
-                const n = this._targets.filter(i => i && i.count > 0);
-                this.initTargets(n)
-            }
-        },
-        initTargets(e) {
-            const t = this._targets,
-                n = t.length,
-                i = e ? e.length : 0;
-            let r = 0;
-            for (; r < i; ++r) t[r] = e[r];
-            for (; r < n && t[r] != null; ++r) t[r] = null;
-            t.active = i
-        },
-        transform(e, t) {
-            const n = t.dataflow,
-                i = e.key,
-                r = e.subflow,
-                s = this._keys,
-                a = e.modified("key"),
-                o = l => this.subflow(l, r, t);
-            return this._group = e.group || {}, this.initTargets(), t.visit(t.REM, l => {
-                const u = ge(l),
-                    c = s.get(u);
-                c !== void 0 && (s.delete(u), o(c).rem(l))
-            }), t.visit(t.ADD, l => {
-                const u = i(l);
-                s.set(ge(l), u), o(u).add(l)
-            }), a || t.modified(i.fields) ? t.visit(t.MOD, l => {
-                const u = ge(l),
-                    c = s.get(u),
-                    f = i(l);
-                c === f ? o(f).mod(l) : (s.set(u, f), o(c).rem(l), o(f).add(l))
-            }) : t.changed(t.MOD) && t.visit(t.MOD, l => {
-                o(s.get(ge(l))).mod(l)
-            }), a && t.visit(t.REFLOW, l => {
-                const u = ge(l),
-                    c = s.get(u),
-                    f = i(l);
-                c !== f && (s.set(u, f), o(c).rem(l), o(f).add(l))
-            }), t.clean() ? n.runAfter(() => {
-                this.clean(), s.clean()
-            }) : s.empty > n.cleanThreshold && n.runAfter(s.clean), t
-        }
-    });
-
-    function xN(e) {
-        it.call(this, null, QV, e)
-    }
-    ee(xN, it);
-
-    function QV(e) {
-        return this.value && !e.modified() ? this.value : W(e.name) ? se(e.name).map(t => ni(t)) : ni(e.name, e.as)
-    }
-
-    function ew(e) {
-        L.call(this, _c(), e)
-    }
-    ew.Definition = {
-        type: "Filter",
-        metadata: {
-            changes: !0
-        },
-        params: [{
-            name: "expr",
-            type: "expr",
-            required: !0
+            array: !0,
+            length: 2
+        }, {
+            name: "geojson",
+            type: "field"
         }]
     };
-    ee(ew, L, {
+    ne(tE, j, {
         transform(e, t) {
-            const n = t.dataflow,
-                i = this.value,
-                r = t.fork(),
-                s = r.add,
-                a = r.rem,
-                o = r.mod,
-                l = e.expr;
-            let u = !0;
-            t.visit(t.REM, f => {
-                const h = ge(f);
-                i.has(h) ? i.delete(h) : a.push(f)
-            }), t.visit(t.ADD, f => {
-                l(f, e) ? s.push(f) : i.set(ge(f), 1)
-            });
-
-            function c(f) {
-                const h = ge(f),
-                    d = l(f, e),
-                    g = i.get(h);
-                d && g ? (i.delete(h), s.push(f)) : !d && !g ? (i.set(h, 1), a.push(f)) : u && d && !g && o.push(f)
+            var n = this._features,
+                i = this._points,
+                r = e.fields,
+                s = r && r[0],
+                a = r && r[1],
+                o = e.geojson || !r && Pn,
+                l = t.ADD,
+                u;
+            u = e.modified() || t.changed(t.REM) || t.modified(Fn(o)) || s && t.modified(Fn(s)) || a && t.modified(Fn(a)), (!this.value || u) && (l = t.SOURCE, this._features = n = [], this._points = i = []), o && t.visit(l, c => n.push(o(c))), s && a && (t.visit(l, c => {
+                var f = s(c),
+                    h = a(c);
+                f != null && h != null && (f = +f) === f && (h = +h) === h && i.push([f, h])
+            }), n = n.concat({
+                type: X2,
+                geometry: {
+                    type: pQ,
+                    coordinates: i
+                }
+            })), this.value = {
+                type: eE,
+                features: n
             }
-            return t.visit(t.MOD, c), e.modified() && (u = !1, t.visit(t.REFLOW, c)), i.empty > n.cleanThreshold && n.runAfter(i.clean), r
         }
     });
 
-    function tw(e) {
-        L.call(this, [], e)
+    function nE(e) {
+        j.call(this, null, e)
     }
-    tw.Definition = {
-        type: "Flatten",
+    nE.Definition = {
+        type: "GeoPath",
         metadata: {
-            generates: !0
+            modifies: !0
         },
         params: [{
-            name: "fields",
-            type: "field",
-            array: !0,
-            required: !0
+            name: "projection",
+            type: "projection"
         }, {
-            name: "index",
-            type: "string"
+            name: "field",
+            type: "field"
+        }, {
+            name: "pointRadius",
+            type: "number",
+            expr: !0
         }, {
             name: "as",
             type: "string",
-            array: !0
+            default: "path"
         }]
     };
-    ee(tw, L, {
+    ne(nE, j, {
         transform(e, t) {
-            const n = t.fork(t.NO_SOURCE),
-                i = e.fields,
-                r = yN(i, e.as || []),
-                s = e.index || null,
-                a = r.length;
-            return n.rem = this.value, t.visit(t.SOURCE, o => {
-                const l = i.map(g => g(o)),
-                    u = l.reduce((g, p) => Math.max(g, p.length), 0);
-                let c = 0,
-                    f, h, d;
-                for (; c < u; ++c) {
-                    for (h = E_(o), f = 0; f < a; ++f) h[r[f]] = (d = l[f][c]) == null ? null : d;
-                    s && (h[s] = c), n.add.push(h)
-                }
-            }), this.value = n.source = n.add, s && n.modifies(s), n.modifies(r)
+            var n = t.fork(t.ALL),
+                i = this.value,
+                r = e.field || Pn,
+                s = e.as || "path",
+                a = n.SOURCE;
+            !i || e.modified() ? (this.value = i = tL(e.projection), n.materialize().reflow()) : a = r === Pn || t.modified(r.fields) ? n.ADD_MOD : n.ADD;
+            const o = mQ(i, e.pointRadius);
+            return n.visit(a, l => l[s] = i(r(l))), i.pointRadius(o), n.modifies(s)
         }
     });
 
-    function nw(e) {
-        L.call(this, [], e)
+    function mQ(e, t) {
+        const n = e.pointRadius();
+        return e.context(null), t != null && e.pointRadius(t), n
     }
-    nw.Definition = {
-        type: "Fold",
+
+    function iE(e) {
+        j.call(this, null, e)
+    }
+    iE.Definition = {
+        type: "GeoPoint",
         metadata: {
-            generates: !0
+            modifies: !0
         },
         params: [{
+            name: "projection",
+            type: "projection",
+            required: !0
+        }, {
             name: "fields",
             type: "field",
             array: !0,
-            required: !0
+            required: !0,
+            length: 2
         }, {
             name: "as",
             type: "string",
             array: !0,
             length: 2,
-            default: ["key", "value"]
+            default: ["x", "y"]
         }]
     };
-    ee(nw, L, {
+    ne(iE, j, {
         transform(e, t) {
-            const n = t.fork(t.NO_SOURCE),
-                i = e.fields,
-                r = i.map(bt),
-                s = e.as || ["key", "value"],
+            var n = e.projection,
+                i = e.fields[0],
+                r = e.fields[1],
+                s = e.as || ["x", "y"],
                 a = s[0],
                 o = s[1],
-                l = i.length;
-            return n.rem = this.value, t.visit(t.SOURCE, u => {
-                for (let c = 0, f; c < l; ++c) f = E_(u), f[a] = r[c], f[o] = i[c](u), n.add.push(f)
-            }), this.value = n.source = n.add, n.modifies(s)
-        }
-    });
-
-    function iw(e) {
-        L.call(this, null, e)
-    }
-    iw.Definition = {
-        type: "Formula",
-        metadata: {
-            modifies: !0
-        },
-        params: [{
-            name: "expr",
-            type: "expr",
-            required: !0
-        }, {
-            name: "as",
-            type: "string",
-            required: !0
-        }, {
-            name: "initonly",
-            type: "boolean"
-        }]
-    };
-    ee(iw, L, {
-        transform(e, t) {
-            const n = e.expr,
-                i = e.as,
-                r = e.modified(),
-                s = e.initonly ? t.ADD : r ? t.SOURCE : t.modified(n.fields) || t.modified(i) ? t.ADD_MOD : t.ADD;
-            return r && (t = t.materialize().reflow(!0)), e.initonly || t.modifies(i), t.visit(s, a => a[i] = n(a, e))
-        }
-    });
+                l;
 
-    function _N(e) {
-        L.call(this, [], e)
-    }
-    ee(_N, L, {
-        transform(e, t) {
-            const n = t.fork(t.ALL),
-                i = e.generator;
-            let r = this.value,
-                s = e.size - r.length,
-                a, o, l;
-            if (s > 0) {
-                for (a = []; --s >= 0;) a.push(l = He(i(e))), r.push(l);
-                n.add = n.add.length ? n.materialize(n.ADD).add.concat(a) : a
-            } else o = r.slice(0, -s), n.rem = n.rem.length ? n.materialize(n.REM).rem.concat(o) : o, r = r.slice(-s);
-            return n.source = this.value = r, n
+            function u(c) {
+                const f = n([i(c), r(c)]);
+                f ? (c[a] = f[0], c[o] = f[1]) : (c[a] = void 0, c[o] = void 0)
+            }
+            return e.modified() ? t = t.materialize().reflow(!0).visit(t.SOURCE, u) : (l = t.modified(i.fields) || t.modified(r.fields), t.visit(l ? t.ADD_MOD : t.ADD, u)), t.modifies(s)
         }
     });
-    const yg = {
-            value: "value",
-            median: zO,
-            mean: $j,
-            min: cb,
-            max: jo
-        },
-        ZV = [];
 
-    function rw(e) {
-        L.call(this, [], e)
+    function rE(e) {
+        j.call(this, null, e)
     }
-    rw.Definition = {
-        type: "Impute",
+    rE.Definition = {
+        type: "GeoShape",
         metadata: {
-            changes: !0
+            modifies: !0,
+            nomod: !0
         },
         params: [{
-            name: "field",
-            type: "field",
-            required: !0
-        }, {
-            name: "key",
-            type: "field",
-            required: !0
-        }, {
-            name: "keyvals",
-            array: !0
+            name: "projection",
+            type: "projection"
         }, {
-            name: "groupby",
+            name: "field",
             type: "field",
-            array: !0
+            default: "datum"
         }, {
-            name: "method",
-            type: "enum",
-            default: "value",
-            values: ["value", "mean", "median", "max", "min"]
+            name: "pointRadius",
+            type: "number",
+            expr: !0
         }, {
-            name: "value",
-            default: 0
+            name: "as",
+            type: "string",
+            default: "shape"
         }]
     };
-
-    function eK(e) {
-        var t = e.method || yg.value,
-            n;
-        if (yg[t] == null) U("Unrecognized imputation method: " + t);
-        else return t === yg.value ? (n = e.value !== void 0 ? e.value : 0, () => n) : yg[t]
-    }
-
-    function tK(e) {
-        const t = e.field;
-        return n => n ? t(n) : NaN
-    }
-    ee(rw, L, {
+    ne(rE, j, {
         transform(e, t) {
             var n = t.fork(t.ALL),
-                i = eK(e),
-                r = tK(e),
-                s = bt(e.field),
-                a = bt(e.key),
-                o = (e.groupby || []).map(bt),
-                l = nK(t.source, e.groupby, e.key, e.keyvals),
-                u = [],
-                c = this.value,
-                f = l.domain.length,
-                h, d, g, p, m, y, v, b, x, _;
-            for (m = 0, b = l.length; m < b; ++m)
-                for (h = l[m], g = h.values, d = NaN, v = 0; v < f; ++v)
-                    if (h[v] == null) {
-                        for (p = l.domain[v], _ = {
-                                _impute: !0
-                            }, y = 0, x = g.length; y < x; ++y) _[o[y]] = g[y];
-                        _[a] = p, _[s] = Number.isNaN(d) ? d = i(h, r) : d, u.push(He(_))
-                    } return u.length && (n.add = n.materialize(n.ADD).add.concat(u)), c.length && (n.rem = n.materialize(n.REM).rem.concat(c)), this.value = u, n
+                i = this.value,
+                r = e.as || "shape",
+                s = n.ADD;
+            return (!i || e.modified()) && (this.value = i = yQ(tL(e.projection), e.field || fi("datum"), e.pointRadius), n.materialize().reflow(), s = n.SOURCE), n.visit(s, a => a[r] = i), n.modifies(r)
         }
     });
 
-    function nK(e, t, n, i) {
-        var r = y => y(m),
-            s = [],
-            a = i ? i.slice() : [],
-            o = {},
-            l = {},
-            u, c, f, h, d, g, p, m;
-        for (a.forEach((y, v) => o[y] = v + 1), h = 0, p = e.length; h < p; ++h) m = e[h], g = n(m), d = o[g] || (o[g] = a.push(g)), c = (u = t ? t.map(r) : ZV) + "", (f = l[c]) || (f = l[c] = [], s.push(f), f.values = u), f[d - 1] = m;
-        return s.domain = a, s
+    function yQ(e, t, n) {
+        const i = n == null ? r => e(t(r)) : r => {
+            var s = e.pointRadius(),
+                a = e.pointRadius(n)(t(r));
+            return e.pointRadius(s), a
+        };
+        return i.context = r => (e.context(r), i), i
     }
 
-    function sw(e) {
-        Ra.call(this, e)
+    function sE(e) {
+        j.call(this, [], e), this.generator = cJ()
     }
-    sw.Definition = {
-        type: "JoinAggregate",
+    sE.Definition = {
+        type: "Graticule",
         metadata: {
-            modifies: !0
+            changes: !0,
+            generates: !0
         },
         params: [{
-            name: "groupby",
-            type: "field",
-            array: !0
+            name: "extent",
+            type: "array",
+            array: !0,
+            length: 2,
+            content: {
+                type: "number",
+                array: !0,
+                length: 2
+            }
         }, {
-            name: "fields",
-            type: "field",
-            null: !0,
-            array: !0
+            name: "extentMajor",
+            type: "array",
+            array: !0,
+            length: 2,
+            content: {
+                type: "number",
+                array: !0,
+                length: 2
+            }
         }, {
-            name: "ops",
-            type: "enum",
+            name: "extentMinor",
+            type: "array",
             array: !0,
-            values: ud
+            length: 2,
+            content: {
+                type: "number",
+                array: !0,
+                length: 2
+            }
         }, {
-            name: "as",
-            type: "string",
-            null: !0,
-            array: !0
+            name: "step",
+            type: "number",
+            array: !0,
+            length: 2
         }, {
-            name: "key",
-            type: "field"
+            name: "stepMajor",
+            type: "number",
+            array: !0,
+            length: 2,
+            default: [90, 360]
+        }, {
+            name: "stepMinor",
+            type: "number",
+            array: !0,
+            length: 2,
+            default: [10, 10]
+        }, {
+            name: "precision",
+            type: "number",
+            default: 2.5
         }]
     };
-    ee(sw, Ra, {
+    ne(sE, j, {
         transform(e, t) {
-            const n = this,
-                i = e.modified();
-            let r;
-            return n.value && (i || t.modified(n._inputs, !0)) ? (r = n.value = i ? n.init(e) : {}, t.visit(t.SOURCE, s => n.add(s))) : (r = n.value = n.value || this.init(e), t.visit(t.REM, s => n.rem(s)), t.visit(t.ADD, s => n.add(s))), n.changes(), t.visit(t.SOURCE, s => {
-                Ae(s, r[n.cellkey(s)].tuple)
-            }), t.reflow(i).modifies(this._outputs)
-        },
-        changes() {
-            const e = this._adds,
-                t = this._mods;
-            let n, i;
-            for (n = 0, i = this._alen; n < i; ++n) this.celltuple(e[n]), e[n] = null;
-            for (n = 0, i = this._mlen; n < i; ++n) this.celltuple(t[n]), t[n] = null;
-            this._alen = this._mlen = 0
+            var n = this.value,
+                i = this.generator,
+                r;
+            if (!n.length || e.modified())
+                for (const s in e) Pe(i[s]) && i[s](e[s]);
+            return r = i(), n.length ? t.mod.push(_R(n[0], r)) : t.add.push(it(r)), n[0] = r, t
         }
     });
 
-    function aw(e) {
-        L.call(this, null, e)
+    function aE(e) {
+        j.call(this, null, e)
     }
-    aw.Definition = {
-        type: "KDE",
+    aE.Definition = {
+        type: "heatmap",
         metadata: {
-            generates: !0
+            modifies: !0
         },
         params: [{
-            name: "groupby",
-            type: "field",
-            array: !0
-        }, {
             name: "field",
-            type: "field",
-            required: !0
-        }, {
-            name: "cumulative",
-            type: "boolean",
-            default: !1
-        }, {
-            name: "counts",
-            type: "boolean",
-            default: !1
+            type: "field"
         }, {
-            name: "bandwidth",
-            type: "number",
-            default: 0
+            name: "color",
+            type: "string",
+            expr: !0
         }, {
-            name: "extent",
+            name: "opacity",
             type: "number",
-            array: !0,
-            length: 2
+            expr: !0
         }, {
             name: "resolve",
             type: "enum",
             values: ["shared", "independent"],
             default: "independent"
         }, {
-            name: "steps",
-            type: "number"
-        }, {
-            name: "minsteps",
-            type: "number",
-            default: 25
-        }, {
-            name: "maxsteps",
-            type: "number",
-            default: 200
-        }, {
             name: "as",
             type: "string",
-            array: !0,
-            default: ["value", "density"]
+            default: "image"
         }]
     };
-    ee(aw, L, {
+    ne(aE, j, {
         transform(e, t) {
-            const n = t.fork(t.NO_SOURCE | t.NO_FIELDS);
-            if (!this.value || t.changed() || e.modified()) {
-                const i = t.materialize(t.SOURCE).source,
-                    r = K_(i, e.groupby, e.field),
-                    s = (e.groupby || []).map(bt),
-                    a = e.bandwidth,
-                    o = e.cumulative ? "cdf" : "pdf",
-                    l = e.as || ["value", "density"],
-                    u = [];
-                let c = e.extent,
-                    f = e.steps || e.minsteps || 25,
-                    h = e.steps || e.maxsteps || 200;
-                o !== "pdf" && o !== "cdf" && U("Invalid density method: " + o), e.resolve === "shared" && (c || (c = Hr(i, e.field)), f = h = e.steps || h), r.forEach(d => {
-                    const g = F_(d, a)[o],
-                        p = e.counts ? d.length : 1,
-                        m = c || Hr(d);
-                    Bm(g, m, f, h).forEach(y => {
-                        const v = {};
-                        for (let b = 0; b < s.length; ++b) v[s[b]] = d.dims[b];
-                        v[l[0]] = y[0], v[l[1]] = y[1] * p, u.push(He(v))
-                    })
-                }), this.value && (n.rem = this.value), this.value = n.add = n.source = u
-            }
-            return n
+            if (!t.changed() && !e.modified()) return t.StopPropagation;
+            var n = t.materialize(t.SOURCE).source,
+                i = e.resolve === "shared",
+                r = e.field || Pn,
+                s = bQ(e.opacity, e),
+                a = vQ(e.color, e),
+                o = e.as || "image",
+                l = {
+                    $x: 0,
+                    $y: 0,
+                    $value: 0,
+                    $max: i ? cl(n.map(u => cl(r(u).values))) : 0
+                };
+            return n.forEach(u => {
+                const c = r(u),
+                    f = Ne({}, u, l);
+                i || (f.$max = cl(c.values || [])), u[o] = xQ(c, f, a.dep ? a : Ln(a(f)), s.dep ? s : Ln(s(f)))
+            }), t.reflow(!0).modifies(o)
         }
     });
 
-    function wN(e) {
-        it.call(this, null, iK, e)
+    function vQ(e, t) {
+        let n;
+        return Pe(e) ? (n = i => to(e(i, t)), n.dep = oL(e)) : n = Ln(to(e || "#888")), n
     }
-    ee(wN, it);
 
-    function iK(e) {
-        return this.value && !e.modified() ? this.value : d_(e.fields, e.flat)
+    function bQ(e, t) {
+        let n;
+        return Pe(e) ? (n = i => e(i, t), n.dep = oL(e)) : e ? n = Ln(e) : (n = i => i.$value / i.$max || 0, n.dep = !0), n
     }
 
-    function SN(e) {
-        L.call(this, [], e), this._pending = null
+    function oL(e) {
+        if (!Pe(e)) return !1;
+        const t = Cr(Fn(e));
+        return t.$x || t.$y || t.$value || t.$max
+    }
+
+    function xQ(e, t, n, i) {
+        const r = e.width,
+            s = e.height,
+            a = e.x1 || 0,
+            o = e.y1 || 0,
+            l = e.x2 || r,
+            u = e.y2 || s,
+            c = e.values,
+            f = c ? m => c[m] : Ma,
+            h = Ha(l - a, u - o),
+            d = h.getContext("2d"),
+            g = d.getImageData(0, 0, l - a, u - o),
+            p = g.data;
+        for (let m = o, y = 0; m < u; ++m) {
+            t.$y = m - o;
+            for (let v = a, b = m * r; v < l; ++v, y += 4) {
+                t.$x = v - a, t.$value = f(v + b);
+                const x = n(t);
+                p[y + 0] = x.r, p[y + 1] = x.g, p[y + 2] = x.b, p[y + 3] = ~~(255 * i(t))
+            }
+        }
+        return d.putImageData(g, 0, 0), h
+    }
+
+    function lL(e) {
+        j.call(this, null, e), this.modified(!0)
     }
-    ee(SN, L, {
+    ne(lL, j, {
         transform(e, t) {
-            const n = t.dataflow;
-            return this._pending ? Ky(this, t, this._pending) : rK(e) ? t.StopPropagation : e.values ? Ky(this, t, n.parse(e.values, e.format)) : e.async ? {
-                async: n.request(e.url, e.format).then(r => (this._pending = se(r.data), s => s.touch(this)))
-            } : n.request(e.url, e.format).then(i => Ky(this, t, se(i.data)))
+            let n = this.value;
+            return !n || e.modified("type") ? (this.value = n = wQ(e.type), Y2.forEach(i => {
+                e[i] != null && AT(n, i, e[i])
+            })) : Y2.forEach(i => {
+                e.modified(i) && AT(n, i, e[i])
+            }), e.pointRadius != null && n.path.pointRadius(e.pointRadius), e.fit && _Q(n, e), t.fork(t.NO_SOURCE | t.NO_FIELDS)
         }
     });
 
-    function rK(e) {
-        return e.modified("async") && !(e.modified("values") || e.modified("url") || e.modified("format"))
+    function _Q(e, t) {
+        const n = SQ(t.fit);
+        t.extent ? e.fitExtent(t.extent, n) : t.size && e.fitSize(t.size, n)
     }
 
-    function Ky(e, t, n) {
-        n.forEach(He);
-        const i = t.fork(t.NO_FIELDS & t.NO_SOURCE);
-        return i.rem = e.value, e.value = i.source = i.add = n, e._pending = null, i.rem.length && i.clean(!0), i
+    function wQ(e) {
+        const t = KS((e || "mercator").toLowerCase());
+        return t || q("Unrecognized projection type: " + e), t()
     }
 
-    function ow(e) {
-        L.call(this, {}, e)
+    function AT(e, t, n) {
+        Pe(e[t]) && e[t](n)
     }
-    ow.Definition = {
-        type: "Lookup",
-        metadata: {
-            modifies: !0
-        },
-        params: [{
-            name: "index",
-            type: "index",
-            params: [{
-                name: "from",
-                type: "data",
-                required: !0
-            }, {
-                name: "key",
-                type: "field",
-                required: !0
-            }]
-        }, {
-            name: "values",
-            type: "field",
-            array: !0
-        }, {
-            name: "fields",
-            type: "field",
-            array: !0,
-            required: !0
-        }, {
-            name: "as",
-            type: "string",
-            array: !0
-        }, {
-            name: "default",
-            default: null
-        }]
-    };
-    ee(ow, L, {
-        transform(e, t) {
-            const n = e.fields,
-                i = e.index,
-                r = e.values,
-                s = e.default == null ? null : e.default,
-                a = e.modified(),
-                o = n.length;
-            let l = a ? t.SOURCE : t.ADD,
-                u = t,
-                c = e.as,
-                f, h, d;
-            return r ? (h = r.length, o > 1 && !c && U('Multi-field lookup requires explicit "as" parameter.'), c && c.length !== o * h && U('The "as" parameter has too few output field names.'), c = c || r.map(bt), f = function(g) {
-                for (var p = 0, m = 0, y, v; p < o; ++p)
-                    if (v = i.get(n[p](g)), v == null)
-                        for (y = 0; y < h; ++y, ++m) g[c[m]] = s;
-                    else
-                        for (y = 0; y < h; ++y, ++m) g[c[m]] = r[y](v)
-            }) : (c || U("Missing output field names."), f = function(g) {
-                for (var p = 0, m; p < o; ++p) m = i.get(n[p](g)), g[c[p]] = m ?? s
-            }), a ? u = t.reflow(!0) : (d = n.some(g => t.modified(g.fields)), l |= d ? t.MOD : 0), t.visit(l, f), u.modifies(c)
+
+    function SQ(e) {
+        return e = ue(e), e.length === 1 ? e[0] : {
+            type: eE,
+            features: e.reduce((t, n) => t.concat(EQ(n)), [])
         }
-    });
+    }
 
-    function EN(e) {
-        it.call(this, null, sK, e)
+    function EQ(e) {
+        return e.type === eE ? e.features : ue(e).filter(t => t != null).map(t => t.type === X2 ? t : {
+            type: X2,
+            geometry: t
+        })
     }
-    ee(EN, it);
+    const kQ = Object.freeze(Object.defineProperty({
+        __proto__: null,
+        contour: ZS,
+        geojson: tE,
+        geopath: nE,
+        geopoint: iE,
+        geoshape: rE,
+        graticule: sE,
+        heatmap: aE,
+        isocontour: JS,
+        kde2d: QS,
+        projection: lL
+    }, Symbol.toStringTag, {
+        value: "Module"
+    }));
 
-    function sK(e) {
-        if (this.value && !e.modified()) return this.value;
-        const t = e.extents,
-            n = t.length;
-        let i = 1 / 0,
-            r = -1 / 0,
-            s, a;
-        for (s = 0; s < n; ++s) a = t[s], a[0] < i && (i = a[0]), a[1] > r && (r = a[1]);
-        return [i, r]
+    function CQ(e, t) {
+        var n, i = 1;
+        e == null && (e = 0), t == null && (t = 0);
+
+        function r() {
+            var s, a = n.length,
+                o, l = 0,
+                u = 0;
+            for (s = 0; s < a; ++s) o = n[s], l += o.x, u += o.y;
+            for (l = (l / a - e) * i, u = (u / a - t) * i, s = 0; s < a; ++s) o = n[s], o.x -= l, o.y -= u
+        }
+        return r.initialize = function(s) {
+            n = s
+        }, r.x = function(s) {
+            return arguments.length ? (e = +s, r) : e
+        }, r.y = function(s) {
+            return arguments.length ? (t = +s, r) : t
+        }, r.strength = function(s) {
+            return arguments.length ? (i = +s, r) : i
+        }, r
     }
 
-    function CN(e) {
-        it.call(this, null, aK, e)
+    function AQ(e) {
+        const t = +this._x.call(null, e),
+            n = +this._y.call(null, e);
+        return uL(this.cover(t, n), t, n, e)
     }
-    ee(CN, it);
 
-    function aK(e) {
-        return this.value && !e.modified() ? this.value : e.values.reduce((t, n) => t.concat(n), [])
+    function uL(e, t, n, i) {
+        if (isNaN(t) || isNaN(n)) return e;
+        var r, s = e._root,
+            a = {
+                data: i
+            },
+            o = e._x0,
+            l = e._y0,
+            u = e._x1,
+            c = e._y1,
+            f, h, d, g, p, m, y, v;
+        if (!s) return e._root = a, e;
+        for (; s.length;)
+            if ((p = t >= (f = (o + u) / 2)) ? o = f : u = f, (m = n >= (h = (l + c) / 2)) ? l = h : c = h, r = s, !(s = s[y = m << 1 | p])) return r[y] = a, e;
+        if (d = +e._x.call(null, s.data), g = +e._y.call(null, s.data), t === d && n === g) return a.next = s, r ? r[y] = a : e._root = a, e;
+        do r = r ? r[y] = new Array(4) : e._root = new Array(4), (p = t >= (f = (o + u) / 2)) ? o = f : u = f, (m = n >= (h = (l + c) / 2)) ? l = h : c = h; while ((y = m << 1 | p) === (v = (g >= h) << 1 | d >= f));
+        return r[v] = s, r[y] = a, e
     }
 
-    function kN(e) {
-        L.call(this, null, e)
+    function $Q(e) {
+        var t, n, i = e.length,
+            r, s, a = new Array(i),
+            o = new Array(i),
+            l = 1 / 0,
+            u = 1 / 0,
+            c = -1 / 0,
+            f = -1 / 0;
+        for (n = 0; n < i; ++n) isNaN(r = +this._x.call(null, t = e[n])) || isNaN(s = +this._y.call(null, t)) || (a[n] = r, o[n] = s, r < l && (l = r), r > c && (c = r), s < u && (u = s), s > f && (f = s));
+        if (l > c || u > f) return this;
+        for (this.cover(l, u).cover(c, f), n = 0; n < i; ++n) uL(this, a[n], o[n], e[n]);
+        return this
     }
-    ee(kN, L, {
-        transform(e, t) {
-            return this.modified(e.modified()), this.value = e, t.fork(t.NO_SOURCE | t.NO_FIELDS)
+
+    function TQ(e, t) {
+        if (isNaN(e = +e) || isNaN(t = +t)) return this;
+        var n = this._x0,
+            i = this._y0,
+            r = this._x1,
+            s = this._y1;
+        if (isNaN(n)) r = (n = Math.floor(e)) + 1, s = (i = Math.floor(t)) + 1;
+        else {
+            for (var a = r - n || 1, o = this._root, l, u; n > e || e >= r || i > t || t >= s;) switch (u = (t < i) << 1 | e < n, l = new Array(4), l[u] = o, o = l, a *= 2, u) {
+                case 0:
+                    r = n + a, s = i + a;
+                    break;
+                case 1:
+                    n = r - a, s = i + a;
+                    break;
+                case 2:
+                    r = n + a, i = s - a;
+                    break;
+                case 3:
+                    n = r - a, i = s - a;
+                    break
+            }
+            this._root && this._root.length && (this._root = o)
         }
-    });
+        return this._x0 = n, this._y0 = i, this._x1 = r, this._y1 = s, this
+    }
 
-    function lw(e) {
-        Ra.call(this, e)
+    function MQ() {
+        var e = [];
+        return this.visit(function(t) {
+            if (!t.length)
+                do e.push(t.data); while (t = t.next)
+        }), e
     }
-    lw.Definition = {
-        type: "Pivot",
-        metadata: {
-            generates: !0,
-            changes: !0
-        },
-        params: [{
-            name: "groupby",
-            type: "field",
-            array: !0
-        }, {
-            name: "field",
-            type: "field",
-            required: !0
-        }, {
-            name: "value",
-            type: "field",
-            required: !0
-        }, {
-            name: "op",
-            type: "enum",
-            values: ud,
-            default: "sum"
-        }, {
-            name: "limit",
-            type: "number",
-            default: 0
-        }, {
-            name: "key",
-            type: "field"
-        }]
-    };
-    ee(lw, Ra, {
-        _transform: Ra.prototype.transform,
-        transform(e, t) {
-            return this._transform(oK(e, t), t)
-        }
-    });
 
-    function oK(e, t) {
-        const n = e.field,
-            i = e.value,
-            r = (e.op === "count" ? "__count__" : e.op) || "sum",
-            s = pn(n).concat(pn(i)),
-            a = uK(n, e.limit || 0, t);
-        return t.changed() && e.set("__pivot__", null, null, !0), {
-            key: e.key,
-            groupby: e.groupby,
-            ops: a.map(() => r),
-            fields: a.map(o => lK(o, n, i, s)),
-            as: a.map(o => o + ""),
-            modified: e.modified.bind(e)
-        }
+    function OQ(e) {
+        return arguments.length ? this.cover(+e[0][0], +e[0][1]).cover(+e[1][0], +e[1][1]) : isNaN(this._x0) ? void 0 : [
+            [this._x0, this._y0],
+            [this._x1, this._y1]
+        ]
     }
 
-    function lK(e, t, n, i) {
-        return li(r => t(r) === e ? n(r) : NaN, i, e + "")
+    function qn(e, t, n, i, r) {
+        this.node = e, this.x0 = t, this.y0 = n, this.x1 = i, this.y1 = r
     }
 
-    function uK(e, t, n) {
-        const i = {},
-            r = [];
-        return n.visit(n.SOURCE, s => {
-            const a = e(s);
-            i[a] || (i[a] = 1, r.push(a))
-        }), r.sort($m), t ? r.slice(0, t) : r
+    function FQ(e, t, n) {
+        var i, r = this._x0,
+            s = this._y0,
+            a, o, l, u, c = this._x1,
+            f = this._y1,
+            h = [],
+            d = this._root,
+            g, p;
+        for (d && h.push(new qn(d, r, s, c, f)), n == null ? n = 1 / 0 : (r = e - n, s = t - n, c = e + n, f = t + n, n *= n); g = h.pop();)
+            if (!(!(d = g.node) || (a = g.x0) > c || (o = g.y0) > f || (l = g.x1) < r || (u = g.y1) < s))
+                if (d.length) {
+                    var m = (a + l) / 2,
+                        y = (o + u) / 2;
+                    h.push(new qn(d[3], m, y, l, u), new qn(d[2], a, y, m, u), new qn(d[1], m, o, l, y), new qn(d[0], a, o, m, y)), (p = (t >= y) << 1 | e >= m) && (g = h[h.length - 1], h[h.length - 1] = h[h.length - 1 - p], h[h.length - 1 - p] = g)
+                } else {
+                    var v = e - +this._x.call(null, d.data),
+                        b = t - +this._y.call(null, d.data),
+                        x = v * v + b * b;
+                    if (x < n) {
+                        var _ = Math.sqrt(n = x);
+                        r = e - _, s = t - _, c = e + _, f = t + _, i = d.data
+                    }
+                } return i
+    }
+
+    function RQ(e) {
+        if (isNaN(c = +this._x.call(null, e)) || isNaN(f = +this._y.call(null, e))) return this;
+        var t, n = this._root,
+            i, r, s, a = this._x0,
+            o = this._y0,
+            l = this._x1,
+            u = this._y1,
+            c, f, h, d, g, p, m, y;
+        if (!n) return this;
+        if (n.length)
+            for (;;) {
+                if ((g = c >= (h = (a + l) / 2)) ? a = h : l = h, (p = f >= (d = (o + u) / 2)) ? o = d : u = d, t = n, !(n = n[m = p << 1 | g])) return this;
+                if (!n.length) break;
+                (t[m + 1 & 3] || t[m + 2 & 3] || t[m + 3 & 3]) && (i = t, y = m)
+            }
+        for (; n.data !== e;)
+            if (r = n, !(n = n.next)) return this;
+        return (s = n.next) && delete n.next, r ? (s ? r.next = s : delete r.next, this) : t ? (s ? t[m] = s : delete t[m], (n = t[0] || t[1] || t[2] || t[3]) && n === (t[3] || t[2] || t[1] || t[0]) && !n.length && (i ? i[y] = n : this._root = n), this) : (this._root = s, this)
     }
 
-    function AN(e) {
-        jm.call(this, e)
+    function DQ(e) {
+        for (var t = 0, n = e.length; t < n; ++t) this.remove(e[t]);
+        return this
     }
-    ee(AN, jm, {
-        transform(e, t) {
-            const n = e.subflow,
-                i = e.field,
-                r = s => this.subflow(ge(s), n, t, s);
-            return (e.modified("field") || i && t.modified(pn(i))) && U("PreFacet does not support field modification."), this.initTargets(), i ? (t.visit(t.MOD, s => {
-                const a = r(s);
-                i(s).forEach(o => a.mod(o))
-            }), t.visit(t.ADD, s => {
-                const a = r(s);
-                i(s).forEach(o => a.add(He(o)))
-            }), t.visit(t.REM, s => {
-                const a = r(s);
-                i(s).forEach(o => a.rem(o))
-            })) : (t.visit(t.MOD, s => r(s).mod(s)), t.visit(t.ADD, s => r(s).add(s)), t.visit(t.REM, s => r(s).rem(s))), t.clean() && t.runAfter(() => this.clean()), t
-        }
-    });
 
-    function uw(e) {
-        L.call(this, null, e)
+    function NQ() {
+        return this._root
     }
-    uw.Definition = {
-        type: "Project",
-        metadata: {
-            generates: !0,
-            changes: !0
-        },
-        params: [{
-            name: "fields",
-            type: "field",
-            array: !0
-        }, {
-            name: "as",
-            type: "string",
-            null: !0,
-            array: !0
-        }]
-    };
-    ee(uw, L, {
-        transform(e, t) {
-            const n = t.fork(t.NO_SOURCE),
-                i = e.fields,
-                r = yN(e.fields, e.as || []),
-                s = i ? (o, l) => cK(o, l, i, r) : Rm;
-            let a;
-            return this.value ? a = this.value : (t = t.addAll(), a = this.value = {}), t.visit(t.REM, o => {
-                const l = ge(o);
-                n.rem.push(a[l]), a[l] = null
-            }), t.visit(t.ADD, o => {
-                const l = s(o, He({}));
-                a[ge(o)] = l, n.add.push(l)
-            }), t.visit(t.MOD, o => {
-                n.mod.push(s(o, a[ge(o)]))
-            }), n
-        }
-    });
 
-    function cK(e, t, n, i) {
-        for (let r = 0, s = n.length; r < s; ++r) t[i[r]] = n[r](e);
-        return t
+    function PQ() {
+        var e = 0;
+        return this.visit(function(t) {
+            if (!t.length)
+                do ++e; while (t = t.next)
+        }), e
     }
 
-    function $N(e) {
-        L.call(this, null, e)
+    function LQ(e) {
+        var t = [],
+            n, i = this._root,
+            r, s, a, o, l;
+        for (i && t.push(new qn(i, this._x0, this._y0, this._x1, this._y1)); n = t.pop();)
+            if (!e(i = n.node, s = n.x0, a = n.y0, o = n.x1, l = n.y1) && i.length) {
+                var u = (s + o) / 2,
+                    c = (a + l) / 2;
+                (r = i[3]) && t.push(new qn(r, u, c, o, l)), (r = i[2]) && t.push(new qn(r, s, c, u, l)), (r = i[1]) && t.push(new qn(r, u, a, o, c)), (r = i[0]) && t.push(new qn(r, s, a, u, c))
+            } return this
     }
-    ee($N, L, {
-        transform(e, t) {
-            return this.value = e.value, e.modified("value") ? t.fork(t.NO_SOURCE | t.NO_FIELDS) : t.StopPropagation
+
+    function IQ(e) {
+        var t = [],
+            n = [],
+            i;
+        for (this._root && t.push(new qn(this._root, this._x0, this._y0, this._x1, this._y1)); i = t.pop();) {
+            var r = i.node;
+            if (r.length) {
+                var s, a = i.x0,
+                    o = i.y0,
+                    l = i.x1,
+                    u = i.y1,
+                    c = (a + l) / 2,
+                    f = (o + u) / 2;
+                (s = r[0]) && t.push(new qn(s, a, o, c, f)), (s = r[1]) && t.push(new qn(s, c, o, l, f)), (s = r[2]) && t.push(new qn(s, a, f, c, u)), (s = r[3]) && t.push(new qn(s, c, f, l, u))
+            }
+            n.push(i)
         }
-    });
+        for (; i = n.pop();) e(i.node, i.x0, i.y0, i.x1, i.y1);
+        return this
+    }
 
-    function cw(e) {
-        L.call(this, null, e)
+    function zQ(e) {
+        return e[0]
     }
-    cw.Definition = {
-        type: "Quantile",
-        metadata: {
-            generates: !0,
-            changes: !0
-        },
-        params: [{
-            name: "groupby",
-            type: "field",
-            array: !0
-        }, {
-            name: "field",
-            type: "field",
-            required: !0
-        }, {
-            name: "probs",
-            type: "number",
-            array: !0
-        }, {
-            name: "step",
-            type: "number",
-            default: .01
-        }, {
-            name: "as",
-            type: "string",
-            array: !0,
-            default: ["prob", "value"]
-        }]
+
+    function BQ(e) {
+        return arguments.length ? (this._x = e, this) : this._x
+    }
+
+    function jQ(e) {
+        return e[1]
+    }
+
+    function GQ(e) {
+        return arguments.length ? (this._y = e, this) : this._y
+    }
+
+    function oE(e, t, n) {
+        var i = new lE(t ?? zQ, n ?? jQ, NaN, NaN, NaN, NaN);
+        return e == null ? i : i.addAll(e)
+    }
+
+    function lE(e, t, n, i, r, s) {
+        this._x = e, this._y = t, this._x0 = n, this._y0 = i, this._x1 = r, this._y1 = s, this._root = void 0
+    }
+
+    function $T(e) {
+        for (var t = {
+                data: e.data
+            }, n = t; e = e.next;) n = n.next = {
+            data: e.data
+        };
+        return t
+    }
+    var Qn = oE.prototype = lE.prototype;
+    Qn.copy = function() {
+        var e = new lE(this._x, this._y, this._x0, this._y0, this._x1, this._y1),
+            t = this._root,
+            n, i;
+        if (!t) return e;
+        if (!t.length) return e._root = $T(t), e;
+        for (n = [{
+                source: t,
+                target: e._root = new Array(4)
+            }]; t = n.pop();)
+            for (var r = 0; r < 4; ++r)(i = t.source[r]) && (i.length ? n.push({
+                source: i,
+                target: t.target[r] = new Array(4)
+            }) : t.target[r] = $T(i));
+        return e
     };
-    const fK = 1e-14;
-    ee(cw, L, {
-        transform(e, t) {
-            const n = t.fork(t.NO_SOURCE | t.NO_FIELDS),
-                i = e.as || ["prob", "value"];
-            if (this.value && !e.modified() && !t.changed()) return n.source = this.value, n;
-            const r = t.materialize(t.SOURCE).source,
-                s = K_(r, e.groupby, e.field),
-                a = (e.groupby || []).map(bt),
-                o = [],
-                l = e.step || .01,
-                u = e.probs || gi(l / 2, 1 - fK, l),
-                c = u.length;
-            return s.forEach(f => {
-                const h = A_(f, u);
-                for (let d = 0; d < c; ++d) {
-                    const g = {};
-                    for (let p = 0; p < a.length; ++p) g[a[p]] = f.dims[p];
-                    g[i[0]] = u[d], g[i[1]] = h[d], o.push(He(g))
-                }
-            }), this.value && (n.rem = this.value), this.value = n.add = n.source = o, n
+    Qn.add = AQ;
+    Qn.addAll = $Q;
+    Qn.cover = TQ;
+    Qn.data = MQ;
+    Qn.extent = OQ;
+    Qn.find = FQ;
+    Qn.remove = RQ;
+    Qn.removeAll = DQ;
+    Qn.root = NQ;
+    Qn.size = PQ;
+    Qn.visit = LQ;
+    Qn.visitAfter = IQ;
+    Qn.x = BQ;
+    Qn.y = GQ;
+
+    function Hn(e) {
+        return function() {
+            return e
         }
-    });
+    }
 
-    function TN(e) {
-        L.call(this, null, e)
+    function Ia(e) {
+        return (e() - .5) * 1e-6
     }
-    ee(TN, L, {
-        transform(e, t) {
-            let n, i;
-            return this.value ? i = this.value : (n = t = t.addAll(), i = this.value = {}), e.derive && (n = t.fork(t.NO_SOURCE), t.visit(t.REM, r => {
-                const s = ge(r);
-                n.rem.push(i[s]), i[s] = null
-            }), t.visit(t.ADD, r => {
-                const s = E_(r);
-                i[ge(r)] = s, n.add.push(s)
-            }), t.visit(t.MOD, r => {
-                const s = i[ge(r)];
-                for (const a in r) s[a] = r[a], n.modifies(a);
-                n.mod.push(s)
-            })), n
-        }
-    });
 
-    function fw(e) {
-        L.call(this, [], e), this.count = 0
+    function UQ(e) {
+        return e.x + e.vx
     }
-    fw.Definition = {
-        type: "Sample",
-        metadata: {},
-        params: [{
-            name: "size",
-            type: "number",
-            default: 1e3
-        }]
-    };
-    ee(fw, L, {
-        transform(e, t) {
-            const n = t.fork(t.NO_SOURCE),
-                i = e.modified("size"),
-                r = e.size,
-                s = this.value.reduce((c, f) => (c[ge(f)] = 1, c), {});
-            let a = this.value,
-                o = this.count,
-                l = 0;
 
-            function u(c) {
-                let f, h;
-                a.length < r ? a.push(c) : (h = ~~((o + 1) * Ni()), h < a.length && h >= l && (f = a[h], s[ge(f)] && n.rem.push(f), a[h] = c)), ++o
-            }
-            if (t.rem.length && (t.visit(t.REM, c => {
-                    const f = ge(c);
-                    s[f] && (s[f] = -1, n.rem.push(c)), --o
-                }), a = a.filter(c => s[ge(c)] !== -1)), (t.rem.length || i) && a.length < r && t.source && (l = o = a.length, t.visit(t.SOURCE, c => {
-                    s[ge(c)] || u(c)
-                }), l = -1), i && a.length > r) {
-                const c = a.length - r;
-                for (let f = 0; f < c; ++f) s[ge(a[f])] = -1, n.rem.push(a[f]);
-                a = a.slice(c)
+    function WQ(e) {
+        return e.y + e.vy
+    }
+
+    function qQ(e) {
+        var t, n, i, r = 1,
+            s = 1;
+        typeof e != "function" && (e = Hn(e == null ? 1 : +e));
+
+        function a() {
+            for (var u, c = t.length, f, h, d, g, p, m, y = 0; y < s; ++y)
+                for (f = oE(t, UQ, WQ).visitAfter(o), u = 0; u < c; ++u) h = t[u], p = n[h.index], m = p * p, d = h.x + h.vx, g = h.y + h.vy, f.visit(v);
+
+            function v(b, x, _, S, w) {
+                var E = b.data,
+                    C = b.r,
+                    k = p + C;
+                if (E) {
+                    if (E.index > h.index) {
+                        var A = d - E.x - E.vx,
+                            F = g - E.y - E.vy,
+                            $ = A * A + F * F;
+                        $ < k * k && (A === 0 && (A = Ia(i), $ += A * A), F === 0 && (F = Ia(i), $ += F * F), $ = (k - ($ = Math.sqrt($))) / $ * r, h.vx += (A *= $) * (k = (C *= C) / (m + C)), h.vy += (F *= $) * k, E.vx -= A * (k = 1 - k), E.vy -= F * k)
+                    }
+                    return
+                }
+                return x > d + k || S < d - k || _ > g + k || w < g - k
             }
-            return t.mod.length && t.visit(t.MOD, c => {
-                s[ge(c)] && n.mod.push(c)
-            }), t.add.length && t.visit(t.ADD, u), (t.add.length || l < 0) && (n.add = a.filter(c => !s[ge(c)])), this.count = o, this.value = n.source = a, n
         }
-    });
 
-    function hw(e) {
-        L.call(this, null, e)
-    }
-    hw.Definition = {
-        type: "Sequence",
-        metadata: {
-            generates: !0,
-            changes: !0
-        },
-        params: [{
-            name: "start",
-            type: "number",
-            required: !0
-        }, {
-            name: "stop",
-            type: "number",
-            required: !0
-        }, {
-            name: "step",
-            type: "number",
-            default: 1
-        }, {
-            name: "as",
-            type: "string",
-            default: "data"
-        }]
-    };
-    ee(hw, L, {
-        transform(e, t) {
-            if (this.value && !e.modified()) return;
-            const n = t.materialize().fork(t.MOD),
-                i = e.as || "data";
-            return n.rem = this.value ? t.rem.concat(this.value) : t.rem, this.value = gi(e.start, e.stop, e.step || 1).map(r => {
-                const s = {};
-                return s[i] = r, He(s)
-            }), n.add = t.add.concat(this.value), n
+        function o(u) {
+            if (u.data) return u.r = n[u.data.index];
+            for (var c = u.r = 0; c < 4; ++c) u[c] && u[c].r > u.r && (u.r = u[c].r)
         }
-    });
 
-    function MN(e) {
-        L.call(this, null, e), this.modified(!0)
-    }
-    ee(MN, L, {
-        transform(e, t) {
-            return this.value = t.source, t.changed() ? t.fork(t.NO_SOURCE | t.NO_FIELDS) : t.StopPropagation
+        function l() {
+            if (t) {
+                var u, c = t.length,
+                    f;
+                for (n = new Array(c), u = 0; u < c; ++u) f = t[u], n[f.index] = +e(f, u, t)
+            }
         }
-    });
+        return a.initialize = function(u, c) {
+            t = u, i = c, l()
+        }, a.iterations = function(u) {
+            return arguments.length ? (s = +u, a) : s
+        }, a.strength = function(u) {
+            return arguments.length ? (r = +u, a) : r
+        }, a.radius = function(u) {
+            return arguments.length ? (e = typeof u == "function" ? u : Hn(+u), l(), a) : e
+        }, a
+    }
 
-    function dw(e) {
-        L.call(this, null, e)
+    function HQ(e) {
+        return e.index
     }
-    const ON = ["unit0", "unit1"];
-    dw.Definition = {
-        type: "TimeUnit",
-        metadata: {
-            modifies: !0
-        },
-        params: [{
-            name: "field",
-            type: "field",
-            required: !0
-        }, {
-            name: "interval",
-            type: "boolean",
-            default: !0
-        }, {
-            name: "units",
-            type: "enum",
-            values: y_,
-            array: !0
-        }, {
-            name: "step",
-            type: "number",
-            default: 1
-        }, {
-            name: "maxbins",
-            type: "number",
-            default: 40
-        }, {
-            name: "extent",
-            type: "date",
-            array: !0
-        }, {
-            name: "timezone",
-            type: "enum",
-            default: "local",
-            values: ["local", "utc"]
-        }, {
-            name: "as",
-            type: "string",
-            array: !0,
-            length: 2,
-            default: ON
-        }]
-    };
-    ee(dw, L, {
-        transform(e, t) {
-            const n = e.field,
-                i = e.interval !== !1,
-                r = e.timezone === "utc",
-                s = this._floor(e, t),
-                a = (r ? Sc : wc)(s.unit).offset,
-                o = e.as || ON,
-                l = o[0],
-                u = o[1],
-                c = s.step;
-            let f = s.start || 1 / 0,
-                h = s.stop || -1 / 0,
-                d = t.ADD;
-            return (e.modified() || t.changed(t.REM) || t.modified(pn(n))) && (t = t.reflow(!0), d = t.SOURCE, f = 1 / 0, h = -1 / 0), t.visit(d, g => {
-                const p = n(g);
-                let m, y;
-                p == null ? (g[l] = null, i && (g[u] = null)) : (g[l] = m = y = s(p), i && (g[u] = y = a(m, c)), m < f && (f = m), y > h && (h = y))
-            }), s.start = f, s.stop = h, t.modifies(i ? o : l)
-        },
-        _floor(e, t) {
-            const n = e.timezone === "utc",
-                {
-                    units: i,
-                    step: r
-                } = e.units ? {
-                    units: e.units,
-                    step: e.step || 1
-                } : $D({
-                    extent: e.extent || Hr(t.materialize(t.SOURCE).source, e.field),
-                    maxbins: e.maxbins
-                }),
-                s = v_(i),
-                a = this.value || {},
-                o = (n ? bD : vD)(s, r);
-            return o.unit = De(s), o.units = s, o.step = r, o.start = a.start, o.stop = a.stop, this.value = o
-        }
-    });
 
-    function FN(e) {
-        L.call(this, _c(), e)
+    function TT(e, t) {
+        var n = e.get(t);
+        if (!n) throw new Error("node not found: " + t);
+        return n
     }
-    ee(FN, L, {
-        transform(e, t) {
-            const n = t.dataflow,
-                i = e.field,
-                r = this.value,
-                s = o => r.set(i(o), o);
-            let a = !0;
-            return e.modified("field") || t.modified(i.fields) ? (r.clear(), t.visit(t.SOURCE, s)) : t.changed() ? (t.visit(t.REM, o => r.delete(i(o))), t.visit(t.ADD, s)) : a = !1, this.modified(a), r.empty > n.cleanThreshold && n.runAfter(r.clean), t.fork()
+
+    function YQ(e) {
+        var t = HQ,
+            n = f,
+            i, r = Hn(30),
+            s, a, o, l, u, c = 1;
+        e == null && (e = []);
+
+        function f(m) {
+            return 1 / Math.min(o[m.source.index], o[m.target.index])
         }
-    });
 
-    function RN(e) {
-        L.call(this, null, e)
-    }
-    ee(RN, L, {
-        transform(e, t) {
-            (!this.value || e.modified("field") || e.modified("sort") || t.changed() || e.sort && t.modified(e.sort.fields)) && (this.value = (e.sort ? t.source.slice().sort($l(e.sort)) : t.source).map(e.field))
+        function h(m) {
+            for (var y = 0, v = e.length; y < c; ++y)
+                for (var b = 0, x, _, S, w, E, C, k; b < v; ++b) x = e[b], _ = x.source, S = x.target, w = S.x + S.vx - _.x - _.vx || Ia(u), E = S.y + S.vy - _.y - _.vy || Ia(u), C = Math.sqrt(w * w + E * E), C = (C - s[b]) / C * m * i[b], w *= C, E *= C, S.vx -= w * (k = l[b]), S.vy -= E * k, _.vx += w * (k = 1 - k), _.vy += E * k
         }
-    });
 
-    function hK(e, t, n, i) {
-        const r = Ch[e](t, n);
-        return {
-            init: r.init || ha,
-            update: function(s, a) {
-                a[i] = r.next(s)
+        function d() {
+            if (a) {
+                var m, y = a.length,
+                    v = e.length,
+                    b = new Map(a.map((_, S) => [t(_, S, a), _])),
+                    x;
+                for (m = 0, o = new Array(y); m < v; ++m) x = e[m], x.index = m, typeof x.source != "object" && (x.source = TT(b, x.source)), typeof x.target != "object" && (x.target = TT(b, x.target)), o[x.source.index] = (o[x.source.index] || 0) + 1, o[x.target.index] = (o[x.target.index] || 0) + 1;
+                for (m = 0, l = new Array(v); m < v; ++m) x = e[m], l[m] = o[x.source.index] / (o[x.source.index] + o[x.target.index]);
+                i = new Array(v), g(), s = new Array(v), p()
             }
         }
+
+        function g() {
+            if (a)
+                for (var m = 0, y = e.length; m < y; ++m) i[m] = +n(e[m], m, e)
+        }
+
+        function p() {
+            if (a)
+                for (var m = 0, y = e.length; m < y; ++m) s[m] = +r(e[m], m, e)
+        }
+        return h.initialize = function(m, y) {
+            a = m, u = y, d()
+        }, h.links = function(m) {
+            return arguments.length ? (e = m, d(), h) : e
+        }, h.id = function(m) {
+            return arguments.length ? (t = m, h) : t
+        }, h.iterations = function(m) {
+            return arguments.length ? (c = +m, h) : c
+        }, h.strength = function(m) {
+            return arguments.length ? (n = typeof m == "function" ? m : Hn(+m), g(), h) : n
+        }, h.distance = function(m) {
+            return arguments.length ? (r = typeof m == "function" ? m : Hn(+m), p(), h) : r
+        }, h
     }
-    const Ch = {
-        row_number: function() {
-            return {
-                next: e => e.index + 1
-            }
-        },
-        rank: function() {
-            let e;
-            return {
-                init: () => e = 1,
-                next: t => {
-                    const n = t.index,
-                        i = t.data;
-                    return n && t.compare(i[n - 1], i[n]) ? e = n + 1 : e
-                }
-            }
-        },
-        dense_rank: function() {
-            let e;
-            return {
-                init: () => e = 1,
-                next: t => {
-                    const n = t.index,
-                        i = t.data;
-                    return n && t.compare(i[n - 1], i[n]) ? ++e : e
-                }
-            }
-        },
-        percent_rank: function() {
-            const e = Ch.rank(),
-                t = e.next;
-            return {
-                init: e.init,
-                next: n => (t(n) - 1) / (n.data.length - 1)
-            }
-        },
-        cume_dist: function() {
-            let e;
+    var XQ = {
+        value: () => {}
+    };
+
+    function cL() {
+        for (var e = 0, t = arguments.length, n = {}, i; e < t; ++e) {
+            if (!(i = arguments[e] + "") || i in n || /[\s.]/.test(i)) throw new Error("illegal type: " + i);
+            n[i] = []
+        }
+        return new Rp(n)
+    }
+
+    function Rp(e) {
+        this._ = e
+    }
+
+    function VQ(e, t) {
+        return e.trim().split(/^|\s+/).map(function(n) {
+            var i = "",
+                r = n.indexOf(".");
+            if (r >= 0 && (i = n.slice(r + 1), n = n.slice(0, r)), n && !t.hasOwnProperty(n)) throw new Error("unknown type: " + n);
             return {
-                init: () => e = 0,
-                next: t => {
-                    const n = t.data,
-                        i = t.compare;
-                    let r = t.index;
-                    if (e < r) {
-                        for (; r + 1 < n.length && !i(n[r], n[r + 1]);) ++r;
-                        e = r
-                    }
-                    return (1 + e) / n.length
-                }
+                type: n,
+                name: i
             }
-        },
-        ntile: function(e, t) {
-            t = +t, t > 0 || U("ntile num must be greater than zero.");
-            const n = Ch.cume_dist(),
-                i = n.next;
-            return {
-                init: n.init,
-                next: r => Math.ceil(t * i(r))
+        })
+    }
+    Rp.prototype = cL.prototype = {
+        constructor: Rp,
+        on: function(e, t) {
+            var n = this._,
+                i = VQ(e + "", n),
+                r, s = -1,
+                a = i.length;
+            if (arguments.length < 2) {
+                for (; ++s < a;)
+                    if ((r = (e = i[s]).type) && (r = KQ(n[r], e.name))) return r;
+                return
             }
+            if (t != null && typeof t != "function") throw new Error("invalid callback: " + t);
+            for (; ++s < a;)
+                if (r = (e = i[s]).type) n[r] = MT(n[r], e.name, t);
+                else if (t == null)
+                for (r in n) n[r] = MT(n[r], e.name, null);
+            return this
         },
-        lag: function(e, t) {
-            return t = +t || 1, {
-                next: n => {
-                    const i = n.index - t;
-                    return i >= 0 ? e(n.data[i]) : null
-                }
-            }
+        copy: function() {
+            var e = {},
+                t = this._;
+            for (var n in t) e[n] = t[n].slice();
+            return new Rp(e)
         },
-        lead: function(e, t) {
-            return t = +t || 1, {
-                next: n => {
-                    const i = n.index + t,
-                        r = n.data;
-                    return i < r.length ? e(r[i]) : null
-                }
-            }
+        call: function(e, t) {
+            if ((r = arguments.length - 2) > 0)
+                for (var n = new Array(r), i = 0, r, s; i < r; ++i) n[i] = arguments[i + 2];
+            if (!this._.hasOwnProperty(e)) throw new Error("unknown type: " + e);
+            for (s = this._[e], i = 0, r = s.length; i < r; ++i) s[i].value.apply(t, n)
         },
-        first_value: function(e) {
-            return {
-                next: t => e(t.data[t.i0])
-            }
+        apply: function(e, t, n) {
+            if (!this._.hasOwnProperty(e)) throw new Error("unknown type: " + e);
+            for (var i = this._[e], r = 0, s = i.length; r < s; ++r) i[r].value.apply(t, n)
+        }
+    };
+
+    function KQ(e, t) {
+        for (var n = 0, i = e.length, r; n < i; ++n)
+            if ((r = e[n]).name === t) return r.value
+    }
+
+    function MT(e, t, n) {
+        for (var i = 0, r = e.length; i < r; ++i)
+            if (e[i].name === t) {
+                e[i] = XQ, e = e.slice(0, i).concat(e.slice(i + 1));
+                break
+            } return n != null && e.push({
+            name: t,
+            value: n
+        }), e
+    }
+    var _c = 0,
+        lh = 0,
+        Tf = 0,
+        fL = 1e3,
+        r0, uh, s0 = 0,
+        Al = 0,
+        D1 = 0,
+        rd = typeof performance == "object" && performance.now ? performance : Date,
+        hL = typeof window == "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(e) {
+            setTimeout(e, 17)
+        };
+
+    function uE() {
+        return Al || (hL(JQ), Al = rd.now() + D1)
+    }
+
+    function JQ() {
+        Al = 0
+    }
+
+    function a0() {
+        this._call = this._time = this._next = null
+    }
+    a0.prototype = dL.prototype = {
+        constructor: a0,
+        restart: function(e, t, n) {
+            if (typeof e != "function") throw new TypeError("callback is not a function");
+            n = (n == null ? uE() : +n) + (t == null ? 0 : +t), !this._next && uh !== this && (uh ? uh._next = this : r0 = this, uh = this), this._call = e, this._time = n, V2()
         },
-        last_value: function(e) {
-            return {
-                next: t => e(t.data[t.i1 - 1])
+        stop: function() {
+            this._call && (this._call = null, this._time = 1 / 0, V2())
+        }
+    };
+
+    function dL(e, t, n) {
+        var i = new a0;
+        return i.restart(e, t, n), i
+    }
+
+    function QQ() {
+        uE(), ++_c;
+        for (var e = r0, t; e;)(t = Al - e._time) >= 0 && e._call.call(void 0, t), e = e._next;
+        --_c
+    }
+
+    function OT() {
+        Al = (s0 = rd.now()) + D1, _c = lh = 0;
+        try {
+            QQ()
+        } finally {
+            _c = 0, eZ(), Al = 0
+        }
+    }
+
+    function ZQ() {
+        var e = rd.now(),
+            t = e - s0;
+        t > fL && (D1 -= t, s0 = e)
+    }
+
+    function eZ() {
+        for (var e, t = r0, n, i = 1 / 0; t;) t._call ? (i > t._time && (i = t._time), e = t, t = t._next) : (n = t._next, t._next = null, t = e ? e._next = n : r0 = n);
+        uh = e, V2(i)
+    }
+
+    function V2(e) {
+        if (!_c) {
+            lh && (lh = clearTimeout(lh));
+            var t = e - Al;
+            t > 24 ? (e < 1 / 0 && (lh = setTimeout(OT, e - rd.now() - D1)), Tf && (Tf = clearInterval(Tf))) : (Tf || (s0 = rd.now(), Tf = setInterval(ZQ, fL)), _c = 1, hL(OT))
+        }
+    }
+
+    function tZ(e, t, n) {
+        var i = new a0,
+            r = t;
+        return t == null ? (i.restart(e, t, n), i) : (i._restart = i.restart, i.restart = function(s, a, o) {
+            a = +a, o = o == null ? uE() : +o, i._restart(function l(u) {
+                u += r, i._restart(l, r += a, o), s(u)
+            }, a, o)
+        }, i.restart(e, t, n), i)
+    }
+    const nZ = 1664525,
+        iZ = 1013904223,
+        FT = 4294967296;
+
+    function rZ() {
+        let e = 1;
+        return () => (e = (nZ * e + iZ) % FT) / FT
+    }
+
+    function sZ(e) {
+        return e.x
+    }
+
+    function aZ(e) {
+        return e.y
+    }
+    var oZ = 10,
+        lZ = Math.PI * (3 - Math.sqrt(5));
+
+    function uZ(e) {
+        var t, n = 1,
+            i = .001,
+            r = 1 - Math.pow(i, 1 / 300),
+            s = 0,
+            a = .6,
+            o = new Map,
+            l = dL(f),
+            u = cL("tick", "end"),
+            c = rZ();
+        e == null && (e = []);
+
+        function f() {
+            h(), u.call("tick", t), n < i && (l.stop(), u.call("end", t))
+        }
+
+        function h(p) {
+            var m, y = e.length,
+                v;
+            p === void 0 && (p = 1);
+            for (var b = 0; b < p; ++b)
+                for (n += (s - n) * r, o.forEach(function(x) {
+                        x(n)
+                    }), m = 0; m < y; ++m) v = e[m], v.fx == null ? v.x += v.vx *= a : (v.x = v.fx, v.vx = 0), v.fy == null ? v.y += v.vy *= a : (v.y = v.fy, v.vy = 0);
+            return t
+        }
+
+        function d() {
+            for (var p = 0, m = e.length, y; p < m; ++p) {
+                if (y = e[p], y.index = p, y.fx != null && (y.x = y.fx), y.fy != null && (y.y = y.fy), isNaN(y.x) || isNaN(y.y)) {
+                    var v = oZ * Math.sqrt(.5 + p),
+                        b = p * lZ;
+                    y.x = v * Math.cos(b), y.y = v * Math.sin(b)
+                }(isNaN(y.vx) || isNaN(y.vy)) && (y.vx = y.vy = 0)
             }
-        },
-        nth_value: function(e, t) {
-            return t = +t, t > 0 || U("nth_value nth must be greater than zero."), {
-                next: n => {
-                    const i = n.i0 + (t - 1);
-                    return i < n.i1 ? e(n.data[i]) : null
-                }
+        }
+
+        function g(p) {
+            return p.initialize && p.initialize(e, c), p
+        }
+        return d(), t = {
+            tick: h,
+            restart: function() {
+                return l.restart(f), t
+            },
+            stop: function() {
+                return l.stop(), t
+            },
+            nodes: function(p) {
+                return arguments.length ? (e = p, d(), o.forEach(g), t) : e
+            },
+            alpha: function(p) {
+                return arguments.length ? (n = +p, t) : n
+            },
+            alphaMin: function(p) {
+                return arguments.length ? (i = +p, t) : i
+            },
+            alphaDecay: function(p) {
+                return arguments.length ? (r = +p, t) : +r
+            },
+            alphaTarget: function(p) {
+                return arguments.length ? (s = +p, t) : s
+            },
+            velocityDecay: function(p) {
+                return arguments.length ? (a = 1 - p, t) : 1 - a
+            },
+            randomSource: function(p) {
+                return arguments.length ? (c = p, o.forEach(g), t) : c
+            },
+            force: function(p, m) {
+                return arguments.length > 1 ? (m == null ? o.delete(p) : o.set(p, g(m)), t) : o.get(p)
+            },
+            find: function(p, m, y) {
+                var v = 0,
+                    b = e.length,
+                    x, _, S, w, E;
+                for (y == null ? y = 1 / 0 : y *= y, v = 0; v < b; ++v) w = e[v], x = p - w.x, _ = m - w.y, S = x * x + _ * _, S < y && (E = w, y = S);
+                return E
+            },
+            on: function(p, m) {
+                return arguments.length > 1 ? (u.on(p, m), t) : u.on(p)
             }
-        },
-        prev_value: function(e) {
-            let t;
-            return {
-                init: () => t = null,
-                next: n => {
-                    const i = e(n.data[n.index]);
-                    return i != null ? t = i : t
-                }
+        }
+    }
+
+    function cZ() {
+        var e, t, n, i, r = Hn(-30),
+            s, a = 1,
+            o = 1 / 0,
+            l = .81;
+
+        function u(d) {
+            var g, p = e.length,
+                m = oE(e, sZ, aZ).visitAfter(f);
+            for (i = d, g = 0; g < p; ++g) t = e[g], m.visit(h)
+        }
+
+        function c() {
+            if (e) {
+                var d, g = e.length,
+                    p;
+                for (s = new Array(g), d = 0; d < g; ++d) p = e[d], s[p.index] = +r(p, d, e)
             }
-        },
-        next_value: function(e) {
-            let t, n;
-            return {
-                init: () => (t = null, n = -1),
-                next: i => {
-                    const r = i.data;
-                    return i.index <= n ? t : (n = dK(e, r, i.index)) < 0 ? (n = r.length, t = null) : t = e(r[n])
-                }
+        }
+
+        function f(d) {
+            var g = 0,
+                p, m, y = 0,
+                v, b, x;
+            if (d.length) {
+                for (v = b = x = 0; x < 4; ++x)(p = d[x]) && (m = Math.abs(p.value)) && (g += p.value, y += m, v += m * p.x, b += m * p.y);
+                d.x = v / y, d.y = b / y
+            } else {
+                p = d, p.x = p.data.x, p.y = p.data.y;
+                do g += s[p.data.index]; while (p = p.next)
             }
+            d.value = g
         }
-    };
 
-    function dK(e, t, n) {
-        for (let i = t.length; n < i; ++n)
-            if (e(t[n]) != null) return n;
-        return -1
+        function h(d, g, p, m) {
+            if (!d.value) return !0;
+            var y = d.x - t.x,
+                v = d.y - t.y,
+                b = m - g,
+                x = y * y + v * v;
+            if (b * b / l < x) return x < o && (y === 0 && (y = Ia(n), x += y * y), v === 0 && (v = Ia(n), x += v * v), x < a && (x = Math.sqrt(a * x)), t.vx += y * d.value * i / x, t.vy += v * d.value * i / x), !0;
+            if (d.length || x >= o) return;
+            (d.data !== t || d.next) && (y === 0 && (y = Ia(n), x += y * y), v === 0 && (v = Ia(n), x += v * v), x < a && (x = Math.sqrt(a * x)));
+            do d.data !== t && (b = s[d.data.index] * i / x, t.vx += y * b, t.vy += v * b); while (d = d.next)
+        }
+        return u.initialize = function(d, g) {
+            e = d, n = g, c()
+        }, u.strength = function(d) {
+            return arguments.length ? (r = typeof d == "function" ? d : Hn(+d), c(), u) : r
+        }, u.distanceMin = function(d) {
+            return arguments.length ? (a = d * d, u) : Math.sqrt(a)
+        }, u.distanceMax = function(d) {
+            return arguments.length ? (o = d * d, u) : Math.sqrt(o)
+        }, u.theta = function(d) {
+            return arguments.length ? (l = d * d, u) : Math.sqrt(l)
+        }, u
     }
-    const gK = Object.keys(Ch);
 
-    function DN(e) {
-        const t = se(e.ops),
-            n = se(e.fields),
-            i = se(e.params),
-            r = se(e.as),
-            s = this.outputs = [],
-            a = this.windows = [],
-            o = {},
-            l = {},
-            u = [],
-            c = [];
-        let f = !0;
+    function fZ(e) {
+        var t = Hn(.1),
+            n, i, r;
+        typeof e != "function" && (e = Hn(e == null ? 0 : +e));
 
-        function h(d) {
-            se(pn(d)).forEach(g => o[g] = 1)
+        function s(o) {
+            for (var l = 0, u = n.length, c; l < u; ++l) c = n[l], c.vx += (r[l] - c.x) * i[l] * o
         }
-        h(e.sort), t.forEach((d, g) => {
-            const p = n[g],
-                m = bt(p),
-                y = uN(d, m, r[g]);
-            if (h(p), s.push(y), me(Ch, d)) a.push(hK(d, n[g], i[g], y));
-            else {
-                if (p == null && d !== "count" && U("Null aggregate field specified."), d === "count") {
-                    u.push(y);
-                    return
-                }
-                f = !1;
-                let v = l[m];
-                v || (v = l[m] = [], v.field = p, c.push(v)), v.push(cN(d, y))
+
+        function a() {
+            if (n) {
+                var o, l = n.length;
+                for (i = new Array(l), r = new Array(l), o = 0; o < l; ++o) i[o] = isNaN(r[o] = +e(n[o], o, n)) ? 0 : +t(n[o], o, n)
             }
-        }), (u.length || c.length) && (this.cell = pK(c, u, f)), this.inputs = Object.keys(o)
+        }
+        return s.initialize = function(o) {
+            n = o, a()
+        }, s.strength = function(o) {
+            return arguments.length ? (t = typeof o == "function" ? o : Hn(+o), a(), s) : t
+        }, s.x = function(o) {
+            return arguments.length ? (e = typeof o == "function" ? o : Hn(+o), a(), s) : e
+        }, s
     }
-    const NN = DN.prototype;
-    NN.init = function() {
-        this.windows.forEach(e => e.init()), this.cell && this.cell.init()
-    };
-    NN.update = function(e, t) {
-        const n = this.cell,
-            i = this.windows,
-            r = e.data,
-            s = i && i.length;
-        let a;
-        if (n) {
-            for (a = e.p0; a < e.i0; ++a) n.rem(r[a]);
-            for (a = e.p1; a < e.i1; ++a) n.add(r[a]);
-            n.set(t)
+
+    function hZ(e) {
+        var t = Hn(.1),
+            n, i, r;
+        typeof e != "function" && (e = Hn(e == null ? 0 : +e));
+
+        function s(o) {
+            for (var l = 0, u = n.length, c; l < u; ++l) c = n[l], c.vy += (r[l] - c.y) * i[l] * o
         }
-        for (a = 0; a < s; ++a) i[a].update(e, t)
-    };
 
-    function pK(e, t, n) {
-        e = e.map(l => hN(l, l.field));
-        const i = {
-            num: 0,
-            agg: null,
-            store: !1,
-            count: t
-        };
-        if (!n)
-            for (var r = e.length, s = i.agg = Array(r), a = 0; a < r; ++a) s[a] = new e[a](i);
-        if (i.store) var o = i.data = new W_;
-        return i.add = function(l) {
-            if (i.num += 1, !n) {
-                o && o.add(l);
-                for (let u = 0; u < r; ++u) s[u].add(s[u].get(l), l)
-            }
-        }, i.rem = function(l) {
-            if (i.num -= 1, !n) {
-                o && o.rem(l);
-                for (let u = 0; u < r; ++u) s[u].rem(s[u].get(l), l)
+        function a() {
+            if (n) {
+                var o, l = n.length;
+                for (i = new Array(l), r = new Array(l), o = 0; o < l; ++o) i[o] = isNaN(r[o] = +e(n[o], o, n)) ? 0 : +t(n[o], o, n)
             }
-        }, i.set = function(l) {
-            let u, c;
-            for (o && o.values(), u = 0, c = t.length; u < c; ++u) l[t[u]] = i.num;
-            if (!n)
-                for (u = 0, c = s.length; u < c; ++u) s[u].set(l)
-        }, i.init = function() {
-            i.num = 0, o && o.reset();
-            for (let l = 0; l < r; ++l) s[l].init()
-        }, i
+        }
+        return s.initialize = function(o) {
+            n = o, a()
+        }, s.strength = function(o) {
+            return arguments.length ? (t = typeof o == "function" ? o : Hn(+o), a(), s) : t
+        }, s.y = function(o) {
+            return arguments.length ? (e = typeof o == "function" ? o : Hn(+o), a(), s) : e
+        }, s
     }
+    const RT = {
+            center: CQ,
+            collide: qQ,
+            nbody: cZ,
+            link: YQ,
+            x: fZ,
+            y: hZ
+        },
+        ch = "forces",
+        K2 = ["alpha", "alphaMin", "alphaTarget", "velocityDecay", "forces"],
+        dZ = ["static", "iterations"],
+        gL = ["x", "y", "vx", "vy"];
 
-    function gw(e) {
-        L.call(this, {}, e), this._mlen = 0, this._mods = []
+    function cE(e) {
+        j.call(this, null, e)
     }
-    gw.Definition = {
-        type: "Window",
+    cE.Definition = {
+        type: "Force",
         metadata: {
             modifies: !0
         },
         params: [{
-            name: "sort",
-            type: "compare"
+            name: "static",
+            type: "boolean",
+            default: !1
         }, {
-            name: "groupby",
-            type: "field",
-            array: !0
+            name: "restart",
+            type: "boolean",
+            default: !1
         }, {
-            name: "ops",
-            type: "enum",
-            array: !0,
-            values: gK.concat(ud)
+            name: "iterations",
+            type: "number",
+            default: 300
         }, {
-            name: "params",
+            name: "alpha",
             type: "number",
-            null: !0,
-            array: !0
+            default: 1
         }, {
-            name: "fields",
-            type: "field",
-            null: !0,
-            array: !0
+            name: "alphaMin",
+            type: "number",
+            default: .001
         }, {
-            name: "as",
-            type: "string",
-            null: !0,
-            array: !0
+            name: "alphaTarget",
+            type: "number",
+            default: 0
         }, {
-            name: "frame",
+            name: "velocityDecay",
             type: "number",
-            null: !0,
+            default: .4
+        }, {
+            name: "forces",
+            type: "param",
             array: !0,
-            length: 2,
-            default: [null, 0]
+            params: [{
+                key: {
+                    force: "center"
+                },
+                params: [{
+                    name: "x",
+                    type: "number",
+                    default: 0
+                }, {
+                    name: "y",
+                    type: "number",
+                    default: 0
+                }]
+            }, {
+                key: {
+                    force: "collide"
+                },
+                params: [{
+                    name: "radius",
+                    type: "number",
+                    expr: !0
+                }, {
+                    name: "strength",
+                    type: "number",
+                    default: .7
+                }, {
+                    name: "iterations",
+                    type: "number",
+                    default: 1
+                }]
+            }, {
+                key: {
+                    force: "nbody"
+                },
+                params: [{
+                    name: "strength",
+                    type: "number",
+                    default: -30,
+                    expr: !0
+                }, {
+                    name: "theta",
+                    type: "number",
+                    default: .9
+                }, {
+                    name: "distanceMin",
+                    type: "number",
+                    default: 1
+                }, {
+                    name: "distanceMax",
+                    type: "number"
+                }]
+            }, {
+                key: {
+                    force: "link"
+                },
+                params: [{
+                    name: "links",
+                    type: "data"
+                }, {
+                    name: "id",
+                    type: "field"
+                }, {
+                    name: "distance",
+                    type: "number",
+                    default: 30,
+                    expr: !0
+                }, {
+                    name: "strength",
+                    type: "number",
+                    expr: !0
+                }, {
+                    name: "iterations",
+                    type: "number",
+                    default: 1
+                }]
+            }, {
+                key: {
+                    force: "x"
+                },
+                params: [{
+                    name: "strength",
+                    type: "number",
+                    default: .1
+                }, {
+                    name: "x",
+                    type: "field"
+                }]
+            }, {
+                key: {
+                    force: "y"
+                },
+                params: [{
+                    name: "strength",
+                    type: "number",
+                    default: .1
+                }, {
+                    name: "y",
+                    type: "field"
+                }]
+            }]
         }, {
-            name: "ignorePeers",
-            type: "boolean",
-            default: !1
+            name: "as",
+            type: "string",
+            array: !0,
+            modify: !1,
+            default: gL
         }]
     };
-    ee(gw, L, {
+    ne(cE, j, {
         transform(e, t) {
-            this.stamp = t.stamp;
-            const n = e.modified(),
-                i = $l(e.sort),
-                r = e2(e.groupby),
-                s = o => this.group(r(o));
-            let a = this.state;
-            (!a || n) && (a = this.state = new DN(e)), n || t.modified(a.inputs) ? (this.value = {}, t.visit(t.SOURCE, o => s(o).add(o))) : (t.visit(t.REM, o => s(o).remove(o)), t.visit(t.ADD, o => s(o).add(o)));
-            for (let o = 0, l = this._mlen; o < l; ++o) mK(this._mods[o], a, i, e);
-            return this._mlen = 0, this._mods = [], t.reflow(n).modifies(a.outputs)
+            var n = this.value,
+                i = t.changed(t.ADD_REM),
+                r = e.modified(K2),
+                s = e.iterations || 300;
+            if (n ? (i && (t.modifies("index"), n.nodes(t.source)), (r || t.changed(t.MOD)) && pL(n, e, 0, t)) : (this.value = n = pZ(t.source, e), n.on("tick", gZ(t.dataflow, this)), e.static || (i = !0, n.tick()), t.modifies("index")), r || i || e.modified(dZ) || t.changed() && e.restart) {
+                if (n.alpha(Math.max(n.alpha(), e.alpha || 1)).alphaDecay(1 - Math.pow(n.alphaMin(), 1 / s)), e.static)
+                    for (n.stop(); --s >= 0;) n.tick();
+                else if (n.stopped() && n.restart(), !i) return t.StopPropagation
+            }
+            return this.finish(e, t)
         },
-        group(e) {
-            let t = this.value[e];
-            return t || (t = this.value[e] = dN(ge), t.stamp = -1), t.stamp < this.stamp && (t.stamp = this.stamp, this._mods[this._mlen++] = t), t
+        finish(e, t) {
+            const n = t.dataflow;
+            for (let o = this._argops, l = 0, u = o.length, c; l < u; ++l)
+                if (c = o[l], !(c.name !== ch || c.op._argval.force !== "link")) {
+                    for (var i = c.op._argops, r = 0, s = i.length, a; r < s; ++r)
+                        if (i[r].name === "links" && (a = i[r].op.source)) {
+                            n.pulse(a, n.changeset().reflow());
+                            break
+                        }
+                } return t.reflow(e.modified()).modifies(gL)
         }
     });
 
-    function mK(e, t, n, i) {
-        const r = i.sort,
-            s = r && !i.ignorePeers,
-            a = i.frame || [null, 0],
-            o = e.data(n),
-            l = o.length,
-            u = s ? Qh(r) : null,
-            c = {
-                i0: 0,
-                i1: 0,
-                p0: 0,
-                p1: 0,
-                index: 0,
-                data: o,
-                compare: r || xn(-1)
-            };
-        t.init();
-        for (let f = 0; f < l; ++f) yK(c, a, f, l), s && vK(c, u), t.update(c, o[f])
+    function gZ(e, t) {
+        return () => e.touch(t).run()
     }
 
-    function yK(e, t, n, i) {
-        e.p0 = e.i0, e.p1 = e.i1, e.i0 = t[0] == null ? 0 : Math.max(0, n - Math.abs(t[0])), e.i1 = t[1] == null ? i : Math.min(i, n + Math.abs(t[1]) + 1), e.index = n
+    function pZ(e, t) {
+        const n = uZ(e),
+            i = n.stop,
+            r = n.restart;
+        let s = !1;
+        return n.stopped = () => s, n.restart = () => (s = !1, r()), n.stop = () => (s = !0, i()), pL(n, t, !0).on("end", () => s = !0)
     }
 
-    function vK(e, t) {
-        const n = e.i0,
-            i = e.i1 - 1,
-            r = e.compare,
-            s = e.data,
-            a = s.length - 1;
-        n > 0 && !r(s[n], s[n - 1]) && (e.i0 = t.left(s, s[n])), i < a && !r(s[i], s[i + 1]) && (e.i1 = t.right(s, s[i]))
+    function pL(e, t, n, i) {
+        var r = ue(t.forces),
+            s, a, o, l;
+        for (s = 0, a = K2.length; s < a; ++s) o = K2[s], o !== ch && t.modified(o) && e[o](t[o]);
+        for (s = 0, a = r.length; s < a; ++s) l = ch + s, o = n || t.modified(ch, s) ? yZ(r[s]) : i && mZ(r[s], i) ? e.force(l) : null, o && e.force(l, o);
+        for (a = e.numForces || 0; s < a; ++s) e.force(ch + s, null);
+        return e.numForces = r.length, e
     }
-    const bK = Object.freeze(Object.defineProperty({
+
+    function mZ(e, t) {
+        var n, i;
+        for (n in e)
+            if (Pe(i = e[n]) && t.modified(Fn(i))) return 1;
+        return 0
+    }
+
+    function yZ(e) {
+        var t, n;
+        Ce(RT, e.force) || q("Unrecognized force: " + e.force), t = RT[e.force]();
+        for (n in e) Pe(t[n]) && vZ(t[n], e[n], e);
+        return t
+    }
+
+    function vZ(e, t, n) {
+        e(Pe(t) ? i => t(i, n) : t)
+    }
+    const bZ = Object.freeze(Object.defineProperty({
         __proto__: null,
-        aggregate: Ra,
-        bin: q_,
-        collect: H_,
-        compare: gN,
-        countpattern: Y_,
-        cross: X_,
-        density: V_,
-        dotbin: J_,
-        expression: bN,
-        extent: Q_,
-        facet: jm,
-        field: xN,
-        filter: ew,
-        flatten: tw,
-        fold: nw,
-        formula: iw,
-        generate: _N,
-        impute: rw,
-        joinaggregate: sw,
-        kde: aw,
-        key: wN,
-        load: SN,
-        lookup: ow,
-        multiextent: EN,
-        multivalues: CN,
-        params: kN,
-        pivot: lw,
-        prefacet: AN,
-        project: uw,
-        proxy: $N,
-        quantile: cw,
-        relay: TN,
-        sample: fw,
-        sequence: hw,
-        sieve: MN,
-        subflow: Z_,
-        timeunit: dw,
-        tupleindex: FN,
-        values: RN,
-        window: gw
+        force: cE
     }, Symbol.toStringTag, {
         value: "Module"
     }));
 
-    function ka(e, t) {
-        if (typeof document < "u" && document.createElement) {
-            const n = document.createElement("canvas");
-            if (n && n.getContext) return n.width = e, n.height = t, n
-        }
-        return null
+    function xZ(e, t) {
+        return e.parent === t.parent ? 1 : 2
     }
-    const xK = () => typeof Image < "u" ? Image : null;
 
-    function pw(e, t, n) {
-        const i = e - t + n * 2;
-        return e ? i > 0 ? i : 1 : 0
+    function _Z(e) {
+        return e.reduce(wZ, 0) / e.length
     }
-    const _K = "identity",
-        Gu = "linear",
-        zs = "log",
-        cd = "pow",
-        fd = "sqrt",
-        Um = "symlog",
-        tl = "time",
-        nl = "utc",
-        zr = "sequential",
-        Cc = "diverging",
-        Wu = "quantile",
-        Gm = "quantize",
-        Wm = "threshold",
-        mw = "ordinal",
-        t2 = "point",
-        PN = "band",
-        yw = "bin-ordinal",
-        Nt = "continuous",
-        hd = "discrete",
-        dd = "discretizing",
-        Ii = "interpolating",
-        vw = "temporal";
 
-    function wK(e) {
-        return function(t) {
-            let n = t[0],
-                i = t[1],
-                r;
-            return i < n && (r = n, n = i, i = r), [e.invert(n), e.invert(i)]
-        }
+    function wZ(e, t) {
+        return e + t.x
     }
 
-    function SK(e) {
-        return function(t) {
-            const n = e.range();
-            let i = t[0],
-                r = t[1],
-                s = -1,
-                a, o, l, u;
-            for (r < i && (o = i, i = r, r = o), l = 0, u = n.length; l < u; ++l) n[l] >= i && n[l] <= r && (s < 0 && (s = l), a = l);
-            if (!(s < 0)) return i = e.invertExtent(n[s]), r = e.invertExtent(n[a]), [i[0] === void 0 ? i[1] : i[0], r[1] === void 0 ? r[0] : r[1]]
-        }
+    function SZ(e) {
+        return 1 + e.reduce(EZ, 0)
     }
 
-    function bw() {
-        const e = dm().unknown(void 0),
-            t = e.domain,
-            n = e.range;
-        let i = [0, 1],
-            r, s, a = !1,
-            o = 0,
-            l = 0,
-            u = .5;
-        delete e.unknown;
+    function EZ(e, t) {
+        return Math.max(e, t.y)
+    }
 
-        function c() {
-            const f = t().length,
-                h = i[1] < i[0],
-                d = i[1 - h],
-                g = pw(f, o, l);
-            let p = i[h - 0];
-            r = (d - p) / (g || 1), a && (r = Math.floor(r)), p += (d - p - r * (f - o)) * u, s = r * (1 - o), a && (p = Math.round(p), s = Math.round(s));
-            const m = gi(f).map(y => p + r * y);
-            return n(h ? m.reverse() : m)
-        }
-        return e.domain = function(f) {
-            return arguments.length ? (t(f), c()) : t()
-        }, e.range = function(f) {
-            return arguments.length ? (i = [+f[0], +f[1]], c()) : i.slice()
-        }, e.rangeRound = function(f) {
-            return i = [+f[0], +f[1]], a = !0, c()
-        }, e.bandwidth = function() {
-            return s
-        }, e.step = function() {
-            return r
-        }, e.round = function(f) {
-            return arguments.length ? (a = !!f, c()) : a
-        }, e.padding = function(f) {
-            return arguments.length ? (l = Math.max(0, Math.min(1, f)), o = l, c()) : o
-        }, e.paddingInner = function(f) {
-            return arguments.length ? (o = Math.max(0, Math.min(1, f)), c()) : o
-        }, e.paddingOuter = function(f) {
-            return arguments.length ? (l = Math.max(0, Math.min(1, f)), c()) : l
-        }, e.align = function(f) {
-            return arguments.length ? (u = Math.max(0, Math.min(1, f)), c()) : u
-        }, e.invertRange = function(f) {
-            if (f[0] == null || f[1] == null) return;
-            const h = i[1] < i[0],
-                d = h ? n().reverse() : n(),
-                g = d.length - 1;
-            let p = +f[0],
-                m = +f[1],
-                y, v, b;
-            if (!(p !== p || m !== m) && (m < p && (b = p, p = m, m = b), !(m < d[0] || p > i[1 - h]))) return y = Math.max(0, wp(d, p) - 1), v = p === m ? y : wp(d, m) - 1, p - d[y] > s + 1e-10 && ++y, h && (b = y, y = g - v, v = g - b), y > v ? void 0 : t().slice(y, v + 1)
-        }, e.invert = function(f) {
-            const h = e.invertRange([f, f]);
-            return h && h[0]
-        }, e.copy = function() {
-            return bw().domain(t()).range(i).round(a).paddingInner(o).paddingOuter(l).align(u)
-        }, c()
+    function kZ(e) {
+        for (var t; t = e.children;) e = t[0];
+        return e
     }
 
-    function LN(e) {
-        const t = e.copy;
-        return e.padding = e.paddingOuter, delete e.paddingInner, e.copy = function() {
-            return LN(t())
-        }, e
+    function CZ(e) {
+        for (var t; t = e.children;) e = t[t.length - 1];
+        return e
     }
 
-    function EK() {
-        return LN(bw().paddingInner(1))
+    function AZ() {
+        var e = xZ,
+            t = 1,
+            n = 1,
+            i = !1;
+
+        function r(s) {
+            var a, o = 0;
+            s.eachAfter(function(h) {
+                var d = h.children;
+                d ? (h.x = _Z(d), h.y = SZ(d)) : (h.x = a ? o += e(h, a) : 0, h.y = 0, a = h)
+            });
+            var l = kZ(s),
+                u = CZ(s),
+                c = l.x - e(l, u) / 2,
+                f = u.x + e(u, l) / 2;
+            return s.eachAfter(i ? function(h) {
+                h.x = (h.x - s.x) * t, h.y = (s.y - h.y) * n
+            } : function(h) {
+                h.x = (h.x - c) / (f - c) * t, h.y = (1 - (s.y ? h.y / s.y : 1)) * n
+            })
+        }
+        return r.separation = function(s) {
+            return arguments.length ? (e = s, r) : e
+        }, r.size = function(s) {
+            return arguments.length ? (i = !1, t = +s[0], n = +s[1], r) : i ? null : [t, n]
+        }, r.nodeSize = function(s) {
+            return arguments.length ? (i = !0, t = +s[0], n = +s[1], r) : i ? [t, n] : null
+        }, r
     }
-    var CK = Array.prototype.map;
 
-    function kK(e) {
-        return CK.call(e, hn)
+    function $Z(e) {
+        var t = 0,
+            n = e.children,
+            i = n && n.length;
+        if (!i) t = 1;
+        else
+            for (; --i >= 0;) t += n[i].value;
+        e.value = t
     }
-    const AK = Array.prototype.slice;
 
-    function IN() {
-        let e = [],
-            t = [];
+    function TZ() {
+        return this.eachAfter($Z)
+    }
 
-        function n(i) {
-            return i == null || i !== i ? void 0 : t[(Zh(e, i) - 1) % t.length]
-        }
-        return n.domain = function(i) {
-            return arguments.length ? (e = kK(i), n) : e.slice()
-        }, n.range = function(i) {
-            return arguments.length ? (t = AK.call(i), n) : t.slice()
-        }, n.tickFormat = function(i, r) {
-            return KF(e[0], De(e), i ?? 10, r)
-        }, n.copy = function() {
-            return IN().domain(n.domain()).range(n.range())
-        }, n
+    function MZ(e, t) {
+        let n = -1;
+        for (const i of this) e.call(t, i, ++n, this);
+        return this
     }
-    const d0 = new Map,
-        zN = Symbol("vega_scale");
 
-    function BN(e) {
-        return e[zN] = !0, e
+    function OZ(e, t) {
+        for (var n = this, i = [n], r, s, a = -1; n = i.pop();)
+            if (e.call(t, n, ++a, this), r = n.children)
+                for (s = r.length - 1; s >= 0; --s) i.push(r[s]);
+        return this
     }
 
-    function $K(e) {
-        return e && e[zN] === !0
+    function FZ(e, t) {
+        for (var n = this, i = [n], r = [], s, a, o, l = -1; n = i.pop();)
+            if (r.push(n), s = n.children)
+                for (a = 0, o = s.length; a < o; ++a) i.push(s[a]);
+        for (; n = r.pop();) e.call(t, n, ++l, this);
+        return this
     }
 
-    function TK(e, t, n) {
-        const i = function() {
-            const s = t();
-            return s.invertRange || (s.invertRange = s.invert ? wK(s) : s.invertExtent ? SK(s) : void 0), s.type = e, BN(s)
-        };
-        return i.metadata = fr(se(n)), i
+    function RZ(e, t) {
+        let n = -1;
+        for (const i of this)
+            if (e.call(t, i, ++n, this)) return i
     }
 
-    function We(e, t, n) {
-        return arguments.length > 1 ? (d0.set(e, TK(e, t, n)), this) : jN(e) ? d0.get(e) : void 0
+    function DZ(e) {
+        return this.eachAfter(function(t) {
+            for (var n = +e(t.data) || 0, i = t.children, r = i && i.length; --r >= 0;) n += i[r].value;
+            t.value = n
+        })
     }
-    We(_K, QF);
-    We(Gu, JF, Nt);
-    We(zs, eR, [Nt, zs]);
-    We(cd, Wx, Nt);
-    We(fd, mq, Nt);
-    We(Um, tR, Nt);
-    We(tl, OH, [Nt, vw]);
-    We(nl, FH, [Nt, vw]);
-    We(zr, Vx, [Nt, Ii]);
-    We(`${zr}-${Gu}`, Vx, [Nt, Ii]);
-    We(`${zr}-${zs}`, gR, [Nt, Ii, zs]);
-    We(`${zr}-${cd}`, Kx, [Nt, Ii]);
-    We(`${zr}-${fd}`, RH, [Nt, Ii]);
-    We(`${zr}-${Um}`, pR, [Nt, Ii]);
-    We(`${Cc}-${Gu}`, mR, [Nt, Ii]);
-    We(`${Cc}-${zs}`, yR, [Nt, Ii, zs]);
-    We(`${Cc}-${cd}`, Jx, [Nt, Ii]);
-    We(`${Cc}-${fd}`, DH, [Nt, Ii]);
-    We(`${Cc}-${Um}`, vR, [Nt, Ii]);
-    We(Wu, nR, [dd, Wu]);
-    We(Gm, iR, dd);
-    We(Wm, rR, dd);
-    We(yw, IN, [hd, dd]);
-    We(mw, dm, hd);
-    We(PN, bw, hd);
-    We(t2, EK, hd);
 
-    function jN(e) {
-        return d0.has(e)
+    function NZ(e) {
+        return this.eachBefore(function(t) {
+            t.children && t.children.sort(e)
+        })
     }
 
-    function Ml(e, t) {
-        const n = d0.get(e);
-        return n && n.metadata[t]
+    function PZ(e) {
+        for (var t = this, n = LZ(t, e), i = [t]; t !== n;) t = t.parent, i.push(t);
+        for (var r = i.length; e !== n;) i.splice(r, 0, e), e = e.parent;
+        return i
     }
 
-    function xw(e) {
-        return Ml(e, Nt)
+    function LZ(e, t) {
+        if (e === t) return e;
+        var n = e.ancestors(),
+            i = t.ancestors(),
+            r = null;
+        for (e = n.pop(), t = i.pop(); e === t;) r = e, e = n.pop(), t = i.pop();
+        return r
     }
 
-    function qu(e) {
-        return Ml(e, hd)
+    function IZ() {
+        for (var e = this, t = [e]; e = e.parent;) t.push(e);
+        return t
     }
 
-    function n2(e) {
-        return Ml(e, dd)
+    function zZ() {
+        return Array.from(this)
     }
 
-    function UN(e) {
-        return Ml(e, zs)
+    function BZ() {
+        var e = [];
+        return this.eachBefore(function(t) {
+            t.children || e.push(t)
+        }), e
     }
 
-    function MK(e) {
-        return Ml(e, vw)
+    function jZ() {
+        var e = this,
+            t = [];
+        return e.each(function(n) {
+            n !== e && t.push({
+                source: n.parent,
+                target: n
+            })
+        }), t
     }
 
-    function GN(e) {
-        return Ml(e, Ii)
+    function* GZ() {
+        var e = this,
+            t, n = [e],
+            i, r, s;
+        do
+            for (t = n.reverse(), n = []; e = t.pop();)
+                if (yield e, i = e.children)
+                    for (r = 0, s = i.length; r < s; ++r) n.push(i[r]); while (n.length)
     }
 
-    function WN(e) {
-        return Ml(e, Wu)
+    function fE(e, t) {
+        e instanceof Map ? (e = [void 0, e], t === void 0 && (t = qZ)) : t === void 0 && (t = WZ);
+        for (var n = new wc(e), i, r = [n], s, a, o, l; i = r.pop();)
+            if ((a = t(i.data)) && (l = (a = Array.from(a)).length))
+                for (i.children = a, o = l - 1; o >= 0; --o) r.push(s = a[o] = new wc(a[o])), s.parent = i, s.depth = i.depth + 1;
+        return n.eachBefore(mL)
     }
-    const OK = ["clamp", "base", "constant", "exponent"];
 
-    function qN(e, t) {
-        const n = t[0],
-            i = De(t) - n;
-        return function(r) {
-            return e(n + r * i)
-        }
+    function UZ() {
+        return fE(this).eachBefore(HZ)
     }
 
-    function qm(e, t, n) {
-        return Cx(_w(t || "rgb", n), e)
+    function WZ(e) {
+        return e.children
     }
 
-    function HN(e, t) {
-        const n = new Array(t),
-            i = t + 1;
-        for (let r = 0; r < t;) n[r] = e(++r / i);
-        return n
+    function qZ(e) {
+        return Array.isArray(e) ? e[1] : null
     }
 
-    function YN(e, t, n) {
-        const i = n - t;
-        let r, s, a;
-        return !i || !Number.isFinite(i) ? xn(.5) : (r = (s = e.type).indexOf("-"), s = r < 0 ? s : s.slice(r + 1), a = We(s)().domain([t, n]).range([0, 1]), OK.forEach(o => e[o] ? a[o](e[o]()) : 0), a)
+    function HZ(e) {
+        e.data.value !== void 0 && (e.value = e.data.value), e.data = e.data.data
     }
 
-    function _w(e, t) {
-        const n = mj[FK(e)];
-        return t != null && n && n.gamma ? n.gamma(t) : n
+    function mL(e) {
+        var t = 0;
+        do e.height = t; while ((e = e.parent) && e.height < ++t)
     }
 
-    function FK(e) {
-        return "interpolate" + e.toLowerCase().split("-").map(t => t[0].toUpperCase() + t.slice(1)).join("")
+    function wc(e) {
+        this.data = e, this.depth = this.height = 0, this.parent = null
     }
-    const RK = {
-            blues: "cfe1f2bed8eca8cee58fc1de74b2d75ba3cf4592c63181bd206fb2125ca40a4a90",
-            greens: "d3eecdc0e6baabdda594d3917bc77d60ba6c46ab5e329a512089430e7735036429",
-            greys: "e2e2e2d4d4d4c4c4c4b1b1b19d9d9d8888887575756262624d4d4d3535351e1e1e",
-            oranges: "fdd8b3fdc998fdb87bfda55efc9244f87f2cf06b18e4580bd14904b93d029f3303",
-            purples: "e2e1efd4d4e8c4c5e0b4b3d6a3a0cc928ec3827cb97566ae684ea25c3696501f8c",
-            reds: "fdc9b4fcb49afc9e80fc8767fa7051f6573fec3f2fdc2a25c81b1db21218970b13",
-            blueGreen: "d5efedc1e8e0a7ddd18bd2be70c6a958ba9144ad77319c5d2089460e7736036429",
-            bluePurple: "ccddecbad0e4a8c2dd9ab0d4919cc98d85be8b6db28a55a6873c99822287730f71",
-            greenBlue: "d3eecec5e8c3b1e1bb9bd8bb82cec269c2ca51b2cd3c9fc7288abd1675b10b60a1",
-            orangeRed: "fddcaffdcf9bfdc18afdad77fb9562f67d53ee6545e24932d32d1ebf130da70403",
-            purpleBlue: "dbdaebc8cee4b1c3de97b7d87bacd15b9fc93a90c01e7fb70b70ab056199045281",
-            purpleBlueGreen: "dbd8eac8cee4b0c3de93b7d872acd1549fc83892bb1c88a3097f8702736b016353",
-            purpleRed: "dcc9e2d3b3d7ce9eccd186c0da6bb2e14da0e23189d91e6fc61159ab07498f023a",
-            redPurple: "fccfccfcbec0faa9b8f98faff571a5ec539ddb3695c41b8aa908808d0179700174",
-            yellowGreen: "e4f4acd1eca0b9e2949ed68880c97c62bb6e47aa5e3297502083440e723b036034",
-            yellowOrangeBrown: "feeaa1fedd84fecc63feb746fca031f68921eb7215db5e0bc54c05ab3d038f3204",
-            yellowOrangeRed: "fee087fed16ffebd59fea849fd903efc7335f9522bee3423de1b20ca0b22af0225",
-            blueOrange: "134b852f78b35da2cb9dcae1d2e5eff2f0ebfce0bafbbf74e8932fc5690d994a07",
-            brownBlueGreen: "704108a0651ac79548e3c78af3e6c6eef1eac9e9e48ed1c74da79e187a72025147",
-            purpleGreen: "5b1667834792a67fb6c9aed3e6d6e8eff0efd9efd5aedda971bb75368e490e5e29",
-            purpleOrange: "4114696647968f83b7b9b4d6dadbebf3eeeafce0bafbbf74e8932fc5690d994a07",
-            redBlue: "8c0d25bf363adf745ef4ae91fbdbc9f2efeed2e5ef9dcae15da2cb2f78b3134b85",
-            redGrey: "8c0d25bf363adf745ef4ae91fcdccbfaf4f1e2e2e2c0c0c0969696646464343434",
-            yellowGreenBlue: "eff9bddbf1b4bde5b594d5b969c5be45b4c22c9ec02182b82163aa23479c1c3185",
-            redYellowBlue: "a50026d4322cf16e43fcac64fedd90faf8c1dcf1ecabd6e875abd04a74b4313695",
-            redYellowGreen: "a50026d4322cf16e43fcac63fedd8df9f7aed7ee8ea4d86e64bc6122964f006837",
-            pinkYellowGreen: "8e0152c0267edd72adf0b3d6faddedf5f3efe1f2cab6de8780bb474f9125276419",
-            spectral: "9e0142d13c4bf0704afcac63fedd8dfbf8b0e0f3a1a9dda269bda94288b55e4fa2",
-            viridis: "440154470e61481a6c482575472f7d443a834144873d4e8a39568c35608d31688e2d708e2a788e27818e23888e21918d1f988b1fa08822a8842ab07f35b77943bf7154c56866cc5d7ad1518fd744a5db36bcdf27d2e21be9e51afde725",
-            magma: "0000040404130b0924150e3720114b2c11603b0f704a107957157e651a80721f817f24828c29819a2e80a8327db6377ac43c75d1426fde4968e95462f1605df76f5cfa7f5efc8f65fe9f6dfeaf78febf84fece91fddea0fcedaffcfdbf",
-            inferno: "0000040403130c0826170c3b240c4f330a5f420a68500d6c5d126e6b176e781c6d86216b932667a12b62ae305cbb3755c73e4cd24644dd513ae65c30ed6925f3771af8850ffb9506fca50afcb519fac62df6d645f2e661f3f484fcffa4",
-            plasma: "0d088723069033059742039d5002a25d01a66a00a87801a88405a7900da49c179ea72198b12a90ba3488c33d80cb4779d35171da5a69e16462e76e5bed7953f2834cf68f44fa9a3dfca636fdb32ffec029fcce25f9dc24f5ea27f0f921",
-            cividis: "00205100235800265d002961012b65042e670831690d346b11366c16396d1c3c6e213f6e26426e2c456e31476e374a6e3c4d6e42506e47536d4c566d51586e555b6e5a5e6e5e616e62646f66676f6a6a706e6d717270717573727976737c79747f7c75827f758682768985778c8877908b78938e789691789a94789e9778a19b78a59e77a9a177aea575b2a874b6ab73bbaf71c0b26fc5b66dc9b96acebd68d3c065d8c462ddc85fe2cb5ce7cf58ebd355f0d652f3da4ff7de4cfae249fce647",
-            rainbow: "6e40aa883eb1a43db3bf3cafd83fa4ee4395fe4b83ff576eff6659ff7847ff8c38f3a130e2b72fcfcc36bee044aff05b8ff4576ff65b52f6673af27828ea8d1ddfa319d0b81cbecb23abd82f96e03d82e14c6edb5a5dd0664dbf6e40aa",
-            sinebow: "ff4040fc582af47218e78d0bd5a703bfbf00a7d5038de70b72f41858fc2a40ff402afc5818f4720be78d03d5a700bfbf03a7d50b8de71872f42a58fc4040ff582afc7218f48d0be7a703d5bf00bfd503a7e70b8df41872fc2a58ff4040",
-            turbo: "23171b32204a3e2a71453493493eae4b49c54a53d7485ee44569ee4074f53c7ff8378af93295f72e9ff42ba9ef28b3e926bce125c5d925cdcf27d5c629dcbc2de3b232e9a738ee9d3ff39347f68950f9805afc7765fd6e70fe667cfd5e88fc5795fb51a1f84badf545b9f140c5ec3cd0e637dae034e4d931ecd12ef4c92bfac029ffb626ffad24ffa223ff9821ff8d1fff821dff771cfd6c1af76118f05616e84b14df4111d5380fcb2f0dc0260ab61f07ac1805a313029b0f00950c00910b00",
-            browns: "eedbbdecca96e9b97ae4a865dc9856d18954c7784cc0673fb85536ad44339f3632",
-            tealBlues: "bce4d89dd3d181c3cb65b3c245a2b9368fae347da0306a932c5985",
-            teals: "bbdfdfa2d4d58ac9c975bcbb61b0af4da5a43799982b8b8c1e7f7f127273006667",
-            warmGreys: "dcd4d0cec5c1c0b8b4b3aaa7a59c9998908c8b827f7e7673726866665c5a59504e",
-            goldGreen: "f4d166d5ca60b6c35c98bb597cb25760a6564b9c533f8f4f33834a257740146c36",
-            goldOrange: "f4d166f8be5cf8aa4cf5983bf3852aef701be2621fd65322c54923b142239e3a26",
-            goldRed: "f4d166f6be59f9aa51fc964ef6834bee734ae56249db5247cf4244c43141b71d3e",
-            lightGreyRed: "efe9e6e1dad7d5cbc8c8bdb9bbaea9cd967ddc7b43e15f19df4011dc000b",
-            lightGreyTeal: "e4eaead6dcddc8ced2b7c2c7a6b4bc64b0bf22a6c32295c11f85be1876bc",
-            lightMulti: "e0f1f2c4e9d0b0de9fd0e181f6e072f6c053f3993ef77440ef4a3c",
-            lightOrange: "f2e7daf7d5baf9c499fab184fa9c73f68967ef7860e8645bde515bd43d5b",
-            lightTealBlue: "e3e9e0c0dccf9aceca7abfc859afc0389fb9328dad2f7ca0276b95255988",
-            darkBlue: "3232322d46681a5c930074af008cbf05a7ce25c0dd38daed50f3faffffff",
-            darkGold: "3c3c3c584b37725e348c7631ae8b2bcfa424ecc31ef9de30fff184ffffff",
-            darkGreen: "3a3a3a215748006f4d048942489e4276b340a6c63dd2d836ffeb2cffffaa",
-            darkMulti: "3737371f5287197d8c29a86995ce3fffe800ffffff",
-            darkRed: "3434347036339e3c38cc4037e75d1eec8620eeab29f0ce32ffeb2c"
-        },
-        DK = {
-            category10: "1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf",
-            category20: "1f77b4aec7e8ff7f0effbb782ca02c98df8ad62728ff98969467bdc5b0d58c564bc49c94e377c2f7b6d27f7f7fc7c7c7bcbd22dbdb8d17becf9edae5",
-            category20b: "393b795254a36b6ecf9c9ede6379398ca252b5cf6bcedb9c8c6d31bd9e39e7ba52e7cb94843c39ad494ad6616be7969c7b4173a55194ce6dbdde9ed6",
-            category20c: "3182bd6baed69ecae1c6dbefe6550dfd8d3cfdae6bfdd0a231a35474c476a1d99bc7e9c0756bb19e9ac8bcbddcdadaeb636363969696bdbdbdd9d9d9",
-            tableau10: "4c78a8f58518e4575672b7b254a24beeca3bb279a2ff9da69d755dbab0ac",
-            tableau20: "4c78a89ecae9f58518ffbf7954a24b88d27ab79a20f2cf5b43989483bcb6e45756ff9d9879706ebab0acd67195fcbfd2b279a2d6a5c99e765fd8b5a5",
-            accent: "7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666",
-            dark2: "1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666",
-            paired: "a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928",
-            pastel1: "fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2",
-            pastel2: "b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc",
-            set1: "e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999",
-            set2: "66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3",
-            set3: "8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f"
-        };
+    wc.prototype = fE.prototype = {
+        constructor: wc,
+        count: TZ,
+        each: MZ,
+        eachAfter: FZ,
+        eachBefore: OZ,
+        find: RZ,
+        sum: DZ,
+        sort: NZ,
+        path: PZ,
+        ancestors: IZ,
+        descendants: zZ,
+        leaves: BZ,
+        links: jZ,
+        copy: UZ,
+        [Symbol.iterator]: GZ
+    };
 
-    function XN(e) {
-        const t = e.length / 6 | 0,
-            n = new Array(t);
-        for (let i = 0; i < t;) n[i] = "#" + e.slice(i * 6, ++i * 6);
-        return n
+    function Dp(e) {
+        return e == null ? null : yL(e)
     }
 
-    function VN(e, t) {
-        for (const n in e) ww(n, t(e[n]))
+    function yL(e) {
+        if (typeof e != "function") throw new Error;
+        return e
     }
-    const L$ = {};
-    VN(DK, XN);
-    VN(RK, e => qm(XN(e)));
-
-    function ww(e, t) {
-        return e = e && e.toLowerCase(), arguments.length > 1 ? (L$[e] = t, this) : L$[e]
-    }
-    const Qg = "symbol",
-        NK = "discrete",
-        PK = "gradient",
-        LK = e => W(e) ? e.map(t => String(t)) : String(e),
-        IK = (e, t) => e[1] - t[1],
-        zK = (e, t) => t[1] - e[1];
 
-    function Sw(e, t, n) {
-        let i;
-        return Ze(t) && (e.bins && (t = Math.max(t, e.bins.length)), n != null && (t = Math.min(t, Math.floor(ad(e.domain()) / n || 1)))), ae(t) && (i = t.step, t = t.interval), re(t) && (t = e.type === tl ? wc(t) : e.type == nl ? Sc(t) : U("Only time and utc scales accept interval strings."), i && (t = t.every(i))), t
+    function el() {
+        return 0
     }
 
-    function KN(e, t, n) {
-        let i = e.range(),
-            r = i[0],
-            s = De(i),
-            a = IK;
-        if (r > s && (i = s, s = r, r = i, a = zK), r = Math.floor(r), s = Math.ceil(s), t = t.map(o => [o, e(o)]).filter(o => r <= o[1] && o[1] <= s).sort(a).map(o => o[0]), n > 0 && t.length > 1) {
-            const o = [t[0], De(t)];
-            for (; t.length > n && t.length >= 3;) t = t.filter((l, u) => !(u % 2));
-            t.length < 3 && (t = o)
+    function Ru(e) {
+        return function() {
+            return e
         }
-        return t
     }
+    const YZ = 1664525,
+        XZ = 1013904223,
+        DT = 4294967296;
 
-    function Ew(e, t) {
-        return e.bins ? KN(e, e.bins) : e.ticks ? e.ticks(t) : e.domain()
+    function VZ() {
+        let e = 1;
+        return () => (e = (YZ * e + XZ) % DT) / DT
     }
 
-    function JN(e, t, n, i, r, s) {
-        const a = t.type;
-        let o = LK;
-        if (a === tl || r === tl) o = e.timeFormat(i);
-        else if (a === nl || r === nl) o = e.utcFormat(i);
-        else if (UN(a)) {
-            const l = e.formatFloat(i);
-            if (s || t.bins) o = l;
-            else {
-                const u = QN(t, n, !1);
-                o = c => u(c) ? l(c) : ""
-            }
-        } else if (t.tickFormat) {
-            const l = t.domain();
-            o = e.formatSpan(l[0], l[l.length - 1], n, i)
-        } else i && (o = e.format(i));
-        return o
+    function KZ(e) {
+        return typeof e == "object" && "length" in e ? e : Array.from(e)
     }
 
-    function QN(e, t, n) {
-        const i = Ew(e, t),
-            r = e.base(),
-            s = Math.log(r),
-            a = Math.max(1, r * t / i.length),
-            o = l => {
-                let u = l / Math.pow(r, Math.round(Math.log(l) / s));
-                return u * r < r - .5 && (u *= r), u <= a
-            };
-        return n ? i.filter(o) : o
+    function JZ(e, t) {
+        let n = e.length,
+            i, r;
+        for (; n;) r = t() * n-- | 0, i = e[n], e[n] = e[r], e[r] = i;
+        return e
     }
-    const i2 = {
-            [Wu]: "quantiles",
-            [Gm]: "thresholds",
-            [Wm]: "domain"
-        },
-        ZN = {
-            [Wu]: "quantiles",
-            [Gm]: "domain"
-        };
 
-    function eP(e, t) {
-        return e.bins ? UK(e.bins) : e.type === zs ? QN(e, t, !0) : i2[e.type] ? jK(e[i2[e.type]]()) : Ew(e, t)
+    function QZ(e, t) {
+        for (var n = 0, i = (e = JZ(Array.from(e), t)).length, r = [], s, a; n < i;) s = e[n], a && vL(a, s) ? ++n : (a = eee(r = ZZ(r, s)), n = 0);
+        return a
     }
 
-    function BK(e, t, n) {
-        const i = t[ZN[t.type]](),
-            r = i.length;
-        let s = r > 1 ? i[1] - i[0] : i[0],
-            a;
-        for (a = 1; a < r; ++a) s = Math.min(s, i[a] - i[a - 1]);
-        return e.formatSpan(0, s, 3 * 10, n)
+    function ZZ(e, t) {
+        var n, i;
+        if (Av(t, e)) return [t];
+        for (n = 0; n < e.length; ++n)
+            if (zg(t, e[n]) && Av(fh(e[n], t), e)) return [e[n], t];
+        for (n = 0; n < e.length - 1; ++n)
+            for (i = n + 1; i < e.length; ++i)
+                if (zg(fh(e[n], e[i]), t) && zg(fh(e[n], t), e[i]) && zg(fh(e[i], t), e[n]) && Av(bL(e[n], e[i], t), e)) return [e[n], e[i], t];
+        throw new Error
     }
 
-    function jK(e) {
-        const t = [-1 / 0].concat(e);
-        return t.max = 1 / 0, t
+    function zg(e, t) {
+        var n = e.r - t.r,
+            i = t.x - e.x,
+            r = t.y - e.y;
+        return n < 0 || n * n < i * i + r * r
     }
 
-    function UK(e) {
-        const t = e.slice(0, -1);
-        return t.max = De(e), t
+    function vL(e, t) {
+        var n = e.r - t.r + Math.max(e.r, t.r, 1) * 1e-9,
+            i = t.x - e.x,
+            r = t.y - e.y;
+        return n > 0 && n * n > i * i + r * r
     }
-    const GK = e => i2[e.type] || e.bins;
 
-    function tP(e, t, n, i, r, s, a) {
-        const o = ZN[t.type] && s !== tl && s !== nl ? BK(e, t, r) : JN(e, t, n, r, s, a);
-        return i === Qg && GK(t) ? WK(o) : i === NK ? qK(o) : HK(o)
-    }
-    const WK = e => (t, n, i) => {
-            const r = I$(i[n + 1], I$(i.max, 1 / 0)),
-                s = z$(t, e),
-                a = z$(r, e);
-            return s && a ? s + " – " + a : a ? "< " + a : "≥ " + s
-        },
-        I$ = (e, t) => e ?? t,
-        qK = e => (t, n) => n ? e(t) : null,
-        HK = e => t => e(t),
-        z$ = (e, t) => Number.isFinite(e) ? t(e) : null;
+    function Av(e, t) {
+        for (var n = 0; n < t.length; ++n)
+            if (!vL(e, t[n])) return !1;
+        return !0
+    }
 
-    function YK(e) {
-        const t = e.domain(),
-            n = t.length - 1;
-        let i = +t[0],
-            r = +De(t),
-            s = r - i;
-        if (e.type === Wm) {
-            const a = n ? s / n : .1;
-            i -= a, r += a, s = r - i
+    function eee(e) {
+        switch (e.length) {
+            case 1:
+                return tee(e[0]);
+            case 2:
+                return fh(e[0], e[1]);
+            case 3:
+                return bL(e[0], e[1], e[2])
         }
-        return a => (a - i) / s
     }
 
-    function XK(e, t, n, i) {
-        const r = i || t.type;
-        return re(n) && MK(r) && (n = n.replace(/%a/g, "%A").replace(/%b/g, "%B")), !n && r === tl ? e.timeFormat("%A, %d %B %Y, %X") : !n && r === nl ? e.utcFormat("%A, %d %B %Y, %X UTC") : tP(e, t, 5, null, n, i, !0)
+    function tee(e) {
+        return {
+            x: e.x,
+            y: e.y,
+            r: e.r
+        }
     }
 
-    function nP(e, t, n) {
-        n = n || {};
-        const i = Math.max(3, n.maxlen || 7),
-            r = XK(e, t, n.format, n.formatType);
-        if (n2(t.type)) {
-            const s = eP(t).slice(1).map(r),
-                a = s.length;
-            return `${a} boundar${a===1?"y":"ies"}: ${s.join(", ")}`
-        } else if (qu(t.type)) {
-            const s = t.domain(),
-                a = s.length,
-                o = a > i ? s.slice(0, i - 2).map(r).join(", ") + ", ending with " + s.slice(-1).map(r) : s.map(r).join(", ");
-            return `${a} value${a===1?"":"s"}: ${o}`
-        } else {
-            const s = t.domain();
-            return `values from ${r(s[0])} to ${r(De(s))}`
+    function fh(e, t) {
+        var n = e.x,
+            i = e.y,
+            r = e.r,
+            s = t.x,
+            a = t.y,
+            o = t.r,
+            l = s - n,
+            u = a - i,
+            c = o - r,
+            f = Math.sqrt(l * l + u * u);
+        return {
+            x: (n + s + l / f * c) / 2,
+            y: (i + a + u / f * c) / 2,
+            r: (f + r + o) / 2
         }
     }
-    let iP = 0;
 
-    function VK() {
-        iP = 0
+    function bL(e, t, n) {
+        var i = e.x,
+            r = e.y,
+            s = e.r,
+            a = t.x,
+            o = t.y,
+            l = t.r,
+            u = n.x,
+            c = n.y,
+            f = n.r,
+            h = i - a,
+            d = i - u,
+            g = r - o,
+            p = r - c,
+            m = l - s,
+            y = f - s,
+            v = i * i + r * r - s * s,
+            b = v - a * a - o * o + l * l,
+            x = v - u * u - c * c + f * f,
+            _ = d * g - h * p,
+            S = (g * x - p * b) / (_ * 2) - i,
+            w = (p * m - g * y) / _,
+            E = (d * b - h * x) / (_ * 2) - r,
+            C = (h * y - d * m) / _,
+            k = w * w + C * C - 1,
+            A = 2 * (s + S * w + E * C),
+            F = S * S + E * E - s * s,
+            $ = -(Math.abs(k) > 1e-6 ? (A + Math.sqrt(A * A - 4 * k * F)) / (2 * k) : F / A);
+        return {
+            x: i + S + w * $,
+            y: r + E + C * $,
+            r: $
+        }
     }
-    const g0 = "p_";
 
-    function Cw(e) {
-        return e && e.gradient
+    function NT(e, t, n) {
+        var i = e.x - t.x,
+            r, s, a = e.y - t.y,
+            o, l, u = i * i + a * a;
+        u ? (s = t.r + n.r, s *= s, l = e.r + n.r, l *= l, s > l ? (r = (u + l - s) / (2 * u), o = Math.sqrt(Math.max(0, l / u - r * r)), n.x = e.x - r * i - o * a, n.y = e.y - r * a + o * i) : (r = (u + s - l) / (2 * u), o = Math.sqrt(Math.max(0, s / u - r * r)), n.x = t.x + r * i - o * a, n.y = t.y + r * a + o * i)) : (n.x = t.x + n.r, n.y = t.y)
     }
 
-    function rP(e, t, n) {
-        const i = e.gradient;
-        let r = e.id,
-            s = i === "radial" ? g0 : "";
-        return r || (r = e.id = "gradient_" + iP++, i === "radial" ? (e.x1 = kr(e.x1, .5), e.y1 = kr(e.y1, .5), e.r1 = kr(e.r1, 0), e.x2 = kr(e.x2, .5), e.y2 = kr(e.y2, .5), e.r2 = kr(e.r2, .5), s = g0) : (e.x1 = kr(e.x1, 0), e.y1 = kr(e.y1, 0), e.x2 = kr(e.x2, 1), e.y2 = kr(e.y2, 0))), t[r] = e, "url(" + (n || "") + "#" + s + r + ")"
+    function PT(e, t) {
+        var n = e.r + t.r - 1e-6,
+            i = t.x - e.x,
+            r = t.y - e.y;
+        return n > 0 && n * n > i * i + r * r
     }
 
-    function kr(e, t) {
-        return e ?? t
+    function LT(e) {
+        var t = e._,
+            n = e.next._,
+            i = t.r + n.r,
+            r = (t.x * n.r + n.x * t.r) / i,
+            s = (t.y * n.r + n.y * t.r) / i;
+        return r * r + s * s
     }
 
-    function sP(e, t) {
-        var n = [],
-            i;
-        return i = {
-            gradient: "linear",
-            x1: e ? e[0] : 0,
-            y1: e ? e[1] : 0,
-            x2: t ? t[0] : 1,
-            y2: t ? t[1] : 0,
-            stops: n,
-            stop: function(r, s) {
-                return n.push({
-                    offset: r,
-                    color: s
-                }), i
-            }
-        }
+    function Bg(e) {
+        this._ = e, this.next = null, this.previous = null
     }
-    const B$ = {
-        basis: {
-            curve: HH
-        },
-        "basis-closed": {
-            curve: YH
-        },
-        "basis-open": {
-            curve: XH
-        },
-        bundle: {
-            curve: VH,
-            tension: "beta",
-            value: .85
-        },
-        cardinal: {
-            curve: KH,
-            tension: "tension",
-            value: 0
-        },
-        "cardinal-open": {
-            curve: QH,
-            tension: "tension",
-            value: 0
-        },
-        "cardinal-closed": {
-            curve: JH,
-            tension: "tension",
-            value: 0
-        },
-        "catmull-rom": {
-            curve: ZH,
-            tension: "alpha",
-            value: .5
-        },
-        "catmull-rom-closed": {
-            curve: eY,
-            tension: "alpha",
-            value: .5
-        },
-        "catmull-rom-open": {
-            curve: tY,
-            tension: "alpha",
-            value: .5
-        },
-        linear: {
-            curve: Qx
-        },
-        "linear-closed": {
-            curve: nY
-        },
-        monotone: {
-            horizontal: rY,
-            vertical: iY
-        },
-        natural: {
-            curve: sY
-        },
-        step: {
-            curve: aY
-        },
-        "step-after": {
-            curve: lY
-        },
-        "step-before": {
-            curve: oY
+
+    function nee(e, t) {
+        if (!(s = (e = KZ(e)).length)) return 0;
+        var n, i, r, s, a, o, l, u, c, f, h;
+        if (n = e[0], n.x = 0, n.y = 0, !(s > 1)) return n.r;
+        if (i = e[1], n.x = -i.r, i.x = n.r, i.y = 0, !(s > 2)) return n.r + i.r;
+        NT(i, n, r = e[2]), n = new Bg(n), i = new Bg(i), r = new Bg(r), n.next = r.previous = i, i.next = n.previous = r, r.next = i.previous = n;
+        e: for (l = 3; l < s; ++l) {
+            NT(n._, i._, r = e[l]), r = new Bg(r), u = i.next, c = n.previous, f = i._.r, h = n._.r;
+            do
+                if (f <= h) {
+                    if (PT(u._, r._)) {
+                        i = u, n.next = i, i.previous = n, --l;
+                        continue e
+                    }
+                    f += u._.r, u = u.next
+                } else {
+                    if (PT(c._, r._)) {
+                        n = c, n.next = i, i.previous = n, --l;
+                        continue e
+                    }
+                    h += c._.r, c = c.previous
+                } while (u !== c.next);
+            for (r.previous = n, r.next = i, n.next = i.previous = i = r, a = LT(n);
+                (r = r.next) !== i;)(o = LT(r)) < a && (n = r, a = o);
+            i = n.next
         }
-    };
+        for (n = [i._], r = i;
+            (r = r.next) !== i;) n.push(r._);
+        for (r = QZ(n, t), l = 0; l < s; ++l) n = e[l], n.x -= r.x, n.y -= r.y;
+        return r.r
+    }
 
-    function kw(e, t, n) {
-        var i = me(B$, e) && B$[e],
-            r = null;
-        return i && (r = i.curve || i[t || "vertical"], i.tension && n != null && (r = r[i.tension](n))), r
+    function iee(e) {
+        return Math.sqrt(e.value)
     }
-    const KK = {
-            m: 2,
-            l: 2,
-            h: 1,
-            v: 1,
-            z: 0,
-            c: 6,
-            s: 4,
-            q: 4,
-            t: 2,
-            a: 7
-        },
-        JK = /[mlhvzcsqta]([^mlhvzcsqta]+|$)/gi,
-        QK = /^[+-]?(([0-9]*\.[0-9]+)|([0-9]+\.)|([0-9]+))([eE][+-]?[0-9]+)?/,
-        ZK = /^((\s+,?\s*)|(,\s*))/,
-        eJ = /^[01]/;
 
-    function Hu(e) {
-        const t = [];
-        return (e.match(JK) || []).forEach(i => {
-            let r = i[0];
-            const s = r.toLowerCase(),
-                a = KK[s],
-                o = tJ(s, a, i.slice(1).trim()),
-                l = o.length;
-            if (l < a || l && l % a !== 0) throw Error("Invalid SVG path, incorrect parameter count");
-            if (t.push([r, ...o.slice(0, a)]), l !== a) {
-                s === "m" && (r = r === "M" ? "L" : "l");
-                for (let u = a; u < l; u += a) t.push([r, ...o.slice(u, u + a)])
-            }
-        }), t
+    function ree() {
+        var e = null,
+            t = 1,
+            n = 1,
+            i = el;
+
+        function r(s) {
+            const a = VZ();
+            return s.x = t / 2, s.y = n / 2, e ? s.eachBefore(IT(e)).eachAfter($v(i, .5, a)).eachBefore(zT(1)) : s.eachBefore(IT(iee)).eachAfter($v(el, 1, a)).eachAfter($v(i, s.r / Math.min(t, n), a)).eachBefore(zT(Math.min(t, n) / (2 * s.r))), s
+        }
+        return r.radius = function(s) {
+            return arguments.length ? (e = Dp(s), r) : e
+        }, r.size = function(s) {
+            return arguments.length ? (t = +s[0], n = +s[1], r) : [t, n]
+        }, r.padding = function(s) {
+            return arguments.length ? (i = typeof s == "function" ? s : Ru(+s), r) : i
+        }, r
     }
 
-    function tJ(e, t, n) {
-        const i = [];
-        for (let r = 0; t && r < n.length;)
-            for (let s = 0; s < t; ++s) {
-                const a = e === "a" && (s === 3 || s === 4) ? eJ : QK,
-                    o = n.slice(r).match(a);
-                if (o === null) throw Error("Invalid SVG path, incorrect parameter type");
-                r += o[0].length, i.push(+o[0]);
-                const l = n.slice(r).match(ZK);
-                l !== null && (r += l[0].length)
+    function IT(e) {
+        return function(t) {
+            t.children || (t.r = Math.max(0, +e(t) || 0))
+        }
+    }
+
+    function $v(e, t, n) {
+        return function(i) {
+            if (r = i.children) {
+                var r, s, a = r.length,
+                    o = e(i) * t || 0,
+                    l;
+                if (o)
+                    for (s = 0; s < a; ++s) r[s].r += o;
+                if (l = nee(r, n), o)
+                    for (s = 0; s < a; ++s) r[s].r -= o;
+                i.r = l + o
             }
-        return i
+        }
     }
-    const Da = Math.PI / 180,
-        nJ = 1e-14,
-        To = Math.PI / 2,
-        Dr = Math.PI * 2,
-        Vl = Math.sqrt(3) / 2;
-    var Jy = {},
-        Qy = {},
-        aP = [].join;
-
-    function iJ(e, t, n, i, r, s, a, o, l) {
-        const u = aP.call(arguments);
-        if (Jy[u]) return Jy[u];
-        const c = a * Da,
-            f = Math.sin(c),
-            h = Math.cos(c);
-        n = Math.abs(n), i = Math.abs(i);
-        const d = h * (o - e) * .5 + f * (l - t) * .5,
-            g = h * (l - t) * .5 - f * (o - e) * .5;
-        let p = d * d / (n * n) + g * g / (i * i);
-        p > 1 && (p = Math.sqrt(p), n *= p, i *= p);
-        const m = h / n,
-            y = f / n,
-            v = -f / i,
-            b = h / i,
-            x = m * o + y * l,
-            _ = v * o + b * l,
-            S = m * e + y * t,
-            w = v * e + b * t;
-        let A = 1 / ((S - x) * (S - x) + (w - _) * (w - _)) - .25;
-        A < 0 && (A = 0);
-        let C = Math.sqrt(A);
-        s == r && (C = -C);
-        const k = .5 * (x + S) - C * (w - _),
-            R = .5 * (_ + w) + C * (S - x),
-            $ = Math.atan2(_ - R, x - k);
-        let M = Math.atan2(w - R, S - k) - $;
-        M < 0 && s === 1 ? M += Dr : M > 0 && s === 0 && (M -= Dr);
-        const F = Math.ceil(Math.abs(M / (To + .001))),
-            N = [];
-        for (let P = 0; P < F; ++P) {
-            const z = $ + P * M / F,
-                I = $ + (P + 1) * M / F;
-            N[P] = [k, R, z, I, n, i, f, h]
+
+    function zT(e) {
+        return function(t) {
+            var n = t.parent;
+            t.r *= e, n && (t.x = n.x + e * t.x, t.y = n.y + e * t.y)
         }
-        return Jy[u] = N
     }
 
-    function rJ(e) {
-        const t = aP.call(e);
-        if (Qy[t]) return Qy[t];
-        var n = e[0],
-            i = e[1],
-            r = e[2],
-            s = e[3],
-            a = e[4],
-            o = e[5],
-            l = e[6],
-            u = e[7];
-        const c = u * a,
-            f = -l * o,
-            h = l * a,
-            d = u * o,
-            g = Math.cos(r),
-            p = Math.sin(r),
-            m = Math.cos(s),
-            y = Math.sin(s),
-            v = .5 * (s - r),
-            b = Math.sin(v * .5),
-            x = 8 / 3 * b * b / Math.sin(v),
-            _ = n + g - x * p,
-            S = i + p + x * g,
-            w = n + m,
-            E = i + y,
-            A = w + x * y,
-            C = E - x * m;
-        return Qy[t] = [c * _ + f * S, h * _ + d * S, c * A + f * C, h * A + d * C, c * w + f * E, h * w + d * E]
-    }
-    const Si = ["l", 0, 0, 0, 0, 0, 0, 0];
-
-    function sJ(e, t, n) {
-        const i = Si[0] = e[0];
-        if (i === "a" || i === "A") Si[1] = t * e[1], Si[2] = n * e[2], Si[3] = e[3], Si[4] = e[4], Si[5] = e[5], Si[6] = t * e[6], Si[7] = n * e[7];
-        else if (i === "h" || i === "H") Si[1] = t * e[1];
-        else if (i === "v" || i === "V") Si[1] = n * e[1];
-        else
-            for (var r = 1, s = e.length; r < s; ++r) Si[r] = (r % 2 == 1 ? t : n) * e[r];
-        return Si
+    function xL(e) {
+        e.x0 = Math.round(e.x0), e.y0 = Math.round(e.y0), e.x1 = Math.round(e.x1), e.y1 = Math.round(e.y1)
     }
 
-    function kh(e, t, n, i, r, s) {
-        var a, o = null,
-            l = 0,
-            u = 0,
-            c = 0,
-            f = 0,
-            h, d, g, p, m = 0,
-            y = 0;
-        n == null && (n = 0), i == null && (i = 0), r == null && (r = 1), s == null && (s = r), e.beginPath && e.beginPath();
-        for (var v = 0, b = t.length; v < b; ++v) {
-            switch (a = t[v], (r !== 1 || s !== 1) && (a = sJ(a, r, s)), a[0]) {
-                case "l":
-                    l += a[1], u += a[2], e.lineTo(l + n, u + i);
-                    break;
-                case "L":
-                    l = a[1], u = a[2], e.lineTo(l + n, u + i);
-                    break;
-                case "h":
-                    l += a[1], e.lineTo(l + n, u + i);
-                    break;
-                case "H":
-                    l = a[1], e.lineTo(l + n, u + i);
-                    break;
-                case "v":
-                    u += a[1], e.lineTo(l + n, u + i);
-                    break;
-                case "V":
-                    u = a[1], e.lineTo(l + n, u + i);
-                    break;
-                case "m":
-                    l += a[1], u += a[2], m = l, y = u, e.moveTo(l + n, u + i);
-                    break;
-                case "M":
-                    l = a[1], u = a[2], m = l, y = u, e.moveTo(l + n, u + i);
-                    break;
-                case "c":
-                    h = l + a[5], d = u + a[6], c = l + a[3], f = u + a[4], e.bezierCurveTo(l + a[1] + n, u + a[2] + i, c + n, f + i, h + n, d + i), l = h, u = d;
-                    break;
-                case "C":
-                    l = a[5], u = a[6], c = a[3], f = a[4], e.bezierCurveTo(a[1] + n, a[2] + i, c + n, f + i, l + n, u + i);
-                    break;
-                case "s":
-                    h = l + a[3], d = u + a[4], c = 2 * l - c, f = 2 * u - f, e.bezierCurveTo(c + n, f + i, l + a[1] + n, u + a[2] + i, h + n, d + i), c = l + a[1], f = u + a[2], l = h, u = d;
-                    break;
-                case "S":
-                    h = a[3], d = a[4], c = 2 * l - c, f = 2 * u - f, e.bezierCurveTo(c + n, f + i, a[1] + n, a[2] + i, h + n, d + i), l = h, u = d, c = a[1], f = a[2];
-                    break;
-                case "q":
-                    h = l + a[3], d = u + a[4], c = l + a[1], f = u + a[2], e.quadraticCurveTo(c + n, f + i, h + n, d + i), l = h, u = d;
-                    break;
-                case "Q":
-                    h = a[3], d = a[4], e.quadraticCurveTo(a[1] + n, a[2] + i, h + n, d + i), l = h, u = d, c = a[1], f = a[2];
-                    break;
-                case "t":
-                    h = l + a[1], d = u + a[2], o[0].match(/[QqTt]/) === null ? (c = l, f = u) : o[0] === "t" ? (c = 2 * l - g, f = 2 * u - p) : o[0] === "q" && (c = 2 * l - c, f = 2 * u - f), g = c, p = f, e.quadraticCurveTo(c + n, f + i, h + n, d + i), l = h, u = d, c = l + a[1], f = u + a[2];
-                    break;
-                case "T":
-                    h = a[1], d = a[2], c = 2 * l - c, f = 2 * u - f, e.quadraticCurveTo(c + n, f + i, h + n, d + i), l = h, u = d;
-                    break;
-                case "a":
-                    j$(e, l + n, u + i, [a[1], a[2], a[3], a[4], a[5], a[6] + l + n, a[7] + u + i]), l += a[6], u += a[7];
-                    break;
-                case "A":
-                    j$(e, l + n, u + i, [a[1], a[2], a[3], a[4], a[5], a[6] + n, a[7] + i]), l = a[6], u = a[7];
-                    break;
-                case "z":
-                case "Z":
-                    l = m, u = y, e.closePath();
-                    break
+    function Vd(e, t, n, i, r) {
+        for (var s = e.children, a, o = -1, l = s.length, u = e.value && (i - t) / e.value; ++o < l;) a = s[o], a.y0 = n, a.y1 = r, a.x0 = t, a.x1 = t += a.value * u
+    }
+
+    function see() {
+        var e = 1,
+            t = 1,
+            n = 0,
+            i = !1;
+
+        function r(a) {
+            var o = a.height + 1;
+            return a.x0 = a.y0 = n, a.x1 = e, a.y1 = t / o, a.eachBefore(s(t, o)), i && a.eachBefore(xL), a
+        }
+
+        function s(a, o) {
+            return function(l) {
+                l.children && Vd(l, l.x0, a * (l.depth + 1) / o, l.x1, a * (l.depth + 2) / o);
+                var u = l.x0,
+                    c = l.y0,
+                    f = l.x1 - n,
+                    h = l.y1 - n;
+                f < u && (u = f = (u + f) / 2), h < c && (c = h = (c + h) / 2), l.x0 = u, l.y0 = c, l.x1 = f, l.y1 = h
             }
-            o = a
         }
+        return r.round = function(a) {
+            return arguments.length ? (i = !!a, r) : i
+        }, r.size = function(a) {
+            return arguments.length ? (e = +a[0], t = +a[1], r) : [e, t]
+        }, r.padding = function(a) {
+            return arguments.length ? (n = +a, r) : n
+        }, r
     }
+    var aee = {
+            depth: -1
+        },
+        BT = {},
+        Tv = {};
 
-    function j$(e, t, n, i) {
-        const r = iJ(i[5], i[6], i[0], i[1], i[3], i[4], i[2], t, n);
-        for (let s = 0; s < r.length; ++s) {
-            const a = rJ(r[s]);
-            e.bezierCurveTo(a[0], a[1], a[2], a[3], a[4], a[5])
-        }
-    }
-    const U$ = .5773502691896257,
-        G$ = {
-            circle: {
-                draw: function(e, t) {
-                    const n = Math.sqrt(t) / 2;
-                    e.moveTo(n, 0), e.arc(0, 0, n, 0, Dr)
-                }
-            },
-            cross: {
-                draw: function(e, t) {
-                    var n = Math.sqrt(t) / 2,
-                        i = n / 2.5;
-                    e.moveTo(-n, -i), e.lineTo(-n, i), e.lineTo(-i, i), e.lineTo(-i, n), e.lineTo(i, n), e.lineTo(i, i), e.lineTo(n, i), e.lineTo(n, -i), e.lineTo(i, -i), e.lineTo(i, -n), e.lineTo(-i, -n), e.lineTo(-i, -i), e.closePath()
-                }
-            },
-            diamond: {
-                draw: function(e, t) {
-                    const n = Math.sqrt(t) / 2;
-                    e.moveTo(-n, 0), e.lineTo(0, -n), e.lineTo(n, 0), e.lineTo(0, n), e.closePath()
-                }
-            },
-            square: {
-                draw: function(e, t) {
-                    var n = Math.sqrt(t),
-                        i = -n / 2;
-                    e.rect(i, i, n, n)
-                }
-            },
-            arrow: {
-                draw: function(e, t) {
-                    var n = Math.sqrt(t) / 2,
-                        i = n / 7,
-                        r = n / 2.5,
-                        s = n / 8;
-                    e.moveTo(-i, n), e.lineTo(i, n), e.lineTo(i, -s), e.lineTo(r, -s), e.lineTo(0, -n), e.lineTo(-r, -s), e.lineTo(-i, -s), e.closePath()
-                }
-            },
-            wedge: {
-                draw: function(e, t) {
-                    var n = Math.sqrt(t) / 2,
-                        i = Vl * n,
-                        r = i - n * U$,
-                        s = n / 4;
-                    e.moveTo(0, -i - r), e.lineTo(-s, i - r), e.lineTo(s, i - r), e.closePath()
-                }
-            },
-            triangle: {
-                draw: function(e, t) {
-                    var n = Math.sqrt(t) / 2,
-                        i = Vl * n,
-                        r = i - n * U$;
-                    e.moveTo(0, -i - r), e.lineTo(-n, i - r), e.lineTo(n, i - r), e.closePath()
-                }
-            },
-            "triangle-up": {
-                draw: function(e, t) {
-                    var n = Math.sqrt(t) / 2,
-                        i = Vl * n;
-                    e.moveTo(0, -i), e.lineTo(-n, i), e.lineTo(n, i), e.closePath()
-                }
-            },
-            "triangle-down": {
-                draw: function(e, t) {
-                    var n = Math.sqrt(t) / 2,
-                        i = Vl * n;
-                    e.moveTo(0, i), e.lineTo(-n, -i), e.lineTo(n, -i), e.closePath()
-                }
-            },
-            "triangle-right": {
-                draw: function(e, t) {
-                    var n = Math.sqrt(t) / 2,
-                        i = Vl * n;
-                    e.moveTo(i, 0), e.lineTo(-i, -n), e.lineTo(-i, n), e.closePath()
-                }
-            },
-            "triangle-left": {
-                draw: function(e, t) {
-                    var n = Math.sqrt(t) / 2,
-                        i = Vl * n;
-                    e.moveTo(-i, 0), e.lineTo(i, -n), e.lineTo(i, n), e.closePath()
-                }
-            },
-            stroke: {
-                draw: function(e, t) {
-                    const n = Math.sqrt(t) / 2;
-                    e.moveTo(-n, 0), e.lineTo(n, 0)
-                }
-            }
-        };
-
-    function oP(e) {
-        return me(G$, e) ? G$[e] : aJ(e)
-    }
-    var Zy = {};
-
-    function aJ(e) {
-        if (!me(Zy, e)) {
-            const t = Hu(e);
-            Zy[e] = {
-                draw: function(n, i) {
-                    kh(n, t, 0, 0, Math.sqrt(i) / 2)
-                }
-            }
-        }
-        return Zy[e]
-    }
-    const ta = .448084975506;
-
-    function oJ(e) {
-        return e.x
-    }
-
-    function lJ(e) {
-        return e.y
-    }
-
-    function uJ(e) {
-        return e.width
-    }
-
-    function cJ(e) {
-        return e.height
-    }
-
-    function hs(e) {
-        return typeof e == "function" ? e : () => +e
-    }
-
-    function vg(e, t, n) {
-        return Math.max(t, Math.min(e, n))
-    }
-
-    function lP() {
-        var e = oJ,
-            t = lJ,
-            n = uJ,
-            i = cJ,
-            r = hs(0),
-            s = r,
-            a = r,
-            o = r,
-            l = null;
-
-        function u(c, f, h) {
-            var d, g = f ?? +e.call(this, c),
-                p = h ?? +t.call(this, c),
-                m = +n.call(this, c),
-                y = +i.call(this, c),
-                v = Math.min(m, y) / 2,
-                b = vg(+r.call(this, c), 0, v),
-                x = vg(+s.call(this, c), 0, v),
-                _ = vg(+a.call(this, c), 0, v),
-                S = vg(+o.call(this, c), 0, v);
-            if (l || (l = d = om()), b <= 0 && x <= 0 && _ <= 0 && S <= 0) l.rect(g, p, m, y);
-            else {
-                var w = g + m,
-                    E = p + y;
-                l.moveTo(g + b, p), l.lineTo(w - x, p), l.bezierCurveTo(w - ta * x, p, w, p + ta * x, w, p + x), l.lineTo(w, E - S), l.bezierCurveTo(w, E - ta * S, w - ta * S, E, w - S, E), l.lineTo(g + _, E), l.bezierCurveTo(g + ta * _, E, g, E - ta * _, g, E - _), l.lineTo(g, p + b), l.bezierCurveTo(g, p + ta * b, g + ta * b, p, g + b, p), l.closePath()
-            }
-            if (d) return l = null, d + "" || null
-        }
-        return u.x = function(c) {
-            return arguments.length ? (e = hs(c), u) : e
-        }, u.y = function(c) {
-            return arguments.length ? (t = hs(c), u) : t
-        }, u.width = function(c) {
-            return arguments.length ? (n = hs(c), u) : n
-        }, u.height = function(c) {
-            return arguments.length ? (i = hs(c), u) : i
-        }, u.cornerRadius = function(c, f, h, d) {
-            return arguments.length ? (r = hs(c), s = f != null ? hs(f) : r, o = h != null ? hs(h) : r, a = d != null ? hs(d) : s, u) : r
-        }, u.context = function(c) {
-            return arguments.length ? (l = c ?? null, u) : l
-        }, u
-    }
-
-    function uP() {
-        var e, t, n, i, r = null,
-            s, a, o, l;
-
-        function u(f, h, d) {
-            const g = d / 2;
-            if (s) {
-                var p = o - h,
-                    m = f - a;
-                if (p || m) {
-                    var y = Math.sqrt(p * p + m * m),
-                        v = (p /= y) * l,
-                        b = (m /= y) * l,
-                        x = Math.atan2(m, p);
-                    r.moveTo(a - v, o - b), r.lineTo(f - p * g, h - m * g), r.arc(f, h, g, x - Math.PI, x), r.lineTo(a + v, o + b), r.arc(a, o, l, x, x + Math.PI)
-                } else r.arc(f, h, g, 0, Dr);
-                r.closePath()
-            } else s = 1;
-            a = f, o = h, l = g
-        }
-
-        function c(f) {
-            var h, d = f.length,
-                g, p = !1,
-                m;
-            for (r == null && (r = m = om()), h = 0; h <= d; ++h) !(h < d && i(g = f[h], h, f)) === p && (p = !p) && (s = 0), p && u(+e(g, h, f), +t(g, h, f), +n(g, h, f));
-            if (m) return r = null, m + "" || null
-        }
-        return c.x = function(f) {
-            return arguments.length ? (e = f, c) : e
-        }, c.y = function(f) {
-            return arguments.length ? (t = f, c) : t
-        }, c.size = function(f) {
-            return arguments.length ? (n = f, c) : n
-        }, c.defined = function(f) {
-            return arguments.length ? (i = f, c) : i
-        }, c.context = function(f) {
-            return arguments.length ? (f == null ? r = null : r = f, c) : r
-        }, c
-    }
-
-    function gd(e, t) {
-        return e ?? t
-    }
-    const pd = e => e.x || 0,
-        md = e => e.y || 0,
-        fJ = e => e.width || 0,
-        hJ = e => e.height || 0,
-        dJ = e => (e.x || 0) + (e.width || 0),
-        gJ = e => (e.y || 0) + (e.height || 0),
-        pJ = e => e.startAngle || 0,
-        mJ = e => e.endAngle || 0,
-        yJ = e => e.padAngle || 0,
-        vJ = e => e.innerRadius || 0,
-        bJ = e => e.outerRadius || 0,
-        xJ = e => e.cornerRadius || 0,
-        _J = e => gd(e.cornerRadiusTopLeft, e.cornerRadius) || 0,
-        wJ = e => gd(e.cornerRadiusTopRight, e.cornerRadius) || 0,
-        SJ = e => gd(e.cornerRadiusBottomRight, e.cornerRadius) || 0,
-        EJ = e => gd(e.cornerRadiusBottomLeft, e.cornerRadius) || 0,
-        CJ = e => gd(e.size, 64),
-        kJ = e => e.size || 1,
-        Hm = e => e.defined !== !1,
-        AJ = e => oP(e.shape || "circle"),
-        $J = GH().startAngle(pJ).endAngle(mJ).padAngle(yJ).innerRadius(vJ).outerRadius(bJ).cornerRadius(xJ),
-        TJ = CR().x(pd).y1(md).y0(gJ).defined(Hm),
-        MJ = CR().y(md).x1(pd).x0(dJ).defined(Hm),
-        OJ = ER().x(pd).y(md).defined(Hm),
-        FJ = lP().x(pd).y(md).width(fJ).height(hJ).cornerRadius(_J, wJ, SJ, EJ),
-        RJ = qH().type(AJ).size(CJ),
-        DJ = uP().x(pd).y(md).defined(Hm).size(kJ);
-
-    function Aw(e) {
-        return e.cornerRadius || e.cornerRadiusTopLeft || e.cornerRadiusTopRight || e.cornerRadiusBottomRight || e.cornerRadiusBottomLeft
-    }
-
-    function NJ(e, t) {
-        return $J.context(e)(t)
-    }
-
-    function PJ(e, t) {
-        const n = t[0],
-            i = n.interpolate || "linear";
-        return (n.orient === "horizontal" ? MJ : TJ).curve(kw(i, n.orient, n.tension)).context(e)(t)
-    }
-
-    function LJ(e, t) {
-        const n = t[0],
-            i = n.interpolate || "linear";
-        return OJ.curve(kw(i, n.orient, n.tension)).context(e)(t)
-    }
-
-    function kc(e, t, n, i) {
-        return FJ.context(e)(t, n, i)
-    }
-
-    function IJ(e, t) {
-        return (t.mark.shape || t.shape).context(e)(t)
-    }
-
-    function zJ(e, t) {
-        return RJ.context(e)(t)
-    }
-
-    function BJ(e, t) {
-        return DJ.context(e)(t)
-    }
-    var cP = 1;
-
-    function fP() {
-        cP = 1
-    }
-
-    function $w(e, t, n) {
-        var i = t.clip,
-            r = e._defs,
-            s = t.clip_id || (t.clip_id = "clip" + cP++),
-            a = r.clipping[s] || (r.clipping[s] = {
-                id: s
-            });
-        return $e(i) ? a.path = i(null) : Aw(n) ? a.path = kc(null, n, 0, 0) : (a.width = n.width || 0, a.height = n.height || 0), "url(#" + s + ")"
-    }
-
-    function kt(e) {
-        this.clear(), e && this.union(e)
-    }
-    kt.prototype = {
-        clone() {
-            return new kt(this)
-        },
-        clear() {
-            return this.x1 = +Number.MAX_VALUE, this.y1 = +Number.MAX_VALUE, this.x2 = -Number.MAX_VALUE, this.y2 = -Number.MAX_VALUE, this
-        },
-        empty() {
-            return this.x1 === +Number.MAX_VALUE && this.y1 === +Number.MAX_VALUE && this.x2 === -Number.MAX_VALUE && this.y2 === -Number.MAX_VALUE
-        },
-        equals(e) {
-            return this.x1 === e.x1 && this.y1 === e.y1 && this.x2 === e.x2 && this.y2 === e.y2
-        },
-        set(e, t, n, i) {
-            return n < e ? (this.x2 = e, this.x1 = n) : (this.x1 = e, this.x2 = n), i < t ? (this.y2 = t, this.y1 = i) : (this.y1 = t, this.y2 = i), this
-        },
-        add(e, t) {
-            return e < this.x1 && (this.x1 = e), t < this.y1 && (this.y1 = t), e > this.x2 && (this.x2 = e), t > this.y2 && (this.y2 = t), this
-        },
-        expand(e) {
-            return this.x1 -= e, this.y1 -= e, this.x2 += e, this.y2 += e, this
-        },
-        round() {
-            return this.x1 = Math.floor(this.x1), this.y1 = Math.floor(this.y1), this.x2 = Math.ceil(this.x2), this.y2 = Math.ceil(this.y2), this
-        },
-        scale(e) {
-            return this.x1 *= e, this.y1 *= e, this.x2 *= e, this.y2 *= e, this
-        },
-        translate(e, t) {
-            return this.x1 += e, this.x2 += e, this.y1 += t, this.y2 += t, this
-        },
-        rotate(e, t, n) {
-            const i = this.rotatedPoints(e, t, n);
-            return this.clear().add(i[0], i[1]).add(i[2], i[3]).add(i[4], i[5]).add(i[6], i[7])
-        },
-        rotatedPoints(e, t, n) {
-            var {
-                x1: i,
-                y1: r,
-                x2: s,
-                y2: a
-            } = this, o = Math.cos(e), l = Math.sin(e), u = t - t * o + n * l, c = n - t * l - n * o;
-            return [o * i - l * r + u, l * i + o * r + c, o * i - l * a + u, l * i + o * a + c, o * s - l * r + u, l * s + o * r + c, o * s - l * a + u, l * s + o * a + c]
-        },
-        union(e) {
-            return e.x1 < this.x1 && (this.x1 = e.x1), e.y1 < this.y1 && (this.y1 = e.y1), e.x2 > this.x2 && (this.x2 = e.x2), e.y2 > this.y2 && (this.y2 = e.y2), this
-        },
-        intersect(e) {
-            return e.x1 > this.x1 && (this.x1 = e.x1), e.y1 > this.y1 && (this.y1 = e.y1), e.x2 < this.x2 && (this.x2 = e.x2), e.y2 < this.y2 && (this.y2 = e.y2), this
-        },
-        encloses(e) {
-            return e && this.x1 <= e.x1 && this.x2 >= e.x2 && this.y1 <= e.y1 && this.y2 >= e.y2
-        },
-        alignsWith(e) {
-            return e && (this.x1 == e.x1 || this.x2 == e.x2 || this.y1 == e.y1 || this.y2 == e.y2)
-        },
-        intersects(e) {
-            return e && !(this.x2 < e.x1 || this.x1 > e.x2 || this.y2 < e.y1 || this.y1 > e.y2)
-        },
-        contains(e, t) {
-            return !(e < this.x1 || e > this.x2 || t < this.y1 || t > this.y2)
-        },
-        width() {
-            return this.x2 - this.x1
-        },
-        height() {
-            return this.y2 - this.y1
-        }
-    };
-
-    function Ym(e) {
-        this.mark = e, this.bounds = this.bounds || new kt
-    }
-
-    function Xm(e) {
-        Ym.call(this, e), this.items = this.items || []
-    }
-    ee(Xm, Ym);
-
-    function Tw(e) {
-        this._pending = 0, this._loader = e || Mm()
-    }
-
-    function W$(e) {
-        e._pending += 1
-    }
-
-    function tf(e) {
-        e._pending -= 1
-    }
-    Tw.prototype = {
-        pending() {
-            return this._pending
-        },
-        sanitizeURL(e) {
-            const t = this;
-            return W$(t), t._loader.sanitize(e, {
-                context: "href"
-            }).then(n => (tf(t), n)).catch(() => (tf(t), null))
-        },
-        loadImage(e) {
-            const t = this,
-                n = xK();
-            return W$(t), t._loader.sanitize(e, {
-                context: "image"
-            }).then(i => {
-                const r = i.href;
-                if (!r || !n) throw {
-                    url: r
-                };
-                const s = new n,
-                    a = me(i, "crossOrigin") ? i.crossOrigin : "anonymous";
-                return a != null && (s.crossOrigin = a), s.onload = () => tf(t), s.onerror = () => tf(t), s.src = r, s
-            }).catch(i => (tf(t), {
-                complete: !1,
-                width: 0,
-                height: 0,
-                src: i && i.url || ""
-            }))
-        },
-        ready() {
-            const e = this;
-            return new Promise(t => {
-                function n(i) {
-                    e.pending() ? setTimeout(() => {
-                        n(!0)
-                    }, 10) : t(i)
-                }
-                n(!1)
-            })
-        }
-    };
-
-    function qs(e, t, n) {
-        if (t.stroke && t.opacity !== 0 && t.strokeOpacity !== 0) {
-            const i = t.strokeWidth != null ? +t.strokeWidth : 1;
-            e.expand(i + (n ? jJ(t, i) : 0))
-        }
-        return e
-    }
-
-    function jJ(e, t) {
-        return e.strokeJoin && e.strokeJoin !== "miter" ? 0 : t
-    }
-    const UJ = Dr - 1e-8;
-    let Vm, Zg, ep, Lo, r2, tp, s2, a2;
-    const ga = (e, t) => Vm.add(e, t),
-        np = (e, t) => ga(Zg = e, ep = t),
-        q$ = e => ga(e, Vm.y1),
-        H$ = e => ga(Vm.x1, e),
-        Mo = (e, t) => r2 * e + s2 * t,
-        Oo = (e, t) => tp * e + a2 * t,
-        ev = (e, t) => ga(Mo(e, t), Oo(e, t)),
-        tv = (e, t) => np(Mo(e, t), Oo(e, t));
-
-    function yd(e, t) {
-        return Vm = e, t ? (Lo = t * Da, r2 = a2 = Math.cos(Lo), tp = Math.sin(Lo), s2 = -tp) : (r2 = a2 = 1, Lo = tp = s2 = 0), GJ
-    }
-    const GJ = {
-        beginPath() {},
-        closePath() {},
-        moveTo: tv,
-        lineTo: tv,
-        rect(e, t, n, i) {
-            Lo ? (ev(e + n, t), ev(e + n, t + i), ev(e, t + i), tv(e, t)) : (ga(e + n, t + i), np(e, t))
-        },
-        quadraticCurveTo(e, t, n, i) {
-            const r = Mo(e, t),
-                s = Oo(e, t),
-                a = Mo(n, i),
-                o = Oo(n, i);
-            Y$(Zg, r, a, q$), Y$(ep, s, o, H$), np(a, o)
-        },
-        bezierCurveTo(e, t, n, i, r, s) {
-            const a = Mo(e, t),
-                o = Oo(e, t),
-                l = Mo(n, i),
-                u = Oo(n, i),
-                c = Mo(r, s),
-                f = Oo(r, s);
-            X$(Zg, a, l, c, q$), X$(ep, o, u, f, H$), np(c, f)
-        },
-        arc(e, t, n, i, r, s) {
-            if (i += Lo, r += Lo, Zg = n * Math.cos(r) + e, ep = n * Math.sin(r) + t, Math.abs(r - i) > UJ) ga(e - n, t - n), ga(e + n, t + n);
-            else {
-                const a = u => ga(n * Math.cos(u) + e, n * Math.sin(u) + t);
-                let o, l;
-                if (a(i), a(r), r !== i)
-                    if (i = i % Dr, i < 0 && (i += Dr), r = r % Dr, r < 0 && (r += Dr), r < i && (s = !s, o = i, i = r, r = o), s)
-                        for (r -= Dr, o = i - i % To, l = 0; l < 4 && o > r; ++l, o -= To) a(o);
-                    else
-                        for (o = i - i % To + To, l = 0; l < 4 && o < r; ++l, o = o + To) a(o)
-            }
-        }
-    };
-
-    function Y$(e, t, n, i) {
-        const r = (e - t) / (e + n - 2 * t);
-        0 < r && r < 1 && i(e + (t - e) * r)
-    }
-
-    function X$(e, t, n, i, r) {
-        const s = i - e + 3 * t - 3 * n,
-            a = e + n - 2 * t,
-            o = e - t;
-        let l = 0,
-            u = 0,
-            c;
-        Math.abs(s) > nJ ? (c = a * a + o * s, c >= 0 && (c = Math.sqrt(c), l = (-a + c) / s, u = (-a - c) / s)) : l = .5 * o / a, 0 < l && l < 1 && r(V$(l, e, t, n, i)), 0 < u && u < 1 && r(V$(u, e, t, n, i))
-    }
-
-    function V$(e, t, n, i, r) {
-        const s = 1 - e,
-            a = s * s,
-            o = e * e;
-        return a * s * t + 3 * a * e * n + 3 * s * o * i + o * e * r
-    }
-    var Aa = (Aa = ka(1, 1)) ? Aa.getContext("2d") : null;
-    const o2 = new kt;
-
-    function Mw(e) {
-        return function(t, n) {
-            if (!Aa) return !0;
-            e(Aa, t), o2.clear().union(t.bounds).intersect(n).round();
-            const {
-                x1: i,
-                y1: r,
-                x2: s,
-                y2: a
-            } = o2;
-            for (let o = r; o <= a; ++o)
-                for (let l = i; l <= s; ++l)
-                    if (Aa.isPointInPath(l, o)) return !0;
-            return !1
-        }
-    }
-
-    function Ow(e, t) {
-        return t.contains(e.x || 0, e.y || 0)
-    }
-
-    function hP(e, t) {
-        const n = e.x || 0,
-            i = e.y || 0,
-            r = e.width || 0,
-            s = e.height || 0;
-        return t.intersects(o2.set(n, i, n + r, i + s))
-    }
-
-    function dP(e, t) {
-        const n = e.x || 0,
-            i = e.y || 0,
-            r = e.x2 != null ? e.x2 : n,
-            s = e.y2 != null ? e.y2 : i;
-        return du(t, n, i, r, s)
-    }
-
-    function du(e, t, n, i, r) {
-        const {
-            x1: s,
-            y1: a,
-            x2: o,
-            y2: l
-        } = e, u = i - t, c = r - n;
-        let f = 0,
-            h = 1,
-            d, g, p, m;
-        for (m = 0; m < 4; ++m) {
-            if (m === 0 && (d = -u, g = -(s - t)), m === 1 && (d = u, g = o - t), m === 2 && (d = -c, g = -(a - n)), m === 3 && (d = c, g = l - n), Math.abs(d) < 1e-10 && g < 0) return !1;
-            if (p = g / d, d < 0) {
-                if (p > h) return !1;
-                p > f && (f = p)
-            } else if (d > 0) {
-                if (p < f) return !1;
-                p < h && (h = p)
-            }
-        }
-        return !0
-    }
-
-    function Yu(e, t) {
-        e.globalCompositeOperation = t.blend || "source-over"
-    }
-
-    function Gi(e, t) {
-        return e ?? t
-    }
-
-    function K$(e, t) {
-        const n = t.length;
-        for (let i = 0; i < n; ++i) e.addColorStop(t[i].offset, t[i].color);
-        return e
-    }
-
-    function WJ(e, t, n) {
-        const i = n.width(),
-            r = n.height();
-        let s;
-        if (t.gradient === "radial") s = e.createRadialGradient(n.x1 + Gi(t.x1, .5) * i, n.y1 + Gi(t.y1, .5) * r, Math.max(i, r) * Gi(t.r1, 0), n.x1 + Gi(t.x2, .5) * i, n.y1 + Gi(t.y2, .5) * r, Math.max(i, r) * Gi(t.r2, .5));
-        else {
-            const a = Gi(t.x1, 0),
-                o = Gi(t.y1, 0),
-                l = Gi(t.x2, 1),
-                u = Gi(t.y2, 0);
-            if (a === l || o === u || i === r) s = e.createLinearGradient(n.x1 + a * i, n.y1 + o * r, n.x1 + l * i, n.y1 + u * r);
-            else {
-                const c = ka(Math.ceil(i), Math.ceil(r)),
-                    f = c.getContext("2d");
-                return f.scale(i, r), f.fillStyle = K$(f.createLinearGradient(a, o, l, u), t.stops), f.fillRect(0, 0, i, r), e.createPattern(c, "no-repeat")
-            }
-        }
-        return K$(s, t.stops)
-    }
-
-    function gP(e, t, n) {
-        return Cw(n) ? WJ(e, n, t.bounds) : n
-    }
-
-    function p0(e, t, n) {
-        return n *= t.fillOpacity == null ? 1 : t.fillOpacity, n > 0 ? (e.globalAlpha = n, e.fillStyle = gP(e, t, t.fill), !0) : !1
-    }
-    var qJ = [];
-
-    function Xu(e, t, n) {
-        var i = (i = t.strokeWidth) != null ? i : 1;
-        return i <= 0 ? !1 : (n *= t.strokeOpacity == null ? 1 : t.strokeOpacity, n > 0 ? (e.globalAlpha = n, e.strokeStyle = gP(e, t, t.stroke), e.lineWidth = i, e.lineCap = t.strokeCap || "butt", e.lineJoin = t.strokeJoin || "miter", e.miterLimit = t.strokeMiterLimit || 10, e.setLineDash && (e.setLineDash(t.strokeDash || qJ), e.lineDashOffset = t.strokeDashOffset || 0), !0) : !1)
-    }
-
-    function HJ(e, t) {
-        return e.zindex - t.zindex || e.index - t.index
-    }
-
-    function Fw(e) {
-        if (!e.zdirty) return e.zitems;
-        var t = e.items,
-            n = [],
-            i, r, s;
-        for (r = 0, s = t.length; r < s; ++r) i = t[r], i.index = r, i.zindex && n.push(i);
-        return e.zdirty = !1, e.zitems = n.sort(HJ)
-    }
-
-    function dr(e, t) {
-        var n = e.items,
-            i, r;
-        if (!n || !n.length) return;
-        const s = Fw(e);
-        if (s && s.length) {
-            for (i = 0, r = n.length; i < r; ++i) n[i].zindex || t(n[i]);
-            n = s
-        }
-        for (i = 0, r = n.length; i < r; ++i) t(n[i])
-    }
-
-    function m0(e, t) {
-        var n = e.items,
-            i, r;
-        if (!n || !n.length) return null;
-        const s = Fw(e);
-        for (s && s.length && (n = s), r = n.length; --r >= 0;)
-            if (i = t(n[r])) return i;
-        if (n === s) {
-            for (n = e.items, r = n.length; --r >= 0;)
-                if (!n[r].zindex && (i = t(n[r]))) return i
-        }
-        return null
-    }
-
-    function Rw(e) {
-        return function(t, n, i) {
-            dr(n, r => {
-                (!i || i.intersects(r.bounds)) && pP(e, t, r, r)
-            })
-        }
-    }
-
-    function YJ(e) {
-        return function(t, n, i) {
-            n.items.length && (!i || i.intersects(n.bounds)) && pP(e, t, n.items[0], n.items)
-        }
-    }
-
-    function pP(e, t, n, i) {
-        var r = n.opacity == null ? 1 : n.opacity;
-        r !== 0 && (e(t, i) || (Yu(t, n), n.fill && p0(t, n, r) && t.fill(), n.stroke && Xu(t, n, r) && t.stroke()))
-    }
-
-    function Km(e) {
-        return e = e || Ri,
-            function(t, n, i, r, s, a) {
-                return i *= t.pixelRatio, r *= t.pixelRatio, m0(n, o => {
-                    const l = o.bounds;
-                    if (!(l && !l.contains(s, a) || !l) && e(t, o, i, r, s, a)) return o
-                })
-            }
-    }
-
-    function vd(e, t) {
-        return function(n, i, r, s) {
-            var a = Array.isArray(i) ? i[0] : i,
-                o = t ?? a.fill,
-                l = a.stroke && n.isPointInStroke,
-                u, c;
-            return l && (u = a.strokeWidth, c = a.strokeCap, n.lineWidth = u ?? 1, n.lineCap = c ?? "butt"), e(n, i) ? !1 : o && n.isPointInPath(r, s) || l && n.isPointInStroke(r, s)
-        }
-    }
-
-    function Dw(e) {
-        return Km(vd(e))
-    }
-
-    function Go(e, t) {
-        return "translate(" + e + "," + t + ")"
-    }
-
-    function Nw(e) {
-        return "rotate(" + e + ")"
+    function oee(e) {
+        return e.id
     }
 
-    function XJ(e, t) {
-        return "scale(" + e + "," + t + ")"
-    }
-
-    function mP(e) {
-        return Go(e.x || 0, e.y || 0)
-    }
-
-    function VJ(e) {
-        return Go(e.x || 0, e.y || 0) + (e.angle ? " " + Nw(e.angle) : "")
-    }
-
-    function KJ(e) {
-        return Go(e.x || 0, e.y || 0) + (e.angle ? " " + Nw(e.angle) : "") + (e.scaleX || e.scaleY ? " " + XJ(e.scaleX || 1, e.scaleY || 1) : "")
-    }
-
-    function Pw(e, t, n) {
-        function i(a, o) {
-            a("transform", VJ(o)), a("d", t(null, o))
-        }
-
-        function r(a, o) {
-            return t(yd(a, o.angle), o), qs(a, o).translate(o.x || 0, o.y || 0)
-        }
-
-        function s(a, o) {
-            var l = o.x || 0,
-                u = o.y || 0,
-                c = o.angle || 0;
-            a.translate(l, u), c && a.rotate(c *= Da), a.beginPath(), t(a, o), c && a.rotate(-c), a.translate(-l, -u)
-        }
-        return {
-            type: e,
-            tag: "path",
-            nested: !1,
-            attr: i,
-            bound: r,
-            draw: Rw(s),
-            pick: Dw(s),
-            isect: n || Mw(s)
-        }
-    }
-    var JJ = Pw("arc", NJ);
-
-    function QJ(e, t) {
-        for (var n = e[0].orient === "horizontal" ? t[1] : t[0], i = e[0].orient === "horizontal" ? "y" : "x", r = e.length, s = 1 / 0, a, o; --r >= 0;) e[r].defined !== !1 && (o = Math.abs(e[r][i] - n), o < s && (s = o, a = e[r]));
-        return a
-    }
-
-    function ZJ(e, t) {
-        for (var n = Math.pow(e[0].strokeWidth || 1, 2), i = e.length, r, s, a; --i >= 0;)
-            if (e[i].defined !== !1 && (r = e[i].x - t[0], s = e[i].y - t[1], a = r * r + s * s, a < n)) return e[i];
-        return null
-    }
-
-    function eQ(e, t) {
-        for (var n = e.length, i, r, s; --n >= 0;)
-            if (e[n].defined !== !1 && (i = e[n].x - t[0], r = e[n].y - t[1], s = i * i + r * r, i = e[n].size || 1, s < i * i)) return e[n];
-        return null
-    }
-
-    function Lw(e, t, n) {
-        function i(l, u) {
-            var c = u.mark.items;
-            c.length && l("d", t(null, c))
-        }
-
-        function r(l, u) {
-            var c = u.items;
-            return c.length === 0 ? l : (t(yd(l), c), qs(l, c[0]))
-        }
-
-        function s(l, u) {
-            l.beginPath(), t(l, u)
-        }
-        const a = vd(s);
-
-        function o(l, u, c, f, h, d) {
-            var g = u.items,
-                p = u.bounds;
-            return !g || !g.length || p && !p.contains(h, d) ? null : (c *= l.pixelRatio, f *= l.pixelRatio, a(l, g, c, f) ? g[0] : null)
-        }
-        return {
-            type: e,
-            tag: "path",
-            nested: !0,
-            attr: i,
-            bound: r,
-            draw: YJ(s),
-            pick: o,
-            isect: Ow,
-            tip: n
-        }
-    }
-    var tQ = Lw("area", PJ, QJ);
-
-    function nQ(e, t) {
-        var n = t.clip;
-        e.save(), $e(n) ? (e.beginPath(), n(e), e.clip()) : yP(e, t.group)
-    }
-
-    function yP(e, t) {
-        e.beginPath(), Aw(t) ? kc(e, t, 0, 0) : e.rect(0, 0, t.width || 0, t.height || 0), e.clip()
-    }
-
-    function vP(e) {
-        const t = Gi(e.strokeWidth, 1);
-        return e.strokeOffset != null ? e.strokeOffset : e.stroke && t > .5 && t < 1.5 ? .5 - Math.abs(t - 1) : 0
-    }
-
-    function iQ(e, t) {
-        e("transform", mP(t))
-    }
-
-    function bP(e, t) {
-        const n = vP(t);
-        e("d", kc(null, t, n, n))
-    }
-
-    function rQ(e, t) {
-        e("class", "background"), e("aria-hidden", !0), bP(e, t)
-    }
-
-    function sQ(e, t) {
-        e("class", "foreground"), e("aria-hidden", !0), t.strokeForeground ? bP(e, t) : e("d", "")
-    }
-
-    function aQ(e, t, n) {
-        const i = t.clip ? $w(n, t, t) : null;
-        e("clip-path", i)
-    }
-
-    function oQ(e, t) {
-        if (!t.clip && t.items) {
-            const n = t.items,
-                i = n.length;
-            for (let r = 0; r < i; ++r) e.union(n[r].bounds)
-        }
-        return (t.clip || t.width || t.height) && !t.noBound && e.add(0, 0).add(t.width || 0, t.height || 0), qs(e, t), e.translate(t.x || 0, t.y || 0)
-    }
-
-    function Ah(e, t, n, i) {
-        const r = vP(t);
-        e.beginPath(), kc(e, t, (n || 0) + r, (i || 0) + r)
-    }
-    const lQ = vd(Ah),
-        uQ = vd(Ah, !1),
-        cQ = vd(Ah, !0);
-
-    function fQ(e, t, n) {
-        dr(t, i => {
-            const r = i.x || 0,
-                s = i.y || 0,
-                a = i.strokeForeground,
-                o = i.opacity == null ? 1 : i.opacity;
-            (i.stroke || i.fill) && o && (Ah(e, i, r, s), Yu(e, i), i.fill && p0(e, i, o) && e.fill(), i.stroke && !a && Xu(e, i, o) && e.stroke()), e.save(), e.translate(r, s), i.clip && yP(e, i), n && n.translate(-r, -s), dr(i, l => {
-                this.draw(e, l, n)
-            }), n && n.translate(r, s), e.restore(), a && i.stroke && o && (Ah(e, i, r, s), Yu(e, i), Xu(e, i, o) && e.stroke())
-        })
-    }
-
-    function hQ(e, t, n, i, r, s) {
-        if (t.bounds && !t.bounds.contains(r, s) || !t.items) return null;
-        const a = n * e.pixelRatio,
-            o = i * e.pixelRatio;
-        return m0(t, l => {
-            let u, c, f;
-            const h = l.bounds;
-            if (h && !h.contains(r, s)) return;
-            c = l.x || 0, f = l.y || 0;
-            const d = c + (l.width || 0),
-                g = f + (l.height || 0),
-                p = l.clip;
-            if (p && (r < c || r > d || s < f || s > g)) return;
-            if (e.save(), e.translate(c, f), c = r - c, f = s - f, p && Aw(l) && !cQ(e, l, a, o)) return e.restore(), null;
-            const m = l.strokeForeground,
-                y = t.interactive !== !1;
-            return y && m && l.stroke && uQ(e, l, a, o) ? (e.restore(), l) : (u = m0(l, v => dQ(v, c, f) ? this.pick(v, n, i, c, f) : null), !u && y && (l.fill || !m && l.stroke) && lQ(e, l, a, o) && (u = l), e.restore(), u || null)
-        })
-    }
-
-    function dQ(e, t, n) {
-        return (e.interactive !== !1 || e.marktype === "group") && e.bounds && e.bounds.contains(t, n)
-    }
-    var gQ = {
-            type: "group",
-            tag: "g",
-            nested: !1,
-            attr: iQ,
-            bound: oQ,
-            draw: fQ,
-            pick: hQ,
-            isect: hP,
-            content: aQ,
-            background: rQ,
-            foreground: sQ
-        },
-        $h = {
-            xmlns: "http://www.w3.org/2000/svg",
-            "xmlns:xlink": "http://www.w3.org/1999/xlink",
-            version: "1.1"
-        };
-
-    function Iw(e, t) {
-        var n = e.image;
-        return (!n || e.url && e.url !== n.url) && (n = {
-            complete: !1,
-            width: 0,
-            height: 0
-        }, t.loadImage(e.url).then(i => {
-            e.image = i, e.image.url = e.url
-        })), n
-    }
-
-    function zw(e, t) {
-        return e.width != null ? e.width : !t || !t.width ? 0 : e.aspect !== !1 && e.height ? e.height * t.width / t.height : t.width
-    }
-
-    function Bw(e, t) {
-        return e.height != null ? e.height : !t || !t.height ? 0 : e.aspect !== !1 && e.width ? e.width * t.height / t.width : t.height
-    }
-
-    function Jm(e, t) {
-        return e === "center" ? t / 2 : e === "right" ? t : 0
-    }
-
-    function Qm(e, t) {
-        return e === "middle" ? t / 2 : e === "bottom" ? t : 0
-    }
-
-    function pQ(e, t, n) {
-        const i = Iw(t, n),
-            r = zw(t, i),
-            s = Bw(t, i),
-            a = (t.x || 0) - Jm(t.align, r),
-            o = (t.y || 0) - Qm(t.baseline, s),
-            l = !i.src && i.toDataURL ? i.toDataURL() : i.src || "";
-        e("href", l, $h["xmlns:xlink"], "xlink:href"), e("transform", Go(a, o)), e("width", r), e("height", s), e("preserveAspectRatio", t.aspect === !1 ? "none" : "xMidYMid")
-    }
-
-    function mQ(e, t) {
-        const n = t.image,
-            i = zw(t, n),
-            r = Bw(t, n),
-            s = (t.x || 0) - Jm(t.align, i),
-            a = (t.y || 0) - Qm(t.baseline, r);
-        return e.set(s, a, s + i, a + r)
-    }
-
-    function yQ(e, t, n) {
-        dr(t, i => {
-            if (n && !n.intersects(i.bounds)) return;
-            const r = Iw(i, this);
-            let s = zw(i, r),
-                a = Bw(i, r);
-            if (s === 0 || a === 0) return;
-            let o = (i.x || 0) - Jm(i.align, s),
-                l = (i.y || 0) - Qm(i.baseline, a),
-                u, c, f, h;
-            i.aspect !== !1 && (c = r.width / r.height, f = i.width / i.height, c === c && f === f && c !== f && (f < c ? (h = s / c, l += (a - h) / 2, a = h) : (h = a * c, o += (s - h) / 2, s = h))), (r.complete || r.toDataURL) && (Yu(e, i), e.globalAlpha = (u = i.opacity) != null ? u : 1, e.imageSmoothingEnabled = i.smooth !== !1, e.drawImage(r, o, l, s, a))
-        })
-    }
-    var vQ = {
-            type: "image",
-            tag: "image",
-            nested: !1,
-            attr: pQ,
-            bound: mQ,
-            draw: yQ,
-            pick: Km(),
-            isect: Ri,
-            get: Iw,
-            xOffset: Jm,
-            yOffset: Qm
-        },
-        bQ = Lw("line", LJ, ZJ);
-
-    function xQ(e, t) {
-        var n = t.scaleX || 1,
-            i = t.scaleY || 1;
-        (n !== 1 || i !== 1) && e("vector-effect", "non-scaling-stroke"), e("transform", KJ(t)), e("d", t.path)
-    }
-
-    function ip(e, t) {
-        var n = t.path;
-        if (n == null) return !0;
-        var i = t.x || 0,
-            r = t.y || 0,
-            s = t.scaleX || 1,
-            a = t.scaleY || 1,
-            o = (t.angle || 0) * Da,
-            l = t.pathCache;
-        (!l || l.path !== n) && ((t.pathCache = l = Hu(n)).path = n), o && e.rotate && e.translate ? (e.translate(i, r), e.rotate(o), kh(e, l, 0, 0, s, a), e.rotate(-o), e.translate(-i, -r)) : kh(e, l, i, r, s, a)
-    }
-
-    function _Q(e, t) {
-        return ip(yd(e, t.angle), t) ? e.set(0, 0, 0, 0) : qs(e, t, !0)
-    }
-    var wQ = {
-        type: "path",
-        tag: "path",
-        nested: !1,
-        attr: xQ,
-        bound: _Q,
-        draw: Rw(ip),
-        pick: Dw(ip),
-        isect: Mw(ip)
-    };
-
-    function SQ(e, t) {
-        e("d", kc(null, t))
-    }
-
-    function EQ(e, t) {
-        var n, i;
-        return qs(e.set(n = t.x || 0, i = t.y || 0, n + t.width || 0, i + t.height || 0), t)
-    }
-
-    function J$(e, t) {
-        e.beginPath(), kc(e, t)
-    }
-    var CQ = {
-        type: "rect",
-        tag: "path",
-        nested: !1,
-        attr: SQ,
-        bound: EQ,
-        draw: Rw(J$),
-        pick: Dw(J$),
-        isect: hP
-    };
-
-    function kQ(e, t) {
-        e("transform", mP(t)), e("x2", t.x2 != null ? t.x2 - (t.x || 0) : 0), e("y2", t.y2 != null ? t.y2 - (t.y || 0) : 0)
-    }
-
-    function AQ(e, t) {
-        var n, i;
-        return qs(e.set(n = t.x || 0, i = t.y || 0, t.x2 != null ? t.x2 : n, t.y2 != null ? t.y2 : i), t)
+    function lee(e) {
+        return e.parentId
     }
 
-    function xP(e, t, n) {
-        var i, r, s, a;
-        return t.stroke && Xu(e, t, n) ? (i = t.x || 0, r = t.y || 0, s = t.x2 != null ? t.x2 : i, a = t.y2 != null ? t.y2 : r, e.beginPath(), e.moveTo(i, r), e.lineTo(s, a), !0) : !1
-    }
+    function jT() {
+        var e = oee,
+            t = lee,
+            n;
 
-    function $Q(e, t, n) {
-        dr(t, i => {
-            if (!(n && !n.intersects(i.bounds))) {
-                var r = i.opacity == null ? 1 : i.opacity;
-                r && xP(e, i, r) && (Yu(e, i), e.stroke())
+        function i(r) {
+            var s = Array.from(r),
+                a = e,
+                o = t,
+                l, u, c, f, h, d, g, p, m = new Map;
+            if (n != null) {
+                const y = s.map((x, _) => uee(n(x, _, r))),
+                    v = y.map(GT),
+                    b = new Set(y).add("");
+                for (const x of v) b.has(x) || (b.add(x), y.push(x), v.push(GT(x)), s.push(Tv));
+                a = (x, _) => y[_], o = (x, _) => v[_]
             }
-        })
-    }
-
-    function TQ(e, t, n, i) {
-        return e.isPointInStroke ? xP(e, t, 1) && e.isPointInStroke(n, i) : !1
-    }
-    var MQ = {
-            type: "rule",
-            tag: "line",
-            nested: !1,
-            attr: kQ,
-            bound: AQ,
-            draw: $Q,
-            pick: Km(TQ),
-            isect: dP
-        },
-        OQ = Pw("shape", IJ),
-        FQ = Pw("symbol", zJ, Ow);
-    const Q$ = sD();
-    var sr = {
-        height: is,
-        measureWidth: jw,
-        estimateWidth: l2,
-        width: l2,
-        canvas: _P
-    };
-    _P(!0);
-
-    function _P(e) {
-        sr.width = e && Aa ? jw : l2
-    }
-
-    function l2(e, t) {
-        return wP(Pa(e, t), is(e))
-    }
-
-    function wP(e, t) {
-        return ~~(.8 * e.length * t)
-    }
-
-    function jw(e, t) {
-        return is(e) <= 0 || !(t = Pa(e, t)) ? 0 : SP(t, Zm(e))
-    }
-
-    function SP(e, t) {
-        const n = `(${t}) ${e}`;
-        let i = Q$.get(n);
-        return i === void 0 && (Aa.font = t, i = Aa.measureText(e).width, Q$.set(n, i)), i
-    }
-
-    function is(e) {
-        return e.fontSize != null ? +e.fontSize || 0 : 11
-    }
-
-    function Na(e) {
-        return e.lineHeight != null ? e.lineHeight : is(e) + 2
-    }
-
-    function RQ(e) {
-        return W(e) ? e.length > 1 ? e : e[0] : e
-    }
-
-    function bd(e) {
-        return RQ(e.lineBreak && e.text && !W(e.text) ? e.text.split(e.lineBreak) : e.text)
-    }
-
-    function Uw(e) {
-        const t = bd(e);
-        return (W(t) ? t.length - 1 : 0) * Na(e)
-    }
-
-    function Pa(e, t) {
-        const n = t == null ? "" : (t + "").trim();
-        return e.limit > 0 && n.length ? NQ(e, n) : n
-    }
-
-    function DQ(e) {
-        if (sr.width === jw) {
-            const t = Zm(e);
-            return n => SP(n, t)
-        } else {
-            const t = is(e);
-            return n => wP(n, t)
-        }
-    }
-
-    function NQ(e, t) {
-        var n = +e.limit,
-            i = DQ(e);
-        if (i(t) < n) return t;
-        var r = e.ellipsis || "…",
-            s = e.dir === "rtl",
-            a = 0,
-            o = t.length,
-            l;
-        if (n -= i(r), s) {
-            for (; a < o;) l = a + o >>> 1, i(t.slice(l)) > n ? a = l + 1 : o = l;
-            return r + t.slice(a)
-        } else {
-            for (; a < o;) l = 1 + (a + o >>> 1), i(t.slice(0, l)) < n ? a = l : o = l - 1;
-            return t.slice(0, a) + r
-        }
-    }
-
-    function xd(e, t) {
-        var n = e.font;
-        return (t && n ? String(n).replace(/"/g, "'") : n) || "sans-serif"
-    }
-
-    function Zm(e, t) {
-        return (e.fontStyle ? e.fontStyle + " " : "") + (e.fontVariant ? e.fontVariant + " " : "") + (e.fontWeight ? e.fontWeight + " " : "") + is(e) + "px " + xd(e, t)
-    }
-
-    function Gw(e) {
-        var t = e.baseline,
-            n = is(e);
-        return Math.round(t === "top" ? .79 * n : t === "middle" ? .3 * n : t === "bottom" ? -.21 * n : t === "line-top" ? .29 * n + .5 * Na(e) : t === "line-bottom" ? .29 * n - .5 * Na(e) : 0)
-    }
-    const PQ = {
-            left: "start",
-            center: "middle",
-            right: "end"
-        },
-        th = new kt;
-
-    function e1(e) {
-        var t = e.x || 0,
-            n = e.y || 0,
-            i = e.radius || 0,
-            r;
-        return i && (r = (e.theta || 0) - To, t += i * Math.cos(r), n += i * Math.sin(r)), th.x1 = t, th.y1 = n, th
-    }
-
-    function LQ(e, t) {
-        var n = t.dx || 0,
-            i = (t.dy || 0) + Gw(t),
-            r = e1(t),
-            s = r.x1,
-            a = r.y1,
-            o = t.angle || 0,
-            l;
-        e("text-anchor", PQ[t.align] || "start"), o ? (l = Go(s, a) + " " + Nw(o), (n || i) && (l += " " + Go(n, i))) : l = Go(s + n, a + i), e("transform", l)
-    }
-
-    function Ww(e, t, n) {
-        var i = sr.height(t),
-            r = t.align,
-            s = e1(t),
-            a = s.x1,
-            o = s.y1,
-            l = t.dx || 0,
-            u = (t.dy || 0) + Gw(t) - Math.round(.8 * i),
-            c = bd(t),
-            f;
-        if (W(c) ? (i += Na(t) * (c.length - 1), f = c.reduce((h, d) => Math.max(h, sr.width(t, d)), 0)) : f = sr.width(t, c), r === "center" ? l -= f / 2 : r === "right" && (l -= f), e.set(l += a, u += o, l + f, u + i), t.angle && !n) e.rotate(t.angle * Da, a, o);
-        else if (n === 2) return e.rotatedPoints(t.angle * Da, a, o);
-        return e
-    }
-
-    function IQ(e, t, n) {
-        dr(t, i => {
-            var r = i.opacity == null ? 1 : i.opacity,
-                s, a, o, l, u, c, f;
-            if (!(n && !n.intersects(i.bounds) || r === 0 || i.fontSize <= 0 || i.text == null || i.text.length === 0)) {
-                if (e.font = Zm(i), e.textAlign = i.align || "left", s = e1(i), a = s.x1, o = s.y1, i.angle && (e.save(), e.translate(a, o), e.rotate(i.angle * Da), a = o = 0), a += i.dx || 0, o += (i.dy || 0) + Gw(i), c = bd(i), Yu(e, i), W(c))
-                    for (u = Na(i), l = 0; l < c.length; ++l) f = Pa(i, c[l]), i.fill && p0(e, i, r) && e.fillText(f, a, o), i.stroke && Xu(e, i, r) && e.strokeText(f, a, o), o += u;
-                else f = Pa(i, c), i.fill && p0(e, i, r) && e.fillText(f, a, o), i.stroke && Xu(e, i, r) && e.strokeText(f, a, o);
-                i.angle && e.restore()
+            for (c = 0, l = s.length; c < l; ++c) u = s[c], d = s[c] = new wc(u), (g = a(u, c, r)) != null && (g += "") && (p = d.id = g, m.set(p, m.has(p) ? BT : d)), (g = o(u, c, r)) != null && (g += "") && (d.parent = g);
+            for (c = 0; c < l; ++c)
+                if (d = s[c], g = d.parent) {
+                    if (h = m.get(g), !h) throw new Error("missing: " + g);
+                    if (h === BT) throw new Error("ambiguous: " + g);
+                    h.children ? h.children.push(d) : h.children = [d], d.parent = h
+                } else {
+                    if (f) throw new Error("multiple roots");
+                    f = d
+                } if (!f) throw new Error("no root");
+            if (n != null) {
+                for (; f.data === Tv && f.children.length === 1;) f = f.children[0], --l;
+                for (let y = s.length - 1; y >= 0 && (d = s[y], d.data === Tv); --y) d.data = null
             }
-        })
-    }
-
-    function zQ(e, t, n, i, r, s) {
-        if (t.fontSize <= 0) return !1;
-        if (!t.angle) return !0;
-        var a = e1(t),
-            o = a.x1,
-            l = a.y1,
-            u = Ww(th, t, 1),
-            c = -t.angle * Da,
-            f = Math.cos(c),
-            h = Math.sin(c),
-            d = f * r - h * s + (o - f * o + h * l),
-            g = h * r + f * s + (l - h * o - f * l);
-        return u.contains(d, g)
-    }
-
-    function BQ(e, t) {
-        const n = Ww(th, e, 2);
-        return du(t, n[0], n[1], n[2], n[3]) || du(t, n[0], n[1], n[4], n[5]) || du(t, n[4], n[5], n[6], n[7]) || du(t, n[2], n[3], n[6], n[7])
-    }
-    var jQ = {
-            type: "text",
-            tag: "text",
-            nested: !1,
-            attr: LQ,
-            bound: Ww,
-            draw: IQ,
-            pick: Km(zQ),
-            isect: BQ
-        },
-        UQ = Lw("trail", BJ, eQ),
-        xi = {
-            arc: JJ,
-            area: tQ,
-            group: gQ,
-            image: vQ,
-            line: bQ,
-            path: wQ,
-            rect: CQ,
-            rule: MQ,
-            shape: OQ,
-            symbol: FQ,
-            text: jQ,
-            trail: UQ
-        };
-
-    function u2(e, t, n) {
-        var i = xi[e.mark.marktype],
-            r = t || i.bound;
-        return i.nested && (e = e.mark), r(e.bounds || (e.bounds = new kt), e, n)
-    }
-    var Z$ = {
-        mark: null
-    };
-
-    function EP(e, t, n) {
-        var i = xi[e.marktype],
-            r = i.bound,
-            s = e.items,
-            a = s && s.length,
-            o, l, u, c;
-        if (i.nested) return a ? u = s[0] : (Z$.mark = e, u = Z$), c = u2(u, r, n), t = t && t.union(c) || c, t;
-        if (t = t || e.bounds && e.bounds.clear() || new kt, a)
-            for (o = 0, l = s.length; o < l; ++o) t.union(u2(s[o], r, n));
-        return e.bounds = t
-    }
-    const GQ = ["marktype", "name", "role", "interactive", "clip", "items", "zindex", "x", "y", "width", "height", "align", "baseline", "fill", "fillOpacity", "opacity", "blend", "stroke", "strokeOpacity", "strokeWidth", "strokeCap", "strokeDash", "strokeDashOffset", "strokeForeground", "strokeOffset", "startAngle", "endAngle", "innerRadius", "outerRadius", "cornerRadius", "padAngle", "cornerRadiusTopLeft", "cornerRadiusTopRight", "cornerRadiusBottomLeft", "cornerRadiusBottomRight", "interpolate", "tension", "orient", "defined", "url", "aspect", "smooth", "path", "scaleX", "scaleY", "x2", "y2", "size", "shape", "text", "angle", "theta", "radius", "dir", "dx", "dy", "ellipsis", "limit", "lineBreak", "lineHeight", "font", "fontSize", "fontWeight", "fontStyle", "fontVariant", "description", "aria", "ariaRole", "ariaRoleDescription"];
-
-    function CP(e, t) {
-        return JSON.stringify(e, GQ, t)
-    }
-
-    function kP(e) {
-        const t = typeof e == "string" ? JSON.parse(e) : e;
-        return AP(t)
-    }
-
-    function AP(e) {
-        var t = e.marktype,
-            n = e.items,
-            i, r, s;
-        if (n)
-            for (r = 0, s = n.length; r < s; ++r) i = t ? "mark" : "group", n[r][i] = e, n[r].zindex && (n[r][i].zdirty = !0), (t || i) === "group" && AP(n[r]);
-        return t && EP(e), e
-    }
-
-    function qw(e) {
-        arguments.length ? this.root = kP(e) : (this.root = $P({
-            marktype: "group",
-            name: "root",
-            role: "frame"
-        }), this.root.items = [new Xm(this.root)])
-    }
-    qw.prototype = {
-        toJSON(e) {
-            return CP(this.root, e || 0)
-        },
-        mark(e, t, n) {
-            t = t || this.root.items[0];
-            const i = $P(e, t);
-            return t.items[n] = i, i.zindex && (i.group.zdirty = !0), i
+            if (f.parent = aee, f.eachBefore(function(y) {
+                    y.depth = y.parent.depth + 1, --l
+                }).eachBefore(mL), f.parent = null, l > 0) throw new Error("cycle");
+            return f
         }
-    };
-
-    function $P(e, t) {
-        const n = {
-            bounds: new kt,
-            clip: !!e.clip,
-            group: t,
-            interactive: e.interactive !== !1,
-            items: [],
-            marktype: e.marktype,
-            name: e.name || void 0,
-            role: e.role || void 0,
-            zindex: e.zindex || 0
-        };
-        return e.aria != null && (n.aria = e.aria), e.description && (n.description = e.description), n
-    }
-
-    function pa(e, t, n) {
-        return !e && typeof document < "u" && document.createElement && (e = document), e ? n ? e.createElementNS(n, t) : e.createElement(t) : null
-    }
-
-    function Hw(e, t) {
-        t = t.toLowerCase();
-        for (var n = e.childNodes, i = 0, r = n.length; i < r; ++i)
-            if (n[i].tagName.toLowerCase() === t) return n[i]
-    }
-
-    function Yn(e, t, n, i) {
-        var r = e.childNodes[t],
-            s;
-        return (!r || r.tagName.toLowerCase() !== n.toLowerCase()) && (s = r || null, r = pa(e.ownerDocument, n, i), e.insertBefore(r, s)), r
-    }
-
-    function Zi(e, t) {
-        for (var n = e.childNodes, i = n.length; i > t;) e.removeChild(n[--i]);
-        return e
+        return i.id = function(r) {
+            return arguments.length ? (e = Dp(r), i) : e
+        }, i.parentId = function(r) {
+            return arguments.length ? (t = Dp(r), i) : t
+        }, i.path = function(r) {
+            return arguments.length ? (n = Dp(r), i) : n
+        }, i
     }
 
-    function TP(e) {
-        return "mark-" + e.marktype + (e.role ? " role-" + e.role : "") + (e.name ? " " + e.name : "")
+    function uee(e) {
+        e = `${e}`;
+        let t = e.length;
+        return J2(e, t - 1) && !J2(e, t - 2) && (e = e.slice(0, -1)), e[0] === "/" ? e : `/${e}`
     }
 
-    function t1(e, t) {
-        const n = t.getBoundingClientRect();
-        return [e.clientX - n.left - (t.clientLeft || 0), e.clientY - n.top - (t.clientTop || 0)]
+    function GT(e) {
+        let t = e.length;
+        if (t < 2) return "";
+        for (; --t > 1 && !J2(e, t););
+        return e.slice(0, t)
     }
 
-    function WQ(e, t, n, i) {
-        var r = e && e.mark,
-            s, a;
-        if (r && (s = xi[r.marktype]).tip) {
-            for (a = t1(t, n), a[0] -= i[0], a[1] -= i[1]; e = e.mark.group;) a[0] -= e.x || 0, a[1] -= e.y || 0;
-            e = s.tip(r.items, a)
+    function J2(e, t) {
+        if (e[t] === "/") {
+            let n = 0;
+            for (; t > 0 && e[--t] === "\\";) ++n;
+            if (!(n & 1)) return !0
         }
-        return e
-    }
-
-    function La(e, t) {
-        this._active = null, this._handlers = {}, this._loader = e || Mm(), this._tooltip = t || qQ
+        return !1
     }
 
-    function qQ(e, t, n, i) {
-        e.element().setAttribute("title", i || "")
+    function cee(e, t) {
+        return e.parent === t.parent ? 1 : 2
     }
-    La.prototype = {
-        initialize(e, t, n) {
-            return this._el = e, this._obj = n || null, this.origin(t)
-        },
-        element() {
-            return this._el
-        },
-        canvas() {
-            return this._el && this._el.firstChild
-        },
-        origin(e) {
-            return arguments.length ? (this._origin = e || [0, 0], this) : this._origin.slice()
-        },
-        scene(e) {
-            return arguments.length ? (this._scene = e, this) : this._scene
-        },
-        on() {},
-        off() {},
-        _handlerIndex(e, t, n) {
-            for (let i = e ? e.length : 0; --i >= 0;)
-                if (e[i].type === t && (!n || e[i].handler === n)) return i;
-            return -1
-        },
-        handlers(e) {
-            const t = this._handlers,
-                n = [];
-            if (e) n.push(...t[this.eventName(e)]);
-            else
-                for (const i in t) n.push(...t[i]);
-            return n
-        },
-        eventName(e) {
-            const t = e.indexOf(".");
-            return t < 0 ? e : e.slice(0, t)
-        },
-        handleHref(e, t, n) {
-            this._loader.sanitize(n, {
-                context: "href"
-            }).then(i => {
-                const r = new MouseEvent(e.type, e),
-                    s = pa(null, "a");
-                for (const a in i) s.setAttribute(a, i[a]);
-                s.dispatchEvent(r)
-            }).catch(() => {})
-        },
-        handleTooltip(e, t, n) {
-            if (t && t.tooltip != null) {
-                t = WQ(t, e, this.canvas(), this._origin);
-                const i = n && t && t.tooltip || null;
-                this._tooltip.call(this._obj, this, e, t, i)
-            }
-        },
-        getItemBoundingClientRect(e) {
-            const t = this.canvas();
-            if (!t) return;
-            const n = t.getBoundingClientRect(),
-                i = this._origin,
-                r = e.bounds,
-                s = r.width(),
-                a = r.height();
-            let o = r.x1 + i[0] + n.left,
-                l = r.y1 + i[1] + n.top;
-            for (; e.mark && (e = e.mark.group);) o += e.x || 0, l += e.y || 0;
-            return {
-                x: o,
-                y: l,
-                width: s,
-                height: a,
-                left: o,
-                top: l,
-                right: o + s,
-                bottom: l + a
-            }
-        }
-    };
 
-    function rs(e) {
-        this._el = null, this._bgcolor = null, this._loader = new Tw(e)
-    }
-    rs.prototype = {
-        initialize(e, t, n, i, r) {
-            return this._el = e, this.resize(t, n, i, r)
-        },
-        element() {
-            return this._el
-        },
-        canvas() {
-            return this._el && this._el.firstChild
-        },
-        background(e) {
-            return arguments.length === 0 ? this._bgcolor : (this._bgcolor = e, this)
-        },
-        resize(e, t, n, i) {
-            return this._width = e, this._height = t, this._origin = n || [0, 0], this._scale = i || 1, this
-        },
-        dirty() {},
-        render(e) {
-            const t = this;
-            return t._call = function() {
-                t._render(e)
-            }, t._call(), t._call = null, t
-        },
-        _render() {},
-        renderAsync(e) {
-            const t = this.render(e);
-            return this._ready ? this._ready.then(() => t) : Promise.resolve(t)
-        },
-        _load(e, t) {
-            var n = this,
-                i = n._loader[e](t);
-            if (!n._ready) {
-                const r = n._call;
-                n._ready = n._loader.ready().then(s => {
-                    s && r(), n._ready = null
-                })
-            }
-            return i
-        },
-        sanitizeURL(e) {
-            return this._load("sanitizeURL", e)
-        },
-        loadImage(e) {
-            return this._load("loadImage", e)
-        }
-    };
-    const HQ = "keydown",
-        YQ = "keypress",
-        XQ = "keyup",
-        MP = "dragenter",
-        rp = "dragleave",
-        OP = "dragover",
-        c2 = "mousedown",
-        VQ = "mouseup",
-        y0 = "mousemove",
-        nh = "mouseout",
-        FP = "mouseover",
-        v0 = "click",
-        KQ = "dblclick",
-        JQ = "wheel",
-        RP = "mousewheel",
-        b0 = "touchstart",
-        x0 = "touchmove",
-        _0 = "touchend",
-        QQ = [HQ, YQ, XQ, MP, rp, OP, c2, VQ, y0, nh, FP, v0, KQ, JQ, RP, b0, x0, _0],
-        f2 = y0,
-        Th = nh,
-        h2 = v0;
-
-    function _d(e, t) {
-        La.call(this, e, t), this._down = null, this._touch = null, this._first = !0, this._events = {}
+    function Mv(e) {
+        var t = e.children;
+        return t ? t[0] : e.t
     }
-    const ZQ = e => e === b0 || e === x0 || e === _0 ? [b0, x0, _0] : [e];
 
-    function eT(e, t) {
-        ZQ(t).forEach(n => eZ(e, n))
+    function Ov(e) {
+        var t = e.children;
+        return t ? t[t.length - 1] : e.t
     }
 
-    function eZ(e, t) {
-        const n = e.canvas();
-        n && !e._events[t] && (e._events[t] = 1, n.addEventListener(t, e[t] ? i => e[t](i) : i => e.fire(t, i)))
+    function fee(e, t, n) {
+        var i = n / (t.i - e.i);
+        t.c -= i, t.s += n, e.c += i, t.z += n, t.m += n
     }
 
-    function tT(e, t, n) {
-        return function(i) {
-            const r = this._active,
-                s = this.pickEvent(i);
-            s === r ? this.fire(e, i) : ((!r || !r.exit) && this.fire(n, i), this._active = s, this.fire(t, i), this.fire(e, i))
-        }
+    function hee(e) {
+        for (var t = 0, n = 0, i = e.children, r = i.length, s; --r >= 0;) s = i[r], s.z += t, s.m += t, t += s.s + (n += s.c)
     }
 
-    function nT(e) {
-        return function(t) {
-            this.fire(e, t), this._active = null
-        }
+    function dee(e, t, n) {
+        return e.a.parent === t.parent ? e.a : n
     }
-    ee(_d, La, {
-        initialize(e, t, n) {
-            return this._canvas = e && Hw(e, "canvas"), [v0, c2, y0, nh, rp].forEach(i => eT(this, i)), La.prototype.initialize.call(this, e, t, n)
-        },
-        canvas() {
-            return this._canvas
-        },
-        context() {
-            return this._canvas.getContext("2d")
-        },
-        events: QQ,
-        DOMMouseScroll(e) {
-            this.fire(RP, e)
-        },
-        mousemove: tT(y0, FP, nh),
-        dragover: tT(OP, MP, rp),
-        mouseout: nT(nh),
-        dragleave: nT(rp),
-        mousedown(e) {
-            this._down = this._active, this.fire(c2, e)
-        },
-        click(e) {
-            this._down === this._active && (this.fire(v0, e), this._down = null)
-        },
-        touchstart(e) {
-            this._touch = this.pickEvent(e.changedTouches[0]), this._first && (this._active = this._touch, this._first = !1), this.fire(b0, e, !0)
-        },
-        touchmove(e) {
-            this.fire(x0, e, !0)
-        },
-        touchend(e) {
-            this.fire(_0, e, !0), this._touch = null
-        },
-        fire(e, t, n) {
-            const i = n ? this._touch : this._active,
-                r = this._handlers[e];
-            if (t.vegaType = e, e === h2 && i && i.href ? this.handleHref(t, i, i.href) : (e === f2 || e === Th) && this.handleTooltip(t, i, e !== Th), r)
-                for (let s = 0, a = r.length; s < a; ++s) r[s].handler.call(this._obj, t, i)
-        },
-        on(e, t) {
-            const n = this.eventName(e),
-                i = this._handlers;
-            return this._handlerIndex(i[n], e, t) < 0 && (eT(this, e), (i[n] || (i[n] = [])).push({
-                type: e,
-                handler: t
-            })), this
-        },
-        off(e, t) {
-            const n = this.eventName(e),
-                i = this._handlers[n],
-                r = this._handlerIndex(i, e, t);
-            return r >= 0 && i.splice(r, 1), this
-        },
-        pickEvent(e) {
-            const t = t1(e, this._canvas),
-                n = this._origin;
-            return this.pick(this._scene, t[0], t[1], t[0] - n[0], t[1] - n[1])
-        },
-        pick(e, t, n, i, r) {
-            const s = this.context();
-            return xi[e.marktype].pick.call(this, s, e, t, n, i, r)
-        }
-    });
 
-    function tZ() {
-        return typeof window < "u" && window.devicePixelRatio || 1
+    function Np(e, t) {
+        this._ = e, this.parent = null, this.children = null, this.A = null, this.a = this, this.z = 0, this.m = 0, this.c = 0, this.s = 0, this.t = null, this.i = t
     }
-    var nZ = tZ();
+    Np.prototype = Object.create(wc.prototype);
 
-    function iZ(e, t, n, i, r, s) {
-        const a = typeof HTMLElement < "u" && e instanceof HTMLElement && e.parentNode != null,
-            o = e.getContext("2d"),
-            l = a ? nZ : r;
-        e.width = t * l, e.height = n * l;
-        for (const u in s) o[u] = s[u];
-        return a && l !== 1 && (e.style.width = t + "px", e.style.height = n + "px"), o.pixelRatio = l, o.setTransform(l, 0, 0, l, l * i[0], l * i[1]), e
+    function gee(e) {
+        for (var t = new Np(e, 0), n, i = [t], r, s, a, o; n = i.pop();)
+            if (s = n._.children)
+                for (n.children = new Array(o = s.length), a = o - 1; a >= 0; --a) i.push(r = n.children[a] = new Np(s[a], a)), r.parent = n;
+        return (t.parent = new Np(null, 0)).children = [t], t
     }
 
-    function w0(e) {
-        rs.call(this, e), this._options = {}, this._redraw = !1, this._dirty = new kt, this._tempb = new kt
-    }
-    const iT = rs.prototype,
-        rZ = (e, t, n) => new kt().set(0, 0, t, n).translate(-e[0], -e[1]);
+    function pee() {
+        var e = cee,
+            t = 1,
+            n = 1,
+            i = null;
 
-    function sZ(e, t, n) {
-        return t.expand(1).round(), e.pixelRatio % 1 && t.scale(e.pixelRatio).round().scale(1 / e.pixelRatio), t.translate(-(n[0] % 1), -(n[1] % 1)), e.beginPath(), e.rect(t.x1, t.y1, t.width(), t.height()), e.clip(), t
-    }
-    ee(w0, rs, {
-        initialize(e, t, n, i, r, s) {
-            return this._options = s || {}, this._canvas = this._options.externalContext ? null : ka(1, 1, this._options.type), e && this._canvas && (Zi(e, 0).appendChild(this._canvas), this._canvas.setAttribute("class", "marks")), iT.initialize.call(this, e, t, n, i, r)
-        },
-        resize(e, t, n, i) {
-            if (iT.resize.call(this, e, t, n, i), this._canvas) iZ(this._canvas, this._width, this._height, this._origin, this._scale, this._options.context);
+        function r(u) {
+            var c = gee(u);
+            if (c.eachAfter(s), c.parent.m = -c.z, c.eachBefore(a), i) u.eachBefore(l);
             else {
-                const r = this._options.externalContext;
-                r || U("CanvasRenderer is missing a valid canvas or context"), r.scale(this._scale, this._scale), r.translate(this._origin[0], this._origin[1])
-            }
-            return this._redraw = !0, this
-        },
-        canvas() {
-            return this._canvas
-        },
-        context() {
-            return this._options.externalContext || (this._canvas ? this._canvas.getContext("2d") : null)
-        },
-        dirty(e) {
-            const t = this._tempb.clear().union(e.bounds);
-            let n = e.mark.group;
-            for (; n;) t.translate(n.x || 0, n.y || 0), n = n.mark.group;
-            this._dirty.union(t)
-        },
-        _render(e) {
-            const t = this.context(),
-                n = this._origin,
-                i = this._width,
-                r = this._height,
-                s = this._dirty,
-                a = rZ(n, i, r);
-            t.save();
-            const o = this._redraw || s.empty() ? (this._redraw = !1, a.expand(1)) : sZ(t, a.intersect(s), n);
-            return this.clear(-n[0], -n[1], i, r), this.draw(t, e, o), t.restore(), s.clear(), this
-        },
-        draw(e, t, n) {
-            const i = xi[t.marktype];
-            t.clip && nQ(e, t), i.draw.call(this, e, t, n), t.clip && e.restore()
-        },
-        clear(e, t, n, i) {
-            const r = this._options,
-                s = this.context();
-            r.type !== "pdf" && !r.externalContext && s.clearRect(e, t, n, i), this._bgcolor != null && (s.fillStyle = this._bgcolor, s.fillRect(e, t, n, i))
-        }
-    });
-
-    function Yw(e, t) {
-        La.call(this, e, t);
-        const n = this;
-        n._hrefHandler = d2(n, (i, r) => {
-            r && r.href && n.handleHref(i, r, r.href)
-        }), n._tooltipHandler = d2(n, (i, r) => {
-            n.handleTooltip(i, r, i.type !== Th)
-        })
-    }
-    const d2 = (e, t) => n => {
-        let i = n.target.__data__;
-        i = Array.isArray(i) ? i[0] : i, n.vegaType = n.type, t.call(e._obj, n, i)
-    };
-    ee(Yw, La, {
-        initialize(e, t, n) {
-            let i = this._svg;
-            return i && (i.removeEventListener(h2, this._hrefHandler), i.removeEventListener(f2, this._tooltipHandler), i.removeEventListener(Th, this._tooltipHandler)), this._svg = i = e && Hw(e, "svg"), i && (i.addEventListener(h2, this._hrefHandler), i.addEventListener(f2, this._tooltipHandler), i.addEventListener(Th, this._tooltipHandler)), La.prototype.initialize.call(this, e, t, n)
-        },
-        canvas() {
-            return this._svg
-        },
-        on(e, t) {
-            const n = this.eventName(e),
-                i = this._handlers;
-            if (this._handlerIndex(i[n], e, t) < 0) {
-                const s = {
-                    type: e,
-                    handler: t,
-                    listener: d2(this, t)
-                };
-                (i[n] || (i[n] = [])).push(s), this._svg && this._svg.addEventListener(n, s.listener)
-            }
-            return this
-        },
-        off(e, t) {
-            const n = this.eventName(e),
-                i = this._handlers[n],
-                r = this._handlerIndex(i, e, t);
-            return r >= 0 && (this._svg && this._svg.removeEventListener(n, i[r].listener), i.splice(r, 1)), this
-        }
-    });
-    const DP = "aria-hidden",
-        Xw = "aria-label",
-        Vw = "role",
-        Kw = "aria-roledescription",
-        NP = "graphics-object",
-        Jw = "graphics-symbol",
-        PP = (e, t, n) => ({
-            [Vw]: e,
-            [Kw]: t,
-            [Xw]: n || void 0
-        }),
-        aZ = fr(["axis-domain", "axis-grid", "axis-label", "axis-tick", "axis-title", "legend-band", "legend-entry", "legend-gradient", "legend-label", "legend-title", "legend-symbol", "title"]),
-        rT = {
-            axis: {
-                desc: "axis",
-                caption: uZ
-            },
-            legend: {
-                desc: "legend",
-                caption: cZ
-            },
-            "title-text": {
-                desc: "title",
-                caption: e => `Title text '${aT(e)}'`
-            },
-            "title-subtitle": {
-                desc: "subtitle",
-                caption: e => `Subtitle text '${aT(e)}'`
-            }
-        },
-        sT = {
-            ariaRole: Vw,
-            ariaRoleDescription: Kw,
-            description: Xw
-        };
-
-    function LP(e, t) {
-        const n = t.aria === !1;
-        if (e(DP, n || void 0), n || t.description == null)
-            for (const i in sT) e(sT[i], void 0);
-        else {
-            const i = t.mark.marktype;
-            e(Xw, t.description), e(Vw, t.ariaRole || (i === "group" ? NP : Jw)), e(Kw, t.ariaRoleDescription || `${i} mark`)
-        }
-    }
-
-    function IP(e) {
-        return e.aria === !1 ? {
-            [DP]: !0
-        } : aZ[e.role] ? null : rT[e.role] ? lZ(e, rT[e.role]) : oZ(e)
-    }
-
-    function oZ(e) {
-        const t = e.marktype,
-            n = t === "group" || t === "text" || e.items.some(i => i.description != null && i.aria !== !1);
-        return PP(n ? NP : Jw, `${t} mark container`, e.description)
-    }
-
-    function lZ(e, t) {
-        try {
-            const n = e.items[0],
-                i = t.caption || (() => "");
-            return PP(t.role || Jw, t.desc, n.description || i(n))
-        } catch {
-            return null
-        }
-    }
-
-    function aT(e) {
-        return se(e.text).join(" ")
-    }
-
-    function uZ(e) {
-        const t = e.datum,
-            n = e.orient,
-            i = t.title ? zP(e) : null,
-            r = e.context,
-            s = r.scales[t.scale].value,
-            a = r.dataflow.locale(),
-            o = s.type;
-        return `${n==="left"||n==="right"?"Y":"X"}-axis` + (i ? ` titled '${i}'` : "") + ` for a ${qu(o)?"discrete":o} scale with ${nP(a,s,e)}`
-    }
-
-    function cZ(e) {
-        const t = e.datum,
-            n = t.title ? zP(e) : null,
-            i = `${t.type||""} legend`.trim(),
-            r = t.scales,
-            s = Object.keys(r),
-            a = e.context,
-            o = a.scales[r[s[0]]].value,
-            l = a.dataflow.locale();
-        return hZ(i) + (n ? ` titled '${n}'` : "") + ` for ${fZ(s)} with ${nP(l,o,e)}`
-    }
-
-    function zP(e) {
-        try {
-            return se(De(e.items).items[0].text).join(" ")
-        } catch {
-            return null
-        }
-    }
-
-    function fZ(e) {
-        return e = e.map(t => t + (t === "fill" || t === "stroke" ? " color" : "")), e.length < 2 ? e[0] : e.slice(0, -1).join(", ") + " and " + De(e)
-    }
-
-    function hZ(e) {
-        return e.length ? e[0].toUpperCase() + e.slice(1) : e
-    }
-    const BP = e => (e + "").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;"),
-        dZ = e => BP(e).replace(/"/g, "&quot;").replace(/\t/g, "&#x9;").replace(/\n/g, "&#xA;").replace(/\r/g, "&#xD;");
-
-    function Qw() {
-        let e = "",
-            t = "",
-            n = "";
-        const i = [],
-            r = () => t = n = "",
-            s = l => {
-                t && (e += `${t}>${n}`, r()), i.push(l)
-            },
-            a = (l, u) => (u != null && (t += ` ${l}="${dZ(u)}"`), o),
-            o = {
-                open(l) {
-                    s(l), t = "<" + l;
-                    for (var u = arguments.length, c = new Array(u > 1 ? u - 1 : 0), f = 1; f < u; f++) c[f - 1] = arguments[f];
-                    for (const h of c)
-                        for (const d in h) a(d, h[d]);
-                    return o
-                },
-                close() {
-                    const l = i.pop();
-                    return t ? e += t + (n ? `>${n}</${l}>` : "/>") : e += `</${l}>`, r(), o
-                },
-                attr: a,
-                text: l => (n += BP(l), o),
-                toString: () => e
-            };
-        return o
-    }
-    const jP = e => UP(Qw(), e) + "";
-
-    function UP(e, t) {
-        if (e.open(t.tagName), t.hasAttributes()) {
-            const n = t.attributes,
-                i = n.length;
-            for (let r = 0; r < i; ++r) e.attr(n[r].name, n[r].value)
-        }
-        if (t.hasChildNodes()) {
-            const n = t.childNodes;
-            for (const i of n) i.nodeType === 3 ? e.text(i.nodeValue) : UP(e, i)
-        }
-        return e.close()
-    }
-    const S0 = {
-            fill: "fill",
-            fillOpacity: "fill-opacity",
-            stroke: "stroke",
-            strokeOpacity: "stroke-opacity",
-            strokeWidth: "stroke-width",
-            strokeCap: "stroke-linecap",
-            strokeJoin: "stroke-linejoin",
-            strokeDash: "stroke-dasharray",
-            strokeDashOffset: "stroke-dashoffset",
-            strokeMiterLimit: "stroke-miterlimit",
-            opacity: "opacity"
-        },
-        E0 = {
-            blend: "mix-blend-mode"
-        },
-        GP = {
-            fill: "none",
-            "stroke-miterlimit": 10
-        },
-        nf = 0,
-        oT = "http://www.w3.org/2000/xmlns/",
-        $t = $h.xmlns;
-
-    function Zw(e) {
-        rs.call(this, e), this._dirtyID = 0, this._dirty = [], this._svg = null, this._root = null, this._defs = null
-    }
-    const nv = rs.prototype;
-    ee(Zw, rs, {
-        initialize(e, t, n, i, r) {
-            return this._defs = {}, this._clearDefs(), e && (this._svg = Yn(e, 0, "svg", $t), this._svg.setAttributeNS(oT, "xmlns", $t), this._svg.setAttributeNS(oT, "xmlns:xlink", $h["xmlns:xlink"]), this._svg.setAttribute("version", $h.version), this._svg.setAttribute("class", "marks"), Zi(e, 1), this._root = Yn(this._svg, nf, "g", $t), ma(this._root, GP), Zi(this._svg, nf + 1)), this.background(this._bgcolor), nv.initialize.call(this, e, t, n, i, r)
-        },
-        background(e) {
-            return arguments.length && this._svg && this._svg.style.setProperty("background-color", e), nv.background.apply(this, arguments)
-        },
-        resize(e, t, n, i) {
-            return nv.resize.call(this, e, t, n, i), this._svg && (ma(this._svg, {
-                width: this._width * this._scale,
-                height: this._height * this._scale,
-                viewBox: `0 0 ${this._width} ${this._height}`
-            }), this._root.setAttribute("transform", `translate(${this._origin})`)), this._dirty = [], this
-        },
-        canvas() {
-            return this._svg
-        },
-        svg() {
-            const e = this._svg,
-                t = this._bgcolor;
-            if (!e) return null;
-            let n;
-            t && (e.removeAttribute("style"), n = Yn(e, nf, "rect", $t), ma(n, {
-                width: this._width,
-                height: this._height,
-                fill: t
-            }));
-            const i = jP(e);
-            return t && (e.removeChild(n), this._svg.style.setProperty("background-color", t)), i
-        },
-        _render(e) {
-            return this._dirtyCheck() && (this._dirtyAll && this._clearDefs(), this.mark(this._root, e), Zi(this._root, 1)), this.defs(), this._dirty = [], ++this._dirtyID, this
-        },
-        dirty(e) {
-            e.dirty !== this._dirtyID && (e.dirty = this._dirtyID, this._dirty.push(e))
-        },
-        isDirty(e) {
-            return this._dirtyAll || !e._svg || !e._svg.ownerSVGElement || e.dirty === this._dirtyID
-        },
-        _dirtyCheck() {
-            this._dirtyAll = !0;
-            const e = this._dirty;
-            if (!e.length || !this._dirtyID) return !0;
-            const t = ++this._dirtyID;
-            let n, i, r, s, a, o, l;
-            for (a = 0, o = e.length; a < o; ++a)
-                if (n = e[a], i = n.mark, i.marktype !== r && (r = i.marktype, s = xi[r]), i.zdirty && i.dirty !== t && (this._dirtyAll = !1, lT(n, t), i.items.forEach(u => {
-                        u.dirty = t
-                    })), !i.zdirty) {
-                    if (n.exit) {
-                        s.nested && i.items.length ? (l = i.items[0], l._svg && this._update(s, l._svg, l)) : n._svg && (l = n._svg.parentNode, l && l.removeChild(n._svg)), n._svg = null;
-                        continue
-                    }
-                    n = s.nested ? i.items[0] : n, n._update !== t && (!n._svg || !n._svg.ownerSVGElement ? (this._dirtyAll = !1, lT(n, t)) : this._update(s, n._svg, n), n._update = t)
-                } return !this._dirtyAll
-        },
-        mark(e, t, n) {
-            if (!this.isDirty(t)) return t._svg;
-            const i = this._svg,
-                r = xi[t.marktype],
-                s = t.interactive === !1 ? "none" : null,
-                a = r.tag === "g",
-                o = uT(t, e, n, "g", i);
-            o.setAttribute("class", TP(t));
-            const l = IP(t);
-            for (const h in l) kn(o, h, l[h]);
-            a || kn(o, "pointer-events", s), kn(o, "clip-path", t.clip ? $w(this, t, t.group) : null);
-            let u = null,
-                c = 0;
-            const f = h => {
-                const d = this.isDirty(h),
-                    g = uT(h, o, u, r.tag, i);
-                d && (this._update(r, g, h), a && mZ(this, g, h)), u = g, ++c
-            };
-            return r.nested ? t.items.length && f(t.items[0]) : dr(t, f), Zi(o, c), o
-        },
-        _update(e, t, n) {
-            As = t, un = t.__values__, LP(ih, n), e.attr(ih, n, this);
-            const i = vZ[e.type];
-            i && i.call(this, e, t, n), As && this.style(As, n)
-        },
-        style(e, t) {
-            if (t != null) {
-                for (const n in S0) {
-                    let i = n === "font" ? xd(t) : t[n];
-                    if (i === un[n]) continue;
-                    const r = S0[n];
-                    i == null ? e.removeAttribute(r) : (Cw(i) && (i = rP(i, this._defs.gradient, WP())), e.setAttribute(r, i + "")), un[n] = i
-                }
-                for (const n in E0) sp(e, E0[n], t[n])
-            }
-        },
-        defs() {
-            const e = this._svg,
-                t = this._defs;
-            let n = t.el,
-                i = 0;
-            for (const r in t.gradient) n || (t.el = n = Yn(e, nf + 1, "defs", $t)), i = gZ(n, t.gradient[r], i);
-            for (const r in t.clipping) n || (t.el = n = Yn(e, nf + 1, "defs", $t)), i = pZ(n, t.clipping[r], i);
-            n && (i === 0 ? (e.removeChild(n), t.el = null) : Zi(n, i))
-        },
-        _clearDefs() {
-            const e = this._defs;
-            e.gradient = {}, e.clipping = {}
-        }
-    });
-
-    function lT(e, t) {
-        for (; e && e.dirty !== t; e = e.mark.group)
-            if (e.dirty = t, e.mark && e.mark.dirty !== t) e.mark.dirty = t;
-            else return
-    }
-
-    function gZ(e, t, n) {
-        let i, r, s;
-        if (t.gradient === "radial") {
-            let a = Yn(e, n++, "pattern", $t);
-            ma(a, {
-                id: g0 + t.id,
-                viewBox: "0,0,1,1",
-                width: "100%",
-                height: "100%",
-                preserveAspectRatio: "xMidYMid slice"
-            }), a = Yn(a, 0, "rect", $t), ma(a, {
-                width: 1,
-                height: 1,
-                fill: `url(${WP()}#${t.id})`
-            }), e = Yn(e, n++, "radialGradient", $t), ma(e, {
-                id: t.id,
-                fx: t.x1,
-                fy: t.y1,
-                fr: t.r1,
-                cx: t.x2,
-                cy: t.y2,
-                r: t.r2
-            })
-        } else e = Yn(e, n++, "linearGradient", $t), ma(e, {
-            id: t.id,
-            x1: t.x1,
-            x2: t.x2,
-            y1: t.y1,
-            y2: t.y2
-        });
-        for (i = 0, r = t.stops.length; i < r; ++i) s = Yn(e, i, "stop", $t), s.setAttribute("offset", t.stops[i].offset), s.setAttribute("stop-color", t.stops[i].color);
-        return Zi(e, i), n
-    }
-
-    function pZ(e, t, n) {
-        let i;
-        return e = Yn(e, n, "clipPath", $t), e.setAttribute("id", t.id), t.path ? (i = Yn(e, 0, "path", $t), i.setAttribute("d", t.path)) : (i = Yn(e, 0, "rect", $t), ma(i, {
-            x: 0,
-            y: 0,
-            width: t.width,
-            height: t.height
-        })), Zi(e, 1), n + 1
-    }
-
-    function mZ(e, t, n) {
-        t = t.lastChild.previousSibling;
-        let i, r = 0;
-        dr(n, s => {
-            i = e.mark(t, s, i), ++r
-        }), Zi(t, 1 + r)
-    }
-
-    function uT(e, t, n, i, r) {
-        let s = e._svg,
-            a;
-        if (!s && (a = t.ownerDocument, s = pa(a, i, $t), e._svg = s, e.mark && (s.__data__ = e, s.__values__ = {
-                fill: "default"
-            }, i === "g"))) {
-            const o = pa(a, "path", $t);
-            s.appendChild(o), o.__data__ = e;
-            const l = pa(a, "g", $t);
-            s.appendChild(l), l.__data__ = e;
-            const u = pa(a, "path", $t);
-            s.appendChild(u), u.__data__ = e, u.__values__ = {
-                fill: "default"
-            }
-        }
-        return (s.ownerSVGElement !== r || yZ(s, n)) && t.insertBefore(s, n ? n.nextSibling : t.firstChild), s
-    }
-
-    function yZ(e, t) {
-        return e.parentNode && e.parentNode.childNodes.length > 1 && e.previousSibling != t
-    }
-    let As = null,
-        un = null;
-    const vZ = {
-        group(e, t, n) {
-            const i = As = t.childNodes[2];
-            un = i.__values__, e.foreground(ih, n, this), un = t.__values__, As = t.childNodes[1], e.content(ih, n, this);
-            const r = As = t.childNodes[0];
-            e.background(ih, n, this);
-            const s = n.mark.interactive === !1 ? "none" : null;
-            if (s !== un.events && (kn(i, "pointer-events", s), kn(r, "pointer-events", s), un.events = s), n.strokeForeground && n.stroke) {
-                const a = n.fill;
-                kn(i, "display", null), this.style(r, n), kn(r, "stroke", null), a && (n.fill = null), un = i.__values__, this.style(i, n), a && (n.fill = a), As = null
-            } else kn(i, "display", "none")
-        },
-        image(e, t, n) {
-            n.smooth === !1 ? (sp(t, "image-rendering", "optimizeSpeed"), sp(t, "image-rendering", "pixelated")) : sp(t, "image-rendering", null)
-        },
-        text(e, t, n) {
-            const i = bd(n);
-            let r, s, a, o;
-            W(i) ? (s = i.map(l => Pa(n, l)), r = s.join(`
-`), r !== un.text && (Zi(t, 0), a = t.ownerDocument, o = Na(n), s.forEach((l, u) => {
-                const c = pa(a, "tspan", $t);
-                c.__data__ = n, c.textContent = l, u && (c.setAttribute("x", 0), c.setAttribute("dy", o)), t.appendChild(c)
-            }), un.text = r)) : (s = Pa(n, i), s !== un.text && (t.textContent = s, un.text = s)), kn(t, "font-family", xd(n)), kn(t, "font-size", is(n) + "px"), kn(t, "font-style", n.fontStyle), kn(t, "font-variant", n.fontVariant), kn(t, "font-weight", n.fontWeight)
-        }
-    };
-
-    function ih(e, t, n) {
-        t !== un[e] && (n ? bZ(As, e, t, n) : kn(As, e, t), un[e] = t)
-    }
-
-    function sp(e, t, n) {
-        n !== un[t] && (n == null ? e.style.removeProperty(t) : e.style.setProperty(t, n + ""), un[t] = n)
-    }
-
-    function ma(e, t) {
-        for (const n in t) kn(e, n, t[n])
-    }
-
-    function kn(e, t, n) {
-        n != null ? e.setAttribute(t, n) : e.removeAttribute(t)
-    }
-
-    function bZ(e, t, n, i) {
-        n != null ? e.setAttributeNS(i, t, n) : e.removeAttributeNS(i, t)
-    }
-
-    function WP() {
-        let e;
-        return typeof window > "u" ? "" : (e = window.location).hash ? e.href.slice(0, -e.hash.length) : e.href
-    }
-
-    function eS(e) {
-        rs.call(this, e), this._text = null, this._defs = {
-            gradient: {},
-            clipping: {}
-        }
-    }
-    ee(eS, rs, {
-        svg() {
-            return this._text
-        },
-        _render(e) {
-            const t = Qw();
-            t.open("svg", Ae({}, $h, {
-                class: "marks",
-                width: this._width * this._scale,
-                height: this._height * this._scale,
-                viewBox: `0 0 ${this._width} ${this._height}`
-            }));
-            const n = this._bgcolor;
-            return n && n !== "transparent" && n !== "none" && t.open("rect", {
-                width: this._width,
-                height: this._height,
-                fill: n
-            }).close(), t.open("g", GP, {
-                transform: "translate(" + this._origin + ")"
-            }), this.mark(t, e), t.close(), this.defs(t), this._text = t.close() + "", this
-        },
-        mark(e, t) {
-            const n = xi[t.marktype],
-                i = n.tag,
-                r = [LP, n.attr];
-            e.open("g", {
-                class: TP(t),
-                "clip-path": t.clip ? $w(this, t, t.group) : null
-            }, IP(t), {
-                "pointer-events": i !== "g" && t.interactive === !1 ? "none" : null
-            });
-            const s = a => {
-                const o = this.href(a);
-                if (o && e.open("a", o), e.open(i, this.attr(t, a, r, i !== "g" ? i : null)), i === "text") {
-                    const l = bd(a);
-                    if (W(l)) {
-                        const u = {
-                            x: 0,
-                            dy: Na(a)
-                        };
-                        for (let c = 0; c < l.length; ++c) e.open("tspan", c ? u : null).text(Pa(a, l[c])).close()
-                    } else e.text(Pa(a, l))
-                } else if (i === "g") {
-                    const l = a.strokeForeground,
-                        u = a.fill,
-                        c = a.stroke;
-                    l && c && (a.stroke = null), e.open("path", this.attr(t, a, n.background, "bgrect")).close(), e.open("g", this.attr(t, a, n.content)), dr(a, f => this.mark(e, f)), e.close(), l && c ? (u && (a.fill = null), a.stroke = c, e.open("path", this.attr(t, a, n.foreground, "bgrect")).close(), u && (a.fill = u)) : e.open("path", this.attr(t, a, n.foreground, "bgfore")).close()
-                }
-                e.close(), o && e.close()
-            };
-            return n.nested ? t.items && t.items.length && s(t.items[0]) : dr(t, s), e.close()
-        },
-        href(e) {
-            const t = e.href;
-            let n;
-            if (t) {
-                if (n = this._hrefs && this._hrefs[t]) return n;
-                this.sanitizeURL(t).then(i => {
-                    i["xlink:href"] = i.href, i.href = null, (this._hrefs || (this._hrefs = {}))[t] = i
+                var f = u,
+                    h = u,
+                    d = u;
+                u.eachBefore(function(v) {
+                    v.x < f.x && (f = v), v.x > h.x && (h = v), v.depth > d.depth && (d = v)
+                });
+                var g = f === h ? 1 : e(f, h) / 2,
+                    p = g - f.x,
+                    m = t / (h.x + g + p),
+                    y = n / (d.depth || 1);
+                u.eachBefore(function(v) {
+                    v.x = (v.x + p) * m, v.y = v.depth * y
                 })
             }
-            return null
-        },
-        attr(e, t, n, i) {
-            const r = {},
-                s = (a, o, l, u) => {
-                    r[u || a] = o
-                };
-            return Array.isArray(n) ? n.forEach(a => a(s, t, this)) : n(s, t, this), i && xZ(r, t, e, i, this._defs), r
-        },
-        defs(e) {
-            const t = this._defs.gradient,
-                n = this._defs.clipping;
-            if (Object.keys(t).length + Object.keys(n).length !== 0) {
-                e.open("defs");
-                for (const r in t) {
-                    const s = t[r],
-                        a = s.stops;
-                    s.gradient === "radial" ? (e.open("pattern", {
-                        id: g0 + r,
-                        viewBox: "0,0,1,1",
-                        width: "100%",
-                        height: "100%",
-                        preserveAspectRatio: "xMidYMid slice"
-                    }), e.open("rect", {
-                        width: "1",
-                        height: "1",
-                        fill: "url(#" + r + ")"
-                    }).close(), e.close(), e.open("radialGradient", {
-                        id: r,
-                        fx: s.x1,
-                        fy: s.y1,
-                        fr: s.r1,
-                        cx: s.x2,
-                        cy: s.y2,
-                        r: s.r2
-                    })) : e.open("linearGradient", {
-                        id: r,
-                        x1: s.x1,
-                        x2: s.x2,
-                        y1: s.y1,
-                        y2: s.y2
-                    });
-                    for (let o = 0; o < a.length; ++o) e.open("stop", {
-                        offset: a[o].offset,
-                        "stop-color": a[o].color
-                    }).close();
-                    e.close()
-                }
-                for (const r in n) {
-                    const s = n[r];
-                    e.open("clipPath", {
-                        id: r
-                    }), s.path ? e.open("path", {
-                        d: s.path
-                    }).close() : e.open("rect", {
-                        x: 0,
-                        y: 0,
-                        width: s.width,
-                        height: s.height
-                    }).close(), e.close()
-                }
-                e.close()
-            }
-        }
-    });
-
-    function xZ(e, t, n, i, r) {
-        let s;
-        if (t == null || (i === "bgrect" && n.interactive === !1 && (e["pointer-events"] = "none"), i === "bgfore" && (n.interactive === !1 && (e["pointer-events"] = "none"), e.display = "none", t.fill !== null))) return e;
-        i === "image" && t.smooth === !1 && (s = ["image-rendering: optimizeSpeed;", "image-rendering: pixelated;"]), i === "text" && (e["font-family"] = xd(t), e["font-size"] = is(t) + "px", e["font-style"] = t.fontStyle, e["font-variant"] = t.fontVariant, e["font-weight"] = t.fontWeight);
-        for (const a in S0) {
-            let o = t[a];
-            const l = S0[a];
-            o === "transparent" && (l === "fill" || l === "stroke") || o != null && (Cw(o) && (o = rP(o, r.gradient, "")), e[l] = o)
-        }
-        for (const a in E0) {
-            const o = t[a];
-            o != null && (s = s || [], s.push(`${E0[a]}: ${o};`))
-        }
-        return s && (e.style = s.join(" ")), e
-    }
-    const qP = "canvas",
-        HP = "png",
-        YP = "svg",
-        XP = "none",
-        ya = {
-            Canvas: qP,
-            PNG: HP,
-            SVG: YP,
-            None: XP
-        },
-        Vu = {};
-    Vu[qP] = Vu[HP] = {
-        renderer: w0,
-        headless: w0,
-        handler: _d
-    };
-    Vu[YP] = {
-        renderer: Zw,
-        headless: eS,
-        handler: Yw
-    };
-    Vu[XP] = {};
-
-    function n1(e, t) {
-        return e = String(e || "").toLowerCase(), arguments.length > 1 ? (Vu[e] = t, this) : Vu[e]
-    }
-
-    function VP(e, t, n) {
-        const i = [],
-            r = new kt().union(t),
-            s = e.marktype;
-        return s ? KP(e, r, n, i) : s === "group" ? JP(e, r, n, i) : U("Intersect scene must be mark node or group item.")
-    }
-
-    function KP(e, t, n, i) {
-        if (_Z(e, t, n)) {
-            const r = e.items,
-                s = e.marktype,
-                a = r.length;
-            let o = 0;
-            if (s === "group")
-                for (; o < a; ++o) JP(r[o], t, n, i);
-            else
-                for (const l = xi[s].isect; o < a; ++o) {
-                    const u = r[o];
-                    QP(u, t, l) && i.push(u)
-                }
-        }
-        return i
-    }
-
-    function _Z(e, t, n) {
-        return e.bounds && t.intersects(e.bounds) && (e.marktype === "group" || e.interactive !== !1 && (!n || n(e)))
-    }
-
-    function JP(e, t, n, i) {
-        n && n(e.mark) && QP(e, t, xi.group.isect) && i.push(e);
-        const r = e.items,
-            s = r && r.length;
-        if (s) {
-            const a = e.x || 0,
-                o = e.y || 0;
-            t.translate(-a, -o);
-            for (let l = 0; l < s; ++l) KP(r[l], t, n, i);
-            t.translate(a, o)
-        }
-        return i
-    }
-
-    function QP(e, t, n) {
-        const i = e.bounds;
-        return t.encloses(i) || t.intersects(i) && n(e, t)
-    }
-    const iv = new kt;
-
-    function ZP(e) {
-        const t = e.clip;
-        if ($e(t)) t(yd(iv.clear()));
-        else if (t) iv.set(0, 0, e.group.width, e.group.height);
-        else return;
-        e.bounds.intersect(iv)
-    }
-    const wZ = 1e-9;
-
-    function tS(e, t, n) {
-        return e === t ? !0 : n === "path" ? e4(e, t) : e instanceof Date && t instanceof Date ? +e == +t : Ze(e) && Ze(t) ? Math.abs(e - t) <= wZ : !e || !t || !ae(e) && !ae(t) ? e == t : SZ(e, t)
-    }
-
-    function e4(e, t) {
-        return tS(Hu(e), Hu(t))
-    }
-
-    function SZ(e, t) {
-        var n = Object.keys(e),
-            i = Object.keys(t),
-            r, s;
-        if (n.length !== i.length) return !1;
-        for (n.sort(), i.sort(), s = n.length - 1; s >= 0; s--)
-            if (n[s] != i[s]) return !1;
-        for (s = n.length - 1; s >= 0; s--)
-            if (r = n[s], !tS(e[r], t[r], r)) return !1;
-        return typeof e == typeof t
-    }
-
-    function EZ() {
-        fP(), VK()
-    }
-    const Ku = "top",
-        er = "left",
-        nr = "right",
-        Ia = "bottom",
-        CZ = "top-left",
-        kZ = "top-right",
-        AZ = "bottom-left",
-        $Z = "bottom-right",
-        nS = "start",
-        g2 = "middle",
-        An = "end",
-        TZ = "x",
-        MZ = "y",
-        i1 = "group",
-        iS = "axis",
-        rS = "title",
-        OZ = "frame",
-        FZ = "scope",
-        sS = "legend",
-        t4 = "row-header",
-        n4 = "row-footer",
-        i4 = "row-title",
-        r4 = "column-header",
-        s4 = "column-footer",
-        a4 = "column-title",
-        RZ = "padding",
-        DZ = "symbol",
-        o4 = "fit",
-        l4 = "fit-x",
-        u4 = "fit-y",
-        NZ = "pad",
-        aS = "none",
-        bg = "all",
-        p2 = "each",
-        oS = "flush",
-        va = "column",
-        ba = "row";
-
-    function c4(e) {
-        L.call(this, null, e)
-    }
-    ee(c4, L, {
-        transform(e, t) {
-            const n = t.dataflow,
-                i = e.mark,
-                r = i.marktype,
-                s = xi[r],
-                a = s.bound;
-            let o = i.bounds,
-                l;
-            if (s.nested) i.items.length && n.dirty(i.items[0]), o = xg(i, a), i.items.forEach(u => {
-                u.bounds.clear().union(o)
-            });
-            else if (r === i1 || e.modified()) switch (t.visit(t.MOD, u => n.dirty(u)), o.clear(), i.items.forEach(u => o.union(xg(u, a))), i.role) {
-                case iS:
-                case sS:
-                case rS:
-                    t.reflow()
-            } else l = t.changed(t.REM), t.visit(t.ADD, u => {
-                o.union(xg(u, a))
-            }), t.visit(t.MOD, u => {
-                l = l || o.alignsWith(u.bounds), n.dirty(u), o.union(xg(u, a))
-            }), l && (o.clear(), i.items.forEach(u => o.union(u.bounds)));
-            return ZP(i), t.modifies("bounds")
-        }
-    });
-
-    function xg(e, t, n) {
-        return t(e.bounds.clear(), e, n)
-    }
-    const cT = ":vega_identifier:";
-
-    function lS(e) {
-        L.call(this, 0, e)
-    }
-    lS.Definition = {
-        type: "Identifier",
-        metadata: {
-            modifies: !0
-        },
-        params: [{
-            name: "as",
-            type: "string",
-            required: !0
-        }]
-    };
-    ee(lS, L, {
-        transform(e, t) {
-            const n = PZ(t.dataflow),
-                i = e.as;
-            let r = n.value;
-            return t.visit(t.ADD, s => s[i] = s[i] || ++r), n.set(this.value = r), t
-        }
-    });
-
-    function PZ(e) {
-        return e._signals[cT] || (e._signals[cT] = e.add(0))
-    }
-
-    function f4(e) {
-        L.call(this, null, e)
-    }
-    ee(f4, L, {
-        transform(e, t) {
-            let n = this.value;
-            n || (n = t.dataflow.scenegraph().mark(e.markdef, LZ(e), e.index), n.group.context = e.context, e.context.group || (e.context.group = n.group), n.source = this.source, n.clip = e.clip, n.interactive = e.interactive, this.value = n);
-            const i = n.marktype === i1 ? Xm : Ym;
-            return t.visit(t.ADD, r => i.call(r, n)), (e.modified("clip") || e.modified("interactive")) && (n.clip = e.clip, n.interactive = !!e.interactive, n.zdirty = !0, t.reflow()), n.items = t.source, t
-        }
-    });
-
-    function LZ(e) {
-        const t = e.groups,
-            n = e.parent;
-        return t && t.size === 1 ? t.get(Object.keys(t.object)[0]) : t && n ? t.lookup(n) : null
-    }
-
-    function h4(e) {
-        L.call(this, null, e)
-    }
-    const fT = {
-            parity: e => e.filter((t, n) => n % 2 ? t.opacity = 0 : 1),
-            greedy: (e, t) => {
-                let n;
-                return e.filter((i, r) => !r || !d4(n.bounds, i.bounds, t) ? (n = i, 1) : i.opacity = 0)
-            }
-        },
-        d4 = (e, t, n) => n > Math.max(t.x1 - e.x2, e.x1 - t.x2, t.y1 - e.y2, e.y1 - t.y2),
-        hT = (e, t) => {
-            for (var n = 1, i = e.length, r = e[0].bounds, s; n < i; r = s, ++n)
-                if (d4(r, s = e[n].bounds, t)) return !0
-        },
-        IZ = e => {
-            const t = e.bounds;
-            return t.width() > 1 && t.height() > 1
-        },
-        zZ = (e, t, n) => {
-            var i = e.range(),
-                r = new kt;
-            return t === Ku || t === Ia ? r.set(i[0], -1 / 0, i[1], 1 / 0) : r.set(-1 / 0, i[0], 1 / 0, i[1]), r.expand(n || 1), s => r.encloses(s.bounds)
-        },
-        dT = e => (e.forEach(t => t.opacity = 1), e),
-        gT = (e, t) => e.reflow(t.modified()).modifies("opacity");
-    ee(h4, L, {
-        transform(e, t) {
-            const n = fT[e.method] || fT.parity,
-                i = e.separation || 0;
-            let r = t.materialize(t.SOURCE).source,
-                s, a;
-            if (!r || !r.length) return;
-            if (!e.method) return e.modified("method") && (dT(r), t = gT(t, e)), t;
-            if (r = r.filter(IZ), !r.length) return;
-            if (e.sort && (r = r.slice().sort(e.sort)), s = dT(r), t = gT(t, e), s.length >= 3 && hT(s, i)) {
-                do s = n(s, i); while (s.length >= 3 && hT(s, i));
-                s.length < 3 && !De(r).opacity && (s.length > 1 && (De(s).opacity = 0), De(r).opacity = 1)
-            }
-            e.boundScale && e.boundTolerance >= 0 && (a = zZ(e.boundScale, e.boundOrient, +e.boundTolerance), r.forEach(l => {
-                a(l) || (l.opacity = 0)
-            }));
-            const o = s[0].mark.bounds.clear();
-            return r.forEach(l => {
-                l.opacity && o.union(l.bounds)
-            }), t
-        }
-    });
-
-    function g4(e) {
-        L.call(this, null, e)
-    }
-    ee(g4, L, {
-        transform(e, t) {
-            const n = t.dataflow;
-            if (t.visit(t.ALL, i => n.dirty(i)), t.fields && t.fields.zindex) {
-                const i = t.source && t.source[0];
-                i && (i.mark.zdirty = !0)
-            }
+            return u
         }
-    });
-    const ln = new kt;
-
-    function gu(e, t, n) {
-        return e[t] === n ? 0 : (e[t] = n, 1)
-    }
-
-    function BZ(e) {
-        var t = e.items[0].orient;
-        return t === er || t === nr
-    }
-
-    function jZ(e) {
-        let t = +e.grid;
-        return [e.ticks ? t++ : -1, e.labels ? t++ : -1, t + +e.domain]
-    }
 
-    function UZ(e, t, n, i) {
-        var r = t.items[0],
-            s = r.datum,
-            a = r.translate != null ? r.translate : .5,
-            o = r.orient,
-            l = jZ(s),
-            u = r.range,
-            c = r.offset,
-            f = r.position,
-            h = r.minExtent,
-            d = r.maxExtent,
-            g = s.title && r.items[l[2]].items[0],
-            p = r.titlePadding,
-            m = r.bounds,
-            y = g && Uw(g),
-            v = 0,
-            b = 0,
-            x, _;
-        switch (ln.clear().union(m), m.clear(), (x = l[0]) > -1 && m.union(r.items[x].bounds), (x = l[1]) > -1 && m.union(r.items[x].bounds), o) {
-            case Ku:
-                v = f || 0, b = -c, _ = Math.max(h, Math.min(d, -m.y1)), m.add(0, -_).add(u, 0), g && _g(e, g, _, p, y, 0, -1, m);
-                break;
-            case er:
-                v = -c, b = f || 0, _ = Math.max(h, Math.min(d, -m.x1)), m.add(-_, 0).add(0, u), g && _g(e, g, _, p, y, 1, -1, m);
-                break;
-            case nr:
-                v = n + c, b = f || 0, _ = Math.max(h, Math.min(d, m.x2)), m.add(0, 0).add(_, u), g && _g(e, g, _, p, y, 1, 1, m);
-                break;
-            case Ia:
-                v = f || 0, b = i + c, _ = Math.max(h, Math.min(d, m.y2)), m.add(0, 0).add(u, _), g && _g(e, g, _, p, 0, 0, 1, m);
-                break;
-            default:
-                v = r.x, b = r.y
+        function s(u) {
+            var c = u.children,
+                f = u.parent.children,
+                h = u.i ? f[u.i - 1] : null;
+            if (c) {
+                hee(u);
+                var d = (c[0].z + c[c.length - 1].z) / 2;
+                h ? (u.z = h.z + e(u._, h._), u.m = u.z - d) : u.z = d
+            } else h && (u.z = h.z + e(u._, h._));
+            u.parent.A = o(u, h, u.parent.A || f[0])
         }
-        return qs(m.translate(v, b), r), gu(r, "x", v + a) | gu(r, "y", b + a) && (r.bounds = ln, e.dirty(r), r.bounds = m, e.dirty(r)), r.mark.bounds.clear().union(m)
-    }
 
-    function _g(e, t, n, i, r, s, a, o) {
-        const l = t.bounds;
-        if (t.auto) {
-            const u = a * (n + r + i);
-            let c = 0,
-                f = 0;
-            e.dirty(t), s ? c = (t.x || 0) - (t.x = u) : f = (t.y || 0) - (t.y = u), t.mark.bounds.clear().union(l.translate(-c, -f)), e.dirty(t)
+        function a(u) {
+            u._.x = u.z + u.parent.m, u.m += u.parent.m
         }
-        o.union(l)
-    }
-    const pT = (e, t) => Math.floor(Math.min(e, t)),
-        mT = (e, t) => Math.ceil(Math.max(e, t));
 
-    function GZ(e) {
-        var t = e.items,
-            n = t.length,
-            i = 0,
-            r, s;
-        const a = {
-            marks: [],
-            rowheaders: [],
-            rowfooters: [],
-            colheaders: [],
-            colfooters: [],
-            rowtitle: null,
-            coltitle: null
-        };
-        for (; i < n; ++i)
-            if (r = t[i], s = r.items, r.marktype === i1) switch (r.role) {
-                case iS:
-                case sS:
-                case rS:
-                    break;
-                case t4:
-                    a.rowheaders.push(...s);
-                    break;
-                case n4:
-                    a.rowfooters.push(...s);
-                    break;
-                case r4:
-                    a.colheaders.push(...s);
-                    break;
-                case s4:
-                    a.colfooters.push(...s);
-                    break;
-                case i4:
-                    a.rowtitle = s[0];
-                    break;
-                case a4:
-                    a.coltitle = s[0];
-                    break;
-                default:
-                    a.marks.push(...s)
+        function o(u, c, f) {
+            if (c) {
+                for (var h = u, d = u, g = c, p = h.parent.children[0], m = h.m, y = d.m, v = g.m, b = p.m, x; g = Ov(g), h = Mv(h), g && h;) p = Mv(p), d = Ov(d), d.a = u, x = g.z + v - h.z - m + e(g._, h._), x > 0 && (fee(dee(g, u, f), u, x), m += x, y += x), v += g.m, m += h.m, b += p.m, y += d.m;
+                g && !Ov(d) && (d.t = g, d.m += v - y), h && !Mv(p) && (p.t = h, p.m += m - b, f = u)
             }
-        return a
-    }
-
-    function WZ(e) {
-        return new kt().set(0, 0, e.width || 0, e.height || 0)
-    }
-
-    function qZ(e) {
-        const t = e.bounds.clone();
-        return t.empty() ? t.set(0, 0, 0, 0) : t.translate(-(e.x || 0), -(e.y || 0))
-    }
-
-    function ct(e, t, n) {
-        const i = ae(e) ? e[t] : e;
-        return i ?? (n !== void 0 ? n : 0)
-    }
-
-    function yT(e) {
-        return e < 0 ? Math.ceil(-e) : 0
-    }
-
-    function p4(e, t, n) {
-        var i = !n.nodirty,
-            r = n.bounds === oS ? WZ : qZ,
-            s = ln.set(0, 0, 0, 0),
-            a = ct(n.align, va),
-            o = ct(n.align, ba),
-            l = ct(n.padding, va),
-            u = ct(n.padding, ba),
-            c = n.columns || t.length,
-            f = c <= 0 ? 1 : Math.ceil(t.length / c),
-            h = t.length,
-            d = Array(h),
-            g = Array(c),
-            p = 0,
-            m = Array(h),
-            y = Array(f),
-            v = 0,
-            b = Array(h),
-            x = Array(h),
-            _ = Array(h),
-            S, w, E, A, C, k, R, $, T, M, F;
-        for (w = 0; w < c; ++w) g[w] = 0;
-        for (w = 0; w < f; ++w) y[w] = 0;
-        for (w = 0; w < h; ++w) k = t[w], C = _[w] = r(k), k.x = k.x || 0, b[w] = 0, k.y = k.y || 0, x[w] = 0, E = w % c, A = ~~(w / c), p = Math.max(p, R = Math.ceil(C.x2)), v = Math.max(v, $ = Math.ceil(C.y2)), g[E] = Math.max(g[E], R), y[A] = Math.max(y[A], $), d[w] = l + yT(C.x1), m[w] = u + yT(C.y1), i && e.dirty(t[w]);
-        for (w = 0; w < h; ++w) w % c === 0 && (d[w] = 0), w < c && (m[w] = 0);
-        if (a === p2)
-            for (E = 1; E < c; ++E) {
-                for (F = 0, w = E; w < h; w += c) F < d[w] && (F = d[w]);
-                for (w = E; w < h; w += c) d[w] = F + g[E - 1]
-            } else if (a === bg) {
-                for (F = 0, w = 0; w < h; ++w) w % c && F < d[w] && (F = d[w]);
-                for (w = 0; w < h; ++w) w % c && (d[w] = F + p)
-            } else
-                for (a = !1, E = 1; E < c; ++E)
-                    for (w = E; w < h; w += c) d[w] += g[E - 1];
-        if (o === p2)
-            for (A = 1; A < f; ++A) {
-                for (F = 0, w = A * c, S = w + c; w < S; ++w) F < m[w] && (F = m[w]);
-                for (w = A * c; w < S; ++w) m[w] = F + y[A - 1]
-            } else if (o === bg) {
-                for (F = 0, w = c; w < h; ++w) F < m[w] && (F = m[w]);
-                for (w = c; w < h; ++w) m[w] = F + v
-            } else
-                for (o = !1, A = 1; A < f; ++A)
-                    for (w = A * c, S = w + c; w < S; ++w) m[w] += y[A - 1];
-        for (T = 0, w = 0; w < h; ++w) T = d[w] + (w % c ? T : 0), b[w] += T - t[w].x;
-        for (E = 0; E < c; ++E)
-            for (M = 0, w = E; w < h; w += c) M += m[w], x[w] += M - t[w].y;
-        if (a && ct(n.center, va) && f > 1)
-            for (w = 0; w < h; ++w) C = a === bg ? p : g[w % c], T = C - _[w].x2 - t[w].x - b[w], T > 0 && (b[w] += T / 2);
-        if (o && ct(n.center, ba) && c !== 1)
-            for (w = 0; w < h; ++w) C = o === bg ? v : y[~~(w / c)], M = C - _[w].y2 - t[w].y - x[w], M > 0 && (x[w] += M / 2);
-        for (w = 0; w < h; ++w) s.union(_[w].translate(b[w], x[w]));
-        switch (T = ct(n.anchor, TZ), M = ct(n.anchor, MZ), ct(n.anchor, va)) {
-            case An:
-                T -= s.width();
-                break;
-            case g2:
-                T -= s.width() / 2
-        }
-        switch (ct(n.anchor, ba)) {
-            case An:
-                M -= s.height();
-                break;
-            case g2:
-                M -= s.height() / 2
-        }
-        for (T = Math.round(T), M = Math.round(M), s.clear(), w = 0; w < h; ++w) t[w].mark.bounds.clear();
-        for (w = 0; w < h; ++w) k = t[w], k.x += b[w] += T, k.y += x[w] += M, s.union(k.mark.bounds.union(k.bounds.translate(b[w], x[w]))), i && e.dirty(k);
-        return s
-    }
-
-    function HZ(e, t, n) {
-        var i = GZ(t),
-            r = i.marks,
-            s = n.bounds === oS ? YZ : XZ,
-            a = n.offset,
-            o = n.columns || r.length,
-            l = o <= 0 ? 1 : Math.ceil(r.length / o),
-            u = l * o,
-            c, f, h, d, g, p, m;
-        const y = p4(e, r, n);
-        y.empty() && y.set(0, 0, 0, 0), i.rowheaders && (p = ct(n.headerBand, ba, null), c = wg(e, i.rowheaders, r, o, l, -ct(a, "rowHeader"), pT, 0, s, "x1", 0, o, 1, p)), i.colheaders && (p = ct(n.headerBand, va, null), f = wg(e, i.colheaders, r, o, o, -ct(a, "columnHeader"), pT, 1, s, "y1", 0, 1, o, p)), i.rowfooters && (p = ct(n.footerBand, ba, null), h = wg(e, i.rowfooters, r, o, l, ct(a, "rowFooter"), mT, 0, s, "x2", o - 1, o, 1, p)), i.colfooters && (p = ct(n.footerBand, va, null), d = wg(e, i.colfooters, r, o, o, ct(a, "columnFooter"), mT, 1, s, "y2", u - o, 1, o, p)), i.rowtitle && (g = ct(n.titleAnchor, ba), m = ct(a, "rowTitle"), m = g === An ? h + m : c - m, p = ct(n.titleBand, ba, .5), vT(e, i.rowtitle, m, 0, y, p)), i.coltitle && (g = ct(n.titleAnchor, va), m = ct(a, "columnTitle"), m = g === An ? d + m : f - m, p = ct(n.titleBand, va, .5), vT(e, i.coltitle, m, 1, y, p))
-    }
-
-    function YZ(e, t) {
-        return t === "x1" ? e.x || 0 : t === "y1" ? e.y || 0 : t === "x2" ? (e.x || 0) + (e.width || 0) : t === "y2" ? (e.y || 0) + (e.height || 0) : void 0
-    }
-
-    function XZ(e, t) {
-        return e.bounds[t]
-    }
-
-    function wg(e, t, n, i, r, s, a, o, l, u, c, f, h, d) {
-        var g = n.length,
-            p = 0,
-            m = 0,
-            y, v, b, x, _, S, w, E, A;
-        if (!g) return p;
-        for (y = c; y < g; y += f) n[y] && (p = a(p, l(n[y], u)));
-        if (!t.length) return p;
-        for (t.length > r && (e.warn("Grid headers exceed limit: " + r), t = t.slice(0, r)), p += s, v = 0, x = t.length; v < x; ++v) e.dirty(t[v]), t[v].mark.bounds.clear();
-        for (y = c, v = 0, x = t.length; v < x; ++v, y += f) {
-            for (S = t[v], _ = S.mark.bounds, b = y; b >= 0 && (w = n[b]) == null; b -= h);
-            o ? (E = d == null ? w.x : Math.round(w.bounds.x1 + d * w.bounds.width()), A = p) : (E = p, A = d == null ? w.y : Math.round(w.bounds.y1 + d * w.bounds.height())), _.union(S.bounds.translate(E - (S.x || 0), A - (S.y || 0))), S.x = E, S.y = A, e.dirty(S), m = a(m, _[u])
-        }
-        return m
-    }
-
-    function vT(e, t, n, i, r, s) {
-        if (t) {
-            e.dirty(t);
-            var a = n,
-                o = n;
-            i ? a = Math.round(r.x1 + s * r.width()) : o = Math.round(r.y1 + s * r.height()), t.bounds.translate(a - (t.x || 0), o - (t.y || 0)), t.mark.bounds.clear().union(t.bounds), t.x = a, t.y = o, e.dirty(t)
-        }
-    }
-
-    function VZ(e, t) {
-        const n = e[t] || {};
-        return (i, r) => n[i] != null ? n[i] : e[i] != null ? e[i] : r
-    }
-
-    function KZ(e, t) {
-        let n = -1 / 0;
-        return e.forEach(i => {
-            i.offset != null && (n = Math.max(n, i.offset))
-        }), n > -1 / 0 ? n : t
-    }
-
-    function JZ(e, t, n, i, r, s, a) {
-        const o = VZ(n, t),
-            l = KZ(e, o("offset", 0)),
-            u = o("anchor", nS),
-            c = u === An ? 1 : u === g2 ? .5 : 0,
-            f = {
-                align: p2,
-                bounds: o("bounds", oS),
-                columns: o("direction") === "vertical" ? 1 : e.length,
-                padding: o("margin", 8),
-                center: o("center"),
-                nodirty: !0
-            };
-        switch (t) {
-            case er:
-                f.anchor = {
-                    x: Math.floor(i.x1) - l,
-                    column: An,
-                    y: c * (a || i.height() + 2 * i.y1),
-                    row: u
-                };
-                break;
-            case nr:
-                f.anchor = {
-                    x: Math.ceil(i.x2) + l,
-                    y: c * (a || i.height() + 2 * i.y1),
-                    row: u
-                };
-                break;
-            case Ku:
-                f.anchor = {
-                    y: Math.floor(r.y1) - l,
-                    row: An,
-                    x: c * (s || r.width() + 2 * r.x1),
-                    column: u
-                };
-                break;
-            case Ia:
-                f.anchor = {
-                    y: Math.ceil(r.y2) + l,
-                    x: c * (s || r.width() + 2 * r.x1),
-                    column: u
-                };
-                break;
-            case CZ:
-                f.anchor = {
-                    x: l,
-                    y: l
-                };
-                break;
-            case kZ:
-                f.anchor = {
-                    x: s - l,
-                    y: l,
-                    column: An
-                };
-                break;
-            case AZ:
-                f.anchor = {
-                    x: l,
-                    y: a - l,
-                    row: An
-                };
-                break;
-            case $Z:
-                f.anchor = {
-                    x: s - l,
-                    y: a - l,
-                    column: An,
-                    row: An
-                };
-                break
+            return f
         }
-        return f
-    }
-
-    function QZ(e, t) {
-        var n = t.items[0],
-            i = n.datum,
-            r = n.orient,
-            s = n.bounds,
-            a = n.x,
-            o = n.y,
-            l, u;
-        return n._bounds ? n._bounds.clear().union(s) : n._bounds = s.clone(), s.clear(), eee(e, n, n.items[0].items[0]), s = ZZ(n, s), l = 2 * n.padding, u = 2 * n.padding, s.empty() || (l = Math.ceil(s.width() + l), u = Math.ceil(s.height() + u)), i.type === DZ && tee(n.items[0].items[0].items[0].items), r !== aS && (n.x = a = 0, n.y = o = 0), n.width = l, n.height = u, qs(s.set(a, o, a + l, o + u), n), n.mark.bounds.clear().union(s), n
-    }
 
-    function ZZ(e, t) {
-        return e.items.forEach(n => t.union(n.bounds)), t.x1 = e.padding, t.y1 = e.padding, t
-    }
-
-    function eee(e, t, n) {
-        var i = t.padding,
-            r = i - n.x,
-            s = i - n.y;
-        if (!t.datum.title)(r || s) && rf(e, n, r, s);
-        else {
-            var a = t.items[1].items[0],
-                o = a.anchor,
-                l = t.titlePadding || 0,
-                u = i - a.x,
-                c = i - a.y;
-            switch (a.orient) {
-                case er:
-                    r += Math.ceil(a.bounds.width()) + l;
-                    break;
-                case nr:
-                case Ia:
-                    break;
-                default:
-                    s += a.bounds.height() + l
-            }
-            switch ((r || s) && rf(e, n, r, s), a.orient) {
-                case er:
-                    c += Kl(t, n, a, o, 1, 1);
-                    break;
-                case nr:
-                    u += Kl(t, n, a, An, 0, 0) + l, c += Kl(t, n, a, o, 1, 1);
-                    break;
-                case Ia:
-                    u += Kl(t, n, a, o, 0, 0), c += Kl(t, n, a, An, -1, 0, 1) + l;
-                    break;
-                default:
-                    u += Kl(t, n, a, o, 0, 0)
-            }(u || c) && rf(e, a, u, c), (u = Math.round(a.bounds.x1 - i)) < 0 && (rf(e, n, -u, 0), rf(e, a, -u, 0))
+        function l(u) {
+            u.x *= t, u.y = u.depth * n
         }
+        return r.separation = function(u) {
+            return arguments.length ? (e = u, r) : e
+        }, r.size = function(u) {
+            return arguments.length ? (i = !1, t = +u[0], n = +u[1], r) : i ? null : [t, n]
+        }, r.nodeSize = function(u) {
+            return arguments.length ? (i = !0, t = +u[0], n = +u[1], r) : i ? [t, n] : null
+        }, r
     }
 
-    function Kl(e, t, n, i, r, s, a) {
-        const o = e.datum.type !== "symbol",
-            l = n.datum.vgrad,
-            u = o && (s || !l) && !a ? t.items[0] : t,
-            c = u.bounds[r ? "y2" : "x2"] - e.padding,
-            f = l && s ? c : 0,
-            h = l && s ? 0 : c,
-            d = r <= 0 ? 0 : Uw(n);
-        return Math.round(i === nS ? f : i === An ? h - d : .5 * (c - d))
-    }
-
-    function rf(e, t, n, i) {
-        t.x += n, t.y += i, t.bounds.translate(n, i), t.mark.bounds.translate(n, i), e.dirty(t)
-    }
-
-    function tee(e) {
-        const t = e.reduce((n, i) => (n[i.column] = Math.max(i.bounds.x2 - i.x, n[i.column] || 0), n), {});
-        e.forEach(n => {
-            n.width = t[n.column], n.height = n.bounds.y2 - n.y
-        })
+    function N1(e, t, n, i, r) {
+        for (var s = e.children, a, o = -1, l = s.length, u = e.value && (r - n) / e.value; ++o < l;) a = s[o], a.x0 = t, a.x1 = i, a.y0 = n, a.y1 = n += a.value * u
     }
+    var _L = (1 + Math.sqrt(5)) / 2;
 
-    function nee(e, t, n, i, r) {
-        var s = t.items[0],
-            a = s.frame,
-            o = s.orient,
-            l = s.anchor,
-            u = s.offset,
-            c = s.padding,
-            f = s.items[0].items[0],
-            h = s.items[1] && s.items[1].items[0],
-            d = o === er || o === nr ? i : n,
-            g = 0,
-            p = 0,
-            m = 0,
-            y = 0,
-            v = 0,
-            b;
-        if (a !== i1 ? o === er ? (g = r.y2, d = r.y1) : o === nr ? (g = r.y1, d = r.y2) : (g = r.x1, d = r.x2) : o === er && (g = i, d = 0), b = l === nS ? g : l === An ? d : (g + d) / 2, h && h.text) {
-            switch (o) {
-                case Ku:
-                case Ia:
-                    v = f.bounds.height() + c;
-                    break;
-                case er:
-                    y = f.bounds.width() + c;
-                    break;
-                case nr:
-                    y = -f.bounds.width() - c;
+    function wL(e, t, n, i, r, s) {
+        for (var a = [], o = t.children, l, u, c = 0, f = 0, h = o.length, d, g, p = t.value, m, y, v, b, x, _, S; c < h;) {
+            d = r - n, g = s - i;
+            do m = o[f++].value; while (!m && f < h);
+            for (y = v = m, _ = Math.max(g / d, d / g) / (p * e), S = m * m * _, x = Math.max(v / S, S / y); f < h; ++f) {
+                if (m += u = o[f].value, u < y && (y = u), u > v && (v = u), S = m * m * _, b = Math.max(v / S, S / y), b > x) {
+                    m -= u;
                     break
-            }
-            ln.clear().union(h.bounds), ln.translate(y - (h.x || 0), v - (h.y || 0)), gu(h, "x", y) | gu(h, "y", v) && (e.dirty(h), h.bounds.clear().union(ln), h.mark.bounds.clear().union(ln), e.dirty(h)), ln.clear().union(h.bounds)
-        } else ln.clear();
-        switch (ln.union(f.bounds), o) {
-            case Ku:
-                p = b, m = r.y1 - ln.height() - u;
-                break;
-            case er:
-                p = r.x1 - ln.width() - u, m = b;
-                break;
-            case nr:
-                p = r.x2 + ln.width() + u, m = b;
-                break;
-            case Ia:
-                p = b, m = r.y2 + u;
-                break;
-            default:
-                p = s.x, m = s.y
-        }
-        return gu(s, "x", p) | gu(s, "y", m) && (ln.translate(p, m), e.dirty(s), s.bounds.clear().union(ln), t.bounds.clear().union(ln), e.dirty(s)), s.bounds
-    }
-
-    function m4(e) {
-        L.call(this, null, e)
-    }
-    ee(m4, L, {
-        transform(e, t) {
-            const n = t.dataflow;
-            return e.mark.items.forEach(i => {
-                e.layout && HZ(n, i, e.layout), ree(n, i, e)
-            }), iee(e.mark.group) ? t.reflow() : t
-        }
-    });
-
-    function iee(e) {
-        return e && e.mark.role !== "legend-entry"
-    }
-
-    function ree(e, t, n) {
-        var i = t.items,
-            r = Math.max(0, t.width || 0),
-            s = Math.max(0, t.height || 0),
-            a = new kt().set(0, 0, r, s),
-            o = a.clone(),
-            l = a.clone(),
-            u = [],
-            c, f, h, d, g, p;
-        for (g = 0, p = i.length; g < p; ++g) switch (f = i[g], f.role) {
-            case iS:
-                d = BZ(f) ? o : l, d.union(UZ(e, f, r, s));
-                break;
-            case rS:
-                c = f;
-                break;
-            case sS:
-                u.push(QZ(e, f));
-                break;
-            case OZ:
-            case FZ:
-            case t4:
-            case n4:
-            case i4:
-            case r4:
-            case s4:
-            case a4:
-                o.union(f.bounds), l.union(f.bounds);
-                break;
-            default:
-                a.union(f.bounds)
-        }
-        if (u.length) {
-            const m = {};
-            u.forEach(y => {
-                h = y.orient || nr, h !== aS && (m[h] || (m[h] = [])).push(y)
-            });
-            for (const y in m) {
-                const v = m[y];
-                p4(e, v, JZ(v, y, n.legends, o, l, r, s))
-            }
-            u.forEach(y => {
-                const v = y.bounds;
-                if (v.equals(y._bounds) || (y.bounds = y._bounds, e.dirty(y), y.bounds = v, e.dirty(y)), n.autosize && (n.autosize.type === o4 || n.autosize.type === l4 || n.autosize.type === u4)) switch (y.orient) {
-                    case er:
-                    case nr:
-                        a.add(v.x1, 0).add(v.x2, 0);
-                        break;
-                    case Ku:
-                    case Ia:
-                        a.add(0, v.y1).add(0, v.y2)
-                } else a.union(v)
-            })
-        }
-        a.union(o).union(l), c && a.union(nee(e, c, r, s, a)), t.clip && a.set(0, 0, t.width || 0, t.height || 0), see(e, t, a, n)
-    }
-
-    function see(e, t, n, i) {
-        const r = i.autosize || {},
-            s = r.type;
-        if (e._autosize < 1 || !s) return;
-        let a = e._width,
-            o = e._height,
-            l = Math.max(0, t.width || 0),
-            u = Math.max(0, Math.ceil(-n.x1)),
-            c = Math.max(0, t.height || 0),
-            f = Math.max(0, Math.ceil(-n.y1));
-        const h = Math.max(0, Math.ceil(n.x2 - l)),
-            d = Math.max(0, Math.ceil(n.y2 - c));
-        if (r.contains === RZ) {
-            const g = e.padding();
-            a -= g.left + g.right, o -= g.top + g.bottom
-        }
-        s === aS ? (u = 0, f = 0, l = a, c = o) : s === o4 ? (l = Math.max(0, a - u - h), c = Math.max(0, o - f - d)) : s === l4 ? (l = Math.max(0, a - u - h), o = c + f + d) : s === u4 ? (a = l + u + h, c = Math.max(0, o - f - d)) : s === NZ && (a = l + u + h, o = c + f + d), e._resizeView(a, o, l, c, [u, f], r.resize)
-    }
-    const aee = Object.freeze(Object.defineProperty({
-        __proto__: null,
-        bound: c4,
-        identifier: lS,
-        mark: f4,
-        overlap: h4,
-        render: g4,
-        viewlayout: m4
-    }, Symbol.toStringTag, {
-        value: "Module"
-    }));
-
-    function y4(e) {
-        L.call(this, null, e)
-    }
-    ee(y4, L, {
-        transform(e, t) {
-            if (this.value && !e.modified()) return t.StopPropagation;
-            var n = t.dataflow.locale(),
-                i = t.fork(t.NO_SOURCE | t.NO_FIELDS),
-                r = this.value,
-                s = e.scale,
-                a = e.count == null ? e.values ? e.values.length : 10 : e.count,
-                o = Sw(s, a, e.minstep),
-                l = e.format || JN(n, s, o, e.formatSpecifier, e.formatType, !!e.values),
-                u = e.values ? KN(s, e.values, o) : Ew(s, o);
-            return r && (i.rem = r), r = u.map((c, f) => He({
-                index: f / (u.length - 1 || 1),
-                value: c,
-                label: l(c)
-            })), e.extra && r.length && r.push(He({
-                index: -1,
-                extra: {
-                    value: r[0].value
-                },
-                label: ""
-            })), i.source = r, i.add = r, this.value = r, i
-        }
-    });
-
-    function v4(e) {
-        L.call(this, null, e)
-    }
-
-    function oee() {
-        return He({})
-    }
-
-    function lee(e) {
-        const t = _c().test(n => n.exit);
-        return t.lookup = n => t.get(e(n)), t
-    }
-    ee(v4, L, {
-        transform(e, t) {
-            var n = t.dataflow,
-                i = t.fork(t.NO_SOURCE | t.NO_FIELDS),
-                r = e.item || oee,
-                s = e.key || ge,
-                a = this.value;
-            return W(i.encode) && (i.encode = null), a && (e.modified("key") || t.modified(s)) && U("DataJoin does not support modified key function or fields."), a || (t = t.addAll(), this.value = a = lee(s)), t.visit(t.ADD, o => {
-                const l = s(o);
-                let u = a.get(l);
-                u ? u.exit ? (a.empty--, i.add.push(u)) : i.mod.push(u) : (u = r(o), a.set(l, u), i.add.push(u)), u.datum = o, u.exit = !1
-            }), t.visit(t.MOD, o => {
-                const l = s(o),
-                    u = a.get(l);
-                u && (u.datum = o, i.mod.push(u))
-            }), t.visit(t.REM, o => {
-                const l = s(o),
-                    u = a.get(l);
-                o === u.datum && !u.exit && (i.rem.push(u), u.exit = !0, ++a.empty)
-            }), t.changed(t.ADD_MOD) && i.modifies("datum"), (t.clean() || e.clean && a.empty > n.cleanThreshold) && n.runAfter(a.clean), i
-        }
-    });
-
-    function b4(e) {
-        L.call(this, null, e)
-    }
-    ee(b4, L, {
-        transform(e, t) {
-            var n = t.fork(t.ADD_REM),
-                i = e.mod || !1,
-                r = e.encoders,
-                s = t.encode;
-            if (W(s))
-                if (n.changed() || s.every(f => r[f])) s = s[0], n.encode = null;
-                else return t.StopPropagation;
-            var a = s === "enter",
-                o = r.update || ia,
-                l = r.enter || ia,
-                u = r.exit || ia,
-                c = (s && !a ? r[s] : o) || ia;
-            if (t.changed(t.ADD) && (t.visit(t.ADD, f => {
-                    l(f, e), o(f, e)
-                }), n.modifies(l.output), n.modifies(o.output), c !== ia && c !== o && (t.visit(t.ADD, f => {
-                    c(f, e)
-                }), n.modifies(c.output))), t.changed(t.REM) && u !== ia && (t.visit(t.REM, f => {
-                    u(f, e)
-                }), n.modifies(u.output)), a || c !== ia) {
-                const f = t.MOD | (e.modified() ? t.REFLOW : 0);
-                a ? (t.visit(f, h => {
-                    const d = l(h, e) || i;
-                    (c(h, e) || d) && n.mod.push(h)
-                }), n.mod.length && n.modifies(l.output)) : t.visit(f, h => {
-                    (c(h, e) || i) && n.mod.push(h)
-                }), n.mod.length && n.modifies(c.output)
-            }
-            return n.changed() ? n : t.StopPropagation
-        }
-    });
-
-    function x4(e) {
-        L.call(this, [], e)
-    }
-    ee(x4, L, {
-        transform(e, t) {
-            if (this.value != null && !e.modified()) return t.StopPropagation;
-            var n = t.dataflow.locale(),
-                i = t.fork(t.NO_SOURCE | t.NO_FIELDS),
-                r = this.value,
-                s = e.type || Qg,
-                a = e.scale,
-                o = +e.limit,
-                l = Sw(a, e.count == null ? 5 : e.count, e.minstep),
-                u = !!e.values || s === Qg,
-                c = e.format || tP(n, a, l, s, e.formatSpecifier, e.formatType, u),
-                f = e.values || eP(a, l),
-                h, d, g, p, m;
-            return r && (i.rem = r), s === Qg ? (o && f.length > o ? (t.dataflow.warn("Symbol legend count exceeds limit, filtering items."), r = f.slice(0, o - 1), m = !0) : r = f, $e(g = e.size) ? (!e.values && a(r[0]) === 0 && (r = r.slice(1)), p = r.reduce((y, v) => Math.max(y, g(v, e)), 0)) : g = xn(p = g || 8), r = r.map((y, v) => He({
-                index: v,
-                label: c(y, v, r),
-                value: y,
-                offset: p,
-                size: g(y, e)
-            })), m && (m = f[r.length], r.push(He({
-                index: r.length,
-                label: `…${f.length-r.length} entries`,
-                value: m,
-                offset: p,
-                size: g(m, e)
-            })))) : s === PK ? (h = a.domain(), d = YN(a, h[0], De(h)), f.length < 3 && !e.values && h[0] !== De(h) && (f = [h[0], De(h)]), r = f.map((y, v) => He({
-                index: v,
-                label: c(y, v, f),
-                value: y,
-                perc: d(y)
-            }))) : (g = f.length - 1, d = YK(a), r = f.map((y, v) => He({
-                index: v,
-                label: c(y, v, f),
-                value: y,
-                perc: v ? d(y) : 0,
-                perc2: v === g ? 1 : d(f[v + 1])
-            }))), i.source = r, i.add = r, this.value = r, i
-        }
-    });
-    const uee = e => e.source.x,
-        cee = e => e.source.y,
-        fee = e => e.target.x,
-        hee = e => e.target.y;
-
-    function uS(e) {
-        L.call(this, {}, e)
-    }
-    uS.Definition = {
-        type: "LinkPath",
-        metadata: {
-            modifies: !0
-        },
-        params: [{
-            name: "sourceX",
-            type: "field",
-            default: "source.x"
-        }, {
-            name: "sourceY",
-            type: "field",
-            default: "source.y"
-        }, {
-            name: "targetX",
-            type: "field",
-            default: "target.x"
-        }, {
-            name: "targetY",
-            type: "field",
-            default: "target.y"
-        }, {
-            name: "orient",
-            type: "enum",
-            default: "vertical",
-            values: ["horizontal", "vertical", "radial"]
-        }, {
-            name: "shape",
-            type: "enum",
-            default: "line",
-            values: ["line", "arc", "curve", "diagonal", "orthogonal"]
-        }, {
-            name: "require",
-            type: "signal"
-        }, {
-            name: "as",
-            type: "string",
-            default: "path"
-        }]
-    };
-    ee(uS, L, {
-        transform(e, t) {
-            var n = e.sourceX || uee,
-                i = e.sourceY || cee,
-                r = e.targetX || fee,
-                s = e.targetY || hee,
-                a = e.as || "path",
-                o = e.orient || "vertical",
-                l = e.shape || "line",
-                u = bT.get(l + "-" + o) || bT.get(l);
-            return u || U("LinkPath unsupported type: " + e.shape + (e.orient ? "-" + e.orient : "")), t.visit(t.SOURCE, c => {
-                c[a] = u(n(c), i(c), r(c), s(c))
-            }), t.reflow(e.modified()).modifies(a)
-        }
-    });
-    const _4 = (e, t, n, i) => "M" + e + "," + t + "L" + n + "," + i,
-        dee = (e, t, n, i) => _4(t * Math.cos(e), t * Math.sin(e), i * Math.cos(n), i * Math.sin(n)),
-        w4 = (e, t, n, i) => {
-            var r = n - e,
-                s = i - t,
-                a = Math.hypot(r, s) / 2,
-                o = 180 * Math.atan2(s, r) / Math.PI;
-            return "M" + e + "," + t + "A" + a + "," + a + " " + o + " 0 1 " + n + "," + i
-        },
-        gee = (e, t, n, i) => w4(t * Math.cos(e), t * Math.sin(e), i * Math.cos(n), i * Math.sin(n)),
-        S4 = (e, t, n, i) => {
-            const r = n - e,
-                s = i - t,
-                a = .2 * (r + s),
-                o = .2 * (s - r);
-            return "M" + e + "," + t + "C" + (e + a) + "," + (t + o) + " " + (n + o) + "," + (i - a) + " " + n + "," + i
-        },
-        pee = (e, t, n, i) => S4(t * Math.cos(e), t * Math.sin(e), i * Math.cos(n), i * Math.sin(n)),
-        mee = (e, t, n, i) => "M" + e + "," + t + "V" + i + "H" + n,
-        yee = (e, t, n, i) => "M" + e + "," + t + "H" + n + "V" + i,
-        vee = (e, t, n, i) => {
-            const r = Math.cos(e),
-                s = Math.sin(e),
-                a = Math.cos(n),
-                o = Math.sin(n),
-                l = Math.abs(n - e) > Math.PI ? n <= e : n > e;
-            return "M" + t * r + "," + t * s + "A" + t + "," + t + " 0 0," + (l ? 1 : 0) + " " + t * a + "," + t * o + "L" + i * a + "," + i * o
-        },
-        bee = (e, t, n, i) => {
-            const r = (e + n) / 2;
-            return "M" + e + "," + t + "C" + r + "," + t + " " + r + "," + i + " " + n + "," + i
-        },
-        xee = (e, t, n, i) => {
-            const r = (t + i) / 2;
-            return "M" + e + "," + t + "C" + e + "," + r + " " + n + "," + r + " " + n + "," + i
-        },
-        _ee = (e, t, n, i) => {
-            const r = Math.cos(e),
-                s = Math.sin(e),
-                a = Math.cos(n),
-                o = Math.sin(n),
-                l = (t + i) / 2;
-            return "M" + t * r + "," + t * s + "C" + l * r + "," + l * s + " " + l * a + "," + l * o + " " + i * a + "," + i * o
-        },
-        bT = _c({
-            line: _4,
-            "line-radial": dee,
-            arc: w4,
-            "arc-radial": gee,
-            curve: S4,
-            "curve-radial": pee,
-            "orthogonal-horizontal": mee,
-            "orthogonal-vertical": yee,
-            "orthogonal-radial": vee,
-            "diagonal-horizontal": bee,
-            "diagonal-vertical": xee,
-            "diagonal-radial": _ee
-        });
-
-    function cS(e) {
-        L.call(this, null, e)
-    }
-    cS.Definition = {
-        type: "Pie",
-        metadata: {
-            modifies: !0
-        },
-        params: [{
-            name: "field",
-            type: "field"
-        }, {
-            name: "startAngle",
-            type: "number",
-            default: 0
-        }, {
-            name: "endAngle",
-            type: "number",
-            default: 6.283185307179586
-        }, {
-            name: "sort",
-            type: "boolean",
-            default: !1
-        }, {
-            name: "as",
-            type: "string",
-            array: !0,
-            length: 2,
-            default: ["startAngle", "endAngle"]
-        }]
-    };
-    ee(cS, L, {
-        transform(e, t) {
-            var n = e.as || ["startAngle", "endAngle"],
-                i = n[0],
-                r = n[1],
-                s = e.field || vc,
-                a = e.startAngle || 0,
-                o = e.endAngle != null ? e.endAngle : 2 * Math.PI,
-                l = t.source,
-                u = l.map(s),
-                c = u.length,
-                f = a,
-                h = (o - a) / jO(u),
-                d = gi(c),
-                g, p, m;
-            for (e.sort && d.sort((y, v) => u[y] - u[v]), g = 0; g < c; ++g) m = u[d[g]], p = l[d[g]], p[i] = f, p[r] = f += m * h;
-            return this.value = u, t.reflow(e.modified()).modifies(n)
-        }
-    });
-    const wee = 5;
-
-    function See(e) {
-        const t = e.type;
-        return !e.bins && (t === Gu || t === cd || t === fd)
-    }
-
-    function E4(e) {
-        return xw(e) && e !== zr
-    }
-    const Eee = fr(["set", "modified", "clear", "type", "scheme", "schemeExtent", "schemeCount", "domain", "domainMin", "domainMid", "domainMax", "domainRaw", "domainImplicit", "nice", "zero", "bins", "range", "rangeStep", "round", "reverse", "interpolate", "interpolateGamma"]);
-
-    function C4(e) {
-        L.call(this, null, e), this.modified(!0)
-    }
-    ee(C4, L, {
-        transform(e, t) {
-            var n = t.dataflow,
-                i = this.value,
-                r = Cee(e);
-            (!i || r !== i.type) && (this.value = i = We(r)());
-            for (r in e)
-                if (!Eee[r]) {
-                    if (r === "padding" && E4(i.type)) continue;
-                    $e(i[r]) ? i[r](e[r]) : n.warn("Unsupported scale property: " + r)
-                } return Oee(i, e, Mee(i, e, Aee(i, e, n))), t.fork(t.NO_SOURCE | t.NO_FIELDS)
-        }
-    });
-
-    function Cee(e) {
-        var t = e.type,
-            n = "",
-            i;
-        return t === zr ? zr + "-" + Gu : (kee(e) && (i = e.rawDomain ? e.rawDomain.length : e.domain ? e.domain.length + +(e.domainMid != null) : 0, n = i === 2 ? zr + "-" : i === 3 ? Cc + "-" : ""), (n + t || Gu).toLowerCase())
-    }
-
-    function kee(e) {
-        const t = e.type;
-        return xw(t) && t !== tl && t !== nl && (e.scheme || e.range && e.range.length && e.range.every(re))
-    }
-
-    function Aee(e, t, n) {
-        const i = $ee(e, t.domainRaw, n);
-        if (i > -1) return i;
-        var r = t.domain,
-            s = e.type,
-            a = t.zero || t.zero === void 0 && See(e),
-            o, l;
-        if (!r) return 0;
-        if (E4(s) && t.padding && r[0] !== De(r) && (r = Tee(s, r, t.range, t.padding, t.exponent, t.constant)), (a || t.domainMin != null || t.domainMax != null || t.domainMid != null) && (o = (r = r.slice()).length - 1 || 1, a && (r[0] > 0 && (r[0] = 0), r[o] < 0 && (r[o] = 0)), t.domainMin != null && (r[0] = t.domainMin), t.domainMax != null && (r[o] = t.domainMax), t.domainMid != null)) {
-            l = t.domainMid;
-            const u = l > r[o] ? o + 1 : l < r[0] ? 0 : o;
-            u !== o && n.warn("Scale domainMid exceeds domain min or max.", l), r.splice(u, 0, l)
-        }
-        return e.domain(k4(s, r, n)), s === mw && e.unknown(t.domainImplicit ? Lb : void 0), t.nice && e.nice && e.nice(t.nice !== !0 && Sw(e, t.nice) || null), r.length
-    }
-
-    function $ee(e, t, n) {
-        return t ? (e.domain(k4(e.type, t, n)), t.length) : -1
-    }
-
-    function Tee(e, t, n, i, r, s) {
-        var a = Math.abs(De(n) - n[0]),
-            o = a / (a - 2 * i),
-            l = e === zs ? u_(t, null, o) : e === fd ? c0(t, null, o, .5) : e === cd ? c0(t, null, o, r || 1) : e === Um ? c_(t, null, o, s || 1) : l_(t, null, o);
-        return t = t.slice(), t[0] = l[0], t[t.length - 1] = l[1], t
-    }
-
-    function k4(e, t, n) {
-        if (UN(e)) {
-            var i = Math.abs(t.reduce((r, s) => r + (s < 0 ? -1 : s > 0 ? 1 : 0), 0));
-            i !== t.length && n.warn("Log scale domain includes zero: " + Z(t))
-        }
-        return t
-    }
-
-    function Mee(e, t, n) {
-        let i = t.bins;
-        if (i && !W(i)) {
-            const r = e.domain(),
-                s = r[0],
-                a = De(r),
-                o = i.step;
-            let l = i.start == null ? s : i.start,
-                u = i.stop == null ? a : i.stop;
-            o || U("Scale bins parameter missing step property."), l < s && (l = o * Math.ceil(s / o)), u > a && (u = o * Math.floor(a / o)), i = gi(l, u + o / 2, o)
-        }
-        return i ? e.bins = i : e.bins && delete e.bins, e.type === yw && (i ? !t.domain && !t.domainRaw && (e.domain(i), n = i.length) : e.bins = e.domain()), n
-    }
-
-    function Oee(e, t, n) {
-        var i = e.type,
-            r = t.round || !1,
-            s = t.range;
-        if (t.rangeStep != null) s = Fee(i, t, n);
-        else if (t.scheme && (s = Ree(i, t, n), $e(s))) {
-            if (e.interpolator) return e.interpolator(s);
-            U(`Scale type ${i} does not support interpolating color schemes.`)
-        }
-        if (s && GN(i)) return e.interpolator(qm(m2(s, t.reverse), t.interpolate, t.interpolateGamma));
-        s && t.interpolate && e.interpolate ? e.interpolate(_w(t.interpolate, t.interpolateGamma)) : $e(e.round) ? e.round(r) : $e(e.rangeRound) && e.interpolate(r ? Jh : Ka), s && e.range(m2(s, t.reverse))
-    }
-
-    function Fee(e, t, n) {
-        e !== PN && e !== t2 && U("Only band and point scales support rangeStep.");
-        var i = (t.paddingOuter != null ? t.paddingOuter : t.padding) || 0,
-            r = e === t2 ? 1 : (t.paddingInner != null ? t.paddingInner : t.padding) || 0;
-        return [0, t.rangeStep * pw(n, r, i)]
-    }
-
-    function Ree(e, t, n) {
-        var i = t.schemeExtent,
-            r, s;
-        return W(t.scheme) ? s = qm(t.scheme, t.interpolate, t.interpolateGamma) : (r = t.scheme.toLowerCase(), s = ww(r), s || U(`Unrecognized scheme name: ${t.scheme}`)), n = e === Wm ? n + 1 : e === yw ? n - 1 : e === Wu || e === Gm ? +t.schemeCount || wee : n, GN(e) ? xT(s, i, t.reverse) : $e(s) ? HN(xT(s, i), n) : e === mw ? s : s.slice(0, n)
-    }
-
-    function xT(e, t, n) {
-        return $e(e) && (t || n) ? qN(e, m2(t || [0, 1], n)) : e
-    }
-
-    function m2(e, t) {
-        return t ? e.slice().reverse() : e
-    }
-
-    function A4(e) {
-        L.call(this, null, e)
-    }
-    ee(A4, L, {
-        transform(e, t) {
-            const n = e.modified("sort") || t.changed(t.ADD) || t.modified(e.sort.fields) || t.modified("datum");
-            return n && t.source.sort($l(e.sort)), this.modified(n), t
-        }
-    });
-    const _T = "zero",
-        $4 = "center",
-        T4 = "normalize",
-        M4 = ["y0", "y1"];
-
-    function fS(e) {
-        L.call(this, null, e)
-    }
-    fS.Definition = {
-        type: "Stack",
-        metadata: {
-            modifies: !0
-        },
-        params: [{
-            name: "field",
-            type: "field"
-        }, {
-            name: "groupby",
-            type: "field",
-            array: !0
-        }, {
-            name: "sort",
-            type: "compare"
-        }, {
-            name: "offset",
-            type: "enum",
-            default: _T,
-            values: [_T, $4, T4]
-        }, {
-            name: "as",
-            type: "string",
-            array: !0,
-            length: 2,
-            default: M4
-        }]
-    };
-    ee(fS, L, {
-        transform(e, t) {
-            var n = e.as || M4,
-                i = n[0],
-                r = n[1],
-                s = $l(e.sort),
-                a = e.field || vc,
-                o = e.offset === $4 ? Dee : e.offset === T4 ? Nee : Pee,
-                l, u, c, f;
-            for (l = Lee(t.source, e.groupby, s, a), u = 0, c = l.length, f = l.max; u < c; ++u) o(l[u], f, a, i, r);
-            return t.reflow(e.modified()).modifies(n)
-        }
-    });
-
-    function Dee(e, t, n, i, r) {
-        for (var s = (t - e.sum) / 2, a = e.length, o = 0, l; o < a; ++o) l = e[o], l[i] = s, l[r] = s += Math.abs(n(l))
-    }
-
-    function Nee(e, t, n, i, r) {
-        for (var s = 1 / e.sum, a = 0, o = e.length, l = 0, u = 0, c; l < o; ++l) c = e[l], c[i] = a, c[r] = a = s * (u += Math.abs(n(c)))
-    }
-
-    function Pee(e, t, n, i, r) {
-        for (var s = 0, a = 0, o = e.length, l = 0, u, c; l < o; ++l) c = e[l], u = +n(c), u < 0 ? (c[i] = a, c[r] = a += u) : (c[i] = s, c[r] = s += u)
-    }
-
-    function Lee(e, t, n, i) {
-        var r = [],
-            s = p => p(c),
-            a, o, l, u, c, f, h, d, g;
-        if (t == null) r.push(e.slice());
-        else
-            for (a = {}, o = 0, l = e.length; o < l; ++o) c = e[o], f = t.map(s), h = a[f], h || (a[f] = h = [], r.push(h)), h.push(c);
-        for (f = 0, g = 0, u = r.length; f < u; ++f) {
-            for (h = r[f], o = 0, d = 0, l = h.length; o < l; ++o) d += Math.abs(i(h[o]));
-            h.sum = d, d > g && (g = d), n && h.sort(n)
-        }
-        return r.max = g, r
-    }
-    const Iee = Object.freeze(Object.defineProperty({
-        __proto__: null,
-        axisticks: y4,
-        datajoin: v4,
-        encode: b4,
-        legendentries: x4,
-        linkpath: uS,
-        pie: cS,
-        scale: C4,
-        sortitems: A4,
-        stack: fS
-    }, Symbol.toStringTag, {
-        value: "Module"
-    }));
-    var zee = Math.abs,
-        y2 = Math.cos,
-        C0 = Math.sin,
-        Bee = 1e-6,
-        O4 = Math.PI,
-        v2 = O4 / 2,
-        wT = jee(2);
-
-    function ST(e) {
-        return e > 1 ? v2 : e < -1 ? -v2 : Math.asin(e)
-    }
-
-    function jee(e) {
-        return e > 0 ? Math.sqrt(e) : 0
-    }
-
-    function Uee(e, t) {
-        var n = e * C0(t),
-            i = 30,
-            r;
-        do t -= r = (t + C0(t) - n) / (1 + y2(t)); while (zee(r) > Bee && --i > 0);
-        return t / 2
-    }
-
-    function Gee(e, t, n) {
-        function i(r, s) {
-            return [e * r * y2(s = Uee(n, s)), t * C0(s)]
-        }
-        return i.invert = function(r, s) {
-            return s = ST(s / t), [r / (e * y2(s)), ST((2 * s + C0(2 * s)) / n)]
-        }, i
-    }
-    var Wee = Gee(wT / v2, wT, O4);
-
-    function qee() {
-        return es(Wee).scale(169.529)
-    }
-    const Hee = $F(),
-        b2 = ["clipAngle", "clipExtent", "scale", "translate", "center", "rotate", "parallels", "precision", "reflectX", "reflectY", "coefficient", "distance", "fraction", "lobes", "parallel", "radius", "ratio", "spacing", "tilt"];
-
-    function Yee(e, t) {
-        return function n() {
-            const i = t();
-            return i.type = e, i.path = $F().projection(i), i.copy = i.copy || function() {
-                const r = n();
-                return b2.forEach(s => {
-                    i[s] && r[s](i[s]())
-                }), r.path.pointRadius(i.path.pointRadius()), r
-            }, BN(i)
-        }
-    }
-
-    function hS(e, t) {
-        if (!e || typeof e != "string") throw new Error("Projection type must be a name string.");
-        return e = e.toLowerCase(), arguments.length > 1 ? (k0[e] = Yee(e, t), this) : k0[e] || null
-    }
-
-    function F4(e) {
-        return e && e.path || Hee
-    }
-    const k0 = {
-        albers: MF,
-        albersusa: UG,
-        azimuthalequalarea: GG,
-        azimuthalequidistant: WG,
-        conicconformal: YG,
-        conicequalarea: Qp,
-        conicequidistant: KG,
-        equalEarth: QG,
-        equirectangular: XG,
-        gnomonic: ZG,
-        identity: eW,
-        mercator: qG,
-        mollweide: qee,
-        naturalEarth1: tW,
-        orthographic: nW,
-        stereographic: iW,
-        transversemercator: rW
-    };
-    for (const e in k0) hS(e, k0[e]);
-
-    function Xee() {}
-    const ds = [
-        [],
-        [
-            [
-                [1, 1.5],
-                [.5, 1]
-            ]
-        ],
-        [
-            [
-                [1.5, 1],
-                [1, 1.5]
-            ]
-        ],
-        [
-            [
-                [1.5, 1],
-                [.5, 1]
-            ]
-        ],
-        [
-            [
-                [1, .5],
-                [1.5, 1]
-            ]
-        ],
-        [
-            [
-                [1, 1.5],
-                [.5, 1]
-            ],
-            [
-                [1, .5],
-                [1.5, 1]
-            ]
-        ],
-        [
-            [
-                [1, .5],
-                [1, 1.5]
-            ]
-        ],
-        [
-            [
-                [1, .5],
-                [.5, 1]
-            ]
-        ],
-        [
-            [
-                [.5, 1],
-                [1, .5]
-            ]
-        ],
-        [
-            [
-                [1, 1.5],
-                [1, .5]
-            ]
-        ],
-        [
-            [
-                [.5, 1],
-                [1, .5]
-            ],
-            [
-                [1.5, 1],
-                [1, 1.5]
-            ]
-        ],
-        [
-            [
-                [1.5, 1],
-                [1, .5]
-            ]
-        ],
-        [
-            [
-                [.5, 1],
-                [1.5, 1]
-            ]
-        ],
-        [
-            [
-                [1, 1.5],
-                [1.5, 1]
-            ]
-        ],
-        [
-            [
-                [.5, 1],
-                [1, 1.5]
-            ]
-        ],
-        []
-    ];
-
-    function R4() {
-        var e = 1,
-            t = 1,
-            n = o;
-
-        function i(l, u) {
-            return u.map(c => r(l, c))
-        }
-
-        function r(l, u) {
-            var c = [],
-                f = [];
-            return s(l, u, h => {
-                n(h, l, u), Vee(h) > 0 ? c.push([h]) : f.push(h)
-            }), f.forEach(h => {
-                for (var d = 0, g = c.length, p; d < g; ++d)
-                    if (Kee((p = c[d])[0], h) !== -1) {
-                        p.push(h);
-                        return
-                    }
-            }), {
-                type: "MultiPolygon",
-                value: u,
-                coordinates: c
-            }
-        }
-
-        function s(l, u, c) {
-            var f = new Array,
-                h = new Array,
-                d, g, p, m, y, v;
-            for (d = g = -1, m = l[0] >= u, ds[m << 1].forEach(b); ++d < e - 1;) p = m, m = l[d + 1] >= u, ds[p | m << 1].forEach(b);
-            for (ds[m << 0].forEach(b); ++g < t - 1;) {
-                for (d = -1, m = l[g * e + e] >= u, y = l[g * e] >= u, ds[m << 1 | y << 2].forEach(b); ++d < e - 1;) p = m, m = l[g * e + e + d + 1] >= u, v = y, y = l[g * e + d + 1] >= u, ds[p | m << 1 | y << 2 | v << 3].forEach(b);
-                ds[m | y << 3].forEach(b)
-            }
-            for (d = -1, y = l[g * e] >= u, ds[y << 2].forEach(b); ++d < e - 1;) v = y, y = l[g * e + d + 1] >= u, ds[y << 2 | v << 3].forEach(b);
-            ds[y << 3].forEach(b);
-
-            function b(x) {
-                var _ = [x[0][0] + d, x[0][1] + g],
-                    S = [x[1][0] + d, x[1][1] + g],
-                    w = a(_),
-                    E = a(S),
-                    A, C;
-                (A = h[w]) ? (C = f[E]) ? (delete h[A.end], delete f[C.start], A === C ? (A.ring.push(S), c(A.ring)) : f[A.start] = h[C.end] = {
-                    start: A.start,
-                    end: C.end,
-                    ring: A.ring.concat(C.ring)
-                }) : (delete h[A.end], A.ring.push(S), h[A.end = E] = A) : (A = f[E]) ? (C = h[w]) ? (delete f[A.start], delete h[C.end], A === C ? (A.ring.push(S), c(A.ring)) : f[C.start] = h[A.end] = {
-                    start: C.start,
-                    end: A.end,
-                    ring: C.ring.concat(A.ring)
-                }) : (delete f[A.start], A.ring.unshift(_), f[A.start = w] = A) : f[w] = h[E] = {
-                    start: w,
-                    end: E,
-                    ring: [_, S]
                 }
+                x = b
             }
+            a.push(l = {
+                value: m,
+                dice: d < g,
+                children: o.slice(c, f)
+            }), l.dice ? Vd(l, n, i, r, p ? i += g * m / p : s) : N1(l, n, i, p ? n += d * m / p : r, s), p -= m, c = f
         }
-
-        function a(l) {
-            return l[0] * 2 + l[1] * (e + 1) * 4
-        }
-
-        function o(l, u, c) {
-            l.forEach(f => {
-                var h = f[0],
-                    d = f[1],
-                    g = h | 0,
-                    p = d | 0,
-                    m, y = u[p * e + g];
-                h > 0 && h < e && g === h && (m = u[p * e + g - 1], f[0] = h + (c - m) / (y - m) - .5), d > 0 && d < t && p === d && (m = u[(p - 1) * e + g], f[1] = d + (c - m) / (y - m) - .5)
-            })
-        }
-        return i.contour = r, i.size = function(l) {
-            if (!arguments.length) return [e, t];
-            var u = Math.floor(l[0]),
-                c = Math.floor(l[1]);
-            return u >= 0 && c >= 0 || U("invalid size"), e = u, t = c, i
-        }, i.smooth = function(l) {
-            return arguments.length ? (n = l ? o : Xee, i) : n === o
-        }, i
-    }
-
-    function Vee(e) {
-        for (var t = 0, n = e.length, i = e[n - 1][1] * e[0][0] - e[n - 1][0] * e[0][1]; ++t < n;) i += e[t - 1][1] * e[t][0] - e[t - 1][0] * e[t][1];
-        return i
-    }
-
-    function Kee(e, t) {
-        for (var n = -1, i = t.length, r; ++n < i;)
-            if (r = Jee(e, t[n])) return r;
-        return 0
-    }
-
-    function Jee(e, t) {
-        for (var n = t[0], i = t[1], r = -1, s = 0, a = e.length, o = a - 1; s < a; o = s++) {
-            var l = e[s],
-                u = l[0],
-                c = l[1],
-                f = e[o],
-                h = f[0],
-                d = f[1];
-            if (Qee(l, f, t)) return 0;
-            c > i != d > i && n < (h - u) * (i - c) / (d - c) + u && (r = -r)
-        }
-        return r
-    }
-
-    function Qee(e, t, n) {
-        var i;
-        return Zee(e, t, n) && ete(e[i = +(e[0] === t[0])], n[i], t[i])
-    }
-
-    function Zee(e, t, n) {
-        return (t[0] - e[0]) * (n[1] - e[1]) === (n[0] - e[0]) * (t[1] - e[1])
-    }
-
-    function ete(e, t, n) {
-        return e <= t && t <= n || n <= t && t <= e
-    }
-
-    function D4(e, t, n) {
-        return function(i) {
-            var r = Hr(i),
-                s = n ? Math.min(r[0], 0) : r[0],
-                a = r[1],
-                o = a - s,
-                l = t ? Oa(s, a, e) : o / (e + 1);
-            return gi(s + l, a, l)
-        }
-    }
-
-    function dS(e) {
-        L.call(this, null, e)
-    }
-    dS.Definition = {
-        type: "Isocontour",
-        metadata: {
-            generates: !0
-        },
-        params: [{
-            name: "field",
-            type: "field"
-        }, {
-            name: "thresholds",
-            type: "number",
-            array: !0
-        }, {
-            name: "levels",
-            type: "number"
-        }, {
-            name: "nice",
-            type: "boolean",
-            default: !1
-        }, {
-            name: "resolve",
-            type: "enum",
-            values: ["shared", "independent"],
-            default: "independent"
-        }, {
-            name: "zero",
-            type: "boolean",
-            default: !0
-        }, {
-            name: "smooth",
-            type: "boolean",
-            default: !0
-        }, {
-            name: "scale",
-            type: "number",
-            expr: !0
-        }, {
-            name: "translate",
-            type: "number",
-            array: !0,
-            expr: !0
-        }, {
-            name: "as",
-            type: "string",
-            null: !0,
-            default: "contour"
-        }]
-    };
-    ee(dS, L, {
-        transform(e, t) {
-            if (this.value && !t.changed() && !e.modified()) return t.StopPropagation;
-            var n = t.fork(t.NO_SOURCE | t.NO_FIELDS),
-                i = t.materialize(t.SOURCE).source,
-                r = e.field || bn,
-                s = R4().smooth(e.smooth !== !1),
-                a = e.thresholds || tte(i, r, e),
-                o = e.as === null ? null : e.as || "contour",
-                l = [];
-            return i.forEach(u => {
-                const c = r(u),
-                    f = s.size([c.width, c.height])(c.values, W(a) ? a : a(c.values));
-                nte(f, c, u, e), f.forEach(h => {
-                    l.push(Rm(u, He(o != null ? {
-                        [o]: h
-                    } : h)))
-                })
-            }), this.value && (n.rem = this.value), this.value = n.source = n.add = l, n
-        }
-    });
-
-    function tte(e, t, n) {
-        const i = D4(n.levels || 10, n.nice, n.zero !== !1);
-        return n.resolve !== "shared" ? i : i(e.map(r => jo(t(r).values)))
-    }
-
-    function nte(e, t, n, i) {
-        let r = i.scale || t.scale,
-            s = i.translate || t.translate;
-        if ($e(r) && (r = r(n, i)), $e(s) && (s = s(n, i)), (r === 1 || r == null) && !s) return;
-        const a = (Ze(r) ? r : r[0]) || 1,
-            o = (Ze(r) ? r : r[1]) || 1,
-            l = s && s[0] || 0,
-            u = s && s[1] || 0;
-        e.forEach(N4(t, a, o, l, u))
-    }
-
-    function N4(e, t, n, i, r) {
-        const s = e.x1 || 0,
-            a = e.y1 || 0,
-            o = t * n < 0;
-
-        function l(f) {
-            f.forEach(u)
-        }
-
-        function u(f) {
-            o && f.reverse(), f.forEach(c)
-        }
-
-        function c(f) {
-            f[0] = (f[0] - s) * t + i, f[1] = (f[1] - a) * n + r
-        }
-        return function(f) {
-            return f.coordinates.forEach(l), f
-        }
-    }
-
-    function ET(e, t, n) {
-        const i = e >= 0 ? e : T_(t, n);
-        return Math.round((Math.sqrt(4 * i * i + 1) - 1) / 2)
-    }
-
-    function rv(e) {
-        return $e(e) ? e : xn(+e)
-    }
-
-    function P4() {
-        var e = l => l[0],
-            t = l => l[1],
-            n = vc,
-            i = [-1, -1],
-            r = 960,
-            s = 500,
-            a = 2;
-
-        function o(l, u) {
-            const c = ET(i[0], l, e) >> a,
-                f = ET(i[1], l, t) >> a,
-                h = c ? c + 2 : 0,
-                d = f ? f + 2 : 0,
-                g = 2 * h + (r >> a),
-                p = 2 * d + (s >> a),
-                m = new Float32Array(g * p),
-                y = new Float32Array(g * p);
-            let v = m;
-            l.forEach(x => {
-                const _ = h + (+e(x) >> a),
-                    S = d + (+t(x) >> a);
-                _ >= 0 && _ < g && S >= 0 && S < p && (m[_ + S * g] += +n(x))
-            }), c > 0 && f > 0 ? (Jl(g, p, m, y, c), Ql(g, p, y, m, f), Jl(g, p, m, y, c), Ql(g, p, y, m, f), Jl(g, p, m, y, c), Ql(g, p, y, m, f)) : c > 0 ? (Jl(g, p, m, y, c), Jl(g, p, y, m, c), Jl(g, p, m, y, c), v = y) : f > 0 && (Ql(g, p, m, y, f), Ql(g, p, y, m, f), Ql(g, p, m, y, f), v = y);
-            const b = u ? Math.pow(2, -2 * a) : 1 / jO(v);
-            for (let x = 0, _ = g * p; x < _; ++x) v[x] *= b;
-            return {
-                values: v,
-                scale: 1 << a,
-                width: g,
-                height: p,
-                x1: h,
-                y1: d,
-                x2: h + (r >> a),
-                y2: d + (s >> a)
-            }
-        }
-        return o.x = function(l) {
-            return arguments.length ? (e = rv(l), o) : e
-        }, o.y = function(l) {
-            return arguments.length ? (t = rv(l), o) : t
-        }, o.weight = function(l) {
-            return arguments.length ? (n = rv(l), o) : n
-        }, o.size = function(l) {
-            if (!arguments.length) return [r, s];
-            var u = +l[0],
-                c = +l[1];
-            return u >= 0 && c >= 0 || U("invalid size"), r = u, s = c, o
-        }, o.cellSize = function(l) {
-            return arguments.length ? ((l = +l) >= 1 || U("invalid cell size"), a = Math.floor(Math.log(l) / Math.LN2), o) : 1 << a
-        }, o.bandwidth = function(l) {
-            return arguments.length ? (l = se(l), l.length === 1 && (l = [+l[0], +l[0]]), l.length !== 2 && U("invalid bandwidth"), i = l, o) : i
-        }, o
-    }
-
-    function Jl(e, t, n, i, r) {
-        const s = (r << 1) + 1;
-        for (let a = 0; a < t; ++a)
-            for (let o = 0, l = 0; o < e + r; ++o) o < e && (l += n[o + a * e]), o >= r && (o >= s && (l -= n[o - s + a * e]), i[o - r + a * e] = l / Math.min(o + 1, e - 1 + s - o, s))
-    }
-
-    function Ql(e, t, n, i, r) {
-        const s = (r << 1) + 1;
-        for (let a = 0; a < e; ++a)
-            for (let o = 0, l = 0; o < t + r; ++o) o < t && (l += n[a + o * e]), o >= r && (o >= s && (l -= n[a + (o - s) * e]), i[a + (o - r) * e] = l / Math.min(o + 1, t - 1 + s - o, s))
-    }
-
-    function gS(e) {
-        L.call(this, null, e)
-    }
-    gS.Definition = {
-        type: "KDE2D",
-        metadata: {
-            generates: !0
-        },
-        params: [{
-            name: "size",
-            type: "number",
-            array: !0,
-            length: 2,
-            required: !0
-        }, {
-            name: "x",
-            type: "field",
-            required: !0
-        }, {
-            name: "y",
-            type: "field",
-            required: !0
-        }, {
-            name: "weight",
-            type: "field"
-        }, {
-            name: "groupby",
-            type: "field",
-            array: !0
-        }, {
-            name: "cellSize",
-            type: "number"
-        }, {
-            name: "bandwidth",
-            type: "number",
-            array: !0,
-            length: 2
-        }, {
-            name: "counts",
-            type: "boolean",
-            default: !1
-        }, {
-            name: "as",
-            type: "string",
-            default: "grid"
-        }]
-    };
-    const ite = ["x", "y", "weight", "size", "cellSize", "bandwidth"];
-
-    function L4(e, t) {
-        return ite.forEach(n => t[n] != null ? e[n](t[n]) : 0), e
-    }
-    ee(gS, L, {
-        transform(e, t) {
-            if (this.value && !t.changed() && !e.modified()) return t.StopPropagation;
-            var n = t.fork(t.NO_SOURCE | t.NO_FIELDS),
-                i = t.materialize(t.SOURCE).source,
-                r = rte(i, e.groupby),
-                s = (e.groupby || []).map(bt),
-                a = L4(P4(), e),
-                o = e.as || "grid",
-                l = [];
-
-            function u(c, f) {
-                for (let h = 0; h < s.length; ++h) c[s[h]] = f[h];
-                return c
-            }
-            return l = r.map(c => He(u({
-                [o]: a(c, e.counts)
-            }, c.dims))), this.value && (n.rem = this.value), this.value = n.source = n.add = l, n
-        }
-    });
-
-    function rte(e, t) {
-        var n = [],
-            i = c => c(o),
-            r, s, a, o, l, u;
-        if (t == null) n.push(e);
-        else
-            for (r = {}, s = 0, a = e.length; s < a; ++s) o = e[s], l = t.map(i), u = r[l], u || (r[l] = u = [], u.dims = l, n.push(u)), u.push(o);
-        return n
-    }
-
-    function pS(e) {
-        L.call(this, null, e)
+        return a
     }
-    pS.Definition = {
-        type: "Contour",
-        metadata: {
-            generates: !0
-        },
-        params: [{
-            name: "size",
-            type: "number",
-            array: !0,
-            length: 2,
-            required: !0
-        }, {
-            name: "values",
-            type: "number",
-            array: !0
-        }, {
-            name: "x",
-            type: "field"
-        }, {
-            name: "y",
-            type: "field"
-        }, {
-            name: "weight",
-            type: "field"
-        }, {
-            name: "cellSize",
-            type: "number"
-        }, {
-            name: "bandwidth",
-            type: "number"
-        }, {
-            name: "count",
-            type: "number"
-        }, {
-            name: "nice",
-            type: "boolean",
-            default: !1
-        }, {
-            name: "thresholds",
-            type: "number",
-            array: !0
-        }, {
-            name: "smooth",
-            type: "boolean",
-            default: !0
-        }]
-    };
-    ee(pS, L, {
-        transform(e, t) {
-            if (this.value && !t.changed() && !e.modified()) return t.StopPropagation;
-            var n = t.fork(t.NO_SOURCE | t.NO_FIELDS),
-                i = R4().smooth(e.smooth !== !1),
-                r = e.values,
-                s = e.thresholds || D4(e.count || 10, e.nice, !!r),
-                a = e.size,
-                o, l;
-            return r || (r = t.materialize(t.SOURCE).source, o = L4(P4(), e)(r, !0), l = N4(o, o.scale || 1, o.scale || 1, 0, 0), a = [o.width, o.height], r = o.values), s = W(s) ? s : s(r), r = i.size(a)(r, s), l && r.forEach(l), this.value && (n.rem = this.value), this.value = n.source = n.add = (r || []).map(He), n
+    const SL = function e(t) {
+        function n(i, r, s, a, o) {
+            wL(t, i, r, s, a, o)
         }
-    });
-    const x2 = "Feature",
-        mS = "FeatureCollection",
-        ste = "MultiPoint";
+        return n.ratio = function(i) {
+            return e((i = +i) > 1 ? i : 1)
+        }, n
+    }(_L);
 
-    function yS(e) {
-        L.call(this, null, e)
-    }
-    yS.Definition = {
-        type: "GeoJSON",
-        metadata: {},
-        params: [{
-            name: "fields",
-            type: "field",
-            array: !0,
-            length: 2
-        }, {
-            name: "geojson",
-            type: "field"
-        }]
-    };
-    ee(yS, L, {
-        transform(e, t) {
-            var n = this._features,
-                i = this._points,
-                r = e.fields,
-                s = r && r[0],
-                a = r && r[1],
-                o = e.geojson || !r && bn,
-                l = t.ADD,
-                u;
-            u = e.modified() || t.changed(t.REM) || t.modified(pn(o)) || s && t.modified(pn(s)) || a && t.modified(pn(a)), (!this.value || u) && (l = t.SOURCE, this._features = n = [], this._points = i = []), o && t.visit(l, c => n.push(o(c))), s && a && (t.visit(l, c => {
-                var f = s(c),
-                    h = a(c);
-                f != null && h != null && (f = +f) === f && (h = +h) === h && i.push([f, h])
-            }), n = n.concat({
-                type: x2,
-                geometry: {
-                    type: ste,
-                    coordinates: i
-                }
-            })), this.value = {
-                type: mS,
-                features: n
-            }
-        }
-    });
+    function mee() {
+        var e = SL,
+            t = !1,
+            n = 1,
+            i = 1,
+            r = [0],
+            s = el,
+            a = el,
+            o = el,
+            l = el,
+            u = el;
 
-    function vS(e) {
-        L.call(this, null, e)
-    }
-    vS.Definition = {
-        type: "GeoPath",
-        metadata: {
-            modifies: !0
-        },
-        params: [{
-            name: "projection",
-            type: "projection"
-        }, {
-            name: "field",
-            type: "field"
-        }, {
-            name: "pointRadius",
-            type: "number",
-            expr: !0
-        }, {
-            name: "as",
-            type: "string",
-            default: "path"
-        }]
-    };
-    ee(vS, L, {
-        transform(e, t) {
-            var n = t.fork(t.ALL),
-                i = this.value,
-                r = e.field || bn,
-                s = e.as || "path",
-                a = n.SOURCE;
-            !i || e.modified() ? (this.value = i = F4(e.projection), n.materialize().reflow()) : a = r === bn || t.modified(r.fields) ? n.ADD_MOD : n.ADD;
-            const o = ate(i, e.pointRadius);
-            return n.visit(a, l => l[s] = i(r(l))), i.pointRadius(o), n.modifies(s)
+        function c(h) {
+            return h.x0 = h.y0 = 0, h.x1 = n, h.y1 = i, h.eachBefore(f), r = [0], t && h.eachBefore(xL), h
         }
-    });
-
-    function ate(e, t) {
-        const n = e.pointRadius();
-        return e.context(null), t != null && e.pointRadius(t), n
-    }
-
-    function bS(e) {
-        L.call(this, null, e)
-    }
-    bS.Definition = {
-        type: "GeoPoint",
-        metadata: {
-            modifies: !0
-        },
-        params: [{
-            name: "projection",
-            type: "projection",
-            required: !0
-        }, {
-            name: "fields",
-            type: "field",
-            array: !0,
-            required: !0,
-            length: 2
-        }, {
-            name: "as",
-            type: "string",
-            array: !0,
-            length: 2,
-            default: ["x", "y"]
-        }]
-    };
-    ee(bS, L, {
-        transform(e, t) {
-            var n = e.projection,
-                i = e.fields[0],
-                r = e.fields[1],
-                s = e.as || ["x", "y"],
-                a = s[0],
-                o = s[1],
-                l;
 
-            function u(c) {
-                const f = n([i(c), r(c)]);
-                f ? (c[a] = f[0], c[o] = f[1]) : (c[a] = void 0, c[o] = void 0)
-            }
-            return e.modified() ? t = t.materialize().reflow(!0).visit(t.SOURCE, u) : (l = t.modified(i.fields) || t.modified(r.fields), t.visit(l ? t.ADD_MOD : t.ADD, u)), t.modifies(s)
+        function f(h) {
+            var d = r[h.depth],
+                g = h.x0 + d,
+                p = h.y0 + d,
+                m = h.x1 - d,
+                y = h.y1 - d;
+            m < g && (g = m = (g + m) / 2), y < p && (p = y = (p + y) / 2), h.x0 = g, h.y0 = p, h.x1 = m, h.y1 = y, h.children && (d = r[h.depth + 1] = s(h) / 2, g += u(h) - d, p += a(h) - d, m -= o(h) - d, y -= l(h) - d, m < g && (g = m = (g + m) / 2), y < p && (p = y = (p + y) / 2), e(h, g, p, m, y))
         }
-    });
-
-    function xS(e) {
-        L.call(this, null, e)
+        return c.round = function(h) {
+            return arguments.length ? (t = !!h, c) : t
+        }, c.size = function(h) {
+            return arguments.length ? (n = +h[0], i = +h[1], c) : [n, i]
+        }, c.tile = function(h) {
+            return arguments.length ? (e = yL(h), c) : e
+        }, c.padding = function(h) {
+            return arguments.length ? c.paddingInner(h).paddingOuter(h) : c.paddingInner()
+        }, c.paddingInner = function(h) {
+            return arguments.length ? (s = typeof h == "function" ? h : Ru(+h), c) : s
+        }, c.paddingOuter = function(h) {
+            return arguments.length ? c.paddingTop(h).paddingRight(h).paddingBottom(h).paddingLeft(h) : c.paddingTop()
+        }, c.paddingTop = function(h) {
+            return arguments.length ? (a = typeof h == "function" ? h : Ru(+h), c) : a
+        }, c.paddingRight = function(h) {
+            return arguments.length ? (o = typeof h == "function" ? h : Ru(+h), c) : o
+        }, c.paddingBottom = function(h) {
+            return arguments.length ? (l = typeof h == "function" ? h : Ru(+h), c) : l
+        }, c.paddingLeft = function(h) {
+            return arguments.length ? (u = typeof h == "function" ? h : Ru(+h), c) : u
+        }, c
     }
-    xS.Definition = {
-        type: "GeoShape",
-        metadata: {
-            modifies: !0,
-            nomod: !0
-        },
-        params: [{
-            name: "projection",
-            type: "projection"
-        }, {
-            name: "field",
-            type: "field",
-            default: "datum"
-        }, {
-            name: "pointRadius",
-            type: "number",
-            expr: !0
-        }, {
-            name: "as",
-            type: "string",
-            default: "shape"
-        }]
-    };
-    ee(xS, L, {
-        transform(e, t) {
-            var n = t.fork(t.ALL),
-                i = this.value,
-                r = e.as || "shape",
-                s = n.ADD;
-            return (!i || e.modified()) && (this.value = i = ote(F4(e.projection), e.field || ni("datum"), e.pointRadius), n.materialize().reflow(), s = n.SOURCE), n.visit(s, a => a[r] = i), n.modifies(r)
-        }
-    });
 
-    function ote(e, t, n) {
-        const i = n == null ? r => e(t(r)) : r => {
-            var s = e.pointRadius(),
-                a = e.pointRadius(n)(t(r));
-            return e.pointRadius(s), a
-        };
-        return i.context = r => (e.context(r), i), i
-    }
+    function yee(e, t, n, i, r) {
+        var s = e.children,
+            a, o = s.length,
+            l, u = new Array(o + 1);
+        for (u[0] = l = a = 0; a < o; ++a) u[a + 1] = l += s[a].value;
+        c(0, o, e.value, t, n, i, r);
 
-    function _S(e) {
-        L.call(this, [], e), this.generator = xG()
-    }
-    _S.Definition = {
-        type: "Graticule",
-        metadata: {
-            changes: !0,
-            generates: !0
-        },
-        params: [{
-            name: "extent",
-            type: "array",
-            array: !0,
-            length: 2,
-            content: {
-                type: "number",
-                array: !0,
-                length: 2
-            }
-        }, {
-            name: "extentMajor",
-            type: "array",
-            array: !0,
-            length: 2,
-            content: {
-                type: "number",
-                array: !0,
-                length: 2
+        function c(f, h, d, g, p, m, y) {
+            if (f >= h - 1) {
+                var v = s[f];
+                v.x0 = g, v.y0 = p, v.x1 = m, v.y1 = y;
+                return
             }
-        }, {
-            name: "extentMinor",
-            type: "array",
-            array: !0,
-            length: 2,
-            content: {
-                type: "number",
-                array: !0,
-                length: 2
+            for (var b = u[f], x = d / 2 + b, _ = f + 1, S = h - 1; _ < S;) {
+                var w = _ + S >>> 1;
+                u[w] < x ? _ = w + 1 : S = w
             }
-        }, {
-            name: "step",
-            type: "number",
-            array: !0,
-            length: 2
-        }, {
-            name: "stepMajor",
-            type: "number",
-            array: !0,
-            length: 2,
-            default: [90, 360]
-        }, {
-            name: "stepMinor",
-            type: "number",
-            array: !0,
-            length: 2,
-            default: [10, 10]
-        }, {
-            name: "precision",
-            type: "number",
-            default: 2.5
-        }]
-    };
-    ee(_S, L, {
-        transform(e, t) {
-            var n = this.value,
-                i = this.generator,
-                r;
-            if (!n.length || e.modified())
-                for (const s in e) $e(i[s]) && i[s](e[s]);
-            return r = i(), n.length ? t.mod.push(WD(n[0], r)) : t.add.push(He(r)), n[0] = r, t
-        }
-    });
-
-    function wS(e) {
-        L.call(this, null, e)
-    }
-    wS.Definition = {
-        type: "heatmap",
-        metadata: {
-            modifies: !0
-        },
-        params: [{
-            name: "field",
-            type: "field"
-        }, {
-            name: "color",
-            type: "string",
-            expr: !0
-        }, {
-            name: "opacity",
-            type: "number",
-            expr: !0
-        }, {
-            name: "resolve",
-            type: "enum",
-            values: ["shared", "independent"],
-            default: "independent"
-        }, {
-            name: "as",
-            type: "string",
-            default: "image"
-        }]
-    };
-    ee(wS, L, {
-        transform(e, t) {
-            if (!t.changed() && !e.modified()) return t.StopPropagation;
-            var n = t.materialize(t.SOURCE).source,
-                i = e.resolve === "shared",
-                r = e.field || bn,
-                s = ute(e.opacity, e),
-                a = lte(e.color, e),
-                o = e.as || "image",
-                l = {
-                    $x: 0,
-                    $y: 0,
-                    $value: 0,
-                    $max: i ? jo(n.map(u => jo(r(u).values))) : 0
-                };
-            return n.forEach(u => {
-                const c = r(u),
-                    f = Ae({}, u, l);
-                i || (f.$max = jo(c.values || [])), u[o] = cte(c, f, a.dep ? a : xn(a(f)), s.dep ? s : xn(s(f)))
-            }), t.reflow(!0).modifies(o)
-        }
-    });
-
-    function lte(e, t) {
-        let n;
-        return $e(e) ? (n = i => Ma(e(i, t)), n.dep = I4(e)) : n = xn(Ma(e || "#888")), n
-    }
-
-    function ute(e, t) {
-        let n;
-        return $e(e) ? (n = i => e(i, t), n.dep = I4(e)) : e ? n = xn(e) : (n = i => i.$value / i.$max || 0, n.dep = !0), n
-    }
-
-    function I4(e) {
-        if (!$e(e)) return !1;
-        const t = fr(pn(e));
-        return t.$x || t.$y || t.$value || t.$max
-    }
-
-    function cte(e, t, n, i) {
-        const r = e.width,
-            s = e.height,
-            a = e.x1 || 0,
-            o = e.y1 || 0,
-            l = e.x2 || r,
-            u = e.y2 || s,
-            c = e.values,
-            f = c ? m => c[m] : ha,
-            h = ka(l - a, u - o),
-            d = h.getContext("2d"),
-            g = d.getImageData(0, 0, l - a, u - o),
-            p = g.data;
-        for (let m = o, y = 0; m < u; ++m) {
-            t.$y = m - o;
-            for (let v = a, b = m * r; v < l; ++v, y += 4) {
-                t.$x = v - a, t.$value = f(v + b);
-                const x = n(t);
-                p[y + 0] = x.r, p[y + 1] = x.g, p[y + 2] = x.b, p[y + 3] = ~~(255 * i(t))
+            x - u[_ - 1] < u[_] - x && f + 1 < _ && --_;
+            var E = u[_] - b,
+                C = d - E;
+            if (m - g > y - p) {
+                var k = d ? (g * C + m * E) / d : m;
+                c(f, _, E, g, p, k, y), c(_, h, C, k, p, m, y)
+            } else {
+                var A = d ? (p * C + y * E) / d : y;
+                c(f, _, E, g, p, m, A), c(_, h, C, g, A, m, y)
             }
         }
-        return d.putImageData(g, 0, 0), h
-    }
-
-    function z4(e) {
-        L.call(this, null, e), this.modified(!0)
-    }
-    ee(z4, L, {
-        transform(e, t) {
-            let n = this.value;
-            return !n || e.modified("type") ? (this.value = n = hte(e.type), b2.forEach(i => {
-                e[i] != null && CT(n, i, e[i])
-            })) : b2.forEach(i => {
-                e.modified(i) && CT(n, i, e[i])
-            }), e.pointRadius != null && n.path.pointRadius(e.pointRadius), e.fit && fte(n, e), t.fork(t.NO_SOURCE | t.NO_FIELDS)
-        }
-    });
-
-    function fte(e, t) {
-        const n = dte(t.fit);
-        t.extent ? e.fitExtent(t.extent, n) : t.size && e.fitSize(t.size, n)
-    }
-
-    function hte(e) {
-        const t = hS((e || "mercator").toLowerCase());
-        return t || U("Unrecognized projection type: " + e), t()
-    }
-
-    function CT(e, t, n) {
-        $e(e[t]) && e[t](n)
-    }
-
-    function dte(e) {
-        return e = se(e), e.length === 1 ? e[0] : {
-            type: mS,
-            features: e.reduce((t, n) => t.concat(gte(n)), [])
-        }
-    }
-
-    function gte(e) {
-        return e.type === mS ? e.features : se(e).filter(t => t != null).map(t => t.type === x2 ? t : {
-            type: x2,
-            geometry: t
-        })
     }
-    const pte = Object.freeze(Object.defineProperty({
-            __proto__: null,
-            contour: pS,
-            geojson: yS,
-            geopath: vS,
-            geopoint: bS,
-            geoshape: xS,
-            graticule: _S,
-            heatmap: wS,
-            isocontour: dS,
-            kde2d: gS,
-            projection: z4
-        }, Symbol.toStringTag, {
-            value: "Module"
-        })),
-        kT = {
-            center: cU,
-            collide: TU,
-            nbody: BU,
-            link: OU,
-            x: jU,
-            y: UU
-        },
-        Bf = "forces",
-        _2 = ["alpha", "alphaMin", "alphaTarget", "velocityDecay", "forces"],
-        mte = ["static", "iterations"],
-        B4 = ["x", "y", "vx", "vy"];
 
-    function SS(e) {
-        L.call(this, null, e)
+    function vee(e, t, n, i, r) {
+        (e.depth & 1 ? N1 : Vd)(e, t, n, i, r)
     }
-    SS.Definition = {
-        type: "Force",
-        metadata: {
-            modifies: !0
-        },
-        params: [{
-            name: "static",
-            type: "boolean",
-            default: !1
-        }, {
-            name: "restart",
-            type: "boolean",
-            default: !1
-        }, {
-            name: "iterations",
-            type: "number",
-            default: 300
-        }, {
-            name: "alpha",
-            type: "number",
-            default: 1
-        }, {
-            name: "alphaMin",
-            type: "number",
-            default: .001
-        }, {
-            name: "alphaTarget",
-            type: "number",
-            default: 0
-        }, {
-            name: "velocityDecay",
-            type: "number",
-            default: .4
-        }, {
-            name: "forces",
-            type: "param",
-            array: !0,
-            params: [{
-                key: {
-                    force: "center"
-                },
-                params: [{
-                    name: "x",
-                    type: "number",
-                    default: 0
-                }, {
-                    name: "y",
-                    type: "number",
-                    default: 0
-                }]
-            }, {
-                key: {
-                    force: "collide"
-                },
-                params: [{
-                    name: "radius",
-                    type: "number",
-                    expr: !0
-                }, {
-                    name: "strength",
-                    type: "number",
-                    default: .7
-                }, {
-                    name: "iterations",
-                    type: "number",
-                    default: 1
-                }]
-            }, {
-                key: {
-                    force: "nbody"
-                },
-                params: [{
-                    name: "strength",
-                    type: "number",
-                    default: -30,
-                    expr: !0
-                }, {
-                    name: "theta",
-                    type: "number",
-                    default: .9
-                }, {
-                    name: "distanceMin",
-                    type: "number",
-                    default: 1
-                }, {
-                    name: "distanceMax",
-                    type: "number"
-                }]
-            }, {
-                key: {
-                    force: "link"
-                },
-                params: [{
-                    name: "links",
-                    type: "data"
-                }, {
-                    name: "id",
-                    type: "field"
-                }, {
-                    name: "distance",
-                    type: "number",
-                    default: 30,
-                    expr: !0
-                }, {
-                    name: "strength",
-                    type: "number",
-                    expr: !0
-                }, {
-                    name: "iterations",
-                    type: "number",
-                    default: 1
-                }]
-            }, {
-                key: {
-                    force: "x"
-                },
-                params: [{
-                    name: "strength",
-                    type: "number",
-                    default: .1
-                }, {
-                    name: "x",
-                    type: "field"
-                }]
-            }, {
-                key: {
-                    force: "y"
-                },
-                params: [{
-                    name: "strength",
-                    type: "number",
-                    default: .1
-                }, {
-                    name: "y",
-                    type: "field"
-                }]
-            }]
-        }, {
-            name: "as",
-            type: "string",
-            array: !0,
-            modify: !1,
-            default: B4
-        }]
-    };
-    ee(SS, L, {
-        transform(e, t) {
-            var n = this.value,
-                i = t.changed(t.ADD_REM),
-                r = e.modified(_2),
-                s = e.iterations || 300;
-            if (n ? (i && (t.modifies("index"), n.nodes(t.source)), (r || t.changed(t.MOD)) && j4(n, e, 0, t)) : (this.value = n = vte(t.source, e), n.on("tick", yte(t.dataflow, this)), e.static || (i = !0, n.tick()), t.modifies("index")), r || i || e.modified(mte) || t.changed() && e.restart) {
-                if (n.alpha(Math.max(n.alpha(), e.alpha || 1)).alphaDecay(1 - Math.pow(n.alphaMin(), 1 / s)), e.static)
-                    for (n.stop(); --s >= 0;) n.tick();
-                else if (n.stopped() && n.restart(), !i) return t.StopPropagation
-            }
-            return this.finish(e, t)
-        },
-        finish(e, t) {
-            const n = t.dataflow;
-            for (let o = this._argops, l = 0, u = o.length, c; l < u; ++l)
-                if (c = o[l], !(c.name !== Bf || c.op._argval.force !== "link")) {
-                    for (var i = c.op._argops, r = 0, s = i.length, a; r < s; ++r)
-                        if (i[r].name === "links" && (a = i[r].op.source)) {
-                            n.pulse(a, n.changeset().reflow());
-                            break
-                        }
-                } return t.reflow(e.modified()).modifies(B4)
+    const bee = function e(t) {
+        function n(i, r, s, a, o) {
+            if ((l = i._squarify) && l.ratio === t)
+                for (var l, u, c, f, h = -1, d, g = l.length, p = i.value; ++h < g;) {
+                    for (u = l[h], c = u.children, f = u.value = 0, d = c.length; f < d; ++f) u.value += c[f].value;
+                    u.dice ? Vd(u, r, s, a, p ? s += (o - s) * u.value / p : o) : N1(u, r, s, p ? r += (a - r) * u.value / p : a, o), p -= u.value
+                } else i._squarify = l = wL(t, i, r, s, a, o), l.ratio = t
         }
-    });
-
-    function yte(e, t) {
-        return () => e.touch(t).run()
-    }
-
-    function vte(e, t) {
-        const n = zU(e),
-            i = n.stop,
-            r = n.restart;
-        let s = !1;
-        return n.stopped = () => s, n.restart = () => (s = !1, r()), n.stop = () => (s = !0, i()), j4(n, t, !0).on("end", () => s = !0)
-    }
-
-    function j4(e, t, n, i) {
-        var r = se(t.forces),
-            s, a, o, l;
-        for (s = 0, a = _2.length; s < a; ++s) o = _2[s], o !== Bf && t.modified(o) && e[o](t[o]);
-        for (s = 0, a = r.length; s < a; ++s) l = Bf + s, o = n || t.modified(Bf, s) ? xte(r[s]) : i && bte(r[s], i) ? e.force(l) : null, o && e.force(l, o);
-        for (a = e.numForces || 0; s < a; ++s) e.force(Bf + s, null);
-        return e.numForces = r.length, e
-    }
-
-    function bte(e, t) {
-        var n, i;
-        for (n in e)
-            if ($e(i = e[n]) && t.modified(pn(i))) return 1;
-        return 0
-    }
-
-    function xte(e) {
-        var t, n;
-        me(kT, e.force) || U("Unrecognized force: " + e.force), t = kT[e.force]();
-        for (n in e) $e(t[n]) && _te(t[n], e[n], e);
-        return t
-    }
-
-    function _te(e, t, n) {
-        e($e(t) ? i => t(i, n) : t)
-    }
-    const wte = Object.freeze(Object.defineProperty({
-        __proto__: null,
-        force: SS
-    }, Symbol.toStringTag, {
-        value: "Module"
-    }));
+        return n.ratio = function(i) {
+            return e((i = +i) > 1 ? i : 1)
+        }, n
+    }(_L);
 
-    function w2(e, t, n) {
+    function Q2(e, t, n) {
         const i = {};
         return e.each(r => {
             const s = r.data;
             n(s) && (i[t(s)] = r)
         }), e.lookup = i, e
     }
 
-    function ES(e) {
-        L.call(this, null, e)
+    function hE(e) {
+        j.call(this, null, e)
     }
-    ES.Definition = {
+    hE.Definition = {
         type: "Nest",
         metadata: {
             treesource: !0,
             changes: !0
         },
         params: [{
             name: "keys",
             type: "field",
             array: !0
         }, {
             name: "generate",
             type: "boolean"
         }]
     };
-    const Ste = e => e.values;
-    ee(ES, L, {
+    const xee = e => e.values;
+    ne(hE, j, {
         transform(e, t) {
-            t.source || U("Nest transform requires an upstream data source.");
+            t.source || q("Nest transform requires an upstream data source.");
             var n = e.generate,
                 i = e.modified(),
                 r = t.clone(),
                 s = this.value;
             return (!s || i || t.changed()) && (s && s.each(a => {
-                a.children && Fm(a.data) && r.rem.push(a.data)
-            }), this.value = s = Bx({
-                values: se(e.keys).reduce((a, o) => (a.key(o), a), Ete()).entries(r.source)
-            }, Ste), n && s.each(a => {
-                a.children && (a = He(a.data), r.add.push(a), r.source.push(a))
-            }), w2(s, ge, ge)), r.source.root = s, r
+                a.children && X0(a.data) && r.rem.push(a.data)
+            }), this.value = s = fE({
+                values: ue(e.keys).reduce((a, o) => (a.key(o), a), _ee()).entries(r.source)
+            }, xee), n && s.each(a => {
+                a.children && (a = it(a.data), r.add.push(a), r.source.push(a))
+            }), Q2(s, Ee, Ee)), r.source.root = s, r
         }
     });
 
-    function Ete() {
+    function _ee() {
         const e = [],
             t = {
                 entries: r => i(n(r, 0), 0),
                 key: r => (e.push(r), t)
             };
 
         function n(r, s) {
@@ -28122,51 +20498,51 @@
                 values: i(r[o], s)
             });
             return a
         }
         return t
     }
 
-    function Hs(e) {
-        L.call(this, null, e)
+    function aa(e) {
+        j.call(this, null, e)
     }
-    const Cte = (e, t) => e.parent === t.parent ? 1 : 2;
-    ee(Hs, L, {
+    const wee = (e, t) => e.parent === t.parent ? 1 : 2;
+    ne(aa, j, {
         transform(e, t) {
-            (!t.source || !t.source.root) && U(this.constructor.name + " transform requires a backing tree data source.");
+            (!t.source || !t.source.root) && q(this.constructor.name + " transform requires a backing tree data source.");
             const n = this.layout(e.method),
                 i = this.fields,
                 r = t.source.root,
                 s = e.as || i;
-            e.field ? r.sum(e.field) : r.count(), e.sort && r.sort($l(e.sort, a => a.data)), kte(n, this.params, e), n.separation && n.separation(e.separation !== !1 ? Cte : vc);
+            e.field ? r.sum(e.field) : r.count(), e.sort && r.sort(Yl(e.sort, a => a.data)), See(n, this.params, e), n.separation && n.separation(e.separation !== !1 ? wee : Bc);
             try {
                 this.value = n(r)
             } catch (a) {
-                U(a)
+                q(a)
             }
-            return r.each(a => Ate(a, i, s)), t.reflow(e.modified()).modifies(s).modifies("leaf")
+            return r.each(a => Eee(a, i, s)), t.reflow(e.modified()).modifies(s).modifies("leaf")
         }
     });
 
-    function kte(e, t, n) {
+    function See(e, t, n) {
         for (let i, r = 0, s = t.length; r < s; ++r) i = t[r], i in n && e[i](n[i])
     }
 
-    function Ate(e, t, n) {
+    function Eee(e, t, n) {
         const i = e.data,
             r = t.length - 1;
         for (let s = 0; s < r; ++s) i[n[s]] = e[t[s]];
         i[n[r]] = e.children ? e.children.length : 0
     }
-    const S2 = ["x", "y", "r", "depth", "children"];
+    const Z2 = ["x", "y", "r", "depth", "children"];
 
-    function CS(e) {
-        Hs.call(this, e)
+    function dE(e) {
+        aa.call(this, e)
     }
-    CS.Definition = {
+    dE.Definition = {
         type: "Pack",
         metadata: {
             tree: !0,
             modifies: !0
         },
         params: [{
             name: "field",
@@ -28187,29 +20563,29 @@
             type: "number",
             array: !0,
             length: 2
         }, {
             name: "as",
             type: "string",
             array: !0,
-            length: S2.length,
-            default: S2
+            length: Z2.length,
+            default: Z2
         }]
     };
-    ee(CS, Hs, {
-        layout: GW,
+    ne(dE, aa, {
+        layout: ree,
         params: ["radius", "size", "padding"],
-        fields: S2
+        fields: Z2
     });
-    const E2 = ["x0", "y0", "x1", "y1", "depth", "children"];
+    const ex = ["x0", "y0", "x1", "y1", "depth", "children"];
 
-    function kS(e) {
-        Hs.call(this, e)
+    function gE(e) {
+        aa.call(this, e)
     }
-    kS.Definition = {
+    gE.Definition = {
         type: "Partition",
         metadata: {
             tree: !0,
             modifies: !0
         },
         params: [{
             name: "field",
@@ -28230,62 +20606,62 @@
             type: "number",
             array: !0,
             length: 2
         }, {
             name: "as",
             type: "string",
             array: !0,
-            length: E2.length,
-            default: E2
+            length: ex.length,
+            default: ex
         }]
     };
-    ee(kS, Hs, {
-        layout: WW,
+    ne(gE, aa, {
+        layout: see,
         params: ["size", "round", "padding"],
-        fields: E2
+        fields: ex
     });
 
-    function AS(e) {
-        L.call(this, null, e)
+    function pE(e) {
+        j.call(this, null, e)
     }
-    AS.Definition = {
+    pE.Definition = {
         type: "Stratify",
         metadata: {
             treesource: !0
         },
         params: [{
             name: "key",
             type: "field",
             required: !0
         }, {
             name: "parentKey",
             type: "field",
             required: !0
         }]
     };
-    ee(AS, L, {
+    ne(pE, j, {
         transform(e, t) {
-            t.source || U("Stratify transform requires an upstream data source.");
+            t.source || q("Stratify transform requires an upstream data source.");
             let n = this.value;
             const i = e.modified(),
                 r = t.fork(t.ALL).materialize(t.SOURCE),
                 s = !n || i || t.changed(t.ADD_REM) || t.modified(e.key.fields) || t.modified(e.parentKey.fields);
-            return r.source = r.source.slice(), s && (n = r.source.length ? w2(PA().id(e.key).parentId(e.parentKey)(r.source), e.key, Ri) : w2(PA()([{}]), e.key, e.key)), r.source.root = this.value = n, r
+            return r.source = r.source.slice(), s && (n = r.source.length ? Q2(jT().id(e.key).parentId(e.parentKey)(r.source), e.key, Yi) : Q2(jT()([{}]), e.key, e.key)), r.source.root = this.value = n, r
         }
     });
-    const AT = {
-            tidy: eq,
-            cluster: hW
+    const UT = {
+            tidy: pee,
+            cluster: AZ
         },
-        C2 = ["x", "y", "depth", "children"];
+        tx = ["x", "y", "depth", "children"];
 
-    function $S(e) {
-        Hs.call(this, e)
+    function mE(e) {
+        aa.call(this, e)
     }
-    $S.Definition = {
+    mE.Definition = {
         type: "Tree",
         metadata: {
             tree: !0,
             modifies: !0
         },
         params: [{
             name: "field",
@@ -28312,72 +20688,72 @@
             name: "separation",
             type: "boolean",
             default: !0
         }, {
             name: "as",
             type: "string",
             array: !0,
-            length: C2.length,
-            default: C2
+            length: tx.length,
+            default: tx
         }]
     };
-    ee($S, Hs, {
+    ne(mE, aa, {
         layout(e) {
             const t = e || "tidy";
-            if (me(AT, t)) return AT[t]();
-            U("Unrecognized Tree layout method: " + t)
+            if (Ce(UT, t)) return UT[t]();
+            q("Unrecognized Tree layout method: " + t)
         },
         params: ["size", "nodeSize"],
-        fields: C2
+        fields: tx
     });
 
-    function TS(e) {
-        L.call(this, [], e)
+    function yE(e) {
+        j.call(this, [], e)
     }
-    TS.Definition = {
+    yE.Definition = {
         type: "TreeLinks",
         metadata: {
             tree: !0,
             generates: !0,
             changes: !0
         },
         params: []
     };
-    ee(TS, L, {
+    ne(yE, j, {
         transform(e, t) {
             const n = this.value,
                 i = t.source && t.source.root,
                 r = t.fork(t.NO_SOURCE),
                 s = {};
-            return i || U("TreeLinks transform requires a tree data source."), t.changed(t.ADD_REM) ? (r.rem = n, t.visit(t.SOURCE, a => s[ge(a)] = 1), i.each(a => {
+            return i || q("TreeLinks transform requires a tree data source."), t.changed(t.ADD_REM) ? (r.rem = n, t.visit(t.SOURCE, a => s[Ee(a)] = 1), i.each(a => {
                 const o = a.data,
                     l = a.parent && a.parent.data;
-                l && s[ge(o)] && s[ge(l)] && r.add.push(He({
+                l && s[Ee(o)] && s[Ee(l)] && r.add.push(it({
                     source: l,
                     target: o
                 }))
-            }), this.value = r.add) : t.changed(t.MOD) && (t.visit(t.MOD, a => s[ge(a)] = 1), n.forEach(a => {
-                (s[ge(a.source)] || s[ge(a.target)]) && r.mod.push(a)
+            }), this.value = r.add) : t.changed(t.MOD) && (t.visit(t.MOD, a => s[Ee(a)] = 1), n.forEach(a => {
+                (s[Ee(a.source)] || s[Ee(a.target)]) && r.mod.push(a)
             })), r
         }
     });
-    const $T = {
-            binary: nq,
-            dice: id,
-            slice: hm,
-            slicedice: iq,
-            squarify: XF,
-            resquarify: rq
+    const WT = {
+            binary: yee,
+            dice: Vd,
+            slice: N1,
+            slicedice: vee,
+            squarify: SL,
+            resquarify: bee
         },
-        k2 = ["x0", "y0", "x1", "y1", "depth", "children"];
+        nx = ["x0", "y0", "x1", "y1", "depth", "children"];
 
-    function MS(e) {
-        Hs.call(this, e)
+    function vE(e) {
+        aa.call(this, e)
     }
-    MS.Definition = {
+    vE.Definition = {
         type: "Treemap",
         metadata: {
             tree: !0,
             modifies: !0
         },
         params: [{
             name: "field",
@@ -28431,394 +20807,394 @@
             type: "number",
             array: !0,
             length: 2
         }, {
             name: "as",
             type: "string",
             array: !0,
-            length: k2.length,
-            default: k2
+            length: nx.length,
+            default: nx
         }]
     };
-    ee(MS, Hs, {
+    ne(vE, aa, {
         layout() {
-            const e = tq();
+            const e = mee();
             return e.ratio = t => {
                 const n = e.tile();
                 n.ratio && e.tile(n.ratio(t))
             }, e.method = t => {
-                me($T, t) ? e.tile($T[t]) : U("Unrecognized Treemap layout method: " + t)
+                Ce(WT, t) ? e.tile(WT[t]) : q("Unrecognized Treemap layout method: " + t)
             }, e
         },
         params: ["method", "ratio", "size", "round", "padding", "paddingInner", "paddingOuter", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft"],
-        fields: k2
+        fields: nx
     });
-    const $te = Object.freeze(Object.defineProperty({
+    const kee = Object.freeze(Object.defineProperty({
             __proto__: null,
-            nest: ES,
-            pack: CS,
-            partition: kS,
-            stratify: AS,
-            tree: $S,
-            treelinks: TS,
-            treemap: MS
+            nest: hE,
+            pack: dE,
+            partition: gE,
+            stratify: pE,
+            tree: mE,
+            treelinks: yE,
+            treemap: vE
         }, Symbol.toStringTag, {
             value: "Module"
         })),
-        sv = 4278190080;
+        Fv = 4278190080;
 
-    function Tte(e, t) {
+    function Cee(e, t) {
         const n = e.bitmap();
         return (t || []).forEach(i => n.set(e(i.boundary[0]), e(i.boundary[3]))), [n, void 0]
     }
 
-    function Mte(e, t, n, i, r) {
+    function Aee(e, t, n, i, r) {
         const s = e.width,
             a = e.height,
             o = i || r,
-            l = ka(s, a).getContext("2d"),
-            u = ka(s, a).getContext("2d"),
-            c = o && ka(s, a).getContext("2d");
-        n.forEach(E => ap(l, E, !1)), ap(u, t, !1), o && ap(c, t, !0);
-        const f = av(l, s, a),
-            h = av(u, s, a),
-            d = o && av(c, s, a),
+            l = Ha(s, a).getContext("2d"),
+            u = Ha(s, a).getContext("2d"),
+            c = o && Ha(s, a).getContext("2d");
+        n.forEach(E => Pp(l, E, !1)), Pp(u, t, !1), o && Pp(c, t, !0);
+        const f = Rv(l, s, a),
+            h = Rv(u, s, a),
+            d = o && Rv(c, s, a),
             g = e.bitmap(),
             p = o && e.bitmap();
         let m, y, v, b, x, _, S, w;
         for (y = 0; y < a; ++y)
-            for (m = 0; m < s; ++m) x = y * s + m, _ = f[x] & sv, w = h[x] & sv, S = o && d[x] & sv, (_ || S || w) && (v = e(m), b = e(y), !r && (_ || w) && g.set(v, b), o && (_ || S) && p.set(v, b));
+            for (m = 0; m < s; ++m) x = y * s + m, _ = f[x] & Fv, w = h[x] & Fv, S = o && d[x] & Fv, (_ || S || w) && (v = e(m), b = e(y), !r && (_ || w) && g.set(v, b), o && (_ || S) && p.set(v, b));
         return [g, p]
     }
 
-    function av(e, t, n) {
+    function Rv(e, t, n) {
         return new Uint32Array(e.getImageData(0, 0, t, n).data.buffer)
     }
 
-    function ap(e, t, n) {
+    function Pp(e, t, n) {
         if (!t.length) return;
         const i = t[0].mark.marktype;
         i === "group" ? t.forEach(r => {
-            r.items.forEach(s => ap(e, s.items, n))
-        }) : xi[i].draw(e, {
-            items: n ? t.map(Ote) : t
+            r.items.forEach(s => Pp(e, s.items, n))
+        }) : Ri[i].draw(e, {
+            items: n ? t.map($ee) : t
         })
     }
 
-    function Ote(e) {
-        const t = Rm(e, {});
+    function $ee(e) {
+        const t = V0(e, {});
         return t.stroke && t.strokeOpacity !== 0 || t.fill && t.fillOpacity !== 0 ? {
             ...t,
             strokeOpacity: 1,
             stroke: "#000",
             fillOpacity: 0
         } : t
     }
-    const gs = 5,
-        Cn = 31,
-        Mh = 32,
-        ua = new Uint32Array(Mh + 1),
-        Vi = new Uint32Array(Mh + 1);
-    Vi[0] = 0;
-    ua[0] = ~Vi[0];
-    for (let e = 1; e <= Mh; ++e) Vi[e] = Vi[e - 1] << 1 | 1, ua[e] = ~Vi[e];
+    const Os = 5,
+        In = 31,
+        sd = 32,
+        $a = new Uint32Array(sd + 1),
+        fr = new Uint32Array(sd + 1);
+    fr[0] = 0;
+    $a[0] = ~fr[0];
+    for (let e = 1; e <= sd; ++e) fr[e] = fr[e - 1] << 1 | 1, $a[e] = ~fr[e];
 
-    function Fte(e, t) {
-        const n = new Uint32Array(~~((e * t + Mh) / Mh));
+    function Tee(e, t) {
+        const n = new Uint32Array(~~((e * t + sd) / sd));
 
         function i(s, a) {
             n[s] |= a
         }
 
         function r(s, a) {
             n[s] &= a
         }
         return {
             array: n,
             get: (s, a) => {
                 const o = a * e + s;
-                return n[o >>> gs] & 1 << (o & Cn)
+                return n[o >>> Os] & 1 << (o & In)
             },
             set: (s, a) => {
                 const o = a * e + s;
-                i(o >>> gs, 1 << (o & Cn))
+                i(o >>> Os, 1 << (o & In))
             },
             clear: (s, a) => {
                 const o = a * e + s;
-                r(o >>> gs, ~(1 << (o & Cn)))
+                r(o >>> Os, ~(1 << (o & In)))
             },
             getRange: (s, a, o, l) => {
                 let u = l,
                     c, f, h, d;
                 for (; u >= a; --u)
-                    if (c = u * e + s, f = u * e + o, h = c >>> gs, d = f >>> gs, h === d) {
-                        if (n[h] & ua[c & Cn] & Vi[(f & Cn) + 1]) return !0
+                    if (c = u * e + s, f = u * e + o, h = c >>> Os, d = f >>> Os, h === d) {
+                        if (n[h] & $a[c & In] & fr[(f & In) + 1]) return !0
                     } else {
-                        if (n[h] & ua[c & Cn] || n[d] & Vi[(f & Cn) + 1]) return !0;
+                        if (n[h] & $a[c & In] || n[d] & fr[(f & In) + 1]) return !0;
                         for (let g = h + 1; g < d; ++g)
                             if (n[g]) return !0
                     } return !1
             },
             setRange: (s, a, o, l) => {
                 let u, c, f, h, d;
                 for (; a <= l; ++a)
-                    if (u = a * e + s, c = a * e + o, f = u >>> gs, h = c >>> gs, f === h) i(f, ua[u & Cn] & Vi[(c & Cn) + 1]);
+                    if (u = a * e + s, c = a * e + o, f = u >>> Os, h = c >>> Os, f === h) i(f, $a[u & In] & fr[(c & In) + 1]);
                     else
-                        for (i(f, ua[u & Cn]), i(h, Vi[(c & Cn) + 1]), d = f + 1; d < h; ++d) i(d, 4294967295)
+                        for (i(f, $a[u & In]), i(h, fr[(c & In) + 1]), d = f + 1; d < h; ++d) i(d, 4294967295)
             },
             clearRange: (s, a, o, l) => {
                 let u, c, f, h, d;
                 for (; a <= l; ++a)
-                    if (u = a * e + s, c = a * e + o, f = u >>> gs, h = c >>> gs, f === h) r(f, Vi[u & Cn] | ua[(c & Cn) + 1]);
+                    if (u = a * e + s, c = a * e + o, f = u >>> Os, h = c >>> Os, f === h) r(f, fr[u & In] | $a[(c & In) + 1]);
                     else
-                        for (r(f, Vi[u & Cn]), r(h, ua[(c & Cn) + 1]), d = f + 1; d < h; ++d) r(d, 0)
+                        for (r(f, fr[u & In]), r(h, $a[(c & In) + 1]), d = f + 1; d < h; ++d) r(d, 0)
             },
             outOfBounds: (s, a, o, l) => s < 0 || a < 0 || l >= t || o >= e
         }
     }
 
-    function Rte(e, t, n) {
+    function Mee(e, t, n) {
         const i = Math.max(1, Math.sqrt(e * t / 1e6)),
             r = ~~((e + 2 * n + i) / i),
             s = ~~((t + 2 * n + i) / i),
             a = o => ~~((o + n) / i);
-        return a.invert = o => o * i - n, a.bitmap = () => Fte(r, s), a.ratio = i, a.padding = n, a.width = e, a.height = t, a
+        return a.invert = o => o * i - n, a.bitmap = () => Tee(r, s), a.ratio = i, a.padding = n, a.width = e, a.height = t, a
     }
 
-    function Dte(e, t, n, i) {
+    function Oee(e, t, n, i) {
         const r = e.width,
             s = e.height;
         return function(a) {
             const o = a.datum.datum.items[i].items,
                 l = o.length,
                 u = a.datum.fontSize,
-                c = sr.width(a.datum, a.datum.text);
+                c = wr.width(a.datum, a.datum.text);
             let f = 0,
                 h, d, g, p, m, y, v;
             for (let b = 0; b < l; ++b) h = o[b].x, g = o[b].y, d = o[b].x2 === void 0 ? h : o[b].x2, p = o[b].y2 === void 0 ? g : o[b].y2, m = (h + d) / 2, y = (g + p) / 2, v = Math.abs(d - h + p - g), v >= f && (f = v, a.x = m, a.y = y);
             return m = c / 2, y = u / 2, h = a.x - m, d = a.x + m, g = a.y - y, p = a.y + y, a.align = "center", h < 0 && d <= r ? a.align = "left" : 0 <= h && r < d && (a.align = "right"), a.baseline = "middle", g < 0 && p <= s ? a.baseline = "top" : 0 <= g && s < p && (a.baseline = "bottom"), !0
         }
     }
 
-    function A0(e, t, n, i, r, s) {
+    function o0(e, t, n, i, r, s) {
         let a = n / 2;
         return e - a < 0 || e + a > r || t - (a = i / 2) < 0 || t + a > s
     }
 
-    function xa(e, t, n, i, r, s, a, o) {
+    function za(e, t, n, i, r, s, a, o) {
         const l = r * s / (i * 2),
             u = e(t - l),
             c = e(t + l),
             f = e(n - (s = s / 2)),
             h = e(n + s);
         return a.outOfBounds(u, f, c, h) || a.getRange(u, f, c, h) || o && o.getRange(u, f, c, h)
     }
 
-    function Nte(e, t, n, i) {
+    function Fee(e, t, n, i) {
         const r = e.width,
             s = e.height,
             a = t[0],
             o = t[1];
 
         function l(u, c, f, h, d) {
             const g = e.invert(u),
                 p = e.invert(c);
             let m = f,
                 y = s,
                 v;
-            if (!A0(g, p, h, d, r, s) && !xa(e, g, p, d, h, m, a, o) && !xa(e, g, p, d, h, d, a, null)) {
-                for (; y - m >= 1;) v = (m + y) / 2, xa(e, g, p, d, h, v, a, o) ? y = v : m = v;
+            if (!o0(g, p, h, d, r, s) && !za(e, g, p, d, h, m, a, o) && !za(e, g, p, d, h, d, a, null)) {
+                for (; y - m >= 1;) v = (m + y) / 2, za(e, g, p, d, h, v, a, o) ? y = v : m = v;
                 if (m > f) return [g, p, m, !0]
             }
         }
         return function(u) {
             const c = u.datum.datum.items[i].items,
                 f = c.length,
                 h = u.datum.fontSize,
-                d = sr.width(u.datum, u.datum.text);
+                d = wr.width(u.datum, u.datum.text);
             let g = n ? h : 0,
                 p = !1,
                 m = !1,
                 y = 0,
-                v, b, x, _, S, w, E, A, C, k, R, $, T, M, F, N, P;
-            for (let z = 0; z < f; ++z) {
-                for (v = c[z].x, x = c[z].y, b = c[z].x2 === void 0 ? v : c[z].x2, _ = c[z].y2 === void 0 ? x : c[z].y2, v > b && (P = v, v = b, b = P), x > _ && (P = x, x = _, _ = P), C = e(v), R = e(b), k = ~~((C + R) / 2), $ = e(x), M = e(_), T = ~~(($ + M) / 2), E = k; E >= C; --E)
-                    for (A = T; A >= $; --A) N = l(E, A, g, d, h), N && ([u.x, u.y, g, p] = N);
-                for (E = k; E <= R; ++E)
-                    for (A = T; A <= M; ++A) N = l(E, A, g, d, h), N && ([u.x, u.y, g, p] = N);
-                !p && !n && (F = Math.abs(b - v + _ - x), S = (v + b) / 2, w = (x + _) / 2, F >= y && !A0(S, w, d, h, r, s) && !xa(e, S, w, h, d, h, a, null) && (y = F, u.x = S, u.y = w, m = !0))
+                v, b, x, _, S, w, E, C, k, A, F, $, T, M, R, N, L;
+            for (let I = 0; I < f; ++I) {
+                for (v = c[I].x, x = c[I].y, b = c[I].x2 === void 0 ? v : c[I].x2, _ = c[I].y2 === void 0 ? x : c[I].y2, v > b && (L = v, v = b, b = L), x > _ && (L = x, x = _, _ = L), k = e(v), F = e(b), A = ~~((k + F) / 2), $ = e(x), M = e(_), T = ~~(($ + M) / 2), E = A; E >= k; --E)
+                    for (C = T; C >= $; --C) N = l(E, C, g, d, h), N && ([u.x, u.y, g, p] = N);
+                for (E = A; E <= F; ++E)
+                    for (C = T; C <= M; ++C) N = l(E, C, g, d, h), N && ([u.x, u.y, g, p] = N);
+                !p && !n && (R = Math.abs(b - v + _ - x), S = (v + b) / 2, w = (x + _) / 2, R >= y && !o0(S, w, d, h, r, s) && !za(e, S, w, h, d, h, a, null) && (y = R, u.x = S, u.y = w, m = !0))
             }
             return p || m ? (S = d / 2, w = h / 2, a.setRange(e(u.x - S), e(u.y - w), e(u.x + S), e(u.y + w)), u.align = "center", u.baseline = "middle", !0) : !1
         }
     }
-    const Pte = [-1, -1, 1, 1],
-        Lte = [-1, 1, -1, 1];
+    const Ree = [-1, -1, 1, 1],
+        Dee = [-1, 1, -1, 1];
 
-    function Ite(e, t, n, i) {
+    function Nee(e, t, n, i) {
         const r = e.width,
             s = e.height,
             a = t[0],
             o = t[1],
             l = e.bitmap();
         return function(u) {
             const c = u.datum.datum.items[i].items,
                 f = c.length,
                 h = u.datum.fontSize,
-                d = sr.width(u.datum, u.datum.text),
+                d = wr.width(u.datum, u.datum.text),
                 g = [];
             let p = n ? h : 0,
                 m = !1,
                 y = !1,
                 v = 0,
-                b, x, _, S, w, E, A, C, k, R, $, T;
+                b, x, _, S, w, E, C, k, A, F, $, T;
             for (let M = 0; M < f; ++M) {
                 for (b = c[M].x, _ = c[M].y, x = c[M].x2 === void 0 ? b : c[M].x2, S = c[M].y2 === void 0 ? _ : c[M].y2, g.push([e((b + x) / 2), e((_ + S) / 2)]); g.length;)
-                    if ([A, C] = g.pop(), !(a.get(A, C) || o.get(A, C) || l.get(A, C))) {
-                        l.set(A, C);
-                        for (let F = 0; F < 4; ++F) w = A + Pte[F], E = C + Lte[F], l.outOfBounds(w, E, w, E) || g.push([w, E]);
-                        if (w = e.invert(A), E = e.invert(C), k = p, R = s, !A0(w, E, d, h, r, s) && !xa(e, w, E, h, d, k, a, o) && !xa(e, w, E, h, d, h, a, null)) {
-                            for (; R - k >= 1;) $ = (k + R) / 2, xa(e, w, E, h, d, $, a, o) ? R = $ : k = $;
-                            k > p && (u.x = w, u.y = E, p = k, m = !0)
+                    if ([C, k] = g.pop(), !(a.get(C, k) || o.get(C, k) || l.get(C, k))) {
+                        l.set(C, k);
+                        for (let R = 0; R < 4; ++R) w = C + Ree[R], E = k + Dee[R], l.outOfBounds(w, E, w, E) || g.push([w, E]);
+                        if (w = e.invert(C), E = e.invert(k), A = p, F = s, !o0(w, E, d, h, r, s) && !za(e, w, E, h, d, A, a, o) && !za(e, w, E, h, d, h, a, null)) {
+                            for (; F - A >= 1;) $ = (A + F) / 2, za(e, w, E, h, d, $, a, o) ? F = $ : A = $;
+                            A > p && (u.x = w, u.y = E, p = A, m = !0)
                         }
-                    }! m && !n && (T = Math.abs(x - b + S - _), w = (b + x) / 2, E = (_ + S) / 2, T >= v && !A0(w, E, d, h, r, s) && !xa(e, w, E, h, d, h, a, null) && (v = T, u.x = w, u.y = E, y = !0))
+                    }! m && !n && (T = Math.abs(x - b + S - _), w = (b + x) / 2, E = (_ + S) / 2, T >= v && !o0(w, E, d, h, r, s) && !za(e, w, E, h, d, h, a, null) && (v = T, u.x = w, u.y = E, y = !0))
             }
             return m || y ? (w = d / 2, E = h / 2, a.setRange(e(u.x - w), e(u.y - E), e(u.x + w), e(u.y + E)), u.align = "center", u.baseline = "middle", !0) : !1
         }
     }
-    const zte = ["right", "center", "left"],
-        Bte = ["bottom", "middle", "top"];
+    const Pee = ["right", "center", "left"],
+        Lee = ["bottom", "middle", "top"];
 
-    function jte(e, t, n, i) {
+    function Iee(e, t, n, i) {
         const r = e.width,
             s = e.height,
             a = t[0],
             o = t[1],
             l = i.length;
         return function(u) {
             const c = u.boundary,
                 f = u.datum.fontSize;
             if (c[2] < 0 || c[5] < 0 || c[0] > r || c[3] > s) return !1;
             let h = u.textWidth ?? 0,
-                d, g, p, m, y, v, b, x, _, S, w, E, A, C, k;
-            for (let R = 0; R < l; ++R) {
-                if (d = (n[R] & 3) - 1, g = (n[R] >>> 2 & 3) - 1, p = d === 0 && g === 0 || i[R] < 0, m = d && g ? Math.SQRT1_2 : 1, y = i[R] < 0 ? -1 : 1, v = c[1 + d] + i[R] * d * m, w = c[4 + g] + y * f * g / 2 + i[R] * g * m, x = w - f / 2, _ = w + f / 2, E = e(v), C = e(x), k = e(_), !h)
-                    if (TT(E, E, C, k, a, o, v, v, x, _, c, p)) h = sr.width(u.datum, u.datum.text);
+                d, g, p, m, y, v, b, x, _, S, w, E, C, k, A;
+            for (let F = 0; F < l; ++F) {
+                if (d = (n[F] & 3) - 1, g = (n[F] >>> 2 & 3) - 1, p = d === 0 && g === 0 || i[F] < 0, m = d && g ? Math.SQRT1_2 : 1, y = i[F] < 0 ? -1 : 1, v = c[1 + d] + i[F] * d * m, w = c[4 + g] + y * f * g / 2 + i[F] * g * m, x = w - f / 2, _ = w + f / 2, E = e(v), k = e(x), A = e(_), !h)
+                    if (qT(E, E, k, A, a, o, v, v, x, _, c, p)) h = wr.width(u.datum, u.datum.text);
                     else continue;
-                if (S = v + y * h * d / 2, v = S - h / 2, b = S + h / 2, E = e(v), A = e(b), TT(E, A, C, k, a, o, v, b, x, _, c, p)) return u.x = d ? d * y < 0 ? b : v : S, u.y = g ? g * y < 0 ? _ : x : w, u.align = zte[d * y + 1], u.baseline = Bte[g * y + 1], a.setRange(E, C, A, k), !0
+                if (S = v + y * h * d / 2, v = S - h / 2, b = S + h / 2, E = e(v), C = e(b), qT(E, C, k, A, a, o, v, b, x, _, c, p)) return u.x = d ? d * y < 0 ? b : v : S, u.y = g ? g * y < 0 ? _ : x : w, u.align = Pee[d * y + 1], u.baseline = Lee[g * y + 1], a.setRange(E, k, C, A), !0
             }
             return !1
         }
     }
 
-    function TT(e, t, n, i, r, s, a, o, l, u, c, f) {
+    function qT(e, t, n, i, r, s, a, o, l, u, c, f) {
         return !(r.outOfBounds(e, n, t, i) || (f && s || r).getRange(e, n, t, i))
     }
-    const ov = 0,
-        lv = 4,
-        uv = 8,
-        cv = 0,
-        fv = 1,
-        hv = 2,
-        Ute = {
-            "top-left": ov + cv,
-            top: ov + fv,
-            "top-right": ov + hv,
-            left: lv + cv,
-            middle: lv + fv,
-            right: lv + hv,
-            "bottom-left": uv + cv,
-            bottom: uv + fv,
-            "bottom-right": uv + hv
-        },
-        Gte = {
-            naive: Dte,
-            "reduced-search": Nte,
-            floodfill: Ite
+    const Dv = 0,
+        Nv = 4,
+        Pv = 8,
+        Lv = 0,
+        Iv = 1,
+        zv = 2,
+        zee = {
+            "top-left": Dv + Lv,
+            top: Dv + Iv,
+            "top-right": Dv + zv,
+            left: Nv + Lv,
+            middle: Nv + Iv,
+            right: Nv + zv,
+            "bottom-left": Pv + Lv,
+            bottom: Pv + Iv,
+            "bottom-right": Pv + zv
+        },
+        Bee = {
+            naive: Oee,
+            "reduced-search": Fee,
+            floodfill: Nee
         };
 
-    function Wte(e, t, n, i, r, s, a, o, l, u, c) {
+    function jee(e, t, n, i, r, s, a, o, l, u, c) {
         if (!e.length) return e;
         const f = Math.max(i.length, r.length),
-            h = qte(i, f),
-            d = Hte(r, f),
-            g = Yte(e[0].datum),
+            h = Gee(i, f),
+            d = Uee(r, f),
+            g = Wee(e[0].datum),
             p = g === "group" && e[0].datum.items[l].marktype,
             m = p === "area",
-            y = Xte(g, p, o, l),
+            y = qee(g, p, o, l),
             v = u === null || u === 1 / 0,
             b = m && c === "naive";
         let x = -1,
             _ = -1;
-        const S = e.map(C => {
-            const k = v ? sr.width(C, C.text) : void 0;
-            return x = Math.max(x, k), _ = Math.max(_, C.fontSize), {
-                datum: C,
+        const S = e.map(k => {
+            const A = v ? wr.width(k, k.text) : void 0;
+            return x = Math.max(x, A), _ = Math.max(_, k.fontSize), {
+                datum: k,
                 opacity: 0,
                 x: void 0,
                 y: void 0,
                 align: void 0,
                 baseline: void 0,
-                boundary: y(C),
-                textWidth: k
+                boundary: y(k),
+                textWidth: A
             }
         });
         u = u === null || u === 1 / 0 ? Math.max(x, _) + Math.max(...i) : u;
-        const w = Rte(t[0], t[1], u);
+        const w = Mee(t[0], t[1], u);
         let E;
         if (!b) {
-            n && S.sort((R, $) => n(R.datum, $.datum));
-            let C = !1;
-            for (let R = 0; R < d.length && !C; ++R) C = d[R] === 5 || h[R] < 0;
-            const k = (g && a || m) && e.map(R => R.datum);
-            E = s.length || k ? Mte(w, k || [], s, C, m) : Tte(w, a && S)
+            n && S.sort((F, $) => n(F.datum, $.datum));
+            let k = !1;
+            for (let F = 0; F < d.length && !k; ++F) k = d[F] === 5 || h[F] < 0;
+            const A = (g && a || m) && e.map(F => F.datum);
+            E = s.length || A ? Aee(w, A || [], s, k, m) : Cee(w, a && S)
         }
-        const A = m ? Gte[c](w, E, a, l) : jte(w, E, d, h);
-        return S.forEach(C => C.opacity = +A(C)), S
+        const C = m ? Bee[c](w, E, a, l) : Iee(w, E, d, h);
+        return S.forEach(k => k.opacity = +C(k)), S
     }
 
-    function qte(e, t) {
+    function Gee(e, t) {
         const n = new Float64Array(t),
             i = e.length;
         for (let r = 0; r < i; ++r) n[r] = e[r] || 0;
         for (let r = i; r < t; ++r) n[r] = n[i - 1];
         return n
     }
 
-    function Hte(e, t) {
+    function Uee(e, t) {
         const n = new Int8Array(t),
             i = e.length;
-        for (let r = 0; r < i; ++r) n[r] |= Ute[e[r]];
+        for (let r = 0; r < i; ++r) n[r] |= zee[e[r]];
         for (let r = i; r < t; ++r) n[r] = n[i - 1];
         return n
     }
 
-    function Yte(e) {
+    function Wee(e) {
         return e && e.mark && e.mark.marktype
     }
 
-    function Xte(e, t, n, i) {
+    function qee(e, t, n, i) {
         const r = s => [s.x, s.x, s.x, s.y, s.y, s.y];
         return e ? e === "line" || e === "area" ? s => r(s.datum) : t === "line" ? s => {
             const a = s.datum.items[i].items;
             return r(a.length ? a[n === "start" ? 0 : a.length - 1] : {
                 x: NaN,
                 y: NaN
             })
         } : s => {
             const a = s.datum.bounds;
             return [a.x1, (a.x1 + a.x2) / 2, a.x2, a.y1, (a.y1 + a.y2) / 2, a.y2]
         } : r
     }
-    const A2 = ["x", "y", "opacity", "align", "baseline"],
-        U4 = ["top-left", "left", "bottom-left", "top", "bottom", "top-right", "right", "bottom-right"];
+    const ix = ["x", "y", "opacity", "align", "baseline"],
+        EL = ["top-left", "left", "bottom-left", "top", "bottom", "top-right", "right", "bottom-right"];
 
-    function OS(e) {
-        L.call(this, null, e)
+    function bE(e) {
+        j.call(this, null, e)
     }
-    OS.Definition = {
+    bE.Definition = {
         type: "Label",
         metadata: {
             modifies: !0
         },
         params: [{
             name: "size",
             type: "number",
@@ -28828,15 +21204,15 @@
         }, {
             name: "sort",
             type: "compare"
         }, {
             name: "anchor",
             type: "string",
             array: !0,
-            default: U4
+            default: EL
         }, {
             name: "offset",
             type: "number",
             array: !0,
             default: [1]
         }, {
             name: "padding",
@@ -28864,57 +21240,57 @@
             name: "method",
             type: "string",
             default: "naive"
         }, {
             name: "as",
             type: "string",
             array: !0,
-            length: A2.length,
-            default: A2
+            length: ix.length,
+            default: ix
         }]
     };
-    ee(OS, L, {
+    ne(bE, j, {
         transform(e, t) {
             function n(s) {
                 const a = e[s];
-                return $e(a) && t.modified(a.fields)
+                return Pe(a) && t.modified(a.fields)
             }
             const i = e.modified();
             if (!(i || t.changed(t.ADD_REM) || n("sort"))) return;
-            (!e.size || e.size.length !== 2) && U("Size parameter should be specified as a [width, height] array.");
-            const r = e.as || A2;
-            return Wte(t.materialize(t.SOURCE).source || [], e.size, e.sort, se(e.offset == null ? 1 : e.offset), se(e.anchor || U4), e.avoidMarks || [], e.avoidBaseMark !== !1, e.lineAnchor || "end", e.markIndex || 0, e.padding === void 0 ? 0 : e.padding, e.method || "naive").forEach(s => {
+            (!e.size || e.size.length !== 2) && q("Size parameter should be specified as a [width, height] array.");
+            const r = e.as || ix;
+            return jee(t.materialize(t.SOURCE).source || [], e.size, e.sort, ue(e.offset == null ? 1 : e.offset), ue(e.anchor || EL), e.avoidMarks || [], e.avoidBaseMark !== !1, e.lineAnchor || "end", e.markIndex || 0, e.padding === void 0 ? 0 : e.padding, e.method || "naive").forEach(s => {
                 const a = s.datum;
                 a[r[0]] = s.x, a[r[1]] = s.y, a[r[2]] = s.opacity, a[r[3]] = s.align, a[r[4]] = s.baseline
             }), t.reflow(i).modifies(r)
         }
     });
-    const Vte = Object.freeze(Object.defineProperty({
+    const Hee = Object.freeze(Object.defineProperty({
         __proto__: null,
-        label: OS
+        label: bE
     }, Symbol.toStringTag, {
         value: "Module"
     }));
 
-    function G4(e, t) {
+    function kL(e, t) {
         var n = [],
             i = function(c) {
                 return c(o)
             },
             r, s, a, o, l, u;
         if (t == null) n.push(e);
         else
             for (r = {}, s = 0, a = e.length; s < a; ++s) o = e[s], l = t.map(i), u = r[l], u || (r[l] = u = [], u.dims = l, n.push(u)), u.push(o);
         return n
     }
 
-    function FS(e) {
-        L.call(this, null, e)
+    function xE(e) {
+        j.call(this, null, e)
     }
-    FS.Definition = {
+    xE.Definition = {
         type: "Loess",
         metadata: {
             generates: !0
         },
         params: [{
             name: "x",
             type: "field",
@@ -28933,50 +21309,50 @@
             default: .3
         }, {
             name: "as",
             type: "string",
             array: !0
         }]
     };
-    ee(FS, L, {
+    ne(xE, j, {
         transform(e, t) {
             const n = t.fork(t.NO_SOURCE | t.NO_FIELDS);
             if (!this.value || t.changed() || e.modified()) {
                 const i = t.materialize(t.SOURCE).source,
-                    r = G4(i, e.groupby),
-                    s = (e.groupby || []).map(bt),
+                    r = kL(i, e.groupby),
+                    s = (e.groupby || []).map(Pt),
                     a = s.length,
-                    o = e.as || [bt(e.x), bt(e.y)],
+                    o = e.as || [Pt(e.x), Pt(e.y)],
                     l = [];
                 r.forEach(u => {
-                    lN(u, e.x, e.y, e.bandwidth || .3).forEach(c => {
+                    zR(u, e.x, e.y, e.bandwidth || .3).forEach(c => {
                         const f = {};
                         for (let h = 0; h < a; ++h) f[s[h]] = u.dims[h];
-                        f[o[0]] = c[0], f[o[1]] = c[1], l.push(He(f))
+                        f[o[0]] = c[0], f[o[1]] = c[1], l.push(it(f))
                     })
                 }), this.value && (n.rem = this.value), this.value = n.add = n.source = l
             }
             return n
         }
     });
-    const $2 = {
-            constant: j_,
-            linear: U_,
-            log: rN,
-            exp: sN,
-            pow: aN,
-            quad: G_,
-            poly: oN
+    const rx = {
+            constant: Z_,
+            linear: ew,
+            log: NR,
+            exp: PR,
+            pow: LR,
+            quad: tw,
+            poly: IR
         },
-        Kte = (e, t) => e === "poly" ? t : e === "quad" ? 2 : 1;
+        Yee = (e, t) => e === "poly" ? t : e === "quad" ? 2 : 1;
 
-    function RS(e) {
-        L.call(this, null, e)
+    function _E(e) {
+        j.call(this, null, e)
     }
-    RS.Definition = {
+    _E.Definition = {
         type: "Regression",
         metadata: {
             generates: !0
         },
         params: [{
             name: "x",
             type: "field",
@@ -28989,15 +21365,15 @@
             name: "groupby",
             type: "field",
             array: !0
         }, {
             name: "method",
             type: "string",
             default: "linear",
-            values: Object.keys($2)
+            values: Object.keys(rx)
         }, {
             name: "order",
             type: "number",
             default: 3
         }, {
             name: "extent",
             type: "number",
@@ -29009,448 +21385,1309 @@
             default: !1
         }, {
             name: "as",
             type: "string",
             array: !0
         }]
     };
-    ee(RS, L, {
+    ne(_E, j, {
         transform(e, t) {
             const n = t.fork(t.NO_SOURCE | t.NO_FIELDS);
             if (!this.value || t.changed() || e.modified()) {
                 const i = t.materialize(t.SOURCE).source,
-                    r = G4(i, e.groupby),
-                    s = (e.groupby || []).map(bt),
+                    r = kL(i, e.groupby),
+                    s = (e.groupby || []).map(Pt),
                     a = e.method || "linear",
                     o = e.order == null ? 3 : e.order,
-                    l = Kte(a, o),
-                    u = e.as || [bt(e.x), bt(e.y)],
-                    c = $2[a],
+                    l = Yee(a, o),
+                    u = e.as || [Pt(e.x), Pt(e.y)],
+                    c = rx[a],
                     f = [];
                 let h = e.extent;
-                me($2, a) || U("Invalid regression method: " + a), h != null && a === "log" && h[0] <= 0 && (t.dataflow.warn("Ignoring extent with values <= 0 for log regression."), h = null), r.forEach(d => {
+                Ce(rx, a) || q("Invalid regression method: " + a), h != null && a === "log" && h[0] <= 0 && (t.dataflow.warn("Ignoring extent with values <= 0 for log regression."), h = null), r.forEach(d => {
                     if (d.length <= l) {
                         t.dataflow.warn("Skipping regression with more parameters than data points.");
                         return
                     }
                     const p = c(d, e.x, e.y, o);
                     if (e.params) {
-                        f.push(He({
+                        f.push(it({
                             keys: d.dims,
                             coef: p.coef,
                             rSquared: p.rSquared
                         }));
                         return
                     }
-                    const m = h || Hr(d, e.x),
+                    const m = h || ss(d, e.x),
                         y = v => {
                             const b = {};
                             for (let x = 0; x < s.length; ++x) b[s[x]] = d.dims[x];
-                            b[u[0]] = v[0], b[u[1]] = v[1], f.push(He(b))
+                            b[u[0]] = v[0], b[u[1]] = v[1], f.push(it(b))
                         };
-                    a === "linear" || a === "constant" ? m.forEach(v => y([v, p.predict(v)])) : Bm(p.predict, m, 25, 200).forEach(y)
+                    a === "linear" || a === "constant" ? m.forEach(v => y([v, p.predict(v)])) : n1(p.predict, m, 25, 200).forEach(y)
                 }), this.value && (n.rem = this.value), this.value = n.add = n.source = f
             }
             return n
         }
     });
-    const Jte = Object.freeze(Object.defineProperty({
-        __proto__: null,
-        loess: FS,
-        regression: RS
-    }, Symbol.toStringTag, {
-        value: "Module"
-    }));
+    const Xee = Object.freeze(Object.defineProperty({
+            __proto__: null,
+            loess: xE,
+            regression: _E
+        }, Symbol.toStringTag, {
+            value: "Module"
+        })),
+        Xs = 11102230246251565e-32,
+        En = 134217729,
+        Vee = (3 + 8 * Xs) * Xs;
 
-    function DS(e) {
-        L.call(this, null, e)
+    function Bv(e, t, n, i, r) {
+        let s, a, o, l, u = t[0],
+            c = i[0],
+            f = 0,
+            h = 0;
+        c > u == c > -u ? (s = u, u = t[++f]) : (s = c, c = i[++h]);
+        let d = 0;
+        if (f < e && h < n)
+            for (c > u == c > -u ? (a = u + s, o = s - (a - u), u = t[++f]) : (a = c + s, o = s - (a - c), c = i[++h]), s = a, o !== 0 && (r[d++] = o); f < e && h < n;) c > u == c > -u ? (a = s + u, l = a - s, o = s - (a - l) + (u - l), u = t[++f]) : (a = s + c, l = a - s, o = s - (a - l) + (c - l), c = i[++h]), s = a, o !== 0 && (r[d++] = o);
+        for (; f < e;) a = s + u, l = a - s, o = s - (a - l) + (u - l), u = t[++f], s = a, o !== 0 && (r[d++] = o);
+        for (; h < n;) a = s + c, l = a - s, o = s - (a - l) + (c - l), c = i[++h], s = a, o !== 0 && (r[d++] = o);
+        return (s !== 0 || d === 0) && (r[d++] = s), d
     }
-    DS.Definition = {
-        type: "Voronoi",
-        metadata: {
-            modifies: !0
-        },
-        params: [{
-            name: "x",
-            type: "field",
-            required: !0
-        }, {
-            name: "y",
-            type: "field",
-            required: !0
-        }, {
-            name: "size",
-            type: "number",
-            array: !0,
-            length: 2
-        }, {
-            name: "extent",
-            type: "array",
-            array: !0,
-            length: 2,
-            default: [
-                [-1e5, -1e5],
-                [1e5, 1e5]
-            ],
-            content: {
-                type: "number",
-                array: !0,
-                length: 2
-            }
-        }, {
-            name: "as",
-            type: "string",
-            default: "path"
-        }]
-    };
-    const Qte = [-1e5, -1e5, 1e5, 1e5];
-    ee(DS, L, {
-        transform(e, t) {
-            const n = e.as || "path",
-                i = t.source;
-            if (!i || !i.length) return t;
-            let r = e.size;
-            r = r ? [0, 0, r[0], r[1]] : (r = e.extent) ? [r[0][0], r[0][1], r[1][0], r[1][1]] : Qte;
-            const s = this.value = $x.from(i, e.x, e.y).voronoi(r);
-            for (let a = 0, o = i.length; a < o; ++a) {
-                const l = s.cellPolygon(a);
-                i[a][n] = l ? Zte(l) : null
-            }
-            return t.reflow(e.modified()).modifies(n)
-        }
-    });
 
-    function Zte(e) {
-        const t = e[0][0],
-            n = e[0][1];
-        let i = e.length - 1;
-        for (; e[i][0] === t && e[i][1] === n; --i);
-        return "M" + e.slice(0, i + 1).join("L") + "Z"
+    function Kee(e, t) {
+        let n = t[0];
+        for (let i = 1; i < e; i++) n += t[i];
+        return n
     }
-    const ene = Object.freeze(Object.defineProperty({
-        __proto__: null,
-        voronoi: DS
-    }, Symbol.toStringTag, {
-        value: "Module"
-    }));
-    var dv = Math.PI / 180,
-        jf = 64,
-        op = 2048;
 
-    function tne() {
-        var e = [256, 256],
-            t, n, i, r, s, a, o, l = W4,
-            u = [],
-            c = Math.random,
-            f = {};
-        f.layout = function() {
-            for (var g = h(ka()), p = one((e[0] >> 5) * e[1]), m = null, y = u.length, v = -1, b = [], x = u.map(S => ({
-                    text: t(S),
-                    font: n(S),
-                    style: r(S),
-                    weight: s(S),
-                    rotate: a(S),
-                    size: ~~(i(S) + 1e-14),
-                    padding: o(S),
-                    xoff: 0,
-                    yoff: 0,
-                    x1: 0,
-                    y1: 0,
-                    x0: 0,
-                    y0: 0,
-                    hasText: !1,
-                    sprite: null,
-                    datum: S
-                })).sort((S, w) => w.size - S.size); ++v < y;) {
-                var _ = x[v];
-                _.x = e[0] * (c() + .5) >> 1, _.y = e[1] * (c() + .5) >> 1, nne(g, _, x, v), _.hasText && d(p, _, m) && (b.push(_), m ? rne(m, _) : m = [{
-                    x: _.x + _.x0,
-                    y: _.y + _.y0
-                }, {
-                    x: _.x + _.x1,
-                    y: _.y + _.y1
-                }], _.x -= e[0] >> 1, _.y -= e[1] >> 1)
-            }
-            return b
-        };
+    function Kd(e) {
+        return new Float64Array(e)
+    }
+    const Jee = (3 + 16 * Xs) * Xs,
+        Qee = (2 + 12 * Xs) * Xs,
+        Zee = (9 + 64 * Xs) * Xs * Xs,
+        _u = Kd(4),
+        HT = Kd(8),
+        YT = Kd(12),
+        XT = Kd(16),
+        zn = Kd(4);
 
-        function h(g) {
-            g.width = g.height = 1;
-            var p = Math.sqrt(g.getContext("2d").getImageData(0, 0, 1, 1).data.length >> 2);
-            g.width = (jf << 5) / p, g.height = op / p;
-            var m = g.getContext("2d");
-            return m.fillStyle = m.strokeStyle = "red", m.textAlign = "center", {
-                context: m,
-                ratio: p
+    function ete(e, t, n, i, r, s, a) {
+        let o, l, u, c, f, h, d, g, p, m, y, v, b, x, _, S, w, E;
+        const C = e - r,
+            k = n - r,
+            A = t - s,
+            F = i - s;
+        x = C * F, h = En * C, d = h - (h - C), g = C - d, h = En * F, p = h - (h - F), m = F - p, _ = g * m - (x - d * p - g * p - d * m), S = A * k, h = En * A, d = h - (h - A), g = A - d, h = En * k, p = h - (h - k), m = k - p, w = g * m - (S - d * p - g * p - d * m), y = _ - w, f = _ - y, _u[0] = _ - (y + f) + (f - w), v = x + y, f = v - x, b = x - (v - f) + (y - f), y = b - S, f = b - y, _u[1] = b - (y + f) + (f - S), E = v + y, f = E - v, _u[2] = v - (E - f) + (y - f), _u[3] = E;
+        let $ = Kee(4, _u),
+            T = Qee * a;
+        if ($ >= T || -$ >= T || (f = e - C, o = e - (C + f) + (f - r), f = n - k, u = n - (k + f) + (f - r), f = t - A, l = t - (A + f) + (f - s), f = i - F, c = i - (F + f) + (f - s), o === 0 && l === 0 && u === 0 && c === 0) || (T = Zee * a + Vee * Math.abs($), $ += C * c + F * o - (A * u + k * l), $ >= T || -$ >= T)) return $;
+        x = o * F, h = En * o, d = h - (h - o), g = o - d, h = En * F, p = h - (h - F), m = F - p, _ = g * m - (x - d * p - g * p - d * m), S = l * k, h = En * l, d = h - (h - l), g = l - d, h = En * k, p = h - (h - k), m = k - p, w = g * m - (S - d * p - g * p - d * m), y = _ - w, f = _ - y, zn[0] = _ - (y + f) + (f - w), v = x + y, f = v - x, b = x - (v - f) + (y - f), y = b - S, f = b - y, zn[1] = b - (y + f) + (f - S), E = v + y, f = E - v, zn[2] = v - (E - f) + (y - f), zn[3] = E;
+        const M = Bv(4, _u, 4, zn, HT);
+        x = C * c, h = En * C, d = h - (h - C), g = C - d, h = En * c, p = h - (h - c), m = c - p, _ = g * m - (x - d * p - g * p - d * m), S = A * u, h = En * A, d = h - (h - A), g = A - d, h = En * u, p = h - (h - u), m = u - p, w = g * m - (S - d * p - g * p - d * m), y = _ - w, f = _ - y, zn[0] = _ - (y + f) + (f - w), v = x + y, f = v - x, b = x - (v - f) + (y - f), y = b - S, f = b - y, zn[1] = b - (y + f) + (f - S), E = v + y, f = E - v, zn[2] = v - (E - f) + (y - f), zn[3] = E;
+        const R = Bv(M, HT, 4, zn, YT);
+        x = o * c, h = En * o, d = h - (h - o), g = o - d, h = En * c, p = h - (h - c), m = c - p, _ = g * m - (x - d * p - g * p - d * m), S = l * u, h = En * l, d = h - (h - l), g = l - d, h = En * u, p = h - (h - u), m = u - p, w = g * m - (S - d * p - g * p - d * m), y = _ - w, f = _ - y, zn[0] = _ - (y + f) + (f - w), v = x + y, f = v - x, b = x - (v - f) + (y - f), y = b - S, f = b - y, zn[1] = b - (y + f) + (f - S), E = v + y, f = E - v, zn[2] = v - (E - f) + (y - f), zn[3] = E;
+        const N = Bv(R, YT, 4, zn, XT);
+        return XT[N - 1]
+    }
+
+    function jg(e, t, n, i, r, s) {
+        const a = (t - s) * (n - r),
+            o = (e - r) * (i - s),
+            l = a - o,
+            u = Math.abs(a + o);
+        return Math.abs(l) >= Jee * u ? l : -ete(e, t, n, i, r, s, u)
+    }
+    const VT = Math.pow(2, -52),
+        Gg = new Uint32Array(512);
+    class l0 {
+        static from(t, n = ste, i = ate) {
+            const r = t.length,
+                s = new Float64Array(r * 2);
+            for (let a = 0; a < r; a++) {
+                const o = t[a];
+                s[2 * a] = n(o), s[2 * a + 1] = i(o)
             }
+            return new l0(s)
         }
-
-        function d(g, p, m) {
-            for (var y = p.x, v = p.y, b = Math.sqrt(e[0] * e[0] + e[1] * e[1]), x = l(e), _ = c() < .5 ? 1 : -1, S = -_, w, E, A;
-                (w = x(S += _)) && (E = ~~w[0], A = ~~w[1], !(Math.min(Math.abs(E), Math.abs(A)) >= b));)
-                if (p.x = y + E, p.y = v + A, !(p.x + p.x0 < 0 || p.y + p.y0 < 0 || p.x + p.x1 > e[0] || p.y + p.y1 > e[1]) && (!m || !ine(p, g, e[0])) && (!m || sne(p, m))) {
-                    for (var C = p.sprite, k = p.width >> 5, R = e[0] >> 5, $ = p.x - (k << 4), T = $ & 127, M = 32 - T, F = p.y1 - p.y0, N = (p.y + p.y0) * R + ($ >> 5), P, z = 0; z < F; z++) {
-                        P = 0;
-                        for (var I = 0; I <= k; I++) g[N + I] |= P << M | (I < k ? (P = C[z * k + I]) >>> T : 0);
-                        N += R
-                    }
-                    return p.sprite = null, !0
-                } return !1
+        constructor(t) {
+            const n = t.length >> 1;
+            if (n > 0 && typeof t[0] != "number") throw new Error("Expected coords to contain numbers.");
+            this.coords = t;
+            const i = Math.max(2 * n - 5, 0);
+            this._triangles = new Uint32Array(i * 3), this._halfedges = new Int32Array(i * 3), this._hashSize = Math.ceil(Math.sqrt(n)), this._hullPrev = new Uint32Array(n), this._hullNext = new Uint32Array(n), this._hullTri = new Uint32Array(n), this._hullHash = new Int32Array(this._hashSize).fill(-1), this._ids = new Uint32Array(n), this._dists = new Float64Array(n), this.update()
         }
-        return f.words = function(g) {
-            return arguments.length ? (u = g, f) : u
-        }, f.size = function(g) {
-            return arguments.length ? (e = [+g[0], +g[1]], f) : e
-        }, f.font = function(g) {
-            return arguments.length ? (n = go(g), f) : n
-        }, f.fontStyle = function(g) {
-            return arguments.length ? (r = go(g), f) : r
-        }, f.fontWeight = function(g) {
-            return arguments.length ? (s = go(g), f) : s
-        }, f.rotate = function(g) {
-            return arguments.length ? (a = go(g), f) : a
-        }, f.text = function(g) {
-            return arguments.length ? (t = go(g), f) : t
-        }, f.spiral = function(g) {
-            return arguments.length ? (l = lne[g] || g, f) : l
-        }, f.fontSize = function(g) {
-            return arguments.length ? (i = go(g), f) : i
-        }, f.padding = function(g) {
-            return arguments.length ? (o = go(g), f) : o
-        }, f.random = function(g) {
-            return arguments.length ? (c = g, f) : c
-        }, f
-    }
-
-    function nne(e, t, n, i) {
-        if (!t.sprite) {
-            var r = e.context,
-                s = e.ratio;
-            r.clearRect(0, 0, (jf << 5) / s, op / s);
-            var a = 0,
-                o = 0,
-                l = 0,
-                u = n.length,
-                c, f, h, d, g;
-            for (--i; ++i < u;) {
-                if (t = n[i], r.save(), r.font = t.style + " " + t.weight + " " + ~~((t.size + 1) / s) + "px " + t.font, c = r.measureText(t.text + "m").width * s, h = t.size << 1, t.rotate) {
-                    var p = Math.sin(t.rotate * dv),
-                        m = Math.cos(t.rotate * dv),
-                        y = c * m,
-                        v = c * p,
-                        b = h * m,
-                        x = h * p;
-                    c = Math.max(Math.abs(y + x), Math.abs(y - x)) + 31 >> 5 << 5, h = ~~Math.max(Math.abs(v + b), Math.abs(v - b))
-                } else c = c + 31 >> 5 << 5;
-                if (h > l && (l = h), a + c >= jf << 5 && (a = 0, o += l, l = 0), o + h >= op) break;
-                r.translate((a + (c >> 1)) / s, (o + (h >> 1)) / s), t.rotate && r.rotate(t.rotate * dv), r.fillText(t.text, 0, 0), t.padding && (r.lineWidth = 2 * t.padding, r.strokeText(t.text, 0, 0)), r.restore(), t.width = c, t.height = h, t.xoff = a, t.yoff = o, t.x1 = c >> 1, t.y1 = h >> 1, t.x0 = -t.x1, t.y0 = -t.y1, t.hasText = !0, a += c
+        update() {
+            const {
+                coords: t,
+                _hullPrev: n,
+                _hullNext: i,
+                _hullTri: r,
+                _hullHash: s
+            } = this, a = t.length >> 1;
+            let o = 1 / 0,
+                l = 1 / 0,
+                u = -1 / 0,
+                c = -1 / 0;
+            for (let k = 0; k < a; k++) {
+                const A = t[2 * k],
+                    F = t[2 * k + 1];
+                A < o && (o = A), F < l && (l = F), A > u && (u = A), F > c && (c = F), this._ids[k] = k
             }
-            for (var _ = r.getImageData(0, 0, (jf << 5) / s, op / s).data, S = []; --i >= 0;)
-                if (t = n[i], !!t.hasText) {
-                    for (c = t.width, f = c >> 5, h = t.y1 - t.y0, d = 0; d < h * f; d++) S[d] = 0;
-                    if (a = t.xoff, a == null) return;
-                    o = t.yoff;
-                    var w = 0,
-                        E = -1;
-                    for (g = 0; g < h; g++) {
-                        for (d = 0; d < c; d++) {
-                            var A = f * g + (d >> 5),
-                                C = _[(o + g) * (jf << 5) + (a + d) << 2] ? 1 << 31 - d % 32 : 0;
-                            S[A] |= C, w |= C
-                        }
-                        w ? E = g : (t.y0++, h--, g--, o++)
+            const f = (o + u) / 2,
+                h = (l + c) / 2;
+            let d = 1 / 0,
+                g, p, m;
+            for (let k = 0; k < a; k++) {
+                const A = jv(f, h, t[2 * k], t[2 * k + 1]);
+                A < d && (g = k, d = A)
+            }
+            const y = t[2 * g],
+                v = t[2 * g + 1];
+            d = 1 / 0;
+            for (let k = 0; k < a; k++) {
+                if (k === g) continue;
+                const A = jv(y, v, t[2 * k], t[2 * k + 1]);
+                A < d && A > 0 && (p = k, d = A)
+            }
+            let b = t[2 * p],
+                x = t[2 * p + 1],
+                _ = 1 / 0;
+            for (let k = 0; k < a; k++) {
+                if (k === g || k === p) continue;
+                const A = ite(y, v, b, x, t[2 * k], t[2 * k + 1]);
+                A < _ && (m = k, _ = A)
+            }
+            let S = t[2 * m],
+                w = t[2 * m + 1];
+            if (_ === 1 / 0) {
+                for (let F = 0; F < a; F++) this._dists[F] = t[2 * F] - t[0] || t[2 * F + 1] - t[1];
+                Bu(this._ids, this._dists, 0, a - 1);
+                const k = new Uint32Array(a);
+                let A = 0;
+                for (let F = 0, $ = -1 / 0; F < a; F++) {
+                    const T = this._ids[F];
+                    this._dists[T] > $ && (k[A++] = T, $ = this._dists[T])
+                }
+                this.hull = k.subarray(0, A), this.triangles = new Uint32Array(0), this.halfedges = new Uint32Array(0);
+                return
+            }
+            if (jg(y, v, b, x, S, w) < 0) {
+                const k = p,
+                    A = b,
+                    F = x;
+                p = m, b = S, x = w, m = k, S = A, w = F
+            }
+            const E = rte(y, v, b, x, S, w);
+            this._cx = E.x, this._cy = E.y;
+            for (let k = 0; k < a; k++) this._dists[k] = jv(t[2 * k], t[2 * k + 1], E.x, E.y);
+            Bu(this._ids, this._dists, 0, a - 1), this._hullStart = g;
+            let C = 3;
+            i[g] = n[m] = p, i[p] = n[g] = m, i[m] = n[p] = g, r[g] = 0, r[p] = 1, r[m] = 2, s.fill(-1), s[this._hashKey(y, v)] = g, s[this._hashKey(b, x)] = p, s[this._hashKey(S, w)] = m, this.trianglesLen = 0, this._addTriangle(g, p, m, -1, -1, -1);
+            for (let k = 0, A, F; k < this._ids.length; k++) {
+                const $ = this._ids[k],
+                    T = t[2 * $],
+                    M = t[2 * $ + 1];
+                if (k > 0 && Math.abs(T - A) <= VT && Math.abs(M - F) <= VT || (A = T, F = M, $ === g || $ === p || $ === m)) continue;
+                let R = 0;
+                for (let ie = 0, ge = this._hashKey(T, M); ie < this._hashSize && (R = s[(ge + ie) % this._hashSize], !(R !== -1 && R !== i[R])); ie++);
+                R = n[R];
+                let N = R,
+                    L;
+                for (; L = i[N], jg(T, M, t[2 * N], t[2 * N + 1], t[2 * L], t[2 * L + 1]) >= 0;)
+                    if (N = L, N === R) {
+                        N = -1;
+                        break
+                    } if (N === -1) continue;
+                let I = this._addTriangle(N, $, i[N], -1, -1, r[N]);
+                r[$] = this._legalize(I + 2), r[N] = I, C++;
+                let G = i[N];
+                for (; L = i[G], jg(T, M, t[2 * G], t[2 * G + 1], t[2 * L], t[2 * L + 1]) < 0;) I = this._addTriangle(G, $, L, r[$], -1, r[G]), r[$] = this._legalize(I + 2), i[G] = G, C--, G = L;
+                if (N === R)
+                    for (; L = n[N], jg(T, M, t[2 * L], t[2 * L + 1], t[2 * N], t[2 * N + 1]) < 0;) I = this._addTriangle(L, $, N, -1, r[N], r[L]), this._legalize(I + 2), r[L] = I, i[N] = N, C--, N = L;
+                this._hullStart = n[$] = N, i[N] = n[G] = $, i[$] = G, s[this._hashKey(T, M)] = $, s[this._hashKey(t[2 * N], t[2 * N + 1])] = N
+            }
+            this.hull = new Uint32Array(C);
+            for (let k = 0, A = this._hullStart; k < C; k++) this.hull[k] = A, A = i[A];
+            this.triangles = this._triangles.subarray(0, this.trianglesLen), this.halfedges = this._halfedges.subarray(0, this.trianglesLen)
+        }
+        _hashKey(t, n) {
+            return Math.floor(tte(t - this._cx, n - this._cy) * this._hashSize) % this._hashSize
+        }
+        _legalize(t) {
+            const {
+                _triangles: n,
+                _halfedges: i,
+                coords: r
+            } = this;
+            let s = 0,
+                a = 0;
+            for (;;) {
+                const o = i[t],
+                    l = t - t % 3;
+                if (a = l + (t + 2) % 3, o === -1) {
+                    if (s === 0) break;
+                    t = Gg[--s];
+                    continue
+                }
+                const u = o - o % 3,
+                    c = l + (t + 1) % 3,
+                    f = u + (o + 2) % 3,
+                    h = n[a],
+                    d = n[t],
+                    g = n[c],
+                    p = n[f];
+                if (nte(r[2 * h], r[2 * h + 1], r[2 * d], r[2 * d + 1], r[2 * g], r[2 * g + 1], r[2 * p], r[2 * p + 1])) {
+                    n[t] = p, n[o] = h;
+                    const y = i[f];
+                    if (y === -1) {
+                        let b = this._hullStart;
+                        do {
+                            if (this._hullTri[b] === f) {
+                                this._hullTri[b] = t;
+                                break
+                            }
+                            b = this._hullPrev[b]
+                        } while (b !== this._hullStart)
                     }
-                    t.y1 = t.y0 + E, t.sprite = S.slice(0, (t.y1 - t.y0) * f)
+                    this._link(t, y), this._link(o, i[a]), this._link(a, f);
+                    const v = u + (o + 1) % 3;
+                    s < Gg.length && (Gg[s++] = v)
+                } else {
+                    if (s === 0) break;
+                    t = Gg[--s]
                 }
+            }
+            return a
+        }
+        _link(t, n) {
+            this._halfedges[t] = n, n !== -1 && (this._halfedges[n] = t)
+        }
+        _addTriangle(t, n, i, r, s, a) {
+            const o = this.trianglesLen;
+            return this._triangles[o] = t, this._triangles[o + 1] = n, this._triangles[o + 2] = i, this._link(o, r), this._link(o + 1, s), this._link(o + 2, a), this.trianglesLen += 3, o
         }
     }
 
-    function ine(e, t, n) {
-        n >>= 5;
-        for (var i = e.sprite, r = e.width >> 5, s = e.x - (r << 4), a = s & 127, o = 32 - a, l = e.y1 - e.y0, u = (e.y + e.y0) * n + (s >> 5), c, f = 0; f < l; f++) {
-            c = 0;
-            for (var h = 0; h <= r; h++)
-                if ((c << o | (h < r ? (c = i[f * r + h]) >>> a : 0)) & t[u + h]) return !0;
-            u += n
-        }
-        return !1
+    function tte(e, t) {
+        const n = e / (Math.abs(e) + Math.abs(t));
+        return (t > 0 ? 3 - n : 1 + n) / 4
     }
 
-    function rne(e, t) {
-        var n = e[0],
-            i = e[1];
-        t.x + t.x0 < n.x && (n.x = t.x + t.x0), t.y + t.y0 < n.y && (n.y = t.y + t.y0), t.x + t.x1 > i.x && (i.x = t.x + t.x1), t.y + t.y1 > i.y && (i.y = t.y + t.y1)
+    function jv(e, t, n, i) {
+        const r = e - n,
+            s = t - i;
+        return r * r + s * s
     }
 
-    function sne(e, t) {
-        return e.x + e.x1 > t[0].x && e.x + e.x0 < t[1].x && e.y + e.y1 > t[0].y && e.y + e.y0 < t[1].y
+    function nte(e, t, n, i, r, s, a, o) {
+        const l = e - a,
+            u = t - o,
+            c = n - a,
+            f = i - o,
+            h = r - a,
+            d = s - o,
+            g = l * l + u * u,
+            p = c * c + f * f,
+            m = h * h + d * d;
+        return l * (f * m - p * d) - u * (c * m - p * h) + g * (c * d - f * h) < 0
     }
 
-    function W4(e) {
-        var t = e[0] / e[1];
-        return function(n) {
-            return [t * (n *= .1) * Math.cos(n), n * Math.sin(n)]
-        }
+    function ite(e, t, n, i, r, s) {
+        const a = n - e,
+            o = i - t,
+            l = r - e,
+            u = s - t,
+            c = a * a + o * o,
+            f = l * l + u * u,
+            h = .5 / (a * u - o * l),
+            d = (u * c - o * f) * h,
+            g = (a * f - l * c) * h;
+        return d * d + g * g
     }
 
-    function ane(e) {
-        var t = 4,
-            n = t * e[0] / e[1],
-            i = 0,
-            r = 0;
-        return function(s) {
-            var a = s < 0 ? -1 : 1;
-            switch (Math.sqrt(1 + 4 * a * s) - a & 3) {
-                case 0:
-                    i += n;
-                    break;
-                case 1:
-                    r += t;
-                    break;
-                case 2:
-                    i -= n;
-                    break;
-                default:
-                    r -= t;
-                    break
-            }
-            return [i, r]
+    function rte(e, t, n, i, r, s) {
+        const a = n - e,
+            o = i - t,
+            l = r - e,
+            u = s - t,
+            c = a * a + o * o,
+            f = l * l + u * u,
+            h = .5 / (a * u - o * l),
+            d = e + (u * c - o * f) * h,
+            g = t + (a * f - l * c) * h;
+        return {
+            x: d,
+            y: g
         }
     }
 
-    function one(e) {
-        for (var t = [], n = -1; ++n < e;) t[n] = 0;
-        return t
+    function Bu(e, t, n, i) {
+        if (i - n <= 20)
+            for (let r = n + 1; r <= i; r++) {
+                const s = e[r],
+                    a = t[s];
+                let o = r - 1;
+                for (; o >= n && t[e[o]] > a;) e[o + 1] = e[o--];
+                e[o + 1] = s
+            } else {
+                const r = n + i >> 1;
+                let s = n + 1,
+                    a = i;
+                Mf(e, r, s), t[e[n]] > t[e[i]] && Mf(e, n, i), t[e[s]] > t[e[i]] && Mf(e, s, i), t[e[n]] > t[e[s]] && Mf(e, n, s);
+                const o = e[s],
+                    l = t[o];
+                for (;;) {
+                    do s++; while (t[e[s]] < l);
+                    do a--; while (t[e[a]] > l);
+                    if (a < s) break;
+                    Mf(e, s, a)
+                }
+                e[n + 1] = e[a], e[a] = o, i - s + 1 >= a - n ? (Bu(e, t, s, i), Bu(e, t, n, a - 1)) : (Bu(e, t, n, a - 1), Bu(e, t, s, i))
+            }
     }
 
-    function go(e) {
-        return typeof e == "function" ? e : function() {
-            return e
-        }
+    function Mf(e, t, n) {
+        const i = e[t];
+        e[t] = e[n], e[n] = i
     }
-    var lne = {
-        archimedean: W4,
-        rectangular: ane
-    };
-    const q4 = ["x", "y", "font", "fontSize", "fontStyle", "fontWeight", "angle"],
-        une = ["text", "font", "rotate", "fontSize", "fontStyle", "fontWeight"];
 
-    function NS(e) {
-        L.call(this, tne(), e)
+    function ste(e) {
+        return e[0]
     }
-    NS.Definition = {
-        type: "Wordcloud",
-        metadata: {
-            modifies: !0
-        },
-        params: [{
-            name: "size",
-            type: "number",
-            array: !0,
-            length: 2
-        }, {
-            name: "font",
-            type: "string",
-            expr: !0,
-            default: "sans-serif"
-        }, {
-            name: "fontStyle",
-            type: "string",
-            expr: !0,
-            default: "normal"
-        }, {
-            name: "fontWeight",
-            type: "string",
-            expr: !0,
-            default: "normal"
-        }, {
-            name: "fontSize",
-            type: "number",
-            expr: !0,
-            default: 14
-        }, {
-            name: "fontSizeRange",
-            type: "number",
-            array: "nullable",
-            default: [10, 50]
-        }, {
-            name: "rotate",
-            type: "number",
-            expr: !0,
-            default: 0
-        }, {
-            name: "text",
-            type: "field"
-        }, {
-            name: "spiral",
-            type: "string",
-            values: ["archimedean", "rectangular"]
-        }, {
-            name: "padding",
-            type: "number",
-            expr: !0
-        }, {
-            name: "as",
-            type: "string",
-            array: !0,
-            length: 7,
-            default: q4
-        }]
-    };
-    ee(NS, L, {
-        transform(e, t) {
-            e.size && !(e.size[0] && e.size[1]) && U("Wordcloud size dimensions must be non-zero.");
 
-            function n(g) {
-                const p = e[g];
-                return $e(p) && t.modified(p.fields)
-            }
-            const i = e.modified();
-            if (!(i || t.changed(t.ADD_REM) || une.some(n))) return;
-            const r = t.materialize(t.SOURCE).source,
-                s = this.value,
-                a = e.as || q4;
-            let o = e.fontSize || 14,
-                l;
-            if ($e(o) ? l = e.fontSizeRange : o = xn(o), l) {
-                const g = o,
-                    p = We("sqrt")().domain(Hr(r, g)).range(l);
-                o = m => p(g(m))
-            }
-            r.forEach(g => {
-                g[a[0]] = NaN, g[a[1]] = NaN, g[a[3]] = 0
-            });
-            const u = s.words(r).text(e.text).size(e.size || [500, 500]).padding(e.padding || 1).spiral(e.spiral || "archimedean").rotate(e.rotate || 0).font(e.font || "sans-serif").fontStyle(e.fontStyle || "normal").fontWeight(e.fontWeight || "normal").fontSize(o).random(Ni).layout(),
-                c = s.size(),
-                f = c[0] >> 1,
-                h = c[1] >> 1,
-                d = u.length;
-            for (let g = 0, p, m; g < d; ++g) p = u[g], m = p.datum, m[a[0]] = p.x + f, m[a[1]] = p.y + h, m[a[2]] = p.font, m[a[3]] = p.size, m[a[4]] = p.style, m[a[5]] = p.weight, m[a[6]] = p.rotate;
-            return t.reflow(i).modifies(a)
+    function ate(e) {
+        return e[1]
+    }
+    const KT = 1e-6;
+    let ol = class {
+        constructor() {
+            this._x0 = this._y0 = this._x1 = this._y1 = null, this._ = ""
         }
-    });
-    const cne = Object.freeze(Object.defineProperty({
-            __proto__: null,
-            wordcloud: NS
+        moveTo(t, n) {
+            this._ += `M${this._x0=this._x1=+t},${this._y0=this._y1=+n}`
+        }
+        closePath() {
+            this._x1 !== null && (this._x1 = this._x0, this._y1 = this._y0, this._ += "Z")
+        }
+        lineTo(t, n) {
+            this._ += `L${this._x1=+t},${this._y1=+n}`
+        }
+        arc(t, n, i) {
+            t = +t, n = +n, i = +i;
+            const r = t + i,
+                s = n;
+            if (i < 0) throw new Error("negative radius");
+            this._x1 === null ? this._ += `M${r},${s}` : (Math.abs(this._x1 - r) > KT || Math.abs(this._y1 - s) > KT) && (this._ += "L" + r + "," + s), i && (this._ += `A${i},${i},0,1,1,${t-i},${n}A${i},${i},0,1,1,${this._x1=r},${this._y1=s}`)
+        }
+        rect(t, n, i, r) {
+            this._ += `M${this._x0=this._x1=+t},${this._y0=this._y1=+n}h${+i}v${+r}h${-i}Z`
+        }
+        value() {
+            return this._ || null
+        }
+    };
+    class sx {
+        constructor() {
+            this._ = []
+        }
+        moveTo(t, n) {
+            this._.push([t, n])
+        }
+        closePath() {
+            this._.push(this._[0].slice())
+        }
+        lineTo(t, n) {
+            this._.push([t, n])
+        }
+        value() {
+            return this._.length ? this._ : null
+        }
+    }
+    let ote = class {
+        constructor(t, [n, i, r, s] = [0, 0, 960, 500]) {
+            if (!((r = +r) >= (n = +n)) || !((s = +s) >= (i = +i))) throw new Error("invalid bounds");
+            this.delaunay = t, this._circumcenters = new Float64Array(t.points.length * 2), this.vectors = new Float64Array(t.points.length * 2), this.xmax = r, this.xmin = n, this.ymax = s, this.ymin = i, this._init()
+        }
+        update() {
+            return this.delaunay.update(), this._init(), this
+        }
+        _init() {
+            const {
+                delaunay: {
+                    points: t,
+                    hull: n,
+                    triangles: i
+                },
+                vectors: r
+            } = this;
+            let s, a;
+            const o = this.circumcenters = this._circumcenters.subarray(0, i.length / 3 * 2);
+            for (let p = 0, m = 0, y = i.length, v, b; p < y; p += 3, m += 2) {
+                const x = i[p] * 2,
+                    _ = i[p + 1] * 2,
+                    S = i[p + 2] * 2,
+                    w = t[x],
+                    E = t[x + 1],
+                    C = t[_],
+                    k = t[_ + 1],
+                    A = t[S],
+                    F = t[S + 1],
+                    $ = C - w,
+                    T = k - E,
+                    M = A - w,
+                    R = F - E,
+                    N = ($ * R - T * M) * 2;
+                if (Math.abs(N) < 1e-9) {
+                    if (s === void 0) {
+                        s = a = 0;
+                        for (const I of n) s += t[I * 2], a += t[I * 2 + 1];
+                        s /= n.length, a /= n.length
+                    }
+                    const L = 1e9 * Math.sign((s - w) * R - (a - E) * M);
+                    v = (w + A) / 2 - L * R, b = (E + F) / 2 + L * M
+                } else {
+                    const L = 1 / N,
+                        I = $ * $ + T * T,
+                        G = M * M + R * R;
+                    v = w + (R * I - T * G) * L, b = E + ($ * G - M * I) * L
+                }
+                o[m] = v, o[m + 1] = b
+            }
+            let l = n[n.length - 1],
+                u, c = l * 4,
+                f, h = t[2 * l],
+                d, g = t[2 * l + 1];
+            r.fill(0);
+            for (let p = 0; p < n.length; ++p) l = n[p], u = c, f = h, d = g, c = l * 4, h = t[2 * l], g = t[2 * l + 1], r[u + 2] = r[c] = d - g, r[u + 3] = r[c + 1] = h - f
+        }
+        render(t) {
+            const n = t == null ? t = new ol : void 0,
+                {
+                    delaunay: {
+                        halfedges: i,
+                        inedges: r,
+                        hull: s
+                    },
+                    circumcenters: a,
+                    vectors: o
+                } = this;
+            if (s.length <= 1) return null;
+            for (let c = 0, f = i.length; c < f; ++c) {
+                const h = i[c];
+                if (h < c) continue;
+                const d = Math.floor(c / 3) * 2,
+                    g = Math.floor(h / 3) * 2,
+                    p = a[d],
+                    m = a[d + 1],
+                    y = a[g],
+                    v = a[g + 1];
+                this._renderSegment(p, m, y, v, t)
+            }
+            let l, u = s[s.length - 1];
+            for (let c = 0; c < s.length; ++c) {
+                l = u, u = s[c];
+                const f = Math.floor(r[u] / 3) * 2,
+                    h = a[f],
+                    d = a[f + 1],
+                    g = l * 4,
+                    p = this._project(h, d, o[g + 2], o[g + 3]);
+                p && this._renderSegment(h, d, p[0], p[1], t)
+            }
+            return n && n.value()
+        }
+        renderBounds(t) {
+            const n = t == null ? t = new ol : void 0;
+            return t.rect(this.xmin, this.ymin, this.xmax - this.xmin, this.ymax - this.ymin), n && n.value()
+        }
+        renderCell(t, n) {
+            const i = n == null ? n = new ol : void 0,
+                r = this._clip(t);
+            if (r === null || !r.length) return;
+            n.moveTo(r[0], r[1]);
+            let s = r.length;
+            for (; r[0] === r[s - 2] && r[1] === r[s - 1] && s > 1;) s -= 2;
+            for (let a = 2; a < s; a += 2)(r[a] !== r[a - 2] || r[a + 1] !== r[a - 1]) && n.lineTo(r[a], r[a + 1]);
+            return n.closePath(), i && i.value()
+        }* cellPolygons() {
+            const {
+                delaunay: {
+                    points: t
+                }
+            } = this;
+            for (let n = 0, i = t.length / 2; n < i; ++n) {
+                const r = this.cellPolygon(n);
+                r && (r.index = n, yield r)
+            }
+        }
+        cellPolygon(t) {
+            const n = new sx;
+            return this.renderCell(t, n), n.value()
+        }
+        _renderSegment(t, n, i, r, s) {
+            let a;
+            const o = this._regioncode(t, n),
+                l = this._regioncode(i, r);
+            o === 0 && l === 0 ? (s.moveTo(t, n), s.lineTo(i, r)) : (a = this._clipSegment(t, n, i, r, o, l)) && (s.moveTo(a[0], a[1]), s.lineTo(a[2], a[3]))
+        }
+        contains(t, n, i) {
+            return n = +n, n !== n || (i = +i, i !== i) ? !1 : this.delaunay._step(t, n, i) === t
+        }* neighbors(t) {
+            const n = this._clip(t);
+            if (n)
+                for (const i of this.delaunay.neighbors(t)) {
+                    const r = this._clip(i);
+                    if (r) {
+                        e: for (let s = 0, a = n.length; s < a; s += 2)
+                            for (let o = 0, l = r.length; o < l; o += 2)
+                                if (n[s] === r[o] && n[s + 1] === r[o + 1] && n[(s + 2) % a] === r[(o + l - 2) % l] && n[(s + 3) % a] === r[(o + l - 1) % l]) {
+                                    yield i;
+                                    break e
+                                }
+                    }
+                }
+        }
+        _cell(t) {
+            const {
+                circumcenters: n,
+                delaunay: {
+                    inedges: i,
+                    halfedges: r,
+                    triangles: s
+                }
+            } = this, a = i[t];
+            if (a === -1) return null;
+            const o = [];
+            let l = a;
+            do {
+                const u = Math.floor(l / 3);
+                if (o.push(n[u * 2], n[u * 2 + 1]), l = l % 3 === 2 ? l - 2 : l + 1, s[l] !== t) break;
+                l = r[l]
+            } while (l !== a && l !== -1);
+            return o
+        }
+        _clip(t) {
+            if (t === 0 && this.delaunay.hull.length === 1) return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
+            const n = this._cell(t);
+            if (n === null) return null;
+            const {
+                vectors: i
+            } = this, r = t * 4;
+            return this._simplify(i[r] || i[r + 1] ? this._clipInfinite(t, n, i[r], i[r + 1], i[r + 2], i[r + 3]) : this._clipFinite(t, n))
+        }
+        _clipFinite(t, n) {
+            const i = n.length;
+            let r = null,
+                s, a, o = n[i - 2],
+                l = n[i - 1],
+                u, c = this._regioncode(o, l),
+                f, h = 0;
+            for (let d = 0; d < i; d += 2)
+                if (s = o, a = l, o = n[d], l = n[d + 1], u = c, c = this._regioncode(o, l), u === 0 && c === 0) f = h, h = 0, r ? r.push(o, l) : r = [o, l];
+                else {
+                    let g, p, m, y, v;
+                    if (u === 0) {
+                        if ((g = this._clipSegment(s, a, o, l, u, c)) === null) continue;
+                        [p, m, y, v] = g
+                    } else {
+                        if ((g = this._clipSegment(o, l, s, a, c, u)) === null) continue;
+                        [y, v, p, m] = g, f = h, h = this._edgecode(p, m), f && h && this._edge(t, f, h, r, r.length), r ? r.push(p, m) : r = [p, m]
+                    }
+                    f = h, h = this._edgecode(y, v), f && h && this._edge(t, f, h, r, r.length), r ? r.push(y, v) : r = [y, v]
+                } if (r) f = h, h = this._edgecode(r[0], r[1]), f && h && this._edge(t, f, h, r, r.length);
+            else if (this.contains(t, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
+            return r
+        }
+        _clipSegment(t, n, i, r, s, a) {
+            const o = s < a;
+            for (o && ([t, n, i, r, s, a] = [i, r, t, n, a, s]);;) {
+                if (s === 0 && a === 0) return o ? [i, r, t, n] : [t, n, i, r];
+                if (s & a) return null;
+                let l, u, c = s || a;
+                c & 8 ? (l = t + (i - t) * (this.ymax - n) / (r - n), u = this.ymax) : c & 4 ? (l = t + (i - t) * (this.ymin - n) / (r - n), u = this.ymin) : c & 2 ? (u = n + (r - n) * (this.xmax - t) / (i - t), l = this.xmax) : (u = n + (r - n) * (this.xmin - t) / (i - t), l = this.xmin), s ? (t = l, n = u, s = this._regioncode(t, n)) : (i = l, r = u, a = this._regioncode(i, r))
+            }
+        }
+        _clipInfinite(t, n, i, r, s, a) {
+            let o = Array.from(n),
+                l;
+            if ((l = this._project(o[0], o[1], i, r)) && o.unshift(l[0], l[1]), (l = this._project(o[o.length - 2], o[o.length - 1], s, a)) && o.push(l[0], l[1]), o = this._clipFinite(t, o))
+                for (let u = 0, c = o.length, f, h = this._edgecode(o[c - 2], o[c - 1]); u < c; u += 2) f = h, h = this._edgecode(o[u], o[u + 1]), f && h && (u = this._edge(t, f, h, o, u), c = o.length);
+            else this.contains(t, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2) && (o = [this.xmin, this.ymin, this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax]);
+            return o
+        }
+        _edge(t, n, i, r, s) {
+            for (; n !== i;) {
+                let a, o;
+                switch (n) {
+                    case 5:
+                        n = 4;
+                        continue;
+                    case 4:
+                        n = 6, a = this.xmax, o = this.ymin;
+                        break;
+                    case 6:
+                        n = 2;
+                        continue;
+                    case 2:
+                        n = 10, a = this.xmax, o = this.ymax;
+                        break;
+                    case 10:
+                        n = 8;
+                        continue;
+                    case 8:
+                        n = 9, a = this.xmin, o = this.ymax;
+                        break;
+                    case 9:
+                        n = 1;
+                        continue;
+                    case 1:
+                        n = 5, a = this.xmin, o = this.ymin;
+                        break
+                }(r[s] !== a || r[s + 1] !== o) && this.contains(t, a, o) && (r.splice(s, 0, a, o), s += 2)
+            }
+            return s
+        }
+        _project(t, n, i, r) {
+            let s = 1 / 0,
+                a, o, l;
+            if (r < 0) {
+                if (n <= this.ymin) return null;
+                (a = (this.ymin - n) / r) < s && (l = this.ymin, o = t + (s = a) * i)
+            } else if (r > 0) {
+                if (n >= this.ymax) return null;
+                (a = (this.ymax - n) / r) < s && (l = this.ymax, o = t + (s = a) * i)
+            }
+            if (i > 0) {
+                if (t >= this.xmax) return null;
+                (a = (this.xmax - t) / i) < s && (o = this.xmax, l = n + (s = a) * r)
+            } else if (i < 0) {
+                if (t <= this.xmin) return null;
+                (a = (this.xmin - t) / i) < s && (o = this.xmin, l = n + (s = a) * r)
+            }
+            return [o, l]
+        }
+        _edgecode(t, n) {
+            return (t === this.xmin ? 1 : t === this.xmax ? 2 : 0) | (n === this.ymin ? 4 : n === this.ymax ? 8 : 0)
+        }
+        _regioncode(t, n) {
+            return (t < this.xmin ? 1 : t > this.xmax ? 2 : 0) | (n < this.ymin ? 4 : n > this.ymax ? 8 : 0)
+        }
+        _simplify(t) {
+            if (t && t.length > 4) {
+                for (let n = 0; n < t.length; n += 2) {
+                    const i = (n + 2) % t.length,
+                        r = (n + 4) % t.length;
+                    (t[n] === t[i] && t[i] === t[r] || t[n + 1] === t[i + 1] && t[i + 1] === t[r + 1]) && (t.splice(i, 2), n -= 2)
+                }
+                t.length || (t = null)
+            }
+            return t
+        }
+    };
+    const lte = 2 * Math.PI,
+        wu = Math.pow;
+
+    function ute(e) {
+        return e[0]
+    }
+
+    function cte(e) {
+        return e[1]
+    }
+
+    function fte(e) {
+        const {
+            triangles: t,
+            coords: n
+        } = e;
+        for (let i = 0; i < t.length; i += 3) {
+            const r = 2 * t[i],
+                s = 2 * t[i + 1],
+                a = 2 * t[i + 2];
+            if ((n[a] - n[r]) * (n[s + 1] - n[r + 1]) - (n[s] - n[r]) * (n[a + 1] - n[r + 1]) > 1e-10) return !1
+        }
+        return !0
+    }
+
+    function hte(e, t, n) {
+        return [e + Math.sin(e + t) * n, t + Math.cos(e - t) * n]
+    }
+    class wE {
+        static from(t, n = ute, i = cte, r) {
+            return new wE("length" in t ? dte(t, n, i, r) : Float64Array.from(gte(t, n, i, r)))
+        }
+        constructor(t) {
+            this._delaunator = new l0(t), this.inedges = new Int32Array(t.length / 2), this._hullIndex = new Int32Array(t.length / 2), this.points = this._delaunator.coords, this._init()
+        }
+        update() {
+            return this._delaunator.update(), this._init(), this
+        }
+        _init() {
+            const t = this._delaunator,
+                n = this.points;
+            if (t.hull && t.hull.length > 2 && fte(t)) {
+                this.collinear = Int32Array.from({
+                    length: n.length / 2
+                }, (h, d) => d).sort((h, d) => n[2 * h] - n[2 * d] || n[2 * h + 1] - n[2 * d + 1]);
+                const l = this.collinear[0],
+                    u = this.collinear[this.collinear.length - 1],
+                    c = [n[2 * l], n[2 * l + 1], n[2 * u], n[2 * u + 1]],
+                    f = 1e-8 * Math.hypot(c[3] - c[1], c[2] - c[0]);
+                for (let h = 0, d = n.length / 2; h < d; ++h) {
+                    const g = hte(n[2 * h], n[2 * h + 1], f);
+                    n[2 * h] = g[0], n[2 * h + 1] = g[1]
+                }
+                this._delaunator = new l0(n)
+            } else delete this.collinear;
+            const i = this.halfedges = this._delaunator.halfedges,
+                r = this.hull = this._delaunator.hull,
+                s = this.triangles = this._delaunator.triangles,
+                a = this.inedges.fill(-1),
+                o = this._hullIndex.fill(-1);
+            for (let l = 0, u = i.length; l < u; ++l) {
+                const c = s[l % 3 === 2 ? l - 2 : l + 1];
+                (i[l] === -1 || a[c] === -1) && (a[c] = l)
+            }
+            for (let l = 0, u = r.length; l < u; ++l) o[r[l]] = l;
+            r.length <= 2 && r.length > 0 && (this.triangles = new Int32Array(3).fill(-1), this.halfedges = new Int32Array(3).fill(-1), this.triangles[0] = r[0], a[r[0]] = 1, r.length === 2 && (a[r[1]] = 0, this.triangles[1] = r[1], this.triangles[2] = r[1]))
+        }
+        voronoi(t) {
+            return new ote(this, t)
+        }* neighbors(t) {
+            const {
+                inedges: n,
+                hull: i,
+                _hullIndex: r,
+                halfedges: s,
+                triangles: a,
+                collinear: o
+            } = this;
+            if (o) {
+                const f = o.indexOf(t);
+                f > 0 && (yield o[f - 1]), f < o.length - 1 && (yield o[f + 1]);
+                return
+            }
+            const l = n[t];
+            if (l === -1) return;
+            let u = l,
+                c = -1;
+            do {
+                if (yield c = a[u], u = u % 3 === 2 ? u - 2 : u + 1, a[u] !== t) return;
+                if (u = s[u], u === -1) {
+                    const f = i[(r[t] + 1) % i.length];
+                    f !== c && (yield f);
+                    return
+                }
+            } while (u !== l)
+        }
+        find(t, n, i = 0) {
+            if (t = +t, t !== t || (n = +n, n !== n)) return -1;
+            const r = i;
+            let s;
+            for (;
+                (s = this._step(i, t, n)) >= 0 && s !== i && s !== r;) i = s;
+            return s
+        }
+        _step(t, n, i) {
+            const {
+                inedges: r,
+                hull: s,
+                _hullIndex: a,
+                halfedges: o,
+                triangles: l,
+                points: u
+            } = this;
+            if (r[t] === -1 || !u.length) return (t + 1) % (u.length >> 1);
+            let c = t,
+                f = wu(n - u[t * 2], 2) + wu(i - u[t * 2 + 1], 2);
+            const h = r[t];
+            let d = h;
+            do {
+                let g = l[d];
+                const p = wu(n - u[g * 2], 2) + wu(i - u[g * 2 + 1], 2);
+                if (p < f && (f = p, c = g), d = d % 3 === 2 ? d - 2 : d + 1, l[d] !== t) break;
+                if (d = o[d], d === -1) {
+                    if (d = s[(a[t] + 1) % s.length], d !== g && wu(n - u[d * 2], 2) + wu(i - u[d * 2 + 1], 2) < f) return d;
+                    break
+                }
+            } while (d !== h);
+            return c
+        }
+        render(t) {
+            const n = t == null ? t = new ol : void 0,
+                {
+                    points: i,
+                    halfedges: r,
+                    triangles: s
+                } = this;
+            for (let a = 0, o = r.length; a < o; ++a) {
+                const l = r[a];
+                if (l < a) continue;
+                const u = s[a] * 2,
+                    c = s[l] * 2;
+                t.moveTo(i[u], i[u + 1]), t.lineTo(i[c], i[c + 1])
+            }
+            return this.renderHull(t), n && n.value()
+        }
+        renderPoints(t, n) {
+            n === void 0 && (!t || typeof t.moveTo != "function") && (n = t, t = null), n = n == null ? 2 : +n;
+            const i = t == null ? t = new ol : void 0,
+                {
+                    points: r
+                } = this;
+            for (let s = 0, a = r.length; s < a; s += 2) {
+                const o = r[s],
+                    l = r[s + 1];
+                t.moveTo(o + n, l), t.arc(o, l, n, 0, lte)
+            }
+            return i && i.value()
+        }
+        renderHull(t) {
+            const n = t == null ? t = new ol : void 0,
+                {
+                    hull: i,
+                    points: r
+                } = this,
+                s = i[0] * 2,
+                a = i.length;
+            t.moveTo(r[s], r[s + 1]);
+            for (let o = 1; o < a; ++o) {
+                const l = 2 * i[o];
+                t.lineTo(r[l], r[l + 1])
+            }
+            return t.closePath(), n && n.value()
+        }
+        hullPolygon() {
+            const t = new sx;
+            return this.renderHull(t), t.value()
+        }
+        renderTriangle(t, n) {
+            const i = n == null ? n = new ol : void 0,
+                {
+                    points: r,
+                    triangles: s
+                } = this,
+                a = s[t *= 3] * 2,
+                o = s[t + 1] * 2,
+                l = s[t + 2] * 2;
+            return n.moveTo(r[a], r[a + 1]), n.lineTo(r[o], r[o + 1]), n.lineTo(r[l], r[l + 1]), n.closePath(), i && i.value()
+        }* trianglePolygons() {
+            const {
+                triangles: t
+            } = this;
+            for (let n = 0, i = t.length / 3; n < i; ++n) yield this.trianglePolygon(n)
+        }
+        trianglePolygon(t) {
+            const n = new sx;
+            return this.renderTriangle(t, n), n.value()
+        }
+    }
+
+    function dte(e, t, n, i) {
+        const r = e.length,
+            s = new Float64Array(r * 2);
+        for (let a = 0; a < r; ++a) {
+            const o = e[a];
+            s[a * 2] = t.call(i, o, a, e), s[a * 2 + 1] = n.call(i, o, a, e)
+        }
+        return s
+    }
+
+    function* gte(e, t, n, i) {
+        let r = 0;
+        for (const s of e) yield t.call(i, s, r, e), yield n.call(i, s, r, e), ++r
+    }
+
+    function SE(e) {
+        j.call(this, null, e)
+    }
+    SE.Definition = {
+        type: "Voronoi",
+        metadata: {
+            modifies: !0
+        },
+        params: [{
+            name: "x",
+            type: "field",
+            required: !0
+        }, {
+            name: "y",
+            type: "field",
+            required: !0
+        }, {
+            name: "size",
+            type: "number",
+            array: !0,
+            length: 2
+        }, {
+            name: "extent",
+            type: "array",
+            array: !0,
+            length: 2,
+            default: [
+                [-1e5, -1e5],
+                [1e5, 1e5]
+            ],
+            content: {
+                type: "number",
+                array: !0,
+                length: 2
+            }
+        }, {
+            name: "as",
+            type: "string",
+            default: "path"
+        }]
+    };
+    const pte = [-1e5, -1e5, 1e5, 1e5];
+    ne(SE, j, {
+        transform(e, t) {
+            const n = e.as || "path",
+                i = t.source;
+            if (!i || !i.length) return t;
+            let r = e.size;
+            r = r ? [0, 0, r[0], r[1]] : (r = e.extent) ? [r[0][0], r[0][1], r[1][0], r[1][1]] : pte;
+            const s = this.value = wE.from(i, e.x, e.y).voronoi(r);
+            for (let a = 0, o = i.length; a < o; ++a) {
+                const l = s.cellPolygon(a);
+                i[a][n] = l ? mte(l) : null
+            }
+            return t.reflow(e.modified()).modifies(n)
+        }
+    });
+
+    function mte(e) {
+        const t = e[0][0],
+            n = e[0][1];
+        let i = e.length - 1;
+        for (; e[i][0] === t && e[i][1] === n; --i);
+        return "M" + e.slice(0, i + 1).join("L") + "Z"
+    }
+    const yte = Object.freeze(Object.defineProperty({
+        __proto__: null,
+        voronoi: SE
+    }, Symbol.toStringTag, {
+        value: "Module"
+    }));
+    var Gv = Math.PI / 180,
+        hh = 64,
+        Lp = 2048;
+
+    function vte() {
+        var e = [256, 256],
+            t, n, i, r, s, a, o, l = CL,
+            u = [],
+            c = Math.random,
+            f = {};
+        f.layout = function() {
+            for (var g = h(Ha()), p = Ete((e[0] >> 5) * e[1]), m = null, y = u.length, v = -1, b = [], x = u.map(S => ({
+                    text: t(S),
+                    font: n(S),
+                    style: r(S),
+                    weight: s(S),
+                    rotate: a(S),
+                    size: ~~(i(S) + 1e-14),
+                    padding: o(S),
+                    xoff: 0,
+                    yoff: 0,
+                    x1: 0,
+                    y1: 0,
+                    x0: 0,
+                    y0: 0,
+                    hasText: !1,
+                    sprite: null,
+                    datum: S
+                })).sort((S, w) => w.size - S.size); ++v < y;) {
+                var _ = x[v];
+                _.x = e[0] * (c() + .5) >> 1, _.y = e[1] * (c() + .5) >> 1, bte(g, _, x, v), _.hasText && d(p, _, m) && (b.push(_), m ? _te(m, _) : m = [{
+                    x: _.x + _.x0,
+                    y: _.y + _.y0
+                }, {
+                    x: _.x + _.x1,
+                    y: _.y + _.y1
+                }], _.x -= e[0] >> 1, _.y -= e[1] >> 1)
+            }
+            return b
+        };
+
+        function h(g) {
+            g.width = g.height = 1;
+            var p = Math.sqrt(g.getContext("2d").getImageData(0, 0, 1, 1).data.length >> 2);
+            g.width = (hh << 5) / p, g.height = Lp / p;
+            var m = g.getContext("2d");
+            return m.fillStyle = m.strokeStyle = "red", m.textAlign = "center", {
+                context: m,
+                ratio: p
+            }
+        }
+
+        function d(g, p, m) {
+            for (var y = p.x, v = p.y, b = Math.sqrt(e[0] * e[0] + e[1] * e[1]), x = l(e), _ = c() < .5 ? 1 : -1, S = -_, w, E, C;
+                (w = x(S += _)) && (E = ~~w[0], C = ~~w[1], !(Math.min(Math.abs(E), Math.abs(C)) >= b));)
+                if (p.x = y + E, p.y = v + C, !(p.x + p.x0 < 0 || p.y + p.y0 < 0 || p.x + p.x1 > e[0] || p.y + p.y1 > e[1]) && (!m || !xte(p, g, e[0])) && (!m || wte(p, m))) {
+                    for (var k = p.sprite, A = p.width >> 5, F = e[0] >> 5, $ = p.x - (A << 4), T = $ & 127, M = 32 - T, R = p.y1 - p.y0, N = (p.y + p.y0) * F + ($ >> 5), L, I = 0; I < R; I++) {
+                        L = 0;
+                        for (var G = 0; G <= A; G++) g[N + G] |= L << M | (G < A ? (L = k[I * A + G]) >>> T : 0);
+                        N += F
+                    }
+                    return p.sprite = null, !0
+                } return !1
+        }
+        return f.words = function(g) {
+            return arguments.length ? (u = g, f) : u
+        }, f.size = function(g) {
+            return arguments.length ? (e = [+g[0], +g[1]], f) : e
+        }, f.font = function(g) {
+            return arguments.length ? (n = Po(g), f) : n
+        }, f.fontStyle = function(g) {
+            return arguments.length ? (r = Po(g), f) : r
+        }, f.fontWeight = function(g) {
+            return arguments.length ? (s = Po(g), f) : s
+        }, f.rotate = function(g) {
+            return arguments.length ? (a = Po(g), f) : a
+        }, f.text = function(g) {
+            return arguments.length ? (t = Po(g), f) : t
+        }, f.spiral = function(g) {
+            return arguments.length ? (l = kte[g] || g, f) : l
+        }, f.fontSize = function(g) {
+            return arguments.length ? (i = Po(g), f) : i
+        }, f.padding = function(g) {
+            return arguments.length ? (o = Po(g), f) : o
+        }, f.random = function(g) {
+            return arguments.length ? (c = g, f) : c
+        }, f
+    }
+
+    function bte(e, t, n, i) {
+        if (!t.sprite) {
+            var r = e.context,
+                s = e.ratio;
+            r.clearRect(0, 0, (hh << 5) / s, Lp / s);
+            var a = 0,
+                o = 0,
+                l = 0,
+                u = n.length,
+                c, f, h, d, g;
+            for (--i; ++i < u;) {
+                if (t = n[i], r.save(), r.font = t.style + " " + t.weight + " " + ~~((t.size + 1) / s) + "px " + t.font, c = r.measureText(t.text + "m").width * s, h = t.size << 1, t.rotate) {
+                    var p = Math.sin(t.rotate * Gv),
+                        m = Math.cos(t.rotate * Gv),
+                        y = c * m,
+                        v = c * p,
+                        b = h * m,
+                        x = h * p;
+                    c = Math.max(Math.abs(y + x), Math.abs(y - x)) + 31 >> 5 << 5, h = ~~Math.max(Math.abs(v + b), Math.abs(v - b))
+                } else c = c + 31 >> 5 << 5;
+                if (h > l && (l = h), a + c >= hh << 5 && (a = 0, o += l, l = 0), o + h >= Lp) break;
+                r.translate((a + (c >> 1)) / s, (o + (h >> 1)) / s), t.rotate && r.rotate(t.rotate * Gv), r.fillText(t.text, 0, 0), t.padding && (r.lineWidth = 2 * t.padding, r.strokeText(t.text, 0, 0)), r.restore(), t.width = c, t.height = h, t.xoff = a, t.yoff = o, t.x1 = c >> 1, t.y1 = h >> 1, t.x0 = -t.x1, t.y0 = -t.y1, t.hasText = !0, a += c
+            }
+            for (var _ = r.getImageData(0, 0, (hh << 5) / s, Lp / s).data, S = []; --i >= 0;)
+                if (t = n[i], !!t.hasText) {
+                    for (c = t.width, f = c >> 5, h = t.y1 - t.y0, d = 0; d < h * f; d++) S[d] = 0;
+                    if (a = t.xoff, a == null) return;
+                    o = t.yoff;
+                    var w = 0,
+                        E = -1;
+                    for (g = 0; g < h; g++) {
+                        for (d = 0; d < c; d++) {
+                            var C = f * g + (d >> 5),
+                                k = _[(o + g) * (hh << 5) + (a + d) << 2] ? 1 << 31 - d % 32 : 0;
+                            S[C] |= k, w |= k
+                        }
+                        w ? E = g : (t.y0++, h--, g--, o++)
+                    }
+                    t.y1 = t.y0 + E, t.sprite = S.slice(0, (t.y1 - t.y0) * f)
+                }
+        }
+    }
+
+    function xte(e, t, n) {
+        n >>= 5;
+        for (var i = e.sprite, r = e.width >> 5, s = e.x - (r << 4), a = s & 127, o = 32 - a, l = e.y1 - e.y0, u = (e.y + e.y0) * n + (s >> 5), c, f = 0; f < l; f++) {
+            c = 0;
+            for (var h = 0; h <= r; h++)
+                if ((c << o | (h < r ? (c = i[f * r + h]) >>> a : 0)) & t[u + h]) return !0;
+            u += n
+        }
+        return !1
+    }
+
+    function _te(e, t) {
+        var n = e[0],
+            i = e[1];
+        t.x + t.x0 < n.x && (n.x = t.x + t.x0), t.y + t.y0 < n.y && (n.y = t.y + t.y0), t.x + t.x1 > i.x && (i.x = t.x + t.x1), t.y + t.y1 > i.y && (i.y = t.y + t.y1)
+    }
+
+    function wte(e, t) {
+        return e.x + e.x1 > t[0].x && e.x + e.x0 < t[1].x && e.y + e.y1 > t[0].y && e.y + e.y0 < t[1].y
+    }
+
+    function CL(e) {
+        var t = e[0] / e[1];
+        return function(n) {
+            return [t * (n *= .1) * Math.cos(n), n * Math.sin(n)]
+        }
+    }
+
+    function Ste(e) {
+        var t = 4,
+            n = t * e[0] / e[1],
+            i = 0,
+            r = 0;
+        return function(s) {
+            var a = s < 0 ? -1 : 1;
+            switch (Math.sqrt(1 + 4 * a * s) - a & 3) {
+                case 0:
+                    i += n;
+                    break;
+                case 1:
+                    r += t;
+                    break;
+                case 2:
+                    i -= n;
+                    break;
+                default:
+                    r -= t;
+                    break
+            }
+            return [i, r]
+        }
+    }
+
+    function Ete(e) {
+        for (var t = [], n = -1; ++n < e;) t[n] = 0;
+        return t
+    }
+
+    function Po(e) {
+        return typeof e == "function" ? e : function() {
+            return e
+        }
+    }
+    var kte = {
+        archimedean: CL,
+        rectangular: Ste
+    };
+    const AL = ["x", "y", "font", "fontSize", "fontStyle", "fontWeight", "angle"],
+        Cte = ["text", "font", "rotate", "fontSize", "fontStyle", "fontWeight"];
+
+    function EE(e) {
+        j.call(this, vte(), e)
+    }
+    EE.Definition = {
+        type: "Wordcloud",
+        metadata: {
+            modifies: !0
+        },
+        params: [{
+            name: "size",
+            type: "number",
+            array: !0,
+            length: 2
+        }, {
+            name: "font",
+            type: "string",
+            expr: !0,
+            default: "sans-serif"
+        }, {
+            name: "fontStyle",
+            type: "string",
+            expr: !0,
+            default: "normal"
+        }, {
+            name: "fontWeight",
+            type: "string",
+            expr: !0,
+            default: "normal"
+        }, {
+            name: "fontSize",
+            type: "number",
+            expr: !0,
+            default: 14
+        }, {
+            name: "fontSizeRange",
+            type: "number",
+            array: "nullable",
+            default: [10, 50]
+        }, {
+            name: "rotate",
+            type: "number",
+            expr: !0,
+            default: 0
+        }, {
+            name: "text",
+            type: "field"
+        }, {
+            name: "spiral",
+            type: "string",
+            values: ["archimedean", "rectangular"]
+        }, {
+            name: "padding",
+            type: "number",
+            expr: !0
+        }, {
+            name: "as",
+            type: "string",
+            array: !0,
+            length: 7,
+            default: AL
+        }]
+    };
+    ne(EE, j, {
+        transform(e, t) {
+            e.size && !(e.size[0] && e.size[1]) && q("Wordcloud size dimensions must be non-zero.");
+
+            function n(g) {
+                const p = e[g];
+                return Pe(p) && t.modified(p.fields)
+            }
+            const i = e.modified();
+            if (!(i || t.changed(t.ADD_REM) || Cte.some(n))) return;
+            const r = t.materialize(t.SOURCE).source,
+                s = this.value,
+                a = e.as || AL;
+            let o = e.fontSize || 14,
+                l;
+            if (Pe(o) ? l = e.fontSizeRange : o = Ln(o), l) {
+                const g = o,
+                    p = Ze("sqrt")().domain(ss(r, g)).range(l);
+                o = m => p(g(m))
+            }
+            r.forEach(g => {
+                g[a[0]] = NaN, g[a[1]] = NaN, g[a[3]] = 0
+            });
+            const u = s.words(r).text(e.text).size(e.size || [500, 500]).padding(e.padding || 1).spiral(e.spiral || "archimedean").rotate(e.rotate || 0).font(e.font || "sans-serif").fontStyle(e.fontStyle || "normal").fontWeight(e.fontWeight || "normal").fontSize(o).random(Vi).layout(),
+                c = s.size(),
+                f = c[0] >> 1,
+                h = c[1] >> 1,
+                d = u.length;
+            for (let g = 0, p, m; g < d; ++g) p = u[g], m = p.datum, m[a[0]] = p.x + f, m[a[1]] = p.y + h, m[a[2]] = p.font, m[a[3]] = p.size, m[a[4]] = p.style, m[a[5]] = p.weight, m[a[6]] = p.rotate;
+            return t.reflow(i).modifies(a)
+        }
+    });
+    const Ate = Object.freeze(Object.defineProperty({
+            __proto__: null,
+            wordcloud: EE
         }, Symbol.toStringTag, {
             value: "Module"
         })),
-        fne = e => new Uint8Array(e),
-        hne = e => new Uint16Array(e),
-        rh = e => new Uint32Array(e);
+        $te = e => new Uint8Array(e),
+        Tte = e => new Uint16Array(e),
+        Fh = e => new Uint32Array(e);
 
-    function dne() {
+    function Mte() {
         let e = 8,
             t = [],
-            n = rh(0),
-            i = Sg(0, e),
-            r = Sg(0, e);
+            n = Fh(0),
+            i = Ug(0, e),
+            r = Ug(0, e);
         return {
             data: () => t,
-            seen: () => n = gne(n, t.length),
+            seen: () => n = Ote(n, t.length),
             add(s) {
                 for (let a = 0, o = t.length, l = s.length, u; a < l; ++a) u = s[a], u._index = o++, t.push(u)
             },
             remove(s, a) {
                 const o = t.length,
                     l = Array(o - s),
                     u = t;
@@ -29468,29 +22705,29 @@
                 i[s] |= a
             },
             clear(s, a) {
                 i[s] &= ~a
             },
             resize(s, a) {
                 const o = i.length;
-                (s > o || a > e) && (e = Math.max(a, e), i = Sg(s, e, i), r = Sg(s, e))
+                (s > o || a > e) && (e = Math.max(a, e), i = Ug(s, e, i), r = Ug(s, e))
             }
         }
     }
 
-    function gne(e, t, n) {
+    function Ote(e, t, n) {
         return e.length >= t ? e : (n = n || new e.constructor(t), n.set(e), n)
     }
 
-    function Sg(e, t, n) {
-        const i = (t < 257 ? fne : t < 65537 ? hne : rh)(e);
+    function Ug(e, t, n) {
+        const i = (t < 257 ? $te : t < 65537 ? Tte : Fh)(e);
         return n && i.set(n), i
     }
 
-    function MT(e, t, n) {
+    function JT(e, t, n) {
         const i = 1 << t;
         return {
             one: i,
             zero: ~i,
             range: n.slice(),
             bisect: e.bisect,
             index: e.index,
@@ -29506,28 +22743,28 @@
                 for (h = 0; h < u; ++h) s[l[h]] |= i;
                 for (h = c; h < f; ++h) s[l[h]] |= i;
                 return a
             }
         }
     }
 
-    function OT() {
-        let e = rh(0),
+    function QT() {
+        let e = Fh(0),
             t = [],
             n = 0;
 
         function i(o, l, u) {
             if (!l.length) return [];
             const c = n,
                 f = l.length,
-                h = rh(f);
+                h = Fh(f);
             let d = Array(f),
                 g, p, m;
             for (m = 0; m < f; ++m) d[m] = o(l[m]), h[m] = m;
-            if (d = pne(d, h), c) g = t, p = e, t = Array(c + f), e = rh(c + f), mne(u, g, p, c, d, h, f, t, e);
+            if (d = Fte(d, h), c) g = t, p = e, t = Array(c + f), e = Fh(c + f), Rte(u, g, p, c, d, h, f, t, e);
             else {
                 if (u > 0)
                     for (m = 0; m < f; ++m) h[m] += u;
                 t = d, e = h
             }
             return n = c + f, {
                 index: h,
@@ -29545,47 +22782,47 @@
 
         function s(o) {
             for (let l = 0, u = n; l < u; ++l) e[l] = o[e[l]]
         }
 
         function a(o, l) {
             let u;
-            return l ? u = l.length : (l = t, u = n), [xj(l, o[0], 0, u), wp(l, o[1], 0, u)]
+            return l ? u = l.length : (l = t, u = n), [JB(l, o[0], 0, u), nm(l, o[1], 0, u)]
         }
         return {
             insert: i,
             remove: r,
             bisect: a,
             reindex: s,
             index: () => e,
             size: () => n
         }
     }
 
-    function pne(e, t) {
+    function Fte(e, t) {
         return e.sort.call(t, (n, i) => {
             const r = e[n],
                 s = e[i];
             return r < s ? -1 : r > s ? 1 : 0
-        }), Sj(e, t)
+        }), ej(e, t)
     }
 
-    function mne(e, t, n, i, r, s, a, o, l) {
+    function Rte(e, t, n, i, r, s, a, o, l) {
         let u = 0,
             c = 0,
             f;
         for (f = 0; u < i && c < a; ++f) t[u] < r[c] ? (o[f] = t[u], l[f] = n[u++]) : (o[f] = r[c], l[f] = s[c++] + e);
         for (; u < i; ++u, ++f) o[f] = t[u], l[f] = n[u];
         for (; c < a; ++c, ++f) o[f] = r[c], l[f] = s[c] + e
     }
 
-    function PS(e) {
-        L.call(this, dne(), e), this._indices = null, this._dims = null
+    function kE(e) {
+        j.call(this, Mte(), e), this._indices = null, this._dims = null
     }
-    PS.Definition = {
+    kE.Definition = {
         type: "CrossFilter",
         metadata: {},
         params: [{
             name: "fields",
             type: "field",
             array: !0,
             required: !0
@@ -29597,30 +22834,30 @@
             content: {
                 type: "number",
                 array: !0,
                 length: 2
             }
         }]
     };
-    ee(PS, L, {
+    ne(kE, j, {
         transform(e, t) {
             if (this._dims) {
                 var n = e.modified("fields") || e.fields.some(i => t.modified(i.fields));
                 return n ? this.reinit(e, t) : this.eval(e, t)
             } else return this.init(e, t)
         },
         init(e, t) {
             const n = e.fields,
                 i = e.query,
                 r = this._indices = {},
                 s = this._dims = [],
                 a = i.length;
             let o = 0,
                 l, u;
-            for (; o < a; ++o) l = n[o].fname, u = r[l] || (r[l] = OT()), s.push(MT(u, o, i[o]));
+            for (; o < a; ++o) l = n[o].fname, u = r[l] || (r[l] = QT()), s.push(JT(u, o, i[o]));
             return this.eval(e, t)
         },
         reinit(e, t) {
             const n = t.materialize().fork(),
                 i = e.fields,
                 r = e.query,
                 s = this._indices,
@@ -29632,15 +22869,15 @@
                 f = n.rem = n.add,
                 h = n.mod,
                 d = r.length,
                 g = {};
             let p, m, y, v, b, x, _, S, w;
             if (u.set(l), t.rem.length && (b = this.remove(e, t, n)), t.add.length && o.add(t.add), t.mod.length)
                 for (x = {}, v = t.mod, _ = 0, S = v.length; _ < S; ++_) x[v[_]._index] = 1;
-            for (_ = 0; _ < d; ++_) w = i[_], (!a[_] || e.modified("fields", _) || t.modified(w.fields)) && (y = w.fname, (p = g[y]) || (s[y] = m = OT(), g[y] = p = m.insert(w, t.source, 0)), a[_] = MT(m, _, r[_]).onAdd(p, l));
+            for (_ = 0; _ < d; ++_) w = i[_], (!a[_] || e.modified("fields", _) || t.modified(w.fields)) && (y = w.fname, (p = g[y]) || (s[y] = m = QT(), g[y] = p = m.insert(w, t.source, 0)), a[_] = JT(m, _, r[_]).onAdd(p, l));
             for (_ = 0, S = o.data().length; _ < S; ++_) b[_] || (u[_] !== l[_] ? f.push(_) : x[_] && l[_] !== c && h.push(_));
             return o.mask = (1 << d) - 1, n
         },
         eval(e, t) {
             const n = t.materialize().fork(),
                 i = this._dims.length;
             let r = 0;
@@ -29753,33 +22990,33 @@
                 for (g = Math.max(u, h), p = c; g < p; ++g) m = a[g], s[m] ^= d, n.push(m);
             else if (c < h)
                 for (g = Math.max(f, c), p = h; g < p; ++g) m = a[g], s[m] ^= d, i.push(m);
             e.range = t.slice()
         }
     });
 
-    function LS(e) {
-        L.call(this, null, e)
+    function CE(e) {
+        j.call(this, null, e)
     }
-    LS.Definition = {
+    CE.Definition = {
         type: "ResolveFilter",
         metadata: {},
         params: [{
             name: "ignore",
             type: "number",
             required: !0,
             description: "A bit mask indicating which filters to ignore."
         }, {
             name: "filter",
             type: "object",
             required: !0,
             description: "Per-tuple filter bitmaps from a CrossFilter transform."
         }]
     };
-    ee(LS, L, {
+    ne(CE, j, {
         transform(e, t) {
             const n = ~(e.ignore || 0),
                 i = e.filter,
                 r = i.mask;
             if (!(r & n)) return t.StopPropagation;
             const s = t.fork(t.ALL),
                 a = i.data(),
@@ -29791,147 +23028,147 @@
                 return !f && f ^ l[c] & n ? a[c] : null
             }), s.filter(s.REM, c => {
                 const f = o[c] & n;
                 return f && !(f ^ (f ^ l[c] & n)) ? a[c] : null
             })) : (s.filter(s.ADD, u), s.filter(s.REM, c => (o[c] & n) === r ? a[c] : null)), s.filter(s.SOURCE, c => u(c._index))
         }
     });
-    const yne = Object.freeze(Object.defineProperty({
+    const Dte = Object.freeze(Object.defineProperty({
             __proto__: null,
-            crossfilter: PS,
-            resolvefilter: LS
+            crossfilter: kE,
+            resolvefilter: CE
         }, Symbol.toStringTag, {
             value: "Module"
         })),
-        vne = "RawCode",
-        il = "Literal",
-        bne = "Property",
-        xne = "Identifier",
-        _ne = "ArrayExpression",
-        wne = "BinaryExpression",
-        H4 = "CallExpression",
-        Sne = "ConditionalExpression",
-        Ene = "LogicalExpression",
-        Cne = "MemberExpression",
-        kne = "ObjectExpression",
-        Ane = "UnaryExpression";
+        Nte = "RawCode",
+        $l = "Literal",
+        Pte = "Property",
+        Lte = "Identifier",
+        Ite = "ArrayExpression",
+        zte = "BinaryExpression",
+        $L = "CallExpression",
+        Bte = "ConditionalExpression",
+        jte = "LogicalExpression",
+        Gte = "MemberExpression",
+        Ute = "ObjectExpression",
+        Wte = "UnaryExpression";
 
-    function yr(e) {
+    function Or(e) {
         this.type = e
     }
-    yr.prototype.visit = function(e) {
+    Or.prototype.visit = function(e) {
         let t, n, i;
         if (e(this)) return 1;
-        for (t = $ne(this), n = 0, i = t.length; n < i; ++n)
+        for (t = qte(this), n = 0, i = t.length; n < i; ++n)
             if (t[n].visit(e)) return 1
     };
 
-    function $ne(e) {
+    function qte(e) {
         switch (e.type) {
-            case _ne:
+            case Ite:
                 return e.elements;
-            case wne:
-            case Ene:
+            case zte:
+            case jte:
                 return [e.left, e.right];
-            case H4:
+            case $L:
                 return [e.callee].concat(e.arguments);
-            case Sne:
+            case Bte:
                 return [e.test, e.consequent, e.alternate];
-            case Cne:
+            case Gte:
                 return [e.object, e.property];
-            case kne:
+            case Ute:
                 return e.properties;
-            case bne:
+            case Pte:
                 return [e.key, e.value];
-            case Ane:
+            case Wte:
                 return [e.argument];
-            case xne:
-            case il:
-            case vne:
+            case Lte:
+            case $l:
+            case Nte:
             default:
                 return []
         }
     }
-    var ss, ce, B, yn, Qe, r1 = 1,
-        wd = 2,
-        rl = 3,
-        eo = 4,
-        s1 = 5,
-        Ol = 6,
-        Wn = 7,
-        Sd = 8,
-        Tne = 9;
-    ss = {};
-    ss[r1] = "Boolean";
-    ss[wd] = "<end>";
-    ss[rl] = "Identifier";
-    ss[eo] = "Keyword";
-    ss[s1] = "Null";
-    ss[Ol] = "Numeric";
-    ss[Wn] = "Punctuator";
-    ss[Sd] = "String";
-    ss[Tne] = "RegularExpression";
-    var Mne = "ArrayExpression",
-        One = "BinaryExpression",
-        Fne = "CallExpression",
-        Rne = "ConditionalExpression",
-        Y4 = "Identifier",
-        Dne = "Literal",
-        Nne = "LogicalExpression",
-        Pne = "MemberExpression",
-        Lne = "ObjectExpression",
-        Ine = "Property",
-        zne = "UnaryExpression",
-        Bt = "Unexpected token %0",
-        Bne = "Unexpected number",
-        jne = "Unexpected string",
-        Une = "Unexpected identifier",
-        Gne = "Unexpected reserved word",
-        Wne = "Unexpected end of input",
-        T2 = "Invalid regular expression",
-        gv = "Invalid regular expression: missing /",
-        X4 = "Octal literals are not allowed in strict mode.",
-        qne = "Duplicate data property in object literal not allowed in strict mode",
-        Kt = "ILLEGAL",
-        Oh = "Disabled.",
-        Hne = new RegExp("[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B2\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]"),
-        Yne = new RegExp("[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0-\\u08B2\\u08E4-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58\\u0C59\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C81-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D01-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D57\\u0D60-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19D9\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1CF8\\u1CF9\\u1D00-\\u1DF5\\u1DFC-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u2E2F\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099\\u309A\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA69D\\uA69F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C4\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2D\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]");
+    var bs, me, W, Dn, ot, P1 = 1,
+        Jd = 2,
+        Tl = 3,
+        _o = 4,
+        L1 = 5,
+        Jl = 6,
+        ti = 7,
+        Qd = 8,
+        Hte = 9;
+    bs = {};
+    bs[P1] = "Boolean";
+    bs[Jd] = "<end>";
+    bs[Tl] = "Identifier";
+    bs[_o] = "Keyword";
+    bs[L1] = "Null";
+    bs[Jl] = "Numeric";
+    bs[ti] = "Punctuator";
+    bs[Qd] = "String";
+    bs[Hte] = "RegularExpression";
+    var Yte = "ArrayExpression",
+        Xte = "BinaryExpression",
+        Vte = "CallExpression",
+        Kte = "ConditionalExpression",
+        TL = "Identifier",
+        Jte = "Literal",
+        Qte = "LogicalExpression",
+        Zte = "MemberExpression",
+        ene = "ObjectExpression",
+        tne = "Property",
+        nne = "UnaryExpression",
+        nn = "Unexpected token %0",
+        ine = "Unexpected number",
+        rne = "Unexpected string",
+        sne = "Unexpected identifier",
+        ane = "Unexpected reserved word",
+        one = "Unexpected end of input",
+        ax = "Invalid regular expression",
+        Uv = "Invalid regular expression: missing /",
+        ML = "Octal literals are not allowed in strict mode.",
+        lne = "Duplicate data property in object literal not allowed in strict mode",
+        yn = "ILLEGAL",
+        ad = "Disabled.",
+        une = new RegExp("[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B2\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]"),
+        cne = new RegExp("[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0-\\u08B2\\u08E4-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58\\u0C59\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C81-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D01-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D57\\u0D60-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19D9\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1CF8\\u1CF9\\u1D00-\\u1DF5\\u1DFC-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u2E2F\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099\\u309A\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA69D\\uA69F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C4\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2D\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]");
 
-    function a1(e, t) {
+    function I1(e, t) {
         if (!e) throw new Error("ASSERT: " + t)
     }
 
-    function xs(e) {
+    function Ls(e) {
         return e >= 48 && e <= 57
     }
 
-    function IS(e) {
+    function AE(e) {
         return "0123456789abcdefABCDEF".indexOf(e) >= 0
     }
 
-    function sh(e) {
+    function Rh(e) {
         return "01234567".indexOf(e) >= 0
     }
 
-    function Xne(e) {
+    function fne(e) {
         return e === 32 || e === 9 || e === 11 || e === 12 || e === 160 || e >= 5760 && [5760, 6158, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279].indexOf(e) >= 0
     }
 
-    function Fh(e) {
+    function od(e) {
         return e === 10 || e === 13 || e === 8232 || e === 8233
     }
 
-    function Ed(e) {
-        return e === 36 || e === 95 || e >= 65 && e <= 90 || e >= 97 && e <= 122 || e === 92 || e >= 128 && Hne.test(String.fromCharCode(e))
+    function Zd(e) {
+        return e === 36 || e === 95 || e >= 65 && e <= 90 || e >= 97 && e <= 122 || e === 92 || e >= 128 && une.test(String.fromCharCode(e))
     }
 
-    function $0(e) {
-        return e === 36 || e === 95 || e >= 65 && e <= 90 || e >= 97 && e <= 122 || e >= 48 && e <= 57 || e === 92 || e >= 128 && Yne.test(String.fromCharCode(e))
+    function u0(e) {
+        return e === 36 || e === 95 || e >= 65 && e <= 90 || e >= 97 && e <= 122 || e >= 48 && e <= 57 || e === 92 || e >= 128 && cne.test(String.fromCharCode(e))
     }
-    const Vne = {
+    const hne = {
         if: 1,
         in: 1,
         do: 1,
         var: 1,
         for: 1,
         new: 1,
         try: 1,
@@ -29968,201 +23205,201 @@
         debugger: 1,
         interface: 1,
         protected: 1,
         instanceof: 1,
         implements: 1
     };
 
-    function V4() {
-        for (; B < yn;) {
-            const e = ce.charCodeAt(B);
-            if (Xne(e) || Fh(e)) ++B;
+    function OL() {
+        for (; W < Dn;) {
+            const e = me.charCodeAt(W);
+            if (fne(e) || od(e)) ++W;
             else break
         }
     }
 
-    function M2(e) {
+    function ox(e) {
         var t, n, i, r = 0;
-        for (n = e === "u" ? 4 : 2, t = 0; t < n; ++t) B < yn && IS(ce[B]) ? (i = ce[B++], r = r * 16 + "0123456789abcdef".indexOf(i.toLowerCase())) : Ue({}, Bt, Kt);
+        for (n = e === "u" ? 4 : 2, t = 0; t < n; ++t) W < Dn && AE(me[W]) ? (i = me[W++], r = r * 16 + "0123456789abcdef".indexOf(i.toLowerCase())) : Je({}, nn, yn);
         return String.fromCharCode(r)
     }
 
-    function Kne() {
+    function dne() {
         var e, t, n, i;
-        for (e = ce[B], t = 0, e === "}" && Ue({}, Bt, Kt); B < yn && (e = ce[B++], !!IS(e));) t = t * 16 + "0123456789abcdef".indexOf(e.toLowerCase());
-        return (t > 1114111 || e !== "}") && Ue({}, Bt, Kt), t <= 65535 ? String.fromCharCode(t) : (n = (t - 65536 >> 10) + 55296, i = (t - 65536 & 1023) + 56320, String.fromCharCode(n, i))
+        for (e = me[W], t = 0, e === "}" && Je({}, nn, yn); W < Dn && (e = me[W++], !!AE(e));) t = t * 16 + "0123456789abcdef".indexOf(e.toLowerCase());
+        return (t > 1114111 || e !== "}") && Je({}, nn, yn), t <= 65535 ? String.fromCharCode(t) : (n = (t - 65536 >> 10) + 55296, i = (t - 65536 & 1023) + 56320, String.fromCharCode(n, i))
     }
 
-    function K4() {
+    function FL() {
         var e, t;
-        for (e = ce.charCodeAt(B++), t = String.fromCharCode(e), e === 92 && (ce.charCodeAt(B) !== 117 && Ue({}, Bt, Kt), ++B, e = M2("u"), (!e || e === "\\" || !Ed(e.charCodeAt(0))) && Ue({}, Bt, Kt), t = e); B < yn && (e = ce.charCodeAt(B), !!$0(e));) ++B, t += String.fromCharCode(e), e === 92 && (t = t.substr(0, t.length - 1), ce.charCodeAt(B) !== 117 && Ue({}, Bt, Kt), ++B, e = M2("u"), (!e || e === "\\" || !$0(e.charCodeAt(0))) && Ue({}, Bt, Kt), t += e);
+        for (e = me.charCodeAt(W++), t = String.fromCharCode(e), e === 92 && (me.charCodeAt(W) !== 117 && Je({}, nn, yn), ++W, e = ox("u"), (!e || e === "\\" || !Zd(e.charCodeAt(0))) && Je({}, nn, yn), t = e); W < Dn && (e = me.charCodeAt(W), !!u0(e));) ++W, t += String.fromCharCode(e), e === 92 && (t = t.substr(0, t.length - 1), me.charCodeAt(W) !== 117 && Je({}, nn, yn), ++W, e = ox("u"), (!e || e === "\\" || !u0(e.charCodeAt(0))) && Je({}, nn, yn), t += e);
         return t
     }
 
-    function Jne() {
+    function gne() {
         var e, t;
-        for (e = B++; B < yn;) {
-            if (t = ce.charCodeAt(B), t === 92) return B = e, K4();
-            if ($0(t)) ++B;
+        for (e = W++; W < Dn;) {
+            if (t = me.charCodeAt(W), t === 92) return W = e, FL();
+            if (u0(t)) ++W;
             else break
         }
-        return ce.slice(e, B)
+        return me.slice(e, W)
     }
 
-    function Qne() {
+    function pne() {
         var e, t, n;
-        return e = B, t = ce.charCodeAt(B) === 92 ? K4() : Jne(), t.length === 1 ? n = rl : Vne.hasOwnProperty(t) ? n = eo : t === "null" ? n = s1 : t === "true" || t === "false" ? n = r1 : n = rl, {
+        return e = W, t = me.charCodeAt(W) === 92 ? FL() : gne(), t.length === 1 ? n = Tl : hne.hasOwnProperty(t) ? n = _o : t === "null" ? n = L1 : t === "true" || t === "false" ? n = P1 : n = Tl, {
             type: n,
             value: t,
             start: e,
-            end: B
+            end: W
         }
     }
 
-    function pv() {
-        var e = B,
-            t = ce.charCodeAt(B),
-            n, i = ce[B],
+    function Wv() {
+        var e = W,
+            t = me.charCodeAt(W),
+            n, i = me[W],
             r, s, a;
         switch (t) {
             case 46:
             case 40:
             case 41:
             case 59:
             case 44:
             case 123:
             case 125:
             case 91:
             case 93:
             case 58:
             case 63:
             case 126:
-                return ++B, {
-                    type: Wn,
+                return ++W, {
+                    type: ti,
                     value: String.fromCharCode(t),
                     start: e,
-                    end: B
+                    end: W
                 };
             default:
-                if (n = ce.charCodeAt(B + 1), n === 61) switch (t) {
+                if (n = me.charCodeAt(W + 1), n === 61) switch (t) {
                     case 43:
                     case 45:
                     case 47:
                     case 60:
                     case 62:
                     case 94:
                     case 124:
                     case 37:
                     case 38:
                     case 42:
-                        return B += 2, {
-                            type: Wn,
+                        return W += 2, {
+                            type: ti,
                             value: String.fromCharCode(t) + String.fromCharCode(n),
                             start: e,
-                            end: B
+                            end: W
                         };
                     case 33:
                     case 61:
-                        return B += 2, ce.charCodeAt(B) === 61 && ++B, {
-                            type: Wn,
-                            value: ce.slice(e, B),
+                        return W += 2, me.charCodeAt(W) === 61 && ++W, {
+                            type: ti,
+                            value: me.slice(e, W),
                             start: e,
-                            end: B
+                            end: W
                         }
                 }
         }
-        if (a = ce.substr(B, 4), a === ">>>=") return B += 4, {
-            type: Wn,
+        if (a = me.substr(W, 4), a === ">>>=") return W += 4, {
+            type: ti,
             value: a,
             start: e,
-            end: B
+            end: W
         };
-        if (s = a.substr(0, 3), s === ">>>" || s === "<<=" || s === ">>=") return B += 3, {
-            type: Wn,
+        if (s = a.substr(0, 3), s === ">>>" || s === "<<=" || s === ">>=") return W += 3, {
+            type: ti,
             value: s,
             start: e,
-            end: B
+            end: W
         };
-        if (r = s.substr(0, 2), i === r[1] && "+-<>&|".indexOf(i) >= 0 || r === "=>") return B += 2, {
-            type: Wn,
+        if (r = s.substr(0, 2), i === r[1] && "+-<>&|".indexOf(i) >= 0 || r === "=>") return W += 2, {
+            type: ti,
             value: r,
             start: e,
-            end: B
+            end: W
         };
-        if (r === "//" && Ue({}, Bt, Kt), "<>=!+-*%&|^/".indexOf(i) >= 0) return ++B, {
-            type: Wn,
+        if (r === "//" && Je({}, nn, yn), "<>=!+-*%&|^/".indexOf(i) >= 0) return ++W, {
+            type: ti,
             value: i,
             start: e,
-            end: B
+            end: W
         };
-        Ue({}, Bt, Kt)
+        Je({}, nn, yn)
     }
 
-    function Zne(e) {
+    function mne(e) {
         let t = "";
-        for (; B < yn && IS(ce[B]);) t += ce[B++];
-        return t.length === 0 && Ue({}, Bt, Kt), Ed(ce.charCodeAt(B)) && Ue({}, Bt, Kt), {
-            type: Ol,
+        for (; W < Dn && AE(me[W]);) t += me[W++];
+        return t.length === 0 && Je({}, nn, yn), Zd(me.charCodeAt(W)) && Je({}, nn, yn), {
+            type: Jl,
             value: parseInt("0x" + t, 16),
             start: e,
-            end: B
+            end: W
         }
     }
 
-    function eie(e) {
-        let t = "0" + ce[B++];
-        for (; B < yn && sh(ce[B]);) t += ce[B++];
-        return (Ed(ce.charCodeAt(B)) || xs(ce.charCodeAt(B))) && Ue({}, Bt, Kt), {
-            type: Ol,
+    function yne(e) {
+        let t = "0" + me[W++];
+        for (; W < Dn && Rh(me[W]);) t += me[W++];
+        return (Zd(me.charCodeAt(W)) || Ls(me.charCodeAt(W))) && Je({}, nn, yn), {
+            type: Jl,
             value: parseInt(t, 8),
             octal: !0,
             start: e,
-            end: B
+            end: W
         }
     }
 
-    function FT() {
+    function ZT() {
         var e, t, n;
-        if (n = ce[B], a1(xs(n.charCodeAt(0)) || n === ".", "Numeric literal must start with a decimal digit or a decimal point"), t = B, e = "", n !== ".") {
-            if (e = ce[B++], n = ce[B], e === "0") {
-                if (n === "x" || n === "X") return ++B, Zne(t);
-                if (sh(n)) return eie(t);
-                n && xs(n.charCodeAt(0)) && Ue({}, Bt, Kt)
+        if (n = me[W], I1(Ls(n.charCodeAt(0)) || n === ".", "Numeric literal must start with a decimal digit or a decimal point"), t = W, e = "", n !== ".") {
+            if (e = me[W++], n = me[W], e === "0") {
+                if (n === "x" || n === "X") return ++W, mne(t);
+                if (Rh(n)) return yne(t);
+                n && Ls(n.charCodeAt(0)) && Je({}, nn, yn)
             }
-            for (; xs(ce.charCodeAt(B));) e += ce[B++];
-            n = ce[B]
+            for (; Ls(me.charCodeAt(W));) e += me[W++];
+            n = me[W]
         }
         if (n === ".") {
-            for (e += ce[B++]; xs(ce.charCodeAt(B));) e += ce[B++];
-            n = ce[B]
+            for (e += me[W++]; Ls(me.charCodeAt(W));) e += me[W++];
+            n = me[W]
         }
         if (n === "e" || n === "E")
-            if (e += ce[B++], n = ce[B], (n === "+" || n === "-") && (e += ce[B++]), xs(ce.charCodeAt(B)))
-                for (; xs(ce.charCodeAt(B));) e += ce[B++];
-            else Ue({}, Bt, Kt);
-        return Ed(ce.charCodeAt(B)) && Ue({}, Bt, Kt), {
-            type: Ol,
+            if (e += me[W++], n = me[W], (n === "+" || n === "-") && (e += me[W++]), Ls(me.charCodeAt(W)))
+                for (; Ls(me.charCodeAt(W));) e += me[W++];
+            else Je({}, nn, yn);
+        return Zd(me.charCodeAt(W)) && Je({}, nn, yn), {
+            type: Jl,
             value: parseFloat(e),
             start: t,
-            end: B
+            end: W
         }
     }
 
-    function tie() {
+    function vne() {
         var e = "",
             t, n, i, r, s = !1;
-        for (t = ce[B], a1(t === "'" || t === '"', "String literal must starts with a quote"), n = B, ++B; B < yn;)
-            if (i = ce[B++], i === t) {
+        for (t = me[W], I1(t === "'" || t === '"', "String literal must starts with a quote"), n = W, ++W; W < Dn;)
+            if (i = me[W++], i === t) {
                 t = "";
                 break
             } else if (i === "\\")
-            if (i = ce[B++], !i || !Fh(i.charCodeAt(0))) switch (i) {
+            if (i = me[W++], !i || !od(i.charCodeAt(0))) switch (i) {
                 case "u":
                 case "x":
-                    ce[B] === "{" ? (++B, e += Kne()) : e += M2(i);
+                    me[W] === "{" ? (++W, e += dne()) : e += ox(i);
                     break;
                 case "n":
                     e += `
 `;
                     break;
                 case "r":
                     e += "\r";
@@ -30176,290 +23413,290 @@
                 case "f":
                     e += "\f";
                     break;
                 case "v":
                     e += "\v";
                     break;
                 default:
-                    sh(i) ? (r = "01234567".indexOf(i), r !== 0 && (s = !0), B < yn && sh(ce[B]) && (s = !0, r = r * 8 + "01234567".indexOf(ce[B++]), "0123".indexOf(i) >= 0 && B < yn && sh(ce[B]) && (r = r * 8 + "01234567".indexOf(ce[B++]))), e += String.fromCharCode(r)) : e += i;
+                    Rh(i) ? (r = "01234567".indexOf(i), r !== 0 && (s = !0), W < Dn && Rh(me[W]) && (s = !0, r = r * 8 + "01234567".indexOf(me[W++]), "0123".indexOf(i) >= 0 && W < Dn && Rh(me[W]) && (r = r * 8 + "01234567".indexOf(me[W++]))), e += String.fromCharCode(r)) : e += i;
                     break
-            } else i === "\r" && ce[B] === `
-` && ++B;
+            } else i === "\r" && me[W] === `
+` && ++W;
             else {
-                if (Fh(i.charCodeAt(0))) break;
+                if (od(i.charCodeAt(0))) break;
                 e += i
-            } return t !== "" && Ue({}, Bt, Kt), {
-            type: Sd,
+            } return t !== "" && Je({}, nn, yn), {
+            type: Qd,
             value: e,
             octal: s,
             start: n,
-            end: B
+            end: W
         }
     }
 
-    function nie(e, t) {
+    function bne(e, t) {
         let n = e;
         t.indexOf("u") >= 0 && (n = n.replace(/\\u\{([0-9a-fA-F]+)\}/g, (i, r) => {
             if (parseInt(r, 16) <= 1114111) return "x";
-            Ue({}, T2)
+            Je({}, ax)
         }).replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, "x"));
         try {
             new RegExp(n)
         } catch {
-            Ue({}, T2)
+            Je({}, ax)
         }
         try {
             return new RegExp(e, t)
         } catch {
             return null
         }
     }
 
-    function iie() {
+    function xne() {
         var e, t, n, i, r;
-        for (e = ce[B], a1(e === "/", "Regular expression literal must start with a slash"), t = ce[B++], n = !1, i = !1; B < yn;)
-            if (e = ce[B++], t += e, e === "\\") e = ce[B++], Fh(e.charCodeAt(0)) && Ue({}, gv), t += e;
-            else if (Fh(e.charCodeAt(0))) Ue({}, gv);
+        for (e = me[W], I1(e === "/", "Regular expression literal must start with a slash"), t = me[W++], n = !1, i = !1; W < Dn;)
+            if (e = me[W++], t += e, e === "\\") e = me[W++], od(e.charCodeAt(0)) && Je({}, Uv), t += e;
+            else if (od(e.charCodeAt(0))) Je({}, Uv);
         else if (n) e === "]" && (n = !1);
         else if (e === "/") {
             i = !0;
             break
         } else e === "[" && (n = !0);
-        return i || Ue({}, gv), r = t.substr(1, t.length - 2), {
+        return i || Je({}, Uv), r = t.substr(1, t.length - 2), {
             value: r,
             literal: t
         }
     }
 
-    function rie() {
+    function _ne() {
         var e, t, n;
-        for (t = "", n = ""; B < yn && (e = ce[B], !!$0(e.charCodeAt(0)));) ++B, e === "\\" && B < yn ? Ue({}, Bt, Kt) : (n += e, t += e);
-        return n.search(/[^gimuy]/g) >= 0 && Ue({}, T2, n), {
+        for (t = "", n = ""; W < Dn && (e = me[W], !!u0(e.charCodeAt(0)));) ++W, e === "\\" && W < Dn ? Je({}, nn, yn) : (n += e, t += e);
+        return n.search(/[^gimuy]/g) >= 0 && Je({}, ax, n), {
             value: n,
             literal: t
         }
     }
 
-    function sie() {
+    function wne() {
         var e, t, n, i;
-        return Qe = null, V4(), e = B, t = iie(), n = rie(), i = nie(t.value, n.value), {
+        return ot = null, OL(), e = W, t = xne(), n = _ne(), i = bne(t.value, n.value), {
             literal: t.literal + n.literal,
             value: i,
             regex: {
                 pattern: t.value,
                 flags: n.value
             },
             start: e,
-            end: B
+            end: W
         }
     }
 
-    function aie(e) {
-        return e.type === rl || e.type === eo || e.type === r1 || e.type === s1
+    function Sne(e) {
+        return e.type === Tl || e.type === _o || e.type === P1 || e.type === L1
     }
 
-    function J4() {
-        if (V4(), B >= yn) return {
-            type: wd,
-            start: B,
-            end: B
+    function RL() {
+        if (OL(), W >= Dn) return {
+            type: Jd,
+            start: W,
+            end: W
         };
-        const e = ce.charCodeAt(B);
-        return Ed(e) ? Qne() : e === 40 || e === 41 || e === 59 ? pv() : e === 39 || e === 34 ? tie() : e === 46 ? xs(ce.charCodeAt(B + 1)) ? FT() : pv() : xs(e) ? FT() : pv()
+        const e = me.charCodeAt(W);
+        return Zd(e) ? pne() : e === 40 || e === 41 || e === 59 ? Wv() : e === 39 || e === 34 ? vne() : e === 46 ? Ls(me.charCodeAt(W + 1)) ? ZT() : Wv() : Ls(e) ? ZT() : Wv()
     }
 
-    function Xn() {
-        const e = Qe;
-        return B = e.end, Qe = J4(), B = e.end, e
+    function si() {
+        const e = ot;
+        return W = e.end, ot = RL(), W = e.end, e
     }
 
-    function Q4() {
-        const e = B;
-        Qe = J4(), B = e
+    function DL() {
+        const e = W;
+        ot = RL(), W = e
     }
 
-    function oie(e) {
-        const t = new yr(Mne);
+    function Ene(e) {
+        const t = new Or(Yte);
         return t.elements = e, t
     }
 
-    function RT(e, t, n) {
-        const i = new yr(e === "||" || e === "&&" ? Nne : One);
+    function e5(e, t, n) {
+        const i = new Or(e === "||" || e === "&&" ? Qte : Xte);
         return i.operator = e, i.left = t, i.right = n, i
     }
 
-    function lie(e, t) {
-        const n = new yr(Fne);
+    function kne(e, t) {
+        const n = new Or(Vte);
         return n.callee = e, n.arguments = t, n
     }
 
-    function uie(e, t, n) {
-        const i = new yr(Rne);
+    function Cne(e, t, n) {
+        const i = new Or(Kte);
         return i.test = e, i.consequent = t, i.alternate = n, i
     }
 
-    function zS(e) {
-        const t = new yr(Y4);
+    function $E(e) {
+        const t = new Or(TL);
         return t.name = e, t
     }
 
-    function Uf(e) {
-        const t = new yr(Dne);
-        return t.value = e.value, t.raw = ce.slice(e.start, e.end), e.regex && (t.raw === "//" && (t.raw = "/(?:)/"), t.regex = e.regex), t
+    function dh(e) {
+        const t = new Or(Jte);
+        return t.value = e.value, t.raw = me.slice(e.start, e.end), e.regex && (t.raw === "//" && (t.raw = "/(?:)/"), t.regex = e.regex), t
     }
 
-    function DT(e, t, n) {
-        const i = new yr(Pne);
+    function t5(e, t, n) {
+        const i = new Or(Zte);
         return i.computed = e === "[", i.object = t, i.property = n, i.computed || (n.member = !0), i
     }
 
-    function cie(e) {
-        const t = new yr(Lne);
+    function Ane(e) {
+        const t = new Or(ene);
         return t.properties = e, t
     }
 
-    function NT(e, t, n) {
-        const i = new yr(Ine);
+    function n5(e, t, n) {
+        const i = new Or(tne);
         return i.key = t, i.value = n, i.kind = e, i
     }
 
-    function fie(e, t) {
-        const n = new yr(zne);
+    function $ne(e, t) {
+        const n = new Or(nne);
         return n.operator = e, n.argument = t, n.prefix = !0, n
     }
 
-    function Ue(e, t) {
+    function Je(e, t) {
         var n, i = Array.prototype.slice.call(arguments, 2),
-            r = t.replace(/%(\d)/g, (s, a) => (a1(a < i.length, "Message reference must be in range"), i[a]));
-        throw n = new Error(r), n.index = B, n.description = r, n
+            r = t.replace(/%(\d)/g, (s, a) => (I1(a < i.length, "Message reference must be in range"), i[a]));
+        throw n = new Error(r), n.index = W, n.description = r, n
     }
 
-    function o1(e) {
-        e.type === wd && Ue(e, Wne), e.type === Ol && Ue(e, Bne), e.type === Sd && Ue(e, jne), e.type === rl && Ue(e, Une), e.type === eo && Ue(e, Gne), Ue(e, Bt, e.value)
+    function z1(e) {
+        e.type === Jd && Je(e, one), e.type === Jl && Je(e, ine), e.type === Qd && Je(e, rne), e.type === Tl && Je(e, sne), e.type === _o && Je(e, ane), Je(e, nn, e.value)
     }
 
-    function vn(e) {
-        const t = Xn();
-        (t.type !== Wn || t.value !== e) && o1(t)
+    function Nn(e) {
+        const t = si();
+        (t.type !== ti || t.value !== e) && z1(t)
     }
 
-    function lt(e) {
-        return Qe.type === Wn && Qe.value === e
+    function vt(e) {
+        return ot.type === ti && ot.value === e
     }
 
-    function mv(e) {
-        return Qe.type === eo && Qe.value === e
+    function qv(e) {
+        return ot.type === _o && ot.value === e
     }
 
-    function hie() {
+    function Tne() {
         const e = [];
-        for (B = Qe.start, vn("["); !lt("]");) lt(",") ? (Xn(), e.push(null)) : (e.push(sl()), lt("]") || vn(","));
-        return Xn(), oie(e)
+        for (W = ot.start, Nn("["); !vt("]");) vt(",") ? (si(), e.push(null)) : (e.push(Ml()), vt("]") || Nn(","));
+        return si(), Ene(e)
     }
 
-    function PT() {
-        B = Qe.start;
-        const e = Xn();
-        return e.type === Sd || e.type === Ol ? (e.octal && Ue(e, X4), Uf(e)) : zS(e.value)
+    function i5() {
+        W = ot.start;
+        const e = si();
+        return e.type === Qd || e.type === Jl ? (e.octal && Je(e, ML), dh(e)) : $E(e.value)
     }
 
-    function die() {
+    function Mne() {
         var e, t, n, i;
-        if (B = Qe.start, e = Qe, e.type === rl) return n = PT(), vn(":"), i = sl(), NT("init", n, i);
-        if (e.type === wd || e.type === Wn) o1(e);
-        else return t = PT(), vn(":"), i = sl(), NT("init", t, i)
+        if (W = ot.start, e = ot, e.type === Tl) return n = i5(), Nn(":"), i = Ml(), n5("init", n, i);
+        if (e.type === Jd || e.type === ti) z1(e);
+        else return t = i5(), Nn(":"), i = Ml(), n5("init", t, i)
     }
 
-    function gie() {
+    function One() {
         var e = [],
             t, n, i, r = {},
             s = String;
-        for (B = Qe.start, vn("{"); !lt("}");) t = die(), t.key.type === Y4 ? n = t.key.name : n = s(t.key.value), i = "$" + n, Object.prototype.hasOwnProperty.call(r, i) ? Ue({}, qne) : r[i] = !0, e.push(t), lt("}") || vn(",");
-        return vn("}"), cie(e)
+        for (W = ot.start, Nn("{"); !vt("}");) t = Mne(), t.key.type === TL ? n = t.key.name : n = s(t.key.value), i = "$" + n, Object.prototype.hasOwnProperty.call(r, i) ? Je({}, lne) : r[i] = !0, e.push(t), vt("}") || Nn(",");
+        return Nn("}"), Ane(e)
     }
 
-    function pie() {
-        vn("(");
-        const e = BS();
-        return vn(")"), e
+    function Fne() {
+        Nn("(");
+        const e = TE();
+        return Nn(")"), e
     }
-    const mie = {
+    const Rne = {
         if: 1
     };
 
-    function yie() {
+    function Dne() {
         var e, t, n;
-        if (lt("(")) return pie();
-        if (lt("[")) return hie();
-        if (lt("{")) return gie();
-        if (e = Qe.type, B = Qe.start, e === rl || mie[Qe.value]) n = zS(Xn().value);
-        else if (e === Sd || e === Ol) Qe.octal && Ue(Qe, X4), n = Uf(Xn());
+        if (vt("(")) return Fne();
+        if (vt("[")) return Tne();
+        if (vt("{")) return One();
+        if (e = ot.type, W = ot.start, e === Tl || Rne[ot.value]) n = $E(si().value);
+        else if (e === Qd || e === Jl) ot.octal && Je(ot, ML), n = dh(si());
         else {
-            if (e === eo) throw new Error(Oh);
-            e === r1 ? (t = Xn(), t.value = t.value === "true", n = Uf(t)) : e === s1 ? (t = Xn(), t.value = null, n = Uf(t)) : lt("/") || lt("/=") ? (n = Uf(sie()), Q4()) : o1(Xn())
+            if (e === _o) throw new Error(ad);
+            e === P1 ? (t = si(), t.value = t.value === "true", n = dh(t)) : e === L1 ? (t = si(), t.value = null, n = dh(t)) : vt("/") || vt("/=") ? (n = dh(wne()), DL()) : z1(si())
         }
         return n
     }
 
-    function vie() {
+    function Nne() {
         const e = [];
-        if (vn("("), !lt(")"))
-            for (; B < yn && (e.push(sl()), !lt(")"));) vn(",");
-        return vn(")"), e
+        if (Nn("("), !vt(")"))
+            for (; W < Dn && (e.push(Ml()), !vt(")"));) Nn(",");
+        return Nn(")"), e
     }
 
-    function bie() {
-        B = Qe.start;
-        const e = Xn();
-        return aie(e) || o1(e), zS(e.value)
+    function Pne() {
+        W = ot.start;
+        const e = si();
+        return Sne(e) || z1(e), $E(e.value)
     }
 
-    function xie() {
-        return vn("."), bie()
+    function Lne() {
+        return Nn("."), Pne()
     }
 
-    function _ie() {
-        vn("[");
-        const e = BS();
-        return vn("]"), e
+    function Ine() {
+        Nn("[");
+        const e = TE();
+        return Nn("]"), e
     }
 
-    function wie() {
+    function zne() {
         var e, t, n;
-        for (e = yie();;)
-            if (lt(".")) n = xie(), e = DT(".", e, n);
-            else if (lt("(")) t = vie(), e = lie(e, t);
-        else if (lt("[")) n = _ie(), e = DT("[", e, n);
+        for (e = Dne();;)
+            if (vt(".")) n = Lne(), e = t5(".", e, n);
+            else if (vt("(")) t = Nne(), e = kne(e, t);
+        else if (vt("[")) n = Ine(), e = t5("[", e, n);
         else break;
         return e
     }
 
-    function LT() {
-        const e = wie();
-        if (Qe.type === Wn && (lt("++") || lt("--"))) throw new Error(Oh);
+    function r5() {
+        const e = zne();
+        if (ot.type === ti && (vt("++") || vt("--"))) throw new Error(ad);
         return e
     }
 
-    function lp() {
+    function Ip() {
         var e, t;
-        if (Qe.type !== Wn && Qe.type !== eo) t = LT();
+        if (ot.type !== ti && ot.type !== _o) t = r5();
         else {
-            if (lt("++") || lt("--")) throw new Error(Oh);
-            if (lt("+") || lt("-") || lt("~") || lt("!")) e = Xn(), t = lp(), t = fie(e.value, t);
+            if (vt("++") || vt("--")) throw new Error(ad);
+            if (vt("+") || vt("-") || vt("~") || vt("!")) e = si(), t = Ip(), t = $ne(e.value, t);
             else {
-                if (mv("delete") || mv("void") || mv("typeof")) throw new Error(Oh);
-                t = LT()
+                if (qv("delete") || qv("void") || qv("typeof")) throw new Error(ad);
+                t = r5()
             }
         }
         return t
     }
 
-    function IT(e) {
+    function s5(e) {
         let t = 0;
-        if (e.type !== Wn && e.type !== eo) return 0;
+        if (e.type !== ti && e.type !== _o) return 0;
         switch (e.value) {
             case "||":
                 t = 1;
                 break;
             case "&&":
                 t = 2;
                 break;
@@ -30500,58 +23737,58 @@
             case "%":
                 t = 11;
                 break
         }
         return t
     }
 
-    function Sie() {
+    function Bne() {
         var e, t, n, i, r, s, a, o, l, u;
-        if (e = Qe, l = lp(), i = Qe, r = IT(i), r === 0) return l;
-        for (i.prec = r, Xn(), t = [e, Qe], a = lp(), s = [l, i, a];
-            (r = IT(Qe)) > 0;) {
-            for (; s.length > 2 && r <= s[s.length - 2].prec;) a = s.pop(), o = s.pop().value, l = s.pop(), t.pop(), n = RT(o, l, a), s.push(n);
-            i = Xn(), i.prec = r, s.push(i), t.push(Qe), n = lp(), s.push(n)
+        if (e = ot, l = Ip(), i = ot, r = s5(i), r === 0) return l;
+        for (i.prec = r, si(), t = [e, ot], a = Ip(), s = [l, i, a];
+            (r = s5(ot)) > 0;) {
+            for (; s.length > 2 && r <= s[s.length - 2].prec;) a = s.pop(), o = s.pop().value, l = s.pop(), t.pop(), n = e5(o, l, a), s.push(n);
+            i = si(), i.prec = r, s.push(i), t.push(ot), n = Ip(), s.push(n)
         }
-        for (u = s.length - 1, n = s[u], t.pop(); u > 1;) t.pop(), n = RT(s[u - 1].value, s[u - 2], n), u -= 2;
+        for (u = s.length - 1, n = s[u], t.pop(); u > 1;) t.pop(), n = e5(s[u - 1].value, s[u - 2], n), u -= 2;
         return n
     }
 
-    function sl() {
+    function Ml() {
         var e, t, n;
-        return e = Sie(), lt("?") && (Xn(), t = sl(), vn(":"), n = sl(), e = uie(e, t, n)), e
+        return e = Bne(), vt("?") && (si(), t = Ml(), Nn(":"), n = Ml(), e = Cne(e, t, n)), e
     }
 
-    function BS() {
-        const e = sl();
-        if (lt(",")) throw new Error(Oh);
+    function TE() {
+        const e = Ml();
+        if (vt(",")) throw new Error(ad);
         return e
     }
 
-    function jS(e) {
-        ce = e, B = 0, yn = ce.length, Qe = null, Q4();
-        const t = BS();
-        if (Qe.type !== wd) throw new Error("Unexpect token after expression.");
+    function ME(e) {
+        me = e, W = 0, Dn = me.length, ot = null, DL();
+        const t = TE();
+        if (ot.type !== Jd) throw new Error("Unexpect token after expression.");
         return t
     }
-    var Z4 = {
+    var NL = {
         NaN: "NaN",
         E: "Math.E",
         LN2: "Math.LN2",
         LN10: "Math.LN10",
         LOG2E: "Math.LOG2E",
         LOG10E: "Math.LOG10E",
         PI: "Math.PI",
         SQRT1_2: "Math.SQRT1_2",
         SQRT2: "Math.SQRT2",
         MIN_VALUE: "Number.MIN_VALUE",
         MAX_VALUE: "Number.MAX_VALUE"
     };
 
-    function eL(e) {
+    function PL(e) {
         function t(a, o, l, u) {
             let c = e(o[0]);
             return l && (c = l + "(" + c + ")", l.lastIndexOf("new ", 0) === 0 && (c = "(" + c + ")")), c + "." + a + (u < 0 ? "" : u === 0 ? "()" : "(" + o.slice(1).map(e).join(",") + ")")
         }
 
         function n(a, o, l) {
             return u => t(a, u, o, l)
@@ -30578,15 +23815,15 @@
             pow: "Math.pow",
             random: "Math.random",
             round: "Math.round",
             sin: "Math.sin",
             sqrt: "Math.sqrt",
             tan: "Math.tan",
             clamp: function(a) {
-                a.length < 3 && U("Missing arguments to clamp function."), a.length > 3 && U("Too many arguments to clamp function.");
+                a.length < 3 && q("Missing arguments to clamp function."), a.length > 3 && q("Too many arguments to clamp function.");
                 const o = a.map(e);
                 return "Math.max(" + o[1] + ", Math.min(" + o[2] + "," + o[0] + "))"
             },
             now: "Date.now",
             utc: "Date.UTC",
             datetime: i,
             date: n("getDate", i, 0),
@@ -30614,63 +23851,63 @@
             lower: n("toLowerCase", r, 0),
             substring: n("substring", r),
             split: n("split", r),
             trim: n("trim", r, 0),
             regexp: s,
             test: n("test", s),
             if: function(a) {
-                a.length < 3 && U("Missing arguments to if function."), a.length > 3 && U("Too many arguments to if function.");
+                a.length < 3 && q("Missing arguments to if function."), a.length > 3 && q("Too many arguments to if function.");
                 const o = a.map(e);
                 return "(" + o[0] + "?" + o[1] + ":" + o[2] + ")"
             }
         }
     }
 
-    function Eie(e) {
+    function jne(e) {
         const t = e && e.length - 1;
         return t && (e[0] === '"' && e[t] === '"' || e[0] === "'" && e[t] === "'") ? e.slice(1, -1) : e
     }
 
-    function tL(e) {
+    function LL(e) {
         e = e || {};
-        const t = e.allowed ? fr(e.allowed) : {},
-            n = e.forbidden ? fr(e.forbidden) : {},
-            i = e.constants || Z4,
-            r = (e.functions || eL)(f),
+        const t = e.allowed ? Cr(e.allowed) : {},
+            n = e.forbidden ? Cr(e.forbidden) : {},
+            i = e.constants || NL,
+            r = (e.functions || PL)(f),
             s = e.globalvar,
             a = e.fieldvar,
-            o = $e(s) ? s : g => `${s}["${g}"]`;
+            o = Pe(s) ? s : g => `${s}["${g}"]`;
         let l = {},
             u = {},
             c = 0;
 
         function f(g) {
-            if (re(g)) return g;
+            if (le(g)) return g;
             const p = h[g.type];
-            return p == null && U("Unsupported type: " + g.type), p(g)
+            return p == null && q("Unsupported type: " + g.type), p(g)
         }
         const h = {
             Literal: g => g.raw,
             Identifier: g => {
                 const p = g.name;
-                return c > 0 ? p : me(n, p) ? U("Illegal identifier: " + p) : me(i, p) ? i[p] : me(t, p) ? p : (l[p] = 1, o(p))
+                return c > 0 ? p : Ce(n, p) ? q("Illegal identifier: " + p) : Ce(i, p) ? i[p] : Ce(t, p) ? p : (l[p] = 1, o(p))
             },
             MemberExpression: g => {
                 const p = !g.computed,
                     m = f(g.object);
                 p && (c += 1);
                 const y = f(g.property);
-                return m === a && (u[Eie(y)] = 1), p && (c -= 1), m + (p ? "." + y : "[" + y + "]")
+                return m === a && (u[jne(y)] = 1), p && (c -= 1), m + (p ? "." + y : "[" + y + "]")
             },
             CallExpression: g => {
-                g.callee.type !== "Identifier" && U("Illegal callee type: " + g.callee.type);
+                g.callee.type !== "Identifier" && q("Illegal callee type: " + g.callee.type);
                 const p = g.callee.name,
                     m = g.arguments,
-                    y = me(r, p) && r[p];
-                return y || U("Unrecognized function: " + p), $e(y) ? y(m) : y + "(" + m.map(f).join(",") + ")"
+                    y = Ce(r, p) && r[p];
+                return y || q("Unrecognized function: " + p), Pe(y) ? y(m) : y + "(" + m.map(f).join(",") + ")"
             },
             ArrayExpression: g => "[" + g.elements.map(f).join(",") + "]",
             BinaryExpression: g => "(" + f(g.left) + " " + g.operator + " " + f(g.right) + ")",
             UnaryExpression: g => "(" + g.operator + f(g.argument) + ")",
             ConditionalExpression: g => "(" + f(g.test) + "?" + f(g.consequent) + ":" + f(g.alternate) + ")",
             LogicalExpression: g => "(" + f(g.left) + g.operator + f(g.right) + ")",
             ObjectExpression: g => "{" + g.properties.map(f).join(",") + "}",
@@ -30688,25 +23925,25 @@
                 fields: Object.keys(u)
             };
             return l = {}, u = {}, p
         }
         return d.functions = r, d.constants = i, d
     }
 
-    function yv(e, t) {
+    function Hv(e, t) {
         return e == null || t == null ? NaN : e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN
     }
 
-    function Cie(e, t) {
+    function Gne(e, t) {
         return e == null || t == null ? NaN : t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN
     }
 
-    function kie(e) {
+    function Une(e) {
         let t, n, i;
-        e.length !== 2 ? (t = yv, n = (o, l) => yv(e(o), l), i = (o, l) => e(o) - l) : (t = e === yv || e === Cie ? e : Aie, n = e, i = e);
+        e.length !== 2 ? (t = Hv, n = (o, l) => Hv(e(o), l), i = (o, l) => e(o) - l) : (t = e === Hv || e === Gne ? e : Wne, n = e, i = e);
 
         function r(o, l, u = 0, c = o.length) {
             if (u < c) {
                 if (t(l, l) !== 0) return c;
                 do {
                     const f = u + c >>> 1;
                     n(o[f], l) < 0 ? u = f + 1 : c = f
@@ -30733,969 +23970,969 @@
         return {
             left: r,
             center: a,
             right: s
         }
     }
 
-    function Aie() {
+    function Wne() {
         return 0
     }
 
-    function $ie(e, ...t) {
-        e = new Sp(e), t = t.map(Tie);
+    function qne(e, ...t) {
+        e = new im(e), t = t.map(Hne);
         e: for (const n of e)
             for (const i of t)
                 if (!i.has(n)) {
                     e.delete(n);
                     continue e
                 }
         return e
     }
 
-    function Tie(e) {
-        return e instanceof Sp ? e : new Sp(e)
+    function Hne(e) {
+        return e instanceof im ? e : new im(e)
     }
 
-    function Mie(...e) {
-        const t = new Sp;
+    function Yne(...e) {
+        const t = new im;
         for (const n of e)
             for (const i of n) t.add(i);
         return t
     }
-    const US = "intersect",
-        zT = "union",
-        Oie = "vlMulti",
-        Fie = "vlPoint",
-        BT = "or",
-        Rie = "and",
-        Or = "_vgsid_",
-        Rh = ni(Or),
-        Die = "E",
-        Nie = "R",
-        Pie = "R-E",
-        Lie = "R-LE",
-        Iie = "R-RE",
-        T0 = "index:unit";
+    const OE = "intersect",
+        a5 = "union",
+        Xne = "vlMulti",
+        Vne = "vlPoint",
+        o5 = "or",
+        Kne = "and",
+        Yr = "_vgsid_",
+        ld = fi(Yr),
+        Jne = "E",
+        Qne = "R",
+        Zne = "R-E",
+        eie = "R-LE",
+        tie = "R-RE",
+        c0 = "index:unit";
 
-    function jT(e, t) {
+    function l5(e, t) {
         for (var n = t.fields, i = t.values, r = n.length, s = 0, a, o; s < r; ++s)
-            if (o = n[s], o.getter = ni.getter || ni(o.field), a = o.getter(e), Ea(a) && (a = hn(a)), Ea(i[s]) && (i[s] = hn(i[s])), Ea(i[s][0]) && (i[s] = i[s].map(hn)), o.type === Die) {
-                if (W(i[s]) ? i[s].indexOf(a) < 0 : a !== i[s]) return !1
-            } else if (o.type === Nie) {
-            if (!hu(a, i[s])) return !1
-        } else if (o.type === Iie) {
-            if (!hu(a, i[s], !0, !1)) return !1
-        } else if (o.type === Pie) {
-            if (!hu(a, i[s], !1, !1)) return !1
-        } else if (o.type === Lie && !hu(a, i[s], !1, !0)) return !1;
+            if (o = n[s], o.getter = fi.getter || fi(o.field), a = o.getter(e), Ua(a) && (a = Tn(a)), Ua(i[s]) && (i[s] = Tn(i[s])), Ua(i[s][0]) && (i[s] = i[s].map(Tn)), o.type === Jne) {
+                if (H(i[s]) ? i[s].indexOf(a) < 0 : a !== i[s]) return !1
+            } else if (o.type === Qne) {
+            if (!Pu(a, i[s])) return !1
+        } else if (o.type === tie) {
+            if (!Pu(a, i[s], !0, !1)) return !1
+        } else if (o.type === Zne) {
+            if (!Pu(a, i[s], !1, !1)) return !1
+        } else if (o.type === eie && !Pu(a, i[s], !1, !0)) return !1;
         return !0
     }
 
-    function zie(e, t, n) {
-        for (var i = this.context.data[e], r = i ? i.values.value : [], s = i ? i[T0] && i[T0].value : void 0, a = n === US, o = r.length, l = 0, u, c, f, h, d; l < o; ++l)
+    function nie(e, t, n) {
+        for (var i = this.context.data[e], r = i ? i.values.value : [], s = i ? i[c0] && i[c0].value : void 0, a = n === OE, o = r.length, l = 0, u, c, f, h, d; l < o; ++l)
             if (u = r[l], s && a) {
                 if (c = c || {}, f = c[h = u.unit] || 0, f === -1) continue;
-                if (d = jT(t, u), c[h] = d ? -1 : ++f, d && s.size === 1) return !0;
+                if (d = l5(t, u), c[h] = d ? -1 : ++f, d && s.size === 1) return !0;
                 if (!d && f === s.get(h).count) return !1
-            } else if (d = jT(t, u), a ^ d) return d;
+            } else if (d = l5(t, u), a ^ d) return d;
         return o && a
     }
-    const nL = kie(Rh),
-        Bie = nL.left,
-        jie = nL.right;
+    const IL = Une(ld),
+        iie = IL.left,
+        rie = IL.right;
 
-    function Uie(e, t, n) {
+    function sie(e, t, n) {
         const i = this.context.data[e],
             r = i ? i.values.value : [],
-            s = i ? i[T0] && i[T0].value : void 0,
-            a = n === US,
-            o = Rh(t),
-            l = Bie(r, o);
-        if (l === r.length || Rh(r[l]) !== o) return !1;
+            s = i ? i[c0] && i[c0].value : void 0,
+            a = n === OE,
+            o = ld(t),
+            l = iie(r, o);
+        if (l === r.length || ld(r[l]) !== o) return !1;
         if (s && a) {
             if (s.size === 1) return !0;
-            if (jie(r, o) - l < s.size) return !1
+            if (rie(r, o) - l < s.size) return !1
         }
         return !0
     }
 
-    function Gie(e, t) {
-        return e.map(n => Ae(t.fields ? {
-            values: t.fields.map(i => (i.getter || (i.getter = ni(i.field)))(n.datum))
+    function aie(e, t) {
+        return e.map(n => Ne(t.fields ? {
+            values: t.fields.map(i => (i.getter || (i.getter = fi(i.field)))(n.datum))
         } : {
-            [Or]: Rh(n.datum)
+            [Yr]: ld(n.datum)
         }, t))
     }
 
-    function Wie(e, t, n, i) {
+    function oie(e, t, n, i) {
         for (var r = this.context.data[e], s = r ? r.values.value : [], a = {}, o = {}, l = {}, u, c, f, h, d, g, p, m, y, v, b = s.length, x = 0, _, S; x < b; ++x)
             if (u = s[x], h = u.unit, c = u.fields, f = u.values, c && f) {
-                for (_ = 0, S = c.length; _ < S; ++_) d = c[_], p = a[d.field] || (a[d.field] = {}), m = p[h] || (p[h] = []), l[d.field] = y = d.type.charAt(0), v = vv[`${y}_union`], p[h] = v(m, se(f[_]));
-                n && (m = o[h] || (o[h] = []), m.push(se(f).reduce((w, E, A) => (w[c[A].field] = E, w), {})))
-            } else d = Or, g = Rh(u), p = a[d] || (a[d] = {}), m = p[h] || (p[h] = []), m.push(g), n && (m = o[h] || (o[h] = []), m.push({
-                [Or]: g
+                for (_ = 0, S = c.length; _ < S; ++_) d = c[_], p = a[d.field] || (a[d.field] = {}), m = p[h] || (p[h] = []), l[d.field] = y = d.type.charAt(0), v = Yv[`${y}_union`], p[h] = v(m, ue(f[_]));
+                n && (m = o[h] || (o[h] = []), m.push(ue(f).reduce((w, E, C) => (w[c[C].field] = E, w), {})))
+            } else d = Yr, g = ld(u), p = a[d] || (a[d] = {}), m = p[h] || (p[h] = []), m.push(g), n && (m = o[h] || (o[h] = []), m.push({
+                [Yr]: g
             }));
-        if (t = t || zT, a[Or] ? a[Or] = vv[`${Or}_${t}`](...Object.values(a[Or])) : Object.keys(a).forEach(w => {
-                a[w] = Object.keys(a[w]).map(E => a[w][E]).reduce((E, A) => E === void 0 ? A : vv[`${l[w]}_${t}`](E, A))
+        if (t = t || a5, a[Yr] ? a[Yr] = Yv[`${Yr}_${t}`](...Object.values(a[Yr])) : Object.keys(a).forEach(w => {
+                a[w] = Object.keys(a[w]).map(E => a[w][E]).reduce((E, C) => E === void 0 ? C : Yv[`${l[w]}_${t}`](E, C))
             }), s = Object.keys(o), n && s.length) {
-            const w = i ? Fie : Oie;
-            a[w] = t === zT ? {
-                [BT]: s.reduce((E, A) => (E.push(...o[A]), E), [])
+            const w = i ? Vne : Xne;
+            a[w] = t === a5 ? {
+                [o5]: s.reduce((E, C) => (E.push(...o[C]), E), [])
             } : {
-                [Rie]: s.map(E => ({
-                    [BT]: o[E]
+                [Kne]: s.map(E => ({
+                    [o5]: o[E]
                 }))
             }
         }
         return a
     }
-    var vv = {
-        [`${Or}_union`]: Mie,
-        [`${Or}_intersect`]: $ie,
+    var Yv = {
+        [`${Yr}_union`]: Yne,
+        [`${Yr}_intersect`]: qne,
         E_union: function(e, t) {
             if (!e.length) return t;
             for (var n = 0, i = t.length; n < i; ++n) e.indexOf(t[n]) < 0 && e.push(t[n]);
             return e
         },
         E_intersect: function(e, t) {
             return e.length ? e.filter(n => t.indexOf(n) >= 0) : t
         },
         R_union: function(e, t) {
-            var n = hn(t[0]),
-                i = hn(t[1]);
+            var n = Tn(t[0]),
+                i = Tn(t[1]);
             return n > i && (n = t[1], i = t[0]), e.length ? (e[0] > n && (e[0] = n), e[1] < i && (e[1] = i), e) : [n, i]
         },
         R_intersect: function(e, t) {
-            var n = hn(t[0]),
-                i = hn(t[1]);
+            var n = Tn(t[0]),
+                i = Tn(t[1]);
             return n > i && (n = t[1], i = t[0]), e.length ? i < e[0] || e[1] < n ? [] : (e[0] < n && (e[0] = n), e[1] > i && (e[1] = i), e) : [n, i]
         }
     };
-    const qie = ":",
-        Hie = "@";
+    const lie = ":",
+        uie = "@";
 
-    function GS(e, t, n, i) {
-        t[0].type !== il && U("First argument to selection functions must be a string literal.");
+    function FE(e, t, n, i) {
+        t[0].type !== $l && q("First argument to selection functions must be a string literal.");
         const r = t[0].value,
-            s = t.length >= 2 && De(t).value,
+            s = t.length >= 2 && We(t).value,
             a = "unit",
-            o = Hie + a,
-            l = qie + r;
-        s === US && !me(i, o) && (i[o] = n.getData(r).indataRef(n, a)), me(i, l) || (i[l] = n.getData(r).tuplesRef())
+            o = uie + a,
+            l = lie + r;
+        s === OE && !Ce(i, o) && (i[o] = n.getData(r).indataRef(n, a)), Ce(i, l) || (i[l] = n.getData(r).tuplesRef())
     }
 
-    function iL(e) {
+    function zL(e) {
         const t = this.context.data[e];
         return t ? t.values.value : []
     }
 
-    function Yie(e, t, n) {
+    function cie(e, t, n) {
         const i = this.context.data[e]["index:" + t],
             r = i ? i.value.get(n) : void 0;
         return r && r.count
     }
 
-    function Xie(e, t) {
+    function fie(e, t) {
         const n = this.context.dataflow,
             i = this.context.data[e],
             r = i.input;
-        return n.pulse(r, n.changeset().remove(Ri).insert(t)), 1
+        return n.pulse(r, n.changeset().remove(Yi).insert(t)), 1
     }
 
-    function Vie(e, t, n) {
+    function hie(e, t, n) {
         if (e) {
             const i = this.context.dataflow,
                 r = e.mark.source;
             i.pulse(r, i.changeset().encode(e, t))
         }
         return n !== void 0 ? n : e
     }
-    const Cd = e => function(t, n) {
+    const eg = e => function(t, n) {
             return this.context.dataflow.locale()[e](n)(t)
         },
-        Kie = Cd("format"),
-        rL = Cd("timeFormat"),
-        Jie = Cd("utcFormat"),
-        Qie = Cd("timeParse"),
-        Zie = Cd("utcParse"),
-        Eg = new Date(2e3, 0, 1);
+        die = eg("format"),
+        BL = eg("timeFormat"),
+        gie = eg("utcFormat"),
+        pie = eg("timeParse"),
+        mie = eg("utcParse"),
+        Wg = new Date(2e3, 0, 1);
 
-    function l1(e, t, n) {
-        return !Number.isInteger(e) || !Number.isInteger(t) ? "" : (Eg.setYear(2e3), Eg.setMonth(e), Eg.setDate(t), rL.call(this, Eg, n))
+    function B1(e, t, n) {
+        return !Number.isInteger(e) || !Number.isInteger(t) ? "" : (Wg.setYear(2e3), Wg.setMonth(e), Wg.setDate(t), BL.call(this, Wg, n))
     }
 
-    function ere(e) {
-        return l1.call(this, e, 1, "%B")
+    function yie(e) {
+        return B1.call(this, e, 1, "%B")
     }
 
-    function tre(e) {
-        return l1.call(this, e, 1, "%b")
+    function vie(e) {
+        return B1.call(this, e, 1, "%b")
     }
 
-    function nre(e) {
-        return l1.call(this, 0, 2 + e, "%A")
+    function bie(e) {
+        return B1.call(this, 0, 2 + e, "%A")
     }
 
-    function ire(e) {
-        return l1.call(this, 0, 2 + e, "%a")
+    function xie(e) {
+        return B1.call(this, 0, 2 + e, "%a")
     }
-    const rre = ":",
-        sre = "@",
-        O2 = "%",
-        sL = "$";
+    const _ie = ":",
+        wie = "@",
+        lx = "%",
+        jL = "$";
 
-    function WS(e, t, n, i) {
-        t[0].type !== il && U("First argument to data functions must be a string literal.");
+    function RE(e, t, n, i) {
+        t[0].type !== $l && q("First argument to data functions must be a string literal.");
         const r = t[0].value,
-            s = rre + r;
-        if (!me(s, i)) try {
+            s = _ie + r;
+        if (!Ce(s, i)) try {
             i[s] = n.getData(r).tuplesRef()
         } catch {}
     }
 
-    function are(e, t, n, i) {
-        t[0].type !== il && U("First argument to indata must be a string literal."), t[1].type !== il && U("Second argument to indata must be a string literal.");
+    function Sie(e, t, n, i) {
+        t[0].type !== $l && q("First argument to indata must be a string literal."), t[1].type !== $l && q("Second argument to indata must be a string literal.");
         const r = t[0].value,
             s = t[1].value,
-            a = sre + s;
-        me(a, i) || (i[a] = n.getData(r).indataRef(n, s))
+            a = wie + s;
+        Ce(a, i) || (i[a] = n.getData(r).indataRef(n, s))
     }
 
-    function Kn(e, t, n, i) {
-        if (t[0].type === il) UT(n, i, t[0].value);
+    function oi(e, t, n, i) {
+        if (t[0].type === $l) u5(n, i, t[0].value);
         else
-            for (e in n.scales) UT(n, i, e)
+            for (e in n.scales) u5(n, i, e)
     }
 
-    function UT(e, t, n) {
-        const i = O2 + n;
-        if (!me(t, i)) try {
+    function u5(e, t, n) {
+        const i = lx + n;
+        if (!Ce(t, i)) try {
             t[i] = e.scaleRef(n)
         } catch {}
     }
 
-    function Ys(e, t) {
-        if ($e(e)) return e;
-        if (re(e)) {
+    function oa(e, t) {
+        if (Pe(e)) return e;
+        if (le(e)) {
             const n = t.scales[e];
-            return n && $K(n.value) ? n.value : void 0
+            return n && TH(n.value) ? n.value : void 0
         }
     }
 
-    function ore(e, t, n) {
-        t.__bandwidth = r => r && r.bandwidth ? r.bandwidth() : 0, n._bandwidth = Kn, n._range = Kn, n._scale = Kn;
-        const i = r => "_[" + (r.type === il ? Z(O2 + r.value) : Z(O2) + "+" + e(r)) + "]";
+    function Eie(e, t, n) {
+        t.__bandwidth = r => r && r.bandwidth ? r.bandwidth() : 0, n._bandwidth = oi, n._range = oi, n._scale = oi;
+        const i = r => "_[" + (r.type === $l ? te(lx + r.value) : te(lx) + "+" + e(r)) + "]";
         return {
             _bandwidth: r => `this.__bandwidth(${i(r[0])})`,
             _range: r => `${i(r[0])}.range()`,
             _scale: r => `${i(r[0])}(${e(r[1])})`
         }
     }
 
-    function qS(e, t) {
+    function DE(e, t) {
         return function(n, i, r) {
             if (n) {
-                const s = Ys(n, (r || this).context);
+                const s = oa(n, (r || this).context);
                 return s && s.path[e](i)
             } else return t(i)
         }
     }
-    const lre = qS("area", ZU),
-        ure = qS("bounds", iG),
-        cre = qS("centroid", uG);
+    const kie = DE("area", UK),
+        Cie = DE("bounds", YK),
+        Aie = DE("centroid", ZK);
 
-    function fre(e) {
+    function $ie(e) {
         const t = this.context.group;
         let n = !1;
         if (t)
             for (; e;) {
                 if (e === t) {
                     n = !0;
                     break
                 }
                 e = e.mark.group
             }
         return n
     }
 
-    function HS(e, t, n) {
+    function NE(e, t, n) {
         try {
             e[t].apply(e, ["EXPRESSION"].concat([].slice.call(n)))
         } catch (i) {
             e.warn(i)
         }
         return n[n.length - 1]
     }
 
-    function hre() {
-        return HS(this.context.dataflow, "warn", arguments)
+    function Tie() {
+        return NE(this.context.dataflow, "warn", arguments)
     }
 
-    function dre() {
-        return HS(this.context.dataflow, "info", arguments)
+    function Mie() {
+        return NE(this.context.dataflow, "info", arguments)
     }
 
-    function gre() {
-        return HS(this.context.dataflow, "debug", arguments)
+    function Oie() {
+        return NE(this.context.dataflow, "debug", arguments)
     }
 
-    function bv(e) {
+    function Xv(e) {
         const t = e / 255;
         return t <= .03928 ? t / 12.92 : Math.pow((t + .055) / 1.055, 2.4)
     }
 
-    function F2(e) {
-        const t = Ma(e),
-            n = bv(t.r),
-            i = bv(t.g),
-            r = bv(t.b);
+    function ux(e) {
+        const t = to(e),
+            n = Xv(t.r),
+            i = Xv(t.g),
+            r = Xv(t.b);
         return .2126 * n + .7152 * i + .0722 * r
     }
 
-    function pre(e, t) {
-        const n = F2(e),
-            i = F2(t),
+    function Fie(e, t) {
+        const n = ux(e),
+            i = ux(t),
             r = Math.max(n, i),
             s = Math.min(n, i);
         return (r + .05) / (s + .05)
     }
 
-    function mre() {
+    function Rie() {
         const e = [].slice.call(arguments);
-        return e.unshift({}), Ae(...e)
+        return e.unshift({}), Ne(...e)
     }
 
-    function aL(e, t) {
-        return e === t || e !== e && t !== t ? !0 : W(e) ? W(t) && e.length === t.length ? yre(e, t) : !1 : ae(e) && ae(t) ? oL(e, t) : !1
+    function GL(e, t) {
+        return e === t || e !== e && t !== t ? !0 : H(e) ? H(t) && e.length === t.length ? Die(e, t) : !1 : ce(e) && ce(t) ? UL(e, t) : !1
     }
 
-    function yre(e, t) {
+    function Die(e, t) {
         for (let n = 0, i = e.length; n < i; ++n)
-            if (!aL(e[n], t[n])) return !1;
+            if (!GL(e[n], t[n])) return !1;
         return !0
     }
 
-    function oL(e, t) {
+    function UL(e, t) {
         for (const n in e)
-            if (!aL(e[n], t[n])) return !1;
+            if (!GL(e[n], t[n])) return !1;
         return !0
     }
 
-    function GT(e) {
-        return t => oL(e, t)
+    function c5(e) {
+        return t => UL(e, t)
     }
 
-    function vre(e, t, n, i, r, s) {
+    function Nie(e, t, n, i, r, s) {
         const a = this.context.dataflow,
             o = this.context.data[e],
             l = o.input,
             u = a.stamp();
         let c = o.changes,
             f, h;
         if (a._trigger === !1 || !(l.value.length || t || i)) return 0;
         if ((!c || c.stamp < u) && (o.changes = c = a.changeset(), c.stamp = u, a.runAfter(() => {
                 o.modified = !0, a.pulse(l, c).run()
-            }, !0, 1)), n && (f = n === !0 ? Ri : W(n) || Fm(n) ? n : GT(n), c.remove(f)), t && c.insert(t), i && (f = GT(i), l.value.some(f) ? c.remove(f) : c.insert(i)), r)
+            }, !0, 1)), n && (f = n === !0 ? Yi : H(n) || X0(n) ? n : c5(n), c.remove(f)), t && c.insert(t), i && (f = c5(i), l.value.some(f) ? c.remove(f) : c.insert(i)), r)
             for (h in s) c.modify(r, h, s[h]);
         return 1
     }
 
-    function bre(e) {
+    function Pie(e) {
         const t = e.touches,
             n = t[0].clientX - t[1].clientX,
             i = t[0].clientY - t[1].clientY;
         return Math.hypot(n, i)
     }
 
-    function xre(e) {
+    function Lie(e) {
         const t = e.touches;
         return Math.atan2(t[0].clientY - t[1].clientY, t[0].clientX - t[1].clientX)
     }
-    const WT = {};
+    const f5 = {};
 
-    function _re(e, t) {
-        const n = WT[t] || (WT[t] = ni(t));
-        return W(e) ? e.map(n) : n(e)
+    function Iie(e, t) {
+        const n = f5[t] || (f5[t] = fi(t));
+        return H(e) ? e.map(n) : n(e)
     }
 
-    function YS(e) {
-        return W(e) || ArrayBuffer.isView(e) ? e : null
+    function PE(e) {
+        return H(e) || ArrayBuffer.isView(e) ? e : null
     }
 
-    function XS(e) {
-        return YS(e) || (re(e) ? e : null)
+    function LE(e) {
+        return PE(e) || (le(e) ? e : null)
     }
 
-    function wre(e) {
+    function zie(e) {
         for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++) n[i - 1] = arguments[i];
-        return YS(e).join(...n)
+        return PE(e).join(...n)
     }
 
-    function Sre(e) {
+    function Bie(e) {
         for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++) n[i - 1] = arguments[i];
-        return XS(e).indexOf(...n)
+        return LE(e).indexOf(...n)
     }
 
-    function Ere(e) {
+    function jie(e) {
         for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++) n[i - 1] = arguments[i];
-        return XS(e).lastIndexOf(...n)
+        return LE(e).lastIndexOf(...n)
     }
 
-    function Cre(e) {
+    function Gie(e) {
         for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++) n[i - 1] = arguments[i];
-        return XS(e).slice(...n)
+        return LE(e).slice(...n)
     }
 
-    function kre(e, t, n) {
-        return $e(n) && U("Function argument passed to replace."), String(e).replace(t, n)
+    function Uie(e, t, n) {
+        return Pe(n) && q("Function argument passed to replace."), String(e).replace(t, n)
     }
 
-    function Are(e) {
-        return YS(e).slice().reverse()
+    function Wie(e) {
+        return PE(e).slice().reverse()
     }
 
-    function $re(e, t, n) {
-        return pw(e || 0, t || 0, n || 0)
+    function qie(e, t, n) {
+        return Hw(e || 0, t || 0, n || 0)
     }
 
-    function Tre(e, t) {
-        const n = Ys(e, (t || this).context);
+    function Hie(e, t) {
+        const n = oa(e, (t || this).context);
         return n && n.bandwidth ? n.bandwidth() : 0
     }
 
-    function Mre(e, t) {
-        const n = Ys(e, (t || this).context);
+    function Yie(e, t) {
+        const n = oa(e, (t || this).context);
         return n ? n.copy() : void 0
     }
 
-    function Ore(e, t) {
-        const n = Ys(e, (t || this).context);
+    function Xie(e, t) {
+        const n = oa(e, (t || this).context);
         return n ? n.domain() : []
     }
 
-    function Fre(e, t, n) {
-        const i = Ys(e, (n || this).context);
-        return i ? W(t) ? (i.invertRange || i.invert)(t) : (i.invert || i.invertExtent)(t) : void 0
+    function Vie(e, t, n) {
+        const i = oa(e, (n || this).context);
+        return i ? H(t) ? (i.invertRange || i.invert)(t) : (i.invert || i.invertExtent)(t) : void 0
     }
 
-    function Rre(e, t) {
-        const n = Ys(e, (t || this).context);
+    function Kie(e, t) {
+        const n = oa(e, (t || this).context);
         return n && n.range ? n.range() : []
     }
 
-    function Dre(e, t, n) {
-        const i = Ys(e, (n || this).context);
+    function Jie(e, t, n) {
+        const i = oa(e, (n || this).context);
         return i ? i(t) : void 0
     }
 
-    function Nre(e, t, n, i, r) {
-        e = Ys(e, (r || this).context);
-        const s = sP(t, n);
+    function Qie(e, t, n, i, r) {
+        e = oa(e, (r || this).context);
+        const s = jN(t, n);
         let a = e.domain(),
             o = a[0],
-            l = De(a),
-            u = bn;
-        return l - o ? u = YN(e, o, l) : e = (e.interpolator ? We("sequential")().interpolator(e.interpolator()) : We("linear")().interpolate(e.interpolate()).range(e.range())).domain([o = 0, l = 1]), e.ticks && (a = e.ticks(+i || 15), o !== a[0] && a.unshift(o), l !== De(a) && a.push(l)), a.forEach(c => s.stop(u(c), e(c))), s
+            l = We(a),
+            u = Pn;
+        return l - o ? u = TN(e, o, l) : e = (e.interpolator ? Ze("sequential")().interpolator(e.interpolator()) : Ze("linear")().interpolate(e.interpolate()).range(e.range())).domain([o = 0, l = 1]), e.ticks && (a = e.ticks(+i || 15), o !== a[0] && a.unshift(o), l !== We(a) && a.push(l)), a.forEach(c => s.stop(u(c), e(c))), s
     }
 
-    function Pre(e, t, n) {
-        const i = Ys(e, (n || this).context);
+    function Zie(e, t, n) {
+        const i = oa(e, (n || this).context);
         return function(r) {
             return i ? i.path.context(r)(t) : ""
         }
     }
 
-    function Lre(e) {
+    function ere(e) {
         let t = null;
         return function(n) {
-            return n ? kh(n, t = t || Hu(e)) : e
+            return n ? Qh(n, t = t || gc(e)) : e
         }
     }
-    const lL = e => e.data;
+    const WL = e => e.data;
 
-    function uL(e, t) {
-        const n = iL.call(t, e);
+    function qL(e, t) {
+        const n = zL.call(t, e);
         return n.root && n.root.lookup || {}
     }
 
-    function Ire(e, t, n) {
-        const i = uL(e, this),
+    function tre(e, t, n) {
+        const i = qL(e, this),
             r = i[t],
             s = i[n];
-        return r && s ? r.path(s).map(lL) : void 0
+        return r && s ? r.path(s).map(WL) : void 0
     }
 
-    function zre(e, t) {
-        const n = uL(e, this)[t];
-        return n ? n.ancestors().map(lL) : void 0
+    function nre(e, t) {
+        const n = qL(e, this)[t];
+        return n ? n.ancestors().map(WL) : void 0
     }
-    const cL = () => typeof window < "u" && window || null;
+    const HL = () => typeof window < "u" && window || null;
 
-    function Bre() {
-        const e = cL();
+    function ire() {
+        const e = HL();
         return e ? e.screen : {}
     }
 
-    function jre() {
-        const e = cL();
+    function rre() {
+        const e = HL();
         return e ? [e.innerWidth, e.innerHeight] : [void 0, void 0]
     }
 
-    function Ure() {
+    function sre() {
         const e = this.context.dataflow,
             t = e.container && e.container();
         return t ? [t.clientWidth, t.clientHeight] : [void 0, void 0]
     }
 
-    function fL(e, t, n) {
+    function YL(e, t, n) {
         if (!e) return [];
-        const [i, r] = e, s = new kt().set(i[0], i[1], r[0], r[1]), a = n || this.context.dataflow.scenegraph().root;
-        return VP(a, s, Gre(t))
+        const [i, r] = e, s = new Ut().set(i[0], i[1], r[0], r[1]), a = n || this.context.dataflow.scenegraph().root;
+        return OP(a, s, are(t))
     }
 
-    function Gre(e) {
+    function are(e) {
         let t = null;
         if (e) {
-            const n = se(e.marktype),
-                i = se(e.markname);
+            const n = ue(e.marktype),
+                i = ue(e.markname);
             t = r => (!n.length || n.some(s => r.marktype === s)) && (!i.length || i.some(s => r.name === s))
         }
         return t
     }
 
-    function Wre(e, t, n) {
+    function ore(e, t, n) {
         let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 5;
-        e = se(e);
+        e = ue(e);
         const r = e[e.length - 1];
         return r === void 0 || Math.hypot(r[0] - t, r[1] - n) > i ? [...e, [t, n]] : e
     }
 
-    function qre(e) {
-        return se(e).reduce((t, n, i) => {
+    function lre(e) {
+        return ue(e).reduce((t, n, i) => {
             let [r, s] = n;
             return t += i == 0 ? `M ${r},${s} ` : i === e.length - 1 ? " Z" : `L ${r},${s} `
         }, "")
     }
 
-    function Hre(e, t, n) {
+    function ure(e, t, n) {
         const {
             x: i,
             y: r,
             mark: s
-        } = n, a = new kt().set(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER, Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER);
+        } = n, a = new Ut().set(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER, Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER);
         for (const [l, u] of t) l < a.x1 && (a.x1 = l), l > a.x2 && (a.x2 = l), u < a.y1 && (a.y1 = u), u > a.y2 && (a.y2 = u);
-        return a.translate(i, r), fL([
+        return a.translate(i, r), YL([
             [a.x1, a.y1],
             [a.x2, a.y2]
-        ], e, s).filter(l => Yre(l.x, l.y, t))
+        ], e, s).filter(l => cre(l.x, l.y, t))
     }
 
-    function Yre(e, t, n) {
+    function cre(e, t, n) {
         let i = 0;
         for (let r = 0, s = n.length - 1; r < n.length; s = r++) {
             const [a, o] = n[s], [l, u] = n[r];
             u > t != o > t && e < (a - l) * (t - u) / (o - u) + l && i++
         }
         return i & 1
     }
-    const Dh = {
+    const ud = {
             random() {
-                return Ni()
+                return Vi()
             },
-            cumulativeNormal: Lm,
-            cumulativeLogNormal: N_,
-            cumulativeUniform: z_,
-            densityNormal: M_,
-            densityLogNormal: D_,
-            densityUniform: I_,
-            quantileNormal: Im,
-            quantileLogNormal: P_,
-            quantileUniform: B_,
-            sampleNormal: Pm,
-            sampleLogNormal: R_,
-            sampleUniform: L_,
-            isArray: W,
-            isBoolean: Za,
-            isDate: Ea,
+            cumulativeNormal: Z0,
+            cumulativeLogNormal: Y_,
+            cumulativeUniform: J_,
+            densityNormal: G_,
+            densityLogNormal: H_,
+            densityUniform: K_,
+            quantileNormal: e1,
+            quantileLogNormal: X_,
+            quantileUniform: Q_,
+            sampleNormal: Q0,
+            sampleLogNormal: q_,
+            sampleUniform: V_,
+            isArray: H,
+            isBoolean: mo,
+            isDate: Ua,
             isDefined(e) {
                 return e !== void 0
             },
-            isNumber: Ze,
-            isObject: ae,
-            isRegExp: iD,
-            isString: re,
-            isTuple: Fm,
+            isNumber: lt,
+            isObject: ce,
+            isRegExp: lF,
+            isString: le,
+            isTuple: X0,
             isValid(e) {
                 return e != null && e === e
             },
-            toBoolean: g_,
+            toBoolean: __,
             toDate(e) {
-                return p_(e)
+                return w_(e)
             },
-            toNumber: hn,
-            toString: m_,
-            indexof: Sre,
-            join: wre,
-            lastindexof: Ere,
-            replace: kre,
-            reverse: Are,
-            slice: Cre,
-            flush: tD,
-            lerp: rD,
-            merge: mre,
-            pad: oD,
-            peek: De,
-            pluck: _re,
-            span: ad,
-            inrange: hu,
-            truncate: lD,
-            rgb: Ma,
-            lab: xp,
-            hcl: _p,
-            hsl: vp,
-            luminance: F2,
-            contrast: pre,
-            sequence: gi,
-            format: Kie,
-            utcFormat: Jie,
-            utcParse: Zie,
-            utcOffset: wD,
-            utcSequence: CD,
-            timeFormat: rL,
-            timeParse: Qie,
-            timeOffset: _D,
-            timeSequence: ED,
-            timeUnitSpecifier: cD,
-            monthFormat: ere,
-            monthAbbrevFormat: tre,
-            dayFormat: nre,
-            dayAbbrevFormat: ire,
-            quarter: JR,
-            utcquarter: QR,
-            week: hD,
-            utcweek: pD,
-            dayofyear: fD,
-            utcdayofyear: gD,
-            warn: hre,
-            info: dre,
-            debug: gre,
+            toNumber: Tn,
+            toString: S_,
+            indexof: Bie,
+            join: zie,
+            lastindexof: jie,
+            replace: Uie,
+            reverse: Wie,
+            slice: Gie,
+            flush: aF,
+            lerp: uF,
+            merge: Rie,
+            pad: hF,
+            peek: We,
+            pluck: Iie,
+            span: Cd,
+            inrange: Pu,
+            truncate: dF,
+            rgb: to,
+            lab: ym,
+            hcl: vm,
+            hsl: pm,
+            luminance: ux,
+            contrast: Fie,
+            sequence: $i,
+            format: die,
+            utcFormat: gie,
+            utcParse: mie,
+            utcOffset: HF,
+            utcSequence: VF,
+            timeFormat: BL,
+            timeParse: pie,
+            timeOffset: qF,
+            timeSequence: XF,
+            timeUnitSpecifier: DF,
+            monthFormat: yie,
+            monthAbbrevFormat: vie,
+            dayFormat: bie,
+            dayAbbrevFormat: xie,
+            quarter: nF,
+            utcquarter: iF,
+            week: PF,
+            utcweek: zF,
+            dayofyear: NF,
+            utcdayofyear: IF,
+            warn: Tie,
+            info: Mie,
+            debug: Oie,
             extent(e) {
-                return Hr(e)
+                return ss(e)
             },
-            inScope: fre,
-            intersect: fL,
-            clampRange: ZR,
-            pinchDistance: bre,
-            pinchAngle: xre,
-            screen: Bre,
-            containerSize: Ure,
-            windowSize: jre,
-            bandspace: $re,
-            setdata: Xie,
-            pathShape: Lre,
-            panLinear: YR,
-            panLog: XR,
-            panPow: VR,
-            panSymlog: KR,
-            zoomLinear: l_,
-            zoomLog: u_,
-            zoomPow: c0,
-            zoomSymlog: c_,
-            encode: Vie,
-            modify: vre,
-            lassoAppend: Wre,
-            lassoPath: qre,
-            intersectLasso: Hre
-        },
-        Xre = ["view", "item", "group", "xy", "x", "y"],
-        Vre = "event.vega.",
-        hL = "this.",
-        VS = {},
-        dL = {
+            inScope: $ie,
+            intersect: YL,
+            clampRange: rF,
+            pinchDistance: Pie,
+            pinchAngle: Lie,
+            screen: ire,
+            containerSize: sre,
+            windowSize: rre,
+            bandspace: qie,
+            setdata: fie,
+            pathShape: ere,
+            panLinear: QO,
+            panLog: ZO,
+            panPow: eF,
+            panSymlog: tF,
+            zoomLinear: p_,
+            zoomLog: m_,
+            zoomPow: tm,
+            zoomSymlog: y_,
+            encode: hie,
+            modify: Nie,
+            lassoAppend: ore,
+            lassoPath: lre,
+            intersectLasso: ure
+        },
+        fre = ["view", "item", "group", "xy", "x", "y"],
+        hre = "event.vega.",
+        XL = "this.",
+        IE = {},
+        VL = {
             forbidden: ["_"],
             allowed: ["datum", "event", "item"],
             fieldvar: "datum",
-            globalvar: e => `_[${Z(sL+e)}]`,
-            functions: Kre,
-            constants: Z4,
-            visitors: VS
-        },
-        R2 = tL(dL);
-
-    function Kre(e) {
-        const t = eL(e);
-        Xre.forEach(n => t[n] = Vre + n);
-        for (const n in Dh) t[n] = hL + n;
-        return Ae(t, ore(e, Dh, VS)), t
-    }
-
-    function At(e, t, n) {
-        return arguments.length === 1 ? Dh[e] : (Dh[e] = t, n && (VS[e] = n), R2 && (R2.functions[e] = hL + e), this)
-    }
-    At("bandwidth", Tre, Kn);
-    At("copy", Mre, Kn);
-    At("domain", Ore, Kn);
-    At("range", Rre, Kn);
-    At("invert", Fre, Kn);
-    At("scale", Dre, Kn);
-    At("gradient", Nre, Kn);
-    At("geoArea", lre, Kn);
-    At("geoBounds", ure, Kn);
-    At("geoCentroid", cre, Kn);
-    At("geoShape", Pre, Kn);
-    At("indata", Yie, are);
-    At("data", iL, WS);
-    At("treePath", Ire, WS);
-    At("treeAncestors", zre, WS);
-    At("vlSelectionTest", zie, GS);
-    At("vlSelectionIdTest", Uie, GS);
-    At("vlSelectionResolve", Wie, GS);
-    At("vlSelectionTuples", Gie);
+            globalvar: e => `_[${te(jL+e)}]`,
+            functions: dre,
+            constants: NL,
+            visitors: IE
+        },
+        cx = LL(VL);
+
+    function dre(e) {
+        const t = PL(e);
+        fre.forEach(n => t[n] = hre + n);
+        for (const n in ud) t[n] = XL + n;
+        return Ne(t, Eie(e, ud, IE)), t
+    }
+
+    function Wt(e, t, n) {
+        return arguments.length === 1 ? ud[e] : (ud[e] = t, n && (IE[e] = n), cx && (cx.functions[e] = XL + e), this)
+    }
+    Wt("bandwidth", Hie, oi);
+    Wt("copy", Yie, oi);
+    Wt("domain", Xie, oi);
+    Wt("range", Kie, oi);
+    Wt("invert", Vie, oi);
+    Wt("scale", Jie, oi);
+    Wt("gradient", Qie, oi);
+    Wt("geoArea", kie, oi);
+    Wt("geoBounds", Cie, oi);
+    Wt("geoCentroid", Aie, oi);
+    Wt("geoShape", Zie, oi);
+    Wt("indata", cie, Sie);
+    Wt("data", zL, RE);
+    Wt("treePath", tre, RE);
+    Wt("treeAncestors", nre, RE);
+    Wt("vlSelectionTest", nie, FE);
+    Wt("vlSelectionIdTest", sie, FE);
+    Wt("vlSelectionResolve", oie, FE);
+    Wt("vlSelectionTuples", aie);
 
-    function Xr(e, t) {
+    function cs(e, t) {
         const n = {};
         let i;
         try {
-            e = re(e) ? e : Z(e) + "", i = jS(e)
+            e = le(e) ? e : te(e) + "", i = ME(e)
         } catch {
-            U("Expression parse error: " + e)
+            q("Expression parse error: " + e)
         }
         i.visit(s => {
-            if (s.type !== H4) return;
+            if (s.type !== $L) return;
             const a = s.callee.name,
-                o = dL.visitors[a];
+                o = VL.visitors[a];
             o && o(a, s.arguments, t, n)
         });
-        const r = R2(i);
+        const r = cx(i);
         return r.globals.forEach(s => {
-            const a = sL + s;
-            !me(n, a) && t.getSignal(s) && (n[a] = t.signalRef(s))
+            const a = jL + s;
+            !Ce(n, a) && t.getSignal(s) && (n[a] = t.signalRef(s))
         }), {
-            $expr: Ae({
+            $expr: Ne({
                 code: r.code
             }, t.options.ast ? {
                 ast: i
             } : null),
             $fields: r.fields,
             $params: n
         }
     }
 
-    function Jre(e) {
+    function gre(e) {
         const t = this,
             n = e.operators || [];
         return e.background && (t.background = e.background), e.eventConfig && (t.eventConfig = e.eventConfig), e.locale && (t.locale = e.locale), n.forEach(i => t.parseOperator(i)), n.forEach(i => t.parseOperatorParameters(i)), (e.streams || []).forEach(i => t.parseStream(i)), (e.updates || []).forEach(i => t.parseUpdate(i)), t.resolve()
     }
-    const Qre = fr(["rule"]),
-        qT = fr(["group", "image", "rect"]);
+    const pre = Cr(["rule"]),
+        h5 = Cr(["group", "image", "rect"]);
 
-    function Zre(e, t) {
+    function mre(e, t) {
         let n = "";
-        return Qre[t] || (e.x2 && (e.x ? (qT[t] && (n += "if(o.x>o.x2)$=o.x,o.x=o.x2,o.x2=$;"), n += "o.width=o.x2-o.x;") : n += "o.x=o.x2-(o.width||0);"), e.xc && (n += "o.x=o.xc-(o.width||0)/2;"), e.y2 && (e.y ? (qT[t] && (n += "if(o.y>o.y2)$=o.y,o.y=o.y2,o.y2=$;"), n += "o.height=o.y2-o.y;") : n += "o.y=o.y2-(o.height||0);"), e.yc && (n += "o.y=o.yc-(o.height||0)/2;")), n
+        return pre[t] || (e.x2 && (e.x ? (h5[t] && (n += "if(o.x>o.x2)$=o.x,o.x=o.x2,o.x2=$;"), n += "o.width=o.x2-o.x;") : n += "o.x=o.x2-(o.width||0);"), e.xc && (n += "o.x=o.xc-(o.width||0)/2;"), e.y2 && (e.y ? (h5[t] && (n += "if(o.y>o.y2)$=o.y,o.y=o.y2,o.y2=$;"), n += "o.height=o.y2-o.y;") : n += "o.y=o.y2-(o.height||0);"), e.yc && (n += "o.y=o.yc-(o.height||0)/2;")), n
     }
 
-    function KS(e) {
+    function zE(e) {
         return (e + "").toLowerCase()
     }
 
-    function ese(e) {
-        return KS(e) === "operator"
+    function yre(e) {
+        return zE(e) === "operator"
     }
 
-    function tse(e) {
-        return KS(e) === "collect"
+    function vre(e) {
+        return zE(e) === "collect"
     }
 
-    function sf(e, t, n) {
+    function Of(e, t, n) {
         n.endsWith(";") || (n = "return(" + n + ");");
         const i = Function(...t.concat(n));
         return e && e.functions ? i.bind(e.functions) : i
     }
 
-    function nse(e, t, n, i) {
+    function bre(e, t, n, i) {
         return `((u = ${e}) < (v = ${t}) || u == null) && v != null ? ${n}
   : (u > v || v == null) && u != null ? ${i}
   : ((v = v instanceof Date ? +v : v), (u = u instanceof Date ? +u : u)) !== u && v === v ? ${n}
   : v !== v && u === u ? ${i} : `
     }
-    var ise = {
-        operator: (e, t) => sf(e, ["_"], t.code),
-        parameter: (e, t) => sf(e, ["datum", "_"], t.code),
-        event: (e, t) => sf(e, ["event"], t.code),
+    var xre = {
+        operator: (e, t) => Of(e, ["_"], t.code),
+        parameter: (e, t) => Of(e, ["datum", "_"], t.code),
+        event: (e, t) => Of(e, ["event"], t.code),
         handler: (e, t) => {
             const n = `var datum=event.item&&event.item.datum;return ${t.code};`;
-            return sf(e, ["_", "event"], n)
+            return Of(e, ["_", "event"], n)
         },
         encode: (e, t) => {
             const {
                 marktype: n,
                 channels: i
             } = t;
             let r = "var o=item,datum=o.datum,m=0,$;";
             for (const s in i) {
-                const a = "o[" + Z(s) + "]";
+                const a = "o[" + te(s) + "]";
                 r += `$=${i[s].code};if(${a}!==$)${a}=$,m=1;`
             }
-            return r += Zre(i, n), r += "return m;", sf(e, ["item", "_"], r)
+            return r += mre(i, n), r += "return m;", Of(e, ["item", "_"], r)
         },
         codegen: {
             get(e) {
-                const t = `[${e.map(Z).join("][")}]`,
+                const t = `[${e.map(te).join("][")}]`,
                     n = Function("_", `return _${t};`);
                 return n.path = t, n
             },
             comparator(e, t) {
                 let n;
                 const i = (s, a) => {
                         const o = t[a];
                         let l, u;
-                        return s.path ? (l = `a${s.path}`, u = `b${s.path}`) : ((n = n || {})["f" + a] = s, l = `this.f${a}(a)`, u = `this.f${a}(b)`), nse(l, u, -o, o)
+                        return s.path ? (l = `a${s.path}`, u = `b${s.path}`) : ((n = n || {})["f" + a] = s, l = `this.f${a}(a)`, u = `this.f${a}(b)`), bre(l, u, -o, o)
                     },
                     r = Function("a", "b", "var u, v; return " + e.map(i).join("") + "0;");
                 return n ? r.bind(n) : r
             }
         }
     };
 
-    function rse(e) {
+    function _re(e) {
         const t = this;
-        ese(e.type) || !e.type ? t.operator(e, e.update ? t.operatorExpression(e.update) : null) : t.transform(e, e.type)
+        yre(e.type) || !e.type ? t.operator(e, e.update ? t.operatorExpression(e.update) : null) : t.transform(e, e.type)
     }
 
-    function sse(e) {
+    function wre(e) {
         const t = this;
         if (e.params) {
             const n = t.get(e.id);
-            n || U("Invalid operator id: " + e.id), t.dataflow.connect(n, n.parameters(t.parseParameters(e.params), e.react, e.initonly))
+            n || q("Invalid operator id: " + e.id), t.dataflow.connect(n, n.parameters(t.parseParameters(e.params), e.react, e.initonly))
         }
     }
 
-    function ase(e, t) {
+    function Sre(e, t) {
         t = t || {};
         const n = this;
         for (const i in e) {
             const r = e[i];
-            t[i] = W(r) ? r.map(s => HT(s, n, t)) : HT(r, n, t)
+            t[i] = H(r) ? r.map(s => d5(s, n, t)) : d5(r, n, t)
         }
         return t
     }
 
-    function HT(e, t, n) {
-        if (!e || !ae(e)) return e;
-        for (let i = 0, r = YT.length, s; i < r; ++i)
-            if (s = YT[i], me(e, s.key)) return s.parse(e, t, n);
+    function d5(e, t, n) {
+        if (!e || !ce(e)) return e;
+        for (let i = 0, r = g5.length, s; i < r; ++i)
+            if (s = g5[i], Ce(e, s.key)) return s.parse(e, t, n);
         return e
     }
-    var YT = [{
+    var g5 = [{
         key: "$ref",
-        parse: ose
+        parse: Ere
     }, {
         key: "$key",
-        parse: use
+        parse: Cre
     }, {
         key: "$expr",
-        parse: lse
+        parse: kre
     }, {
         key: "$field",
-        parse: cse
+        parse: Are
     }, {
         key: "$encode",
-        parse: hse
+        parse: Tre
     }, {
         key: "$compare",
-        parse: fse
+        parse: $re
     }, {
         key: "$context",
-        parse: dse
+        parse: Mre
     }, {
         key: "$subflow",
-        parse: gse
+        parse: Ore
     }, {
         key: "$tupleid",
-        parse: pse
+        parse: Fre
     }];
 
-    function ose(e, t) {
-        return t.get(e.$ref) || U("Operator not defined: " + e.$ref)
+    function Ere(e, t) {
+        return t.get(e.$ref) || q("Operator not defined: " + e.$ref)
     }
 
-    function lse(e, t, n) {
+    function kre(e, t, n) {
         e.$params && t.parseParameters(e.$params, n);
         const i = "e:" + e.$expr.code;
-        return t.fn[i] || (t.fn[i] = li(t.parameterExpression(e.$expr), e.$fields))
+        return t.fn[i] || (t.fn[i] = vi(t.parameterExpression(e.$expr), e.$fields))
     }
 
-    function use(e, t) {
+    function Cre(e, t) {
         const n = "k:" + e.$key + "_" + !!e.$flat;
-        return t.fn[n] || (t.fn[n] = d_(e.$key, e.$flat, t.expr.codegen))
+        return t.fn[n] || (t.fn[n] = x_(e.$key, e.$flat, t.expr.codegen))
     }
 
-    function cse(e, t) {
+    function Are(e, t) {
         if (!e.$field) return null;
         const n = "f:" + e.$field + "_" + e.$name;
-        return t.fn[n] || (t.fn[n] = ni(e.$field, e.$name, t.expr.codegen))
+        return t.fn[n] || (t.fn[n] = fi(e.$field, e.$name, t.expr.codegen))
     }
 
-    function fse(e, t) {
+    function $re(e, t) {
         const n = "c:" + e.$compare + "_" + e.$order,
-            i = se(e.$compare).map(r => r && r.$tupleid ? ge : r);
-        return t.fn[n] || (t.fn[n] = f_(i, e.$order, t.expr.codegen))
+            i = ue(e.$compare).map(r => r && r.$tupleid ? Ee : r);
+        return t.fn[n] || (t.fn[n] = v_(i, e.$order, t.expr.codegen))
     }
 
-    function hse(e, t) {
+    function Tre(e, t) {
         const n = e.$encode,
             i = {};
         for (const r in n) {
             const s = n[r];
-            i[r] = li(t.encodeExpression(s.$expr), s.$fields), i[r].output = s.$output
+            i[r] = vi(t.encodeExpression(s.$expr), s.$fields), i[r].output = s.$output
         }
         return i
     }
 
-    function dse(e, t) {
+    function Mre(e, t) {
         return t
     }
 
-    function gse(e, t) {
+    function Ore(e, t) {
         const n = e.$subflow;
         return function(i, r, s) {
             const a = t.fork().parse(n),
                 o = a.get(n.operators[0].id),
                 l = a.signals.parent;
             return l && l.set(s), o.detachSubflow = () => t.detach(a), o
         }
     }
 
-    function pse() {
-        return ge
+    function Fre() {
+        return Ee
     }
 
-    function mse(e) {
+    function Rre(e) {
         var t = this,
             n = e.filter != null ? t.eventExpression(e.filter) : void 0,
             i = e.stream != null ? t.get(e.stream) : void 0,
             r;
-        e.source ? i = t.events(e.source, e.type, n) : e.merge && (r = e.merge.map(s => t.get(s)), i = r[0].merge.apply(r[0], r.slice(1))), e.between && (r = e.between.map(s => t.get(s)), i = i.between(r[0], r[1])), e.filter && (i = i.filter(n)), e.throttle != null && (i = i.throttle(+e.throttle)), e.debounce != null && (i = i.debounce(+e.debounce)), i == null && U("Invalid stream definition: " + JSON.stringify(e)), e.consume && i.consume(!0), t.stream(e, i)
+        e.source ? i = t.events(e.source, e.type, n) : e.merge && (r = e.merge.map(s => t.get(s)), i = r[0].merge.apply(r[0], r.slice(1))), e.between && (r = e.between.map(s => t.get(s)), i = i.between(r[0], r[1])), e.filter && (i = i.filter(n)), e.throttle != null && (i = i.throttle(+e.throttle)), e.debounce != null && (i = i.debounce(+e.debounce)), i == null && q("Invalid stream definition: " + JSON.stringify(e)), e.consume && i.consume(!0), t.stream(e, i)
     }
 
-    function yse(e) {
+    function Dre(e) {
         var t = this,
-            n = ae(n = e.source) ? n.$ref : n,
+            n = ce(n = e.source) ? n.$ref : n,
             i = t.get(n),
             r = null,
             s = e.update,
             a = void 0;
-        i || U("Source not defined: " + e.source), r = e.target && e.target.$expr ? t.eventExpression(e.target.$expr) : t.get(e.target), s && s.$expr && (s.$params && (a = t.parseParameters(s.$params)), s = t.handlerExpression(s.$expr)), t.update(e, i, r, s, a)
+        i || q("Source not defined: " + e.source), r = e.target && e.target.$expr ? t.eventExpression(e.target.$expr) : t.get(e.target), s && s.$expr && (s.$params && (a = t.parseParameters(s.$params)), s = t.handlerExpression(s.$expr)), t.update(e, i, r, s, a)
     }
-    const vse = {
+    const Nre = {
         skip: !0
     };
 
-    function bse(e) {
+    function Pre(e) {
         var t = this,
             n = {};
         if (e.signals) {
             var i = n.signals = {};
             Object.keys(t.signals).forEach(s => {
                 const a = t.signals[s];
                 e.signals(s, a) && (i[s] = a.value)
@@ -31707,43 +24944,43 @@
                 const a = t.data[s];
                 e.data(s, a) && (r[s] = a.input.value)
             })
         }
         return t.subcontext && e.recurse !== !1 && (n.subcontext = t.subcontext.map(s => s.getState(e))), n
     }
 
-    function xse(e) {
+    function Lre(e) {
         var t = this,
             n = t.dataflow,
             i = e.data,
             r = e.signals;
         Object.keys(r || {}).forEach(s => {
-            n.update(t.signals[s], r[s], vse)
+            n.update(t.signals[s], r[s], Nre)
         }), Object.keys(i || {}).forEach(s => {
-            n.pulse(t.data[s].input, n.changeset().remove(Ri).insert(i[s]))
+            n.pulse(t.data[s].input, n.changeset().remove(Yi).insert(i[s]))
         }), (e.subcontext || []).forEach((s, a) => {
             const o = t.subcontext[a];
             o && o.setState(s)
         })
     }
 
-    function gL(e, t, n, i) {
-        return new pL(e, t, n, i)
+    function KL(e, t, n, i) {
+        return new JL(e, t, n, i)
     }
 
-    function pL(e, t, n, i) {
-        this.dataflow = e, this.transforms = t, this.events = e.events.bind(e), this.expr = i || ise, this.signals = {}, this.scales = {}, this.nodes = {}, this.data = {}, this.fn = {}, n && (this.functions = Object.create(n), this.functions.context = this)
+    function JL(e, t, n, i) {
+        this.dataflow = e, this.transforms = t, this.events = e.events.bind(e), this.expr = i || xre, this.signals = {}, this.scales = {}, this.nodes = {}, this.data = {}, this.fn = {}, n && (this.functions = Object.create(n), this.functions.context = this)
     }
 
-    function XT(e) {
+    function p5(e) {
         this.dataflow = e.dataflow, this.transforms = e.transforms, this.events = e.events, this.expr = e.expr, this.signals = Object.create(e.signals), this.scales = Object.create(e.scales), this.nodes = Object.create(e.nodes), this.data = Object.create(e.data), this.fn = Object.create(e.fn), e.functions && (this.functions = Object.create(e.functions), this.functions.context = this)
     }
-    pL.prototype = XT.prototype = {
+    JL.prototype = p5.prototype = {
         fork() {
-            const e = new XT(this);
+            const e = new p5(this);
             return (this.subcontext || (this.subcontext = [])).push(e), e
         },
         detach(e) {
             this.subcontext = this.subcontext.filter(n => n !== e);
             const t = Object.keys(e.nodes);
             for (const n of t) e.nodes[n]._targets = null;
             for (const n of t) e.nodes[n].detach();
@@ -31755,15 +24992,15 @@
         set(e, t) {
             return this.nodes[e] = t
         },
         add(e, t) {
             const n = this,
                 i = n.dataflow,
                 r = e.value;
-            if (n.set(e.id, t), tse(e.type) && r && (r.$ingest ? i.ingest(t, r.$ingest, r.$format) : r.$request ? i.preload(t, r.$request, r.$format) : i.pulse(t, i.changeset().insert(r))), e.root && (n.root = t), e.parent) {
+            if (n.set(e.id, t), vre(e.type) && r && (r.$ingest ? i.ingest(t, r.$ingest, r.$format) : r.$request ? i.preload(t, r.$request, r.$format) : i.pulse(t, i.changeset().insert(r))), e.root && (n.root = t), e.parent) {
                 let s = n.get(e.parent.$ref);
                 s ? (i.connect(s, [t]), t.targets().add(s)) : (n.unresolved = n.unresolved || []).push(() => {
                     s = n.get(e.parent.$ref), i.connect(s, [t]), t.targets().add(s)
                 })
             }
             if (e.signal && (n.signals[e.signal] = t), e.scale && (n.scales[e.scale] = t), e.data)
                 for (const s in e.data) {
@@ -31774,15 +25011,15 @@
         resolve() {
             return (this.unresolved || []).forEach(e => e()), delete this.unresolved, this
         },
         operator(e, t) {
             this.add(e, this.dataflow.add(e.value, t))
         },
         transform(e, t) {
-            this.add(e, this.dataflow.add(this.transforms[KS(t)]))
+            this.add(e, this.dataflow.add(this.transforms[zE(t)]))
         },
         stream(e, t) {
             this.set(e.id, t)
         },
         update(e, t, n, i, r) {
             this.dataflow.on(t, n, i, r, e.options)
         },
@@ -31797,127 +25034,127 @@
         },
         handlerExpression(e) {
             return this.expr.handler(this, e)
         },
         encodeExpression(e) {
             return this.expr.encode(this, e)
         },
-        parse: Jre,
-        parseOperator: rse,
-        parseOperatorParameters: sse,
-        parseParameters: ase,
-        parseStream: mse,
-        parseUpdate: yse,
-        getState: bse,
-        setState: xse
+        parse: gre,
+        parseOperator: _re,
+        parseOperatorParameters: wre,
+        parseParameters: Sre,
+        parseStream: Rre,
+        parseUpdate: Dre,
+        getState: Pre,
+        setState: Lre
     };
 
-    function _se(e) {
+    function Ire(e) {
         const t = e.container();
-        t && (t.setAttribute("role", "graphics-document"), t.setAttribute("aria-roleDescription", "visualization"), mL(t, e.description()))
+        t && (t.setAttribute("role", "graphics-document"), t.setAttribute("aria-roleDescription", "visualization"), QL(t, e.description()))
     }
 
-    function mL(e, t) {
+    function QL(e, t) {
         e && (t == null ? e.removeAttribute("aria-label") : e.setAttribute("aria-label", t))
     }
 
-    function wse(e) {
+    function zre(e) {
         e.add(null, t => (e._background = t.bg, e._resize = 1, t.bg), {
             bg: e._signals.background
         })
     }
-    const xv = "default";
+    const Vv = "default";
 
-    function Sse(e) {
+    function Bre(e) {
         const t = e._signals.cursor || (e._signals.cursor = e.add({
-            user: xv,
+            user: Vv,
             item: null
         }));
         e.on(e.events("view", "mousemove"), t, (n, i) => {
             const r = t.value,
-                s = r ? re(r) ? r : r.user : xv,
+                s = r ? le(r) ? r : r.user : Vv,
                 a = i.item && i.item.cursor || null;
             return r && s === r.user && a == r.item ? r : {
                 user: s,
                 item: a
             }
         }), e.add(null, function(n) {
             let i = n.cursor,
                 r = this.value;
-            return re(i) || (r = i.item, i = i.user), D2(e, i && i !== xv ? i : r || i), r
+            return le(i) || (r = i.item, i = i.user), fx(e, i && i !== Vv ? i : r || i), r
         }, {
             cursor: t
         })
     }
 
-    function D2(e, t) {
+    function fx(e, t) {
         const n = e.globalCursor() ? typeof document < "u" && document.body : e.container();
         if (n) return t == null ? n.style.removeProperty("cursor") : n.style.cursor = t
     }
 
-    function M0(e, t) {
+    function f0(e, t) {
         var n = e._runtime.data;
-        return me(n, t) || U("Unrecognized data set: " + t), n[t]
+        return Ce(n, t) || q("Unrecognized data set: " + t), n[t]
     }
 
-    function Ese(e, t) {
-        return arguments.length < 2 ? M0(this, e).values.value : u1.call(this, e, Tl().remove(Ri).insert(t))
+    function jre(e, t) {
+        return arguments.length < 2 ? f0(this, e).values.value : j1.call(this, e, Xl().remove(Yi).insert(t))
     }
 
-    function u1(e, t) {
-        qD(t) || U("Second argument to changes must be a changeset.");
-        const n = M0(this, e);
+    function j1(e, t) {
+        wR(t) || q("Second argument to changes must be a changeset.");
+        const n = f0(this, e);
         return n.modified = !0, this.pulse(n.input, t)
     }
 
-    function Cse(e, t) {
-        return u1.call(this, e, Tl().insert(t))
+    function Gre(e, t) {
+        return j1.call(this, e, Xl().insert(t))
     }
 
-    function kse(e, t) {
-        return u1.call(this, e, Tl().remove(t))
+    function Ure(e, t) {
+        return j1.call(this, e, Xl().remove(t))
     }
 
-    function yL(e) {
+    function ZL(e) {
         var t = e.padding();
         return Math.max(0, e._viewWidth + t.left + t.right)
     }
 
-    function vL(e) {
+    function eI(e) {
         var t = e.padding();
         return Math.max(0, e._viewHeight + t.top + t.bottom)
     }
 
-    function c1(e) {
+    function G1(e) {
         var t = e.padding(),
             n = e._origin;
         return [t.left + n[0], t.top + n[1]]
     }
 
-    function Ase(e) {
-        var t = c1(e),
-            n = yL(e),
-            i = vL(e);
+    function Wre(e) {
+        var t = G1(e),
+            n = ZL(e),
+            i = eI(e);
         e._renderer.background(e.background()), e._renderer.resize(n, i, t), e._handler.origin(t), e._resizeListeners.forEach(r => {
             try {
                 r(n, i)
             } catch (s) {
                 e.error(s)
             }
         })
     }
 
-    function $se(e, t, n) {
+    function qre(e, t, n) {
         var i = e._renderer,
             r = i && i.canvas(),
             s, a, o;
-        return r && (o = c1(e), a = t.changedTouches ? t.changedTouches[0] : t, s = t1(a, r), s[0] -= o[0], s[1] -= o[1]), t.dataflow = e, t.item = n, t.vega = Tse(e, n, s), t
+        return r && (o = G1(e), a = t.changedTouches ? t.changedTouches[0] : t, s = $1(a, r), s[0] -= o[0], s[1] -= o[1]), t.dataflow = e, t.item = n, t.vega = Hre(e, n, s), t
     }
 
-    function Tse(e, t, n) {
+    function Hre(e, t, n) {
         const i = t ? t.mark.marktype === "group" ? t : t.mark.group : null;
 
         function r(a) {
             var o = i,
                 l;
             if (a) {
                 for (l = t; l; l = l.mark.group)
@@ -31927,577 +25164,577 @@
                     }
             }
             return o && o.mark && o.mark.interactive ? o : {}
         }
 
         function s(a) {
             if (!a) return n;
-            re(a) && (a = r(a));
+            le(a) && (a = r(a));
             const o = n.slice();
             for (; a;) o[0] -= a.x || 0, o[1] -= a.y || 0, a = a.mark && a.mark.group;
             return o
         }
         return {
-            view: xn(e),
-            item: xn(t || {}),
+            view: Ln(e),
+            item: Ln(t || {}),
             group: r,
             xy: s,
             x: a => s(a)[0],
             y: a => s(a)[1]
         }
     }
-    const VT = "view",
-        Mse = "timer",
-        Ose = "window",
-        Fse = {
+    const m5 = "view",
+        Yre = "timer",
+        Xre = "window",
+        Vre = {
             trap: !1
         };
 
-    function Rse(e) {
-        const t = Ae({
+    function Kre(e) {
+        const t = Ne({
                 defaults: {}
             }, e),
             n = (i, r) => {
                 r.forEach(s => {
-                    W(i[s]) && (i[s] = fr(i[s]))
+                    H(i[s]) && (i[s] = Cr(i[s]))
                 })
             };
         return n(t.defaults, ["prevent", "allow"]), n(t, ["view", "window", "selector"]), t
     }
 
-    function bL(e, t, n, i) {
+    function tI(e, t, n, i) {
         e._eventListeners.push({
             type: n,
-            sources: se(t),
+            sources: ue(t),
             handler: i
         })
     }
 
-    function Dse(e, t) {
+    function Jre(e, t) {
         var n = e._eventConfig.defaults,
             i = n.prevent,
             r = n.allow;
         return i === !1 || r === !0 ? !1 : i === !0 || r === !1 ? !0 : i ? i[t] : r ? !r[t] : e.preventDefault()
     }
 
-    function Cg(e, t, n) {
+    function qg(e, t, n) {
         const i = e._eventConfig && e._eventConfig[t];
-        return i === !1 || ae(i) && !i[n] ? (e.warn(`Blocked ${t} ${n} event listener.`), !1) : !0
+        return i === !1 || ce(i) && !i[n] ? (e.warn(`Blocked ${t} ${n} event listener.`), !1) : !0
     }
 
-    function Nse(e, t, n) {
+    function Qre(e, t, n) {
         var i = this,
-            r = new Nm(n),
+            r = new J0(n),
             s = function(u, c) {
                 i.runAsync(null, () => {
-                    e === VT && Dse(i, t) && u.preventDefault(), r.receive($se(i, u, c))
+                    e === m5 && Jre(i, t) && u.preventDefault(), r.receive(qre(i, u, c))
                 })
             },
             a;
-        if (e === Mse) Cg(i, "timer", t) && i.timer(s, t);
-        else if (e === VT) Cg(i, "view", t) && i.addEventListener(t, s, Fse);
-        else if (e === Ose ? Cg(i, "window", t) && typeof window < "u" && (a = [window]) : typeof document < "u" && Cg(i, "selector", t) && (a = Array.from(document.querySelectorAll(e))), !a) i.warn("Can not resolve event source: " + e);
+        if (e === Yre) qg(i, "timer", t) && i.timer(s, t);
+        else if (e === m5) qg(i, "view", t) && i.addEventListener(t, s, Vre);
+        else if (e === Xre ? qg(i, "window", t) && typeof window < "u" && (a = [window]) : typeof document < "u" && qg(i, "selector", t) && (a = Array.from(document.querySelectorAll(e))), !a) i.warn("Can not resolve event source: " + e);
         else {
             for (var o = 0, l = a.length; o < l; ++o) a[o].addEventListener(t, s);
-            bL(i, a, t, s)
+            tI(i, a, t, s)
         }
         return r
     }
 
-    function KT(e) {
+    function y5(e) {
         return e.item
     }
 
-    function JT(e) {
+    function v5(e) {
         return e.item.mark.source
     }
 
-    function QT(e) {
+    function b5(e) {
         return function(t, n) {
             return n.vega.view().changeset().encode(n.item, e)
         }
     }
 
-    function Pse(e, t) {
-        return e = [e || "hover"], t = [t || "update", e[0]], this.on(this.events("view", "mouseover", KT), JT, QT(e)), this.on(this.events("view", "mouseout", KT), JT, QT(t)), this
+    function Zre(e, t) {
+        return e = [e || "hover"], t = [t || "update", e[0]], this.on(this.events("view", "mouseover", y5), v5, b5(e)), this.on(this.events("view", "mouseout", y5), v5, b5(t)), this
     }
 
-    function Lse() {
+    function ese() {
         var e = this._tooltip,
             t = this._timers,
             n = this._eventListeners,
             i, r, s;
         for (i = t.length; --i >= 0;) t[i].stop();
         for (i = n.length; --i >= 0;)
             for (s = n[i], r = s.sources.length; --r >= 0;) s.sources[r].removeEventListener(s.type, s.handler);
         return e && e.call(this, this._handler, null, null, null), this
     }
 
-    function yi(e, t, n) {
+    function Ti(e, t, n) {
         const i = document.createElement(e);
         for (const r in t) i.setAttribute(r, t[r]);
         return n != null && (i.textContent = n), i
     }
-    const Ise = "vega-bind",
-        zse = "vega-bind-name",
-        Bse = "vega-bind-radio";
+    const tse = "vega-bind",
+        nse = "vega-bind-name",
+        ise = "vega-bind-radio";
 
-    function jse(e, t, n) {
+    function rse(e, t, n) {
         if (!t) return;
         const i = n.param;
         let r = n.state;
         return r || (r = n.state = {
             elements: null,
             active: !1,
             set: null,
             update: a => {
                 a != e.signal(i.signal) && e.runAsync(null, () => {
                     r.source = !0, e.signal(i.signal, a)
                 })
             }
-        }, i.debounce && (r.update = h_(i.debounce, r.update))), (i.input == null && i.element ? Use : Wse)(r, t, i, e), r.active || (e.on(e._signals[i.signal], null, () => {
+        }, i.debounce && (r.update = b_(i.debounce, r.update))), (i.input == null && i.element ? sse : ose)(r, t, i, e), r.active || (e.on(e._signals[i.signal], null, () => {
             r.source ? r.source = !1 : r.set(e.signal(i.signal))
         }), r.active = !0), r
     }
 
-    function Use(e, t, n, i) {
+    function sse(e, t, n, i) {
         const r = n.event || "input",
             s = () => e.update(t.value);
-        i.signal(n.signal, t.value), t.addEventListener(r, s), bL(i, t, r, s), e.set = a => {
-            t.value = a, t.dispatchEvent(Gse(r))
+        i.signal(n.signal, t.value), t.addEventListener(r, s), tI(i, t, r, s), e.set = a => {
+            t.value = a, t.dispatchEvent(ase(r))
         }
     }
 
-    function Gse(e) {
+    function ase(e) {
         return typeof Event < "u" ? new Event(e) : {
             type: e
         }
     }
 
-    function Wse(e, t, n, i) {
+    function ose(e, t, n, i) {
         const r = i.signal(n.signal),
-            s = yi("div", {
-                class: Ise
+            s = Ti("div", {
+                class: tse
             }),
-            a = n.input === "radio" ? s : s.appendChild(yi("label"));
-        a.appendChild(yi("span", {
-            class: zse
+            a = n.input === "radio" ? s : s.appendChild(Ti("label"));
+        a.appendChild(Ti("span", {
+            class: nse
         }, n.name || n.signal)), t.appendChild(s);
-        let o = qse;
+        let o = lse;
         switch (n.input) {
             case "checkbox":
-                o = Hse;
+                o = use;
                 break;
             case "select":
-                o = Yse;
+                o = cse;
                 break;
             case "radio":
-                o = Xse;
+                o = fse;
                 break;
             case "range":
-                o = Vse;
+                o = hse;
                 break
         }
         o(e, a, n, r)
     }
 
-    function qse(e, t, n, i) {
-        const r = yi("input");
+    function lse(e, t, n, i) {
+        const r = Ti("input");
         for (const s in n) s !== "signal" && s !== "element" && r.setAttribute(s === "input" ? "type" : s, n[s]);
         r.setAttribute("name", n.signal), r.value = i, t.appendChild(r), r.addEventListener("input", () => e.update(r.value)), e.elements = [r], e.set = s => r.value = s
     }
 
-    function Hse(e, t, n, i) {
+    function use(e, t, n, i) {
         const r = {
             type: "checkbox",
             name: n.signal
         };
         i && (r.checked = !0);
-        const s = yi("input", r);
+        const s = Ti("input", r);
         t.appendChild(s), s.addEventListener("change", () => e.update(s.checked)), e.elements = [s], e.set = a => s.checked = !!a || null
     }
 
-    function Yse(e, t, n, i) {
-        const r = yi("select", {
+    function cse(e, t, n, i) {
+        const r = Ti("select", {
                 name: n.signal
             }),
             s = n.labels || [];
         n.options.forEach((a, o) => {
             const l = {
                 value: a
             };
-            O0(a, i) && (l.selected = !0), r.appendChild(yi("option", l, (s[o] || a) + ""))
+            h0(a, i) && (l.selected = !0), r.appendChild(Ti("option", l, (s[o] || a) + ""))
         }), t.appendChild(r), r.addEventListener("change", () => {
             e.update(n.options[r.selectedIndex])
         }), e.elements = [r], e.set = a => {
             for (let o = 0, l = n.options.length; o < l; ++o)
-                if (O0(n.options[o], a)) {
+                if (h0(n.options[o], a)) {
                     r.selectedIndex = o;
                     return
                 }
         }
     }
 
-    function Xse(e, t, n, i) {
-        const r = yi("span", {
-                class: Bse
+    function fse(e, t, n, i) {
+        const r = Ti("span", {
+                class: ise
             }),
             s = n.labels || [];
         t.appendChild(r), e.elements = n.options.map((a, o) => {
             const l = {
                 type: "radio",
                 name: n.signal,
                 value: a
             };
-            O0(a, i) && (l.checked = !0);
-            const u = yi("input", l);
+            h0(a, i) && (l.checked = !0);
+            const u = Ti("input", l);
             u.addEventListener("change", () => e.update(a));
-            const c = yi("label", {}, (s[o] || a) + "");
+            const c = Ti("label", {}, (s[o] || a) + "");
             return c.prepend(u), r.appendChild(c), u
         }), e.set = a => {
             const o = e.elements,
                 l = o.length;
-            for (let u = 0; u < l; ++u) O0(o[u].value, a) && (o[u].checked = !0)
+            for (let u = 0; u < l; ++u) h0(o[u].value, a) && (o[u].checked = !0)
         }
     }
 
-    function Vse(e, t, n, i) {
+    function hse(e, t, n, i) {
         i = i !== void 0 ? i : (+n.max + +n.min) / 2;
         const r = n.max != null ? n.max : Math.max(100, +i) || 100,
             s = n.min || Math.min(0, r, +i) || 0,
-            a = n.step || Oa(s, r, 100),
-            o = yi("input", {
+            a = n.step || Qa(s, r, 100),
+            o = Ti("input", {
                 type: "range",
                 name: n.signal,
                 min: s,
                 max: r,
                 step: a
             });
         o.value = i;
-        const l = yi("span", {}, +i);
+        const l = Ti("span", {}, +i);
         t.appendChild(o), t.appendChild(l);
         const u = () => {
             l.textContent = o.value, e.update(+o.value)
         };
         o.addEventListener("input", u), o.addEventListener("change", u), e.elements = [o], e.set = c => {
             o.value = c, l.textContent = c
         }
     }
 
-    function O0(e, t) {
+    function h0(e, t) {
         return e === t || e + "" == t + ""
     }
 
-    function xL(e, t, n, i, r, s) {
-        return t = t || new i(e.loader()), t.initialize(n, yL(e), vL(e), c1(e), r, s).background(e.background())
+    function nI(e, t, n, i, r, s) {
+        return t = t || new i(e.loader()), t.initialize(n, ZL(e), eI(e), G1(e), r, s).background(e.background())
     }
 
-    function JS(e, t) {
+    function BE(e, t) {
         return t ? function() {
             try {
                 t.apply(this, arguments)
             } catch (n) {
                 e.error(n)
             }
         } : null
     }
 
-    function Kse(e, t, n, i) {
-        const r = new i(e.loader(), JS(e, e.tooltip())).scene(e.scenegraph().root).initialize(n, c1(e), e);
+    function dse(e, t, n, i) {
+        const r = new i(e.loader(), BE(e, e.tooltip())).scene(e.scenegraph().root).initialize(n, G1(e), e);
         return t && t.handlers().forEach(s => {
             r.on(s.type, s.handler)
         }), r
     }
 
-    function Jse(e, t) {
+    function gse(e, t) {
         const n = this,
             i = n._renderType,
             r = n._eventConfig.bind,
-            s = n1(i);
-        e = n._el = e ? _v(n, e, !0) : null, _se(n), s || n.error("Unrecognized renderer type: " + i);
-        const a = s.handler || _d,
+            s = T1(i);
+        e = n._el = e ? Kv(n, e, !0) : null, Ire(n), s || n.error("Unrecognized renderer type: " + i);
+        const a = s.handler || Hd,
             o = e ? s.renderer : s.headless;
-        return n._renderer = o ? xL(n, n._renderer, e, o) : null, n._handler = Kse(n, n._handler, e, a), n._redraw = !0, e && r !== "none" && (t = t ? n._elBind = _v(n, t, !0) : e.appendChild(yi("form", {
+        return n._renderer = o ? nI(n, n._renderer, e, o) : null, n._handler = dse(n, n._handler, e, a), n._redraw = !0, e && r !== "none" && (t = t ? n._elBind = Kv(n, t, !0) : e.appendChild(Ti("form", {
             class: "vega-bindings"
         })), n._bind.forEach(l => {
-            l.param.element && r !== "container" && (l.element = _v(n, l.param.element, !!l.param.input))
+            l.param.element && r !== "container" && (l.element = Kv(n, l.param.element, !!l.param.input))
         }), n._bind.forEach(l => {
-            jse(n, l.element || t, l)
+            rse(n, l.element || t, l)
         })), n
     }
 
-    function _v(e, t, n) {
+    function Kv(e, t, n) {
         if (typeof t == "string")
             if (typeof document < "u") {
                 if (t = document.querySelector(t), !t) return e.error("Signal bind element not found: " + t), null
             } else return e.error("DOM document instance not found."), null;
         if (t && n) try {
             t.textContent = ""
         } catch (i) {
             t = null, e.error(i)
         }
         return t
     }
-    const af = e => +e || 0,
-        Qse = e => ({
+    const Ff = e => +e || 0,
+        pse = e => ({
             top: e,
             bottom: e,
             left: e,
             right: e
         });
 
-    function ZT(e) {
-        return ae(e) ? {
-            top: af(e.top),
-            bottom: af(e.bottom),
-            left: af(e.left),
-            right: af(e.right)
-        } : Qse(af(e))
+    function x5(e) {
+        return ce(e) ? {
+            top: Ff(e.top),
+            bottom: Ff(e.bottom),
+            left: Ff(e.left),
+            right: Ff(e.right)
+        } : pse(Ff(e))
     }
-    async function QS(e, t, n, i) {
-        const r = n1(t),
+    async function jE(e, t, n, i) {
+        const r = T1(t),
             s = r && r.headless;
-        return s || U("Unrecognized renderer type: " + t), await e.runAsync(), xL(e, null, null, s, n, i).renderAsync(e._scenegraph.root)
+        return s || q("Unrecognized renderer type: " + t), await e.runAsync(), nI(e, null, null, s, n, i).renderAsync(e._scenegraph.root)
     }
-    async function Zse(e, t) {
-        e !== ya.Canvas && e !== ya.SVG && e !== ya.PNG && U("Unrecognized image type: " + e);
-        const n = await QS(this, e, t);
-        return e === ya.SVG ? eae(n.svg(), "image/svg+xml") : n.canvas().toDataURL("image/png")
+    async function mse(e, t) {
+        e !== Na.Canvas && e !== Na.SVG && e !== Na.PNG && q("Unrecognized image type: " + e);
+        const n = await jE(this, e, t);
+        return e === Na.SVG ? yse(n.svg(), "image/svg+xml") : n.canvas().toDataURL("image/png")
     }
 
-    function eae(e, t) {
+    function yse(e, t) {
         const n = new Blob([e], {
             type: t
         });
         return window.URL.createObjectURL(n)
     }
-    async function tae(e, t) {
-        return (await QS(this, ya.Canvas, e, t)).canvas()
+    async function vse(e, t) {
+        return (await jE(this, Na.Canvas, e, t)).canvas()
     }
-    async function nae(e) {
-        return (await QS(this, ya.SVG, e)).svg()
+    async function bse(e) {
+        return (await jE(this, Na.SVG, e)).svg()
     }
 
-    function iae(e, t, n) {
-        return gL(e, Uu, Dh, n).parse(t)
+    function xse(e, t, n) {
+        return KL(e, lc, ud, n).parse(t)
     }
 
-    function rae(e) {
+    function _se(e) {
         var t = this._runtime.scales;
-        return me(t, e) || U("Unrecognized scale or projection: " + e), t[e].value
+        return Ce(t, e) || q("Unrecognized scale or projection: " + e), t[e].value
     }
-    var _L = "width",
-        wL = "height",
-        ZS = "padding",
-        e5 = {
+    var iI = "width",
+        rI = "height",
+        GE = "padding",
+        _5 = {
             skip: !0
         };
 
-    function SL(e, t) {
+    function sI(e, t) {
         var n = e.autosize(),
             i = e.padding();
-        return t - (n && n.contains === ZS ? i.left + i.right : 0)
+        return t - (n && n.contains === GE ? i.left + i.right : 0)
     }
 
-    function EL(e, t) {
+    function aI(e, t) {
         var n = e.autosize(),
             i = e.padding();
-        return t - (n && n.contains === ZS ? i.top + i.bottom : 0)
+        return t - (n && n.contains === GE ? i.top + i.bottom : 0)
     }
 
-    function sae(e) {
+    function wse(e) {
         var t = e._signals,
-            n = t[_L],
-            i = t[wL],
-            r = t[ZS];
+            n = t[iI],
+            i = t[rI],
+            r = t[GE];
 
         function s() {
             e._autosize = e._resize = 1
         }
         e._resizeWidth = e.add(null, o => {
-            e._width = o.size, e._viewWidth = SL(e, o.size), s()
+            e._width = o.size, e._viewWidth = sI(e, o.size), s()
         }, {
             size: n
         }), e._resizeHeight = e.add(null, o => {
-            e._height = o.size, e._viewHeight = EL(e, o.size), s()
+            e._height = o.size, e._viewHeight = aI(e, o.size), s()
         }, {
             size: i
         });
         const a = e.add(null, s, {
             pad: r
         });
         e._resizeWidth.rank = n.rank + 1, e._resizeHeight.rank = i.rank + 1, a.rank = r.rank + 1
     }
 
-    function aae(e, t, n, i, r, s) {
+    function Sse(e, t, n, i, r, s) {
         this.runAfter(a => {
             let o = 0;
-            a._autosize = 0, a.width() !== n && (o = 1, a.signal(_L, n, e5), a._resizeWidth.skip(!0)), a.height() !== i && (o = 1, a.signal(wL, i, e5), a._resizeHeight.skip(!0)), a._viewWidth !== e && (a._resize = 1, a._viewWidth = e), a._viewHeight !== t && (a._resize = 1, a._viewHeight = t), (a._origin[0] !== r[0] || a._origin[1] !== r[1]) && (a._resize = 1, a._origin = r), o && a.run("enter"), s && a.runAfter(l => l.resize())
+            a._autosize = 0, a.width() !== n && (o = 1, a.signal(iI, n, _5), a._resizeWidth.skip(!0)), a.height() !== i && (o = 1, a.signal(rI, i, _5), a._resizeHeight.skip(!0)), a._viewWidth !== e && (a._resize = 1, a._viewWidth = e), a._viewHeight !== t && (a._resize = 1, a._viewHeight = t), (a._origin[0] !== r[0] || a._origin[1] !== r[1]) && (a._resize = 1, a._origin = r), o && a.run("enter"), s && a.runAfter(l => l.resize())
         }, !1, 1)
     }
 
-    function oae(e) {
+    function Ese(e) {
         return this._runtime.getState(e || {
-            data: lae,
-            signals: uae,
+            data: kse,
+            signals: Cse,
             recurse: !0
         })
     }
 
-    function lae(e, t) {
-        return t.modified && W(t.input.value) && e.indexOf("_:vega:_")
+    function kse(e, t) {
+        return t.modified && H(t.input.value) && e.indexOf("_:vega:_")
     }
 
-    function uae(e, t) {
-        return !(e === "parent" || t instanceof Uu.proxy)
+    function Cse(e, t) {
+        return !(e === "parent" || t instanceof lc.proxy)
     }
 
-    function cae(e) {
+    function Ase(e) {
         return this.runAsync(null, t => {
             t._trigger = !1, t._runtime.setState(e)
         }, t => {
             t._trigger = !0
         }), this
     }
 
-    function fae(e, t) {
+    function $se(e, t) {
         function n(i) {
             e({
                 timestamp: Date.now(),
                 elapsed: i
             })
         }
-        this._timers.push(Lj(n, t))
+        this._timers.push(tZ(n, t))
     }
 
-    function hae(e, t, n, i) {
+    function Tse(e, t, n, i) {
         const r = e.element();
-        r && r.setAttribute("title", dae(i))
+        r && r.setAttribute("title", Mse(i))
     }
 
-    function dae(e) {
-        return e == null ? "" : W(e) ? CL(e) : ae(e) && !Ea(e) ? gae(e) : e + ""
+    function Mse(e) {
+        return e == null ? "" : H(e) ? oI(e) : ce(e) && !Ua(e) ? Ose(e) : e + ""
     }
 
-    function gae(e) {
+    function Ose(e) {
         return Object.keys(e).map(t => {
             const n = e[t];
-            return t + ": " + (W(n) ? CL(n) : kL(n))
+            return t + ": " + (H(n) ? oI(n) : lI(n))
         }).join(`
 `)
     }
 
-    function CL(e) {
-        return "[" + e.map(kL).join(", ") + "]"
+    function oI(e) {
+        return "[" + e.map(lI).join(", ") + "]"
     }
 
-    function kL(e) {
-        return W(e) ? "[…]" : ae(e) && !Ea(e) ? "{…}" : e
+    function lI(e) {
+        return H(e) ? "[…]" : ce(e) && !Ua(e) ? "{…}" : e
     }
 
-    function AL(e, t) {
+    function uI(e, t) {
         const n = this;
-        if (t = t || {}, wu.call(n), t.loader && n.loader(t.loader), t.logger && n.logger(t.logger), t.logLevel != null && n.logLevel(t.logLevel), t.locale || e.locale) {
-            const s = Ae({}, e.locale, t.locale);
-            n.locale(ND(s.number, s.time))
+        if (t = t || {}, Wu.call(n), t.loader && n.loader(t.loader), t.logger && n.logger(t.logger), t.logLevel != null && n.logLevel(t.logLevel), t.locale || e.locale) {
+            const s = Ne({}, e.locale, t.locale);
+            n.locale(hR(s.number, s.time))
         }
-        n._el = null, n._elBind = null, n._renderType = t.renderer || ya.Canvas, n._scenegraph = new qw;
+        n._el = null, n._elBind = null, n._renderType = t.renderer || Na.Canvas, n._scenegraph = new wS;
         const i = n._scenegraph.root;
-        n._renderer = null, n._tooltip = t.tooltip || hae, n._redraw = !0, n._handler = new _d().scene(i), n._globalCursor = !1, n._preventDefault = !1, n._timers = [], n._eventListeners = [], n._resizeListeners = [], n._eventConfig = Rse(e.eventConfig), n.globalCursor(n._eventConfig.globalCursor);
-        const r = iae(n, e, t.expr);
+        n._renderer = null, n._tooltip = t.tooltip || Tse, n._redraw = !0, n._handler = new Hd().scene(i), n._globalCursor = !1, n._preventDefault = !1, n._timers = [], n._eventListeners = [], n._resizeListeners = [], n._eventConfig = Kre(e.eventConfig), n.globalCursor(n._eventConfig.globalCursor);
+        const r = xse(n, e, t.expr);
         n._runtime = r, n._signals = r.signals, n._bind = (e.bindings || []).map(s => ({
             state: null,
-            param: Ae({}, s)
-        })), r.root && r.root.set(i), i.source = r.data.root.input, n.pulse(r.data.root.input, n.changeset().insert(i.items)), n._width = n.width(), n._height = n.height(), n._viewWidth = SL(n, n._width), n._viewHeight = EL(n, n._height), n._origin = [0, 0], n._resize = 0, n._autosize = 1, sae(n), wse(n), Sse(n), n.description(e.description), t.hover && n.hover(), t.container && n.initialize(t.container, t.bind)
+            param: Ne({}, s)
+        })), r.root && r.root.set(i), i.source = r.data.root.input, n.pulse(r.data.root.input, n.changeset().insert(i.items)), n._width = n.width(), n._height = n.height(), n._viewWidth = sI(n, n._width), n._viewHeight = aI(n, n._height), n._origin = [0, 0], n._resize = 0, n._autosize = 1, wse(n), zre(n), Bre(n), n.description(e.description), t.hover && n.hover(), t.container && n.initialize(t.container, t.bind)
     }
 
-    function kg(e, t) {
-        return me(e._signals, t) ? e._signals[t] : U("Unrecognized signal name: " + Z(t))
+    function Hg(e, t) {
+        return Ce(e._signals, t) ? e._signals[t] : q("Unrecognized signal name: " + te(t))
     }
 
-    function $L(e, t) {
+    function cI(e, t) {
         const n = (e._targets || []).filter(i => i._update && i._update.handler === t);
         return n.length ? n[0] : null
     }
 
-    function t5(e, t, n, i) {
-        let r = $L(n, i);
-        return r || (r = JS(e, () => i(t, n.value)), r.handler = i, e.on(n, null, r)), e
+    function w5(e, t, n, i) {
+        let r = cI(n, i);
+        return r || (r = BE(e, () => i(t, n.value)), r.handler = i, e.on(n, null, r)), e
     }
 
-    function n5(e, t, n) {
-        const i = $L(t, n);
+    function S5(e, t, n) {
+        const i = cI(t, n);
         return i && t._targets.remove(i), e
     }
-    ee(AL, wu, {
+    ne(uI, Wu, {
         async evaluate(e, t, n) {
-            if (await wu.prototype.evaluate.call(this, e, t), this._redraw || this._resize) try {
-                this._renderer && (this._resize && (this._resize = 0, Ase(this)), await this._renderer.renderAsync(this._scenegraph.root)), this._redraw = !1
+            if (await Wu.prototype.evaluate.call(this, e, t), this._redraw || this._resize) try {
+                this._renderer && (this._resize && (this._resize = 0, Wre(this)), await this._renderer.renderAsync(this._scenegraph.root)), this._redraw = !1
             } catch (i) {
                 this.error(i)
             }
-            return n && Kg(this, n), this
+            return n && wp(this, n), this
         },
         dirty(e) {
             this._redraw = !0, this._renderer && this._renderer.dirty(e)
         },
         description(e) {
             if (arguments.length) {
                 const t = e != null ? e + "" : null;
-                return t !== this._desc && mL(this._el, this._desc = t), this
+                return t !== this._desc && QL(this._el, this._desc = t), this
             }
             return this._desc
         },
         container() {
             return this._el
         },
         scenegraph() {
             return this._scenegraph
         },
         origin() {
             return this._origin.slice()
         },
         signal(e, t, n) {
-            const i = kg(this, e);
+            const i = Hg(this, e);
             return arguments.length === 1 ? i.value : this.update(i, t, n)
         },
         width(e) {
             return arguments.length ? this.signal("width", e) : this.signal("width")
         },
         height(e) {
             return arguments.length ? this.signal("height", e) : this.signal("height")
         },
         padding(e) {
-            return arguments.length ? this.signal("padding", ZT(e)) : ZT(this.signal("padding"))
+            return arguments.length ? this.signal("padding", x5(e)) : x5(this.signal("padding"))
         },
         autosize(e) {
             return arguments.length ? this.signal("autosize", e) : this.signal("autosize")
         },
         background(e) {
             return arguments.length ? this.signal("background", e) : this.signal("background")
         },
         renderer(e) {
-            return arguments.length ? (n1(e) || U("Unrecognized renderer type: " + e), e !== this._renderType && (this._renderType = e, this._resetRenderer()), this) : this._renderType
+            return arguments.length ? (T1(e) || q("Unrecognized renderer type: " + e), e !== this._renderType && (this._renderType = e, this._resetRenderer()), this) : this._renderType
         },
         tooltip(e) {
             return arguments.length ? (e !== this._tooltip && (this._tooltip = e, this._resetRenderer()), this) : this._tooltip
         },
         loader(e) {
-            return arguments.length ? (e !== this._loader && (wu.prototype.loader.call(this, e), this._resetRenderer()), this) : this._loader
+            return arguments.length ? (e !== this._loader && (Wu.prototype.loader.call(this, e), this._resetRenderer()), this) : this._loader
         },
         resize() {
-            return this._autosize = 1, this.touch(kg(this, "autosize"))
+            return this._autosize = 1, this.touch(Hg(this, "autosize"))
         },
         _resetRenderer() {
             this._renderer && (this._renderer = null, this.initialize(this._el, this._elBind))
         },
-        _resizeView: aae,
+        _resizeView: Sse,
         addEventListener(e, t, n) {
             let i = t;
-            return n && n.trap === !1 || (i = JS(this, t), i.raw = t), this._handler.on(e, i), this
+            return n && n.trap === !1 || (i = BE(this, t), i.raw = t), this._handler.on(e, i), this
         },
         removeEventListener(e, t) {
             for (var n = this._handler.handlers(e), i = n.length, r, s; --i >= 0;)
                 if (s = n[i].type, r = n[i].handler, e === s && (t === r || t === r.raw)) {
                     this._handler.off(s, r);
                     break
                 } return this
@@ -32508,1092 +25745,1093 @@
         },
         removeResizeListener(e) {
             var t = this._resizeListeners,
                 n = t.indexOf(e);
             return n >= 0 && t.splice(n, 1), this
         },
         addSignalListener(e, t) {
-            return t5(this, e, kg(this, e), t)
+            return w5(this, e, Hg(this, e), t)
         },
         removeSignalListener(e, t) {
-            return n5(this, kg(this, e), t)
+            return S5(this, Hg(this, e), t)
         },
         addDataListener(e, t) {
-            return t5(this, e, M0(this, e).values, t)
+            return w5(this, e, f0(this, e).values, t)
         },
         removeDataListener(e, t) {
-            return n5(this, M0(this, e).values, t)
+            return S5(this, f0(this, e).values, t)
         },
         globalCursor(e) {
             if (arguments.length) {
                 if (this._globalCursor !== !!e) {
-                    const t = D2(this, null);
-                    this._globalCursor = !!e, t && D2(this, t)
+                    const t = fx(this, null);
+                    this._globalCursor = !!e, t && fx(this, t)
                 }
                 return this
             } else return this._globalCursor
         },
         preventDefault(e) {
             return arguments.length ? (this._preventDefault = e, this) : this._preventDefault
         },
-        timer: fae,
-        events: Nse,
-        finalize: Lse,
-        hover: Pse,
-        data: Ese,
-        change: u1,
-        insert: Cse,
-        remove: kse,
-        scale: rae,
-        initialize: Jse,
-        toImageURL: Zse,
-        toCanvas: tae,
-        toSVG: nae,
-        getState: oae,
-        setState: cae
-    });
-    const pae = "view",
-        F0 = "[",
-        R0 = "]",
-        TL = "{",
-        ML = "}",
-        mae = ":",
-        OL = ",",
-        yae = "@",
-        vae = ">",
-        bae = /[[\]{}]/,
-        xae = {
+        timer: $se,
+        events: Qre,
+        finalize: ese,
+        hover: Zre,
+        data: jre,
+        change: j1,
+        insert: Gre,
+        remove: Ure,
+        scale: _se,
+        initialize: gse,
+        toImageURL: mse,
+        toCanvas: vse,
+        toSVG: bse,
+        getState: Ese,
+        setState: Ase
+    });
+    const Fse = "view",
+        d0 = "[",
+        g0 = "]",
+        fI = "{",
+        hI = "}",
+        Rse = ":",
+        dI = ",",
+        Dse = "@",
+        Nse = ">",
+        Pse = /[[\]{}]/,
+        Lse = {
             "*": 1,
             arc: 1,
             area: 1,
             group: 1,
             image: 1,
             line: 1,
             path: 1,
             rect: 1,
             rule: 1,
             shape: 1,
             symbol: 1,
             text: 1,
             trail: 1
         };
-    let FL, RL;
+    let gI, pI;
 
-    function to(e, t, n) {
-        return FL = t || pae, RL = n || xae, DL(e.trim()).map(N2)
+    function wo(e, t, n) {
+        return gI = t || Fse, pI = n || Lse, mI(e.trim()).map(hx)
     }
 
-    function _ae(e) {
-        return RL[e]
+    function Ise(e) {
+        return pI[e]
     }
 
-    function ah(e, t, n, i, r) {
+    function Dh(e, t, n, i, r) {
         const s = e.length;
         let a = 0,
             o;
         for (; t < s; ++t) {
             if (o = e[t], !a && o === n) return t;
             r && r.indexOf(o) >= 0 ? --a : i && i.indexOf(o) >= 0 && ++a
         }
         return t
     }
 
-    function DL(e) {
+    function mI(e) {
         const t = [],
             n = e.length;
         let i = 0,
             r = 0;
-        for (; r < n;) r = ah(e, r, OL, F0 + TL, R0 + ML), t.push(e.substring(i, r).trim()), i = ++r;
+        for (; r < n;) r = Dh(e, r, dI, d0 + fI, g0 + hI), t.push(e.substring(i, r).trim()), i = ++r;
         if (t.length === 0) throw "Empty event selector: " + e;
         return t
     }
 
-    function N2(e) {
-        return e[0] === "[" ? wae(e) : Sae(e)
+    function hx(e) {
+        return e[0] === "[" ? zse(e) : Bse(e)
     }
 
-    function wae(e) {
+    function zse(e) {
         const t = e.length;
         let n = 1,
             i;
-        if (n = ah(e, n, R0, F0, R0), n === t) throw "Empty between selector: " + e;
-        if (i = DL(e.substring(1, n)), i.length !== 2) throw "Between selector must have two elements: " + e;
-        if (e = e.slice(n + 1).trim(), e[0] !== vae) throw "Expected '>' after between selector: " + e;
-        i = i.map(N2);
-        const r = N2(e.slice(1).trim());
+        if (n = Dh(e, n, g0, d0, g0), n === t) throw "Empty between selector: " + e;
+        if (i = mI(e.substring(1, n)), i.length !== 2) throw "Between selector must have two elements: " + e;
+        if (e = e.slice(n + 1).trim(), e[0] !== Nse) throw "Expected '>' after between selector: " + e;
+        i = i.map(hx);
+        const r = hx(e.slice(1).trim());
         return r.between ? {
             between: i,
             stream: r
         } : (r.between = i, r)
     }
 
-    function Sae(e) {
+    function Bse(e) {
         const t = {
-                source: FL
+                source: gI
             },
             n = [];
         let i = [0, 0],
             r = 0,
             s = 0,
             a = e.length,
             o = 0,
             l, u;
-        if (e[a - 1] === ML) {
-            if (o = e.lastIndexOf(TL), o >= 0) {
+        if (e[a - 1] === hI) {
+            if (o = e.lastIndexOf(fI), o >= 0) {
                 try {
-                    i = Eae(e.substring(o + 1, a - 1))
+                    i = jse(e.substring(o + 1, a - 1))
                 } catch {
                     throw "Invalid throttle specification: " + e
                 }
                 e = e.slice(0, o).trim(), a = e.length
             } else throw "Unmatched right brace: " + e;
             o = 0
         }
         if (!a) throw e;
-        if (e[0] === yae && (r = ++o), l = ah(e, o, mae), l < a && (n.push(e.substring(s, l).trim()), s = o = ++l), o = ah(e, o, F0), o === a) n.push(e.substring(s, a).trim());
+        if (e[0] === Dse && (r = ++o), l = Dh(e, o, Rse), l < a && (n.push(e.substring(s, l).trim()), s = o = ++l), o = Dh(e, o, d0), o === a) n.push(e.substring(s, a).trim());
         else if (n.push(e.substring(s, o).trim()), u = [], s = ++o, s === a) throw "Unmatched left bracket: " + e;
         for (; o < a;) {
-            if (o = ah(e, o, R0), o === a) throw "Unmatched left bracket: " + e;
-            if (u.push(e.substring(s, o).trim()), o < a - 1 && e[++o] !== F0) throw "Expected left bracket: " + e;
+            if (o = Dh(e, o, g0), o === a) throw "Unmatched left bracket: " + e;
+            if (u.push(e.substring(s, o).trim()), o < a - 1 && e[++o] !== d0) throw "Expected left bracket: " + e;
             s = ++o
         }
-        if (!(a = n.length) || bae.test(n[a - 1])) throw "Invalid event selector: " + e;
-        return a > 1 ? (t.type = n[1], r ? t.markname = n[0].slice(1) : _ae(n[0]) ? t.marktype = n[0] : t.source = n[0]) : t.type = n[0], t.type.slice(-1) === "!" && (t.consume = !0, t.type = t.type.slice(0, -1)), u != null && (t.filter = u), i[0] && (t.throttle = i[0]), i[1] && (t.debounce = i[1]), t
+        if (!(a = n.length) || Pse.test(n[a - 1])) throw "Invalid event selector: " + e;
+        return a > 1 ? (t.type = n[1], r ? t.markname = n[0].slice(1) : Ise(n[0]) ? t.marktype = n[0] : t.source = n[0]) : t.type = n[0], t.type.slice(-1) === "!" && (t.consume = !0, t.type = t.type.slice(0, -1)), u != null && (t.filter = u), i[0] && (t.throttle = i[0]), i[1] && (t.debounce = i[1]), t
     }
 
-    function Eae(e) {
-        const t = e.split(OL);
+    function jse(e) {
+        const t = e.split(dI);
         if (!e.length || t.length > 2) throw e;
         return t.map(n => {
             const i = +n;
             if (i !== i) throw e;
             return i
         })
     }
 
-    function Cae(e) {
-        return ae(e) ? e : {
+    function Gse(e) {
+        return ce(e) ? e : {
             type: e || "pad"
         }
     }
-    const of = e => +e || 0, kae = e => ({
-        top: e,
-        bottom: e,
-        left: e,
-        right: e
-    });
-
-    function Aae(e) {
-        return ae(e) ? e.signal ? e : {
-            top: of(e.top),
-            bottom: of(e.bottom),
-            left: of(e.left),
-            right: of(e.right)
-        } : kae(of(e))
+    const Rf = e => +e || 0,
+        Use = e => ({
+            top: e,
+            bottom: e,
+            left: e,
+            right: e
+        });
+
+    function Wse(e) {
+        return ce(e) ? e.signal ? e : {
+            top: Rf(e.top),
+            bottom: Rf(e.bottom),
+            left: Rf(e.left),
+            right: Rf(e.right)
+        } : Use(Rf(e))
     }
-    const jt = e => ae(e) && !W(e) ? Ae({}, e) : {
+    const rn = e => ce(e) && !H(e) ? Ne({}, e) : {
         value: e
     };
 
-    function i5(e, t, n, i) {
-        return n != null ? (ae(n) && !W(n) || W(n) && n.length && ae(n[0]) ? e.update[t] = n : e[i || "enter"][t] = {
+    function E5(e, t, n, i) {
+        return n != null ? (ce(n) && !H(n) || H(n) && n.length && ce(n[0]) ? e.update[t] = n : e[i || "enter"][t] = {
             value: n
         }, 1) : 0
     }
 
-    function Zt(e, t, n) {
-        for (const i in t) i5(e, i, t[i]);
-        for (const i in n) i5(e, i, n[i], "update")
+    function xn(e, t, n) {
+        for (const i in t) E5(e, i, t[i]);
+        for (const i in n) E5(e, i, n[i], "update")
     }
 
-    function Ac(e, t, n) {
-        for (const i in t) n && me(n, i) || (e[i] = Ae(e[i] || {}, t[i]));
+    function Zc(e, t, n) {
+        for (const i in t) n && Ce(n, i) || (e[i] = Ne(e[i] || {}, t[i]));
         return e
     }
 
-    function ou(e, t) {
+    function Du(e, t) {
         return t && (t.enter && t.enter[e] || t.update && t.update[e])
     }
-    const eE = "mark",
-        tE = "frame",
-        nE = "scope",
-        $ae = "axis",
-        Tae = "axis-domain",
-        Mae = "axis-grid",
-        Oae = "axis-label",
-        Fae = "axis-tick",
-        Rae = "axis-title",
-        Dae = "legend",
-        Nae = "legend-band",
-        Pae = "legend-entry",
-        Lae = "legend-gradient",
-        NL = "legend-label",
-        Iae = "legend-symbol",
-        zae = "legend-title",
-        Bae = "title",
-        jae = "title-text",
-        Uae = "title-subtitle";
+    const UE = "mark",
+        WE = "frame",
+        qE = "scope",
+        qse = "axis",
+        Hse = "axis-domain",
+        Yse = "axis-grid",
+        Xse = "axis-label",
+        Vse = "axis-tick",
+        Kse = "axis-title",
+        Jse = "legend",
+        Qse = "legend-band",
+        Zse = "legend-entry",
+        eae = "legend-gradient",
+        yI = "legend-label",
+        tae = "legend-symbol",
+        nae = "legend-title",
+        iae = "title",
+        rae = "title-text",
+        sae = "title-subtitle";
 
-    function Gae(e, t, n, i, r) {
+    function aae(e, t, n, i, r) {
         const s = {},
             a = {};
         let o, l, u, c;
-        l = "lineBreak", t === "text" && r[l] != null && !ou(l, e) && wv(s, l, r[l]), (n == "legend" || String(n).startsWith("axis")) && (n = null), c = n === tE ? r.group : n === eE ? Ae({}, r.mark, r[t]) : null;
-        for (l in c) u = ou(l, e) || (l === "fill" || l === "stroke") && (ou("fill", e) || ou("stroke", e)), u || wv(s, l, c[l]);
-        se(i).forEach(f => {
+        l = "lineBreak", t === "text" && r[l] != null && !Du(l, e) && Jv(s, l, r[l]), (n == "legend" || String(n).startsWith("axis")) && (n = null), c = n === WE ? r.group : n === UE ? Ne({}, r.mark, r[t]) : null;
+        for (l in c) u = Du(l, e) || (l === "fill" || l === "stroke") && (Du("fill", e) || Du("stroke", e)), u || Jv(s, l, c[l]);
+        ue(i).forEach(f => {
             const h = r.style && r.style[f];
-            for (const d in h) ou(d, e) || wv(s, d, h[d])
-        }), e = Ae({}, e);
+            for (const d in h) Du(d, e) || Jv(s, d, h[d])
+        }), e = Ne({}, e);
         for (l in s) c = s[l], c.signal ? (o = o || {})[l] = c : a[l] = c;
-        return e.enter = Ae(a, e.enter), o && (e.update = Ae(o, e.update)), e
+        return e.enter = Ne(a, e.enter), o && (e.update = Ne(o, e.update)), e
     }
 
-    function wv(e, t, n) {
+    function Jv(e, t, n) {
         e[t] = n && n.signal ? {
             signal: n.signal
         } : {
             value: n
         }
     }
-    const PL = e => re(e) ? Z(e) : e.signal ? `(${e.signal})` : LL(e);
+    const vI = e => le(e) ? te(e) : e.signal ? `(${e.signal})` : bI(e);
 
-    function f1(e) {
-        if (e.gradient != null) return qae(e);
-        let t = e.signal ? `(${e.signal})` : e.color ? Wae(e.color) : e.field != null ? LL(e.field) : e.value !== void 0 ? Z(e.value) : void 0;
-        return e.scale != null && (t = Hae(e, t)), t === void 0 && (t = null), e.exponent != null && (t = `pow(${t},${up(e.exponent)})`), e.mult != null && (t += `*${up(e.mult)}`), e.offset != null && (t += `+${up(e.offset)}`), e.round && (t = `round(${t})`), t
+    function U1(e) {
+        if (e.gradient != null) return lae(e);
+        let t = e.signal ? `(${e.signal})` : e.color ? oae(e.color) : e.field != null ? bI(e.field) : e.value !== void 0 ? te(e.value) : void 0;
+        return e.scale != null && (t = uae(e, t)), t === void 0 && (t = null), e.exponent != null && (t = `pow(${t},${zp(e.exponent)})`), e.mult != null && (t += `*${zp(e.mult)}`), e.offset != null && (t += `+${zp(e.offset)}`), e.round && (t = `round(${t})`), t
     }
-    const Ag = (e, t, n, i) => `(${e}(${[t,n,i].map(f1).join(",")})+'')`;
+    const Yg = (e, t, n, i) => `(${e}(${[t,n,i].map(U1).join(",")})+'')`;
 
-    function Wae(e) {
-        return e.c ? Ag("hcl", e.h, e.c, e.l) : e.h || e.s ? Ag("hsl", e.h, e.s, e.l) : e.l || e.a ? Ag("lab", e.l, e.a, e.b) : e.r || e.g || e.b ? Ag("rgb", e.r, e.g, e.b) : null
+    function oae(e) {
+        return e.c ? Yg("hcl", e.h, e.c, e.l) : e.h || e.s ? Yg("hsl", e.h, e.s, e.l) : e.l || e.a ? Yg("lab", e.l, e.a, e.b) : e.r || e.g || e.b ? Yg("rgb", e.r, e.g, e.b) : null
     }
 
-    function qae(e) {
-        const t = [e.start, e.stop, e.count].map(n => n == null ? null : Z(n));
-        for (; t.length && De(t) == null;) t.pop();
-        return t.unshift(PL(e.gradient)), `gradient(${t.join(",")})`
+    function lae(e) {
+        const t = [e.start, e.stop, e.count].map(n => n == null ? null : te(n));
+        for (; t.length && We(t) == null;) t.pop();
+        return t.unshift(vI(e.gradient)), `gradient(${t.join(",")})`
     }
 
-    function up(e) {
-        return ae(e) ? "(" + f1(e) + ")" : e
+    function zp(e) {
+        return ce(e) ? "(" + U1(e) + ")" : e
     }
 
-    function LL(e) {
-        return IL(ae(e) ? e : {
+    function bI(e) {
+        return xI(ce(e) ? e : {
             datum: e
         })
     }
 
-    function IL(e) {
+    function xI(e) {
         let t, n, i;
         if (e.signal) t = "datum", i = e.signal;
         else if (e.group || e.parent) {
             for (n = Math.max(1, e.level || 1), t = "item"; n-- > 0;) t += ".mark.group";
             e.parent ? (i = e.parent, t += ".datum") : i = e.group
-        } else e.datum ? (t = "datum", i = e.datum) : U("Invalid field reference: " + Z(e));
-        return e.signal || (i = re(i) ? ns(i).map(Z).join("][") : IL(i)), t + "[" + i + "]"
+        } else e.datum ? (t = "datum", i = e.datum) : q("Invalid field reference: " + te(e));
+        return e.signal || (i = le(i) ? gs(i).map(te).join("][") : xI(i)), t + "[" + i + "]"
     }
 
-    function Hae(e, t) {
-        const n = PL(e.scale);
-        return e.range != null ? t = `lerp(_range(${n}), ${+e.range})` : (t !== void 0 && (t = `_scale(${n}, ${t})`), e.band && (t = (t ? t + "+" : "") + `_bandwidth(${n})` + (+e.band == 1 ? "" : "*" + up(e.band)), e.extra && (t = `(datum.extra ? _scale(${n}, datum.extra.value) : ${t})`)), t == null && (t = "0")), t
+    function uae(e, t) {
+        const n = vI(e.scale);
+        return e.range != null ? t = `lerp(_range(${n}), ${+e.range})` : (t !== void 0 && (t = `_scale(${n}, ${t})`), e.band && (t = (t ? t + "+" : "") + `_bandwidth(${n})` + (+e.band == 1 ? "" : "*" + zp(e.band)), e.extra && (t = `(datum.extra ? _scale(${n}, datum.extra.value) : ${t})`)), t == null && (t = "0")), t
     }
 
-    function Yae(e) {
+    function cae(e) {
         let t = "";
         return e.forEach(n => {
-            const i = f1(n);
+            const i = U1(n);
             t += n.test ? `(${n.test})?${i}:` : i
-        }), De(t) === ":" && (t += "null"), t
+        }), We(t) === ":" && (t += "null"), t
     }
 
-    function zL(e, t, n, i, r, s) {
+    function _I(e, t, n, i, r, s) {
         const a = {};
         s = s || {}, s.encoders = {
             $encode: a
-        }, e = Gae(e, t, n, i, r.config);
-        for (const o in e) a[o] = Xae(e[o], t, s, r);
+        }, e = aae(e, t, n, i, r.config);
+        for (const o in e) a[o] = fae(e[o], t, s, r);
         return s
     }
 
-    function Xae(e, t, n, i) {
+    function fae(e, t, n, i) {
         const r = {},
             s = {};
-        for (const a in e) e[a] != null && (r[a] = Kae(Vae(e[a]), i, n, s));
+        for (const a in e) e[a] != null && (r[a] = dae(hae(e[a]), i, n, s));
         return {
             $expr: {
                 marktype: t,
                 channels: r
             },
             $fields: Object.keys(s),
             $output: Object.keys(e)
         }
     }
 
-    function Vae(e) {
-        return W(e) ? Yae(e) : f1(e)
+    function hae(e) {
+        return H(e) ? cae(e) : U1(e)
     }
 
-    function Kae(e, t, n, i) {
-        const r = Xr(e, t);
-        return r.$fields.forEach(s => i[s] = 1), Ae(n, r.$params), r.$expr
+    function dae(e, t, n, i) {
+        const r = cs(e, t);
+        return r.$fields.forEach(s => i[s] = 1), Ne(n, r.$params), r.$expr
     }
-    const Jae = "outer",
-        Qae = ["value", "update", "init", "react", "bind"];
+    const gae = "outer",
+        pae = ["value", "update", "init", "react", "bind"];
 
-    function r5(e, t) {
-        U(e + ' for "outer" push: ' + Z(t))
+    function k5(e, t) {
+        q(e + ' for "outer" push: ' + te(t))
     }
 
-    function BL(e, t) {
+    function wI(e, t) {
         const n = e.name;
-        if (e.push === Jae) t.signals[n] || r5("No prior signal definition", n), Qae.forEach(i => {
-            e[i] !== void 0 && r5("Invalid property ", i)
+        if (e.push === gae) t.signals[n] || k5("No prior signal definition", n), pae.forEach(i => {
+            e[i] !== void 0 && k5("Invalid property ", i)
         });
         else {
             const i = t.addSignal(n, e.value);
             e.react === !1 && (i.react = !1), e.bind && t.addBinding(n, e.bind)
         }
     }
 
-    function P2(e, t, n, i) {
+    function dx(e, t, n, i) {
         this.id = -1, this.type = e, this.value = t, this.params = n, i && (this.parent = i)
     }
 
-    function h1(e, t, n, i) {
-        return new P2(e, t, n, i)
+    function W1(e, t, n, i) {
+        return new dx(e, t, n, i)
     }
 
-    function D0(e, t) {
-        return h1("operator", e, t)
+    function p0(e, t) {
+        return W1("operator", e, t)
     }
 
-    function de(e) {
+    function Se(e) {
         const t = {
             $ref: e.id
         };
         return e.id < 0 && (e.refs = e.refs || []).push(t), t
     }
 
-    function Nh(e, t) {
+    function cd(e, t) {
         return t ? {
             $field: e,
             $name: t
         } : {
             $field: e
         }
     }
-    const L2 = Nh("key");
+    const gx = cd("key");
 
-    function s5(e, t) {
+    function C5(e, t) {
         return {
             $compare: e,
             $order: t
         }
     }
 
-    function Zae(e, t) {
+    function mae(e, t) {
         const n = {
             $key: e
         };
         return t && (n.$flat = !0), n
     }
-    const eoe = "ascending",
-        toe = "descending";
+    const yae = "ascending",
+        vae = "descending";
 
-    function noe(e) {
-        return ae(e) ? (e.order === toe ? "-" : "+") + d1(e.op, e.field) : ""
+    function bae(e) {
+        return ce(e) ? (e.order === vae ? "-" : "+") + q1(e.op, e.field) : ""
     }
 
-    function d1(e, t) {
+    function q1(e, t) {
         return (e && e.signal ? "$" + e.signal : e || "") + (e && t ? "_" : "") + (t && t.signal ? "$" + t.signal : t || "")
     }
-    const iE = "scope",
-        I2 = "view";
+    const HE = "scope",
+        px = "view";
 
-    function Ft(e) {
+    function Xt(e) {
         return e && e.signal
     }
 
-    function ioe(e) {
+    function xae(e) {
         return e && e.expr
     }
 
-    function cp(e) {
-        if (Ft(e)) return !0;
-        if (ae(e)) {
+    function Bp(e) {
+        if (Xt(e)) return !0;
+        if (ce(e)) {
             for (const t in e)
-                if (cp(e[t])) return !0
+                if (Bp(e[t])) return !0
         }
         return !1
     }
 
-    function Yi(e, t) {
+    function ur(e, t) {
         return e ?? t
     }
 
-    function Wo(e) {
+    function gl(e) {
         return e && e.signal || e
     }
-    const a5 = "timer";
+    const A5 = "timer";
 
-    function Ph(e, t) {
-        return (e.merge ? soe : e.stream ? aoe : e.type ? ooe : U("Invalid stream specification: " + Z(e)))(e, t)
+    function fd(e, t) {
+        return (e.merge ? wae : e.stream ? Sae : e.type ? Eae : q("Invalid stream specification: " + te(e)))(e, t)
     }
 
-    function roe(e) {
-        return e === iE ? I2 : e || I2
+    function _ae(e) {
+        return e === HE ? px : e || px
     }
 
-    function soe(e, t) {
-        const n = e.merge.map(r => Ph(r, t)),
-            i = rE({
+    function wae(e, t) {
+        const n = e.merge.map(r => fd(r, t)),
+            i = YE({
                 merge: n
             }, e, t);
         return t.addStream(i).id
     }
 
-    function aoe(e, t) {
-        const n = Ph(e.stream, t),
-            i = rE({
+    function Sae(e, t) {
+        const n = fd(e.stream, t),
+            i = YE({
                 stream: n
             }, e, t);
         return t.addStream(i).id
     }
 
-    function ooe(e, t) {
+    function Eae(e, t) {
         let n;
-        e.type === a5 ? (n = t.event(a5, e.throttle), e = {
+        e.type === A5 ? (n = t.event(A5, e.throttle), e = {
             between: e.between,
             filter: e.filter
-        }) : n = t.event(roe(e.source), e.type);
-        const i = rE({
+        }) : n = t.event(_ae(e.source), e.type);
+        const i = YE({
             stream: n
         }, e, t);
         return Object.keys(i).length === 1 ? n : t.addStream(i).id
     }
 
-    function rE(e, t, n) {
+    function YE(e, t, n) {
         let i = t.between;
-        return i && (i.length !== 2 && U('Stream "between" parameter must have 2 entries: ' + Z(t)), e.between = [Ph(i[0], n), Ph(i[1], n)]), i = t.filter ? [].concat(t.filter) : [], (t.marktype || t.markname || t.markrole) && i.push(loe(t.marktype, t.markname, t.markrole)), t.source === iE && i.push("inScope(event.item)"), i.length && (e.filter = Xr("(" + i.join(")&&(") + ")", n).$expr), (i = t.throttle) != null && (e.throttle = +i), (i = t.debounce) != null && (e.debounce = +i), t.consume && (e.consume = !0), e
+        return i && (i.length !== 2 && q('Stream "between" parameter must have 2 entries: ' + te(t)), e.between = [fd(i[0], n), fd(i[1], n)]), i = t.filter ? [].concat(t.filter) : [], (t.marktype || t.markname || t.markrole) && i.push(kae(t.marktype, t.markname, t.markrole)), t.source === HE && i.push("inScope(event.item)"), i.length && (e.filter = cs("(" + i.join(")&&(") + ")", n).$expr), (i = t.throttle) != null && (e.throttle = +i), (i = t.debounce) != null && (e.debounce = +i), t.consume && (e.consume = !0), e
     }
 
-    function loe(e, t, n) {
+    function kae(e, t, n) {
         const i = "event.item";
         return i + (e && e !== "*" ? "&&" + i + ".mark.marktype==='" + e + "'" : "") + (n ? "&&" + i + ".mark.role==='" + n + "'" : "") + (t ? "&&" + i + ".mark.name==='" + t + "'" : "")
     }
-    const uoe = {
+    const Cae = {
         code: "_.$value",
         ast: {
             type: "Identifier",
             value: "value"
         }
     };
 
-    function coe(e, t, n) {
+    function Aae(e, t, n) {
         const i = e.encode,
             r = {
                 target: n
             };
         let s = e.events,
             a = e.update,
             o = [];
-        s || U("Signal update missing events specification."), re(s) && (s = to(s, t.isSubscope() ? iE : I2)), s = se(s).filter(l => l.signal || l.scale ? (o.push(l), 0) : 1), o.length > 1 && (o = [hoe(o)]), s.length && o.push(s.length > 1 ? {
+        s || q("Signal update missing events specification."), le(s) && (s = wo(s, t.isSubscope() ? HE : px)), s = ue(s).filter(l => l.signal || l.scale ? (o.push(l), 0) : 1), o.length > 1 && (o = [Tae(o)]), s.length && o.push(s.length > 1 ? {
             merge: s
-        } : s[0]), i != null && (a && U("Signal encode and update are mutually exclusive."), a = "encode(item()," + Z(i) + ")"), r.update = re(a) ? Xr(a, t) : a.expr != null ? Xr(a.expr, t) : a.value != null ? a.value : a.signal != null ? {
-            $expr: uoe,
+        } : s[0]), i != null && (a && q("Signal encode and update are mutually exclusive."), a = "encode(item()," + te(i) + ")"), r.update = le(a) ? cs(a, t) : a.expr != null ? cs(a.expr, t) : a.value != null ? a.value : a.signal != null ? {
+            $expr: Cae,
             $params: {
                 $value: t.signalRef(a.signal)
             }
-        } : U("Invalid signal update specification."), e.force && (r.options = {
+        } : q("Invalid signal update specification."), e.force && (r.options = {
             force: !0
-        }), o.forEach(l => t.addUpdate(Ae(foe(l, t), r)))
+        }), o.forEach(l => t.addUpdate(Ne($ae(l, t), r)))
     }
 
-    function foe(e, t) {
+    function $ae(e, t) {
         return {
-            source: e.signal ? t.signalRef(e.signal) : e.scale ? t.scaleRef(e.scale) : Ph(e, t)
+            source: e.signal ? t.signalRef(e.signal) : e.scale ? t.scaleRef(e.scale) : fd(e, t)
         }
     }
 
-    function hoe(e) {
+    function Tae(e) {
         return {
             signal: "[" + e.map(t => t.scale ? 'scale("' + t.scale + '")' : t.signal) + "]"
         }
     }
 
-    function doe(e, t) {
+    function Mae(e, t) {
         const n = t.getSignal(e.name);
         let i = e.update;
-        e.init && (i ? U("Signals can not include both init and update expressions.") : (i = e.init, n.initonly = !0)), i && (i = Xr(i, t), n.update = i.$expr, n.params = i.$params), e.on && e.on.forEach(r => coe(r, t, n.id))
+        e.init && (i ? q("Signals can not include both init and update expressions.") : (i = e.init, n.initonly = !0)), i && (i = cs(i, t), n.update = i.$expr, n.params = i.$params), e.on && e.on.forEach(r => Aae(r, t, n.id))
     }
-    const tt = e => (t, n, i) => h1(e, n, t || void 0, i),
-        jL = tt("aggregate"),
-        goe = tt("axisticks"),
-        UL = tt("bound"),
-        vr = tt("collect"),
-        o5 = tt("compare"),
-        poe = tt("datajoin"),
-        GL = tt("encode"),
-        moe = tt("expression"),
-        yoe = tt("facet"),
-        voe = tt("field"),
-        boe = tt("key"),
-        xoe = tt("legendentries"),
-        _oe = tt("load"),
-        woe = tt("mark"),
-        Soe = tt("multiextent"),
-        Eoe = tt("multivalues"),
-        Coe = tt("overlap"),
-        koe = tt("params"),
-        WL = tt("prefacet"),
-        Aoe = tt("projection"),
-        $oe = tt("proxy"),
-        Toe = tt("relay"),
-        qL = tt("render"),
-        Moe = tt("scale"),
-        Fl = tt("sieve"),
-        Ooe = tt("sortitems"),
-        HL = tt("viewlayout"),
-        Foe = tt("values");
-    let Roe = 0;
-    const YL = {
+    const ht = e => (t, n, i) => W1(e, n, t || void 0, i),
+        SI = ht("aggregate"),
+        Oae = ht("axisticks"),
+        EI = ht("bound"),
+        Fr = ht("collect"),
+        $5 = ht("compare"),
+        Fae = ht("datajoin"),
+        kI = ht("encode"),
+        Rae = ht("expression"),
+        Dae = ht("facet"),
+        Nae = ht("field"),
+        Pae = ht("key"),
+        Lae = ht("legendentries"),
+        Iae = ht("load"),
+        zae = ht("mark"),
+        Bae = ht("multiextent"),
+        jae = ht("multivalues"),
+        Gae = ht("overlap"),
+        Uae = ht("params"),
+        CI = ht("prefacet"),
+        Wae = ht("projection"),
+        qae = ht("proxy"),
+        Hae = ht("relay"),
+        AI = ht("render"),
+        Yae = ht("scale"),
+        Ql = ht("sieve"),
+        Xae = ht("sortitems"),
+        $I = ht("viewlayout"),
+        Vae = ht("values");
+    let Kae = 0;
+    const TI = {
         min: "min",
         max: "max",
         count: "sum"
     };
 
-    function Doe(e, t) {
+    function Jae(e, t) {
         const n = e.type || "linear";
-        jN(n) || U("Unrecognized scale type: " + Z(n)), t.addScale(e.name, {
+        SN(n) || q("Unrecognized scale type: " + te(n)), t.addScale(e.name, {
             type: n,
             domain: void 0
         })
     }
 
-    function Noe(e, t) {
+    function Qae(e, t) {
         const n = t.getScale(e.name).params;
         let i;
-        n.domain = XL(e.domain, e, t), e.range != null && (n.range = KL(e, t, n)), e.interpolate != null && qoe(e.interpolate, n), e.nice != null && (n.nice = Woe(e.nice)), e.bins != null && (n.bins = Goe(e.bins, t));
-        for (i in e) me(n, i) || i === "name" || (n[i] = $i(e[i], t))
+        n.domain = MI(e.domain, e, t), e.range != null && (n.range = FI(e, t, n)), e.interpolate != null && loe(e.interpolate, n), e.nice != null && (n.nice = ooe(e.nice)), e.bins != null && (n.bins = aoe(e.bins, t));
+        for (i in e) Ce(n, i) || i === "name" || (n[i] = Gi(e[i], t))
     }
 
-    function $i(e, t) {
-        return ae(e) ? e.signal ? t.signalRef(e.signal) : U("Unsupported object: " + Z(e)) : e
+    function Gi(e, t) {
+        return ce(e) ? e.signal ? t.signalRef(e.signal) : q("Unsupported object: " + te(e)) : e
     }
 
-    function fp(e, t) {
-        return e.signal ? t.signalRef(e.signal) : e.map(n => $i(n, t))
+    function jp(e, t) {
+        return e.signal ? t.signalRef(e.signal) : e.map(n => Gi(n, t))
     }
 
-    function g1(e) {
-        U("Can not find data set: " + Z(e))
+    function H1(e) {
+        q("Can not find data set: " + te(e))
     }
 
-    function XL(e, t, n) {
+    function MI(e, t, n) {
         if (!e) {
-            (t.domainMin != null || t.domainMax != null) && U("No scale domain defined for domainMin/domainMax to override.");
+            (t.domainMin != null || t.domainMax != null) && q("No scale domain defined for domainMin/domainMax to override.");
             return
         }
-        return e.signal ? n.signalRef(e.signal) : (W(e) ? Poe : e.fields ? Ioe : Loe)(e, t, n)
+        return e.signal ? n.signalRef(e.signal) : (H(e) ? Zae : e.fields ? toe : eoe)(e, t, n)
     }
 
-    function Poe(e, t, n) {
-        return e.map(i => $i(i, n))
+    function Zae(e, t, n) {
+        return e.map(i => Gi(i, n))
     }
 
-    function Loe(e, t, n) {
+    function eoe(e, t, n) {
         const i = n.getData(e.data);
-        return i || g1(e.data), qu(t.type) ? i.valuesRef(n, e.field, VL(e.sort, !1)) : WN(t.type) ? i.domainRef(n, e.field) : i.extentRef(n, e.field)
+        return i || H1(e.data), dc(t.type) ? i.valuesRef(n, e.field, OI(e.sort, !1)) : CN(t.type) ? i.domainRef(n, e.field) : i.extentRef(n, e.field)
     }
 
-    function Ioe(e, t, n) {
+    function toe(e, t, n) {
         const i = e.data,
-            r = e.fields.reduce((s, a) => (a = re(a) ? {
+            r = e.fields.reduce((s, a) => (a = le(a) ? {
                 data: i,
                 field: a
-            } : W(a) || a.signal ? zoe(a, n) : a, s.push(a), s), []);
-        return (qu(t.type) ? Boe : WN(t.type) ? joe : Uoe)(e, n, r)
+            } : H(a) || a.signal ? noe(a, n) : a, s.push(a), s), []);
+        return (dc(t.type) ? ioe : CN(t.type) ? roe : soe)(e, n, r)
     }
 
-    function zoe(e, t) {
-        const n = "_:vega:_" + Roe++,
-            i = vr({});
-        if (W(e)) i.value = {
+    function noe(e, t) {
+        const n = "_:vega:_" + Kae++,
+            i = Fr({});
+        if (H(e)) i.value = {
             $ingest: e
         };
         else if (e.signal) {
-            const r = "setdata(" + Z(n) + "," + e.signal + ")";
+            const r = "setdata(" + te(n) + "," + e.signal + ")";
             i.params.input = t.signalRef(r)
         }
-        return t.addDataPipeline(n, [i, Fl({})]), {
+        return t.addDataPipeline(n, [i, Ql({})]), {
             data: n,
             field: "data"
         }
     }
 
-    function Boe(e, t, n) {
-        const i = VL(e.sort, !0);
+    function ioe(e, t, n) {
+        const i = OI(e.sort, !0);
         let r, s;
         const a = n.map(u => {
                 const c = t.getData(u.data);
-                return c || g1(u.data), c.countsRef(t, u.field, i)
+                return c || H1(u.data), c.countsRef(t, u.field, i)
             }),
             o = {
-                groupby: L2,
+                groupby: gx,
                 pulse: a
             };
-        i && (r = i.op || "count", s = i.field ? d1(r, i.field) : "count", o.ops = [YL[r]], o.fields = [t.fieldRef(s)], o.as = [s]), r = t.add(jL(o));
-        const l = t.add(vr({
-            pulse: de(r)
+        i && (r = i.op || "count", s = i.field ? q1(r, i.field) : "count", o.ops = [TI[r]], o.fields = [t.fieldRef(s)], o.as = [s]), r = t.add(SI(o));
+        const l = t.add(Fr({
+            pulse: Se(r)
         }));
-        return s = t.add(Foe({
-            field: L2,
+        return s = t.add(Vae({
+            field: gx,
             sort: t.sortRef(i),
-            pulse: de(l)
-        })), de(s)
+            pulse: Se(l)
+        })), Se(s)
     }
 
-    function VL(e, t) {
-        return e && (!e.field && !e.op ? ae(e) ? e.field = "key" : e = {
+    function OI(e, t) {
+        return e && (!e.field && !e.op ? ce(e) ? e.field = "key" : e = {
             field: "key"
-        } : !e.field && e.op !== "count" ? U("No field provided for sort aggregate op: " + e.op) : t && e.field && e.op && !YL[e.op] && U("Multiple domain scales can not be sorted using " + e.op)), e
+        } : !e.field && e.op !== "count" ? q("No field provided for sort aggregate op: " + e.op) : t && e.field && e.op && !TI[e.op] && q("Multiple domain scales can not be sorted using " + e.op)), e
     }
 
-    function joe(e, t, n) {
+    function roe(e, t, n) {
         const i = n.map(r => {
             const s = t.getData(r.data);
-            return s || g1(r.data), s.domainRef(t, r.field)
+            return s || H1(r.data), s.domainRef(t, r.field)
         });
-        return de(t.add(Eoe({
+        return Se(t.add(jae({
             values: i
         })))
     }
 
-    function Uoe(e, t, n) {
+    function soe(e, t, n) {
         const i = n.map(r => {
             const s = t.getData(r.data);
-            return s || g1(r.data), s.extentRef(t, r.field)
+            return s || H1(r.data), s.extentRef(t, r.field)
         });
-        return de(t.add(Soe({
+        return Se(t.add(Bae({
             extents: i
         })))
     }
 
-    function Goe(e, t) {
-        return e.signal || W(e) ? fp(e, t) : t.objectProperty(e)
+    function aoe(e, t) {
+        return e.signal || H(e) ? jp(e, t) : t.objectProperty(e)
     }
 
-    function Woe(e) {
-        return ae(e) ? {
-            interval: $i(e.interval),
-            step: $i(e.step)
-        } : $i(e)
+    function ooe(e) {
+        return ce(e) ? {
+            interval: Gi(e.interval),
+            step: Gi(e.step)
+        } : Gi(e)
     }
 
-    function qoe(e, t) {
-        t.interpolate = $i(e.type || e), e.gamma != null && (t.interpolateGamma = $i(e.gamma))
+    function loe(e, t) {
+        t.interpolate = Gi(e.type || e), e.gamma != null && (t.interpolateGamma = Gi(e.gamma))
     }
 
-    function KL(e, t, n) {
+    function FI(e, t, n) {
         const i = t.config.range;
         let r = e.range;
         if (r.signal) return t.signalRef(r.signal);
-        if (re(r)) {
-            if (i && me(i, r)) return e = Ae({}, e, {
+        if (le(r)) {
+            if (i && Ce(i, r)) return e = Ne({}, e, {
                 range: i[r]
-            }), KL(e, t, n);
+            }), FI(e, t, n);
             r === "width" ? r = [0, {
                 signal: "width"
-            }] : r === "height" ? r = qu(e.type) ? [0, {
+            }] : r === "height" ? r = dc(e.type) ? [0, {
                 signal: "height"
             }] : [{
                 signal: "height"
-            }, 0] : U("Unrecognized scale range value: " + Z(r))
+            }, 0] : q("Unrecognized scale range value: " + te(r))
         } else if (r.scheme) {
-            n.scheme = W(r.scheme) ? fp(r.scheme, t) : $i(r.scheme, t), r.extent && (n.schemeExtent = fp(r.extent, t)), r.count && (n.schemeCount = $i(r.count, t));
+            n.scheme = H(r.scheme) ? jp(r.scheme, t) : Gi(r.scheme, t), r.extent && (n.schemeExtent = jp(r.extent, t)), r.count && (n.schemeCount = Gi(r.count, t));
             return
         } else if (r.step) {
-            n.rangeStep = $i(r.step, t);
+            n.rangeStep = Gi(r.step, t);
             return
         } else {
-            if (qu(e.type) && !W(r)) return XL(r, e, t);
-            W(r) || U("Unsupported range type: " + Z(r))
+            if (dc(e.type) && !H(r)) return MI(r, e, t);
+            H(r) || q("Unsupported range type: " + te(r))
         }
-        return r.map(s => (W(s) ? fp : $i)(s, t))
+        return r.map(s => (H(s) ? jp : Gi)(s, t))
     }
 
-    function Hoe(e, t) {
+    function uoe(e, t) {
         const n = t.config.projection || {},
             i = {};
-        for (const r in e) r !== "name" && (i[r] = z2(e[r], r, t));
-        for (const r in n) i[r] == null && (i[r] = z2(n[r], r, t));
+        for (const r in e) r !== "name" && (i[r] = mx(e[r], r, t));
+        for (const r in n) i[r] == null && (i[r] = mx(n[r], r, t));
         t.addProjection(e.name, i)
     }
 
-    function z2(e, t, n) {
-        return W(e) ? e.map(i => z2(i, t, n)) : ae(e) ? e.signal ? n.signalRef(e.signal) : t === "fit" ? e : U("Unsupported parameter object: " + Z(e)) : e
+    function mx(e, t, n) {
+        return H(e) ? e.map(i => mx(i, t, n)) : ce(e) ? e.signal ? n.signalRef(e.signal) : t === "fit" ? e : q("Unsupported parameter object: " + te(e)) : e
     }
-    const br = "top",
-        $c = "left",
-        Tc = "right",
-        za = "bottom",
-        JL = "center",
-        Yoe = "vertical",
-        Xoe = "start",
-        Voe = "middle",
-        Koe = "end",
-        B2 = "index",
-        sE = "label",
-        Joe = "offset",
-        Ju = "perc",
-        Qoe = "perc2",
-        Mi = "value",
-        kd = "guide-label",
-        aE = "guide-title",
-        Zoe = "group-title",
-        ele = "group-subtitle",
-        l5 = "symbol",
-        hp = "gradient",
-        j2 = "discrete",
-        U2 = "size",
-        tle = "shape",
-        nle = "fill",
-        ile = "stroke",
-        rle = "strokeWidth",
-        sle = "strokeDash",
-        ale = "opacity",
-        oE = [U2, tle, nle, ile, rle, sle, ale],
-        Ad = {
+    const Rr = "top",
+        ef = "left",
+        tf = "right",
+        oo = "bottom",
+        RI = "center",
+        coe = "vertical",
+        foe = "start",
+        hoe = "middle",
+        doe = "end",
+        yx = "index",
+        XE = "label",
+        goe = "offset",
+        Sc = "perc",
+        poe = "perc2",
+        Wi = "value",
+        tg = "guide-label",
+        VE = "guide-title",
+        moe = "group-title",
+        yoe = "group-subtitle",
+        T5 = "symbol",
+        Gp = "gradient",
+        vx = "discrete",
+        bx = "size",
+        voe = "shape",
+        boe = "fill",
+        xoe = "stroke",
+        _oe = "strokeWidth",
+        woe = "strokeDash",
+        Soe = "opacity",
+        KE = [bx, voe, boe, xoe, _oe, woe, Soe],
+        ng = {
             name: 1,
             style: 1,
             interactive: 1
         },
-        Le = {
+        Ye = {
             value: 0
         },
-        Oi = {
+        qi = {
             value: 1
         },
-        p1 = "group",
-        QL = "rect",
-        lE = "rule",
-        ole = "symbol",
-        Rl = "text";
+        Y1 = "group",
+        DI = "rect",
+        JE = "rule",
+        Eoe = "symbol",
+        Zl = "text";
 
-    function Lh(e) {
-        return e.type = p1, e.interactive = e.interactive || !1, e
+    function hd(e) {
+        return e.type = Y1, e.interactive = e.interactive || !1, e
     }
 
-    function ui(e, t) {
-        const n = (i, r) => Yi(e[i], Yi(t[i], r));
-        return n.isVertical = i => Yoe === Yi(e.direction, t.direction || (i ? t.symbolDirection : t.gradientDirection)), n.gradientLength = () => Yi(e.gradientLength, t.gradientLength || t.gradientWidth), n.gradientThickness = () => Yi(e.gradientThickness, t.gradientThickness || t.gradientHeight), n.entryColumns = () => Yi(e.columns, Yi(t.columns, +n.isVertical(!0))), n
+    function bi(e, t) {
+        const n = (i, r) => ur(e[i], ur(t[i], r));
+        return n.isVertical = i => coe === ur(e.direction, t.direction || (i ? t.symbolDirection : t.gradientDirection)), n.gradientLength = () => ur(e.gradientLength, t.gradientLength || t.gradientWidth), n.gradientThickness = () => ur(e.gradientThickness, t.gradientThickness || t.gradientHeight), n.entryColumns = () => ur(e.columns, ur(t.columns, +n.isVertical(!0))), n
     }
 
-    function ZL(e, t) {
+    function NI(e, t) {
         const n = t && (t.update && t.update[e] || t.enter && t.enter[e]);
         return n && n.signal ? n : n ? n.value : null
     }
 
-    function lle(e, t, n) {
+    function koe(e, t, n) {
         const i = t.config.style[n];
         return i && i[e]
     }
 
-    function m1(e, t, n) {
-        return `item.anchor === '${Xoe}' ? ${e} : item.anchor === '${Koe}' ? ${t} : ${n}`
+    function X1(e, t, n) {
+        return `item.anchor === '${foe}' ? ${e} : item.anchor === '${doe}' ? ${t} : ${n}`
     }
-    const uE = m1(Z($c), Z(Tc), Z(JL));
+    const QE = X1(te(ef), te(tf), te(RI));
 
-    function ule(e) {
+    function Coe(e) {
         const t = e("tickBand");
         let n = e("tickOffset"),
             i, r;
         return t ? t.signal ? (i = {
             signal: `(${t.signal}) === 'extent' ? 1 : 0.5`
         }, r = {
             signal: `(${t.signal}) === 'extent'`
-        }, ae(n) || (n = {
+        }, ce(n) || (n = {
             signal: `(${t.signal}) === 'extent' ? 0 : ${n}`
         })) : t === "extent" ? (i = 1, r = !0, n = 0) : (i = .5, r = !1) : (i = e("bandPosition"), r = e("tickExtra")), {
             extra: r,
             band: i,
             offset: n
         }
     }
 
-    function eI(e, t) {
-        return t ? e ? ae(e) ? Object.assign({}, e, {
-            offset: eI(e.offset, t)
+    function PI(e, t) {
+        return t ? e ? ce(e) ? Object.assign({}, e, {
+            offset: PI(e.offset, t)
         }) : {
             value: e,
             offset: t
         } : t : e
     }
 
-    function _i(e, t) {
-        return t ? (e.name = t.name, e.style = t.style || e.style, e.interactive = !!t.interactive, e.encode = Ac(e.encode, t, Ad)) : e.interactive = !1, e
+    function Di(e, t) {
+        return t ? (e.name = t.name, e.style = t.style || e.style, e.interactive = !!t.interactive, e.encode = Zc(e.encode, t, ng)) : e.interactive = !1, e
     }
 
-    function cle(e, t, n, i) {
-        const r = ui(e, n),
+    function Aoe(e, t, n, i) {
+        const r = bi(e, n),
             s = r.isVertical(),
             a = r.gradientThickness(),
             o = r.gradientLength();
         let l, u, c, f, h;
         s ? (u = [0, 1], c = [0, 0], f = a, h = o) : (u = [0, 0], c = [1, 0], f = o, h = a);
         const d = {
             enter: l = {
-                opacity: Le,
-                x: Le,
-                y: Le,
-                width: jt(f),
-                height: jt(h)
+                opacity: Ye,
+                x: Ye,
+                y: Ye,
+                width: rn(f),
+                height: rn(h)
             },
-            update: Ae({}, l, {
-                opacity: Oi,
+            update: Ne({}, l, {
+                opacity: qi,
                 fill: {
                     gradient: t,
                     start: u,
                     stop: c
                 }
             }),
             exit: {
-                opacity: Le
+                opacity: Ye
             }
         };
-        return Zt(d, {
+        return xn(d, {
             stroke: r("gradientStrokeColor"),
             strokeWidth: r("gradientStrokeWidth")
         }, {
             opacity: r("gradientOpacity")
-        }), _i({
-            type: QL,
-            role: Lae,
+        }), Di({
+            type: DI,
+            role: eae,
             encode: d
         }, i)
     }
 
-    function fle(e, t, n, i, r) {
-        const s = ui(e, n),
+    function $oe(e, t, n, i, r) {
+        const s = bi(e, n),
             a = s.isVertical(),
             o = s.gradientThickness(),
             l = s.gradientLength();
         let u, c, f, h, d = "";
         a ? (u = "y", f = "y2", c = "x", h = "width", d = "1-") : (u = "x", f = "x2", c = "y", h = "height");
         const g = {
-            opacity: Le,
+            opacity: Ye,
             fill: {
                 scale: t,
-                field: Mi
+                field: Wi
             }
         };
         g[u] = {
-            signal: d + "datum." + Ju,
+            signal: d + "datum." + Sc,
             mult: l
-        }, g[c] = Le, g[f] = {
-            signal: d + "datum." + Qoe,
+        }, g[c] = Ye, g[f] = {
+            signal: d + "datum." + poe,
             mult: l
-        }, g[h] = jt(o);
+        }, g[h] = rn(o);
         const p = {
             enter: g,
-            update: Ae({}, g, {
-                opacity: Oi
+            update: Ne({}, g, {
+                opacity: qi
             }),
             exit: {
-                opacity: Le
+                opacity: Ye
             }
         };
-        return Zt(p, {
+        return xn(p, {
             stroke: s("gradientStrokeColor"),
             strokeWidth: s("gradientStrokeWidth")
         }, {
             opacity: s("gradientOpacity")
-        }), _i({
-            type: QL,
-            role: Nae,
-            key: Mi,
+        }), Di({
+            type: DI,
+            role: Qse,
+            key: Wi,
             from: r,
             encode: p
         }, i)
     }
-    const hle = `datum.${Ju}<=0?"${$c}":datum.${Ju}>=1?"${Tc}":"${JL}"`,
-        dle = `datum.${Ju}<=0?"${za}":datum.${Ju}>=1?"${br}":"${Voe}"`;
+    const Toe = `datum.${Sc}<=0?"${ef}":datum.${Sc}>=1?"${tf}":"${RI}"`,
+        Moe = `datum.${Sc}<=0?"${oo}":datum.${Sc}>=1?"${Rr}":"${hoe}"`;
 
-    function u5(e, t, n, i) {
-        const r = ui(e, t),
+    function M5(e, t, n, i) {
+        const r = bi(e, t),
             s = r.isVertical(),
-            a = jt(r.gradientThickness()),
+            a = rn(r.gradientThickness()),
             o = r.gradientLength();
         let l = r("labelOverlap"),
             u, c, f, h, d = "";
         const g = {
             enter: u = {
-                opacity: Le
+                opacity: Ye
             },
             update: c = {
-                opacity: Oi,
+                opacity: qi,
                 text: {
-                    field: sE
+                    field: XE
                 }
             },
             exit: {
-                opacity: Le
+                opacity: Ye
             }
         };
-        return Zt(g, {
+        return xn(g, {
             fill: r("labelColor"),
             fillOpacity: r("labelOpacity"),
             font: r("labelFont"),
             fontSize: r("labelFontSize"),
             fontStyle: r("labelFontStyle"),
             fontWeight: r("labelFontWeight"),
-            limit: Yi(e.labelLimit, t.gradientLabelLimit)
+            limit: ur(e.labelLimit, t.gradientLabelLimit)
         }), s ? (u.align = {
             value: "left"
         }, u.baseline = c.baseline = {
-            signal: dle
+            signal: Moe
         }, f = "y", h = "x", d = "1-") : (u.align = c.align = {
-            signal: hle
+            signal: Toe
         }, u.baseline = {
             value: "top"
         }, f = "x", h = "y"), u[f] = c[f] = {
-            signal: d + "datum." + Ju,
+            signal: d + "datum." + Sc,
             mult: o
-        }, u[h] = c[h] = a, a.offset = Yi(e.labelOffset, t.gradientLabelOffset) || 0, l = l ? {
+        }, u[h] = c[h] = a, a.offset = ur(e.labelOffset, t.gradientLabelOffset) || 0, l = l ? {
             separation: r("labelSeparation"),
             method: l,
-            order: "datum." + B2
-        } : void 0, _i({
-            type: Rl,
-            role: NL,
-            style: kd,
-            key: Mi,
+            order: "datum." + yx
+        } : void 0, Di({
+            type: Zl,
+            role: yI,
+            style: tg,
+            key: Wi,
             from: i,
             encode: g,
             overlap: l
         }, n)
     }
 
-    function gle(e, t, n, i, r) {
-        const s = ui(e, t),
+    function Ooe(e, t, n, i, r) {
+        const s = bi(e, t),
             a = n.entries,
             o = !!(a && a.interactive),
             l = a ? a.name : void 0,
             u = s("clipHeight"),
             c = s("symbolOffset"),
             f = {
                 data: "value"
             },
-            h = `(${r}) ? datum.${Joe} : datum.${U2}`,
-            d = u ? jt(u) : {
-                field: U2
+            h = `(${r}) ? datum.${goe} : datum.${bx}`,
+            d = u ? rn(u) : {
+                field: bx
             },
-            g = `datum.${B2}`,
+            g = `datum.${yx}`,
             p = `max(1, ${r})`;
         let m, y, v, b, x;
         d.mult = .5, m = {
             enter: y = {
-                opacity: Le,
+                opacity: Ye,
                 x: {
                     signal: h,
                     mult: .5,
                     offset: c
                 },
                 y: d
             },
             update: v = {
-                opacity: Oi,
+                opacity: qi,
                 x: y.x,
                 y: y.y
             },
             exit: {
-                opacity: Le
+                opacity: Ye
             }
         };
         let _ = null,
             S = null;
-        e.fill || (_ = t.symbolBaseFillColor, S = t.symbolBaseStrokeColor), Zt(m, {
+        e.fill || (_ = t.symbolBaseFillColor, S = t.symbolBaseStrokeColor), xn(m, {
             fill: s("symbolFillColor", _),
             shape: s("symbolType"),
             size: s("symbolSize"),
             stroke: s("symbolStrokeColor", S),
             strokeDash: s("symbolDash"),
             strokeDashOffset: s("symbolDashOffset"),
             strokeWidth: s("symbolStrokeWidth")
         }, {
             opacity: s("symbolOpacity")
-        }), oE.forEach(C => {
-            e[C] && (v[C] = y[C] = {
-                scale: e[C],
-                field: Mi
+        }), KE.forEach(k => {
+            e[k] && (v[k] = y[k] = {
+                scale: e[k],
+                field: Wi
             })
         });
-        const w = _i({
-                type: ole,
-                role: Iae,
-                key: Mi,
+        const w = Di({
+                type: Eoe,
+                role: tae,
+                key: Wi,
                 from: f,
                 clip: u ? !0 : void 0,
                 encode: m
             }, n.symbols),
-            E = jt(c);
+            E = rn(c);
         E.offset = s("labelOffset"), m = {
             enter: y = {
-                opacity: Le,
+                opacity: Ye,
                 x: {
                     signal: h,
                     offset: E
                 },
                 y: d
             },
             update: v = {
-                opacity: Oi,
+                opacity: qi,
                 text: {
-                    field: sE
+                    field: XE
                 },
                 x: y.x,
                 y: y.y
             },
             exit: {
-                opacity: Le
+                opacity: Ye
             }
-        }, Zt(m, {
+        }, xn(m, {
             align: s("labelAlign"),
             baseline: s("labelBaseline"),
             fill: s("labelColor"),
             fillOpacity: s("labelOpacity"),
             font: s("labelFont"),
             fontSize: s("labelFontSize"),
             fontStyle: s("labelFontStyle"),
             fontWeight: s("labelFontWeight"),
             limit: s("labelLimit")
         });
-        const A = _i({
-            type: Rl,
-            role: NL,
-            style: kd,
-            key: Mi,
+        const C = Di({
+            type: Zl,
+            role: yI,
+            style: tg,
+            key: Wi,
             from: f,
             encode: m
         }, n.labels);
         return m = {
             enter: {
                 noBound: {
                     value: !u
                 },
-                width: Le,
-                height: u ? jt(u) : Le,
-                opacity: Le
+                width: Ye,
+                height: u ? rn(u) : Ye,
+                opacity: Ye
             },
             exit: {
-                opacity: Le
+                opacity: Ye
             },
             update: v = {
-                opacity: Oi,
+                opacity: qi,
                 row: {
                     signal: null
                 },
                 column: {
                     signal: null
                 }
             }
@@ -33601,511 +26839,511 @@
             field: ["row", g]
         }) : (v.row.signal = `floor(${g} / ${p})`, v.column.signal = `${g} % ${p}`, x = {
             field: g
         }), v.column.signal = `(${r})?${v.column.signal}:${g}`, i = {
             facet: {
                 data: i,
                 name: "value",
-                groupby: B2
+                groupby: yx
             }
-        }, Lh({
-            role: nE,
+        }, hd({
+            role: qE,
             from: i,
-            encode: Ac(m, a, Ad),
-            marks: [w, A],
+            encode: Zc(m, a, ng),
+            marks: [w, C],
             name: l,
             interactive: o,
             sort: x
         })
     }
 
-    function ple(e, t) {
-        const n = ui(e, t);
+    function Foe(e, t) {
+        const n = bi(e, t);
         return {
             align: n("gridAlign"),
             columns: n.entryColumns(),
             center: {
                 row: !0,
                 column: !1
             },
             padding: {
                 row: n("rowPadding"),
                 column: n("columnPadding")
             }
         }
     }
-    const cE = 'item.orient === "left"',
-        fE = 'item.orient === "right"',
-        y1 = `(${cE} || ${fE})`,
-        mle = `datum.vgrad && ${y1}`,
-        yle = m1('"top"', '"bottom"', '"middle"'),
-        vle = m1('"right"', '"left"', '"center"'),
-        ble = `datum.vgrad && ${fE} ? (${vle}) : (${y1} && !(datum.vgrad && ${cE})) ? "left" : ${uE}`,
-        xle = `item._anchor || (${y1} ? "middle" : "start")`,
-        _le = `${mle} ? (${cE} ? -90 : 90) : 0`,
-        wle = `${y1} ? (datum.vgrad ? (${fE} ? "bottom" : "top") : ${yle}) : "top"`;
+    const ZE = 'item.orient === "left"',
+        ek = 'item.orient === "right"',
+        V1 = `(${ZE} || ${ek})`,
+        Roe = `datum.vgrad && ${V1}`,
+        Doe = X1('"top"', '"bottom"', '"middle"'),
+        Noe = X1('"right"', '"left"', '"center"'),
+        Poe = `datum.vgrad && ${ek} ? (${Noe}) : (${V1} && !(datum.vgrad && ${ZE})) ? "left" : ${QE}`,
+        Loe = `item._anchor || (${V1} ? "middle" : "start")`,
+        Ioe = `${Roe} ? (${ZE} ? -90 : 90) : 0`,
+        zoe = `${V1} ? (datum.vgrad ? (${ek} ? "bottom" : "top") : ${Doe}) : "top"`;
 
-    function Sle(e, t, n, i) {
-        const r = ui(e, t),
+    function Boe(e, t, n, i) {
+        const r = bi(e, t),
             s = {
                 enter: {
-                    opacity: Le
+                    opacity: Ye
                 },
                 update: {
-                    opacity: Oi,
+                    opacity: qi,
                     x: {
                         field: {
                             group: "padding"
                         }
                     },
                     y: {
                         field: {
                             group: "padding"
                         }
                     }
                 },
                 exit: {
-                    opacity: Le
+                    opacity: Ye
                 }
             };
-        return Zt(s, {
+        return xn(s, {
             orient: r("titleOrient"),
             _anchor: r("titleAnchor"),
             anchor: {
-                signal: xle
+                signal: Loe
             },
             angle: {
-                signal: _le
+                signal: Ioe
             },
             align: {
-                signal: ble
+                signal: Poe
             },
             baseline: {
-                signal: wle
+                signal: zoe
             },
             text: e.title,
             fill: r("titleColor"),
             fillOpacity: r("titleOpacity"),
             font: r("titleFont"),
             fontSize: r("titleFontSize"),
             fontStyle: r("titleFontStyle"),
             fontWeight: r("titleFontWeight"),
             limit: r("titleLimit"),
             lineHeight: r("titleLineHeight")
         }, {
             align: r("titleAlign"),
             baseline: r("titleBaseline")
-        }), _i({
-            type: Rl,
-            role: zae,
-            style: aE,
+        }), Di({
+            type: Zl,
+            role: nae,
+            style: VE,
             from: i,
             encode: s
         }, n)
     }
 
-    function Ele(e, t) {
+    function joe(e, t) {
         let n;
-        return ae(e) && (e.signal ? n = e.signal : e.path ? n = "pathShape(" + c5(e.path) + ")" : e.sphere && (n = "geoShape(" + c5(e.sphere) + ', {type: "Sphere"})')), n ? t.signalRef(n) : !!e
+        return ce(e) && (e.signal ? n = e.signal : e.path ? n = "pathShape(" + O5(e.path) + ")" : e.sphere && (n = "geoShape(" + O5(e.sphere) + ', {type: "Sphere"})')), n ? t.signalRef(n) : !!e
     }
 
-    function c5(e) {
-        return ae(e) && e.signal ? e.signal : Z(e)
+    function O5(e) {
+        return ce(e) && e.signal ? e.signal : te(e)
     }
 
-    function tI(e) {
+    function LI(e) {
         const t = e.role || "";
-        return !t.indexOf("axis") || !t.indexOf("legend") || !t.indexOf("title") ? t : e.type === p1 ? nE : t || eE
+        return !t.indexOf("axis") || !t.indexOf("legend") || !t.indexOf("title") ? t : e.type === Y1 ? qE : t || UE
     }
 
-    function Cle(e) {
+    function Goe(e) {
         return {
             marktype: e.type,
             name: e.name || void 0,
-            role: e.role || tI(e),
+            role: e.role || LI(e),
             zindex: +e.zindex || void 0,
             aria: e.aria,
             description: e.description
         }
     }
 
-    function kle(e, t) {
+    function Uoe(e, t) {
         return e && e.signal ? t.signalRef(e.signal) : e !== !1
     }
 
-    function hE(e, t) {
-        const n = XD(e.type);
-        n || U("Unrecognized transform type: " + Z(e.type));
-        const i = h1(n.type.toLowerCase(), null, nI(n, e, t));
+    function tk(e, t) {
+        const n = kR(e.type);
+        n || q("Unrecognized transform type: " + te(e.type));
+        const i = W1(n.type.toLowerCase(), null, II(n, e, t));
         return e.signal && t.addSignal(e.signal, t.proxy(i)), i.metadata = n.metadata || {}, i
     }
 
-    function nI(e, t, n) {
+    function II(e, t, n) {
         const i = {},
             r = e.params.length;
         for (let s = 0; s < r; ++s) {
             const a = e.params[s];
-            i[a.name] = Ale(a, t, n)
+            i[a.name] = Woe(a, t, n)
         }
         return i
     }
 
-    function Ale(e, t, n) {
+    function Woe(e, t, n) {
         const i = e.type,
             r = t[e.name];
-        if (i === "index") return $le(e, t, n);
+        if (i === "index") return qoe(e, t, n);
         if (r === void 0) {
-            e.required && U("Missing required " + Z(t.type) + " parameter: " + Z(e.name));
+            e.required && q("Missing required " + te(t.type) + " parameter: " + te(e.name));
             return
         } else {
-            if (i === "param") return Tle(e, t, n);
+            if (i === "param") return Hoe(e, t, n);
             if (i === "projection") return n.projectionRef(t[e.name])
         }
-        return e.array && !Ft(r) ? r.map(s => f5(e, s, n)) : f5(e, r, n)
+        return e.array && !Xt(r) ? r.map(s => F5(e, s, n)) : F5(e, r, n)
     }
 
-    function f5(e, t, n) {
+    function F5(e, t, n) {
         const i = e.type;
-        if (Ft(t)) return d5(i) ? U("Expression references can not be signals.") : Sv(i) ? n.fieldRef(t) : g5(i) ? n.compareRef(t) : n.signalRef(t.signal); {
-            const r = e.expr || Sv(i);
-            return r && Mle(t) ? n.exprRef(t.expr, t.as) : r && Ole(t) ? Nh(t.field, t.as) : d5(i) ? Xr(t, n) : Fle(i) ? de(n.getData(t).values) : Sv(i) ? Nh(t) : g5(i) ? n.compareRef(t) : t
+        if (Xt(t)) return D5(i) ? q("Expression references can not be signals.") : Qv(i) ? n.fieldRef(t) : N5(i) ? n.compareRef(t) : n.signalRef(t.signal); {
+            const r = e.expr || Qv(i);
+            return r && Yoe(t) ? n.exprRef(t.expr, t.as) : r && Xoe(t) ? cd(t.field, t.as) : D5(i) ? cs(t, n) : Voe(i) ? Se(n.getData(t).values) : Qv(i) ? cd(t) : N5(i) ? n.compareRef(t) : t
         }
     }
 
-    function $le(e, t, n) {
-        return re(t.from) || U('Lookup "from" parameter must be a string literal.'), n.getData(t.from).lookupRef(n, t.key)
+    function qoe(e, t, n) {
+        return le(t.from) || q('Lookup "from" parameter must be a string literal.'), n.getData(t.from).lookupRef(n, t.key)
     }
 
-    function Tle(e, t, n) {
+    function Hoe(e, t, n) {
         const i = t[e.name];
-        return e.array ? (W(i) || U("Expected an array of sub-parameters. Instead: " + Z(i)), i.map(r => h5(e, r, n))) : h5(e, i, n)
+        return e.array ? (H(i) || q("Expected an array of sub-parameters. Instead: " + te(i)), i.map(r => R5(e, r, n))) : R5(e, i, n)
     }
 
-    function h5(e, t, n) {
+    function R5(e, t, n) {
         const i = e.params.length;
         let r;
         for (let a = 0; a < i; ++a) {
             r = e.params[a];
             for (const o in r.key)
                 if (r.key[o] !== t[o]) {
                     r = null;
                     break
                 } if (r) break
         }
-        r || U("Unsupported parameter: " + Z(t));
-        const s = Ae(nI(r, t, n), r.key);
-        return de(n.add(koe(s)))
-    }
-    const Mle = e => e && e.expr,
-        Ole = e => e && e.field,
-        Fle = e => e === "data",
-        d5 = e => e === "expr",
-        Sv = e => e === "field",
-        g5 = e => e === "compare";
+        r || q("Unsupported parameter: " + te(t));
+        const s = Ne(II(r, t, n), r.key);
+        return Se(n.add(Uae(s)))
+    }
+    const Yoe = e => e && e.expr,
+        Xoe = e => e && e.field,
+        Voe = e => e === "data",
+        D5 = e => e === "expr",
+        Qv = e => e === "field",
+        N5 = e => e === "compare";
 
-    function Rle(e, t, n) {
+    function Koe(e, t, n) {
         let i, r, s, a, o;
-        return e ? (i = e.facet) && (t || U("Only group marks can be faceted."), i.field != null ? a = o = dp(i, n) : (e.data ? o = de(n.getData(e.data).aggregate) : (s = hE(Ae({
+        return e ? (i = e.facet) && (t || q("Only group marks can be faceted."), i.field != null ? a = o = Up(i, n) : (e.data ? o = Se(n.getData(e.data).aggregate) : (s = tk(Ne({
             type: "aggregate",
-            groupby: se(i.groupby)
-        }, i.aggregate), n), s.params.key = n.keyRef(i.groupby), s.params.pulse = dp(i, n), a = o = de(n.add(s))), r = n.keyRef(i.groupby, !0))) : a = de(n.add(vr(null, [{}]))), a || (a = dp(e, n)), {
+            groupby: ue(i.groupby)
+        }, i.aggregate), n), s.params.key = n.keyRef(i.groupby), s.params.pulse = Up(i, n), a = o = Se(n.add(s))), r = n.keyRef(i.groupby, !0))) : a = Se(n.add(Fr(null, [{}]))), a || (a = Up(e, n)), {
             key: r,
             pulse: a,
             parent: o
         }
     }
 
-    function dp(e, t) {
-        return e.$ref ? e : e.data && e.data.$ref ? e.data : de(t.getData(e.data).output)
+    function Up(e, t) {
+        return e.$ref ? e : e.data && e.data.$ref ? e.data : Se(t.getData(e.data).output)
     }
 
-    function al(e, t, n, i, r) {
+    function Ol(e, t, n, i, r) {
         this.scope = e, this.input = t, this.output = n, this.values = i, this.aggregate = r, this.index = {}
     }
-    al.fromEntries = function(e, t) {
+    Ol.fromEntries = function(e, t) {
         const n = t.length,
             i = t[n - 1],
             r = t[n - 2];
         let s = t[0],
             a = null,
             o = 1;
-        for (s && s.type === "load" && (s = t[1]), e.add(t[0]); o < n; ++o) t[o].params.pulse = de(t[o - 1]), e.add(t[o]), t[o].type === "aggregate" && (a = t[o]);
-        return new al(e, s, r, i, a)
+        for (s && s.type === "load" && (s = t[1]), e.add(t[0]); o < n; ++o) t[o].params.pulse = Se(t[o - 1]), e.add(t[o]), t[o].type === "aggregate" && (a = t[o]);
+        return new Ol(e, s, r, i, a)
     };
 
-    function iI(e) {
-        return re(e) ? e : null
+    function zI(e) {
+        return le(e) ? e : null
     }
 
-    function p5(e, t, n) {
-        const i = d1(n.op, n.field);
+    function P5(e, t, n) {
+        const i = q1(n.op, n.field);
         let r;
         if (t.ops) {
             for (let s = 0, a = t.as.length; s < a; ++s)
                 if (t.as[s] === i) return
         } else t.ops = ["count"], t.fields = [null], t.as = ["count"];
         n.op && (t.ops.push((r = n.op.signal) ? e.signalRef(r) : n.op), t.fields.push(e.fieldRef(n.field)), t.as.push(i))
     }
 
-    function lf(e, t, n, i, r, s, a) {
+    function Df(e, t, n, i, r, s, a) {
         const o = t[n] || (t[n] = {}),
-            l = noe(s);
-        let u = iI(r),
+            l = bae(s);
+        let u = zI(r),
             c, f;
         if (u != null && (e = t.scope, u = u + (l ? "|" + l : ""), c = o[u]), !c) {
             const h = s ? {
-                field: L2,
+                field: gx,
                 pulse: t.countsRef(e, r, s)
             } : {
                 field: e.fieldRef(r),
-                pulse: de(t.output)
+                pulse: Se(t.output)
             };
-            l && (h.sort = e.sortRef(s)), f = e.add(h1(i, void 0, h)), a && (t.index[r] = f), c = de(f), u != null && (o[u] = c)
+            l && (h.sort = e.sortRef(s)), f = e.add(W1(i, void 0, h)), a && (t.index[r] = f), c = Se(f), u != null && (o[u] = c)
         }
         return c
     }
-    al.prototype = {
+    Ol.prototype = {
         countsRef(e, t, n) {
             const i = this,
                 r = i.counts || (i.counts = {}),
-                s = iI(t);
+                s = zI(t);
             let a, o, l;
-            return s != null && (e = i.scope, a = r[s]), a ? n && n.field && p5(e, a.agg.params, n) : (l = {
+            return s != null && (e = i.scope, a = r[s]), a ? n && n.field && P5(e, a.agg.params, n) : (l = {
                 groupby: e.fieldRef(t, "key"),
-                pulse: de(i.output)
-            }, n && n.field && p5(e, l, n), o = e.add(jL(l)), a = e.add(vr({
-                pulse: de(o)
+                pulse: Se(i.output)
+            }, n && n.field && P5(e, l, n), o = e.add(SI(l)), a = e.add(Fr({
+                pulse: Se(o)
             })), a = {
                 agg: o,
-                ref: de(a)
+                ref: Se(a)
             }, s != null && (r[s] = a)), a.ref
         },
         tuplesRef() {
-            return de(this.values)
+            return Se(this.values)
         },
         extentRef(e, t) {
-            return lf(e, this, "extent", "extent", t, !1)
+            return Df(e, this, "extent", "extent", t, !1)
         },
         domainRef(e, t) {
-            return lf(e, this, "domain", "values", t, !1)
+            return Df(e, this, "domain", "values", t, !1)
         },
         valuesRef(e, t, n) {
-            return lf(e, this, "vals", "values", t, n || !0)
+            return Df(e, this, "vals", "values", t, n || !0)
         },
         lookupRef(e, t) {
-            return lf(e, this, "lookup", "tupleindex", t, !1)
+            return Df(e, this, "lookup", "tupleindex", t, !1)
         },
         indataRef(e, t) {
-            return lf(e, this, "indata", "tupleindex", t, !0, !0)
+            return Df(e, this, "indata", "tupleindex", t, !0, !0)
         }
     };
 
-    function Dle(e, t, n) {
+    function Joe(e, t, n) {
         const i = e.from.facet,
             r = i.name,
-            s = dp(i, t);
+            s = Up(i, t);
         let a;
-        i.name || U("Facet must have a name: " + Z(i)), i.data || U("Facet must reference a data set: " + Z(i)), i.field ? a = t.add(WL({
+        i.name || q("Facet must have a name: " + te(i)), i.data || q("Facet must reference a data set: " + te(i)), i.field ? a = t.add(CI({
             field: t.fieldRef(i.field),
             pulse: s
-        })) : i.groupby ? a = t.add(yoe({
+        })) : i.groupby ? a = t.add(Dae({
             key: t.keyRef(i.groupby),
-            group: de(t.proxy(n.parent)),
+            group: Se(t.proxy(n.parent)),
             pulse: s
-        })) : U("Facet must specify groupby or field: " + Z(i));
+        })) : q("Facet must specify groupby or field: " + te(i));
         const o = t.fork(),
-            l = o.add(vr()),
-            u = o.add(Fl({
-                pulse: de(l)
+            l = o.add(Fr()),
+            u = o.add(Ql({
+                pulse: Se(l)
             }));
-        o.addData(r, new al(o, l, l, u)), o.addSignal("parent", null), a.params.subflow = {
+        o.addData(r, new Ol(o, l, l, u)), o.addSignal("parent", null), a.params.subflow = {
             $subflow: o.parse(e).toRuntime()
         }
     }
 
-    function Nle(e, t, n) {
-        const i = t.add(WL({
+    function Qoe(e, t, n) {
+        const i = t.add(CI({
                 pulse: n.pulse
             })),
             r = t.fork();
-        r.add(Fl()), r.addSignal("parent", null), i.params.subflow = {
+        r.add(Ql()), r.addSignal("parent", null), i.params.subflow = {
             $subflow: r.parse(e).toRuntime()
         }
     }
 
-    function rI(e, t, n) {
+    function BI(e, t, n) {
         const i = e.remove,
             r = e.insert,
             s = e.toggle,
             a = e.modify,
             o = e.values,
-            l = t.add(D0()),
+            l = t.add(p0()),
             u = "if(" + e.trigger + ',modify("' + n + '",' + [r, i, s, a, o].map(f => f ?? "null").join(",") + "),0)",
-            c = Xr(u, t);
+            c = cs(u, t);
         l.update = c.$expr, l.params = c.$params
     }
 
-    function v1(e, t) {
-        const n = tI(e),
-            i = e.type === p1,
+    function K1(e, t) {
+        const n = LI(e),
+            i = e.type === Y1,
             r = e.from && e.from.facet,
             s = e.overlap;
-        let a = e.layout || n === nE || n === tE,
+        let a = e.layout || n === qE || n === WE,
             o, l, u, c, f, h, d;
-        const g = n === eE || a || r,
-            p = Rle(e.from, i, t);
-        l = t.add(poe({
-            key: p.key || (e.key ? Nh(e.key) : void 0),
+        const g = n === UE || a || r,
+            p = Koe(e.from, i, t);
+        l = t.add(Fae({
+            key: p.key || (e.key ? cd(e.key) : void 0),
             pulse: p.pulse,
             clean: !i
         }));
-        const m = de(l);
-        l = u = t.add(vr({
+        const m = Se(l);
+        l = u = t.add(Fr({
             pulse: m
-        })), l = t.add(woe({
-            markdef: Cle(e),
-            interactive: kle(e.interactive, t),
-            clip: Ele(e.clip, t),
+        })), l = t.add(zae({
+            markdef: Goe(e),
+            interactive: Uoe(e.interactive, t),
+            clip: joe(e.clip, t),
             context: {
                 $context: !0
             },
             groups: t.lookup(),
             parent: t.signals.parent ? t.signalRef("parent") : null,
             index: t.markpath(),
-            pulse: de(l)
+            pulse: Se(l)
         }));
-        const y = de(l);
-        l = c = t.add(GL(zL(e.encode, e.type, n, e.style, t, {
+        const y = Se(l);
+        l = c = t.add(kI(_I(e.encode, e.type, n, e.style, t, {
             mod: !1,
             pulse: y
         }))), l.params.parent = t.encode(), e.transform && e.transform.forEach(S => {
-            const w = hE(S, t),
+            const w = tk(S, t),
                 E = w.metadata;
-            (E.generates || E.changes) && U("Mark transforms should not generate new data."), E.nomod || (c.params.mod = !0), w.params.pulse = de(l), t.add(l = w)
-        }), e.sort && (l = t.add(Ooe({
+            (E.generates || E.changes) && q("Mark transforms should not generate new data."), E.nomod || (c.params.mod = !0), w.params.pulse = Se(l), t.add(l = w)
+        }), e.sort && (l = t.add(Xae({
             sort: t.compareRef(e.sort),
-            pulse: de(l)
+            pulse: Se(l)
         })));
-        const v = de(l);
-        (r || a) && (a = t.add(HL({
+        const v = Se(l);
+        (r || a) && (a = t.add($I({
             layout: t.objectProperty(e.layout),
             legends: t.legends,
             mark: y,
             pulse: v
-        })), h = de(a));
-        const b = t.add(UL({
+        })), h = Se(a));
+        const b = t.add(EI({
             mark: y,
             pulse: h || v
         }));
-        d = de(b), i && (g && (o = t.operators, o.pop(), a && o.pop()), t.pushState(v, h || d, m), r ? Dle(e, t, p) : g ? Nle(e, t, p) : t.parse(e), t.popState(), g && (a && o.push(a), o.push(b))), s && (d = Ple(s, d, t));
-        const x = t.add(qL({
+        d = Se(b), i && (g && (o = t.operators, o.pop(), a && o.pop()), t.pushState(v, h || d, m), r ? Joe(e, t, p) : g ? Qoe(e, t, p) : t.parse(e), t.popState(), g && (a && o.push(a), o.push(b))), s && (d = Zoe(s, d, t));
+        const x = t.add(AI({
                 pulse: d
             })),
-            _ = t.add(Fl({
-                pulse: de(x)
+            _ = t.add(Ql({
+                pulse: Se(x)
             }, void 0, t.parent()));
-        e.name != null && (f = e.name, t.addData(f, new al(t, u, x, _)), e.on && e.on.forEach(S => {
-            (S.insert || S.remove || S.toggle) && U("Marks only support modify triggers."), rI(S, t, f)
+        e.name != null && (f = e.name, t.addData(f, new Ol(t, u, x, _)), e.on && e.on.forEach(S => {
+            (S.insert || S.remove || S.toggle) && q("Marks only support modify triggers."), BI(S, t, f)
         }))
     }
 
-    function Ple(e, t, n) {
+    function Zoe(e, t, n) {
         const i = e.method,
             r = e.bound,
             s = e.separation,
             a = {
-                separation: Ft(s) ? n.signalRef(s.signal) : s,
-                method: Ft(i) ? n.signalRef(i.signal) : i,
+                separation: Xt(s) ? n.signalRef(s.signal) : s,
+                method: Xt(i) ? n.signalRef(i.signal) : i,
                 pulse: t
             };
         if (e.order && (a.sort = n.compareRef({
                 field: e.order
             })), r) {
             const o = r.tolerance;
-            a.boundTolerance = Ft(o) ? n.signalRef(o.signal) : +o, a.boundScale = n.scaleRef(r.scale), a.boundOrient = r.orient
+            a.boundTolerance = Xt(o) ? n.signalRef(o.signal) : +o, a.boundScale = n.scaleRef(r.scale), a.boundOrient = r.orient
         }
-        return de(n.add(Coe(a)))
+        return Se(n.add(Gae(a)))
     }
 
-    function Lle(e, t) {
+    function ele(e, t) {
         const n = t.config.legend,
             i = e.encode || {},
-            r = ui(e, n),
+            r = bi(e, n),
             s = i.legend || {},
             a = s.name || void 0,
             o = s.interactive,
             l = s.style,
             u = {};
         let c = 0,
             f, h, d;
-        oE.forEach(b => e[b] ? (u[b] = e[b], c = c || e[b]) : 0), c || U("Missing valid scale for legend.");
-        const g = Ile(e, t.scaleType(c)),
+        KE.forEach(b => e[b] ? (u[b] = e[b], c = c || e[b]) : 0), c || q("Missing valid scale for legend.");
+        const g = tle(e, t.scaleType(c)),
             p = {
                 title: e.title != null,
                 scales: u,
                 type: g,
                 vgrad: g !== "symbol" && r.isVertical()
             },
-            m = de(t.add(vr(null, [p]))),
+            m = Se(t.add(Fr(null, [p]))),
             y = {
                 enter: {
                     x: {
                         value: 0
                     },
                     y: {
                         value: 0
                     }
                 }
             },
-            v = de(t.add(xoe(h = {
+            v = Se(t.add(Lae(h = {
                 type: g,
                 scale: t.scaleRef(c),
                 count: t.objectProperty(r("tickCount")),
                 limit: t.property(r("symbolLimit")),
                 values: t.objectProperty(e.values),
                 minstep: t.property(e.tickMinStep),
                 formatType: t.property(e.formatType),
                 formatSpecifier: t.property(e.format)
             })));
-        return g === hp ? (d = [cle(e, c, n, i.gradient), u5(e, n, i.labels, v)], h.count = h.count || t.signalRef(`max(2,2*floor((${Wo(r.gradientLength())})/100))`)) : g === j2 ? d = [fle(e, c, n, i.gradient, v), u5(e, n, i.labels, v)] : (f = ple(e, n), d = [gle(e, n, i, v, Wo(f.columns))], h.size = jle(e, t, d[0].marks)), d = [Lh({
-            role: Pae,
+        return g === Gp ? (d = [Aoe(e, c, n, i.gradient), M5(e, n, i.labels, v)], h.count = h.count || t.signalRef(`max(2,2*floor((${gl(r.gradientLength())})/100))`)) : g === vx ? d = [$oe(e, c, n, i.gradient, v), M5(e, n, i.labels, v)] : (f = Foe(e, n), d = [Ooe(e, n, i, v, gl(f.columns))], h.size = rle(e, t, d[0].marks)), d = [hd({
+            role: Zse,
             from: m,
             encode: y,
             marks: d,
             layout: f,
             interactive: o
-        })], p.title && d.push(Sle(e, n, i.title, m)), v1(Lh({
-            role: Dae,
+        })], p.title && d.push(Boe(e, n, i.title, m)), K1(hd({
+            role: Jse,
             from: m,
-            encode: Ac(Ble(r, e, n), s, Ad),
+            encode: Zc(ile(r, e, n), s, ng),
             marks: d,
             aria: r("aria"),
             description: r("description"),
             zindex: r("zindex"),
             name: a,
             interactive: o,
             style: l
         }), t)
     }
 
-    function Ile(e, t) {
-        let n = e.type || l5;
-        return !e.type && zle(e) === 1 && (e.fill || e.stroke) && (n = xw(t) ? hp : n2(t) ? j2 : l5), n !== hp ? n : n2(t) ? j2 : hp
+    function tle(e, t) {
+        let n = e.type || T5;
+        return !e.type && nle(e) === 1 && (e.fill || e.stroke) && (n = Jw(t) ? Gp : c2(t) ? vx : T5), n !== Gp ? n : c2(t) ? vx : Gp
     }
 
-    function zle(e) {
-        return oE.reduce((t, n) => t + (e[n] ? 1 : 0), 0)
+    function nle(e) {
+        return KE.reduce((t, n) => t + (e[n] ? 1 : 0), 0)
     }
 
-    function Ble(e, t, n) {
+    function ile(e, t, n) {
         const i = {
             enter: {},
             update: {}
         };
-        return Zt(i, {
+        return xn(i, {
             orient: e("orient"),
             offset: e("offset"),
             padding: e("padding"),
             titlePadding: e("titlePadding"),
             cornerRadius: e("cornerRadius"),
             fill: e("fillColor"),
             stroke: e("strokeColor"),
@@ -34114,88 +27352,88 @@
             x: e("legendX"),
             y: e("legendY"),
             format: t.format,
             formatType: t.formatType
         }), i
     }
 
-    function jle(e, t, n) {
-        const i = Wo(m5("size", e, n)),
-            r = Wo(m5("strokeWidth", e, n)),
-            s = Wo(Ule(n[1].encode, t, kd));
-        return Xr(`max(ceil(sqrt(${i})+${r}),${s})`, t)
+    function rle(e, t, n) {
+        const i = gl(L5("size", e, n)),
+            r = gl(L5("strokeWidth", e, n)),
+            s = gl(sle(n[1].encode, t, tg));
+        return cs(`max(ceil(sqrt(${i})+${r}),${s})`, t)
     }
 
-    function m5(e, t, n) {
-        return t[e] ? `scale("${t[e]}",datum)` : ZL(e, n[0].encode)
+    function L5(e, t, n) {
+        return t[e] ? `scale("${t[e]}",datum)` : NI(e, n[0].encode)
     }
 
-    function Ule(e, t, n) {
-        return ZL("fontSize", e) || lle("fontSize", t, n)
+    function sle(e, t, n) {
+        return NI("fontSize", e) || koe("fontSize", t, n)
     }
-    const Gle = `item.orient==="${$c}"?-90:item.orient==="${Tc}"?90:0`;
+    const ale = `item.orient==="${ef}"?-90:item.orient==="${tf}"?90:0`;
 
-    function Wle(e, t) {
-        e = re(e) ? {
+    function ole(e, t) {
+        e = le(e) ? {
             text: e
         } : e;
-        const n = ui(e, t.config.title),
+        const n = bi(e, t.config.title),
             i = e.encode || {},
             r = i.group || {},
             s = r.name || void 0,
             a = r.interactive,
             o = r.style,
             l = [],
             u = {},
-            c = de(t.add(vr(null, [u])));
-        return l.push(Yle(e, n, qle(e), c)), e.subtitle && l.push(Xle(e, n, i.subtitle, c)), v1(Lh({
-            role: Bae,
+            c = Se(t.add(Fr(null, [u])));
+        return l.push(cle(e, n, lle(e), c)), e.subtitle && l.push(fle(e, n, i.subtitle, c)), K1(hd({
+            role: iae,
             from: c,
-            encode: Hle(n, r),
+            encode: ule(n, r),
             marks: l,
             aria: n("aria"),
             description: n("description"),
             zindex: n("zindex"),
             name: s,
             interactive: a,
             style: o
         }), t)
     }
 
-    function qle(e) {
+    function lle(e) {
         const t = e.encode;
-        return t && t.title || Ae({
+        return t && t.title || Ne({
             name: e.name,
             interactive: e.interactive,
             style: e.style
         }, t)
     }
 
-    function Hle(e, t) {
+    function ule(e, t) {
         const n = {
             enter: {},
             update: {}
         };
-        return Zt(n, {
+        return xn(n, {
             orient: e("orient"),
             anchor: e("anchor"),
             align: {
-                signal: uE
+                signal: QE
             },
             angle: {
-                signal: Gle
+                signal: ale
             },
             limit: e("limit"),
             frame: e("frame"),
             offset: e("offset") || 0,
             padding: e("subtitlePadding")
-        }), Ac(n, t, Ad)
+        }), Zc(n, t, ng)
     }
 
-    function Yle(e, t, n, i) {
+    function cle(e, t, n, i) {
         const r = {
                 value: 0
             },
             s = e.text,
             a = {
                 enter: {
                     opacity: r
@@ -34205,15 +27443,15 @@
                         value: 1
                     }
                 },
                 exit: {
                     opacity: r
                 }
             };
-        return Zt(a, {
+        return xn(a, {
             text: s,
             align: {
                 signal: "item.mark.group.align"
             },
             angle: {
                 signal: "item.mark.group.angle"
             },
@@ -34229,24 +27467,24 @@
             fontStyle: t("fontStyle"),
             fontWeight: t("fontWeight"),
             lineHeight: t("lineHeight")
         }, {
             align: t("align"),
             angle: t("angle"),
             baseline: t("baseline")
-        }), _i({
-            type: Rl,
-            role: jae,
-            style: Zoe,
+        }), Di({
+            type: Zl,
+            role: rae,
+            style: moe,
             from: i,
             encode: a
         }, n)
     }
 
-    function Xle(e, t, n, i) {
+    function fle(e, t, n, i) {
         const r = {
                 value: 0
             },
             s = e.subtitle,
             a = {
                 enter: {
                     opacity: r
@@ -34256,15 +27494,15 @@
                         value: 1
                     }
                 },
                 exit: {
                     opacity: r
                 }
             };
-        return Zt(a, {
+        return xn(a, {
             text: s,
             align: {
                 signal: "item.mark.group.align"
             },
             angle: {
                 signal: "item.mark.group.angle"
             },
@@ -34280,240 +27518,240 @@
             fontStyle: t("subtitleFontStyle"),
             fontWeight: t("subtitleFontWeight"),
             lineHeight: t("subtitleLineHeight")
         }, {
             align: t("align"),
             angle: t("angle"),
             baseline: t("baseline")
-        }), _i({
-            type: Rl,
-            role: Uae,
-            style: ele,
+        }), Di({
+            type: Zl,
+            role: sae,
+            style: yoe,
             from: i,
             encode: a
         }, n)
     }
 
-    function Vle(e, t) {
+    function hle(e, t) {
         const n = [];
         e.transform && e.transform.forEach(i => {
-            n.push(hE(i, t))
+            n.push(tk(i, t))
         }), e.on && e.on.forEach(i => {
-            rI(i, t, e.name)
-        }), t.addDataPipeline(e.name, Kle(e, t, n))
+            BI(i, t, e.name)
+        }), t.addDataPipeline(e.name, dle(e, t, n))
     }
 
-    function Kle(e, t, n) {
+    function dle(e, t, n) {
         const i = [];
         let r = null,
             s = !1,
             a = !1,
             o, l, u, c, f;
-        for (e.values ? Ft(e.values) || cp(e.format) ? (i.push(y5(t, e)), i.push(r = po())) : i.push(r = po({
+        for (e.values ? Xt(e.values) || Bp(e.format) ? (i.push(I5(t, e)), i.push(r = Lo())) : i.push(r = Lo({
                 $ingest: e.values,
                 $format: e.format
-            })) : e.url ? cp(e.url) || cp(e.format) ? (i.push(y5(t, e)), i.push(r = po())) : i.push(r = po({
+            })) : e.url ? Bp(e.url) || Bp(e.format) ? (i.push(I5(t, e)), i.push(r = Lo())) : i.push(r = Lo({
                 $request: e.url,
                 $format: e.format
-            })) : e.source && (r = o = se(e.source).map(h => de(t.getData(h).output)), i.push(null)), l = 0, u = n.length; l < u; ++l) c = n[l], f = c.metadata, !r && !f.source && i.push(r = po()), i.push(c), f.generates && (a = !0), f.modifies && !a && (s = !0), f.source ? r = c : f.changes && (r = null);
-        return o && (u = o.length - 1, i[0] = Toe({
+            })) : e.source && (r = o = ue(e.source).map(h => Se(t.getData(h).output)), i.push(null)), l = 0, u = n.length; l < u; ++l) c = n[l], f = c.metadata, !r && !f.source && i.push(r = Lo()), i.push(c), f.generates && (a = !0), f.modifies && !a && (s = !0), f.source ? r = c : f.changes && (r = null);
+        return o && (u = o.length - 1, i[0] = Hae({
             derive: s,
             pulse: u ? o : o[0]
-        }), (s || u) && i.splice(1, 0, po())), r || i.push(po()), i.push(Fl({})), i
+        }), (s || u) && i.splice(1, 0, Lo())), r || i.push(Lo()), i.push(Ql({})), i
     }
 
-    function po(e) {
-        const t = vr({}, e);
+    function Lo(e) {
+        const t = Fr({}, e);
         return t.metadata = {
             source: !0
         }, t
     }
 
-    function y5(e, t) {
-        return _oe({
+    function I5(e, t) {
+        return Iae({
             url: t.url ? e.property(t.url) : void 0,
             async: t.async ? e.property(t.async) : void 0,
             values: t.values ? e.property(t.values) : void 0,
             format: e.objectProperty(t.format)
         })
     }
-    const sI = e => e === za || e === br,
-        b1 = (e, t, n) => Ft(e) ? eue(e.signal, t, n) : e === $c || e === br ? t : n,
-        Ut = (e, t, n) => Ft(e) ? Qle(e.signal, t, n) : sI(e) ? t : n,
-        ar = (e, t, n) => Ft(e) ? Zle(e.signal, t, n) : sI(e) ? n : t,
-        aI = (e, t, n) => Ft(e) ? tue(e.signal, t, n) : e === br ? {
+    const jI = e => e === oo || e === Rr,
+        J1 = (e, t, n) => Xt(e) ? yle(e.signal, t, n) : e === ef || e === Rr ? t : n,
+        sn = (e, t, n) => Xt(e) ? ple(e.signal, t, n) : jI(e) ? t : n,
+        Sr = (e, t, n) => Xt(e) ? mle(e.signal, t, n) : jI(e) ? n : t,
+        GI = (e, t, n) => Xt(e) ? vle(e.signal, t, n) : e === Rr ? {
             value: t
         } : {
             value: n
         },
-        Jle = (e, t, n) => Ft(e) ? nue(e.signal, t, n) : e === Tc ? {
+        gle = (e, t, n) => Xt(e) ? ble(e.signal, t, n) : e === tf ? {
             value: t
         } : {
             value: n
         },
-        Qle = (e, t, n) => oI(`${e} === '${br}' || ${e} === '${za}'`, t, n),
-        Zle = (e, t, n) => oI(`${e} !== '${br}' && ${e} !== '${za}'`, t, n),
-        eue = (e, t, n) => dE(`${e} === '${$c}' || ${e} === '${br}'`, t, n),
-        tue = (e, t, n) => dE(`${e} === '${br}'`, t, n),
-        nue = (e, t, n) => dE(`${e} === '${Tc}'`, t, n),
-        oI = (e, t, n) => (t = t != null ? jt(t) : t, n = n != null ? jt(n) : n, v5(t) && v5(n) ? (t = t ? t.signal || Z(t.value) : null, n = n ? n.signal || Z(n.value) : null, {
+        ple = (e, t, n) => UI(`${e} === '${Rr}' || ${e} === '${oo}'`, t, n),
+        mle = (e, t, n) => UI(`${e} !== '${Rr}' && ${e} !== '${oo}'`, t, n),
+        yle = (e, t, n) => nk(`${e} === '${ef}' || ${e} === '${Rr}'`, t, n),
+        vle = (e, t, n) => nk(`${e} === '${Rr}'`, t, n),
+        ble = (e, t, n) => nk(`${e} === '${tf}'`, t, n),
+        UI = (e, t, n) => (t = t != null ? rn(t) : t, n = n != null ? rn(n) : n, z5(t) && z5(n) ? (t = t ? t.signal || te(t.value) : null, n = n ? n.signal || te(n.value) : null, {
             signal: `${e} ? (${t}) : (${n})`
-        }) : [Ae({
+        }) : [Ne({
             test: e
         }, t)].concat(n || [])),
-        v5 = e => e == null || Object.keys(e).length === 1,
-        dE = (e, t, n) => ({
-            signal: `${e} ? (${pu(t)}) : (${pu(n)})`
+        z5 = e => e == null || Object.keys(e).length === 1,
+        nk = (e, t, n) => ({
+            signal: `${e} ? (${ju(t)}) : (${ju(n)})`
         }),
-        iue = (e, t, n, i, r) => ({
-            signal: (i != null ? `${e} === '${$c}' ? (${pu(i)}) : ` : "") + (n != null ? `${e} === '${za}' ? (${pu(n)}) : ` : "") + (r != null ? `${e} === '${Tc}' ? (${pu(r)}) : ` : "") + (t != null ? `${e} === '${br}' ? (${pu(t)}) : ` : "") + "(null)"
+        xle = (e, t, n, i, r) => ({
+            signal: (i != null ? `${e} === '${ef}' ? (${ju(i)}) : ` : "") + (n != null ? `${e} === '${oo}' ? (${ju(n)}) : ` : "") + (r != null ? `${e} === '${tf}' ? (${ju(r)}) : ` : "") + (t != null ? `${e} === '${Rr}' ? (${ju(t)}) : ` : "") + "(null)"
         }),
-        pu = e => Ft(e) ? e.signal : e == null ? null : Z(e),
-        rue = (e, t) => t === 0 ? 0 : Ft(e) ? {
+        ju = e => Xt(e) ? e.signal : e == null ? null : te(e),
+        _le = (e, t) => t === 0 ? 0 : Xt(e) ? {
             signal: `(${e.signal}) * ${t}`
         } : {
             value: e * t
         },
-        Su = (e, t) => {
+        Xu = (e, t) => {
             const n = e.signal;
             return n && n.endsWith("(null)") ? {
                 signal: n.slice(0, -6) + t.signal
             } : e
         };
 
-    function Zl(e, t, n, i) {
+    function Su(e, t, n, i) {
         let r;
-        if (t && me(t, e)) return t[e];
-        if (me(n, e)) return n[e];
+        if (t && Ce(t, e)) return t[e];
+        if (Ce(n, e)) return n[e];
         if (e.startsWith("title")) {
             switch (e) {
                 case "titleColor":
                     r = "fill";
                     break;
                 case "titleFont":
                 case "titleFontSize":
                 case "titleFontWeight":
                     r = e[5].toLowerCase() + e.slice(6)
             }
-            return i[aE][r]
+            return i[VE][r]
         } else if (e.startsWith("label")) {
             switch (e) {
                 case "labelColor":
                     r = "fill";
                     break;
                 case "labelFont":
                 case "labelFontSize":
                     r = e[5].toLowerCase() + e.slice(6)
             }
-            return i[kd][r]
+            return i[tg][r]
         }
         return null
     }
 
-    function b5(e) {
+    function B5(e) {
         const t = {};
         for (const n of e)
             if (n)
                 for (const i in n) t[i] = 1;
         return Object.keys(t)
     }
 
-    function sue(e, t) {
+    function wle(e, t) {
         var n = t.config,
             i = n.style,
             r = n.axis,
             s = t.scaleType(e.scale) === "band" && n.axisBand,
             a = e.orient,
             o, l, u;
-        if (Ft(a)) {
-            const f = b5([n.axisX, n.axisY]),
-                h = b5([n.axisTop, n.axisBottom, n.axisLeft, n.axisRight]);
+        if (Xt(a)) {
+            const f = B5([n.axisX, n.axisY]),
+                h = B5([n.axisTop, n.axisBottom, n.axisLeft, n.axisRight]);
             o = {};
-            for (u of f) o[u] = Ut(a, Zl(u, n.axisX, r, i), Zl(u, n.axisY, r, i));
+            for (u of f) o[u] = sn(a, Su(u, n.axisX, r, i), Su(u, n.axisY, r, i));
             l = {};
-            for (u of h) l[u] = iue(a.signal, Zl(u, n.axisTop, r, i), Zl(u, n.axisBottom, r, i), Zl(u, n.axisLeft, r, i), Zl(u, n.axisRight, r, i))
-        } else o = a === br || a === za ? n.axisX : n.axisY, l = n["axis" + a[0].toUpperCase() + a.slice(1)];
-        return o || l || s ? Ae({}, r, o, l, s) : r
+            for (u of h) l[u] = xle(a.signal, Su(u, n.axisTop, r, i), Su(u, n.axisBottom, r, i), Su(u, n.axisLeft, r, i), Su(u, n.axisRight, r, i))
+        } else o = a === Rr || a === oo ? n.axisX : n.axisY, l = n["axis" + a[0].toUpperCase() + a.slice(1)];
+        return o || l || s ? Ne({}, r, o, l, s) : r
     }
 
-    function aue(e, t, n, i) {
-        const r = ui(e, t),
+    function Sle(e, t, n, i) {
+        const r = bi(e, t),
             s = e.orient;
         let a, o;
         const l = {
             enter: a = {
-                opacity: Le
+                opacity: Ye
             },
             update: o = {
-                opacity: Oi
+                opacity: qi
             },
             exit: {
-                opacity: Le
+                opacity: Ye
             }
         };
-        Zt(l, {
+        xn(l, {
             stroke: r("domainColor"),
             strokeCap: r("domainCap"),
             strokeDash: r("domainDash"),
             strokeDashOffset: r("domainDashOffset"),
             strokeWidth: r("domainWidth"),
             strokeOpacity: r("domainOpacity")
         });
-        const u = x5(e, 0),
-            c = x5(e, 1);
-        return a.x = o.x = Ut(s, u, Le), a.x2 = o.x2 = Ut(s, c), a.y = o.y = ar(s, u, Le), a.y2 = o.y2 = ar(s, c), _i({
-            type: lE,
-            role: Tae,
+        const u = j5(e, 0),
+            c = j5(e, 1);
+        return a.x = o.x = sn(s, u, Ye), a.x2 = o.x2 = sn(s, c), a.y = o.y = Sr(s, u, Ye), a.y2 = o.y2 = Sr(s, c), Di({
+            type: JE,
+            role: Hse,
             from: i,
             encode: l
         }, n)
     }
 
-    function x5(e, t) {
+    function j5(e, t) {
         return {
             scale: e.scale,
             range: t
         }
     }
 
-    function oue(e, t, n, i, r) {
-        const s = ui(e, t),
+    function Ele(e, t, n, i, r) {
+        const s = bi(e, t),
             a = e.orient,
             o = e.gridScale,
-            l = b1(a, 1, -1),
-            u = lue(e.offset, l);
+            l = J1(a, 1, -1),
+            u = kle(e.offset, l);
         let c, f, h;
         const d = {
             enter: c = {
-                opacity: Le
+                opacity: Ye
             },
             update: h = {
-                opacity: Oi
+                opacity: qi
             },
             exit: f = {
-                opacity: Le
+                opacity: Ye
             }
         };
-        Zt(d, {
+        xn(d, {
             stroke: s("gridColor"),
             strokeCap: s("gridCap"),
             strokeDash: s("gridDash"),
             strokeDashOffset: s("gridDashOffset"),
             strokeOpacity: s("gridOpacity"),
             strokeWidth: s("gridWidth")
         });
         const g = {
                 scale: e.scale,
-                field: Mi,
+                field: Wi,
                 band: r.band,
                 extra: r.extra,
                 offset: r.offset,
                 round: s("tickRound")
             },
-            p = Ut(a, {
+            p = sn(a, {
                 signal: "height"
             }, {
                 signal: "width"
             }),
             m = o ? {
                 scale: o,
                 range: 0,
@@ -34524,146 +27762,146 @@
                 offset: u
             },
             y = o ? {
                 scale: o,
                 range: 1,
                 mult: l,
                 offset: u
-            } : Ae(p, {
+            } : Ne(p, {
                 mult: l,
                 offset: u
             });
-        return c.x = h.x = Ut(a, g, m), c.y = h.y = ar(a, g, m), c.x2 = h.x2 = ar(a, y), c.y2 = h.y2 = Ut(a, y), f.x = Ut(a, g), f.y = ar(a, g), _i({
-            type: lE,
-            role: Mae,
-            key: Mi,
+        return c.x = h.x = sn(a, g, m), c.y = h.y = Sr(a, g, m), c.x2 = h.x2 = Sr(a, y), c.y2 = h.y2 = sn(a, y), f.x = sn(a, g), f.y = Sr(a, g), Di({
+            type: JE,
+            role: Yse,
+            key: Wi,
             from: i,
             encode: d
         }, n)
     }
 
-    function lue(e, t) {
+    function kle(e, t) {
         if (t !== 1)
-            if (!ae(e)) e = Ft(t) ? {
+            if (!ce(e)) e = Xt(t) ? {
                 signal: `(${t.signal}) * (${e||0})`
             } : t * (e || 0);
             else {
-                let n = e = Ae({}, e);
+                let n = e = Ne({}, e);
                 for (; n.mult != null;)
-                    if (ae(n.mult)) n = n.mult = Ae({}, n.mult);
-                    else return n.mult = Ft(t) ? {
+                    if (ce(n.mult)) n = n.mult = Ne({}, n.mult);
+                    else return n.mult = Xt(t) ? {
                         signal: `(${n.mult}) * (${t.signal})`
                     } : n.mult * t, e;
                 n.mult = t
             } return e
     }
 
-    function uue(e, t, n, i, r, s) {
-        const a = ui(e, t),
+    function Cle(e, t, n, i, r, s) {
+        const a = bi(e, t),
             o = e.orient,
-            l = b1(o, -1, 1);
+            l = J1(o, -1, 1);
         let u, c, f;
         const h = {
             enter: u = {
-                opacity: Le
+                opacity: Ye
             },
             update: f = {
-                opacity: Oi
+                opacity: qi
             },
             exit: c = {
-                opacity: Le
+                opacity: Ye
             }
         };
-        Zt(h, {
+        xn(h, {
             stroke: a("tickColor"),
             strokeCap: a("tickCap"),
             strokeDash: a("tickDash"),
             strokeDashOffset: a("tickDashOffset"),
             strokeOpacity: a("tickOpacity"),
             strokeWidth: a("tickWidth")
         });
-        const d = jt(r);
+        const d = rn(r);
         d.mult = l;
         const g = {
             scale: e.scale,
-            field: Mi,
+            field: Wi,
             band: s.band,
             extra: s.extra,
             offset: s.offset,
             round: a("tickRound")
         };
-        return f.y = u.y = Ut(o, Le, g), f.y2 = u.y2 = Ut(o, d), c.x = Ut(o, g), f.x = u.x = ar(o, Le, g), f.x2 = u.x2 = ar(o, d), c.y = ar(o, g), _i({
-            type: lE,
-            role: Fae,
-            key: Mi,
+        return f.y = u.y = sn(o, Ye, g), f.y2 = u.y2 = sn(o, d), c.x = sn(o, g), f.x = u.x = Sr(o, Ye, g), f.x2 = u.x2 = Sr(o, d), c.y = Sr(o, g), Di({
+            type: JE,
+            role: Vse,
+            key: Wi,
             from: i,
             encode: h
         }, n)
     }
 
-    function Ev(e, t, n, i, r) {
+    function Zv(e, t, n, i, r) {
         return {
             signal: 'flush(range("' + e + '"), scale("' + e + '", datum.value), ' + t + "," + n + "," + i + "," + r + ")"
         }
     }
 
-    function cue(e, t, n, i, r, s) {
-        const a = ui(e, t),
+    function Ale(e, t, n, i, r, s) {
+        const a = bi(e, t),
             o = e.orient,
             l = e.scale,
-            u = b1(o, -1, 1),
-            c = Wo(a("labelFlush")),
-            f = Wo(a("labelFlushOffset")),
+            u = J1(o, -1, 1),
+            c = gl(a("labelFlush")),
+            f = gl(a("labelFlushOffset")),
             h = a("labelAlign"),
             d = a("labelBaseline");
         let g = c === 0 || !!c,
             p;
-        const m = jt(r);
-        m.mult = u, m.offset = jt(a("labelPadding") || 0), m.offset.mult = u;
+        const m = rn(r);
+        m.mult = u, m.offset = rn(a("labelPadding") || 0), m.offset.mult = u;
         const y = {
                 scale: l,
-                field: Mi,
+                field: Wi,
                 band: .5,
-                offset: eI(s.offset, a("labelOffset"))
+                offset: PI(s.offset, a("labelOffset"))
             },
-            v = Ut(o, g ? Ev(l, c, '"left"', '"right"', '"center"') : {
+            v = sn(o, g ? Zv(l, c, '"left"', '"right"', '"center"') : {
                 value: "center"
-            }, Jle(o, "left", "right")),
-            b = Ut(o, aI(o, "bottom", "top"), g ? Ev(l, c, '"top"', '"bottom"', '"middle"') : {
+            }, gle(o, "left", "right")),
+            b = sn(o, GI(o, "bottom", "top"), g ? Zv(l, c, '"top"', '"bottom"', '"middle"') : {
                 value: "middle"
             }),
-            x = Ev(l, c, `-(${f})`, f, 0);
+            x = Zv(l, c, `-(${f})`, f, 0);
         g = g && f;
         const _ = {
-                opacity: Le,
-                x: Ut(o, y, m),
-                y: ar(o, y, m)
+                opacity: Ye,
+                x: sn(o, y, m),
+                y: Sr(o, y, m)
             },
             S = {
                 enter: _,
                 update: p = {
-                    opacity: Oi,
+                    opacity: qi,
                     text: {
-                        field: sE
+                        field: XE
                     },
                     x: _.x,
                     y: _.y,
                     align: v,
                     baseline: b
                 },
                 exit: {
-                    opacity: Le,
+                    opacity: Ye,
                     x: _.x,
                     y: _.y
                 }
             };
-        Zt(S, {
-            dx: !h && g ? Ut(o, x) : null,
-            dy: !d && g ? ar(o, x) : null
-        }), Zt(S, {
+        xn(S, {
+            dx: !h && g ? sn(o, x) : null,
+            dy: !d && g ? Sr(o, x) : null
+        }), xn(S, {
             angle: a("labelAngle"),
             fill: a("labelColor"),
             fillOpacity: a("labelOpacity"),
             font: a("labelFont"),
             fontSize: a("labelFontSize"),
             fontWeight: a("labelFontWeight"),
             fontStyle: a("labelFontStyle"),
@@ -34680,150 +27918,150 @@
             method: E,
             order: "datum.index",
             bound: w ? {
                 scale: l,
                 orient: o,
                 tolerance: w
             } : null
-        } : void 0, p.align !== v && (p.align = Su(p.align, v)), p.baseline !== b && (p.baseline = Su(p.baseline, b)), _i({
-            type: Rl,
-            role: Oae,
-            style: kd,
-            key: Mi,
+        } : void 0, p.align !== v && (p.align = Xu(p.align, v)), p.baseline !== b && (p.baseline = Xu(p.baseline, b)), Di({
+            type: Zl,
+            role: Xse,
+            style: tg,
+            key: Wi,
             from: i,
             encode: S,
             overlap: E
         }, n)
     }
 
-    function fue(e, t, n, i) {
-        const r = ui(e, t),
+    function $le(e, t, n, i) {
+        const r = bi(e, t),
             s = e.orient,
-            a = b1(s, -1, 1);
+            a = J1(s, -1, 1);
         let o, l;
         const u = {
                 enter: o = {
-                    opacity: Le,
-                    anchor: jt(r("titleAnchor", null)),
+                    opacity: Ye,
+                    anchor: rn(r("titleAnchor", null)),
                     align: {
-                        signal: uE
+                        signal: QE
                     }
                 },
-                update: l = Ae({}, o, {
-                    opacity: Oi,
-                    text: jt(e.title)
+                update: l = Ne({}, o, {
+                    opacity: qi,
+                    text: rn(e.title)
                 }),
                 exit: {
-                    opacity: Le
+                    opacity: Ye
                 }
             },
             c = {
-                signal: `lerp(range("${e.scale}"), ${m1(0,1,.5)})`
+                signal: `lerp(range("${e.scale}"), ${X1(0,1,.5)})`
             };
-        return l.x = Ut(s, c), l.y = ar(s, c), o.angle = Ut(s, Le, rue(a, 90)), o.baseline = Ut(s, aI(s, za, br), {
-            value: za
-        }), l.angle = o.angle, l.baseline = o.baseline, Zt(u, {
+        return l.x = sn(s, c), l.y = Sr(s, c), o.angle = sn(s, Ye, _le(a, 90)), o.baseline = sn(s, GI(s, oo, Rr), {
+            value: oo
+        }), l.angle = o.angle, l.baseline = o.baseline, xn(u, {
             fill: r("titleColor"),
             fillOpacity: r("titleOpacity"),
             font: r("titleFont"),
             fontSize: r("titleFontSize"),
             fontStyle: r("titleFontStyle"),
             fontWeight: r("titleFontWeight"),
             limit: r("titleLimit"),
             lineHeight: r("titleLineHeight")
         }, {
             align: r("titleAlign"),
             angle: r("titleAngle"),
             baseline: r("titleBaseline")
-        }), hue(r, s, u, n), u.update.align = Su(u.update.align, o.align), u.update.angle = Su(u.update.angle, o.angle), u.update.baseline = Su(u.update.baseline, o.baseline), _i({
-            type: Rl,
-            role: Rae,
-            style: aE,
+        }), Tle(r, s, u, n), u.update.align = Xu(u.update.align, o.align), u.update.angle = Xu(u.update.angle, o.angle), u.update.baseline = Xu(u.update.baseline, o.baseline), Di({
+            type: Zl,
+            role: Kse,
+            style: VE,
             from: i,
             encode: u
         }, n)
     }
 
-    function hue(e, t, n, i) {
-        const r = (o, l) => o != null ? (n.update[l] = Su(jt(o), n.update[l]), !1) : !ou(l, i),
+    function Tle(e, t, n, i) {
+        const r = (o, l) => o != null ? (n.update[l] = Xu(rn(o), n.update[l]), !1) : !Du(l, i),
             s = r(e("titleX"), "x"),
             a = r(e("titleY"), "y");
-        n.enter.auto = a === s ? jt(a) : Ut(t, jt(a), jt(s))
+        n.enter.auto = a === s ? rn(a) : sn(t, rn(a), rn(s))
     }
 
-    function due(e, t) {
-        const n = sue(e, t),
+    function Mle(e, t) {
+        const n = wle(e, t),
             i = e.encode || {},
             r = i.axis || {},
             s = r.name || void 0,
             a = r.interactive,
             o = r.style,
-            l = ui(e, n),
-            u = ule(l),
+            l = bi(e, n),
+            u = Coe(l),
             c = {
                 scale: e.scale,
                 ticks: !!l("ticks"),
                 labels: !!l("labels"),
                 grid: !!l("grid"),
                 domain: !!l("domain"),
                 title: e.title != null
             },
-            f = de(t.add(vr({}, [c]))),
-            h = de(t.add(goe({
+            f = Se(t.add(Fr({}, [c]))),
+            h = Se(t.add(Oae({
                 scale: t.scaleRef(e.scale),
                 extra: t.property(u.extra),
                 count: t.objectProperty(e.tickCount),
                 values: t.objectProperty(e.values),
                 minstep: t.property(e.tickMinStep),
                 formatType: t.property(e.formatType),
                 formatSpecifier: t.property(e.format)
             }))),
             d = [];
         let g;
-        return c.grid && d.push(oue(e, n, i.grid, h, u)), c.ticks && (g = l("tickSize"), d.push(uue(e, n, i.ticks, h, g, u))), c.labels && (g = c.ticks ? g : 0, d.push(cue(e, n, i.labels, h, g, u))), c.domain && d.push(aue(e, n, i.domain, f)), c.title && d.push(fue(e, n, i.title, f)), v1(Lh({
-            role: $ae,
+        return c.grid && d.push(Ele(e, n, i.grid, h, u)), c.ticks && (g = l("tickSize"), d.push(Cle(e, n, i.ticks, h, g, u))), c.labels && (g = c.ticks ? g : 0, d.push(Ale(e, n, i.labels, h, g, u))), c.domain && d.push(Sle(e, n, i.domain, f)), c.title && d.push($le(e, n, i.title, f)), K1(hd({
+            role: qse,
             from: f,
-            encode: Ac(gue(l, e), r, Ad),
+            encode: Zc(Ole(l, e), r, ng),
             marks: d,
             aria: l("aria"),
             description: l("description"),
             zindex: l("zindex"),
             name: s,
             interactive: a,
             style: o
         }), t)
     }
 
-    function gue(e, t) {
+    function Ole(e, t) {
         const n = {
             enter: {},
             update: {}
         };
-        return Zt(n, {
+        return xn(n, {
             orient: e("orient"),
             offset: e("offset") || 0,
-            position: Yi(t.position, 0),
+            position: ur(t.position, 0),
             titlePadding: e("titlePadding"),
             minExtent: e("minExtent"),
             maxExtent: e("maxExtent"),
             range: {
                 signal: `abs(span(range("${t.scale}")))`
             },
             translate: e("translate"),
             format: t.format,
             formatType: t.formatType
         }), n
     }
 
-    function lI(e, t, n) {
-        const i = se(e.signals),
-            r = se(e.scales);
-        return n || i.forEach(s => BL(s, t)), se(e.projections).forEach(s => Hoe(s, t)), r.forEach(s => Doe(s, t)), se(e.data).forEach(s => Vle(s, t)), r.forEach(s => Noe(s, t)), (n || i).forEach(s => doe(s, t)), se(e.axes).forEach(s => due(s, t)), se(e.marks).forEach(s => v1(s, t)), se(e.legends).forEach(s => Lle(s, t)), e.title && Wle(e.title, t), t.parseLambdas(), t
+    function WI(e, t, n) {
+        const i = ue(e.signals),
+            r = ue(e.scales);
+        return n || i.forEach(s => wI(s, t)), ue(e.projections).forEach(s => uoe(s, t)), r.forEach(s => Jae(s, t)), ue(e.data).forEach(s => hle(s, t)), r.forEach(s => Qae(s, t)), (n || i).forEach(s => Mae(s, t)), ue(e.axes).forEach(s => Mle(s, t)), ue(e.marks).forEach(s => K1(s, t)), ue(e.legends).forEach(s => ele(s, t)), e.title && ole(e.title, t), t.parseLambdas(), t
     }
-    const pue = e => Ac({
+    const Fle = e => Zc({
         enter: {
             x: {
                 value: 0
             },
             y: {
                 value: 0
             }
@@ -34834,77 +28072,77 @@
             },
             height: {
                 signal: "height"
             }
         }
     }, e);
 
-    function mue(e, t) {
+    function Rle(e, t) {
         const n = t.config,
-            i = de(t.root = t.add(D0())),
-            r = yue(e, n);
-        r.forEach(u => BL(u, t)), t.description = e.description || n.description, t.eventConfig = n.events, t.legends = t.objectProperty(n.legend && n.legend.layout), t.locale = n.locale;
-        const s = t.add(vr()),
-            a = t.add(GL(zL(pue(e.encode), p1, tE, e.style, t, {
-                pulse: de(s)
+            i = Se(t.root = t.add(p0())),
+            r = Dle(e, n);
+        r.forEach(u => wI(u, t)), t.description = e.description || n.description, t.eventConfig = n.events, t.legends = t.objectProperty(n.legend && n.legend.layout), t.locale = n.locale;
+        const s = t.add(Fr()),
+            a = t.add(kI(_I(Fle(e.encode), Y1, WE, e.style, t, {
+                pulse: Se(s)
             }))),
-            o = t.add(HL({
+            o = t.add($I({
                 layout: t.objectProperty(e.layout),
                 legends: t.legends,
                 autosize: t.signalRef("autosize"),
                 mark: i,
-                pulse: de(a)
+                pulse: Se(a)
             }));
-        t.operators.pop(), t.pushState(de(a), de(o), null), lI(e, t, r), t.operators.push(o);
-        let l = t.add(UL({
+        t.operators.pop(), t.pushState(Se(a), Se(o), null), WI(e, t, r), t.operators.push(o);
+        let l = t.add(EI({
             mark: i,
-            pulse: de(o)
+            pulse: Se(o)
         }));
-        return l = t.add(qL({
-            pulse: de(l)
-        })), l = t.add(Fl({
-            pulse: de(l)
-        })), t.addData("root", new al(t, s, s, l)), t
+        return l = t.add(AI({
+            pulse: Se(l)
+        })), l = t.add(Ql({
+            pulse: Se(l)
+        })), t.addData("root", new Ol(t, s, s, l)), t
     }
 
-    function uf(e, t) {
+    function Nf(e, t) {
         return t && t.signal ? {
             name: e,
             update: t.signal
         } : {
             name: e,
             value: t
         }
     }
 
-    function yue(e, t) {
-        const n = a => Yi(e[a], t[a]),
-            i = [uf("background", n("background")), uf("autosize", Cae(n("autosize"))), uf("padding", Aae(n("padding"))), uf("width", n("width") || 0), uf("height", n("height") || 0)],
+    function Dle(e, t) {
+        const n = a => ur(e[a], t[a]),
+            i = [Nf("background", n("background")), Nf("autosize", Gse(n("autosize"))), Nf("padding", Wse(n("padding"))), Nf("width", n("width") || 0), Nf("height", n("height") || 0)],
             r = i.reduce((a, o) => (a[o.name] = o, a), {}),
             s = {};
-        return se(e.signals).forEach(a => {
-            me(r, a.name) ? a = Ae(r[a.name], a) : i.push(a), s[a.name] = a
-        }), se(t.signals).forEach(a => {
-            !me(s, a.name) && !me(r, a.name) && i.push(a)
+        return ue(e.signals).forEach(a => {
+            Ce(r, a.name) ? a = Ne(r[a.name], a) : i.push(a), s[a.name] = a
+        }), ue(t.signals).forEach(a => {
+            !Ce(s, a.name) && !Ce(r, a.name) && i.push(a)
         }), i
     }
 
-    function uI(e, t) {
+    function qI(e, t) {
         this.config = e || {}, this.options = t || {}, this.bindings = [], this.field = {}, this.signals = {}, this.lambdas = {}, this.scales = {}, this.events = {}, this.data = {}, this.streams = [], this.updates = [], this.operators = [], this.eventConfig = null, this.locale = null, this._id = 0, this._subid = 0, this._nextsub = [0], this._parent = [], this._encode = [], this._lookup = [], this._markpath = []
     }
 
-    function _5(e) {
+    function G5(e) {
         this.config = e.config, this.options = e.options, this.legends = e.legends, this.field = Object.create(e.field), this.signals = Object.create(e.signals), this.lambdas = Object.create(e.lambdas), this.scales = Object.create(e.scales), this.events = Object.create(e.events), this.data = Object.create(e.data), this.streams = [], this.updates = [], this.operators = [], this._id = 0, this._subid = ++e._nextsub[0], this._nextsub = e._nextsub, this._parent = e._parent.slice(), this._encode = e._encode.slice(), this._lookup = e._lookup.slice(), this._markpath = e._markpath
     }
-    uI.prototype = _5.prototype = {
+    qI.prototype = G5.prototype = {
         parse(e) {
-            return lI(e, this)
+            return WI(e, this)
         },
         fork() {
-            return new _5(this)
+            return new G5(this)
         },
         isSubscope() {
             return this._subid > 0
         },
         toRuntime() {
             return this.finish(), {
                 description: this.description,
@@ -34921,16 +28159,16 @@
         },
         add(e) {
             return this.operators.push(e), e.id = this.id(), e.refs && (e.refs.forEach(t => {
                 t.$ref = e.id
             }), e.refs = null), e
         },
         proxy(e) {
-            const t = e instanceof P2 ? de(e) : e;
-            return this.add($oe({
+            const t = e instanceof dx ? Se(e) : e;
+            return this.add(qae({
                 value: t
             }))
         },
         addStream(e) {
             return this.streams.push(e), e.id = this.id(), e
         },
         addUpdate(e) {
@@ -34949,185 +28187,185 @@
             for (e in this.data) {
                 t = this.data[e], n(t.input, e, "input"), n(t.output, e, "output"), n(t.values, e, "values");
                 for (const i in t.index) n(t.index[i], e, "index:" + i)
             }
             return this
         },
         pushState(e, t, n) {
-            this._encode.push(de(this.add(Fl({
+            this._encode.push(Se(this.add(Ql({
                 pulse: e
-            })))), this._parent.push(t), this._lookup.push(n ? de(this.proxy(n)) : null), this._markpath.push(-1)
+            })))), this._parent.push(t), this._lookup.push(n ? Se(this.proxy(n)) : null), this._markpath.push(-1)
         },
         popState() {
             this._encode.pop(), this._parent.pop(), this._lookup.pop(), this._markpath.pop()
         },
         parent() {
-            return De(this._parent)
+            return We(this._parent)
         },
         encode() {
-            return De(this._encode)
+            return We(this._encode)
         },
         lookup() {
-            return De(this._lookup)
+            return We(this._lookup)
         },
         markpath() {
             const e = this._markpath;
             return ++e[e.length - 1]
         },
         fieldRef(e, t) {
-            if (re(e)) return Nh(e, t);
-            e.signal || U("Unsupported field reference: " + Z(e));
+            if (le(e)) return cd(e, t);
+            e.signal || q("Unsupported field reference: " + te(e));
             const n = e.signal;
             let i = this.field[n];
             if (!i) {
                 const r = {
                     name: this.signalRef(n)
                 };
-                t && (r.as = t), this.field[n] = i = de(this.add(voe(r)))
+                t && (r.as = t), this.field[n] = i = Se(this.add(Nae(r)))
             }
             return i
         },
         compareRef(e) {
             let t = !1;
-            const n = s => Ft(s) ? (t = !0, this.signalRef(s.signal)) : ioe(s) ? (t = !0, this.exprRef(s.expr)) : s,
-                i = se(e.field).map(n),
-                r = se(e.order).map(n);
-            return t ? de(this.add(o5({
+            const n = s => Xt(s) ? (t = !0, this.signalRef(s.signal)) : xae(s) ? (t = !0, this.exprRef(s.expr)) : s,
+                i = ue(e.field).map(n),
+                r = ue(e.order).map(n);
+            return t ? Se(this.add($5({
                 fields: i,
                 orders: r
-            }))) : s5(i, r)
+            }))) : C5(i, r)
         },
         keyRef(e, t) {
             let n = !1;
-            const i = s => Ft(s) ? (n = !0, de(r[s.signal])) : s,
+            const i = s => Xt(s) ? (n = !0, Se(r[s.signal])) : s,
                 r = this.signals;
-            return e = se(e).map(i), n ? de(this.add(boe({
+            return e = ue(e).map(i), n ? Se(this.add(Pae({
                 fields: e,
                 flat: t
-            }))) : Zae(e, t)
+            }))) : mae(e, t)
         },
         sortRef(e) {
             if (!e) return e;
-            const t = d1(e.op, e.field),
-                n = e.order || eoe;
-            return n.signal ? de(this.add(o5({
+            const t = q1(e.op, e.field),
+                n = e.order || yae;
+            return n.signal ? Se(this.add($5({
                 fields: t,
                 orders: this.signalRef(n.signal)
-            }))) : s5(t, n)
+            }))) : C5(t, n)
         },
         event(e, t) {
             const n = e + ":" + t;
             if (!this.events[n]) {
                 const i = this.id();
                 this.streams.push({
                     id: i,
                     source: e,
                     type: t
                 }), this.events[n] = i
             }
             return this.events[n]
         },
         hasOwnSignal(e) {
-            return me(this.signals, e)
+            return Ce(this.signals, e)
         },
         addSignal(e, t) {
-            this.hasOwnSignal(e) && U("Duplicate signal name: " + Z(e));
-            const n = t instanceof P2 ? t : this.add(D0(t));
+            this.hasOwnSignal(e) && q("Duplicate signal name: " + te(e));
+            const n = t instanceof dx ? t : this.add(p0(t));
             return this.signals[e] = n
         },
         getSignal(e) {
-            return this.signals[e] || U("Unrecognized signal name: " + Z(e)), this.signals[e]
+            return this.signals[e] || q("Unrecognized signal name: " + te(e)), this.signals[e]
         },
         signalRef(e) {
-            return this.signals[e] ? de(this.signals[e]) : (me(this.lambdas, e) || (this.lambdas[e] = this.add(D0(null))), de(this.lambdas[e]))
+            return this.signals[e] ? Se(this.signals[e]) : (Ce(this.lambdas, e) || (this.lambdas[e] = this.add(p0(null))), Se(this.lambdas[e]))
         },
         parseLambdas() {
             const e = Object.keys(this.lambdas);
             for (let t = 0, n = e.length; t < n; ++t) {
                 const i = e[t],
-                    r = Xr(i, this),
+                    r = cs(i, this),
                     s = this.lambdas[i];
                 s.params = r.$params, s.update = r.$expr
             }
         },
         property(e) {
             return e && e.signal ? this.signalRef(e.signal) : e
         },
         objectProperty(e) {
-            return !e || !ae(e) ? e : this.signalRef(e.signal || gE(e))
+            return !e || !ce(e) ? e : this.signalRef(e.signal || ik(e))
         },
         exprRef(e, t) {
             const n = {
-                expr: Xr(e, this)
+                expr: cs(e, this)
             };
-            return t && (n.expr.$name = t), de(this.add(moe(n)))
+            return t && (n.expr.$name = t), Se(this.add(Rae(n)))
         },
         addBinding(e, t) {
-            this.bindings || U("Nested signals do not support binding: " + Z(e)), this.bindings.push(Ae({
+            this.bindings || q("Nested signals do not support binding: " + te(e)), this.bindings.push(Ne({
                 signal: e
             }, t))
         },
         addScaleProj(e, t) {
-            me(this.scales, e) && U("Duplicate scale or projection name: " + Z(e)), this.scales[e] = this.add(t)
+            Ce(this.scales, e) && q("Duplicate scale or projection name: " + te(e)), this.scales[e] = this.add(t)
         },
         addScale(e, t) {
-            this.addScaleProj(e, Moe(t))
+            this.addScaleProj(e, Yae(t))
         },
         addProjection(e, t) {
-            this.addScaleProj(e, Aoe(t))
+            this.addScaleProj(e, Wae(t))
         },
         getScale(e) {
-            return this.scales[e] || U("Unrecognized scale name: " + Z(e)), this.scales[e]
+            return this.scales[e] || q("Unrecognized scale name: " + te(e)), this.scales[e]
         },
         scaleRef(e) {
-            return de(this.getScale(e))
+            return Se(this.getScale(e))
         },
         scaleType(e) {
             return this.getScale(e).params.type
         },
         projectionRef(e) {
             return this.scaleRef(e)
         },
         projectionType(e) {
             return this.scaleType(e)
         },
         addData(e, t) {
-            return me(this.data, e) && U("Duplicate data set name: " + Z(e)), this.data[e] = t
+            return Ce(this.data, e) && q("Duplicate data set name: " + te(e)), this.data[e] = t
         },
         getData(e) {
-            return this.data[e] || U("Undefined data set name: " + Z(e)), this.data[e]
+            return this.data[e] || q("Undefined data set name: " + te(e)), this.data[e]
         },
         addDataPipeline(e, t) {
-            return me(this.data, e) && U("Duplicate data set name: " + Z(e)), this.addData(e, al.fromEntries(this, t))
+            return Ce(this.data, e) && q("Duplicate data set name: " + te(e)), this.addData(e, Ol.fromEntries(this, t))
         }
     };
 
-    function gE(e) {
-        return (W(e) ? vue : bue)(e)
+    function ik(e) {
+        return (H(e) ? Nle : Ple)(e)
     }
 
-    function vue(e) {
+    function Nle(e) {
         const t = e.length;
         let n = "[";
         for (let i = 0; i < t; ++i) {
             const r = e[i];
-            n += (i > 0 ? "," : "") + (ae(r) ? r.signal || gE(r) : Z(r))
+            n += (i > 0 ? "," : "") + (ce(r) ? r.signal || ik(r) : te(r))
         }
         return n + "]"
     }
 
-    function bue(e) {
+    function Ple(e) {
         let t = "{",
             n = 0,
             i, r;
-        for (i in e) r = e[i], t += (++n > 1 ? "," : "") + Z(i) + ":" + (ae(r) ? r.signal || gE(r) : Z(r));
+        for (i in e) r = e[i], t += (++n > 1 ? "," : "") + te(i) + ":" + (ce(r) ? r.signal || ik(r) : te(r));
         return t + "}"
     }
 
-    function xue() {
+    function Lle() {
         const e = "sans-serif",
             i = "#4c78a8",
             r = "#000",
             s = "#888",
             a = "#ddd";
         return {
             description: "Vega visualization",
@@ -35314,274 +28552,274 @@
                     extent: [1, 0]
                 },
                 symbol: ["circle", "square", "triangle-up", "cross", "diamond", "triangle-right", "triangle-down", "triangle-left"]
             }
         }
     }
 
-    function _ue(e, t, n) {
-        return ae(e) || U("Input Vega specification must be an object."), t = bc(xue(), t, e.config), mue(e, new uI(t, n)).toRuntime()
+    function Ile(e, t, n) {
+        return ce(e) || q("Input Vega specification must be an object."), t = jc(Lle(), t, e.config), Rle(e, new qI(t, n)).toRuntime()
     }
-    var wue = "5.25.0";
-    Ae(Uu, bK, aee, Iee, pte, wte, Vte, $te, Jte, ene, cne, yne);
-    const Sue = Object.freeze(Object.defineProperty({
+    var zle = "5.25.0";
+    Ne(lc, jW, oK, zK, kQ, bZ, Hee, kee, Xee, yte, Ate, Dte);
+    const Ble = Object.freeze(Object.defineProperty({
         __proto__: null,
-        Bounds: kt,
-        CanvasHandler: _d,
-        CanvasRenderer: w0,
-        DATE: ri,
-        DAY: fn,
-        DAYOFYEAR: Yr,
-        Dataflow: wu,
-        Debug: UR,
-        Error: s_,
-        EventStream: Nm,
-        Gradient: sP,
-        GroupItem: Xm,
-        HOURS: vi,
-        Handler: La,
-        Info: jR,
-        Item: Ym,
-        MILLISECONDS: hr,
-        MINUTES: bi,
-        MONTH: mn,
-        Marks: xi,
-        MultiPulse: C_,
-        None: BR,
-        Operator: it,
-        Parameters: Dm,
-        Pulse: Ca,
-        QUARTER: ii,
-        RenderType: ya,
-        Renderer: rs,
-        ResourceLoader: Tw,
-        SECONDS: Di,
-        SVGHandler: Yw,
-        SVGRenderer: Zw,
-        SVGStringRenderer: eS,
-        Scenegraph: qw,
-        TIME_UNITS: y_,
-        Transform: L,
-        View: AL,
-        WEEK: Tt,
-        Warn: a_,
-        YEAR: Jt,
-        accessor: li,
-        accessorFields: pn,
-        accessorName: bt,
-        array: se,
-        ascending: $m,
-        bandwidthNRD: T_,
-        bin: JD,
-        bootstrapCI: QD,
-        boundClip: ZP,
-        boundContext: yd,
-        boundItem: u2,
-        boundMark: EP,
-        boundStroke: qs,
-        changeset: Tl,
-        clampRange: ZR,
-        codegenExpression: tL,
-        compare: f_,
-        constant: xn,
-        cumulativeLogNormal: N_,
-        cumulativeNormal: Lm,
-        cumulativeUniform: z_,
-        dayofyear: fD,
-        debounce: h_,
-        defaultLocale: x_,
-        definition: XD,
-        densityLogNormal: D_,
-        densityNormal: M_,
-        densityUniform: I_,
-        domChild: Yn,
-        domClear: Zi,
-        domCreate: pa,
-        domFind: Hw,
-        dotbin: ZD,
-        error: U,
-        expressionFunction: At,
-        extend: Ae,
-        extent: Hr,
-        extentIndex: eD,
-        falsy: ia,
-        fastmap: _c,
-        field: ni,
-        flush: tD,
-        font: Zm,
-        fontFamily: xd,
-        fontSize: is,
-        format: Vg,
-        formatLocale: f0,
-        formats: S_,
-        hasOwnProperty: me,
-        id: sd,
-        identity: bn,
-        inferType: LD,
-        inferTypes: ID,
-        ingest: He,
-        inherits: ee,
-        inrange: hu,
-        interpolate: _w,
-        interpolateColors: qm,
-        interpolateRange: qN,
-        intersect: VP,
-        intersectBoxLine: du,
-        intersectPath: Mw,
-        intersectPoint: Ow,
-        intersectRule: dP,
-        isArray: W,
-        isBoolean: Za,
-        isDate: Ea,
-        isFunction: $e,
-        isIterable: nD,
-        isNumber: Ze,
-        isObject: ae,
-        isRegExp: iD,
-        isString: re,
-        isTuple: Fm,
-        key: d_,
-        lerp: rD,
-        lineHeight: Na,
-        loader: Mm,
-        locale: ND,
-        logger: o_,
-        lruCache: sD,
-        markup: Qw,
-        merge: aD,
-        mergeConfig: bc,
-        multiLineOffset: Uw,
-        one: vc,
-        pad: oD,
-        panLinear: YR,
-        panLog: XR,
-        panPow: VR,
-        panSymlog: KR,
-        parse: _ue,
-        parseExpression: jS,
-        parseSelector: to,
-        path: om,
-        pathCurves: kw,
-        pathEqual: e4,
-        pathParse: Hu,
-        pathRectangle: lP,
-        pathRender: kh,
-        pathSymbols: oP,
-        pathTrail: uP,
-        peek: De,
-        point: t1,
-        projection: hS,
-        quantileLogNormal: P_,
-        quantileNormal: Im,
-        quantileUniform: B_,
-        quantiles: A_,
-        quantizeInterpolator: HN,
-        quarter: JR,
-        quartiles: $_,
+        Bounds: Ut,
+        CanvasHandler: Hd,
+        CanvasRenderer: $m,
+        DATE: di,
+        DAY: $n,
+        DAYOFYEAR: ls,
+        Dataflow: Wu,
+        Debug: YO,
+        Error: h_,
+        EventStream: J0,
+        Gradient: jN,
+        GroupItem: _1,
+        HOURS: Oi,
+        Handler: so,
+        Info: HO,
+        Item: x1,
+        MILLISECONDS: Ar,
+        MINUTES: Fi,
+        MONTH: Rn,
+        Marks: Ri,
+        MultiPulse: L_,
+        None: qO,
+        Operator: dt,
+        Parameters: K0,
+        Pulse: qa,
+        QUARTER: hi,
+        RenderType: Na,
+        Renderer: ys,
+        ResourceLoader: aS,
+        SECONDS: Xi,
+        SVGHandler: ES,
+        SVGRenderer: MS,
+        SVGStringRenderer: OS,
+        Scenegraph: wS,
+        TIME_UNITS: A_,
+        Transform: j,
+        View: uI,
+        WEEK: Ht,
+        Warn: d_,
+        YEAR: vn,
+        accessor: vi,
+        accessorFields: Fn,
+        accessorName: Pt,
+        array: ue,
+        ascending: z0,
+        bandwidthNRD: j_,
+        bin: $R,
+        bootstrapCI: TR,
+        boundClip: NP,
+        boundContext: Gd,
+        boundItem: y2,
+        boundMark: aP,
+        boundStroke: sa,
+        changeset: Xl,
+        clampRange: rF,
+        codegenExpression: LL,
+        compare: v_,
+        constant: Ln,
+        cumulativeLogNormal: Y_,
+        cumulativeNormal: Z0,
+        cumulativeUniform: J_,
+        dayofyear: NF,
+        debounce: b_,
+        defaultLocale: F_,
+        definition: kR,
+        densityLogNormal: H_,
+        densityNormal: G_,
+        densityUniform: K_,
+        domChild: ri,
+        domClear: dr,
+        domCreate: Ra,
+        domFind: SS,
+        dotbin: MR,
+        error: q,
+        expressionFunction: Wt,
+        extend: Ne,
+        extent: ss,
+        extentIndex: sF,
+        falsy: _a,
+        fastmap: Uc,
+        field: fi,
+        flush: aF,
+        font: C1,
+        fontFamily: qd,
+        fontSize: ms,
+        format: _p,
+        formatLocale: lm,
+        formats: N_,
+        hasOwnProperty: Ce,
+        id: kd,
+        identity: Pn,
+        inferType: gR,
+        inferTypes: pR,
+        ingest: it,
+        inherits: ne,
+        inrange: Pu,
+        interpolate: Qw,
+        interpolateColors: v1,
+        interpolateRange: AN,
+        intersect: OP,
+        intersectBoxLine: Lu,
+        intersectPath: oS,
+        intersectPoint: lS,
+        intersectRule: VN,
+        isArray: H,
+        isBoolean: mo,
+        isDate: Ua,
+        isFunction: Pe,
+        isIterable: oF,
+        isNumber: lt,
+        isObject: ce,
+        isRegExp: lF,
+        isString: le,
+        isTuple: X0,
+        key: x_,
+        lerp: uF,
+        lineHeight: io,
+        loader: H0,
+        locale: hR,
+        logger: g_,
+        lruCache: cF,
+        markup: TS,
+        merge: fF,
+        mergeConfig: jc,
+        multiLineOffset: bS,
+        one: Bc,
+        pad: hF,
+        panLinear: QO,
+        panLog: ZO,
+        panPow: eF,
+        panSymlog: tF,
+        parse: Ile,
+        parseExpression: ME,
+        parseSelector: wo,
+        path: r1,
+        pathCurves: iS,
+        pathEqual: PP,
+        pathParse: gc,
+        pathRectangle: WN,
+        pathRender: Qh,
+        pathSymbols: UN,
+        pathTrail: qN,
+        peek: We,
+        point: $1,
+        projection: KS,
+        quantileLogNormal: X_,
+        quantileNormal: e1,
+        quantileUniform: Q_,
+        quantiles: z_,
+        quantizeInterpolator: $N,
+        quarter: nF,
+        quartiles: B_,
         get random() {
-            return Ni
+            return Vi
         },
-        randomInteger: SV,
-        randomKDE: F_,
-        randomLCG: wV,
-        randomLogNormal: tN,
-        randomMixture: nN,
-        randomNormal: O_,
-        randomUniform: iN,
-        read: jD,
-        regressionConstant: j_,
-        regressionExp: sN,
-        regressionLinear: U_,
-        regressionLoess: lN,
-        regressionLog: rN,
-        regressionPoly: oN,
-        regressionPow: aN,
-        regressionQuad: G_,
-        renderModule: n1,
-        repeat: Ff,
-        resetDefaultLocale: bX,
-        resetSVGClipId: fP,
-        resetSVGDefIds: EZ,
-        responseType: BD,
-        runtimeContext: gL,
-        sampleCurve: Bm,
-        sampleLogNormal: R_,
-        sampleNormal: Pm,
-        sampleUniform: L_,
-        scale: We,
-        sceneEqual: tS,
-        sceneFromJSON: kP,
-        scenePickVisit: m0,
-        sceneToJSON: CP,
-        sceneVisit: dr,
-        sceneZOrder: Fw,
-        scheme: ww,
-        serializeXML: jP,
-        setRandom: xV,
-        span: ad,
-        splitAccessPath: ns,
-        stringValue: Z,
-        textMetrics: sr,
-        timeBin: $D,
-        timeFloor: vD,
-        timeFormatLocale: Sh,
-        timeInterval: wc,
-        timeOffset: _D,
-        timeSequence: ED,
-        timeUnitSpecifier: cD,
-        timeUnits: v_,
-        toBoolean: g_,
-        toDate: p_,
-        toNumber: hn,
-        toSet: fr,
-        toString: m_,
-        transform: VD,
-        transforms: Uu,
-        truncate: lD,
-        truthy: Ri,
-        tupleid: ge,
-        typeParsers: Zb,
-        utcFloor: bD,
-        utcInterval: Sc,
-        utcOffset: wD,
-        utcSequence: CD,
-        utcdayofyear: gD,
-        utcquarter: QR,
-        utcweek: pD,
-        version: wue,
-        visitArray: oa,
-        week: hD,
-        writeConfig: xc,
-        zero: ha,
-        zoomLinear: l_,
-        zoomLog: u_,
-        zoomPow: c0,
-        zoomSymlog: c_
+        randomInteger: qU,
+        randomKDE: W_,
+        randomLCG: WU,
+        randomLogNormal: FR,
+        randomMixture: RR,
+        randomNormal: U_,
+        randomUniform: DR,
+        read: vR,
+        regressionConstant: Z_,
+        regressionExp: PR,
+        regressionLinear: ew,
+        regressionLoess: zR,
+        regressionLog: NR,
+        regressionPoly: IR,
+        regressionPow: LR,
+        regressionQuad: tw,
+        renderModule: T1,
+        repeat: Xf,
+        resetDefaultLocale: jG,
+        resetSVGClipId: YN,
+        resetSVGDefIds: kV,
+        responseType: yR,
+        runtimeContext: KL,
+        sampleCurve: n1,
+        sampleLogNormal: q_,
+        sampleNormal: Q0,
+        sampleUniform: V_,
+        scale: Ze,
+        sceneEqual: FS,
+        sceneFromJSON: lP,
+        scenePickVisit: wm,
+        sceneToJSON: oP,
+        sceneVisit: $r,
+        sceneZOrder: uS,
+        scheme: Zw,
+        serializeXML: SP,
+        setRandom: GU,
+        span: Cd,
+        splitAccessPath: gs,
+        stringValue: te,
+        textMetrics: wr,
+        timeBin: QF,
+        timeFloor: GF,
+        timeFormatLocale: Hh,
+        timeInterval: Hc,
+        timeOffset: qF,
+        timeSequence: XF,
+        timeUnitSpecifier: DF,
+        timeUnits: $_,
+        toBoolean: __,
+        toDate: w_,
+        toNumber: Tn,
+        toSet: Cr,
+        toString: S_,
+        transform: CR,
+        transforms: lc,
+        truncate: dF,
+        truthy: Yi,
+        tupleid: Ee,
+        typeParsers: Qb,
+        utcFloor: UF,
+        utcInterval: Yc,
+        utcOffset: HF,
+        utcSequence: VF,
+        utcdayofyear: IF,
+        utcquarter: iF,
+        utcweek: zF,
+        version: zle,
+        visitArray: ka,
+        week: PF,
+        writeConfig: Gc,
+        zero: Ma,
+        zoomLinear: p_,
+        zoomLog: m_,
+        zoomPow: tm,
+        zoomSymlog: y_
     }, Symbol.toStringTag, {
         value: "Module"
     }));
 
-    function Eue(e, t, n) {
+    function jle(e, t, n) {
         let i;
         t.x2 && (t.x ? (n && e.x > e.x2 && (i = e.x, e.x = e.x2, e.x2 = i), e.width = e.x2 - e.x) : e.x = e.x2 - (e.width || 0)), t.xc && (e.x = e.xc - (e.width || 0) / 2), t.y2 && (t.y ? (n && e.y > e.y2 && (i = e.y, e.y = e.y2, e.y2 = i), e.height = e.y2 - e.y) : e.y = e.y2 - (e.height || 0)), t.yc && (e.y = e.yc - (e.height || 0) / 2)
     }
-    var Cue = {
+    var Gle = {
             NaN: NaN,
             E: Math.E,
             LN2: Math.LN2,
             LN10: Math.LN10,
             LOG2E: Math.LOG2E,
             LOG10E: Math.LOG10E,
             PI: Math.PI,
             SQRT1_2: Math.SQRT1_2,
             SQRT2: Math.SQRT2,
             MIN_VALUE: Number.MIN_VALUE,
             MAX_VALUE: Number.MAX_VALUE
         },
-        kue = {
+        Ule = {
             "*": (e, t) => e * t,
             "+": (e, t) => e + t,
             "-": (e, t) => e - t,
             "/": (e, t) => e / t,
             "%": (e, t) => e % t,
             ">": (e, t) => e > t,
             "<": (e, t) => e < t,
@@ -35594,27 +28832,27 @@
             "&": (e, t) => e & t,
             "|": (e, t) => e | t,
             "^": (e, t) => e ^ t,
             "<<": (e, t) => e << t,
             ">>": (e, t) => e >> t,
             ">>>": (e, t) => e >>> t
         },
-        Aue = {
+        Wle = {
             "+": e => +e,
             "-": e => -e,
             "~": e => ~e,
             "!": e => !e
         };
-    const $ue = Array.prototype.slice,
-        mo = (e, t, n) => {
+    const qle = Array.prototype.slice,
+        Io = (e, t, n) => {
             const i = n ? n(t[0]) : t[0];
-            return i[e].apply(i, $ue.call(t, 1))
+            return i[e].apply(i, qle.call(t, 1))
         },
-        Tue = (e, t, n, i, r, s, a) => new Date(e, t || 0, n ?? 1, i || 0, r || 0, s || 0, a || 0);
-    var Mue = {
+        Hle = (e, t, n, i, r, s, a) => new Date(e, t || 0, n ?? 1, i || 0, r || 0, s || 0, a || 0);
+    var Yle = {
         isNaN: Number.isNaN,
         isFinite: Number.isFinite,
         abs: Math.abs,
         acos: Math.acos,
         asin: Math.asin,
         atan: Math.atan,
         atan2: Math.atan2,
@@ -35630,15 +28868,15 @@
         round: Math.round,
         sin: Math.sin,
         sqrt: Math.sqrt,
         tan: Math.tan,
         clamp: (e, t, n) => Math.max(t, Math.min(n, e)),
         now: Date.now,
         utc: Date.UTC,
-        datetime: Tue,
+        datetime: Hle,
         date: e => new Date(e).getDate(),
         day: e => new Date(e).getDay(),
         year: e => new Date(e).getFullYear(),
         month: e => new Date(e).getMonth(),
         hours: e => new Date(e).getHours(),
         minutes: e => new Date(e).getMinutes(),
         seconds: e => new Date(e).getSeconds(),
@@ -35651,144 +28889,144 @@
         utcmonth: e => new Date(e).getUTCMonth(),
         utchours: e => new Date(e).getUTCHours(),
         utcminutes: e => new Date(e).getUTCMinutes(),
         utcseconds: e => new Date(e).getUTCSeconds(),
         utcmilliseconds: e => new Date(e).getUTCMilliseconds(),
         length: e => e.length,
         join: function() {
-            return mo("join", arguments)
+            return Io("join", arguments)
         },
         indexof: function() {
-            return mo("indexOf", arguments)
+            return Io("indexOf", arguments)
         },
         lastindexof: function() {
-            return mo("lastIndexOf", arguments)
+            return Io("lastIndexOf", arguments)
         },
         slice: function() {
-            return mo("slice", arguments)
+            return Io("slice", arguments)
         },
         reverse: e => e.slice().reverse(),
         parseFloat,
         parseInt,
         upper: e => String(e).toUpperCase(),
         lower: e => String(e).toLowerCase(),
         substring: function() {
-            return mo("substring", arguments, String)
+            return Io("substring", arguments, String)
         },
         split: function() {
-            return mo("split", arguments, String)
+            return Io("split", arguments, String)
         },
         replace: function() {
-            return mo("replace", arguments, String)
+            return Io("replace", arguments, String)
         },
         trim: e => String(e).trim(),
         regexp: RegExp,
         test: (e, t) => RegExp(e).test(t)
     };
-    const Oue = ["view", "item", "group", "xy", "x", "y"],
-        G2 = new Set([Function, eval, setTimeout, setInterval]);
-    typeof setImmediate == "function" && G2.add(setImmediate);
-    const Fue = {
+    const Xle = ["view", "item", "group", "xy", "x", "y"],
+        xx = new Set([Function, eval, setTimeout, setInterval]);
+    typeof setImmediate == "function" && xx.add(setImmediate);
+    const Vle = {
         Literal: (e, t) => t.value,
         Identifier: (e, t) => {
             const n = t.name;
-            return e.memberDepth > 0 ? n : n === "datum" ? e.datum : n === "event" ? e.event : n === "item" ? e.item : Cue[n] || e.params["$" + n]
+            return e.memberDepth > 0 ? n : n === "datum" ? e.datum : n === "event" ? e.event : n === "item" ? e.item : Gle[n] || e.params["$" + n]
         },
         MemberExpression: (e, t) => {
             const n = !t.computed,
                 i = e(t.object);
             n && (e.memberDepth += 1);
             const r = e(t.property);
-            if (n && (e.memberDepth -= 1), G2.has(i[r])) {
+            if (n && (e.memberDepth -= 1), xx.has(i[r])) {
                 console.error(`Prevented interpretation of member "${r}" which could lead to insecure code execution`);
                 return
             }
             return i[r]
         },
         CallExpression: (e, t) => {
             const n = t.arguments;
             let i = t.callee.name;
-            return i.startsWith("_") && (i = i.slice(1)), i === "if" ? e(n[0]) ? e(n[1]) : e(n[2]) : (e.fn[i] || Mue[i]).apply(e.fn, n.map(e))
+            return i.startsWith("_") && (i = i.slice(1)), i === "if" ? e(n[0]) ? e(n[1]) : e(n[2]) : (e.fn[i] || Yle[i]).apply(e.fn, n.map(e))
         },
         ArrayExpression: (e, t) => t.elements.map(e),
-        BinaryExpression: (e, t) => kue[t.operator](e(t.left), e(t.right)),
-        UnaryExpression: (e, t) => Aue[t.operator](e(t.argument)),
+        BinaryExpression: (e, t) => Ule[t.operator](e(t.left), e(t.right)),
+        UnaryExpression: (e, t) => Wle[t.operator](e(t.argument)),
         ConditionalExpression: (e, t) => e(t.test) ? e(t.consequent) : e(t.alternate),
         LogicalExpression: (e, t) => t.operator === "&&" ? e(t.left) && e(t.right) : e(t.left) || e(t.right),
         ObjectExpression: (e, t) => t.properties.reduce((n, i) => {
             e.memberDepth += 1;
             const r = e(i.key);
-            return e.memberDepth -= 1, G2.has(e(i.value)) ? console.error(`Prevented interpretation of property "${r}" which could lead to insecure code execution`) : n[r] = e(i.value), n
+            return e.memberDepth -= 1, xx.has(e(i.value)) ? console.error(`Prevented interpretation of property "${r}" which could lead to insecure code execution`) : n[r] = e(i.value), n
         }, {})
     };
 
-    function cf(e, t, n, i, r, s) {
-        const a = o => Fue[o.type](a, o);
-        return a.memberDepth = 0, a.fn = Object.create(t), a.params = n, a.datum = i, a.event = r, a.item = s, Oue.forEach(o => a.fn[o] = function() {
+    function Pf(e, t, n, i, r, s) {
+        const a = o => Vle[o.type](a, o);
+        return a.memberDepth = 0, a.fn = Object.create(t), a.params = n, a.datum = i, a.event = r, a.item = s, Xle.forEach(o => a.fn[o] = function() {
             return r.vega[o](...arguments)
         }), a(e)
     }
-    var Rue = {
+    var Kle = {
         operator(e, t) {
             const n = t.ast,
                 i = e.functions;
-            return r => cf(n, i, r)
+            return r => Pf(n, i, r)
         },
         parameter(e, t) {
             const n = t.ast,
                 i = e.functions;
-            return (r, s) => cf(n, i, s, r)
+            return (r, s) => Pf(n, i, s, r)
         },
         event(e, t) {
             const n = t.ast,
                 i = e.functions;
-            return r => cf(n, i, void 0, void 0, r)
+            return r => Pf(n, i, void 0, void 0, r)
         },
         handler(e, t) {
             const n = t.ast,
                 i = e.functions;
             return (r, s) => {
                 const a = s.item && s.item.datum;
-                return cf(n, i, r, a, s)
+                return Pf(n, i, r, a, s)
             }
         },
         encode(e, t) {
             const {
                 marktype: n,
                 channels: i
             } = t, r = e.functions, s = n === "group" || n === "image" || n === "rect";
             return (a, o) => {
                 const l = a.datum;
                 let u = 0,
                     c;
-                for (const f in i) c = cf(i[f].ast, r, o, l, void 0, a), a[f] !== c && (a[f] = c, u = 1);
-                return n !== "rule" && Eue(a, i, s), u
+                for (const f in i) c = Pf(i[f].ast, r, o, l, void 0, a), a[f] !== c && (a[f] = c, u = 1);
+                return n !== "rule" && jle(a, i, s), u
             }
         }
     };
-    const Due = "vega-lite",
-        Nue = 'Dominik Moritz, Kanit "Ham" Wongsuphasawat, Arvind Satyanarayan, Jeffrey Heer',
-        Pue = "5.9.3",
-        Lue = ["Kanit Wongsuphasawat (http://kanitw.yellowpigz.com)", "Dominik Moritz (https://www.domoritz.de)", "Arvind Satyanarayan (https://arvindsatya.com)", "Jeffrey Heer (https://jheer.org)"],
-        Iue = "https://vega.github.io/vega-lite/",
-        zue = "Vega-Lite is a concise high-level language for interactive visualization.",
-        Bue = ["vega", "chart", "visualization"],
-        jue = "build/vega-lite.js",
-        Uue = "build/vega-lite.min.js",
-        Gue = "build/vega-lite.min.js",
-        Wue = "build/src/index",
-        que = "build/src/index.d.ts",
-        Hue = {
+    const Jle = "vega-lite",
+        Qle = 'Dominik Moritz, Kanit "Ham" Wongsuphasawat, Arvind Satyanarayan, Jeffrey Heer',
+        Zle = "5.13.0",
+        eue = ["Kanit Wongsuphasawat (http://kanitw.yellowpigz.com)", "Dominik Moritz (https://www.domoritz.de)", "Arvind Satyanarayan (https://arvindsatya.com)", "Jeffrey Heer (https://jheer.org)"],
+        tue = "https://vega.github.io/vega-lite/",
+        nue = "Vega-Lite is a concise high-level language for interactive visualization.",
+        iue = ["vega", "chart", "visualization"],
+        rue = "build/vega-lite.js",
+        sue = "build/vega-lite.min.js",
+        aue = "build/vega-lite.min.js",
+        oue = "build/src/index",
+        lue = "build/src/index.d.ts",
+        uue = {
             vl2pdf: "./bin/vl2pdf",
             vl2png: "./bin/vl2png",
             vl2svg: "./bin/vl2svg",
             vl2vg: "./bin/vl2vg"
         },
-        Yue = ["bin", "build", "src", "vega-lite*", "tsconfig.json"],
-        Xue = {
+        cue = ["bin", "build", "src", "vega-lite*", "tsconfig.json"],
+        fue = {
             changelog: "conventional-changelog -p angular -r 2",
             prebuild: "yarn clean:build",
             build: "yarn build:only",
             "build:only": "tsc -p tsconfig.build.json && rollup -c",
             "prebuild:examples": "yarn build:only",
             "build:examples": "yarn data && TZ=America/Los_Angeles scripts/build-examples.sh",
             "prebuild:examples-full": "yarn build:only",
@@ -35817,24 +29055,25 @@
             "test:runtime:generate": "yarn build:only && del-cli test-runtime/resources && VL_GENERATE_TESTS=true yarn test:runtime",
             watch: "tsc -p tsconfig.build.json -w",
             "watch:site": "yarn build:site -w",
             "watch:test": "yarn jest --watch test/",
             "watch:test:runtime": "NODE_OPTIONS=--experimental-vm-modules TZ=America/Los_Angeles npx jest --watch test-runtime/ --config test-runtime/jest-config.json",
             release: "release-it"
         },
-        Vue = {
+        hue = {
             type: "git",
             url: "https://github.com/vega/vega-lite.git"
         },
-        Kue = "BSD-3-Clause",
-        Jue = {
+        due = "BSD-3-Clause",
+        gue = {
             url: "https://github.com/vega/vega-lite/issues"
         },
-        Que = {
+        pue = {
             "@babel/core": "^7.21.8",
+            "@babel/plugin-proposal-class-properties": "^7.18.6",
             "@babel/preset-env": "^7.21.5",
             "@babel/preset-typescript": "^7.21.5",
             "@release-it/conventional-changelog": "^5.1.1",
             "@rollup/plugin-alias": "^5.0.0",
             "@rollup/plugin-babel": "^6.0.3",
             "@rollup/plugin-commonjs": "^25.0.0",
             "@rollup/plugin-json": "^6.0.0",
@@ -35842,90 +29081,90 @@
             "@rollup/plugin-terser": "^0.4.1",
             "@types/chai": "^4.3.5",
             "@types/d3": "^7.4.0",
             "@types/jest": "^27.4.1",
             "@types/pako": "^2.0.0",
             "@typescript-eslint/eslint-plugin": "^5.59.5",
             "@typescript-eslint/parser": "^5.59.5",
-            "ajv-formats": "^2.1.1",
             ajv: "^8.12.0",
+            "ajv-formats": "^2.1.1",
             chai: "^4.3.7",
             cheerio: "^1.0.0-rc.12",
-            "conventional-changelog-cli": "^2.2.2",
+            "conventional-changelog-cli": "^3.0.0",
             d3: "^7.8.4",
             "del-cli": "^5.0.0",
+            eslint: "^8.40.0",
             "eslint-config-prettier": "^8.8.0",
             "eslint-plugin-jest": "^27.2.1",
             "eslint-plugin-prettier": "^4.2.1",
-            eslint: "^8.40.0",
             "highlight.js": "^11.8.0",
-            "jest-dev-server": "^6.1.1",
             jest: "^27.5.1",
+            "jest-dev-server": "^6.1.1",
             mkdirp: "^3.0.1",
             pako: "^2.1.0",
             prettier: "^2.8.8",
             puppeteer: "^15.0.0",
             "release-it": "^15.10.3",
+            rollup: "^3.21.6",
             "rollup-plugin-bundle-size": "^1.0.3",
             "rollup-plugin-sourcemaps": "^0.6.3",
-            rollup: "^3.21.6",
             serve: "^14.2.0",
             terser: "^5.17.3",
             "ts-jest": "^29.1.0",
             "ts-json-schema-generator": "^1.2.0",
             typescript: "~4.9.5",
             "vega-cli": "^5.25.0",
             "vega-datasets": "^2.7.0",
             "vega-embed": "^6.22.1",
             "vega-tooltip": "^0.32.0",
             "yaml-front-matter": "^4.1.1"
         },
-        Zue = {
+        mue = {
             "@types/clone": "~2.1.1",
             clone: "~2.1.2",
             "fast-deep-equal": "~3.1.3",
             "fast-json-stable-stringify": "~2.1.0",
             "json-stringify-pretty-compact": "~3.0.0",
             tslib: "~2.5.0",
             "vega-event-selector": "~3.0.1",
             "vega-expression": "~5.1.0",
             "vega-util": "~1.17.2",
             yargs: "~17.7.2"
         },
-        ece = {
+        yue = {
             vega: "^5.24.0"
         },
-        tce = {
+        vue = {
             node: ">=16"
         },
-        nce = {
-            name: Due,
-            author: Nue,
-            version: Pue,
-            collaborators: Lue,
-            homepage: Iue,
-            description: zue,
-            keywords: Bue,
-            main: jue,
-            unpkg: Uue,
-            jsdelivr: Gue,
-            module: Wue,
-            types: que,
-            bin: Hue,
-            files: Yue,
-            scripts: Xue,
-            repository: Vue,
-            license: Kue,
-            bugs: Jue,
-            devDependencies: Que,
-            dependencies: Zue,
-            peerDependencies: ece,
-            engines: tce
+        bue = {
+            name: Jle,
+            author: Qle,
+            version: Zle,
+            collaborators: eue,
+            homepage: tue,
+            description: nue,
+            keywords: iue,
+            main: rue,
+            unpkg: sue,
+            jsdelivr: aue,
+            module: oue,
+            types: lue,
+            bin: uue,
+            files: cue,
+            scripts: fue,
+            repository: hue,
+            license: due,
+            bugs: gue,
+            devDependencies: pue,
+            dependencies: mue,
+            peerDependencies: yue,
+            engines: vue
         };
-    var cI = {
+    var HI = {
         exports: {}
     };
     (function(e) {
         var t = function() {
             function n(h, d) {
                 return d != null && h instanceof d
             }
@@ -35958,58 +29197,58 @@
                 function x(_, S) {
                     if (_ === null) return null;
                     if (S === 0) return _;
                     var w, E;
                     if (typeof _ != "object") return _;
                     if (n(_, i)) w = new i;
                     else if (n(_, r)) w = new r;
-                    else if (n(_, s)) w = new s(function(N, P) {
-                        _.then(function(z) {
-                            N(x(z, S - 1))
-                        }, function(z) {
-                            P(x(z, S - 1))
+                    else if (n(_, s)) w = new s(function(N, L) {
+                        _.then(function(I) {
+                            N(x(I, S - 1))
+                        }, function(I) {
+                            L(x(I, S - 1))
                         })
                     });
                     else if (a.__isArray(_)) w = [];
                     else if (a.__isRegExp(_)) w = new RegExp(_.source, f(_)), _.lastIndex && (w.lastIndex = _.lastIndex);
                     else if (a.__isDate(_)) w = new Date(_.getTime());
                     else {
                         if (b && Buffer.isBuffer(_)) return Buffer.allocUnsafe ? w = Buffer.allocUnsafe(_.length) : w = new Buffer(_.length), _.copy(w), w;
                         n(_, Error) ? w = Object.create(_) : typeof p > "u" ? (E = Object.getPrototypeOf(_), w = Object.create(E)) : (w = Object.create(p), E = p)
                     }
                     if (d) {
-                        var A = y.indexOf(_);
-                        if (A != -1) return v[A];
+                        var C = y.indexOf(_);
+                        if (C != -1) return v[C];
                         y.push(_), v.push(w)
                     }
-                    n(_, i) && _.forEach(function(N, P) {
-                        var z = x(P, S - 1),
-                            I = x(N, S - 1);
-                        w.set(z, I)
+                    n(_, i) && _.forEach(function(N, L) {
+                        var I = x(L, S - 1),
+                            G = x(N, S - 1);
+                        w.set(I, G)
                     }), n(_, r) && _.forEach(function(N) {
-                        var P = x(N, S - 1);
-                        w.add(P)
+                        var L = x(N, S - 1);
+                        w.add(L)
                     });
-                    for (var C in _) {
-                        var k;
-                        E && (k = Object.getOwnPropertyDescriptor(E, C)), !(k && k.set == null) && (w[C] = x(_[C], S - 1))
+                    for (var k in _) {
+                        var A;
+                        E && (A = Object.getOwnPropertyDescriptor(E, k)), !(A && A.set == null) && (w[k] = x(_[k], S - 1))
                     }
                     if (Object.getOwnPropertySymbols)
-                        for (var R = Object.getOwnPropertySymbols(_), C = 0; C < R.length; C++) {
-                            var $ = R[C],
+                        for (var F = Object.getOwnPropertySymbols(_), k = 0; k < F.length; k++) {
+                            var $ = F[k],
                                 T = Object.getOwnPropertyDescriptor(_, $);
                             T && !T.enumerable && !m || (w[$] = x(_[$], S - 1), T.enumerable || Object.defineProperty(w, $, {
                                 enumerable: !1
                             }))
                         }
                     if (m)
-                        for (var M = Object.getOwnPropertyNames(_), C = 0; C < M.length; C++) {
-                            var F = M[C],
-                                T = Object.getOwnPropertyDescriptor(_, F);
-                            T && T.enumerable || (w[F] = x(_[F], S - 1), Object.defineProperty(w, F, {
+                        for (var M = Object.getOwnPropertyNames(_), k = 0; k < M.length; k++) {
+                            var R = M[k],
+                                T = Object.getOwnPropertyDescriptor(_, R);
+                            T && T.enumerable || (w[R] = x(_[R], S - 1), Object.defineProperty(w, R, {
                                 enumerable: !1
                             }))
                         }
                     return w
                 }
                 return x(h, g)
             }
@@ -36042,18 +29281,18 @@
             function f(h) {
                 var d = "";
                 return h.global && (d += "g"), h.ignoreCase && (d += "i"), h.multiline && (d += "m"), d
             }
             return a.__getRegExpFlags = f, a
         }();
         e.exports && (e.exports = t)
-    })(cI);
-    var ice = cI.exports;
-    const rce = Cm(ice);
-    var sce = function e(t, n) {
+    })(HI);
+    var xue = HI.exports;
+    const _ue = Ed(xue);
+    var wue = function e(t, n) {
         if (t === n) return !0;
         if (t && n && typeof t == "object" && typeof n == "object") {
             if (t.constructor !== n.constructor) return !1;
             var i, r, s;
             if (Array.isArray(t)) {
                 if (i = t.length, i != n.length) return !1;
                 for (r = i; r-- !== 0;)
@@ -36070,16 +29309,16 @@
                 var a = s[r];
                 if (!e(t[a], n[a])) return !1
             }
             return !0
         }
         return t !== t && n !== n
     };
-    const fI = Cm(sce);
-    var ace = function(e, t) {
+    const YI = Ed(wue);
+    var Sue = function(e, t) {
         t || (t = {}), typeof t == "function" && (t = {
             cmp: t
         });
         var n = typeof t.cycles == "boolean" ? t.cycles : !1,
             i = t.cmp && function(s) {
                 return function(a) {
                     return function(o, l) {
@@ -36117,332 +29356,332 @@
                         h = s(a[f]);
                     h && (l && (l += ","), l += JSON.stringify(f) + ":" + h)
                 }
                 return r.splice(u, 1), "{" + l + "}"
             }
         }(e)
     };
-    const pE = Cm(ace);
+    const rk = Ed(Sue);
 
-    function mE(e) {
+    function sk(e) {
         return !!e.or
     }
 
-    function yE(e) {
+    function ak(e) {
         return !!e.and
     }
 
-    function vE(e) {
+    function ok(e) {
         return !!e.not
     }
 
-    function gp(e, t) {
-        if (vE(e)) gp(e.not, t);
-        else if (yE(e))
-            for (const n of e.and) gp(n, t);
-        else if (mE(e))
-            for (const n of e.or) gp(n, t);
+    function Wp(e, t) {
+        if (ok(e)) Wp(e.not, t);
+        else if (ak(e))
+            for (const n of e.and) Wp(n, t);
+        else if (sk(e))
+            for (const n of e.or) Wp(n, t);
         else t(e)
     }
 
-    function Eu(e, t) {
-        return vE(e) ? {
-            not: Eu(e.not, t)
-        } : yE(e) ? {
-            and: e.and.map(n => Eu(n, t))
-        } : mE(e) ? {
-            or: e.or.map(n => Eu(n, t))
+    function Vu(e, t) {
+        return ok(e) ? {
+            not: Vu(e.not, t)
+        } : ak(e) ? {
+            and: e.and.map(n => Vu(n, t))
+        } : sk(e) ? {
+            or: e.or.map(n => Vu(n, t))
         } : t(e)
     }
-    const Nr = fI,
-        ke = rce;
+    const Jr = YI,
+        Fe = _ue;
 
-    function hI(e) {
+    function XI(e) {
         throw new Error(e)
     }
 
-    function Qu(e, t) {
+    function Ec(e, t) {
         const n = {};
-        for (const i of t) me(e, i) && (n[i] = e[i]);
+        for (const i of t) Ce(e, i) && (n[i] = e[i]);
         return n
     }
 
-    function Jn(e, t) {
+    function li(e, t) {
         const n = {
             ...e
         };
         for (const i of t) delete n[i];
         return n
     }
     Set.prototype.toJSON = function() {
-        return `Set(${[...this].map(e=>pE(e)).join(",")})`
+        return `Set(${[...this].map(e=>rk(e)).join(",")})`
     };
-    const at = pE;
+    const mt = rk;
 
-    function Ne(e) {
-        if (Ze(e)) return e;
-        const t = re(e) ? e : pE(e);
+    function ze(e) {
+        if (lt(e)) return e;
+        const t = le(e) ? e : rk(e);
         if (t.length < 250) return t;
         let n = 0;
         for (let i = 0; i < t.length; i++) {
             const r = t.charCodeAt(i);
             n = (n << 5) - n + r, n = n & n
         }
         return n
     }
 
-    function W2(e) {
+    function _x(e) {
         return e === !1 || e === null
     }
 
-    function Fe(e, t) {
+    function Be(e, t) {
         return e.includes(t)
     }
 
-    function ol(e, t) {
+    function Fl(e, t) {
         let n = 0;
         for (const [i, r] of e.entries())
             if (t(r, i, n++)) return !0;
         return !1
     }
 
-    function bE(e, t) {
+    function lk(e, t) {
         let n = 0;
         for (const [i, r] of e.entries())
             if (!t(r, i, n++)) return !1;
         return !0
     }
 
-    function dI(e, ...t) {
-        for (const n of t) oce(e, n ?? {});
+    function VI(e, ...t) {
+        for (const n of t) Eue(e, n ?? {});
         return e
     }
 
-    function oce(e, t) {
-        for (const n of H(t)) xc(e, n, t[n], !0)
+    function Eue(e, t) {
+        for (const n of K(t)) Gc(e, n, t[n], !0)
     }
 
-    function Pr(e, t) {
+    function Qr(e, t) {
         const n = [],
             i = {};
         let r;
         for (const s of e) r = t(s), !(r in i) && (i[r] = 1, n.push(s));
         return n
     }
 
-    function lce(e, t) {
-        const n = H(e),
-            i = H(t);
+    function kue(e, t) {
+        const n = K(e),
+            i = K(t);
         if (n.length !== i.length) return !1;
         for (const r of n)
             if (e[r] !== t[r]) return !1;
         return !0
     }
 
-    function gI(e, t) {
+    function KI(e, t) {
         if (e.size !== t.size) return !1;
         for (const n of e)
             if (!t.has(n)) return !1;
         return !0
     }
 
-    function xE(e, t) {
+    function uk(e, t) {
         for (const n of e)
             if (t.has(n)) return !0;
         return !1
     }
 
-    function q2(e) {
+    function wx(e) {
         const t = new Set;
         for (const n of e) {
-            const r = ns(n).map((a, o) => o === 0 ? a : `[${a}]`),
+            const r = gs(n).map((a, o) => o === 0 ? a : `[${a}]`),
                 s = r.map((a, o) => r.slice(0, o + 1).join(""));
             for (const a of s) t.add(a)
         }
         return t
     }
 
-    function _E(e, t) {
-        return e === void 0 || t === void 0 ? !0 : xE(q2(e), q2(t))
+    function ck(e, t) {
+        return e === void 0 || t === void 0 ? !0 : uk(wx(e), wx(t))
     }
 
-    function et(e) {
-        return H(e).length === 0
+    function ft(e) {
+        return K(e).length === 0
     }
-    const H = Object.keys,
-        Qt = Object.values,
-        Ba = Object.entries;
+    const K = Object.keys,
+        bn = Object.values,
+        lo = Object.entries;
 
-    function Ih(e) {
+    function dd(e) {
         return e === !0 || e === !1
     }
 
-    function ft(e) {
+    function Et(e) {
         const t = e.replace(/\W/g, "_");
         return (e.match(/^\d+/) ? "_" : "") + t
     }
 
-    function oh(e, t) {
-        return vE(e) ? `!(${oh(e.not,t)})` : yE(e) ? `(${e.and.map(n=>oh(n,t)).join(") && (")})` : mE(e) ? `(${e.or.map(n=>oh(n,t)).join(") || (")})` : t(e)
+    function Nh(e, t) {
+        return ok(e) ? `!(${Nh(e.not,t)})` : ak(e) ? `(${e.and.map(n=>Nh(n,t)).join(") && (")})` : sk(e) ? `(${e.or.map(n=>Nh(n,t)).join(") || (")})` : t(e)
     }
 
-    function N0(e, t) {
+    function m0(e, t) {
         if (t.length === 0) return !0;
         const n = t.shift();
-        return n in e && N0(e[n], t) && delete e[n], et(e)
+        return n in e && m0(e[n], t) && delete e[n], ft(e)
     }
 
-    function $d(e) {
+    function ig(e) {
         return e.charAt(0).toUpperCase() + e.substr(1)
     }
 
-    function wE(e, t = "datum") {
-        const n = ns(e),
+    function fk(e, t = "datum") {
+        const n = gs(e),
             i = [];
         for (let r = 1; r <= n.length; r++) {
-            const s = `[${n.slice(0,r).map(Z).join("][")}]`;
+            const s = `[${n.slice(0,r).map(te).join("][")}]`;
             i.push(`${t}${s}`)
         }
         return i.join(" && ")
     }
 
-    function pI(e, t = "datum") {
-        return `${t}[${Z(ns(e).join("."))}]`
+    function JI(e, t = "datum") {
+        return `${t}[${te(gs(e).join("."))}]`
     }
 
-    function uce(e) {
+    function Cue(e) {
         return e.replace(/(\[|\]|\.|'|")/g, "\\$1")
     }
 
-    function Pi(e) {
-        return `${ns(e).map(uce).join("\\.")}`
+    function Ji(e) {
+        return `${gs(e).map(Cue).join("\\.")}`
     }
 
-    function ll(e, t, n) {
+    function Rl(e, t, n) {
         return e.replace(new RegExp(t.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&"), "g"), n)
     }
 
-    function SE(e) {
-        return `${ns(e).join(".")}`
+    function hk(e) {
+        return `${gs(e).join(".")}`
     }
 
-    function Zu(e) {
-        return e ? ns(e).length : 0
+    function kc(e) {
+        return e ? gs(e).length : 0
     }
 
-    function Ct(...e) {
+    function Gt(...e) {
         for (const t of e)
             if (t !== void 0) return t
     }
-    let mI = 42;
+    let QI = 42;
 
-    function yI(e) {
-        const t = ++mI;
+    function ZI(e) {
+        const t = ++QI;
         return e ? String(e) + t : t
     }
 
-    function cce() {
-        mI = 42
+    function Aue() {
+        QI = 42
     }
 
-    function vI(e) {
-        return bI(e) ? e : `__${e}`
+    function e6(e) {
+        return t6(e) ? e : `__${e}`
     }
 
-    function bI(e) {
+    function t6(e) {
         return e.startsWith("__")
     }
 
-    function zh(e) {
+    function gd(e) {
         if (e !== void 0) return (e % 360 + 360) % 360
     }
 
-    function x1(e) {
-        return Ze(e) ? !0 : !isNaN(e) && !isNaN(parseFloat(e))
+    function Q1(e) {
+        return lt(e) ? !0 : !isNaN(e) && !isNaN(parseFloat(e))
     }
-    const Fs = "row",
-        Rs = "column",
-        _1 = "facet",
-        ht = "x",
-        Gt = "y",
-        xr = "x2",
-        as = "y2",
-        no = "xOffset",
-        Mc = "yOffset",
-        _r = "radius",
-        Xs = "radius2",
-        zi = "theta",
-        Vs = "theta2",
-        wr = "latitude",
-        Sr = "longitude",
-        Er = "latitude2",
-        Li = "longitude2",
-        si = "color",
-        os = "fill",
-        ls = "stroke",
-        ai = "shape",
-        Ks = "size",
-        Dl = "angle",
-        Js = "opacity",
-        io = "fillOpacity",
-        ro = "strokeOpacity",
-        so = "strokeWidth",
-        ao = "strokeDash",
-        Td = "text",
-        ec = "order",
-        Md = "detail",
-        w1 = "key",
-        ul = "tooltip",
-        S1 = "href",
-        E1 = "url",
-        C1 = "description",
-        fce = {
+    const Vs = "row",
+        Ks = "column",
+        Z1 = "facet",
+        kt = "x",
+        un = "y",
+        Dr = "x2",
+        xs = "y2",
+        So = "xOffset",
+        nf = "yOffset",
+        Nr = "radius",
+        la = "radius2",
+        nr = "theta",
+        ua = "theta2",
+        Pr = "latitude",
+        Lr = "longitude",
+        Ir = "latitude2",
+        Qi = "longitude2",
+        pi = "color",
+        _s = "fill",
+        ws = "stroke",
+        mi = "shape",
+        ca = "size",
+        eu = "angle",
+        fa = "opacity",
+        Eo = "fillOpacity",
+        ko = "strokeOpacity",
+        Co = "strokeWidth",
+        Ao = "strokeDash",
+        rg = "text",
+        Cc = "order",
+        sg = "detail",
+        ey = "key",
+        Dl = "tooltip",
+        ty = "href",
+        ny = "url",
+        iy = "description",
+        $ue = {
             x: 1,
             y: 1,
             x2: 1,
             y2: 1
         },
-        xI = {
+        n6 = {
             theta: 1,
             theta2: 1,
             radius: 1,
             radius2: 1
         };
 
-    function _I(e) {
-        return e in xI
+    function i6(e) {
+        return e in n6
     }
-    const EE = {
+    const dk = {
         longitude: 1,
         longitude2: 1,
         latitude: 1,
         latitude2: 1
     };
 
-    function wI(e) {
+    function r6(e) {
         switch (e) {
-            case wr:
+            case Pr:
                 return "y";
-            case Er:
+            case Ir:
                 return "y2";
-            case Sr:
+            case Lr:
                 return "x";
-            case Li:
+            case Qi:
                 return "x2"
         }
     }
 
-    function SI(e) {
-        return e in EE
+    function s6(e) {
+        return e in dk
     }
-    const hce = H(EE),
-        CE = {
-            ...fce,
-            ...xI,
-            ...EE,
+    const Tue = K(dk),
+        gk = {
+            ...$ue,
+            ...n6,
+            ...dk,
             xOffset: 1,
             yOffset: 1,
             color: 1,
             fill: 1,
             stroke: 1,
             opacity: 1,
             fillOpacity: 1,
@@ -36458,246 +29697,246 @@
             key: 1,
             tooltip: 1,
             href: 1,
             url: 1,
             description: 1
         };
 
-    function Cu(e) {
-        return e === si || e === os || e === ls
+    function Ku(e) {
+        return e === pi || e === _s || e === ws
     }
-    const EI = {
+    const a6 = {
             row: 1,
             column: 1,
             facet: 1
         },
-        Ti = H(EI),
-        kE = {
-            ...CE,
-            ...EI
+        Ui = K(a6),
+        pk = {
+            ...gk,
+            ...a6
         },
-        dce = H(kE),
+        Mue = K(pk),
         {
-            order: Jbe,
-            detail: Qbe,
-            tooltip: Zbe,
-            ...gce
-        } = kE,
+            order: F_e,
+            detail: R_e,
+            tooltip: D_e,
+            ...Oue
+        } = pk,
         {
-            row: e2e,
-            column: t2e,
-            facet: n2e,
-            ...pce
-        } = gce;
+            row: N_e,
+            column: P_e,
+            facet: L_e,
+            ...Fue
+        } = Oue;
 
-    function mce(e) {
-        return !!pce[e]
+    function Rue(e) {
+        return !!Fue[e]
     }
 
-    function CI(e) {
-        return !!kE[e]
+    function o6(e) {
+        return !!pk[e]
     }
-    const yce = [xr, as, Er, Li, Vs, Xs];
+    const Due = [Dr, xs, Ir, Qi, ua, la];
 
-    function kI(e) {
-        return Nl(e) !== e
+    function l6(e) {
+        return tu(e) !== e
     }
 
-    function Nl(e) {
+    function tu(e) {
         switch (e) {
-            case xr:
-                return ht;
-            case as:
-                return Gt;
-            case Er:
-                return wr;
-            case Li:
-                return Sr;
-            case Vs:
-                return zi;
-            case Xs:
-                return _r
+            case Dr:
+                return kt;
+            case xs:
+                return un;
+            case Ir:
+                return Pr;
+            case Qi:
+                return Lr;
+            case ua:
+                return nr;
+            case la:
+                return Nr
         }
         return e
     }
 
-    function ja(e) {
-        if (_I(e)) switch (e) {
-            case zi:
+    function uo(e) {
+        if (i6(e)) switch (e) {
+            case nr:
                 return "startAngle";
-            case Vs:
+            case ua:
                 return "endAngle";
-            case _r:
+            case Nr:
                 return "outerRadius";
-            case Xs:
+            case la:
                 return "innerRadius"
         }
         return e
     }
 
-    function us(e) {
+    function Ss(e) {
         switch (e) {
-            case ht:
-                return xr;
-            case Gt:
-                return as;
-            case wr:
-                return Er;
-            case Sr:
-                return Li;
-            case zi:
-                return Vs;
-            case _r:
-                return Xs
+            case kt:
+                return Dr;
+            case un:
+                return xs;
+            case Pr:
+                return Ir;
+            case Lr:
+                return Qi;
+            case nr:
+                return ua;
+            case Nr:
+                return la
         }
     }
 
-    function oi(e) {
+    function yi(e) {
         switch (e) {
-            case ht:
-            case xr:
+            case kt:
+            case Dr:
                 return "width";
-            case Gt:
-            case as:
+            case un:
+            case xs:
                 return "height"
         }
     }
 
-    function AI(e) {
+    function u6(e) {
         switch (e) {
-            case ht:
+            case kt:
                 return "xOffset";
-            case Gt:
+            case un:
                 return "yOffset";
-            case xr:
+            case Dr:
                 return "x2Offset";
-            case as:
+            case xs:
                 return "y2Offset";
-            case zi:
+            case nr:
                 return "thetaOffset";
-            case _r:
+            case Nr:
                 return "radiusOffset";
-            case Vs:
+            case ua:
                 return "theta2Offset";
-            case Xs:
+            case la:
                 return "radius2Offset"
         }
     }
 
-    function AE(e) {
+    function mk(e) {
         switch (e) {
-            case ht:
+            case kt:
                 return "xOffset";
-            case Gt:
+            case un:
                 return "yOffset"
         }
     }
 
-    function $I(e) {
+    function c6(e) {
         switch (e) {
             case "xOffset":
                 return "x";
             case "yOffset":
                 return "y"
         }
     }
-    const vce = H(CE),
+    const Nue = K(gk),
         {
-            x: i2e,
-            y: r2e,
-            x2: s2e,
-            y2: a2e,
-            xOffset: o2e,
-            yOffset: l2e,
-            latitude: u2e,
-            longitude: c2e,
-            latitude2: f2e,
-            longitude2: h2e,
-            theta: d2e,
-            theta2: g2e,
-            radius: p2e,
-            radius2: m2e,
-            ...$E
-        } = CE,
-        bce = H($E),
-        TE = {
+            x: I_e,
+            y: z_e,
+            x2: B_e,
+            y2: j_e,
+            xOffset: G_e,
+            yOffset: U_e,
+            latitude: W_e,
+            longitude: q_e,
+            latitude2: H_e,
+            longitude2: Y_e,
+            theta: X_e,
+            theta2: V_e,
+            radius: K_e,
+            radius2: J_e,
+            ...yk
+        } = gk,
+        Pue = K(yk),
+        vk = {
             x: 1,
             y: 1
         },
-        cs = H(TE);
+        Es = K(vk);
 
-    function Wt(e) {
-        return e in TE
+    function cn(e) {
+        return e in vk
     }
-    const ME = {
+    const bk = {
             theta: 1,
             radius: 1
         },
-        xce = H(ME);
+        Lue = K(bk);
 
-    function k1(e) {
-        return e === "width" ? ht : Gt
+    function ry(e) {
+        return e === "width" ? kt : un
     }
-    const TI = {
+    const f6 = {
         xOffset: 1,
         yOffset: 1
     };
 
-    function Oc(e) {
-        return e in TI
+    function rf(e) {
+        return e in f6
     }
     const {
-        text: y2e,
-        tooltip: v2e,
-        href: b2e,
-        url: x2e,
-        description: _2e,
-        detail: w2e,
-        key: S2e,
-        order: E2e,
-        ...MI
-    } = $E, _ce = H(MI);
+        text: Q_e,
+        tooltip: Z_e,
+        href: ewe,
+        url: twe,
+        description: nwe,
+        detail: iwe,
+        key: rwe,
+        order: swe,
+        ...h6
+    } = yk, Iue = K(h6);
 
-    function wce(e) {
-        return !!$E[e]
+    function zue(e) {
+        return !!yk[e]
     }
 
-    function Sce(e) {
+    function Bue(e) {
         switch (e) {
-            case si:
-            case os:
-            case ls:
-            case Ks:
-            case ai:
-            case Js:
-            case so:
-            case ao:
+            case pi:
+            case _s:
+            case ws:
+            case ca:
+            case mi:
+            case fa:
+            case Co:
+            case Ao:
                 return !0;
-            case io:
-            case ro:
-            case Dl:
+            case Eo:
+            case ko:
+            case eu:
                 return !1
         }
     }
-    const OI = {
-            ...TE,
-            ...ME,
-            ...TI,
-            ...MI
+    const d6 = {
+            ...vk,
+            ...bk,
+            ...f6,
+            ...h6
         },
-        A1 = H(OI);
+        sy = K(d6);
 
-    function Qs(e) {
-        return !!OI[e]
+    function ha(e) {
+        return !!d6[e]
     }
 
-    function Ece(e, t) {
-        return kce(e)[t]
+    function jue(e, t) {
+        return Uue(e)[t]
     }
-    const FI = {
+    const g6 = {
             arc: "always",
             area: "always",
             bar: "always",
             circle: "always",
             geoshape: "always",
             image: "always",
             line: "always",
@@ -36706,136 +29945,136 @@
             rect: "always",
             square: "always",
             trail: "always",
             text: "always",
             tick: "always"
         },
         {
-            geoshape: C2e,
-            ...Cce
-        } = FI;
+            geoshape: awe,
+            ...Gue
+        } = g6;
 
-    function kce(e) {
+    function Uue(e) {
         switch (e) {
-            case si:
-            case os:
-            case ls:
-            case C1:
-            case Md:
-            case w1:
-            case ul:
-            case S1:
-            case ec:
-            case Js:
-            case io:
-            case ro:
-            case so:
-            case _1:
-            case Fs:
-            case Rs:
-                return FI;
-            case ht:
-            case Gt:
-            case no:
-            case Mc:
-            case wr:
-            case Sr:
-                return Cce;
-            case xr:
-            case as:
-            case Er:
-            case Li:
+            case pi:
+            case _s:
+            case ws:
+            case iy:
+            case sg:
+            case ey:
+            case Dl:
+            case ty:
+            case Cc:
+            case fa:
+            case Eo:
+            case ko:
+            case Co:
+            case Z1:
+            case Vs:
+            case Ks:
+                return g6;
+            case kt:
+            case un:
+            case So:
+            case nf:
+            case Pr:
+            case Lr:
+                return Gue;
+            case Dr:
+            case xs:
+            case Ir:
+            case Qi:
                 return {
                     area: "always", bar: "always", image: "always", rect: "always", rule: "always", circle: "binned", point: "binned", square: "binned", tick: "binned", line: "binned", trail: "binned"
                 };
-            case Ks:
+            case ca:
                 return {
                     point: "always", tick: "always", rule: "always", circle: "always", square: "always", bar: "always", text: "always", line: "always", trail: "always"
                 };
-            case ao:
+            case Ao:
                 return {
                     line: "always", point: "always", tick: "always", rule: "always", circle: "always", square: "always", bar: "always", geoshape: "always"
                 };
-            case ai:
+            case mi:
                 return {
                     point: "always", geoshape: "always"
                 };
-            case Td:
+            case rg:
                 return {
                     text: "always"
                 };
-            case Dl:
+            case eu:
                 return {
                     point: "always", square: "always", text: "always"
                 };
-            case E1:
+            case ny:
                 return {
                     image: "always"
                 };
-            case zi:
+            case nr:
                 return {
                     text: "always", arc: "always"
                 };
-            case _r:
+            case Nr:
                 return {
                     text: "always", arc: "always"
                 };
-            case Vs:
-            case Xs:
+            case ua:
+            case la:
                 return {
                     arc: "always"
                 }
         }
     }
 
-    function Cv(e) {
+    function eb(e) {
         switch (e) {
-            case ht:
-            case Gt:
-            case zi:
-            case _r:
-            case no:
-            case Mc:
+            case kt:
+            case un:
+            case nr:
+            case Nr:
+            case So:
+            case nf:
+            case ca:
+            case eu:
+            case Co:
+            case fa:
+            case Eo:
+            case ko:
+            case Dr:
+            case xs:
+            case ua:
+            case la:
+                return;
+            case Z1:
+            case Vs:
             case Ks:
+            case mi:
+            case Ao:
+            case rg:
             case Dl:
-            case so:
-            case Js:
-            case io:
-            case ro:
-            case xr:
-            case as:
-            case Vs:
-            case Xs:
-                return;
-            case _1:
-            case Fs:
-            case Rs:
-            case ai:
-            case ao:
-            case Td:
-            case ul:
-            case S1:
-            case E1:
-            case C1:
+            case ty:
+            case ny:
+            case iy:
                 return "discrete";
-            case si:
-            case os:
-            case ls:
+            case pi:
+            case _s:
+            case ws:
                 return "flexible";
-            case wr:
-            case Sr:
-            case Er:
-            case Li:
-            case Md:
-            case w1:
-            case ec:
+            case Pr:
+            case Lr:
+            case Ir:
+            case Qi:
+            case sg:
+            case ey:
+            case Cc:
                 return
         }
     }
-    const Ace = {
+    const Wue = {
             argmax: 1,
             argmin: 1,
             average: 1,
             count: 1,
             distinct: 1,
             product: 1,
             max: 1,
@@ -36852,96 +30091,96 @@
             stdevp: 1,
             sum: 1,
             valid: 1,
             values: 1,
             variance: 1,
             variancep: 1
         },
-        $ce = {
+        que = {
             count: 1,
             min: 1,
             max: 1
         };
 
-    function Bs(e) {
+    function na(e) {
         return !!e && !!e.argmin
     }
 
-    function oo(e) {
+    function $o(e) {
         return !!e && !!e.argmax
     }
 
-    function OE(e) {
-        return re(e) && !!Ace[e]
+    function xk(e) {
+        return le(e) && !!Wue[e]
     }
-    const Tce = new Set(["count", "valid", "missing", "distinct"]);
+    const Hue = new Set(["count", "valid", "missing", "distinct"]);
 
-    function RI(e) {
-        return re(e) && Tce.has(e)
+    function p6(e) {
+        return le(e) && Hue.has(e)
     }
 
-    function Mce(e) {
-        return re(e) && Fe(["min", "max"], e)
+    function Yue(e) {
+        return le(e) && Be(["min", "max"], e)
     }
-    const Oce = new Set(["count", "sum", "distinct", "valid", "missing"]),
-        Fce = new Set(["mean", "average", "median", "q1", "q3", "min", "max"]);
+    const Xue = new Set(["count", "sum", "distinct", "valid", "missing"]),
+        Vue = new Set(["mean", "average", "median", "q1", "q3", "min", "max"]);
 
-    function DI(e) {
-        return Za(e) && (e = z1(e, void 0)), "bin" + H(e).map(t => $1(e[t]) ? ft(`_${t}_${Ba(e[t])}`) : ft(`_${t}_${e[t]}`)).join("")
+    function m6(e) {
+        return mo(e) && (e = yy(e, void 0)), "bin" + K(e).map(t => ay(e[t]) ? Et(`_${t}_${lo(e[t])}`) : Et(`_${t}_${e[t]}`)).join("")
     }
 
-    function ot(e) {
-        return e === !0 || Pl(e) && !e.binned
+    function yt(e) {
+        return e === !0 || nu(e) && !e.binned
     }
 
-    function Xt(e) {
-        return e === "binned" || Pl(e) && e.binned === !0
+    function pn(e) {
+        return e === "binned" || nu(e) && e.binned === !0
     }
 
-    function Pl(e) {
-        return ae(e)
+    function nu(e) {
+        return ce(e)
     }
 
-    function $1(e) {
+    function ay(e) {
         return e == null ? void 0 : e.param
     }
 
-    function w5(e) {
+    function U5(e) {
         switch (e) {
-            case Fs:
-            case Rs:
+            case Vs:
             case Ks:
-            case si:
-            case os:
-            case ls:
-            case so:
-            case Js:
-            case io:
-            case ro:
-            case ai:
+            case ca:
+            case pi:
+            case _s:
+            case ws:
+            case Co:
+            case fa:
+            case Eo:
+            case ko:
+            case mi:
                 return 6;
-            case ao:
+            case Ao:
                 return 4;
             default:
                 return 10
         }
     }
 
-    function Fc(e) {
+    function ag(e) {
         return !!(e != null && e.expr)
     }
 
-    function Hn(e) {
-        const t = H(e || {}),
+    function ii(e) {
+        const t = K(e || {}),
             n = {};
-        for (const i of t) n[i] = di(e[i]);
+        for (const i of t) n[i] = Ci(e[i]);
         return n
     }
 
-    function NI(e) {
+    function y6(e) {
         const {
             anchor: t,
             frame: n,
             offset: i,
             orient: r,
             angle: s,
             limit: a,
@@ -36996,47 +30235,47 @@
             } : {},
             ...d ? {
                 subtitleLineHeight: d
             } : {},
             ...g ? {
                 subtitlePadding: g
             } : {}
-        }, b = Qu(e, ["align", "baseline", "dx", "dy", "limit"]);
+        }, b = Ec(e, ["align", "baseline", "dx", "dy", "limit"]);
         return {
             titleMarkConfig: m,
             subtitleMarkConfig: b,
             nonMarkTitleProperties: y,
             subtitle: v
         }
     }
 
-    function ca(e) {
-        return re(e) || W(e) && re(e[0])
+    function Ta(e) {
+        return le(e) || H(e) && le(e[0])
     }
 
-    function he(e) {
+    function xe(e) {
         return !!(e != null && e.signal)
     }
 
-    function lo(e) {
+    function To(e) {
         return !!e.step
     }
 
-    function Rce(e) {
-        return W(e) ? !1 : "fields" in e && !("data" in e)
+    function Kue(e) {
+        return H(e) ? !1 : "fields" in e && !("data" in e)
     }
 
-    function Dce(e) {
-        return W(e) ? !1 : "fields" in e && "data" in e
+    function Jue(e) {
+        return H(e) ? !1 : "fields" in e && "data" in e
     }
 
-    function $s(e) {
-        return W(e) ? !1 : "field" in e && "data" in e
+    function qs(e) {
+        return H(e) ? !1 : "field" in e && "data" in e
     }
-    const Nce = {
+    const Que = {
             aria: 1,
             description: 1,
             ariaRole: 1,
             ariaRoleDescription: 1,
             blend: 1,
             opacity: 1,
             fill: 1,
@@ -37087,825 +30326,869 @@
             cornerRadiusBottomRight: 1,
             aspect: 1,
             width: 1,
             height: 1,
             url: 1,
             smooth: 1
         },
-        Pce = H(Nce),
-        Lce = {
+        Zue = K(Que),
+        ece = {
             arc: 1,
             area: 1,
             group: 1,
             image: 1,
             line: 1,
             path: 1,
             rect: 1,
             rule: 1,
             shape: 1,
             symbol: 1,
             text: 1,
             trail: 1
         },
-        H2 = ["cornerRadius", "cornerRadiusTopLeft", "cornerRadiusTopRight", "cornerRadiusBottomLeft", "cornerRadiusBottomRight"];
+        Sx = ["cornerRadius", "cornerRadiusTopLeft", "cornerRadiusTopRight", "cornerRadiusBottomLeft", "cornerRadiusBottomRight"];
 
-    function PI(e) {
-        const t = W(e.condition) ? e.condition.map(S5) : S5(e.condition);
+    function v6(e) {
+        const t = H(e.condition) ? e.condition.map(W5) : W5(e.condition);
         return {
-            ...di(e),
+            ...Ci(e),
             condition: t
         }
     }
 
-    function di(e) {
-        if (Fc(e)) {
+    function Ci(e) {
+        if (ag(e)) {
             const {
                 expr: t,
                 ...n
             } = e;
             return {
                 signal: t,
                 ...n
             }
         }
         return e
     }
 
-    function S5(e) {
-        if (Fc(e)) {
+    function W5(e) {
+        if (ag(e)) {
             const {
                 expr: t,
                 ...n
             } = e;
             return {
                 signal: t,
                 ...n
             }
         }
         return e
     }
 
-    function ut(e) {
-        if (Fc(e)) {
+    function bt(e) {
+        if (ag(e)) {
             const {
                 expr: t,
                 ...n
             } = e;
             return {
                 signal: t,
                 ...n
             }
         }
-        return he(e) ? e : e !== void 0 ? {
+        return xe(e) ? e : e !== void 0 ? {
             value: e
         } : void 0
     }
 
-    function Ice(e) {
-        return he(e) ? e.signal : Z(e)
+    function tce(e) {
+        return xe(e) ? e.signal : te(e)
     }
 
-    function E5(e) {
-        return he(e) ? e.signal : Z(e.value)
+    function q5(e) {
+        return xe(e) ? e.signal : te(e.value)
     }
 
-    function Ds(e) {
-        return he(e) ? e.signal : e == null ? null : Z(e)
+    function br(e) {
+        return xe(e) ? e.signal : e == null ? null : te(e)
     }
 
-    function zce(e, t, n) {
+    function nce(e, t, n) {
         for (const i of n) {
-            const r = cl(i, t.markDef, t.config);
-            r !== void 0 && (e[i] = ut(r))
+            const r = ia(i, t.markDef, t.config);
+            r !== void 0 && (e[i] = bt(r))
         }
         return e
     }
 
-    function LI(e) {
+    function b6(e) {
         return [].concat(e.type, e.style ?? [])
     }
 
-    function Xe(e, t, n, i = {}) {
+    function st(e, t, n, i = {}) {
         const {
             vgChannel: r,
             ignoreVgConfig: s
         } = i;
-        return r && t[r] !== void 0 ? t[r] : t[e] !== void 0 ? t[e] : s && (!r || r === e) ? void 0 : cl(e, t, n, i)
+        return r && t[r] !== void 0 ? t[r] : t[e] !== void 0 ? t[e] : s && (!r || r === e) ? void 0 : ia(e, t, n, i)
     }
 
-    function cl(e, t, n, {
+    function ia(e, t, n, {
         vgChannel: i
     } = {}) {
-        return Ct(i ? P0(e, t, n.style) : void 0, P0(e, t, n.style), i ? n[t.type][i] : void 0, n[t.type][e], i ? n.mark[i] : n.mark[e])
+        return Gt(i ? y0(e, t, n.style) : void 0, y0(e, t, n.style), i ? n[t.type][i] : void 0, n[t.type][e], i ? n.mark[i] : n.mark[e])
     }
 
-    function P0(e, t, n) {
-        return II(e, LI(t), n)
+    function y0(e, t, n) {
+        return x6(e, b6(t), n)
     }
 
-    function II(e, t, n) {
-        t = se(t);
+    function x6(e, t, n) {
+        t = ue(t);
         let i;
         for (const r of t) {
             const s = n[r];
             s && s[e] !== void 0 && (i = s[e])
         }
         return i
     }
 
-    function zI(e, t) {
-        return se(e).reduce((n, i) => (n.field.push(ie(i, t)), n.order.push(i.sort ?? "ascending"), n), {
+    function _6(e, t) {
+        return ue(e).reduce((n, i) => (n.field.push(oe(i, t)), n.order.push(i.sort ?? "ascending"), n), {
             field: [],
             order: []
         })
     }
 
-    function BI(e, t) {
+    function w6(e, t) {
         const n = [...e];
         return t.forEach(i => {
             for (const r of n)
-                if (Nr(r, i)) return;
+                if (Jr(r, i)) return;
             n.push(i)
         }), n
     }
 
-    function jI(e, t) {
-        return Nr(e, t) || !t ? e : e ? [...se(e), ...se(t)].join(", ") : t
+    function S6(e, t) {
+        return Jr(e, t) || !t ? e : e ? [...ue(e), ...ue(t)].join(", ") : t
     }
 
-    function UI(e, t) {
+    function E6(e, t) {
         const n = e.value,
             i = t.value;
         if (n == null || i === null) return {
             explicit: e.explicit,
             value: null
         };
-        if ((ca(n) || he(n)) && (ca(i) || he(i))) return {
+        if ((Ta(n) || xe(n)) && (Ta(i) || xe(i))) return {
             explicit: e.explicit,
-            value: jI(n, i)
+            value: S6(n, i)
         };
-        if (ca(n) || he(n)) return {
+        if (Ta(n) || xe(n)) return {
             explicit: e.explicit,
             value: n
         };
-        if (ca(i) || he(i)) return {
+        if (Ta(i) || xe(i)) return {
             explicit: e.explicit,
             value: i
         };
-        if (!ca(n) && !he(n) && !ca(i) && !he(i)) return {
+        if (!Ta(n) && !xe(n) && !Ta(i) && !xe(i)) return {
             explicit: e.explicit,
-            value: BI(n, i)
+            value: w6(n, i)
         };
         throw new Error("It should never reach here")
     }
 
-    function FE(e) {
-        return `Invalid specification ${at(e)}. Make sure the specification includes at least one of the following properties: "mark", "layer", "facet", "hconcat", "vconcat", "concat", or "repeat".`
+    function _k(e) {
+        return `Invalid specification ${mt(e)}. Make sure the specification includes at least one of the following properties: "mark", "layer", "facet", "hconcat", "vconcat", "concat", or "repeat".`
     }
-    const Bce = 'Autosize "fit" only works for single views and layered views.';
+    const ice = 'Autosize "fit" only works for single views and layered views.';
 
-    function C5(e) {
+    function H5(e) {
         return `${e=="width"?"Width":"Height"} "container" only works for single views and layered views.`
     }
 
-    function k5(e) {
+    function Y5(e) {
         const t = e == "width" ? "Width" : "Height",
             n = e == "width" ? "x" : "y";
         return `${t} "container" only works well with autosize "fit" or "fit-${n}".`
     }
 
-    function A5(e) {
-        return e ? `Dropping "fit-${e}" because spec has discrete ${oi(e)}.` : 'Dropping "fit" because spec has discrete size.'
+    function X5(e) {
+        return e ? `Dropping "fit-${e}" because spec has discrete ${yi(e)}.` : 'Dropping "fit" because spec has discrete size.'
     }
 
-    function RE(e) {
+    function wk(e) {
         return `Unknown field for ${e}. Cannot calculate view size.`
     }
 
-    function $5(e) {
+    function V5(e) {
         return `Cannot project a selection on encoding channel "${e}", which has no field.`
     }
 
-    function jce(e, t) {
+    function rce(e, t) {
         return `Cannot project a selection on encoding channel "${e}" as it uses an aggregate function ("${t}").`
     }
 
-    function Uce(e) {
+    function sce(e) {
         return `The "nearest" transform is not supported for ${e} marks.`
     }
 
-    function GI(e) {
+    function k6(e) {
         return `Selection not supported for ${e} yet.`
     }
 
-    function Gce(e) {
+    function ace(e) {
         return `Cannot find a selection named "${e}".`
     }
-    const Wce = "Scale bindings are currently only supported for scales with unbinned, continuous domains.",
-        qce = "Legend bindings are only supported for selections over an individual field or encoding channel.";
+    const oce = "Scale bindings are currently only supported for scales with unbinned, continuous domains.",
+        lce = "Legend bindings are only supported for selections over an individual field or encoding channel.";
 
-    function Hce(e) {
+    function uce(e) {
         return `Lookups can only be performed on selection parameters. "${e}" is a variable parameter.`
     }
 
-    function Yce(e) {
+    function cce(e) {
         return `Cannot define and lookup the "${e}" selection in the same view. Try moving the lookup into a second, layered view?`
     }
-    const Xce = "The same selection must be used to override scale domains in a layered view.",
-        Vce = 'Interval selections should be initialized using "x", "y", "longitude", or "latitude" keys.';
+    const fce = "The same selection must be used to override scale domains in a layered view.",
+        hce = 'Interval selections should be initialized using "x", "y", "longitude", or "latitude" keys.';
 
-    function Kce(e) {
+    function dce(e) {
         return `Unknown repeated value "${e}".`
     }
 
-    function T5(e) {
+    function K5(e) {
         return `The "columns" property cannot be used when "${e}" has nested row/column.`
     }
-    const Jce = "Axes cannot be shared in concatenated or repeated views yet (https://github.com/vega/vega-lite/issues/2415).";
+    const gce = "Axes cannot be shared in concatenated or repeated views yet (https://github.com/vega/vega-lite/issues/2415).";
 
-    function Qce(e) {
+    function pce(e) {
         return `Unrecognized parse "${e}".`
     }
 
-    function M5(e, t, n) {
+    function J5(e, t, n) {
         return `An ancestor parsed field "${e}" as ${n} but a child wants to parse the field as ${t}.`
     }
-    const Zce = "Attempt to add the same child twice.";
+    const mce = "Attempt to add the same child twice.";
 
-    function efe(e) {
-        return `Ignoring an invalid transform: ${at(e)}.`
+    function yce(e) {
+        return `Ignoring an invalid transform: ${mt(e)}.`
     }
-    const tfe = 'If "from.fields" is not specified, "as" has to be a string that specifies the key to be used for the data from the secondary source.';
+    const vce = 'If "from.fields" is not specified, "as" has to be a string that specifies the key to be used for the data from the secondary source.';
 
-    function O5(e) {
+    function Q5(e) {
         return `Config.customFormatTypes is not true, thus custom format type and format for channel ${e} are dropped.`
     }
 
-    function nfe(e) {
+    function bce(e) {
         const {
             parentProjection: t,
             projection: n
         } = e;
-        return `Layer's shared projection ${at(t)} is overridden by a child projection ${at(n)}.`
+        return `Layer's shared projection ${mt(t)} is overridden by a child projection ${mt(n)}.`
     }
-    const ife = "Arc marks uses theta channel rather than angle, replacing angle with theta.";
+    const xce = "Arc marks uses theta channel rather than angle, replacing angle with theta.";
 
-    function rfe(e) {
+    function _ce(e) {
         return `${e}Offset dropped because ${e} is continuous`
     }
 
-    function sfe(e) {
+    function wce(e) {
         return `There is no ${e} encoding. Replacing ${e}Offset encoding as ${e}.`
     }
 
-    function afe(e, t, n) {
-        return `Channel ${e} is a ${t}. Converted to {value: ${at(n)}}.`
+    function Sce(e, t, n) {
+        return `Channel ${e} is a ${t}. Converted to {value: ${mt(n)}}.`
     }
 
-    function WI(e) {
+    function C6(e) {
         return `Invalid field type "${e}".`
     }
 
-    function ofe(e, t) {
+    function Ece(e, t) {
         return `Invalid field type "${e}" for aggregate: "${t}", using "quantitative" instead.`
     }
 
-    function lfe(e) {
+    function kce(e) {
         return `Invalid aggregation operator "${e}".`
     }
 
-    function qI(e, t) {
+    function A6(e, t) {
         const {
             fill: n,
             stroke: i
         } = t;
         return `Dropping color ${e} as the plot also has ${n&&i?"fill and stroke":n?"fill":"stroke"}.`
     }
 
-    function ufe(e) {
+    function Cce(e) {
         return `Position range does not support relative band size for ${e}.`
     }
 
-    function Y2(e, t) {
-        return `Dropping ${at(e)} from channel "${t}" since it does not contain any data field, datum, value, or signal.`
+    function Ex(e, t) {
+        return `Dropping ${mt(e)} from channel "${t}" since it does not contain any data field, datum, value, or signal.`
     }
-    const cfe = "Line marks cannot encode size with a non-groupby field. You may want to use trail marks instead.";
+    const Ace = "Line marks cannot encode size with a non-groupby field. You may want to use trail marks instead.";
 
-    function T1(e, t, n) {
+    function oy(e, t, n) {
         return `${e} dropped as it is incompatible with "${t}"${n?` when ${n}`:""}.`
     }
 
-    function ffe(e) {
+    function $ce(e) {
         return `${e} encoding has no scale, so specified scale is ignored.`
     }
 
-    function hfe(e) {
+    function Tce(e) {
         return `${e}-encoding is dropped as ${e} is not a valid encoding channel.`
     }
 
-    function dfe(e) {
+    function Mce(e) {
         return `${e} encoding should be discrete (ordinal / nominal / binned).`
     }
 
-    function gfe(e) {
+    function Oce(e) {
         return `${e} encoding should be discrete (ordinal / nominal / binned) or use a discretizing scale (e.g. threshold).`
     }
 
-    function pfe(e) {
+    function Fce(e) {
         return `Facet encoding dropped as ${e.join(" and ")} ${e.length>1?"are":"is"} also specified.`
     }
 
-    function kv(e, t) {
+    function tb(e, t) {
         return `Using discrete channel "${e}" to encode "${t}" field can be misleading as it does not encode ${t==="ordinal"?"order":"magnitude"}.`
     }
 
-    function mfe(e) {
+    function Rce(e) {
         return `The ${e} for range marks cannot be an expression`
     }
 
-    function yfe(e, t) {
+    function Dce(e, t) {
         return `Line mark is for continuous lines and thus cannot be used with ${e&&t?"x2 and y2":e?"x2":"y2"}. We will use the rule mark (line segments) instead.`
     }
 
-    function vfe(e, t) {
+    function Nce(e, t) {
         return `Specified orient "${e}" overridden with "${t}".`
     }
 
-    function bfe(e) {
+    function Pce(e) {
         return `Cannot use the scale property "${e}" with non-color channel.`
     }
 
-    function xfe(e) {
+    function Lce(e) {
         return `Cannot use the relative band size with ${e} scale.`
     }
 
-    function _fe(e) {
-        return `Using unaggregated domain with raw field has no effect (${at(e)}).`
+    function Ice(e) {
+        return `Using unaggregated domain with raw field has no effect (${mt(e)}).`
     }
 
-    function wfe(e) {
+    function zce(e) {
         return `Unaggregated domain not applicable for "${e}" since it produces values outside the origin domain of the source data.`
     }
 
-    function Sfe(e) {
-        return `Unaggregated domain is currently unsupported for log scale (${at(e)}).`
+    function Bce(e) {
+        return `Unaggregated domain is currently unsupported for log scale (${mt(e)}).`
     }
 
-    function Efe(e) {
+    function jce(e) {
         return `Cannot apply size to non-oriented mark "${e}".`
     }
 
-    function Cfe(e, t, n) {
+    function Gce(e, t, n) {
         return `Channel "${e}" does not work with "${t}" scale. We are using "${n}" scale instead.`
     }
 
-    function kfe(e, t) {
+    function Uce(e, t) {
         return `FieldDef does not work with "${e}" scale. We are using "${t}" scale instead.`
     }
 
-    function HI(e, t, n) {
+    function $6(e, t, n) {
         return `${n}-scale's "${t}" is dropped as it does not work with ${e} scale.`
     }
 
-    function YI(e) {
+    function T6(e) {
         return `The step for "${e}" is dropped because the ${e==="width"?"x":"y"} is continuous.`
     }
 
-    function Afe(e, t, n, i) {
-        return `Conflicting ${t.toString()} property "${e.toString()}" (${at(n)} and ${at(i)}). Using ${at(n)}.`
+    function Wce(e, t, n, i) {
+        return `Conflicting ${t.toString()} property "${e.toString()}" (${mt(n)} and ${mt(i)}). Using ${mt(n)}.`
     }
 
-    function $fe(e, t, n, i) {
-        return `Conflicting ${t.toString()} property "${e.toString()}" (${at(n)} and ${at(i)}). Using the union of the two domains.`
+    function qce(e, t, n, i) {
+        return `Conflicting ${t.toString()} property "${e.toString()}" (${mt(n)} and ${mt(i)}). Using the union of the two domains.`
     }
 
-    function Tfe(e) {
+    function Hce(e) {
         return `Setting the scale to be independent for "${e}" means we also have to set the guide (axis or legend) to be independent.`
     }
 
-    function Mfe(e) {
-        return `Dropping sort property ${at(e)} as unioned domains only support boolean or op "count", "min", and "max".`
+    function Yce(e) {
+        return `Dropping sort property ${mt(e)} as unioned domains only support boolean or op "count", "min", and "max".`
     }
-    const F5 = "Domains that should be unioned has conflicting sort properties. Sort will be set to true.",
-        Ofe = "Detected faceted independent scales that union domain of multiple fields from different data sources. We will use the first field. The result view size may be incorrect.",
-        Ffe = "Detected faceted independent scales that union domain of the same fields from different source. We will assume that this is the same field from a different fork of the same data source. However, if this is not the case, the result view size may be incorrect.",
-        Rfe = "Detected faceted independent scales that union domain of multiple fields from the same data source. We will use the first field. The result view size may be incorrect.";
+    const Z5 = "Domains that should be unioned has conflicting sort properties. Sort will be set to true.",
+        Xce = "Detected faceted independent scales that union domain of multiple fields from different data sources. We will use the first field. The result view size may be incorrect.",
+        Vce = "Detected faceted independent scales that union domain of the same fields from different source. We will assume that this is the same field from a different fork of the same data source. However, if this is not the case, the result view size may be incorrect.",
+        Kce = "Detected faceted independent scales that union domain of multiple fields from the same data source. We will use the first field. The result view size may be incorrect.";
 
-    function Dfe(e) {
+    function Jce(e) {
         return `Cannot stack "${e}" if there is already "${e}2".`
     }
 
-    function Nfe(e) {
+    function Qce(e) {
         return `Cannot stack non-linear scale (${e}).`
     }
 
-    function Pfe(e) {
+    function Zce(e) {
         return `Stacking is applied even though the aggregate function is non-summative ("${e}").`
     }
 
-    function L0(e, t) {
-        return `Invalid ${e}: ${at(t)}.`
+    function v0(e, t) {
+        return `Invalid ${e}: ${mt(t)}.`
     }
 
-    function Lfe(e) {
-        return `Dropping day from datetime ${at(e)} as day cannot be combined with other units.`
+    function efe(e) {
+        return `Dropping day from datetime ${mt(e)} as day cannot be combined with other units.`
     }
 
-    function Ife(e, t) {
+    function tfe(e, t) {
         return `${t?"extent ":""}${t&&e?"and ":""}${e?"center ":""}${t&&e?"are ":"is "}not needed when data are aggregated.`
     }
 
-    function zfe(e, t, n) {
+    function nfe(e, t, n) {
         return `${e} is not usually used with ${t} for ${n}.`
     }
 
-    function Bfe(e, t) {
+    function ife(e, t) {
         return `Continuous axis should not have customized aggregation function ${e}; ${t} already agregates the axis.`
     }
 
-    function R5(e) {
+    function eM(e) {
         return `1D error band does not support ${e}.`
     }
 
-    function XI(e) {
+    function M6(e) {
         return `Channel ${e} is required for "binned" bin.`
     }
 
-    function jfe(e) {
+    function rfe(e) {
         return `Channel ${e} should not be used with "binned" bin.`
     }
 
-    function Ufe(e) {
+    function sfe(e) {
         return `Domain for ${e} is required for threshold scale.`
     }
     globalThis && globalThis.__classPrivateFieldSet;
     globalThis && globalThis.__classPrivateFieldGet;
-    const VI = o_(a_);
-    let tc = VI;
+    const O6 = g_(d_);
+    let Ac = O6;
 
-    function Gfe(e) {
-        return tc = e, tc
+    function afe(e) {
+        return Ac = e, Ac
     }
 
-    function Wfe() {
-        return tc = VI, tc
+    function ofe() {
+        return Ac = O6, Ac
     }
 
-    function X(...e) {
-        tc.warn(...e)
+    function J(...e) {
+        Ac.warn(...e)
     }
 
-    function qfe(...e) {
-        tc.debug(...e)
+    function lfe(...e) {
+        Ac.debug(...e)
     }
 
-    function Ll(e) {
-        if (e && ae(e)) {
-            for (const t of NE)
+    function iu(e) {
+        if (e && ce(e)) {
+            for (const t of Ek)
                 if (t in e) return !0
         }
         return !1
     }
-    const KI = ["january", "february", "march", "april", "may", "june", "july", "august", "september", "october", "november", "december"],
-        Hfe = KI.map(e => e.substr(0, 3)),
-        JI = ["sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday"],
-        Yfe = JI.map(e => e.substr(0, 3));
-
-    function Xfe(e) {
-        if (x1(e) && (e = +e), Ze(e)) return e > 4 && X(L0("quarter", e)), e - 1;
-        throw new Error(L0("quarter", e))
+    const F6 = ["january", "february", "march", "april", "may", "june", "july", "august", "september", "october", "november", "december"],
+        ufe = F6.map(e => e.substr(0, 3)),
+        R6 = ["sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday"],
+        cfe = R6.map(e => e.substr(0, 3));
+
+    function ffe(e) {
+        if (Q1(e) && (e = +e), lt(e)) return e > 4 && J(v0("quarter", e)), e - 1;
+        throw new Error(v0("quarter", e))
     }
 
-    function Vfe(e) {
-        if (x1(e) && (e = +e), Ze(e)) return e - 1; {
+    function hfe(e) {
+        if (Q1(e) && (e = +e), lt(e)) return e - 1; {
             const t = e.toLowerCase(),
-                n = KI.indexOf(t);
+                n = F6.indexOf(t);
             if (n !== -1) return n;
             const i = t.substr(0, 3),
-                r = Hfe.indexOf(i);
+                r = ufe.indexOf(i);
             if (r !== -1) return r;
-            throw new Error(L0("month", e))
+            throw new Error(v0("month", e))
         }
     }
 
-    function Kfe(e) {
-        if (x1(e) && (e = +e), Ze(e)) return e % 7; {
+    function dfe(e) {
+        if (Q1(e) && (e = +e), lt(e)) return e % 7; {
             const t = e.toLowerCase(),
-                n = JI.indexOf(t);
+                n = R6.indexOf(t);
             if (n !== -1) return n;
             const i = t.substr(0, 3),
-                r = Yfe.indexOf(i);
+                r = cfe.indexOf(i);
             if (r !== -1) return r;
-            throw new Error(L0("day", e))
+            throw new Error(v0("day", e))
         }
     }
 
-    function DE(e, t) {
+    function Sk(e, t) {
         const n = [];
-        if (t && e.day !== void 0 && H(e).length > 1 && (X(Lfe(e)), e = ke(e), delete e.day), e.year !== void 0 ? n.push(e.year) : n.push(2012), e.month !== void 0) {
-            const i = t ? Vfe(e.month) : e.month;
+        if (t && e.day !== void 0 && K(e).length > 1 && (J(efe(e)), e = Fe(e), delete e.day), e.year !== void 0 ? n.push(e.year) : n.push(2012), e.month !== void 0) {
+            const i = t ? hfe(e.month) : e.month;
             n.push(i)
         } else if (e.quarter !== void 0) {
-            const i = t ? Xfe(e.quarter) : e.quarter;
-            n.push(Ze(i) ? i * 3 : `${i}*3`)
+            const i = t ? ffe(e.quarter) : e.quarter;
+            n.push(lt(i) ? i * 3 : `${i}*3`)
         } else n.push(0);
         if (e.date !== void 0) n.push(e.date);
         else if (e.day !== void 0) {
-            const i = t ? Kfe(e.day) : e.day;
-            n.push(Ze(i) ? i + 1 : `${i}+1`)
+            const i = t ? dfe(e.day) : e.day;
+            n.push(lt(i) ? i + 1 : `${i}+1`)
         } else n.push(1);
         for (const i of ["hours", "minutes", "seconds", "milliseconds"]) {
             const r = e[i];
             n.push(typeof r > "u" ? 0 : r)
         }
         return n
     }
 
-    function fl(e) {
-        const n = DE(e, !0).join(", ");
+    function Nl(e) {
+        const n = Sk(e, !0).join(", ");
         return e.utc ? `utc(${n})` : `datetime(${n})`
     }
 
-    function Jfe(e) {
-        const n = DE(e, !1).join(", ");
+    function gfe(e) {
+        const n = Sk(e, !1).join(", ");
         return e.utc ? `utc(${n})` : `datetime(${n})`
     }
 
-    function Qfe(e) {
-        const t = DE(e, !0);
+    function pfe(e) {
+        const t = Sk(e, !0);
         return e.utc ? +new Date(Date.UTC(...t)) : +new Date(...t)
     }
-    const QI = {
+    const D6 = {
             year: 1,
             quarter: 1,
             month: 1,
             week: 1,
             day: 1,
             dayofyear: 1,
             date: 1,
             hours: 1,
             minutes: 1,
             seconds: 1,
             milliseconds: 1
         },
-        NE = H(QI);
+        Ek = K(D6);
 
-    function Zfe(e) {
-        return !!QI[e]
+    function mfe(e) {
+        return !!D6[e]
     }
 
-    function PE(e) {
+    function ru(e) {
+        return ce(e) ? e.binned : N6(e)
+    }
+
+    function N6(e) {
+        return e && e.startsWith("binned")
+    }
+
+    function kk(e) {
         return e.startsWith("utc")
     }
 
-    function ehe(e) {
-        return e.substr(3)
+    function yfe(e) {
+        return e.substring(3)
     }
-    const the = {
+    const vfe = {
         "year-month": "%b %Y ",
         "year-month-date": "%b %d, %Y "
     };
 
-    function M1(e) {
-        return NE.filter(t => ZI(e, t))
+    function ly(e) {
+        return Ek.filter(t => L6(e, t))
     }
 
-    function nhe(e) {
-        const t = M1(e);
+    function P6(e) {
+        const t = ly(e);
         return t[t.length - 1]
     }
 
-    function ZI(e, t) {
+    function L6(e, t) {
         const n = e.indexOf(t);
         return !(n < 0 || n > 0 && t === "seconds" && e.charAt(n - 1) === "i" || e.length > n + 3 && t === "day" && e.charAt(n + 3) === "o" || n > 0 && t === "year" && e.charAt(n - 1) === "f")
     }
 
-    function ihe(e, t, {
+    function bfe(e, t, {
         end: n
     } = {
         end: !1
     }) {
-        const i = wE(t),
-            r = PE(e) ? "utc" : "";
+        const i = fk(t),
+            r = kk(e) ? "utc" : "";
 
         function s(l) {
             return l === "quarter" ? `(${r}quarter(${i})-1)` : `${r}${l}(${i})`
         }
         let a;
         const o = {};
-        for (const l of NE) ZI(e, l) && (o[l] = s(l), a = l);
-        return n && (o[a] += "+1"), Jfe(o)
+        for (const l of Ek) L6(e, l) && (o[l] = s(l), a = l);
+        return n && (o[a] += "+1"), gfe(o)
     }
 
-    function e6(e) {
+    function I6(e) {
         if (!e) return;
-        const t = M1(e);
-        return `timeUnitSpecifier(${at(t)}, ${at(the)})`
+        const t = ly(e);
+        return `timeUnitSpecifier(${mt(t)}, ${mt(vfe)})`
     }
 
-    function rhe(e, t, n) {
+    function xfe(e, t, n) {
         if (!e) return;
-        const i = e6(e);
-        return `${n||PE(e)?"utc":"time"}Format(${t}, ${i})`
+        const i = I6(e);
+        return `${n||kk(e)?"utc":"time"}Format(${t}, ${i})`
     }
 
-    function en(e) {
+    function an(e) {
         if (!e) return;
         let t;
-        return re(e) ? t = {
+        return le(e) ? N6(e) ? t = {
+            unit: e.substring(6),
+            binned: !0
+        } : t = {
             unit: e
-        } : ae(e) && (t = {
+        } : ce(e) && (t = {
             ...e,
             ...e.unit ? {
                 unit: e.unit
             } : {}
-        }), PE(t.unit) && (t.utc = !0, t.unit = ehe(t.unit)), t
+        }), kk(t.unit) && (t.utc = !0, t.unit = yfe(t.unit)), t
     }
 
-    function she(e) {
+    function _fe(e) {
         const {
             utc: t,
             ...n
-        } = en(e);
-        return n.unit ? (t ? "utc" : "") + H(n).map(i => ft(`${i==="unit"?"":`_${i}_`}${n[i]}`)).join("") : (t ? "utc" : "") + "timeunit" + H(n).map(i => ft(`_${i}_${n[i]}`)).join("")
+        } = an(e);
+        return n.unit ? (t ? "utc" : "") + K(n).map(i => Et(`${i==="unit"?"":`_${i}_`}${n[i]}`)).join("") : (t ? "utc" : "") + "timeunit" + K(n).map(i => Et(`_${i}_${n[i]}`)).join("")
     }
 
-    function t6(e, t = n => n) {
-        const n = en(e),
-            i = nhe(n.unit);
+    function z6(e, t = n => n) {
+        const n = an(e),
+            i = P6(n.unit);
         if (i && i !== "day") {
             const r = {
                     year: 2001,
                     month: 1,
                     date: 1,
                     hours: 0,
                     minutes: 0,
                     seconds: 0,
                     milliseconds: 0
                 },
-                s = n.step || 1,
-                a = {
+                {
+                    step: s,
+                    part: a
+                } = B6(i, n.step),
+                o = {
                     ...r,
-                    ...i === "quarter" ? {
-                        month: +r.month + s * 3
-                    } : i === "week" ? {
-                        date: +r.date + s * 7
-                    } : {
-                        [i]: +r[i] + s
-                    }
+                    [a]: +r[a] + s
                 };
-            return `${t(fl(a))} - ${t(fl(r))}`
+            return `${t(Nl(o))} - ${t(Nl(r))}`
         }
     }
+    const wfe = {
+        year: 1,
+        month: 1,
+        date: 1,
+        hours: 1,
+        minutes: 1,
+        seconds: 1,
+        milliseconds: 1
+    };
+
+    function Sfe(e) {
+        return !!wfe[e]
+    }
 
-    function ahe(e) {
+    function B6(e, t = 1) {
+        if (Sfe(e)) return {
+            part: e,
+            step: t
+        };
+        switch (e) {
+            case "day":
+            case "dayofyear":
+                return {
+                    part: "date", step: t
+                };
+            case "quarter":
+                return {
+                    part: "month", step: t * 3
+                };
+            case "week":
+                return {
+                    part: "date", step: t * 7
+                }
+        }
+    }
+
+    function Efe(e) {
         return e == null ? void 0 : e.param
     }
 
-    function LE(e) {
+    function Ck(e) {
         return !!(e != null && e.field) && e.equal !== void 0
     }
 
-    function IE(e) {
+    function Ak(e) {
         return !!(e != null && e.field) && e.lt !== void 0
     }
 
-    function zE(e) {
+    function $k(e) {
         return !!(e != null && e.field) && e.lte !== void 0
     }
 
-    function BE(e) {
+    function Tk(e) {
         return !!(e != null && e.field) && e.gt !== void 0
     }
 
-    function jE(e) {
+    function Mk(e) {
         return !!(e != null && e.field) && e.gte !== void 0
     }
 
-    function UE(e) {
+    function Ok(e) {
         if (e != null && e.field) {
-            if (W(e.range) && e.range.length === 2) return !0;
-            if (he(e.range)) return !0
+            if (H(e.range) && e.range.length === 2) return !0;
+            if (xe(e.range)) return !0
         }
         return !1
     }
 
-    function GE(e) {
-        return !!(e != null && e.field) && (W(e.oneOf) || W(e.in))
+    function Fk(e) {
+        return !!(e != null && e.field) && (H(e.oneOf) || H(e.in))
     }
 
-    function ohe(e) {
+    function kfe(e) {
         return !!(e != null && e.field) && e.valid !== void 0
     }
 
-    function n6(e) {
-        return GE(e) || LE(e) || UE(e) || IE(e) || BE(e) || zE(e) || jE(e)
+    function j6(e) {
+        return Fk(e) || Ck(e) || Ok(e) || Ak(e) || Tk(e) || $k(e) || Mk(e)
     }
 
-    function Ar(e, t) {
-        return B1(e, {
+    function Ur(e, t) {
+        return vy(e, {
             timeUnit: t,
             wrapTime: !0
         })
     }
 
-    function lhe(e, t) {
-        return e.map(n => Ar(n, t))
+    function Cfe(e, t) {
+        return e.map(n => Ur(n, t))
     }
 
-    function i6(e, t = !0) {
-        var s;
+    function G6(e, t = !0) {
         const {
             field: n
-        } = e, i = (s = en(e.timeUnit)) == null ? void 0 : s.unit, r = i ? `time(${ihe(i,n)})` : ie(e, {
+        } = e, i = an(e.timeUnit), {
+            unit: r,
+            binned: s
+        } = i || {}, a = oe(e, {
             expr: "datum"
-        });
-        if (LE(e)) return `${r}===${Ar(e.equal,i)}`;
-        if (IE(e)) {
-            const a = e.lt;
-            return `${r}<${Ar(a,i)}`
-        } else if (BE(e)) {
-            const a = e.gt;
-            return `${r}>${Ar(a,i)}`
-        } else if (zE(e)) {
-            const a = e.lte;
-            return `${r}<=${Ar(a,i)}`
-        } else if (jE(e)) {
-            const a = e.gte;
-            return `${r}>=${Ar(a,i)}`
+        }), o = r ? `time(${s?a:bfe(r,n)})` : a;
+        if (Ck(e)) return `${o}===${Ur(e.equal,r)}`;
+        if (Ak(e)) {
+            const l = e.lt;
+            return `${o}<${Ur(l,r)}`
+        } else if (Tk(e)) {
+            const l = e.gt;
+            return `${o}>${Ur(l,r)}`
+        } else if ($k(e)) {
+            const l = e.lte;
+            return `${o}<=${Ur(l,r)}`
+        } else if (Mk(e)) {
+            const l = e.gte;
+            return `${o}>=${Ur(l,r)}`
         } else {
-            if (GE(e)) return `indexof([${lhe(e.oneOf,i).join(",")}], ${r}) !== -1`;
-            if (ohe(e)) return WE(r, e.valid);
-            if (UE(e)) {
+            if (Fk(e)) return `indexof([${Cfe(e.oneOf,r).join(",")}], ${o}) !== -1`;
+            if (kfe(e)) return Rk(o, e.valid);
+            if (Ok(e)) {
                 const {
-                    range: a
-                } = e, o = he(a) ? {
-                    signal: `${a.signal}[0]`
-                } : a[0], l = he(a) ? {
-                    signal: `${a.signal}[1]`
-                } : a[1];
-                if (o !== null && l !== null && t) return "inrange(" + r + ", [" + Ar(o, i) + ", " + Ar(l, i) + "])";
-                const u = [];
-                return o !== null && u.push(`${r} >= ${Ar(o,i)}`), l !== null && u.push(`${r} <= ${Ar(l,i)}`), u.length > 0 ? u.join(" && ") : "true"
+                    range: l
+                } = e, u = xe(l) ? {
+                    signal: `${l.signal}[0]`
+                } : l[0], c = xe(l) ? {
+                    signal: `${l.signal}[1]`
+                } : l[1];
+                if (u !== null && c !== null && t) return "inrange(" + o + ", [" + Ur(u, r) + ", " + Ur(c, r) + "])";
+                const f = [];
+                return u !== null && f.push(`${o} >= ${Ur(u,r)}`), c !== null && f.push(`${o} <= ${Ur(c,r)}`), f.length > 0 ? f.join(" && ") : "true"
             }
         }
-        throw new Error(`Invalid field predicate: ${at(e)}`)
+        throw new Error(`Invalid field predicate: ${mt(e)}`)
     }
 
-    function WE(e, t = !0) {
+    function Rk(e, t = !0) {
         return t ? `isValid(${e}) && isFinite(+${e})` : `!isValid(${e}) || !isFinite(+${e})`
     }
 
-    function uhe(e) {
-        var t;
-        return n6(e) && e.timeUnit ? {
+    function Afe(e) {
+        return j6(e) && e.timeUnit ? {
             ...e,
-            timeUnit: (t = en(e.timeUnit)) == null ? void 0 : t.unit
+            timeUnit: an(e.timeUnit)
         } : e
     }
-    const Od = {
+    const og = {
         quantitative: "quantitative",
         ordinal: "ordinal",
         temporal: "temporal",
         nominal: "nominal",
         geojson: "geojson"
     };
 
-    function che(e) {
+    function $fe(e) {
         return e === "quantitative" || e === "temporal"
     }
 
-    function r6(e) {
+    function U6(e) {
         return e === "ordinal" || e === "nominal"
     }
-    const hl = Od.quantitative,
-        qE = Od.ordinal,
-        nc = Od.temporal,
-        HE = Od.nominal,
-        Rc = Od.geojson;
+    const Pl = og.quantitative,
+        Dk = og.ordinal,
+        $c = og.temporal,
+        Nk = og.nominal,
+        sf = og.geojson;
 
-    function fhe(e) {
+    function Tfe(e) {
         if (e) switch (e = e.toLowerCase(), e) {
             case "q":
-            case hl:
+            case Pl:
                 return "quantitative";
             case "t":
-            case nc:
+            case $c:
                 return "temporal";
             case "o":
-            case qE:
+            case Dk:
                 return "ordinal";
             case "n":
-            case HE:
+            case Nk:
                 return "nominal";
-            case Rc:
+            case sf:
                 return "geojson"
         }
     }
-    const Qn = {
+    const ui = {
             LINEAR: "linear",
             LOG: "log",
             POW: "pow",
             SQRT: "sqrt",
             SYMLOG: "symlog",
             IDENTITY: "identity",
             SEQUENTIAL: "sequential",
@@ -37915,15 +31198,15 @@
             QUANTIZE: "quantize",
             THRESHOLD: "threshold",
             BIN_ORDINAL: "bin-ordinal",
             ORDINAL: "ordinal",
             POINT: "point",
             BAND: "band"
         },
-        X2 = {
+        kx = {
             linear: "numeric",
             log: "numeric",
             pow: "numeric",
             sqrt: "numeric",
             symlog: "numeric",
             identity: "numeric",
             sequential: "numeric",
@@ -37934,20 +31217,20 @@
             point: "ordinal-position",
             band: "ordinal-position",
             quantile: "discretizing",
             quantize: "discretizing",
             threshold: "discretizing"
         };
 
-    function hhe(e, t) {
-        const n = X2[e],
-            i = X2[t];
+    function Mfe(e, t) {
+        const n = kx[e],
+            i = kx[t];
         return n === i || n === "ordinal-position" && i === "time" || i === "ordinal-position" && n === "time"
     }
-    const dhe = {
+    const Ofe = {
         linear: 0,
         log: 1,
         pow: 1,
         sqrt: 1,
         symlog: 1,
         identity: 1,
         sequential: 1,
@@ -37958,43 +31241,43 @@
         ordinal: 0,
         "bin-ordinal": 0,
         quantile: 0,
         quantize: 0,
         threshold: 0
     };
 
-    function D5(e) {
-        return dhe[e]
+    function tM(e) {
+        return Ofe[e]
     }
-    const s6 = new Set(["linear", "log", "pow", "sqrt", "symlog"]),
-        a6 = new Set([...s6, "time", "utc"]);
+    const W6 = new Set(["linear", "log", "pow", "sqrt", "symlog"]),
+        q6 = new Set([...W6, "time", "utc"]);
 
-    function o6(e) {
-        return s6.has(e)
+    function H6(e) {
+        return W6.has(e)
     }
-    const l6 = new Set(["quantile", "quantize", "threshold"]),
-        ghe = new Set([...a6, ...l6, "sequential", "identity"]),
-        phe = new Set(["ordinal", "bin-ordinal", "point", "band"]);
+    const Y6 = new Set(["quantile", "quantize", "threshold"]),
+        Ffe = new Set([...q6, ...Y6, "sequential", "identity"]),
+        Rfe = new Set(["ordinal", "bin-ordinal", "point", "band"]);
 
-    function qt(e) {
-        return phe.has(e)
+    function fn(e) {
+        return Rfe.has(e)
     }
 
-    function wi(e) {
-        return ghe.has(e)
+    function Ni(e) {
+        return Ffe.has(e)
     }
 
-    function ir(e) {
-        return a6.has(e)
+    function xr(e) {
+        return q6.has(e)
     }
 
-    function ic(e) {
-        return l6.has(e)
+    function Tc(e) {
+        return Y6.has(e)
     }
-    const mhe = {
+    const Dfe = {
         pointPadding: .5,
         barBandPaddingInner: .1,
         rectBandPaddingInner: 0,
         bandWithNestedOffsetPaddingInner: .2,
         bandWithNestedOffsetPaddingOuter: .2,
         minBandSize: 2,
         minFontSize: 8,
@@ -38005,35 +31288,36 @@
         minStrokeWidth: 1,
         maxStrokeWidth: 4,
         quantileCount: 4,
         quantizeCount: 4,
         zero: !0
     };
 
-    function yhe(e) {
-        return !re(e) && !!e.name
+    function Nfe(e) {
+        return !le(e) && !!e.name
     }
 
-    function u6(e) {
+    function X6(e) {
         return e == null ? void 0 : e.param
     }
 
-    function vhe(e) {
+    function Pfe(e) {
         return e == null ? void 0 : e.unionWith
     }
 
-    function bhe(e) {
-        return ae(e) && "field" in e
+    function Lfe(e) {
+        return ce(e) && "field" in e
     }
-    const xhe = {
+    const Ife = {
             type: 1,
             domain: 1,
             domainMax: 1,
             domainMin: 1,
             domainMid: 1,
+            domainRaw: 1,
             align: 1,
             range: 1,
             rangeMax: 1,
             rangeMin: 1,
             scheme: 1,
             bins: 1,
             reverse: 1,
@@ -38046,77 +31330,79 @@
             interpolate: 1,
             zero: 1,
             padding: 1,
             paddingInner: 1,
             paddingOuter: 1
         },
         {
-            type: k2e,
-            domain: A2e,
-            range: $2e,
-            rangeMax: T2e,
-            rangeMin: M2e,
-            scheme: O2e,
-            ..._he
-        } = xhe,
-        whe = H(_he);
+            type: owe,
+            domain: lwe,
+            range: uwe,
+            rangeMax: cwe,
+            rangeMin: fwe,
+            scheme: hwe,
+            ...zfe
+        } = Ife,
+        Bfe = K(zfe);
 
-    function V2(e, t) {
+    function Cx(e, t) {
         switch (t) {
             case "type":
             case "domain":
             case "reverse":
             case "range":
                 return !0;
             case "scheme":
             case "interpolate":
                 return !["point", "band", "identity"].includes(e);
             case "bins":
                 return !["point", "band", "identity", "ordinal"].includes(e);
             case "round":
-                return ir(e) || e === "band" || e === "point";
+                return xr(e) || e === "band" || e === "point";
             case "padding":
             case "rangeMin":
             case "rangeMax":
-                return ir(e) || ["point", "band"].includes(e);
+                return xr(e) || ["point", "band"].includes(e);
             case "paddingOuter":
             case "align":
                 return ["point", "band"].includes(e);
             case "paddingInner":
                 return e === "band";
             case "domainMax":
             case "domainMid":
             case "domainMin":
+            case "domainRaw":
             case "clamp":
-                return ir(e);
+                return xr(e);
             case "nice":
-                return ir(e) || e === "quantize" || e === "threshold";
+                return xr(e) || e === "quantize" || e === "threshold";
             case "exponent":
                 return e === "pow";
             case "base":
                 return e === "log";
             case "constant":
                 return e === "symlog";
             case "zero":
-                return wi(e) && !Fe(["log", "time", "utc", "threshold", "quantile"], e)
+                return Ni(e) && !Be(["log", "time", "utc", "threshold", "quantile"], e)
         }
     }
 
-    function c6(e, t) {
+    function V6(e, t) {
         switch (t) {
             case "interpolate":
             case "scheme":
             case "domainMid":
-                return Cu(e) ? void 0 : bfe(t);
+                return Ku(e) ? void 0 : Pce(t);
             case "align":
             case "type":
             case "bins":
             case "domain":
             case "domainMax":
             case "domainMin":
+            case "domainRaw":
             case "range":
             case "base":
             case "exponent":
             case "constant":
             case "nice":
             case "padding":
             case "paddingInner":
@@ -38127,45 +31413,45 @@
             case "round":
             case "clamp":
             case "zero":
                 return
         }
     }
 
-    function She(e, t) {
-        return Fe([qE, HE], t) ? e === void 0 || qt(e) : t === nc ? Fe([Qn.TIME, Qn.UTC, void 0], e) : t === hl ? o6(e) || ic(e) || e === void 0 : !0
+    function jfe(e, t) {
+        return Be([Dk, Nk], t) ? e === void 0 || fn(e) : t === $c ? Be([ui.TIME, ui.UTC, void 0], e) : t === Pl ? H6(e) || Tc(e) || e === void 0 : !0
     }
 
-    function Ehe(e, t, n = !1) {
-        if (!Qs(e)) return !1;
+    function Gfe(e, t, n = !1) {
+        if (!ha(e)) return !1;
         switch (e) {
-            case ht:
-            case Gt:
-            case no:
-            case Mc:
-            case zi:
-            case _r:
-                return ir(t) || t === "band" ? !0 : t === "point" ? !n : !1;
-            case Ks:
-            case so:
-            case Js:
-            case io:
-            case ro:
-            case Dl:
-                return ir(t) || ic(t) || Fe(["band", "point", "ordinal"], t);
-            case si:
-            case os:
-            case ls:
+            case kt:
+            case un:
+            case So:
+            case nf:
+            case nr:
+            case Nr:
+                return xr(t) || t === "band" ? !0 : t === "point" ? !n : !1;
+            case ca:
+            case Co:
+            case fa:
+            case Eo:
+            case ko:
+            case eu:
+                return xr(t) || Tc(t) || Be(["band", "point", "ordinal"], t);
+            case pi:
+            case _s:
+            case ws:
                 return t !== "band";
-            case ao:
-            case ai:
-                return t === "ordinal" || ic(t)
+            case Ao:
+            case mi:
+                return t === "ordinal" || Tc(t)
         }
     }
-    const jn = {
+    const Zn = {
             arc: "arc",
             area: "area",
             bar: "bar",
             image: "image",
             line: "line",
             point: "point",
             rect: "rect",
@@ -38173,68 +31459,68 @@
             text: "text",
             tick: "tick",
             trail: "trail",
             circle: "circle",
             square: "square",
             geoshape: "geoshape"
         },
-        f6 = jn.arc,
-        O1 = jn.area,
-        F1 = jn.bar,
-        Che = jn.image,
-        R1 = jn.line,
-        D1 = jn.point,
-        khe = jn.rect,
-        I0 = jn.rule,
-        h6 = jn.text,
-        YE = jn.tick,
-        Ahe = jn.trail,
-        XE = jn.circle,
-        VE = jn.square,
-        d6 = jn.geoshape;
+        K6 = Zn.arc,
+        uy = Zn.area,
+        cy = Zn.bar,
+        Ufe = Zn.image,
+        fy = Zn.line,
+        hy = Zn.point,
+        Wfe = Zn.rect,
+        b0 = Zn.rule,
+        J6 = Zn.text,
+        Pk = Zn.tick,
+        qfe = Zn.trail,
+        Lk = Zn.circle,
+        Ik = Zn.square,
+        Q6 = Zn.geoshape;
 
-    function uo(e) {
+    function Mo(e) {
         return ["line", "area", "trail"].includes(e)
     }
 
-    function g6(e) {
+    function zk(e) {
         return ["rect", "bar", "image", "arc"].includes(e)
     }
-    const $he = new Set(H(jn));
+    const Hfe = new Set(K(Zn));
 
-    function Vr(e) {
+    function fs(e) {
         return e.type
     }
-    const The = ["stroke", "strokeWidth", "strokeDash", "strokeDashOffset", "strokeOpacity", "strokeJoin", "strokeMiterLimit"],
-        Mhe = ["fill", "fillOpacity"],
-        Ohe = [...The, ...Mhe],
-        Fhe = {
+    const Yfe = ["stroke", "strokeWidth", "strokeDash", "strokeDashOffset", "strokeOpacity", "strokeJoin", "strokeMiterLimit"],
+        Xfe = ["fill", "fillOpacity"],
+        Vfe = [...Yfe, ...Xfe],
+        Kfe = {
             color: 1,
             filled: 1,
             invalid: 1,
             order: 1,
             radius2: 1,
             theta2: 1,
             timeUnitBandSize: 1,
             timeUnitBandPosition: 1
         },
-        N5 = H(Fhe),
-        Rhe = {
+        nM = K(Kfe),
+        Jfe = {
             area: ["line", "point"],
-            bar: ["binSpacing", "continuousBandSize", "discreteBandSize"],
-            rect: ["binSpacing", "continuousBandSize", "discreteBandSize"],
+            bar: ["binSpacing", "continuousBandSize", "discreteBandSize", "minBandSize"],
+            rect: ["binSpacing", "continuousBandSize", "discreteBandSize", "minBandSize"],
             line: ["point"],
             tick: ["bandSize", "thickness"]
         },
-        Dhe = {
+        Qfe = {
             color: "#4c78a8",
             invalid: "filter",
             timeUnitBandSize: 1
         },
-        Nhe = {
+        Zfe = {
             mark: 1,
             arc: 1,
             area: 1,
             bar: 1,
             circle: 1,
             image: 1,
             line: 1,
@@ -38243,480 +31529,496 @@
             rule: 1,
             square: 1,
             text: 1,
             tick: 1,
             trail: 1,
             geoshape: 1
         },
-        p6 = H(Nhe);
+        Z6 = K(Zfe);
 
-    function dl(e) {
+    function Ll(e) {
         return e && e.band != null
     }
-    const Phe = {
+    const ehe = {
             horizontal: ["cornerRadiusTopRight", "cornerRadiusBottomRight"],
             vertical: ["cornerRadiusTopLeft", "cornerRadiusTopRight"]
         },
-        m6 = 5,
-        Lhe = {
+        e8 = 5,
+        the = {
             binSpacing: 1,
-            continuousBandSize: m6,
+            continuousBandSize: e8,
+            minBandSize: .25,
             timeUnitBandPosition: .5
         },
-        Ihe = {
+        nhe = {
             binSpacing: 0,
-            continuousBandSize: m6,
+            continuousBandSize: e8,
+            minBandSize: .25,
             timeUnitBandPosition: .5
         },
-        zhe = {
+        ihe = {
             thickness: 1
         };
 
-    function Bhe(e) {
-        return Vr(e) ? e.type : e
+    function rhe(e) {
+        return fs(e) ? e.type : e
     }
 
-    function KE(e) {
+    function Bk(e) {
         const {
             channel: t,
             channelDef: n,
             markDef: i,
             scale: r,
             config: s
-        } = e, a = QE(e);
-        return K(n) && !RI(n.aggregate) && r && ir(r.get("type")) ? jhe({
+        } = e, a = Gk(e);
+        return Z(n) && !p6(n.aggregate) && r && xr(r.get("type")) ? she({
             fieldDef: n,
             channel: t,
             markDef: i,
             ref: a,
             config: s
         }) : a
     }
 
-    function jhe({
+    function she({
         fieldDef: e,
         channel: t,
         markDef: n,
         ref: i,
         config: r
     }) {
-        return uo(n.type) ? i : Xe("invalid", n, r) === null ? [Uhe(e, t), i] : i
+        return Mo(n.type) ? i : st("invalid", n, r) === null ? [ahe(e, t), i] : i
     }
 
-    function Uhe(e, t) {
-        const n = JE(e, !0),
-            r = Nl(t) === "y" ? {
+    function ahe(e, t) {
+        const n = jk(e, !0),
+            r = tu(t) === "y" ? {
                 field: {
                     group: "height"
                 }
             } : {
                 value: 0
             };
         return {
             test: n,
             ...r
         }
     }
 
-    function JE(e, t = !0) {
-        return WE(re(e) ? e : ie(e, {
+    function jk(e, t = !0) {
+        return Rk(le(e) ? e : oe(e, {
             expr: "datum"
         }), !t)
     }
 
-    function Ghe(e) {
+    function ohe(e) {
         const {
             datum: t
         } = e;
-        return Ll(t) ? fl(t) : `${at(t)}`
+        return iu(t) ? Nl(t) : `${mt(t)}`
     }
 
-    function qo(e, t, n, i) {
+    function pl(e, t, n, i) {
         const r = {};
-        if (t && (r.scale = t), fs(e)) {
+        if (t && (r.scale = t), ks(e)) {
             const {
                 datum: s
             } = e;
-            Ll(s) ? r.signal = fl(s) : he(s) ? r.signal = s.signal : Fc(s) ? r.signal = s.expr : r.value = s
-        } else r.field = ie(e, n);
+            iu(s) ? r.signal = Nl(s) : xe(s) ? r.signal = s.signal : ag(s) ? r.signal = s.expr : r.value = s
+        } else r.field = oe(e, n);
         if (i) {
             const {
                 offset: s,
                 band: a
             } = i;
             s && (r.offset = s), a && (r.band = a)
         }
         return r
     }
 
-    function z0({
+    function x0({
         scaleName: e,
         fieldOrDatumDef: t,
         fieldOrDatumDef2: n,
         offset: i,
         startSuffix: r,
         bandPosition: s = .5
     }) {
         const a = 0 < s && s < 1 ? "datum" : void 0,
-            o = ie(t, {
+            o = oe(t, {
                 expr: a,
                 suffix: r
             }),
-            l = n !== void 0 ? ie(n, {
+            l = n !== void 0 ? oe(n, {
                 expr: a
-            }) : ie(t, {
+            }) : oe(t, {
                 suffix: "end",
                 expr: a
             }),
             u = {};
         if (s === 0 || s === 1) {
             u.scale = e;
             const c = s === 0 ? o : l;
             u.field = c
         } else {
-            const c = he(s) ? `${s.signal} * ${o} + (1-${s.signal}) * ${l}` : `${s} * ${o} + ${1-s} * ${l}`;
+            const c = xe(s) ? `${s.signal} * ${o} + (1-${s.signal}) * ${l}` : `${s} * ${o} + ${1-s} * ${l}`;
             u.signal = `scale("${e}", ${c})`
         }
         return i && (u.offset = i), u
     }
 
-    function QE({
+    function lhe({
+        scaleName: e,
+        fieldDef: t
+    }) {
+        const n = oe(t, {
+                expr: "datum"
+            }),
+            i = oe(t, {
+                expr: "datum",
+                suffix: "end"
+            });
+        return `abs(scale("${e}", ${i}) - scale("${e}", ${n}))`
+    }
+
+    function Gk({
         channel: e,
         channelDef: t,
         channel2Def: n,
         markDef: i,
         config: r,
         scaleName: s,
         scale: a,
         stack: o,
         offset: l,
         defaultRef: u,
         bandPosition: c
     }) {
         if (t) {
-            if (Ce(t)) {
+            if (De(t)) {
                 const f = a == null ? void 0 : a.get("type");
-                if (zn(t)) {
-                    c ?? (c = E6({
+                if (Jn(t)) {
+                    c ?? (c = l8({
                         fieldDef: t,
                         fieldDef2: n,
                         markDef: i,
                         config: r
                     }));
                     const {
                         bin: h,
                         timeUnit: d,
                         type: g
                     } = t;
-                    if (ot(h) || c && d && g === nc) return o != null && o.impute ? qo(t, s, {
+                    if (yt(h) || c && d && g === $c) return o != null && o.impute ? pl(t, s, {
                         binSuffix: "mid"
                     }, {
                         offset: l
-                    }) : c && !qt(f) ? z0({
+                    }) : c && !fn(f) ? x0({
                         scaleName: s,
                         fieldOrDatumDef: t,
                         bandPosition: c,
                         offset: l
-                    }) : qo(t, s, Nd(t, e) ? {
+                    }) : pl(t, s, fg(t, e) ? {
                         binSuffix: "range"
                     } : {}, {
                         offset: l
                     });
-                    if (Xt(h)) {
-                        if (K(n)) return z0({
+                    if (pn(h)) {
+                        if (Z(n)) return x0({
                             scaleName: s,
                             fieldOrDatumDef: t,
                             fieldOrDatumDef2: n,
                             bandPosition: c,
                             offset: l
                         });
-                        X(XI(e === ht ? xr : as))
+                        J(M6(e === kt ? Dr : xs))
                     }
                 }
-                return qo(t, s, qt(f) ? {
+                return pl(t, s, fn(f) ? {
                     binSuffix: "range"
                 } : {}, {
                     offset: l,
                     band: f === "band" ? c ?? t.bandPosition ?? .5 : void 0
                 })
-            } else if (gr(t)) {
+            } else if (Tr(t)) {
                 const f = t.value,
                     h = l ? {
                         offset: l
                     } : {};
                 return {
-                    ...lh(e, f),
+                    ...Ph(e, f),
                     ...h
                 }
             }
         }
-        return $e(u) && (u = u()), u && {
+        return Pe(u) && (u = u()), u && {
             ...u,
             ...l ? {
                 offset: l
             } : {}
         }
     }
 
-    function lh(e, t) {
-        return Fe(["x", "x2"], e) && t === "width" ? {
+    function Ph(e, t) {
+        return Be(["x", "x2"], e) && t === "width" ? {
             field: {
                 group: "width"
             }
-        } : Fe(["y", "y2"], e) && t === "height" ? {
+        } : Be(["y", "y2"], e) && t === "height" ? {
             field: {
                 group: "height"
             }
-        } : ut(t)
+        } : bt(t)
     }
 
-    function gl(e) {
+    function Il(e) {
         return e && e !== "number" && e !== "time"
     }
 
-    function y6(e, t, n) {
-        return `${e}(${t}${n?`, ${at(n)}`:""})`
+    function t8(e, t, n) {
+        return `${e}(${t}${n?`, ${mt(n)}`:""})`
     }
-    const Whe = " – ";
+    const uhe = " – ";
 
-    function ZE({
+    function Uk({
         fieldOrDatumDef: e,
         format: t,
         formatType: n,
         expr: i,
         normalizeStack: r,
         config: s
     }) {
         var l, u;
-        if (gl(n)) return rr({
+        if (Il(n)) return _r({
             fieldOrDatumDef: e,
             format: t,
             formatType: n,
             expr: i,
             config: s
         });
-        const a = v6(e, i, r),
-            o = rc(e);
+        const a = n8(e, i, r),
+            o = Mc(e);
         if (t === void 0 && n === void 0 && s.customFormatTypes) {
             if (o === "quantitative") {
-                if (r && s.normalizedNumberFormatType) return rr({
+                if (r && s.normalizedNumberFormatType) return _r({
                     fieldOrDatumDef: e,
                     format: s.normalizedNumberFormat,
                     formatType: s.normalizedNumberFormatType,
                     expr: i,
                     config: s
                 });
-                if (s.numberFormatType) return rr({
+                if (s.numberFormatType) return _r({
                     fieldOrDatumDef: e,
                     format: s.numberFormat,
                     formatType: s.numberFormatType,
                     expr: i,
                     config: s
                 })
             }
-            if (o === "temporal" && s.timeFormatType && K(e) && e.timeUnit === void 0) return rr({
+            if (o === "temporal" && s.timeFormatType && Z(e) && e.timeUnit === void 0) return _r({
                 fieldOrDatumDef: e,
                 format: s.timeFormat,
                 formatType: s.timeFormatType,
                 expr: i,
                 config: s
             })
         }
-        if (ac(e)) {
-            const c = Hhe({
+        if (Fc(e)) {
+            const c = fhe({
                 field: a,
-                timeUnit: K(e) ? (l = en(e.timeUnit)) == null ? void 0 : l.unit : void 0,
+                timeUnit: Z(e) ? (l = an(e.timeUnit)) == null ? void 0 : l.unit : void 0,
                 format: t,
                 formatType: s.timeFormatType,
                 rawTimeFormat: s.timeFormat,
-                isUTCScale: Il(e) && ((u = e.scale) == null ? void 0 : u.type) === Qn.UTC
+                isUTCScale: su(e) && ((u = e.scale) == null ? void 0 : u.type) === ui.UTC
             });
             return c ? {
                 signal: c
             } : void 0
         }
-        if (t = K2({
+        if (t = Ax({
                 type: o,
                 specifiedFormat: t,
                 config: s,
                 normalizeStack: r
-            }), K(e) && ot(e.bin)) {
-            const c = ie(e, {
+            }), Z(e) && yt(e.bin)) {
+            const c = oe(e, {
                 expr: i,
                 binSuffix: "end"
             });
             return {
-                signal: Fd(a, c, t, n, s)
+                signal: lg(a, c, t, n, s)
             }
-        } else return t || rc(e) === "quantitative" ? {
-            signal: `${_6(a,t)}`
+        } else return t || Mc(e) === "quantitative" ? {
+            signal: `${s8(a,t)}`
         } : {
             signal: `isValid(${a}) ? ${a} : ""+${a}`
         }
     }
 
-    function v6(e, t, n) {
-        return K(e) ? n ? `${ie(e,{expr:t,suffix:"end"})}-${ie(e,{expr:t,suffix:"start"})}` : ie(e, {
+    function n8(e, t, n) {
+        return Z(e) ? n ? `${oe(e,{expr:t,suffix:"end"})}-${oe(e,{expr:t,suffix:"start"})}` : oe(e, {
             expr: t
-        }) : Ghe(e)
+        }) : ohe(e)
     }
 
-    function rr({
+    function _r({
         fieldOrDatumDef: e,
         format: t,
         formatType: n,
         expr: i,
         normalizeStack: r,
         config: s,
         field: a
     }) {
-        if (a ?? (a = v6(e, i, r)), a !== "datum.value" && K(e) && ot(e.bin)) {
-            const o = ie(e, {
+        if (a ?? (a = n8(e, i, r)), a !== "datum.value" && Z(e) && yt(e.bin)) {
+            const o = oe(e, {
                 expr: i,
                 binSuffix: "end"
             });
             return {
-                signal: Fd(a, o, t, n, s)
+                signal: lg(a, o, t, n, s)
             }
         }
         return {
-            signal: y6(n, a, t)
+            signal: t8(n, a, t)
         }
     }
 
-    function b6(e, t, n, i, r, s) {
+    function i8(e, t, n, i, r, s) {
         var a;
-        if (!(re(i) && gl(i)) && !(n === void 0 && i === void 0 && r.customFormatTypes && rc(e) === "quantitative" && (r.normalizedNumberFormatType && sc(e) && e.stack === "normalize" || r.numberFormatType))) {
-            if (sc(e) && e.stack === "normalize" && r.normalizedNumberFormat) return K2({
+        if (!(le(i) && Il(i)) && !(n === void 0 && i === void 0 && r.customFormatTypes && Mc(e) === "quantitative" && (r.normalizedNumberFormatType && Oc(e) && e.stack === "normalize" || r.numberFormatType))) {
+            if (Oc(e) && e.stack === "normalize" && r.normalizedNumberFormat) return Ax({
                 type: "quantitative",
                 config: r,
                 normalizeStack: !0
             });
-            if (ac(e)) {
-                const o = K(e) ? (a = en(e.timeUnit)) == null ? void 0 : a.unit : void 0;
-                return o === void 0 && r.customFormatTypes && r.timeFormatType ? void 0 : qhe({
+            if (Fc(e)) {
+                const o = Z(e) ? (a = an(e.timeUnit)) == null ? void 0 : a.unit : void 0;
+                return o === void 0 && r.customFormatTypes && r.timeFormatType ? void 0 : che({
                     specifiedFormat: n,
                     timeUnit: o,
                     config: r,
                     omitTimeFormatConfig: s
                 })
             }
-            return K2({
+            return Ax({
                 type: t,
                 specifiedFormat: n,
                 config: r
             })
         }
     }
 
-    function x6(e, t, n) {
+    function r8(e, t, n) {
         var i;
-        if (e && (he(e) || e === "number" || e === "time")) return e;
-        if (ac(t) && n !== "time" && n !== "utc") return K(t) && ((i = en(t == null ? void 0 : t.timeUnit)) != null && i.utc) ? "utc" : "time"
+        if (e && (xe(e) || e === "number" || e === "time")) return e;
+        if (Fc(t) && n !== "time" && n !== "utc") return Z(t) && ((i = an(t == null ? void 0 : t.timeUnit)) != null && i.utc) ? "utc" : "time"
     }
 
-    function K2({
+    function Ax({
         type: e,
         specifiedFormat: t,
         config: n,
         normalizeStack: i
     }) {
-        if (re(t)) return t;
-        if (e === hl) return i ? n.normalizedNumberFormat : n.numberFormat
+        if (le(t)) return t;
+        if (e === Pl) return i ? n.normalizedNumberFormat : n.numberFormat
     }
 
-    function qhe({
+    function che({
         specifiedFormat: e,
         timeUnit: t,
         config: n,
         omitTimeFormatConfig: i
     }) {
         return e || (t ? {
-            signal: e6(t)
+            signal: I6(t)
         } : i ? void 0 : n.timeFormat)
     }
 
-    function _6(e, t) {
+    function s8(e, t) {
         return `format(${e}, "${t||""}")`
     }
 
-    function P5(e, t, n, i) {
-        return gl(n) ? y6(n, e, t) : _6(e, (re(t) ? t : void 0) ?? i.numberFormat)
+    function iM(e, t, n, i) {
+        return Il(n) ? t8(n, e, t) : s8(e, (le(t) ? t : void 0) ?? i.numberFormat)
     }
 
-    function Fd(e, t, n, i, r) {
-        if (n === void 0 && i === void 0 && r.customFormatTypes && r.numberFormatType) return Fd(e, t, r.numberFormat, r.numberFormatType, r);
-        const s = P5(e, n, i, r),
-            a = P5(t, n, i, r);
-        return `${WE(e,!1)} ? "null" : ${s} + "${Whe}" + ${a}`
+    function lg(e, t, n, i, r) {
+        if (n === void 0 && i === void 0 && r.customFormatTypes && r.numberFormatType) return lg(e, t, r.numberFormat, r.numberFormatType, r);
+        const s = iM(e, n, i, r),
+            a = iM(t, n, i, r);
+        return `${Rk(e,!1)} ? "null" : ${s} + "${uhe}" + ${a}`
     }
 
-    function Hhe({
+    function fhe({
         field: e,
         timeUnit: t,
         format: n,
         formatType: i,
         rawTimeFormat: r,
         isUTCScale: s
     }) {
-        return !t || n ? !t && i ? `${i}(${e}, '${n}')` : (n = re(n) ? n : r, `${s?"utc":"time"}Format(${e}, '${n}')`) : rhe(t, e, s)
+        return !t || n ? !t && i ? `${i}(${e}, '${n}')` : (n = le(n) ? n : r, `${s?"utc":"time"}Format(${e}, '${n}')`) : xfe(t, e, s)
     }
-    const N1 = "min",
-        Yhe = {
+    const dy = "min",
+        hhe = {
             x: 1,
             y: 1,
             color: 1,
             fill: 1,
             stroke: 1,
             strokeWidth: 1,
             size: 1,
             shape: 1,
             fillOpacity: 1,
             strokeOpacity: 1,
             opacity: 1,
             text: 1
         };
 
-    function L5(e) {
-        return e in Yhe
+    function rM(e) {
+        return e in hhe
     }
 
-    function w6(e) {
+    function a8(e) {
         return !!(e != null && e.encoding)
     }
 
-    function Br(e) {
+    function ns(e) {
         return e && (e.op === "count" || !!e.field)
     }
 
-    function S6(e) {
-        return e && W(e)
+    function o8(e) {
+        return e && H(e)
     }
 
-    function Rd(e) {
+    function ug(e) {
         return "row" in e || "column" in e
     }
 
-    function eC(e) {
+    function Wk(e) {
         return !!e && "header" in e
     }
 
-    function P1(e) {
+    function gy(e) {
         return "facet" in e
     }
 
-    function Xhe(e) {
+    function dhe(e) {
         return e.param
     }
 
-    function Vhe(e) {
-        return e && !re(e) && "repeat" in e
+    function ghe(e) {
+        return e && !le(e) && "repeat" in e
     }
 
-    function I5(e) {
+    function sM(e) {
         const {
             field: t,
             timeUnit: n,
             bin: i,
             aggregate: r
         } = e;
         return {
@@ -38729,439 +32031,439 @@
             ...r ? {
                 aggregate: r
             } : {},
             field: t
         }
     }
 
-    function tC(e) {
+    function qk(e) {
         return "sort" in e
     }
 
-    function E6({
+    function l8({
         fieldDef: e,
         fieldDef2: t,
         markDef: n,
         config: i
     }) {
-        if (Ce(e) && e.bandPosition !== void 0) return e.bandPosition;
-        if (K(e)) {
+        if (De(e) && e.bandPosition !== void 0) return e.bandPosition;
+        if (Z(e)) {
             const {
                 timeUnit: r,
                 bin: s
             } = e;
-            if (r && !t) return g6(n.type) ? 0 : cl("timeUnitBandPosition", n, i);
-            if (ot(s)) return .5
+            if (r && !t) return zk(n.type) ? 0 : ia("timeUnitBandPosition", n, i);
+            if (yt(s)) return .5
         }
     }
 
-    function C6({
+    function u8({
         channel: e,
         fieldDef: t,
         fieldDef2: n,
         markDef: i,
         config: r,
         scaleType: s,
         useVlSizeChannel: a
     }) {
         var u, c, f;
-        const o = oi(e),
-            l = Xe(a ? "size" : o, i, r, {
+        const o = yi(e),
+            l = st(a ? "size" : o, i, r, {
                 vgChannel: o
             });
         if (l !== void 0) return l;
-        if (K(t)) {
+        if (Z(t)) {
             const {
                 timeUnit: h,
                 bin: d
             } = t;
             if (h && !n) return {
-                band: cl("timeUnitBandSize", i, r)
+                band: ia("timeUnitBandSize", i, r)
             };
-            if (ot(d) && !qt(s)) return {
+            if (yt(d) && !fn(s)) return {
                 band: 1
             }
         }
-        if (g6(i.type)) return s ? qt(s) ? ((u = r[i.type]) == null ? void 0 : u.discreteBandSize) || {
+        if (zk(i.type)) return s ? fn(s) ? ((u = r[i.type]) == null ? void 0 : u.discreteBandSize) || {
             band: 1
         } : (c = r[i.type]) == null ? void 0 : c.continuousBandSize : (f = r[i.type]) == null ? void 0 : f.discreteBandSize
     }
 
-    function k6(e, t, n, i) {
-        return ot(e.bin) || e.timeUnit && zn(e) && e.type === "temporal" ? E6({
+    function c8(e, t, n, i) {
+        return yt(e.bin) || e.timeUnit && Jn(e) && e.type === "temporal" ? l8({
             fieldDef: e,
             fieldDef2: t,
             markDef: n,
             config: i
         }) !== void 0 : !1
     }
 
-    function A6(e) {
+    function f8(e) {
         return e && !!e.sort && !e.field
     }
 
-    function L1(e) {
+    function py(e) {
         return e && "condition" in e
     }
 
-    function I1(e) {
+    function my(e) {
         const t = e == null ? void 0 : e.condition;
-        return !!t && !W(t) && K(t)
+        return !!t && !H(t) && Z(t)
     }
 
-    function Dd(e) {
+    function cg(e) {
         const t = e == null ? void 0 : e.condition;
-        return !!t && !W(t) && Ce(t)
+        return !!t && !H(t) && De(t)
     }
 
-    function Khe(e) {
+    function phe(e) {
         const t = e == null ? void 0 : e.condition;
-        return !!t && (W(t) || gr(t))
+        return !!t && (H(t) || Tr(t))
     }
 
-    function K(e) {
+    function Z(e) {
         return e && (!!e.field || e.aggregate === "count")
     }
 
-    function rc(e) {
+    function Mc(e) {
         return e == null ? void 0 : e.type
     }
 
-    function fs(e) {
+    function ks(e) {
         return e && "datum" in e
     }
 
-    function _a(e) {
-        return zn(e) && !j0(e) || B0(e)
+    function Ba(e) {
+        return Jn(e) && !w0(e) || _0(e)
     }
 
-    function z5(e) {
-        return zn(e) && e.type === "quantitative" && !e.bin || B0(e)
+    function aM(e) {
+        return Jn(e) && e.type === "quantitative" && !e.bin || _0(e)
     }
 
-    function B0(e) {
-        return fs(e) && Ze(e.datum)
+    function _0(e) {
+        return ks(e) && lt(e.datum)
     }
 
-    function Ce(e) {
-        return K(e) || fs(e)
+    function De(e) {
+        return Z(e) || ks(e)
     }
 
-    function zn(e) {
+    function Jn(e) {
         return e && ("field" in e || e.aggregate === "count") && "type" in e
     }
 
-    function gr(e) {
+    function Tr(e) {
         return e && "value" in e && "value" in e
     }
 
-    function Il(e) {
+    function su(e) {
         return e && ("scale" in e || "sort" in e)
     }
 
-    function sc(e) {
+    function Oc(e) {
         return e && ("axis" in e || "stack" in e || "impute" in e)
     }
 
-    function $6(e) {
+    function h8(e) {
         return e && "legend" in e
     }
 
-    function T6(e) {
+    function d8(e) {
         return e && ("format" in e || "formatType" in e)
     }
 
-    function Jhe(e) {
-        return Jn(e, ["legend", "axis", "header", "scale"])
+    function mhe(e) {
+        return li(e, ["legend", "axis", "header", "scale"])
     }
 
-    function Qhe(e) {
+    function yhe(e) {
         return "op" in e
     }
 
-    function ie(e, t = {}) {
+    function oe(e, t = {}) {
         let n = e.field;
         const i = t.prefix;
         let r = t.suffix,
             s = "";
-        if (ede(e)) n = vI("count");
+        if (bhe(e)) n = e6("count");
         else {
             let a;
             if (!t.nofn)
-                if (Qhe(e)) a = e.op;
+                if (yhe(e)) a = e.op;
                 else {
                     const {
                         bin: o,
                         aggregate: l,
                         timeUnit: u
                     } = e;
-                    ot(o) ? (a = DI(o), r = (t.binSuffix ?? "") + (t.suffix ?? "")) : l ? oo(l) ? (s = `["${n}"]`, n = `argmax_${l.argmax}`) : Bs(l) ? (s = `["${n}"]`, n = `argmin_${l.argmin}`) : a = String(l) : u && (a = she(u), r = (!["range", "mid"].includes(t.binSuffix) && t.binSuffix || "") + (t.suffix ?? ""))
+                    yt(o) ? (a = m6(o), r = (t.binSuffix ?? "") + (t.suffix ?? "")) : l ? $o(l) ? (s = `["${n}"]`, n = `argmax_${l.argmax}`) : na(l) ? (s = `["${n}"]`, n = `argmin_${l.argmin}`) : a = String(l) : u && !ru(u) && (a = _fe(u), r = (!["range", "mid"].includes(t.binSuffix) && t.binSuffix || "") + (t.suffix ?? ""))
                 } a && (n = n ? `${a}_${n}` : a)
         }
-        return r && (n = `${n}_${r}`), i && (n = `${i}_${n}`), t.forAs ? SE(n) : t.expr ? pI(n, t.expr) + s : Pi(n) + s
+        return r && (n = `${n}_${r}`), i && (n = `${i}_${n}`), t.forAs ? hk(n) : t.expr ? JI(n, t.expr) + s : Ji(n) + s
     }
 
-    function j0(e) {
+    function w0(e) {
         switch (e.type) {
             case "nominal":
             case "ordinal":
             case "geojson":
                 return !0;
             case "quantitative":
-                return K(e) && !!e.bin;
+                return Z(e) && !!e.bin;
             case "temporal":
                 return !1
         }
-        throw new Error(WI(e.type))
+        throw new Error(C6(e.type))
     }
 
-    function Zhe(e) {
+    function vhe(e) {
         var t;
-        return Il(e) && ic((t = e.scale) == null ? void 0 : t.type)
+        return su(e) && Tc((t = e.scale) == null ? void 0 : t.type)
     }
 
-    function ede(e) {
+    function bhe(e) {
         return e.aggregate === "count"
     }
 
-    function tde(e, t) {
+    function xhe(e, t) {
         var a;
         const {
             field: n,
             bin: i,
             timeUnit: r,
             aggregate: s
         } = e;
         if (s === "count") return t.countTitle;
-        if (ot(i)) return `${n} (binned)`;
-        if (r) {
-            const o = (a = en(r)) == null ? void 0 : a.unit;
-            if (o) return `${n} (${M1(o).join("-")})`
-        } else if (s) return oo(s) ? `${n} for max ${s.argmax}` : Bs(s) ? `${n} for min ${s.argmin}` : `${$d(s)} of ${n}`;
+        if (yt(i)) return `${n} (binned)`;
+        if (r && !ru(r)) {
+            const o = (a = an(r)) == null ? void 0 : a.unit;
+            if (o) return `${n} (${ly(o).join("-")})`
+        } else if (s) return $o(s) ? `${n} for max ${s.argmax}` : na(s) ? `${n} for min ${s.argmin}` : `${ig(s)} of ${n}`;
         return n
     }
 
-    function nde(e) {
+    function _he(e) {
         const {
             aggregate: t,
             bin: n,
             timeUnit: i,
             field: r
         } = e;
-        if (oo(t)) return `${r} for argmax(${t.argmax})`;
-        if (Bs(t)) return `${r} for argmin(${t.argmin})`;
-        const s = en(i),
-            a = t || (s == null ? void 0 : s.unit) || (s == null ? void 0 : s.maxbins) && "timeunit" || ot(n) && "bin";
+        if ($o(t)) return `${r} for argmax(${t.argmax})`;
+        if (na(t)) return `${r} for argmin(${t.argmin})`;
+        const s = i && !ru(i) ? an(i) : void 0,
+            a = t || (s == null ? void 0 : s.unit) || (s == null ? void 0 : s.maxbins) && "timeunit" || yt(n) && "bin";
         return a ? `${a.toUpperCase()}(${r})` : r
     }
-    const M6 = (e, t) => {
+    const g8 = (e, t) => {
         switch (t.fieldTitle) {
             case "plain":
                 return e.field;
             case "functional":
-                return nde(e);
+                return _he(e);
             default:
-                return tde(e, t)
+                return xhe(e, t)
         }
     };
-    let O6 = M6;
+    let p8 = g8;
 
-    function F6(e) {
-        O6 = e
+    function m8(e) {
+        p8 = e
     }
 
-    function ide() {
-        F6(M6)
+    function whe() {
+        m8(g8)
     }
 
-    function ku(e, t, {
+    function Ju(e, t, {
         allowDisabling: n,
         includeDefault: i = !0
     }) {
         var o;
-        const r = (o = nC(e)) == null ? void 0 : o.title;
-        if (!K(e)) return r ?? e.title;
+        const r = (o = Hk(e)) == null ? void 0 : o.title;
+        if (!Z(e)) return r ?? e.title;
         const s = e,
-            a = i ? iC(s, t) : void 0;
-        return n ? Ct(r, s.title, a) : r ?? s.title ?? a
+            a = i ? Yk(s, t) : void 0;
+        return n ? Gt(r, s.title, a) : r ?? s.title ?? a
     }
 
-    function nC(e) {
-        if (sc(e) && e.axis) return e.axis;
-        if ($6(e) && e.legend) return e.legend;
-        if (eC(e) && e.header) return e.header
+    function Hk(e) {
+        if (Oc(e) && e.axis) return e.axis;
+        if (h8(e) && e.legend) return e.legend;
+        if (Wk(e) && e.header) return e.header
     }
 
-    function iC(e, t) {
-        return O6(e, t)
+    function Yk(e, t) {
+        return p8(e, t)
     }
 
-    function U0(e) {
-        if (T6(e)) {
+    function S0(e) {
+        if (d8(e)) {
             const {
                 format: t,
                 formatType: n
             } = e;
             return {
                 format: t,
                 formatType: n
             }
         } else {
-            const t = nC(e) ?? {},
+            const t = Hk(e) ?? {},
                 {
                     format: n,
                     formatType: i
                 } = t;
             return {
                 format: n,
                 formatType: i
             }
         }
     }
 
-    function rde(e, t) {
+    function She(e, t) {
         var s;
         switch (t) {
             case "latitude":
             case "longitude":
                 return "quantitative";
             case "row":
             case "column":
             case "facet":
             case "shape":
             case "strokeDash":
                 return "nominal";
             case "order":
                 return "ordinal"
         }
-        if (tC(e) && W(e.sort)) return "ordinal";
+        if (qk(e) && H(e.sort)) return "ordinal";
         const {
             aggregate: n,
             bin: i,
             timeUnit: r
         } = e;
         if (r) return "temporal";
-        if (i || n && !oo(n) && !Bs(n)) return "quantitative";
-        if (Il(e) && ((s = e.scale) != null && s.type)) switch (X2[e.scale.type]) {
+        if (i || n && !$o(n) && !na(n)) return "quantitative";
+        if (su(e) && ((s = e.scale) != null && s.type)) switch (kx[e.scale.type]) {
             case "numeric":
             case "discretizing":
                 return "quantitative";
             case "time":
                 return "temporal"
         }
         return "nominal"
     }
 
-    function Kr(e) {
-        if (K(e)) return e;
-        if (I1(e)) return e.condition
+    function hs(e) {
+        if (Z(e)) return e;
+        if (my(e)) return e.condition
     }
 
-    function Mt(e) {
-        if (Ce(e)) return e;
-        if (Dd(e)) return e.condition
+    function Yt(e) {
+        if (De(e)) return e;
+        if (cg(e)) return e.condition
     }
 
-    function R6(e, t, n, i = {}) {
-        if (re(e) || Ze(e) || Za(e)) {
-            const r = re(e) ? "string" : Ze(e) ? "number" : "boolean";
-            return X(afe(t, r, e)), {
+    function y8(e, t, n, i = {}) {
+        if (le(e) || lt(e) || mo(e)) {
+            const r = le(e) ? "string" : lt(e) ? "number" : "boolean";
+            return J(Sce(t, r, e)), {
                 value: e
             }
         }
-        return Ce(e) ? G0(e, t, n, i) : Dd(e) ? {
+        return De(e) ? E0(e, t, n, i) : cg(e) ? {
             ...e,
-            condition: G0(e.condition, t, n, i)
+            condition: E0(e.condition, t, n, i)
         } : e
     }
 
-    function G0(e, t, n, i) {
-        if (T6(e)) {
+    function E0(e, t, n, i) {
+        if (d8(e)) {
             const {
                 format: r,
                 formatType: s,
                 ...a
             } = e;
-            if (gl(s) && !n.customFormatTypes) return X(O5(t)), G0(a, t, n, i)
+            if (Il(s) && !n.customFormatTypes) return J(Q5(t)), E0(a, t, n, i)
         } else {
-            const r = sc(e) ? "axis" : $6(e) ? "legend" : eC(e) ? "header" : null;
+            const r = Oc(e) ? "axis" : h8(e) ? "legend" : Wk(e) ? "header" : null;
             if (r && e[r]) {
                 const {
                     format: s,
                     formatType: a,
                     ...o
                 } = e[r];
-                if (gl(a) && !n.customFormatTypes) return X(O5(t)), G0({
+                if (Il(a) && !n.customFormatTypes) return J(Q5(t)), E0({
                     ...e,
                     [r]: o
                 }, t, n, i)
             }
         }
-        return K(e) ? rC(e, t, i) : sde(e)
+        return Z(e) ? Xk(e, t, i) : Ehe(e)
     }
 
-    function sde(e) {
+    function Ehe(e) {
         let t = e.type;
         if (t) return e;
         const {
             datum: n
         } = e;
-        return t = Ze(n) ? "quantitative" : re(n) ? "nominal" : Ll(n) ? "temporal" : void 0, {
+        return t = lt(n) ? "quantitative" : le(n) ? "nominal" : iu(n) ? "temporal" : void 0, {
             ...e,
             type: t
         }
     }
 
-    function rC(e, t, {
+    function Xk(e, t, {
         compositeMark: n = !1
     } = {}) {
         const {
             aggregate: i,
             timeUnit: r,
             bin: s,
             field: a
         } = e, o = {
             ...e
         };
-        if (!n && i && !OE(i) && !oo(i) && !Bs(i) && (X(lfe(i)), delete o.aggregate), r && (o.timeUnit = en(r)), a && (o.field = `${a}`), ot(s) && (o.bin = z1(s, t)), Xt(s) && !Wt(t) && X(jfe(t)), zn(o)) {
+        if (!n && i && !xk(i) && !$o(i) && !na(i) && (J(kce(i)), delete o.aggregate), r && (o.timeUnit = an(r)), a && (o.field = `${a}`), yt(s) && (o.bin = yy(s, t)), pn(s) && !cn(t) && J(rfe(t)), Jn(o)) {
             const {
                 type: l
-            } = o, u = fhe(l);
-            l !== u && (o.type = u), l !== "quantitative" && RI(i) && (X(ofe(l, i)), o.type = "quantitative")
-        } else if (!kI(t)) {
-            const l = rde(o, t);
+            } = o, u = Tfe(l);
+            l !== u && (o.type = u), l !== "quantitative" && p6(i) && (J(Ece(l, i)), o.type = "quantitative")
+        } else if (!l6(t)) {
+            const l = She(o, t);
             o.type = l
         }
-        if (zn(o)) {
+        if (Jn(o)) {
             const {
                 compatible: l,
                 warning: u
-            } = ade(o, t) || {};
-            l === !1 && X(u)
+            } = khe(o, t) || {};
+            l === !1 && J(u)
         }
-        if (tC(o) && re(o.sort)) {
+        if (qk(o) && le(o.sort)) {
             const {
                 sort: l
             } = o;
-            if (L5(l)) return {
+            if (rM(l)) return {
                 ...o,
                 sort: {
                     encoding: l
                 }
             };
             const u = l.substr(1);
-            if (l.charAt(0) === "-" && L5(u)) return {
+            if (l.charAt(0) === "-" && rM(u)) return {
                 ...o,
                 sort: {
                     encoding: u,
                     order: "descending"
                 }
             }
         }
-        if (eC(o)) {
+        if (Wk(o)) {
             const {
                 header: l
             } = o;
             if (l) {
                 const {
                     orient: u,
                     ...c
@@ -39175,141 +32477,142 @@
                     }
                 }
             }
         }
         return o
     }
 
-    function z1(e, t) {
-        return Za(e) ? {
-            maxbins: w5(t)
+    function yy(e, t) {
+        return mo(e) ? {
+            maxbins: U5(t)
         } : e === "binned" ? {
             binned: !0
         } : !e.maxbins && !e.step ? {
             ...e,
-            maxbins: w5(t)
+            maxbins: U5(t)
         } : e
     }
-    const eu = {
+    const Eu = {
         compatible: !0
     };
 
-    function ade(e, t) {
+    function khe(e, t) {
         const n = e.type;
         if (n === "geojson" && t !== "shape") return {
             compatible: !1,
             warning: `Channel ${t} should not be used with a geojson data.`
         };
         switch (t) {
-            case Fs:
-            case Rs:
-            case _1:
-                return j0(e) ? eu : {
+            case Vs:
+            case Ks:
+            case Z1:
+                return w0(e) ? Eu : {
                     compatible: !1,
-                    warning: dfe(t)
+                    warning: Mce(t)
                 };
-            case ht:
-            case Gt:
-            case no:
-            case Mc:
-            case si:
-            case os:
-            case ls:
-            case Td:
-            case Md:
-            case w1:
-            case ul:
-            case S1:
-            case E1:
+            case kt:
+            case un:
+            case So:
+            case nf:
+            case pi:
+            case _s:
+            case ws:
+            case rg:
+            case sg:
+            case ey:
             case Dl:
-            case zi:
-            case _r:
-            case C1:
-                return eu;
-            case Sr:
-            case Li:
-            case wr:
-            case Er:
-                return n !== hl ? {
+            case ty:
+            case ny:
+            case eu:
+            case nr:
+            case Nr:
+            case iy:
+                return Eu;
+            case Lr:
+            case Qi:
+            case Pr:
+            case Ir:
+                return n !== Pl ? {
                     compatible: !1,
                     warning: `Channel ${t} should be used with a quantitative field only, not ${e.type} field.`
-                } : eu;
-            case Js:
-            case io:
-            case ro:
-            case so:
-            case Ks:
-            case Vs:
-            case Xs:
-            case xr:
-            case as:
+                } : Eu;
+            case fa:
+            case Eo:
+            case ko:
+            case Co:
+            case ca:
+            case ua:
+            case la:
+            case Dr:
+            case xs:
                 return n === "nominal" && !e.sort ? {
                     compatible: !1,
                     warning: `Channel ${t} should not be used with an unsorted discrete field.`
-                } : eu;
-            case ai:
-            case ao:
-                return !j0(e) && !Zhe(e) ? {
+                } : Eu;
+            case mi:
+            case Ao:
+                return !w0(e) && !vhe(e) ? {
                     compatible: !1,
-                    warning: gfe(t)
-                } : eu;
-            case ec:
+                    warning: Oce(t)
+                } : Eu;
+            case Cc:
                 return e.type === "nominal" && !("sort" in e) ? {
                     compatible: !1,
                     warning: "Channel order is inappropriate for nominal field, which has no inherent order."
-                } : eu
+                } : Eu
         }
     }
 
-    function ac(e) {
+    function Fc(e) {
         const {
             formatType: t
-        } = U0(e);
-        return t === "time" || !t && ode(e)
+        } = S0(e);
+        return t === "time" || !t && Che(e)
     }
 
-    function ode(e) {
-        return e && (e.type === "temporal" || K(e) && !!e.timeUnit)
+    function Che(e) {
+        return e && (e.type === "temporal" || Z(e) && !!e.timeUnit)
     }
 
-    function B1(e, {
+    function vy(e, {
         timeUnit: t,
         type: n,
         wrapTime: i,
         undefinedIfExprNotRequired: r
     }) {
         var l;
-        const s = t && ((l = en(t)) == null ? void 0 : l.unit);
+        const s = t && ((l = an(t)) == null ? void 0 : l.unit);
         let a = s || n === "temporal",
             o;
-        return Fc(e) ? o = e.expr : he(e) ? o = e.signal : Ll(e) ? (a = !0, o = fl(e)) : (re(e) || Ze(e)) && a && (o = `datetime(${at(e)})`, Zfe(s) && (Ze(e) && e < 1e4 || re(e) && isNaN(Date.parse(e))) && (o = fl({
+        return ag(e) ? o = e.expr : xe(e) ? o = e.signal : iu(e) ? (a = !0, o = Nl(e)) : (le(e) || lt(e)) && a && (o = `datetime(${mt(e)})`, mfe(s) && (lt(e) && e < 1e4 || le(e) && isNaN(Date.parse(e))) && (o = Nl({
             [s]: e
-        }))), o ? i && a ? `time(${o})` : o : r ? void 0 : at(e)
+        }))), o ? i && a ? `time(${o})` : o : r ? void 0 : mt(e)
     }
 
-    function D6(e, t) {
+    function v8(e, t) {
         const {
             type: n
         } = e;
         return t.map(i => {
-            const r = B1(i, {
-                timeUnit: K(e) ? e.timeUnit : void 0,
-                type: n,
-                undefinedIfExprNotRequired: !0
-            });
-            return r !== void 0 ? {
-                signal: r
+            const r = Z(e) && !ru(e.timeUnit) ? e.timeUnit : void 0,
+                s = vy(i, {
+                    timeUnit: r,
+                    type: n,
+                    undefinedIfExprNotRequired: !0
+                });
+            return s !== void 0 ? {
+                signal: s
             } : i
         })
     }
 
-    function Nd(e, t) {
-        return ot(e.bin) ? Qs(t) && ["ordinal", "nominal"].includes(e.type) : (console.warn("Only call this method for binned field defs."), !1)
+    function fg(e, t) {
+        return yt(e.bin) ? ha(t) && ["ordinal", "nominal"].includes(e.type) : (console.warn("Only call this method for binned field defs."), !1)
     }
-    const B5 = {
+    const oM = {
         labelAlign: {
             part: "labels",
             vgProp: "align"
         },
         labelBaseline: {
             part: "labels",
             vgProp: "baseline"
@@ -39379,19 +32682,19 @@
         tickSize: null,
         tickWidth: {
             part: "ticks",
             vgProp: "strokeWidth"
         }
     };
 
-    function Pd(e) {
+    function hg(e) {
         return e == null ? void 0 : e.condition
     }
-    const N6 = ["domain", "grid", "labels", "ticks", "title"],
-        lde = {
+    const b8 = ["domain", "grid", "labels", "ticks", "title"],
+        Ahe = {
             grid: "grid",
             gridCap: "grid",
             gridColor: "grid",
             gridDash: "grid",
             gridDashOffset: "grid",
             gridOpacity: "grid",
             gridScale: "grid",
@@ -39464,15 +32767,15 @@
             tickBand: "both",
             tickCount: "both",
             tickExtra: "both",
             translate: "both",
             values: "both",
             zindex: "both"
         },
-        P6 = {
+        x8 = {
             orient: 1,
             aria: 1,
             bandPosition: 1,
             description: 1,
             domain: 1,
             domainCap: 1,
             domainColor: 1,
@@ -39542,25 +32845,25 @@
             titlePadding: 1,
             titleX: 1,
             titleY: 1,
             translate: 1,
             values: 1,
             zindex: 1
         },
-        ude = {
-            ...P6,
+        $he = {
+            ...x8,
             style: 1,
             labelExpr: 1,
             encoding: 1
         };
 
-    function j5(e) {
-        return !!ude[e]
+    function lM(e) {
+        return !!$he[e]
     }
-    const cde = {
+    const The = {
             axis: 1,
             axisBand: 1,
             axisBottom: 1,
             axisDiscrete: 1,
             axisLeft: 1,
             axisPoint: 1,
             axisQuantitative: 1,
@@ -39576,138 +32879,138 @@
             axisY: 1,
             axisYBand: 1,
             axisYDiscrete: 1,
             axisYPoint: 1,
             axisYQuantitative: 1,
             axisYTemporal: 1
         },
-        L6 = H(cde);
+        _8 = K(The);
 
-    function Zs(e) {
+    function da(e) {
         return "mark" in e
     }
-    class j1 {
+    class by {
         constructor(t, n) {
             this.name = t, this.run = n
         }
         hasMatchingType(t) {
-            return Zs(t) ? Bhe(t.mark) === this.name : !1
+            return da(t) ? rhe(t.mark) === this.name : !1
         }
     }
 
-    function Ho(e, t) {
+    function ml(e, t) {
         const n = e && e[t];
-        return n ? W(n) ? ol(n, i => !!i.field) : K(n) || I1(n) : !1
+        return n ? H(n) ? Fl(n, i => !!i.field) : Z(n) || my(n) : !1
     }
 
-    function I6(e, t) {
+    function w8(e, t) {
         const n = e && e[t];
-        return n ? W(n) ? ol(n, i => !!i.field) : K(n) || fs(n) || Dd(n) : !1
+        return n ? H(n) ? Fl(n, i => !!i.field) : Z(n) || ks(n) || cg(n) : !1
     }
 
-    function J2(e, t) {
-        if (Wt(t)) {
+    function $x(e, t) {
+        if (cn(t)) {
             const n = e[t];
-            if ((K(n) || fs(n)) && (r6(n.type) || K(n) && n.timeUnit)) {
-                const i = AE(t);
-                return I6(e, i)
+            if ((Z(n) || ks(n)) && (U6(n.type) || Z(n) && n.timeUnit)) {
+                const i = mk(t);
+                return w8(e, i)
             }
         }
         return !1
     }
 
-    function sC(e) {
-        return ol(dce, t => {
-            if (Ho(e, t)) {
+    function Vk(e) {
+        return Fl(Mue, t => {
+            if (ml(e, t)) {
                 const n = e[t];
-                if (W(n)) return ol(n, i => !!i.aggregate); {
-                    const i = Kr(n);
+                if (H(n)) return Fl(n, i => !!i.aggregate); {
+                    const i = hs(n);
                     return i && !!i.aggregate
                 }
             }
             return !1
         })
     }
 
-    function z6(e, t) {
+    function S8(e, t) {
         const n = [],
             i = [],
             r = [],
             s = [],
             a = {};
-        return aC(e, (o, l) => {
-            if (K(o)) {
+        return Kk(e, (o, l) => {
+            if (Z(o)) {
                 const {
                     field: u,
                     aggregate: c,
                     bin: f,
                     timeUnit: h,
                     ...d
                 } = o;
                 if (c || h || f) {
-                    const g = nC(o),
+                    const g = Hk(o),
                         p = g == null ? void 0 : g.title;
-                    let m = ie(o, {
+                    let m = oe(o, {
                         forAs: !0
                     });
                     const y = {
                         ...p ? [] : {
-                            title: ku(o, t, {
+                            title: Ju(o, t, {
                                 allowDisabling: !0
                             })
                         },
                         ...d,
                         field: m
                     };
                     if (c) {
                         let v;
-                        if (oo(c) ? (v = "argmax", m = ie({
+                        if ($o(c) ? (v = "argmax", m = oe({
                                 op: "argmax",
                                 field: c.argmax
                             }, {
                                 forAs: !0
-                            }), y.field = `${m}.${u}`) : Bs(c) ? (v = "argmin", m = ie({
+                            }), y.field = `${m}.${u}`) : na(c) ? (v = "argmin", m = oe({
                                 op: "argmin",
                                 field: c.argmin
                             }, {
                                 forAs: !0
                             }), y.field = `${m}.${u}`) : c !== "boxplot" && c !== "errorbar" && c !== "errorband" && (v = c), v) {
                             const b = {
                                 op: v,
                                 as: m
                             };
                             u && (b.field = u), s.push(b)
                         }
-                    } else if (n.push(m), zn(o) && ot(f)) {
+                    } else if (n.push(m), Jn(o) && yt(f)) {
                         if (i.push({
                                 bin: f,
                                 field: u,
                                 as: m
-                            }), n.push(ie(o, {
+                            }), n.push(oe(o, {
                                 binSuffix: "end"
-                            })), Nd(o, l) && n.push(ie(o, {
+                            })), fg(o, l) && n.push(oe(o, {
                                 binSuffix: "range"
-                            })), Wt(l)) {
+                            })), cn(l)) {
                             const v = {
                                 field: `${m}_end`
                             };
                             a[`${l}2`] = v
                         }
-                        y.bin = "binned", kI(l) || (y.type = hl)
-                    } else if (h) {
+                        y.bin = "binned", l6(l) || (y.type = Pl)
+                    } else if (h && !ru(h)) {
                         r.push({
                             timeUnit: h,
                             field: u,
                             as: m
                         });
-                        const v = zn(o) && o.type !== nc && "time";
-                        v && (l === Td || l === ul ? y.formatType = v : wce(l) ? y.legend = {
+                        const v = Jn(o) && o.type !== $c && "time";
+                        v && (l === rg || l === Dl ? y.formatType = v : zue(l) ? y.legend = {
                             formatType: v,
                             ...y.legend
-                        } : Wt(l) && (y.axis = {
+                        } : cn(l) && (y.axis = {
                             formatType: v,
                             ...y.axis
                         }))
                     }
                     a[l] = y
                 } else n.push(u), a[l] = e[l]
             } else a[l] = e[l]
@@ -39716,235 +33019,235 @@
             timeUnits: r,
             aggregate: s,
             groupby: n,
             encoding: a
         }
     }
 
-    function fde(e, t, n) {
-        const i = Ece(t, n);
+    function Mhe(e, t, n) {
+        const i = jue(t, n);
         if (i) {
             if (i === "binned") {
-                const r = e[t === xr ? ht : Gt];
-                return !!(K(r) && K(e[t]) && Xt(r.bin))
+                const r = e[t === Dr ? kt : un];
+                return !!(Z(r) && Z(e[t]) && pn(r.bin))
             }
         } else return !1;
         return !0
     }
 
-    function hde(e, t, n, i) {
+    function Ohe(e, t, n, i) {
         const r = {};
-        for (const s of H(e)) CI(s) || X(hfe(s));
-        for (let s of vce) {
+        for (const s of K(e)) o6(s) || J(Tce(s));
+        for (let s of Nue) {
             if (!e[s]) continue;
             const a = e[s];
-            if (Oc(s)) {
-                const o = $I(s),
+            if (rf(s)) {
+                const o = c6(s),
                     l = r[o];
-                if (K(l)) {
-                    if (che(l.type) && K(a) && !l.timeUnit) {
-                        X(rfe(o));
+                if (Z(l)) {
+                    if ($fe(l.type) && Z(a) && !l.timeUnit) {
+                        J(_ce(o));
                         continue
                     }
-                } else s = o, X(sfe(o))
+                } else s = o, J(wce(o))
             }
-            if (s === "angle" && t === "arc" && !e.theta && (X(ife), s = zi), !fde(e, s, t)) {
-                X(T1(s, t));
+            if (s === "angle" && t === "arc" && !e.theta && (J(xce), s = nr), !Mhe(e, s, t)) {
+                J(oy(s, t));
                 continue
             }
-            if (s === Ks && t === "line") {
-                const o = Kr(e[s]);
+            if (s === ca && t === "line") {
+                const o = hs(e[s]);
                 if (o != null && o.aggregate) {
-                    X(cfe);
+                    J(Ace);
                     continue
                 }
             }
-            if (s === si && (n ? "fill" in e : "stroke" in e)) {
-                X(qI("encoding", {
+            if (s === pi && (n ? "fill" in e : "stroke" in e)) {
+                J(A6("encoding", {
                     fill: "fill" in e,
                     stroke: "stroke" in e
                 }));
                 continue
             }
-            if (s === Md || s === ec && !W(a) && !gr(a) || s === ul && W(a)) {
+            if (s === sg || s === Cc && !H(a) && !Tr(a) || s === Dl && H(a)) {
                 if (a) {
-                    if (s === ec) {
+                    if (s === Cc) {
                         const o = e[s];
-                        if (A6(o)) {
+                        if (f8(o)) {
                             r[s] = o;
                             continue
                         }
                     }
-                    r[s] = se(a).reduce((o, l) => (K(l) ? o.push(rC(l, s)) : X(Y2(l, s)), o), [])
+                    r[s] = ue(a).reduce((o, l) => (Z(l) ? o.push(Xk(l, s)) : J(Ex(l, s)), o), [])
                 }
             } else {
-                if (s === ul && a === null) r[s] = null;
-                else if (!K(a) && !fs(a) && !gr(a) && !L1(a) && !he(a)) {
-                    X(Y2(a, s));
+                if (s === Dl && a === null) r[s] = null;
+                else if (!Z(a) && !ks(a) && !Tr(a) && !py(a) && !xe(a)) {
+                    J(Ex(a, s));
                     continue
                 }
-                r[s] = R6(a, s, i)
+                r[s] = y8(a, s, i)
             }
         }
         return r
     }
 
-    function U1(e, t) {
+    function xy(e, t) {
         const n = {};
-        for (const i of H(e)) {
-            const r = R6(e[i], i, t, {
+        for (const i of K(e)) {
+            const r = y8(e[i], i, t, {
                 compositeMark: !0
             });
             n[i] = r
         }
         return n
     }
 
-    function dde(e) {
+    function Fhe(e) {
         const t = [];
-        for (const n of H(e))
-            if (Ho(e, n)) {
+        for (const n of K(e))
+            if (ml(e, n)) {
                 const i = e[n],
-                    r = se(i);
-                for (const s of r) K(s) ? t.push(s) : I1(s) && t.push(s.condition)
+                    r = ue(i);
+                for (const s of r) Z(s) ? t.push(s) : my(s) && t.push(s.condition)
             } return t
     }
 
-    function aC(e, t, n) {
+    function Kk(e, t, n) {
         if (e)
-            for (const i of H(e)) {
+            for (const i of K(e)) {
                 const r = e[i];
-                if (W(r))
+                if (H(r))
                     for (const s of r) t.call(n, s, i);
                 else t.call(n, r, i)
             }
     }
 
-    function gde(e, t, n, i) {
-        return e ? H(e).reduce((r, s) => {
+    function Rhe(e, t, n, i) {
+        return e ? K(e).reduce((r, s) => {
             const a = e[s];
-            return W(a) ? a.reduce((o, l) => t.call(i, o, l, s), r) : t.call(i, r, a, s)
+            return H(a) ? a.reduce((o, l) => t.call(i, o, l, s), r) : t.call(i, r, a, s)
         }, n) : n
     }
 
-    function B6(e, t) {
-        return H(t).reduce((n, i) => {
+    function E8(e, t) {
+        return K(t).reduce((n, i) => {
             switch (i) {
-                case ht:
-                case Gt:
-                case S1:
-                case C1:
-                case E1:
-                case xr:
-                case as:
-                case no:
-                case Mc:
-                case zi:
-                case Vs:
-                case _r:
-                case Xs:
-                case wr:
-                case Sr:
-                case Er:
-                case Li:
-                case Td:
-                case ai:
+                case kt:
+                case un:
+                case ty:
+                case iy:
+                case ny:
+                case Dr:
+                case xs:
+                case So:
+                case nf:
+                case nr:
+                case ua:
+                case Nr:
+                case la:
+                case Pr:
+                case Lr:
+                case Ir:
+                case Qi:
+                case rg:
+                case mi:
+                case eu:
                 case Dl:
-                case ul:
                     return n;
-                case ec:
+                case Cc:
                     if (e === "line" || e === "trail") return n;
-                case Md:
-                case w1: {
+                case sg:
+                case ey: {
                     const r = t[i];
-                    if (W(r) || K(r))
-                        for (const s of se(r)) s.aggregate || n.push(ie(s, {}));
+                    if (H(r) || Z(r))
+                        for (const s of ue(r)) s.aggregate || n.push(oe(s, {}));
                     return n
                 }
-                case Ks:
+                case ca:
                     if (e === "trail") return n;
-                case si:
-                case os:
-                case ls:
-                case Js:
-                case io:
-                case ro:
-                case ao:
-                case so: {
-                    const r = Kr(t[i]);
-                    return r && !r.aggregate && n.push(ie(r, {})), n
+                case pi:
+                case _s:
+                case ws:
+                case fa:
+                case Eo:
+                case ko:
+                case Ao:
+                case Co: {
+                    const r = hs(t[i]);
+                    return r && !r.aggregate && n.push(oe(r, {})), n
                 }
             }
         }, [])
     }
 
-    function pde(e) {
+    function Dhe(e) {
         const {
             tooltip: t,
             ...n
         } = e;
         if (!t) return {
             filteredEncoding: n
         };
         let i, r;
-        if (W(t)) {
+        if (H(t)) {
             for (const s of t) s.aggregate ? (i || (i = []), i.push(s)) : (r || (r = []), r.push(s));
             i && (n.tooltip = i)
         } else t.aggregate ? n.tooltip = t : r = t;
-        return W(r) && r.length === 1 && (r = r[0]), {
+        return H(r) && r.length === 1 && (r = r[0]), {
             customTooltipWithoutAggregatedField: r,
             filteredEncoding: n
         }
     }
 
-    function Q2(e, t, n, i = !0) {
+    function Tx(e, t, n, i = !0) {
         if ("tooltip" in n) return {
             tooltip: n.tooltip
         };
         const r = e.map(({
                 fieldPrefix: a,
                 titlePrefix: o
             }) => {
-                const l = i ? ` of ${oC(t)}` : "";
+                const l = i ? ` of ${Jk(t)}` : "";
                 return {
                     field: a + t.field,
                     type: t.type,
-                    title: he(o) ? {
+                    title: xe(o) ? {
                         signal: `${o}"${escape(l)}"`
                     } : o + l
                 }
             }),
-            s = dde(n).map(Jhe);
+            s = Fhe(n).map(mhe);
         return {
-            tooltip: [...r, ...Pr(s, Ne)]
+            tooltip: [...r, ...Qr(s, ze)]
         }
     }
 
-    function oC(e) {
+    function Jk(e) {
         const {
             title: t,
             field: n
         } = e;
-        return Ct(t, n)
+        return Gt(t, n)
     }
 
-    function lC(e, t, n, i, r) {
+    function Qk(e, t, n, i, r) {
         const {
             scale: s,
             axis: a
         } = n;
         return ({
             partName: o,
             mark: l,
             positionPrefix: u,
             endPositionPrefix: c = void 0,
             extraEncoding: f = {}
         }) => {
-            const h = oC(n);
-            return j6(e, o, r, {
+            const h = Jk(n);
+            return k8(e, o, r, {
                 mark: l,
                 encoding: {
                     [t]: {
                         field: `${u}_${n.field}`,
                         type: n.type,
                         ...h !== void 0 ? {
                             title: h
@@ -39952,27 +33255,27 @@
                         ...s !== void 0 ? {
                             scale: s
                         } : {},
                         ...a !== void 0 ? {
                             axis: a
                         } : {}
                     },
-                    ...re(c) ? {
+                    ...le(c) ? {
                         [`${t}2`]: {
                             field: `${c}_${n.field}`
                         }
                     } : {},
                     ...i,
                     ...f
                 }
             })
         }
     }
 
-    function j6(e, t, n, i) {
+    function k8(e, t, n, i) {
         const {
             clip: r,
             color: s,
             opacity: a
         } = e, o = e.type;
         return e[t] || e[t] === void 0 && n[t] ? [{
             ...i,
@@ -39983,127 +33286,127 @@
                 } : {},
                 ...s ? {
                     color: s
                 } : {},
                 ...a ? {
                     opacity: a
                 } : {},
-                ...Vr(i.mark) ? i.mark : {
+                ...fs(i.mark) ? i.mark : {
                     type: i.mark
                 },
                 style: `${o}-${String(t)}`,
-                ...Za(e[t]) ? {} : e[t]
+                ...mo(e[t]) ? {} : e[t]
             }
         }] : []
     }
 
-    function U6(e, t, n) {
+    function C8(e, t, n) {
         const {
             encoding: i
         } = e, r = t === "vertical" ? "y" : "x", s = i[r], a = i[`${r}2`], o = i[`${r}Error`], l = i[`${r}Error2`];
         return {
-            continuousAxisChannelDef: $g(s, n),
-            continuousAxisChannelDef2: $g(a, n),
-            continuousAxisChannelDefError: $g(o, n),
-            continuousAxisChannelDefError2: $g(l, n),
+            continuousAxisChannelDef: Xg(s, n),
+            continuousAxisChannelDef2: Xg(a, n),
+            continuousAxisChannelDefError: Xg(o, n),
+            continuousAxisChannelDefError2: Xg(l, n),
             continuousAxis: r
         }
     }
 
-    function $g(e, t) {
+    function Xg(e, t) {
         if (e != null && e.aggregate) {
             const {
                 aggregate: n,
                 ...i
             } = e;
-            return n !== t && X(Bfe(n, t)), i
+            return n !== t && J(ife(n, t)), i
         } else return e
     }
 
-    function G6(e, t) {
+    function A8(e, t) {
         const {
             mark: n,
             encoding: i
         } = e, {
             x: r,
             y: s
         } = i;
-        if (Vr(n) && n.orient) return n.orient;
-        if (_a(r)) {
-            if (_a(s)) {
-                const a = K(r) && r.aggregate,
-                    o = K(s) && s.aggregate;
+        if (fs(n) && n.orient) return n.orient;
+        if (Ba(r)) {
+            if (Ba(s)) {
+                const a = Z(r) && r.aggregate,
+                    o = Z(s) && s.aggregate;
                 if (!a && o === t) return "vertical";
                 if (!o && a === t) return "horizontal";
                 if (a === t && o === t) throw new Error("Both x and y cannot have aggregate");
-                return ac(s) && !ac(r) ? "horizontal" : "vertical"
+                return Fc(s) && !Fc(r) ? "horizontal" : "vertical"
             }
             return "horizontal"
         } else {
-            if (_a(s)) return "vertical";
+            if (Ba(s)) return "vertical";
             throw new Error(`Need a valid continuous axis for ${t}s`)
         }
     }
-    const W0 = "boxplot",
-        mde = ["box", "median", "outliers", "rule", "ticks"],
-        yde = new j1(W0, q6);
+    const k0 = "boxplot",
+        Nhe = ["box", "median", "outliers", "rule", "ticks"],
+        Phe = new by(k0, T8);
 
-    function W6(e) {
-        return Ze(e) ? "tukey" : e
+    function $8(e) {
+        return lt(e) ? "tukey" : e
     }
 
-    function q6(e, {
+    function T8(e, {
         config: t
     }) {
         e = {
             ...e,
-            encoding: U1(e.encoding, t)
+            encoding: xy(e.encoding, t)
         };
         const {
             mark: n,
             encoding: i,
             params: r,
             projection: s,
             ...a
-        } = e, o = Vr(n) ? n : {
+        } = e, o = fs(n) ? n : {
             type: n
         };
-        r && X(GI("boxplot"));
+        r && J(k6("boxplot"));
         const l = o.extent ?? t.boxplot.extent,
-            u = Xe("size", o, t),
+            u = st("size", o, t),
             c = o.invalid,
-            f = W6(l),
+            f = $8(l),
             {
                 bins: h,
                 timeUnits: d,
                 transform: g,
                 continuousAxisChannelDef: p,
                 continuousAxis: m,
                 groupby: y,
                 aggregate: v,
                 encodingWithoutContinuousAxis: b,
                 ticksOrient: x,
                 boxOrient: _,
                 customTooltipWithoutAggregatedField: S
-            } = vde(e, l, t),
+            } = Lhe(e, l, t),
             {
                 color: w,
                 size: E,
-                ...A
+                ...C
             } = b,
-            C = Sn => lC(o, m, p, Sn, t.boxplot),
-            k = C(A),
-            R = C(b),
-            $ = C({
-                ...A,
+            k = dn => Qk(o, m, p, dn, t.boxplot),
+            A = k(C),
+            F = k(b),
+            $ = k({
+                ...C,
                 ...E ? {
                     size: E
                 } : {}
             }),
-            T = Q2([{
+            T = Tx([{
                 fieldPrefix: f === "min-max" ? "upper_whisker_" : "max_",
                 titlePrefix: "Max"
             }, {
                 fieldPrefix: "upper_box_",
                 titlePrefix: "Q3"
             }, {
                 fieldPrefix: "mid_box_",
@@ -40119,53 +33422,53 @@
                 type: "tick",
                 color: "black",
                 opacity: 1,
                 orient: x,
                 invalid: c,
                 aria: !1
             },
-            F = f === "min-max" ? T : Q2([{
+            R = f === "min-max" ? T : Tx([{
                 fieldPrefix: "upper_whisker_",
                 titlePrefix: "Upper Whisker"
             }, {
                 fieldPrefix: "lower_whisker_",
                 titlePrefix: "Lower Whisker"
             }], p, b),
-            N = [...k({
+            N = [...A({
                 partName: "rule",
                 mark: {
                     type: "rule",
                     invalid: c,
                     aria: !1
                 },
                 positionPrefix: "lower_whisker",
                 endPositionPrefix: "lower_box",
-                extraEncoding: F
-            }), ...k({
+                extraEncoding: R
+            }), ...A({
                 partName: "rule",
                 mark: {
                     type: "rule",
                     invalid: c,
                     aria: !1
                 },
                 positionPrefix: "upper_box",
                 endPositionPrefix: "upper_whisker",
-                extraEncoding: F
-            }), ...k({
+                extraEncoding: R
+            }), ...A({
                 partName: "ticks",
                 mark: M,
                 positionPrefix: "lower_whisker",
-                extraEncoding: F
-            }), ...k({
+                extraEncoding: R
+            }), ...A({
                 partName: "ticks",
                 mark: M,
                 positionPrefix: "upper_whisker",
-                extraEncoding: F
+                extraEncoding: R
             })],
-            P = [...f !== "tukey" ? N : [], ...R({
+            L = [...f !== "tukey" ? N : [], ...F({
                 partName: "box",
                 mark: {
                     type: "bar",
                     ...u ? {
                         size: u
                     } : {},
                     orient: _,
@@ -40176,44 +33479,44 @@
                 endPositionPrefix: "upper_box",
                 extraEncoding: T
             }), ...$({
                 partName: "median",
                 mark: {
                     type: "tick",
                     invalid: c,
-                    ...ae(t.boxplot.median) && t.boxplot.median.color ? {
+                    ...ce(t.boxplot.median) && t.boxplot.median.color ? {
                         color: t.boxplot.median.color
                     } : {},
                     ...u ? {
                         size: u
                     } : {},
                     orient: x,
                     aria: !1
                 },
                 positionPrefix: "mid_box",
                 extraEncoding: T
             })];
         if (f === "min-max") return {
             ...a,
             transform: (a.transform ?? []).concat(g),
-            layer: P
+            layer: L
         };
-        const z = `datum["lower_box_${p.field}"]`,
-            I = `datum["upper_box_${p.field}"]`,
-            Q = `(${I} - ${z})`,
-            oe = `${z} - ${l} * ${Q}`,
-            Se = `${I} + ${l} * ${Q}`,
-            ye = `datum["${p.field}"]`,
-            Pe = {
-                joinaggregate: H6(p.field),
+        const I = `datum["lower_box_${p.field}"]`,
+            G = `datum["upper_box_${p.field}"]`,
+            ie = `(${G} - ${I})`,
+            ge = `${I} - ${l} * ${ie}`,
+            Re = `${G} + ${l} * ${ie}`,
+            Te = `datum["${p.field}"]`,
+            tt = {
+                joinaggregate: M8(p.field),
                 groupby: y
             },
-            xt = {
+            wn = {
                 transform: [{
-                    filter: `(${oe} <= ${ye}) && (${ye} <= ${Se})`
+                    filter: `(${ge} <= ${Te}) && (${Te} <= ${Re})`
                 }, {
                     aggregate: [{
                         op: "min",
                         field: p.field,
                         as: `lower_whisker_${p.field}`
                     }, {
                         op: "max",
@@ -40229,86 +33532,86 @@
                         as: `upper_box_${p.field}`
                     }, ...v],
                     groupby: y
                 }],
                 layer: N
             },
             {
-                tooltip: rn,
-                ...Un
-            } = A,
+                tooltip: Pi,
+                ...xi
+            } = C,
             {
-                scale: Y,
-                axis: ue
+                scale: ae,
+                axis: _e
             } = p,
-            be = oC(p),
-            q = Jn(ue, ["title"]),
-            ze = j6(o, "outliers", t.boxplot, {
+            Ae = Jk(p),
+            Y = li(_e, ["title"]),
+            je = k8(o, "outliers", t.boxplot, {
                 transform: [{
-                    filter: `(${ye} < ${oe}) || (${ye} > ${Se})`
+                    filter: `(${Te} < ${ge}) || (${Te} > ${Re})`
                 }],
                 mark: "point",
                 encoding: {
                     [m]: {
                         field: p.field,
                         type: p.type,
-                        ...be !== void 0 ? {
-                            title: be
+                        ...Ae !== void 0 ? {
+                            title: Ae
                         } : {},
-                        ...Y !== void 0 ? {
-                            scale: Y
+                        ...ae !== void 0 ? {
+                            scale: ae
                         } : {},
-                        ...et(q) ? {} : {
-                            axis: q
+                        ...ft(Y) ? {} : {
+                            axis: Y
                         }
                     },
-                    ...Un,
+                    ...xi,
                     ...w ? {
                         color: w
                     } : {},
                     ...S ? {
                         tooltip: S
                     } : {}
                 }
             })[0];
-        let fe;
-        const Be = [...h, ...d, Pe];
-        return ze ? fe = {
-            transform: Be,
-            layer: [ze, xt]
-        } : (fe = xt, fe.transform.unshift(...Be)), {
+        let be;
+        const qe = [...h, ...d, tt];
+        return je ? be = {
+            transform: qe,
+            layer: [je, wn]
+        } : (be = wn, be.transform.unshift(...qe)), {
             ...a,
-            layer: [fe, {
+            layer: [be, {
                 transform: g,
-                layer: P
+                layer: L
             }]
         }
     }
 
-    function H6(e) {
+    function M8(e) {
         return [{
             op: "q1",
             field: e,
             as: `lower_box_${e}`
         }, {
             op: "q3",
             field: e,
             as: `upper_box_${e}`
         }]
     }
 
-    function vde(e, t, n) {
-        const i = G6(e, W0),
+    function Lhe(e, t, n) {
+        const i = A8(e, k0),
             {
                 continuousAxisChannelDef: r,
                 continuousAxis: s
-            } = U6(e, i, W0),
+            } = C8(e, i, k0),
             a = r.field,
-            o = W6(t),
-            l = [...H6(a), {
+            o = $8(t),
+            l = [...M8(a), {
                 op: "median",
                 field: a,
                 as: `mid_box_${a}`
             }, {
                 op: "min",
                 field: a,
                 as: (o === "min-max" ? "lower_whisker_" : "min_") + a
@@ -40330,22 +33633,22 @@
             {
                 [s]: c,
                 ...f
             } = e.encoding,
             {
                 customTooltipWithoutAggregatedField: h,
                 filteredEncoding: d
-            } = pde(f),
+            } = Dhe(f),
             {
                 bins: g,
                 timeUnits: p,
                 aggregate: m,
                 groupby: y,
                 encoding: v
-            } = z6(d, n),
+            } = S8(d, n),
             b = i === "vertical" ? "horizontal" : "vertical",
             x = i,
             _ = [...g, ...p, {
                 aggregate: [...m, ...l],
                 groupby: y
             }, ...u];
         return {
@@ -40358,37 +33661,37 @@
             continuousAxis: s,
             encodingWithoutContinuousAxis: v,
             ticksOrient: b,
             boxOrient: x,
             customTooltipWithoutAggregatedField: h
         }
     }
-    const uC = "errorbar",
-        bde = ["ticks", "rule"],
-        xde = new j1(uC, Y6);
+    const Zk = "errorbar",
+        Ihe = ["ticks", "rule"],
+        zhe = new by(Zk, O8);
 
-    function Y6(e, {
+    function O8(e, {
         config: t
     }) {
         e = {
             ...e,
-            encoding: U1(e.encoding, t)
+            encoding: xy(e.encoding, t)
         };
         const {
             transform: n,
             continuousAxisChannelDef: i,
             continuousAxis: r,
             encodingWithoutContinuousAxis: s,
             ticksOrient: a,
             markDef: o,
             outerSpec: l,
             tooltipEncoding: u
-        } = X6(e, uC, t);
+        } = F8(e, Zk, t);
         delete s.size;
-        const c = lC(o, r, i, s, t.errorbar),
+        const c = Qk(o, r, i, s, t.errorbar),
             f = o.thickness,
             h = o.size,
             d = {
                 type: "tick",
                 orient: a,
                 aria: !1,
                 ...f !== void 0 ? {
@@ -40428,145 +33731,145 @@
                 layer: g
             } : {
                 ...g[0]
             }
         }
     }
 
-    function _de(e, t) {
+    function Bhe(e, t) {
         const {
             encoding: n
         } = e;
-        if (wde(n)) return {
-            orient: G6(e, t),
+        if (jhe(n)) return {
+            orient: A8(e, t),
             inputType: "raw"
         };
-        const i = Sde(n),
-            r = Ede(n),
+        const i = Ghe(n),
+            r = Uhe(n),
             s = n.x,
             a = n.y;
         if (i) {
             if (r) throw new Error(`${t} cannot be both type aggregated-upper-lower and aggregated-error`);
             const o = n.x2,
                 l = n.y2;
-            if (Ce(o) && Ce(l)) throw new Error(`${t} cannot have both x2 and y2`);
-            if (Ce(o)) {
-                if (_a(s)) return {
+            if (De(o) && De(l)) throw new Error(`${t} cannot have both x2 and y2`);
+            if (De(o)) {
+                if (Ba(s)) return {
                     orient: "horizontal",
                     inputType: "aggregated-upper-lower"
                 };
                 throw new Error(`Both x and x2 have to be quantitative in ${t}`)
-            } else if (Ce(l)) {
-                if (_a(a)) return {
+            } else if (De(l)) {
+                if (Ba(a)) return {
                     orient: "vertical",
                     inputType: "aggregated-upper-lower"
                 };
                 throw new Error(`Both y and y2 have to be quantitative in ${t}`)
             }
             throw new Error("No ranged axis")
         } else {
             const o = n.xError,
                 l = n.xError2,
                 u = n.yError,
                 c = n.yError2;
-            if (Ce(l) && !Ce(o)) throw new Error(`${t} cannot have xError2 without xError`);
-            if (Ce(c) && !Ce(u)) throw new Error(`${t} cannot have yError2 without yError`);
-            if (Ce(o) && Ce(u)) throw new Error(`${t} cannot have both xError and yError with both are quantiative`);
-            if (Ce(o)) {
-                if (_a(s)) return {
+            if (De(l) && !De(o)) throw new Error(`${t} cannot have xError2 without xError`);
+            if (De(c) && !De(u)) throw new Error(`${t} cannot have yError2 without yError`);
+            if (De(o) && De(u)) throw new Error(`${t} cannot have both xError and yError with both are quantiative`);
+            if (De(o)) {
+                if (Ba(s)) return {
                     orient: "horizontal",
                     inputType: "aggregated-error"
                 };
                 throw new Error("All x, xError, and xError2 (if exist) have to be quantitative")
-            } else if (Ce(u)) {
-                if (_a(a)) return {
+            } else if (De(u)) {
+                if (Ba(a)) return {
                     orient: "vertical",
                     inputType: "aggregated-error"
                 };
                 throw new Error("All y, yError, and yError2 (if exist) have to be quantitative")
             }
             throw new Error("No ranged axis")
         }
     }
 
-    function wde(e) {
-        return (Ce(e.x) || Ce(e.y)) && !Ce(e.x2) && !Ce(e.y2) && !Ce(e.xError) && !Ce(e.xError2) && !Ce(e.yError) && !Ce(e.yError2)
+    function jhe(e) {
+        return (De(e.x) || De(e.y)) && !De(e.x2) && !De(e.y2) && !De(e.xError) && !De(e.xError2) && !De(e.yError) && !De(e.yError2)
     }
 
-    function Sde(e) {
-        return Ce(e.x2) || Ce(e.y2)
+    function Ghe(e) {
+        return De(e.x2) || De(e.y2)
     }
 
-    function Ede(e) {
-        return Ce(e.xError) || Ce(e.xError2) || Ce(e.yError) || Ce(e.yError2)
+    function Uhe(e) {
+        return De(e.xError) || De(e.xError2) || De(e.yError) || De(e.yError2)
     }
 
-    function X6(e, t, n) {
+    function F8(e, t, n) {
         const {
             mark: i,
             encoding: r,
             params: s,
             projection: a,
             ...o
-        } = e, l = Vr(i) ? i : {
+        } = e, l = fs(i) ? i : {
             type: i
         };
-        s && X(GI(t));
+        s && J(k6(t));
         const {
             orient: u,
             inputType: c
-        } = _de(e, t), {
+        } = Bhe(e, t), {
             continuousAxisChannelDef: f,
             continuousAxisChannelDef2: h,
             continuousAxisChannelDefError: d,
             continuousAxisChannelDefError2: g,
             continuousAxis: p
-        } = U6(e, u, t), {
+        } = C8(e, u, t), {
             errorBarSpecificAggregate: m,
             postAggregateCalculates: y,
             tooltipSummary: v,
             tooltipTitleWithFieldName: b
-        } = Cde(l, f, h, d, g, c, t, n), {
+        } = Whe(l, f, h, d, g, c, t, n), {
             [p]: x,
             [p === "x" ? "x2" : "y2"]: _,
             [p === "x" ? "xError" : "yError"]: S,
             [p === "x" ? "xError2" : "yError2"]: w,
             ...E
         } = r, {
-            bins: A,
-            timeUnits: C,
-            aggregate: k,
-            groupby: R,
+            bins: C,
+            timeUnits: k,
+            aggregate: A,
+            groupby: F,
             encoding: $
-        } = z6(E, n), T = [...k, ...m], M = c !== "raw" ? [] : R, F = Q2(v, f, $, b);
+        } = S8(E, n), T = [...A, ...m], M = c !== "raw" ? [] : F, R = Tx(v, f, $, b);
         return {
-            transform: [...o.transform ?? [], ...A, ...C, ...T.length === 0 ? [] : [{
+            transform: [...o.transform ?? [], ...C, ...k, ...T.length === 0 ? [] : [{
                 aggregate: T,
                 groupby: M
             }], ...y],
             groupby: M,
             continuousAxisChannelDef: f,
             continuousAxis: p,
             encodingWithoutContinuousAxis: $,
             ticksOrient: u === "vertical" ? "horizontal" : "vertical",
             markDef: l,
             outerSpec: o,
-            tooltipEncoding: F
+            tooltipEncoding: R
         }
     }
 
-    function Cde(e, t, n, i, r, s, a, o) {
+    function Whe(e, t, n, i, r, s, a, o) {
         let l = [],
             u = [];
         const c = t.field;
         let f, h = !1;
         if (s === "raw") {
             const d = e.center ? e.center : e.extent ? e.extent === "iqr" ? "median" : "mean" : o.errorbar.center,
                 g = e.extent ? e.extent : d === "mean" ? "stderr" : "iqr";
-            if (d === "median" != (g === "iqr") && X(zfe(d, g, a)), g === "stderr" || g === "stdev") l = [{
+            if (d === "median" != (g === "iqr") && J(nfe(d, g, a)), g === "stderr" || g === "stdev") l = [{
                 op: g,
                 field: c,
                 as: `extent_${c}`
             }, {
                 op: d,
                 field: c,
                 as: `center_${c}`
@@ -40574,21 +33877,21 @@
                 calculate: `datum["center_${c}"] + datum["extent_${c}"]`,
                 as: `upper_${c}`
             }, {
                 calculate: `datum["center_${c}"] - datum["extent_${c}"]`,
                 as: `lower_${c}`
             }], f = [{
                 fieldPrefix: "center_",
-                titlePrefix: $d(d)
+                titlePrefix: ig(d)
             }, {
                 fieldPrefix: "upper_",
-                titlePrefix: U5(d, g, "+")
+                titlePrefix: uM(d, g, "+")
             }, {
                 fieldPrefix: "lower_",
-                titlePrefix: U5(d, g, "-")
+                titlePrefix: uM(d, g, "-")
             }], h = !0;
             else {
                 let p, m, y;
                 g === "ci" ? (p = "mean", m = "ci0", y = "ci1") : (p = "median", m = "q1", y = "q3"), l = [{
                     op: m,
                     field: c,
                     as: `lower_${c}`
@@ -40598,43 +33901,43 @@
                     as: `upper_${c}`
                 }, {
                     op: p,
                     field: c,
                     as: `center_${c}`
                 }], f = [{
                     fieldPrefix: "upper_",
-                    titlePrefix: ku({
+                    titlePrefix: Ju({
                         field: c,
                         aggregate: y,
                         type: "quantitative"
                     }, o, {
                         allowDisabling: !1
                     })
                 }, {
                     fieldPrefix: "lower_",
-                    titlePrefix: ku({
+                    titlePrefix: Ju({
                         field: c,
                         aggregate: m,
                         type: "quantitative"
                     }, o, {
                         allowDisabling: !1
                     })
                 }, {
                     fieldPrefix: "center_",
-                    titlePrefix: ku({
+                    titlePrefix: Ju({
                         field: c,
                         aggregate: p,
                         type: "quantitative"
                     }, o, {
                         allowDisabling: !1
                     })
                 }]
             }
         } else {
-            (e.center || e.extent) && X(Ife(e.center, e.extent)), s === "aggregated-upper-lower" ? (f = [], u = [{
+            (e.center || e.extent) && J(tfe(e.center, e.extent)), s === "aggregated-upper-lower" ? (f = [], u = [{
                 calculate: `datum["${n.field}"]`,
                 as: `upper_${c}`
             }, {
                 calculate: `datum["${c}"]`,
                 as: `lower_${c}`
             }]) : s === "aggregated-error" && (f = [{
                 fieldPrefix: "",
@@ -40647,48 +33950,48 @@
                 as: `lower_${c}`
             }) : u.push({
                 calculate: `datum["${c}"] - datum["${i.field}"]`,
                 as: `lower_${c}`
             }));
             for (const d of u) f.push({
                 fieldPrefix: d.as.substring(0, 6),
-                titlePrefix: ll(ll(d.calculate, 'datum["', ""), '"]', "")
+                titlePrefix: Rl(Rl(d.calculate, 'datum["', ""), '"]', "")
             })
         }
         return {
             postAggregateCalculates: u,
             errorBarSpecificAggregate: l,
             tooltipSummary: f,
             tooltipTitleWithFieldName: h
         }
     }
 
-    function U5(e, t, n) {
-        return `${$d(e)} ${n} ${t}`
+    function uM(e, t, n) {
+        return `${ig(e)} ${n} ${t}`
     }
-    const cC = "errorband",
-        kde = ["band", "borders"],
-        Ade = new j1(cC, V6);
+    const eC = "errorband",
+        qhe = ["band", "borders"],
+        Hhe = new by(eC, R8);
 
-    function V6(e, {
+    function R8(e, {
         config: t
     }) {
         e = {
             ...e,
-            encoding: U1(e.encoding, t)
+            encoding: xy(e.encoding, t)
         };
         const {
             transform: n,
             continuousAxisChannelDef: i,
             continuousAxis: r,
             encodingWithoutContinuousAxis: s,
             markDef: a,
             outerSpec: o,
             tooltipEncoding: l
-        } = X6(e, cC, t), u = a, c = lC(u, r, i, s, t.errorband), f = e.encoding.x !== void 0 && e.encoding.y !== void 0;
+        } = F8(e, eC, t), u = a, c = Qk(u, r, i, s, t.errorband), f = e.encoding.x !== void 0 && e.encoding.y !== void 0;
         let h = {
                 type: f ? "area" : "rect"
             },
             d = {
                 type: f ? "line" : "rule"
             };
         const g = {
@@ -40703,15 +34006,15 @@
             ...h,
             ...g,
             ariaRoleDescription: "errorband"
         }, d = {
             ...d,
             ...g,
             aria: !1
-        }) : u.interpolate ? X(R5("interpolate")) : u.tension && X(R5("tension")), {
+        }) : u.interpolate ? J(eM("interpolate")) : u.tension && J(eM("tension")), {
             ...o,
             transform: n,
             layer: [...c({
                 partName: "band",
                 mark: h,
                 positionPrefix: "lower",
                 endPositionPrefix: "upper",
@@ -40725,79 +34028,79 @@
                 partName: "borders",
                 mark: d,
                 positionPrefix: "upper",
                 extraEncoding: l
             })]
         }
     }
-    const K6 = {};
+    const D8 = {};
 
-    function fC(e, t, n) {
-        const i = new j1(e, t);
-        K6[e] = {
+    function tC(e, t, n) {
+        const i = new by(e, t);
+        D8[e] = {
             normalizer: i,
             parts: n
         }
     }
 
-    function $de() {
-        return H(K6)
+    function Yhe() {
+        return K(D8)
     }
-    fC(W0, q6, mde);
-    fC(uC, Y6, bde);
-    fC(cC, V6, kde);
-    const Tde = ["gradientHorizontalMaxLength", "gradientHorizontalMinLength", "gradientVerticalMaxLength", "gradientVerticalMinLength", "unselectedOpacity"],
-        J6 = {
+    tC(k0, T8, Nhe);
+    tC(Zk, O8, Ihe);
+    tC(eC, R8, qhe);
+    const Xhe = ["gradientHorizontalMaxLength", "gradientHorizontalMinLength", "gradientVerticalMaxLength", "gradientVerticalMinLength", "unselectedOpacity"],
+        N8 = {
             titleAlign: "align",
             titleAnchor: "anchor",
             titleAngle: "angle",
             titleBaseline: "baseline",
             titleColor: "color",
             titleFont: "font",
             titleFontSize: "fontSize",
             titleFontStyle: "fontStyle",
             titleFontWeight: "fontWeight",
             titleLimit: "limit",
             titleLineHeight: "lineHeight",
             titleOrient: "orient",
             titlePadding: "offset"
         },
-        Q6 = {
+        P8 = {
             labelAlign: "align",
             labelAnchor: "anchor",
             labelAngle: "angle",
             labelBaseline: "baseline",
             labelColor: "color",
             labelFont: "font",
             labelFontSize: "fontSize",
             labelFontStyle: "fontStyle",
             labelFontWeight: "fontWeight",
             labelLimit: "limit",
             labelLineHeight: "lineHeight",
             labelOrient: "orient",
             labelPadding: "offset"
         },
-        Mde = H(J6),
-        Ode = H(Q6),
-        Fde = {
+        Vhe = K(N8),
+        Khe = K(P8),
+        Jhe = {
             header: 1,
             headerRow: 1,
             headerColumn: 1,
             headerFacet: 1
         },
-        Z6 = H(Fde),
-        ez = ["size", "shape", "fill", "stroke", "strokeDash", "strokeWidth", "opacity"],
-        Rde = {
+        L8 = K(Jhe),
+        I8 = ["size", "shape", "fill", "stroke", "strokeDash", "strokeWidth", "opacity"],
+        Qhe = {
             gradientHorizontalMaxLength: 200,
             gradientHorizontalMinLength: 100,
             gradientVerticalMaxLength: 200,
             gradientVerticalMinLength: 64,
             unselectedOpacity: .35
         },
-        Dde = {
+        Zhe = {
             aria: 1,
             clipHeight: 1,
             columnPadding: 1,
             columns: 1,
             cornerRadius: 1,
             description: 1,
             direction: 1,
@@ -40856,19 +34159,19 @@
             titleOpacity: 1,
             titleOrient: 1,
             titlePadding: 1,
             type: 1,
             values: 1,
             zindex: 1
         },
-        pr = "_vgsid_",
-        Nde = {
+        Mr = "_vgsid_",
+        ede = {
             point: {
                 on: "click",
-                fields: [pr],
+                fields: [Mr],
                 toggle: "event.shiftKey",
                 resolve: "global",
                 clear: "dblclick"
             },
             interval: {
                 on: "[mousedown, window:mouseup] > window:mousemove!",
                 encodings: ["x", "y"],
@@ -40880,30 +34183,30 @@
                     stroke: "white"
                 },
                 resolve: "global",
                 clear: "dblclick"
             }
         };
 
-    function hC(e) {
+    function nC(e) {
         return e === "legend" || !!(e != null && e.legend)
     }
 
-    function Av(e) {
-        return hC(e) && ae(e)
+    function nb(e) {
+        return nC(e) && ce(e)
     }
 
-    function dC(e) {
+    function iC(e) {
         return !!(e != null && e.select)
     }
 
-    function tz(e) {
+    function z8(e) {
         const t = [];
         for (const n of e || []) {
-            if (dC(n)) continue;
+            if (iC(n)) continue;
             const {
                 expr: i,
                 bind: r,
                 ...s
             } = n;
             if (r && i) {
                 const a = {
@@ -40924,119 +34227,119 @@
                 };
                 t.push(a)
             }
         }
         return t
     }
 
-    function Pde(e) {
-        return G1(e) || pC(e) || gC(e)
+    function tde(e) {
+        return _y(e) || sC(e) || rC(e)
     }
 
-    function gC(e) {
+    function rC(e) {
         return "concat" in e
     }
 
-    function G1(e) {
+    function _y(e) {
         return "vconcat" in e
     }
 
-    function pC(e) {
+    function sC(e) {
         return "hconcat" in e
     }
 
-    function nz({
+    function B8({
         step: e,
         offsetIsDiscrete: t
     }) {
         return t ? e.for ?? "offset" : "position"
     }
 
-    function Jr(e) {
-        return ae(e) && e.step !== void 0
+    function ds(e) {
+        return ce(e) && e.step !== void 0
     }
 
-    function G5(e) {
+    function cM(e) {
         return e.view || e.width || e.height
     }
-    const W5 = 20,
-        Lde = {
+    const fM = 20,
+        nde = {
             align: 1,
             bounds: 1,
             center: 1,
             columns: 1,
             spacing: 1
         },
-        Ide = H(Lde);
+        ide = K(nde);
 
-    function zde(e, t, n) {
+    function rde(e, t, n) {
         const i = n[t],
             r = {},
             {
                 spacing: s,
                 columns: a
             } = i;
-        s !== void 0 && (r.spacing = s), a !== void 0 && (P1(e) && !Rd(e.facet) || gC(e)) && (r.columns = a), G1(e) && (r.columns = 1);
-        for (const o of Ide)
+        s !== void 0 && (r.spacing = s), a !== void 0 && (gy(e) && !ug(e.facet) || rC(e)) && (r.columns = a), _y(e) && (r.columns = 1);
+        for (const o of ide)
             if (e[o] !== void 0)
                 if (o === "spacing") {
                     const l = e[o];
-                    r[o] = Ze(l) ? l : {
+                    r[o] = lt(l) ? l : {
                         row: l.row ?? s,
                         column: l.column ?? s
                     }
                 } else r[o] = e[o];
         return r
     }
 
-    function Z2(e, t) {
+    function Mx(e, t) {
         return e[t] ?? e[t === "width" ? "continuousWidth" : "continuousHeight"]
     }
 
-    function q0(e, t) {
-        const n = H0(e, t);
-        return Jr(n) ? n.step : iz
+    function C0(e, t) {
+        const n = A0(e, t);
+        return ds(n) ? n.step : j8
     }
 
-    function H0(e, t) {
+    function A0(e, t) {
         const n = e[t] ?? e[t === "width" ? "discreteWidth" : "discreteHeight"];
-        return Ct(n, {
+        return Gt(n, {
             step: e.step
         })
     }
-    const iz = 20,
-        Bde = {
+    const j8 = 20,
+        sde = {
             continuousWidth: 200,
             continuousHeight: 200,
-            step: iz
+            step: j8
         },
-        jde = {
+        ade = {
             background: "white",
             padding: 5,
             timeFormat: "%b %d, %Y",
             countTitle: "Count of Records",
-            view: Bde,
-            mark: Dhe,
+            view: sde,
+            mark: Qfe,
             arc: {},
             area: {},
-            bar: Lhe,
+            bar: the,
             circle: {},
             geoshape: {},
             image: {},
             line: {},
             point: {},
-            rect: Ihe,
+            rect: nhe,
             rule: {
                 color: "black"
             },
             square: {},
             text: {
                 color: "black"
             },
-            tick: zhe,
+            tick: ihe,
             trail: {},
             boxplot: {
                 size: 14,
                 extent: 1.5,
                 box: {},
                 median: {
                     color: "white"
@@ -41052,53 +34355,53 @@
             },
             errorband: {
                 band: {
                     opacity: .3
                 },
                 borders: !1
             },
-            scale: mhe,
+            scale: Dfe,
             projection: {},
-            legend: Rde,
+            legend: Qhe,
             header: {
                 titlePadding: 10,
                 labelPadding: 10
             },
             headerColumn: {},
             headerRow: {},
             headerFacet: {},
-            selection: Nde,
+            selection: ede,
             style: {},
             title: {},
             facet: {
-                spacing: W5
+                spacing: fM
             },
             concat: {
-                spacing: W5
+                spacing: fM
             },
             normalizedNumberFormat: ".0%"
         },
-        ps = ["#4c78a8", "#f58518", "#e45756", "#72b7b2", "#54a24b", "#eeca3b", "#b279a2", "#ff9da6", "#9d755d", "#bab0ac"],
-        q5 = {
+        Fs = ["#4c78a8", "#f58518", "#e45756", "#72b7b2", "#54a24b", "#eeca3b", "#b279a2", "#ff9da6", "#9d755d", "#bab0ac"],
+        hM = {
             text: 11,
             guideLabel: 10,
             guideTitle: 11,
             groupTitle: 13,
             groupSubtitle: 12
         },
-        H5 = {
-            blue: ps[0],
-            orange: ps[1],
-            red: ps[2],
-            teal: ps[3],
-            green: ps[4],
-            yellow: ps[5],
-            purple: ps[6],
-            pink: ps[7],
-            brown: ps[8],
+        dM = {
+            blue: Fs[0],
+            orange: Fs[1],
+            red: Fs[2],
+            teal: Fs[3],
+            green: Fs[4],
+            yellow: Fs[5],
+            purple: Fs[6],
+            pink: Fs[7],
+            brown: Fs[8],
             gray0: "#000",
             gray1: "#111",
             gray2: "#222",
             gray3: "#333",
             gray4: "#444",
             gray5: "#555",
             gray6: "#666",
@@ -41109,22 +34412,22 @@
             gray11: "#bbb",
             gray12: "#ccc",
             gray13: "#ddd",
             gray14: "#eee",
             gray15: "#fff"
         };
 
-    function Ude(e = {}) {
+    function ode(e = {}) {
         return {
             signals: [{
                 name: "color",
-                value: ae(e) ? {
-                    ...H5,
+                value: ce(e) ? {
+                    ...dM,
                     ...e
-                } : H5
+                } : dM
             }],
             mark: {
                 color: {
                     signal: "color.blue"
                 }
             },
             rule: {
@@ -41197,22 +34500,22 @@
                 }, {
                     signal: "color.grey8"
                 }]
             }
         }
     }
 
-    function Gde(e) {
+    function lde(e) {
         return {
             signals: [{
                 name: "fontSize",
-                value: ae(e) ? {
-                    ...q5,
+                value: ce(e) ? {
+                    ...hM,
                     ...e
-                } : q5
+                } : hM
             }],
             text: {
                 fontSize: {
                     signal: "fontSize.text"
                 }
             },
             style: {
@@ -41236,15 +34539,15 @@
                         signal: "fontSize.groupSubtitle"
                     }
                 }
             }
         }
     }
 
-    function Wde(e) {
+    function ude(e) {
         return {
             text: {
                 font: e
             },
             style: {
                 "guide-label": {
                     font: e
@@ -41258,124 +34561,124 @@
                 "group-subtitle": {
                     font: e
                 }
             }
         }
     }
 
-    function rz(e) {
-        const t = H(e || {}),
+    function G8(e) {
+        const t = K(e || {}),
             n = {};
         for (const i of t) {
             const r = e[i];
-            n[i] = Pd(r) ? PI(r) : di(r)
+            n[i] = hg(r) ? v6(r) : Ci(r)
         }
         return n
     }
 
-    function qde(e) {
-        const t = H(e),
+    function cde(e) {
+        const t = K(e),
             n = {};
-        for (const i of t) n[i] = rz(e[i]);
+        for (const i of t) n[i] = G8(e[i]);
         return n
     }
-    const Hde = [...p6, ...L6, ...Z6, "background", "padding", "legend", "lineBreak", "scale", "style", "title", "view"];
+    const fde = [...Z6, ..._8, ...L8, "background", "padding", "legend", "lineBreak", "scale", "style", "title", "view"];
 
-    function sz(e = {}) {
+    function U8(e = {}) {
         const {
             color: t,
             font: n,
             fontSize: i,
             selection: r,
             ...s
-        } = e, a = bc({}, ke(jde), n ? Wde(n) : {}, t ? Ude(t) : {}, i ? Gde(i) : {}, s || {});
-        r && xc(a, "selection", r, !0);
-        const o = Jn(a, Hde);
-        for (const l of ["background", "lineBreak", "padding"]) a[l] && (o[l] = di(a[l]));
-        for (const l of p6) a[l] && (o[l] = Hn(a[l]));
-        for (const l of L6) a[l] && (o[l] = rz(a[l]));
-        for (const l of Z6) a[l] && (o[l] = Hn(a[l]));
-        return a.legend && (o.legend = Hn(a.legend)), a.scale && (o.scale = Hn(a.scale)), a.style && (o.style = qde(a.style)), a.title && (o.title = Hn(a.title)), a.view && (o.view = Hn(a.view)), o
-    }
-    const Yde = new Set(["view", ...$he]),
-        Xde = ["color", "fontSize", "background", "padding", "facet", "concat", "numberFormat", "numberFormatType", "normalizedNumberFormat", "normalizedNumberFormatType", "timeFormat", "countTitle", "header", "axisQuantitative", "axisTemporal", "axisDiscrete", "axisPoint", "axisXBand", "axisXPoint", "axisXDiscrete", "axisXQuantitative", "axisXTemporal", "axisYBand", "axisYPoint", "axisYDiscrete", "axisYQuantitative", "axisYTemporal", "scale", "selection", "overlay"],
-        Vde = {
+        } = e, a = jc({}, Fe(ade), n ? ude(n) : {}, t ? ode(t) : {}, i ? lde(i) : {}, s || {});
+        r && Gc(a, "selection", r, !0);
+        const o = li(a, fde);
+        for (const l of ["background", "lineBreak", "padding"]) a[l] && (o[l] = Ci(a[l]));
+        for (const l of Z6) a[l] && (o[l] = ii(a[l]));
+        for (const l of _8) a[l] && (o[l] = G8(a[l]));
+        for (const l of L8) a[l] && (o[l] = ii(a[l]));
+        return a.legend && (o.legend = ii(a.legend)), a.scale && (o.scale = ii(a.scale)), a.style && (o.style = cde(a.style)), a.title && (o.title = ii(a.title)), a.view && (o.view = ii(a.view)), o
+    }
+    const hde = new Set(["view", ...Hfe]),
+        dde = ["color", "fontSize", "background", "padding", "facet", "concat", "numberFormat", "numberFormatType", "normalizedNumberFormat", "normalizedNumberFormatType", "timeFormat", "countTitle", "header", "axisQuantitative", "axisTemporal", "axisDiscrete", "axisPoint", "axisXBand", "axisXPoint", "axisXDiscrete", "axisXQuantitative", "axisXTemporal", "axisYBand", "axisYPoint", "axisYDiscrete", "axisYQuantitative", "axisYTemporal", "scale", "selection", "overlay"],
+        gde = {
             view: ["continuousWidth", "continuousHeight", "discreteWidth", "discreteHeight", "step"],
-            ...Rhe
+            ...Jfe
         };
 
-    function Kde(e) {
-        e = ke(e);
-        for (const t of Xde) delete e[t];
+    function pde(e) {
+        e = Fe(e);
+        for (const t of dde) delete e[t];
         if (e.axis)
-            for (const t in e.axis) Pd(e.axis[t]) && delete e.axis[t];
+            for (const t in e.axis) hg(e.axis[t]) && delete e.axis[t];
         if (e.legend)
-            for (const t of Tde) delete e.legend[t];
+            for (const t of Xhe) delete e.legend[t];
         if (e.mark) {
-            for (const t of N5) delete e.mark[t];
-            e.mark.tooltip && ae(e.mark.tooltip) && delete e.mark.tooltip
+            for (const t of nM) delete e.mark[t];
+            e.mark.tooltip && ce(e.mark.tooltip) && delete e.mark.tooltip
         }
-        e.params && (e.signals = (e.signals || []).concat(tz(e.params)), delete e.params);
-        for (const t of Yde) {
-            for (const i of N5) delete e[t][i];
-            const n = Vde[t];
+        e.params && (e.signals = (e.signals || []).concat(z8(e.params)), delete e.params);
+        for (const t of hde) {
+            for (const i of nM) delete e[t][i];
+            const n = gde[t];
             if (n)
                 for (const i of n) delete e[t][i];
-            Qde(e, t)
+            yde(e, t)
         }
-        for (const t of $de()) delete e[t];
-        Jde(e);
-        for (const t in e) ae(e[t]) && et(e[t]) && delete e[t];
-        return et(e) ? void 0 : e
+        for (const t of Yhe()) delete e[t];
+        mde(e);
+        for (const t in e) ce(e[t]) && ft(e[t]) && delete e[t];
+        return ft(e) ? void 0 : e
     }
 
-    function Jde(e) {
+    function mde(e) {
         const {
             titleMarkConfig: t,
             subtitleMarkConfig: n,
             subtitle: i
-        } = NI(e.title);
-        et(t) || (e.style["group-title"] = {
+        } = y6(e.title);
+        ft(t) || (e.style["group-title"] = {
             ...e.style["group-title"],
             ...t
-        }), et(n) || (e.style["group-subtitle"] = {
+        }), ft(n) || (e.style["group-subtitle"] = {
             ...e.style["group-subtitle"],
             ...n
-        }), et(i) ? delete e.title : e.title = i
+        }), ft(i) ? delete e.title : e.title = i
     }
 
-    function Qde(e, t, n, i) {
+    function yde(e, t, n, i) {
         const r = i ? e[t][i] : e[t];
         t === "view" && (n = "cell");
         const s = {
             ...r,
             ...e.style[n ?? t]
         };
-        et(s) || (e.style[n ?? t] = s), i || delete e[t]
+        ft(s) || (e.style[n ?? t] = s), i || delete e[t]
     }
 
-    function W1(e) {
+    function wy(e) {
         return "layer" in e
     }
 
-    function Zde(e) {
+    function vde(e) {
         return "repeat" in e
     }
 
-    function ege(e) {
-        return !W(e.repeat) && e.repeat.layer
+    function bde(e) {
+        return !H(e.repeat) && e.repeat.layer
     }
-    class mC {
+    class aC {
         map(t, n) {
-            return P1(t) ? this.mapFacet(t, n) : Zde(t) ? this.mapRepeat(t, n) : pC(t) ? this.mapHConcat(t, n) : G1(t) ? this.mapVConcat(t, n) : gC(t) ? this.mapConcat(t, n) : this.mapLayerOrUnit(t, n)
+            return gy(t) ? this.mapFacet(t, n) : vde(t) ? this.mapRepeat(t, n) : sC(t) ? this.mapHConcat(t, n) : _y(t) ? this.mapVConcat(t, n) : rC(t) ? this.mapConcat(t, n) : this.mapLayerOrUnit(t, n)
         }
         mapLayerOrUnit(t, n) {
-            if (W1(t)) return this.mapLayer(t, n);
-            if (Zs(t)) return this.mapUnit(t, n);
-            throw new Error(FE(t))
+            if (wy(t)) return this.mapLayer(t, n);
+            if (da(t)) return this.mapUnit(t, n);
+            throw new Error(_k(t))
         }
         mapLayer(t, n) {
             return {
                 ...t,
                 layer: t.layer.map(i => this.mapLayerOrUnit(i, n))
             }
         }
@@ -41410,195 +34713,195 @@
         mapRepeat(t, n) {
             return {
                 ...t,
                 spec: this.map(t.spec, n)
             }
         }
     }
-    const tge = {
+    const xde = {
         zero: 1,
         center: 1,
         normalize: 1
     };
 
-    function nge(e) {
-        return e in tge
+    function _de(e) {
+        return e in xde
     }
-    const ige = new Set([f6, F1, O1, I0, D1, XE, VE, R1, h6, YE]),
-        rge = new Set([F1, O1, f6]);
+    const wde = new Set([K6, cy, uy, b0, hy, Lk, Ik, fy, J6, Pk]),
+        Sde = new Set([cy, uy, K6]);
 
-    function tu(e) {
-        return K(e) && rc(e) === "quantitative" && !e.bin
+    function ku(e) {
+        return Z(e) && Mc(e) === "quantitative" && !e.bin
     }
 
-    function Y5(e, t, {
+    function gM(e, t, {
         orient: n,
         type: i
     }) {
         const r = t === "x" ? "y" : "radius",
             s = t === "x",
             a = e[t],
             o = e[r];
-        if (K(a) && K(o))
-            if (tu(a) && tu(o)) {
+        if (Z(a) && Z(o))
+            if (ku(a) && ku(o)) {
                 if (a.stack) return t;
                 if (o.stack) return r;
-                const l = K(a) && !!a.aggregate,
-                    u = K(o) && !!o.aggregate;
+                const l = Z(a) && !!a.aggregate,
+                    u = Z(o) && !!o.aggregate;
                 if (l !== u) return l ? t : r;
                 if (s && i === "bar") {
                     if (n === "vertical") return r;
                     if (n === "horizontal") return t
                 }
             } else {
-                if (tu(a)) return t;
-                if (tu(o)) return r
+                if (ku(a)) return t;
+                if (ku(o)) return r
             }
         else {
-            if (tu(a)) return t;
-            if (tu(o)) return r
+            if (ku(a)) return t;
+            if (ku(o)) return r
         }
     }
 
-    function sge(e) {
+    function Ede(e) {
         switch (e) {
             case "x":
                 return "y";
             case "y":
                 return "x";
             case "theta":
                 return "radius";
             case "radius":
                 return "theta"
         }
     }
 
-    function az(e, t) {
+    function W8(e, t) {
         var h, d;
-        const n = Vr(e) ? e : {
+        const n = fs(e) ? e : {
                 type: e
             },
             i = n.type;
-        if (!ige.has(i)) return null;
-        const r = Y5(t, "x", n) || Y5(t, "theta", n);
+        if (!wde.has(i)) return null;
+        const r = gM(t, "x", n) || gM(t, "theta", n);
         if (!r) return null;
         const s = t[r],
-            a = K(s) ? ie(s, {}) : void 0,
-            o = sge(r),
+            a = Z(s) ? oe(s, {}) : void 0,
+            o = Ede(r),
             l = [],
             u = new Set;
         if (t[o]) {
             const g = t[o],
-                p = K(g) ? ie(g, {}) : void 0;
+                p = Z(g) ? oe(g, {}) : void 0;
             p && p !== a && (l.push(o), u.add(p));
             const m = o === "x" ? "xOffset" : "yOffset",
                 y = t[m],
-                v = K(y) ? ie(y, {}) : void 0;
+                v = Z(y) ? oe(y, {}) : void 0;
             v && v !== a && (l.push(m), u.add(v))
         }
-        const c = bce.reduce((g, p) => {
-            if (p !== "tooltip" && Ho(t, p)) {
+        const c = Pue.reduce((g, p) => {
+            if (p !== "tooltip" && ml(t, p)) {
                 const m = t[p];
-                for (const y of se(m)) {
-                    const v = Kr(y);
+                for (const y of ue(m)) {
+                    const v = hs(y);
                     if (v.aggregate) continue;
-                    const b = ie(v, {});
+                    const b = oe(v, {});
                     (!b || !u.has(b)) && g.push({
                         channel: p,
                         fieldDef: v
                     })
                 }
             }
             return g
         }, []);
         let f;
-        return s.stack !== void 0 ? Za(s.stack) ? f = s.stack ? "zero" : null : f = s.stack : rge.has(i) && (f = "zero"), !f || !nge(f) || sC(t) && c.length === 0 ? null : (h = s == null ? void 0 : s.scale) != null && h.type && ((d = s == null ? void 0 : s.scale) == null ? void 0 : d.type) !== Qn.LINEAR ? (s != null && s.stack && X(Nfe(s.scale.type)), null) : Ce(t[us(r)]) ? (s.stack !== void 0 && X(Dfe(r)), null) : (K(s) && s.aggregate && !Oce.has(s.aggregate) && X(Pfe(s.aggregate)), {
+        return s.stack !== void 0 ? mo(s.stack) ? f = s.stack ? "zero" : null : f = s.stack : Sde.has(i) && (f = "zero"), !f || !_de(f) || Vk(t) && c.length === 0 ? null : (h = s == null ? void 0 : s.scale) != null && h.type && ((d = s == null ? void 0 : s.scale) == null ? void 0 : d.type) !== ui.LINEAR ? (s != null && s.stack && J(Qce(s.scale.type)), null) : De(t[Ss(r)]) ? (s.stack !== void 0 && J(Jce(r)), null) : (Z(s) && s.aggregate && !Xue.has(s.aggregate) && J(Zce(s.aggregate)), {
             groupbyChannels: l,
             groupbyFields: u,
             fieldChannel: r,
-            impute: s.impute === null ? !1 : uo(i),
+            impute: s.impute === null ? !1 : Mo(i),
             stackBy: c,
             offset: f
         })
     }
 
-    function age(e) {
+    function kde(e) {
         const {
             point: t,
             line: n,
             ...i
         } = e;
-        return H(i).length > 1 ? i : i.type
+        return K(i).length > 1 ? i : i.type
     }
 
-    function oge(e) {
+    function Cde(e) {
         for (const t of ["line", "area", "rule", "trail"]) e[t] && (e = {
             ...e,
-            [t]: Jn(e[t], ["point", "line"])
+            [t]: li(e[t], ["point", "line"])
         });
         return e
     }
 
-    function $v(e, t = {}, n) {
+    function ib(e, t = {}, n) {
         return e.point === "transparent" ? {
             opacity: 0
-        } : e.point ? ae(e.point) ? e.point : {} : e.point !== void 0 ? null : t.point || n.shape ? ae(t.point) ? t.point : {} : void 0
+        } : e.point ? ce(e.point) ? e.point : {} : e.point !== void 0 ? null : t.point || n.shape ? ce(t.point) ? t.point : {} : void 0
     }
 
-    function X5(e, t = {}) {
+    function pM(e, t = {}) {
         return e.line ? e.line === !0 ? {} : e.line : e.line !== void 0 ? null : t.line ? t.line === !0 ? {} : t.line : void 0
     }
-    class lge {
+    class Ade {
         constructor() {
             this.name = "path-overlay"
         }
         hasMatchingType(t, n) {
-            if (Zs(t)) {
+            if (da(t)) {
                 const {
                     mark: i,
                     encoding: r
-                } = t, s = Vr(i) ? i : {
+                } = t, s = fs(i) ? i : {
                     type: i
                 };
                 switch (s.type) {
                     case "line":
                     case "rule":
                     case "trail":
-                        return !!$v(s, n[s.type], r);
+                        return !!ib(s, n[s.type], r);
                     case "area":
-                        return !!$v(s, n[s.type], r) || !!X5(s, n[s.type])
+                        return !!ib(s, n[s.type], r) || !!pM(s, n[s.type])
                 }
             }
             return !1
         }
         run(t, n, i) {
             const {
                 config: r
             } = n, {
                 params: s,
                 projection: a,
                 mark: o,
                 name: l,
                 encoding: u,
                 ...c
-            } = t, f = U1(u, r), h = Vr(o) ? o : {
+            } = t, f = xy(u, r), h = fs(o) ? o : {
                 type: o
-            }, d = $v(h, r[h.type], f), g = h.type === "area" && X5(h, r[h.type]), p = [{
+            }, d = ib(h, r[h.type], f), g = h.type === "area" && pM(h, r[h.type]), p = [{
                 name: l,
                 ...s ? {
                     params: s
                 } : {},
-                mark: age({
+                mark: kde({
                     ...h.type === "area" && h.opacity === void 0 && h.fillOpacity === void 0 ? {
                         opacity: .7
                     } : {},
                     ...h
                 }),
-                encoding: Jn(f, ["shape"])
-            }], m = az(h, f);
+                encoding: li(f, ["shape"])
+            }], m = W8(h, f);
             let y = f;
             if (m) {
                 const {
                     fieldChannel: v,
                     offset: b
                 } = m;
                 y = {
@@ -41607,100 +34910,100 @@
                         ...f[v],
                         ...b ? {
                             stack: b
                         } : {}
                     }
                 }
             }
-            return y = Jn(y, ["y2", "x2"]), g && p.push({
+            return y = li(y, ["y2", "x2"]), g && p.push({
                 ...a ? {
                     projection: a
                 } : {},
                 mark: {
                     type: "line",
-                    ...Qu(h, ["clip", "interpolate", "tension", "tooltip"]),
+                    ...Ec(h, ["clip", "interpolate", "tension", "tooltip"]),
                     ...g
                 },
                 encoding: y
             }), d && p.push({
                 ...a ? {
                     projection: a
                 } : {},
                 mark: {
                     type: "point",
                     opacity: 1,
                     filled: !0,
-                    ...Qu(h, ["clip", "tooltip"]),
+                    ...Ec(h, ["clip", "tooltip"]),
                     ...d
                 },
                 encoding: y
             }), i({
                 ...c,
                 layer: p
             }, {
                 ...n,
-                config: oge(r)
+                config: Cde(r)
             })
         }
     }
 
-    function uge(e, t) {
-        return t ? Rd(e) ? lz(e, t) : oz(e, t) : e
+    function $de(e, t) {
+        return t ? ug(e) ? H8(e, t) : q8(e, t) : e
     }
 
-    function Tv(e, t) {
-        return t ? lz(e, t) : e
+    function rb(e, t) {
+        return t ? H8(e, t) : e
     }
 
-    function ex(e, t, n) {
+    function Ox(e, t, n) {
         const i = t[e];
-        if (Vhe(i)) {
+        if (ghe(i)) {
             if (i.repeat in n) return {
                 ...t,
                 [e]: n[i.repeat]
             };
-            X(Kce(i.repeat));
+            J(dce(i.repeat));
             return
         }
         return t
     }
 
-    function oz(e, t) {
-        if (e = ex("field", e, t), e !== void 0) {
+    function q8(e, t) {
+        if (e = Ox("field", e, t), e !== void 0) {
             if (e === null) return null;
-            if (tC(e) && Br(e.sort)) {
-                const n = ex("field", e.sort, t);
+            if (qk(e) && ns(e.sort)) {
+                const n = Ox("field", e.sort, t);
                 e = {
                     ...e,
                     ...n ? {
                         sort: n
                     } : {}
                 }
             }
             return e
         }
     }
 
-    function V5(e, t) {
-        if (K(e)) return oz(e, t); {
-            const n = ex("datum", e, t);
+    function mM(e, t) {
+        if (Z(e)) return q8(e, t); {
+            const n = Ox("datum", e, t);
             return n !== e && !n.type && (n.type = "nominal"), n
         }
     }
 
-    function K5(e, t) {
-        if (Ce(e)) {
-            const n = V5(e, t);
+    function yM(e, t) {
+        if (De(e)) {
+            const n = mM(e, t);
             if (n) return n;
-            if (L1(e)) return {
+            if (py(e)) return {
                 condition: e.condition
             }
         } else {
-            if (Dd(e)) {
-                const n = V5(e.condition, t);
+            if (cg(e)) {
+                const n = mM(e.condition, t);
                 if (n) return {
                     ...e,
                     condition: n
                 }; {
                     const {
                         condition: i,
                         ...r
@@ -41708,77 +35011,77 @@
                     return r
                 }
             }
             return e
         }
     }
 
-    function lz(e, t) {
+    function H8(e, t) {
         const n = {};
         for (const i in e)
-            if (me(e, i)) {
+            if (Ce(e, i)) {
                 const r = e[i];
-                if (W(r)) n[i] = r.map(s => K5(s, t)).filter(s => s);
+                if (H(r)) n[i] = r.map(s => yM(s, t)).filter(s => s);
                 else {
-                    const s = K5(r, t);
+                    const s = yM(r, t);
                     s !== void 0 && (n[i] = s)
                 }
             } return n
     }
-    class cge {
+    class Tde {
         constructor() {
             this.name = "RuleForRangedLine"
         }
         hasMatchingType(t) {
-            if (Zs(t)) {
+            if (da(t)) {
                 const {
                     encoding: n,
                     mark: i
                 } = t;
-                if (i === "line" || Vr(i) && i.type === "line")
-                    for (const r of yce) {
-                        const s = Nl(r),
+                if (i === "line" || fs(i) && i.type === "line")
+                    for (const r of Due) {
+                        const s = tu(r),
                             a = n[s];
-                        if (n[r] && (K(a) && !Xt(a.bin) || fs(a))) return !0
+                        if (n[r] && (Z(a) && !pn(a.bin) || ks(a))) return !0
                     }
             }
             return !1
         }
         run(t, n, i) {
             const {
                 encoding: r,
                 mark: s
             } = t;
-            return X(yfe(!!r.x2, !!r.y2)), i({
+            return J(Dce(!!r.x2, !!r.y2)), i({
                 ...t,
-                mark: ae(s) ? {
+                mark: ce(s) ? {
                     ...s,
                     type: "rule"
                 } : "rule"
             }, n)
         }
     }
-    class fge extends mC {
+    class Mde extends aC {
         constructor() {
-            super(...arguments), this.nonFacetUnitNormalizers = [yde, xde, Ade, new lge, new cge]
+            super(...arguments), this.nonFacetUnitNormalizers = [Phe, zhe, Hhe, new Ade, new Tde]
         }
         map(t, n) {
-            if (Zs(t)) {
-                const i = Ho(t.encoding, Fs),
-                    r = Ho(t.encoding, Rs),
-                    s = Ho(t.encoding, _1);
+            if (da(t)) {
+                const i = ml(t.encoding, Vs),
+                    r = ml(t.encoding, Ks),
+                    s = ml(t.encoding, Z1);
                 if (i || r || s) return this.mapFacetedUnit(t, n)
             }
             return super.map(t, n)
         }
         mapUnit(t, n) {
             const {
                 parentEncoding: i,
                 parentProjection: r
-            } = n, s = Tv(t.encoding, n.repeater), a = {
+            } = n, s = rb(t.encoding, n.repeater), a = {
                 ...t,
                 ...t.name ? {
                     name: [n.repeaterPrefix, t.name].filter(l => l).join("_")
                 } : {},
                 ...s ? {
                     encoding: s
                 } : {}
@@ -41786,15 +35089,15 @@
             if (i || r) return this.mapUnitWithParentEncodingOrProjection(a, n);
             const o = this.mapLayerOrUnit.bind(this);
             for (const l of this.nonFacetUnitNormalizers)
                 if (l.hasMatchingType(a, n.config)) return l.run(a, n, o);
             return a
         }
         mapRepeat(t, n) {
-            return ege(t) ? this.mapLayerRepeat(t, n) : this.mapNonLayerRepeat(t, n)
+            return bde(t) ? this.mapLayerRepeat(t, n) : this.mapNonLayerRepeat(t, n)
         }
         mapLayerRepeat(t, n) {
             const {
                 repeat: i,
                 spec: r,
                 ...s
             } = t, {
@@ -41824,15 +35127,15 @@
             }, n) : {
                 ...s,
                 layer: l.map(f => {
                     const h = {
                             ...u,
                             layer: f
                         },
-                        d = `${(r.name?`${r.name}_`:"")+c}child__layer_${ft(f)}`,
+                        d = `${(r.name?`${r.name}_`:"")+c}child__layer_${Et(f)}`,
                         g = this.mapLayerOrUnit(r, {
                             ...n,
                             repeater: h,
                             repeaterPrefix: d
                         });
                     return g.name = d, g
                 })
@@ -41841,69 +35144,69 @@
         mapNonLayerRepeat(t, n) {
             const {
                 repeat: i,
                 spec: r,
                 data: s,
                 ...a
             } = t;
-            !W(i) && t.columns && (t = Jn(t, ["columns"]), X(T5("repeat")));
+            !H(i) && t.columns && (t = li(t, ["columns"]), J(K5("repeat")));
             const o = [],
                 {
                     repeater: l = {},
                     repeaterPrefix: u = ""
                 } = n,
-                c = !W(i) && i.row || [l ? l.row : null],
-                f = !W(i) && i.column || [l ? l.column : null],
-                h = W(i) && i || [l ? l.repeat : null];
+                c = !H(i) && i.row || [l ? l.row : null],
+                f = !H(i) && i.column || [l ? l.column : null],
+                h = H(i) && i || [l ? l.repeat : null];
             for (const g of h)
                 for (const p of c)
                     for (const m of f) {
                         const y = {
                                 repeat: g,
                                 row: p,
                                 column: m,
                                 layer: l.layer
                             },
-                            v = (r.name ? `${r.name}_` : "") + u + "child__" + (W(i) ? `${ft(g)}` : (i.row ? `row_${ft(p)}` : "") + (i.column ? `column_${ft(m)}` : "")),
+                            v = (r.name ? `${r.name}_` : "") + u + "child__" + (H(i) ? `${Et(g)}` : (i.row ? `row_${Et(p)}` : "") + (i.column ? `column_${Et(m)}` : "")),
                             b = this.map(r, {
                                 ...n,
                                 repeater: y,
                                 repeaterPrefix: v
                             });
-                        b.name = v, o.push(Jn(b, ["data"]))
+                        b.name = v, o.push(li(b, ["data"]))
                     }
-            const d = W(i) ? t.columns : i.column ? i.column.length : 1;
+            const d = H(i) ? t.columns : i.column ? i.column.length : 1;
             return {
                 data: r.data ?? s,
                 align: "all",
                 ...a,
                 columns: d,
                 concat: o
             }
         }
         mapFacet(t, n) {
             const {
                 facet: i
             } = t;
-            return Rd(i) && t.columns && (t = Jn(t, ["columns"]), X(T5("facet"))), super.mapFacet(t, n)
+            return ug(i) && t.columns && (t = li(t, ["columns"]), J(K5("facet"))), super.mapFacet(t, n)
         }
         mapUnitWithParentEncodingOrProjection(t, n) {
             const {
                 encoding: i,
                 projection: r
             } = t, {
                 parentEncoding: s,
                 parentProjection: a,
                 config: o
-            } = n, l = Q5({
+            } = n, l = bM({
                 parentProjection: a,
                 projection: r
-            }), u = J5({
+            }), u = vM({
                 parentEncoding: s,
-                encoding: Tv(i, n.repeater)
+                encoding: rb(i, n.repeater)
             });
             return this.mapUnit({
                 ...t,
                 ...l ? {
                     projection: l
                 } : {},
                 ...u ? {
@@ -41931,15 +35234,15 @@
             } = t, {
                 facetMapping: p,
                 layout: m
             } = this.getFacetMappingAndLayout({
                 row: i,
                 column: r,
                 facet: s
-            }, n), y = Tv(a, n.repeater);
+            }, n), y = rb(a, n.repeater);
             return this.mapFacet({
                 ...g,
                 ...m,
                 facet: p,
                 spec: {
                     ...l ? {
                         width: l
@@ -41964,18 +35267,18 @@
         getFacetMappingAndLayout(t, n) {
             const {
                 row: i,
                 column: r,
                 facet: s
             } = t;
             if (i || r) {
-                s && X(pfe([...i ? [Fs] : [], ...r ? [Rs] : []]));
+                s && J(Fce([...i ? [Vs] : [], ...r ? [Ks] : []]));
                 const a = {},
                     o = {};
-                for (const l of [Fs, Rs]) {
+                for (const l of [Vs, Ks]) {
                     const u = t[l];
                     if (u) {
                         const {
                             align: c,
                             center: f,
                             spacing: h,
                             columns: d,
@@ -41994,15 +35297,15 @@
                     align: a,
                     center: o,
                     spacing: l,
                     columns: u,
                     ...c
                 } = s;
                 return {
-                    facetMapping: uge(c, n.repeater),
+                    facetMapping: $de(c, n.repeater),
                     layout: {
                         ...a ? {
                             align: a
                         } : {},
                         ...o ? {
                             center: o
                         } : {},
@@ -42023,219 +35326,223 @@
         }) {
             const {
                 encoding: s,
                 projection: a,
                 ...o
             } = t, l = {
                 ...r,
-                parentEncoding: J5({
+                parentEncoding: vM({
                     parentEncoding: n,
                     encoding: s,
                     layer: !0
                 }),
-                parentProjection: Q5({
+                parentProjection: bM({
                     parentProjection: i,
                     projection: a
                 })
             };
             return super.mapLayer({
                 ...o,
                 ...t.name ? {
                     name: [l.repeaterPrefix, t.name].filter(u => u).join("_")
                 } : {}
             }, l)
         }
     }
 
-    function J5({
+    function vM({
         parentEncoding: e,
         encoding: t = {},
         layer: n
     }) {
         let i = {};
         if (e) {
-            const r = new Set([...H(e), ...H(t)]);
+            const r = new Set([...K(e), ...K(t)]);
             for (const s of r) {
                 const a = t[s],
                     o = e[s];
-                if (Ce(a)) {
+                if (De(a)) {
                     const l = {
                         ...o,
                         ...a
                     };
                     i[s] = l
-                } else Dd(a) ? i[s] = {
+                } else cg(a) ? i[s] = {
                     ...a,
                     condition: {
                         ...o,
                         ...a.condition
                     }
-                } : a || a === null ? i[s] = a : (n || gr(o) || he(o) || Ce(o) || W(o)) && (i[s] = o)
+                } : a || a === null ? i[s] = a : (n || Tr(o) || xe(o) || De(o) || H(o)) && (i[s] = o)
             }
         } else i = t;
-        return !i || et(i) ? void 0 : i
+        return !i || ft(i) ? void 0 : i
     }
 
-    function Q5(e) {
+    function bM(e) {
         const {
             parentProjection: t,
             projection: n
         } = e;
-        return t && n && X(nfe({
+        return t && n && J(bce({
             parentProjection: t,
             projection: n
         })), n ?? t
     }
 
-    function yC(e) {
+    function oC(e) {
         return "filter" in e
     }
 
-    function hge(e) {
+    function Ode(e) {
         return (e == null ? void 0 : e.stop) !== void 0
     }
 
-    function uz(e) {
+    function Y8(e) {
         return "lookup" in e
     }
 
-    function dge(e) {
+    function Fde(e) {
         return "data" in e
     }
 
-    function gge(e) {
+    function Rde(e) {
         return "param" in e
     }
 
-    function pge(e) {
+    function Dde(e) {
         return "pivot" in e
     }
 
-    function mge(e) {
+    function Nde(e) {
         return "density" in e
     }
 
-    function yge(e) {
+    function Pde(e) {
         return "quantile" in e
     }
 
-    function vge(e) {
+    function Lde(e) {
         return "regression" in e
     }
 
-    function bge(e) {
+    function Ide(e) {
         return "loess" in e
     }
 
-    function xge(e) {
+    function zde(e) {
         return "sample" in e
     }
 
-    function _ge(e) {
+    function Bde(e) {
         return "window" in e
     }
 
-    function wge(e) {
+    function jde(e) {
         return "joinaggregate" in e
     }
 
-    function Sge(e) {
+    function Gde(e) {
         return "flatten" in e
     }
 
-    function Ege(e) {
+    function Ude(e) {
         return "calculate" in e
     }
 
-    function cz(e) {
+    function X8(e) {
         return "bin" in e
     }
 
-    function Cge(e) {
+    function Wde(e) {
         return "impute" in e
     }
 
-    function kge(e) {
+    function qde(e) {
         return "timeUnit" in e
     }
 
-    function Age(e) {
+    function Hde(e) {
         return "aggregate" in e
     }
 
-    function $ge(e) {
+    function Yde(e) {
         return "stack" in e
     }
 
-    function Tge(e) {
+    function Xde(e) {
         return "fold" in e
     }
 
-    function Mge(e) {
-        return e.map(t => yC(t) ? {
-            filter: Eu(t.filter, uhe)
+    function Vde(e) {
+        return "extent" in e && !("density" in e)
+    }
+
+    function Kde(e) {
+        return e.map(t => oC(t) ? {
+            filter: Vu(t.filter, Afe)
         } : t)
     }
-    class Oge extends mC {
+    class Jde extends aC {
         map(t, n) {
-            return n.emptySelections ?? (n.emptySelections = {}), n.selectionPredicates ?? (n.selectionPredicates = {}), t = Z5(t, n), super.map(t, n)
+            return n.emptySelections ?? (n.emptySelections = {}), n.selectionPredicates ?? (n.selectionPredicates = {}), t = xM(t, n), super.map(t, n)
         }
         mapLayerOrUnit(t, n) {
-            if (t = Z5(t, n), t.encoding) {
+            if (t = xM(t, n), t.encoding) {
                 const i = {};
-                for (const [r, s] of Ba(t.encoding)) i[r] = fz(s, n);
+                for (const [r, s] of lo(t.encoding)) i[r] = V8(s, n);
                 t = {
                     ...t,
                     encoding: i
                 }
             }
             return super.mapLayerOrUnit(t, n)
         }
         mapUnit(t, n) {
             const {
                 selection: i,
                 ...r
             } = t;
             return i ? {
                 ...r,
-                params: Ba(i).map(([s, a]) => {
+                params: lo(i).map(([s, a]) => {
                     const {
                         init: o,
                         bind: l,
                         empty: u,
                         ...c
                     } = a;
                     c.type === "single" ? (c.type = "point", c.toggle = !1) : c.type === "multi" && (c.type = "point"), n.emptySelections[s] = u !== "none";
-                    for (const f of Qt(n.selectionPredicates[s] ?? {})) f.empty = u !== "none";
+                    for (const f of bn(n.selectionPredicates[s] ?? {})) f.empty = u !== "none";
                     return {
                         name: s,
                         value: o,
                         select: c,
                         bind: l
                     }
                 })
             } : t
         }
     }
 
-    function Z5(e, t) {
+    function xM(e, t) {
         const {
             transform: n,
             ...i
         } = e;
         if (n) {
             const r = n.map(s => {
-                if (yC(s)) return {
-                    filter: tx(s, t)
+                if (oC(s)) return {
+                    filter: Fx(s, t)
                 };
-                if (cz(s) && Pl(s.bin)) return {
+                if (X8(s) && nu(s.bin)) return {
                     ...s,
-                    bin: hz(s.bin)
+                    bin: K8(s.bin)
                 };
-                if (uz(s)) {
+                if (Y8(s)) {
                     const {
                         selection: a,
                         ...o
                     } = s.from;
                     return a ? {
                         ...s,
                         from: {
@@ -42250,57 +35557,57 @@
                 ...i,
                 transform: r
             }
         }
         return e
     }
 
-    function fz(e, t) {
+    function V8(e, t) {
         var i, r;
-        const n = ke(e);
-        if (K(n) && Pl(n.bin) && (n.bin = hz(n.bin)), Il(n) && ((r = (i = n.scale) == null ? void 0 : i.domain) != null && r.selection)) {
+        const n = Fe(e);
+        if (Z(n) && nu(n.bin) && (n.bin = K8(n.bin)), su(n) && ((r = (i = n.scale) == null ? void 0 : i.domain) != null && r.selection)) {
             const {
                 selection: s,
                 ...a
             } = n.scale.domain;
             n.scale.domain = {
                 ...a,
                 ...s ? {
                     param: s
                 } : {}
             }
         }
-        if (L1(n))
-            if (W(n.condition)) n.condition = n.condition.map(s => {
+        if (py(n))
+            if (H(n.condition)) n.condition = n.condition.map(s => {
                 const {
                     selection: a,
                     param: o,
                     test: l,
                     ...u
                 } = s;
                 return o ? s : {
                     ...u,
-                    test: tx(s, t)
+                    test: Fx(s, t)
                 }
             });
             else {
                 const {
                     selection: s,
                     param: a,
                     test: o,
                     ...l
-                } = fz(n.condition, t);
+                } = V8(n.condition, t);
                 n.condition = a ? n.condition : {
                     ...l,
-                    test: tx(n.condition, t)
+                    test: Fx(n.condition, t)
                 }
             } return n
     }
 
-    function hz(e) {
+    function K8(e) {
         const t = e.extent;
         if (t != null && t.selection) {
             const {
                 selection: n,
                 ...i
             } = t;
             return {
@@ -42310,146 +35617,146 @@
                     param: n
                 }
             }
         }
         return e
     }
 
-    function tx(e, t) {
-        const n = i => Eu(i, r => {
+    function Fx(e, t) {
+        const n = i => Vu(i, r => {
             var s;
             const a = t.emptySelections[r] ?? !0,
                 o = {
                     param: r,
                     empty: a
                 };
             return (s = t.selectionPredicates)[r] ?? (s[r] = []), t.selectionPredicates[r].push(o), o
         });
-        return e.selection ? n(e.selection) : Eu(e.test || e.filter, i => i.selection ? n(i.selection) : i)
+        return e.selection ? n(e.selection) : Vu(e.test || e.filter, i => i.selection ? n(i.selection) : i)
     }
-    class nx extends mC {
+    class Rx extends aC {
         map(t, n) {
             const i = n.selections ?? [];
-            if (t.params && !Zs(t)) {
+            if (t.params && !da(t)) {
                 const r = [];
-                for (const s of t.params) dC(s) ? i.push(s) : r.push(s);
+                for (const s of t.params) iC(s) ? i.push(s) : r.push(s);
                 t.params = r
             }
             return n.selections = i, super.map(t, n)
         }
         mapUnit(t, n) {
             const i = n.selections;
             if (!i || !i.length) return t;
             const r = (n.path ?? []).concat(t.name),
                 s = [];
             for (const a of i)
                 if (!a.views || !a.views.length) s.push(a);
                 else
-                    for (const o of a.views)(re(o) && (o === t.name || r.includes(o)) || W(o) && o.map(l => r.indexOf(l)).every((l, u, c) => l !== -1 && (u === 0 || l > c[u - 1]))) && s.push(a);
+                    for (const o of a.views)(le(o) && (o === t.name || r.includes(o)) || H(o) && o.map(l => r.indexOf(l)).every((l, u, c) => l !== -1 && (u === 0 || l > c[u - 1]))) && s.push(a);
             return s.length && (t.params = s), t
         }
     }
     for (const e of ["mapFacet", "mapRepeat", "mapHConcat", "mapVConcat", "mapLayer"]) {
-        const t = nx.prototype[e];
-        nx.prototype[e] = function(n, i) {
-            return t.call(this, n, Fge(n, i))
+        const t = Rx.prototype[e];
+        Rx.prototype[e] = function(n, i) {
+            return t.call(this, n, Qde(n, i))
         }
     }
 
-    function Fge(e, t) {
+    function Qde(e, t) {
         return e.name ? {
             ...t,
             path: (t.path ?? []).concat(e.name)
         } : t
     }
 
-    function dz(e, t) {
-        t === void 0 && (t = sz(e.config));
-        const n = Pge(e, t),
+    function J8(e, t) {
+        t === void 0 && (t = U8(e.config));
+        const n = nge(e, t),
             {
                 width: i,
                 height: r
             } = e,
-            s = Lge(n, {
+            s = ige(n, {
                 width: i,
                 height: r,
                 autosize: e.autosize
             }, t);
         return {
             ...n,
             ...s ? {
                 autosize: s
             } : {}
         }
     }
-    const Rge = new fge,
-        Dge = new Oge,
-        Nge = new nx;
+    const Zde = new Mde,
+        ege = new Jde,
+        tge = new Rx;
 
-    function Pge(e, t = {}) {
+    function nge(e, t = {}) {
         const n = {
             config: t
         };
-        return Nge.map(Rge.map(Dge.map(e, n), n), n)
+        return tge.map(Zde.map(ege.map(e, n), n), n)
     }
 
-    function e3(e) {
-        return re(e) ? {
+    function _M(e) {
+        return le(e) ? {
             type: e
         } : e ?? {}
     }
 
-    function Lge(e, t, n) {
+    function ige(e, t, n) {
         let {
             width: i,
             height: r
         } = t;
-        const s = Zs(e) || W1(e),
+        const s = da(e) || wy(e),
             a = {};
-        s ? i == "container" && r == "container" ? (a.type = "fit", a.contains = "padding") : i == "container" ? (a.type = "fit-x", a.contains = "padding") : r == "container" && (a.type = "fit-y", a.contains = "padding") : (i == "container" && (X(C5("width")), i = void 0), r == "container" && (X(C5("height")), r = void 0));
+        s ? i == "container" && r == "container" ? (a.type = "fit", a.contains = "padding") : i == "container" ? (a.type = "fit-x", a.contains = "padding") : r == "container" && (a.type = "fit-y", a.contains = "padding") : (i == "container" && (J(H5("width")), i = void 0), r == "container" && (J(H5("height")), r = void 0));
         const o = {
             type: "pad",
             ...a,
-            ...n ? e3(n.autosize) : {},
-            ...e3(e.autosize)
+            ...n ? _M(n.autosize) : {},
+            ..._M(e.autosize)
         };
-        if (o.type === "fit" && !s && (X(Bce), o.type = "pad"), i == "container" && !(o.type == "fit" || o.type == "fit-x") && X(k5("width")), r == "container" && !(o.type == "fit" || o.type == "fit-y") && X(k5("height")), !Nr(o, {
+        if (o.type === "fit" && !s && (J(ice), o.type = "pad"), i == "container" && !(o.type == "fit" || o.type == "fit-x") && J(Y5("width")), r == "container" && !(o.type == "fit" || o.type == "fit-y") && J(Y5("height")), !Jr(o, {
                 type: "pad"
             })) return o
     }
 
-    function Ige(e) {
+    function rge(e) {
         return e === "fit" || e === "fit-x" || e === "fit-y"
     }
 
-    function zge(e) {
-        return e ? `fit-${k1(e)}` : "fit"
+    function sge(e) {
+        return e ? `fit-${ry(e)}` : "fit"
     }
-    const Bge = ["background", "padding"];
+    const age = ["background", "padding"];
 
-    function t3(e, t) {
+    function wM(e, t) {
         const n = {};
-        for (const i of Bge) e && e[i] !== void 0 && (n[i] = di(e[i]));
+        for (const i of age) e && e[i] !== void 0 && (n[i] = Ci(e[i]));
         return t && (n.params = e.params), n
     }
-    class ea {
+    class ga {
         constructor(t = {}, n = {}) {
             this.explicit = t, this.implicit = n
         }
         clone() {
-            return new ea(ke(this.explicit), ke(this.implicit))
+            return new ga(Fe(this.explicit), Fe(this.implicit))
         }
         combine() {
             return {
                 ...this.explicit,
                 ...this.implicit
             }
         }
         get(t) {
-            return Ct(this.explicit[t], this.implicit[t])
+            return Gt(this.explicit[t], this.implicit[t])
         }
         getWithExplicit(t) {
             return this.explicit[t] !== void 0 ? {
                 explicit: !0,
                 value: this.explicit[t]
             } : this.implicit[t] !== void 0 ? {
                 explicit: !1,
@@ -42474,220 +35781,220 @@
         }) {
             n[t] !== void 0 ? this.set(t, n[t], !0) : i[t] !== void 0 && this.set(t, i[t], !1)
         }
         copyKeyFromObject(t, n) {
             n[t] !== void 0 && this.set(t, n[t], !0)
         }
         copyAll(t) {
-            for (const n of H(t.combine())) {
+            for (const n of K(t.combine())) {
                 const i = t.getWithExplicit(n);
                 this.setWithExplicit(n, i)
             }
         }
     }
 
-    function Mr(e) {
+    function Hr(e) {
         return {
             explicit: !0,
             value: e
         }
     }
 
-    function ci(e) {
+    function Si(e) {
         return {
             explicit: !1,
             value: e
         }
     }
 
-    function gz(e) {
+    function Q8(e) {
         return (t, n, i, r) => {
             const s = e(t.value, n.value);
-            return s > 0 ? t : s < 0 ? n : q1(t, n, i, r)
+            return s > 0 ? t : s < 0 ? n : Sy(t, n, i, r)
         }
     }
 
-    function q1(e, t, n, i) {
-        return e.explicit && t.explicit && X(Afe(n, i, e.value, t.value)), e
+    function Sy(e, t, n, i) {
+        return e.explicit && t.explicit && J(Wce(n, i, e.value, t.value)), e
     }
 
-    function Ua(e, t, n, i, r = q1) {
-        return e === void 0 || e.value === void 0 ? t : e.explicit && !t.explicit ? e : t.explicit && !e.explicit ? t : Nr(e.value, t.value) ? e : r(e, t, n, i)
+    function co(e, t, n, i, r = Sy) {
+        return e === void 0 || e.value === void 0 ? t : e.explicit && !t.explicit ? e : t.explicit && !e.explicit ? t : Jr(e.value, t.value) ? e : r(e, t, n, i)
     }
-    class jge extends ea {
+    class oge extends ga {
         constructor(t = {}, n = {}, i = !1) {
             super(t, n), this.explicit = t, this.implicit = n, this.parseNothing = i
         }
         clone() {
             const t = super.clone();
             return t.parseNothing = this.parseNothing, t
         }
     }
 
-    function oc(e) {
+    function Rc(e) {
         return "url" in e
     }
 
-    function Bh(e) {
+    function pd(e) {
         return "values" in e
     }
 
-    function pz(e) {
-        return "name" in e && !oc(e) && !Bh(e) && !$a(e)
+    function Z8(e) {
+        return "name" in e && !Rc(e) && !pd(e) && !Xa(e)
     }
 
-    function $a(e) {
-        return e && (mz(e) || yz(e) || vC(e))
+    function Xa(e) {
+        return e && (ez(e) || tz(e) || lC(e))
     }
 
-    function mz(e) {
+    function ez(e) {
         return "sequence" in e
     }
 
-    function yz(e) {
+    function tz(e) {
         return "sphere" in e
     }
 
-    function vC(e) {
+    function lC(e) {
         return "graticule" in e
     }
-    var st;
+    var pt;
     (function(e) {
         e[e.Raw = 0] = "Raw", e[e.Main = 1] = "Main", e[e.Row = 2] = "Row", e[e.Column = 3] = "Column", e[e.Lookup = 4] = "Lookup"
-    })(st || (st = {}));
+    })(pt || (pt = {}));
 
-    function vz(e) {
+    function nz(e) {
         const {
             signals: t,
             hasLegend: n,
             index: i,
             ...r
         } = e;
-        return r.field = Pi(r.field), r
+        return r.field = Ji(r.field), r
     }
 
-    function pl(e, t = !0, n = bn) {
-        if (W(e)) {
-            const i = e.map(r => pl(r, t, n));
+    function zl(e, t = !0, n = Pn) {
+        if (H(e)) {
+            const i = e.map(r => zl(r, t, n));
             return t ? `[${i.join(", ")}]` : i
-        } else if (Ll(e)) return n(t ? fl(e) : Qfe(e));
-        return t ? n(at(e)) : e
+        } else if (iu(e)) return n(t ? Nl(e) : pfe(e));
+        return t ? n(mt(e)) : e
     }
 
-    function Uge(e, t) {
-        for (const n of Qt(e.component.selection ?? {})) {
+    function lge(e, t) {
+        for (const n of bn(e.component.selection ?? {})) {
             const i = n.name;
-            let r = `${i}${Wa}, ${n.resolve==="global"?"true":`{unit: ${Yo(e)}}`}`;
-            for (const s of Y1) s.defined(n) && (s.signals && (t = s.signals(e, n, t)), s.modifyExpr && (r = s.modifyExpr(e, n, r)));
+            let r = `${i}${ho}, ${n.resolve==="global"?"true":`{unit: ${yl(e)}}`}`;
+            for (const s of ky) s.defined(n) && (s.signals && (t = s.signals(e, n, t)), s.modifyExpr && (r = s.modifyExpr(e, n, r)));
             t.push({
-                name: i + xpe,
+                name: i + Bge,
                 on: [{
                     events: {
-                        signal: n.name + Wa
+                        signal: n.name + ho
                     },
-                    update: `modify(${Z(n.name+ml)}, ${r})`
+                    update: `modify(${te(n.name+Bl)}, ${r})`
                 }]
             })
         }
-        return bC(t)
+        return uC(t)
     }
 
-    function Gge(e, t) {
-        if (e.component.selection && H(e.component.selection).length) {
-            const n = Z(e.getName("cell"));
+    function uge(e, t) {
+        if (e.component.selection && K(e.component.selection).length) {
+            const n = te(e.getName("cell"));
             t.unshift({
                 name: "facet",
                 value: {},
                 on: [{
-                    events: to("mousemove", "scope"),
+                    events: wo("mousemove", "scope"),
                     update: `isTuple(facet) ? facet : group(${n}).datum`
                 }]
             })
         }
-        return bC(t)
+        return uC(t)
     }
 
-    function Wge(e, t) {
+    function cge(e, t) {
         let n = !1;
-        for (const i of Qt(e.component.selection ?? {})) {
+        for (const i of bn(e.component.selection ?? {})) {
             const r = i.name,
-                s = Z(r + ml);
+                s = te(r + Bl);
             if (t.filter(o => o.name === r).length === 0) {
                 const o = i.resolve === "global" ? "union" : i.resolve,
                     l = i.type === "point" ? ", true, true)" : ")";
                 t.push({
                     name: i.name,
-                    update: `${Nz}(${s}, ${Z(o)}${l}`
+                    update: `${bz}(${s}, ${te(o)}${l}`
                 })
             }
             n = !0;
-            for (const o of Y1) o.defined(i) && o.topLevelSignals && (t = o.topLevelSignals(e, i, t))
+            for (const o of ky) o.defined(i) && o.topLevelSignals && (t = o.topLevelSignals(e, i, t))
         }
         return n && t.filter(r => r.name === "unit").length === 0 && t.unshift({
             name: "unit",
             value: {},
             on: [{
                 events: "mousemove",
                 update: "isTuple(group()) ? group() : unit"
             }]
-        }), bC(t)
+        }), uC(t)
     }
 
-    function qge(e, t) {
+    function fge(e, t) {
         const n = [...t],
-            i = Yo(e, {
+            i = yl(e, {
                 escape: !1
             });
-        for (const r of Qt(e.component.selection ?? {})) {
+        for (const r of bn(e.component.selection ?? {})) {
             const s = {
-                name: r.name + ml
+                name: r.name + Bl
             };
             if (r.project.hasSelectionId && (s.transform = [{
                     type: "collect",
                     sort: {
-                        field: pr
+                        field: Mr
                     }
                 }]), r.init) {
-                const o = r.project.items.map(vz);
+                const o = r.project.items.map(nz);
                 s.values = r.project.hasSelectionId ? r.init.map(l => ({
                     unit: i,
-                    [pr]: pl(l, !1)[0]
+                    [Mr]: zl(l, !1)[0]
                 })) : r.init.map(l => ({
                     unit: i,
                     fields: o,
-                    values: pl(l, !1)
+                    values: zl(l, !1)
                 }))
             }
-            n.filter(o => o.name === r.name + ml).length || n.push(s)
+            n.filter(o => o.name === r.name + Bl).length || n.push(s)
         }
         return n
     }
 
-    function bz(e, t) {
-        for (const n of Qt(e.component.selection ?? {}))
-            for (const i of Y1) i.defined(n) && i.marks && (t = i.marks(e, n, t));
+    function iz(e, t) {
+        for (const n of bn(e.component.selection ?? {}))
+            for (const i of ky) i.defined(n) && i.marks && (t = i.marks(e, n, t));
         return t
     }
 
-    function Hge(e, t) {
-        for (const n of e.children) Et(n) && (t = bz(n, t));
+    function hge(e, t) {
+        for (const n of e.children) Dt(n) && (t = iz(n, t));
         return t
     }
 
-    function Yge(e, t, n, i) {
-        const r = Bz(e, t.param, t);
+    function dge(e, t, n, i) {
+        const r = Ez(e, t.param, t);
         return {
-            signal: wi(n.get("type")) && W(i) && i[0] > i[1] ? `isValid(${r}) && reverse(${r})` : r
+            signal: Ni(n.get("type")) && H(i) && i[0] > i[1] ? `isValid(${r}) && reverse(${r})` : r
         }
     }
 
-    function bC(e) {
+    function uC(e) {
         return e.map(t => (t.on && !t.on.length && delete t.on, t))
     }
-    class nt {
+    class ut {
         constructor(t, n) {
             this.debugName = n, this._children = [], this._parent = null, t && (this.parent = t)
         }
         clone() {
             throw new Error("Cannot clone node")
         }
         get parent() {
@@ -42700,15 +36007,15 @@
             return this._children
         }
         numChildren() {
             return this._children.length
         }
         addChild(t, n) {
             if (this._children.includes(t)) {
-                X(Zce);
+                J(mce);
                 return
             }
             n !== void 0 ? this._children.splice(n, 0, t) : this._children.push(t)
         }
         removeChild(t) {
             const n = this._children.indexOf(t);
             return this._children.splice(n, 1), n
@@ -42726,410 +36033,442 @@
                 n = t.parent;
             for (const r of this._children) r.parent = t;
             this._children = [], t.removeChild(this);
             const i = t.parent.removeChild(t);
             this._parent = n, n.addChild(this, i), t.parent = this
         }
     }
-    class Dn extends nt {
+    class Xn extends ut {
         clone() {
             const t = new this.constructor;
             return t.debugName = `clone_${this.debugName}`, t._source = this._source, t._name = `clone_${this._name}`, t.type = this.type, t.refCounts = this.refCounts, t.refCounts[t._name] = 0, t
         }
         constructor(t, n, i, r) {
             super(t, n), this.type = i, this.refCounts = r, this._source = this._name = n, this.refCounts && !(this._name in this.refCounts) && (this.refCounts[this._name] = 0)
         }
         dependentFields() {
             return new Set
         }
         producedFields() {
             return new Set
         }
         hash() {
-            return this._hash === void 0 && (this._hash = `Output ${yI()}`), this._hash
+            return this._hash === void 0 && (this._hash = `Output ${ZI()}`), this._hash
         }
         getSource() {
             return this.refCounts[this._name]++, this._source
         }
         isRequired() {
             return !!this.refCounts[this._name]
         }
         setSource(t) {
             this._source = t
         }
     }
-    class jr extends nt {
+
+    function sb(e) {
+        return e.as !== void 0
+    }
+
+    function SM(e) {
+        return `${e}_end`
+    }
+    class is extends ut {
         clone() {
-            return new jr(null, ke(this.formula))
+            return new is(null, Fe(this.formula))
         }
         constructor(t, n) {
             super(t), this.formula = n
         }
         static makeFromEncoding(t, n) {
             const i = n.reduceFieldDef((r, s) => {
                 const {
                     field: a,
                     timeUnit: o
                 } = s;
                 if (o) {
-                    const l = ie(s, {
-                        forAs: !0
-                    });
-                    r[Ne({
-                        as: l,
-                        field: a,
-                        timeUnit: o
-                    })] = {
-                        as: l,
+                    let l;
+                    if (ru(o)) {
+                        if (Dt(n)) {
+                            const {
+                                mark: u
+                            } = n;
+                            (zk(u) || s.bandPosition) && (l = {
+                                timeUnit: an(o),
+                                field: a
+                            })
+                        }
+                    } else l = {
+                        as: oe(s, {
+                            forAs: !0
+                        }),
                         field: a,
                         timeUnit: o
-                    }
+                    };
+                    l && (r[ze(l)] = l)
                 }
                 return r
             }, {});
-            return et(i) ? null : new jr(t, i)
+            return ft(i) ? null : new is(t, i)
         }
         static makeFromTransform(t, n) {
             const {
                 timeUnit: i,
                 ...r
             } = {
                 ...n
-            }, s = en(i), a = {
+            }, s = an(i), a = {
                 ...r,
                 timeUnit: s
             };
-            return new jr(t, {
-                [Ne(a)]: a
+            return new is(t, {
+                [ze(a)]: a
             })
         }
         merge(t) {
             this.formula = {
                 ...this.formula
             };
             for (const n in t.formula) this.formula[n] || (this.formula[n] = t.formula[n]);
             for (const n of t.children) t.removeChild(n), n.parent = this;
             t.remove()
         }
         removeFormulas(t) {
             const n = {};
-            for (const [i, r] of Ba(this.formula)) t.has(r.as) || (n[i] = r);
+            for (const [i, r] of lo(this.formula)) {
+                const s = sb(r) ? r.as : `${r.field}_end`;
+                t.has(s) || (n[i] = r)
+            }
             this.formula = n
         }
         producedFields() {
-            return new Set(Qt(this.formula).map(t => t.as))
+            return new Set(bn(this.formula).map(t => sb(t) ? t.as : SM(t.field)))
         }
         dependentFields() {
-            return new Set(Qt(this.formula).map(t => t.field))
+            return new Set(bn(this.formula).map(t => t.field))
         }
         hash() {
-            return `TimeUnit ${Ne(this.formula)}`
+            return `TimeUnit ${ze(this.formula)}`
         }
         assemble() {
             const t = [];
-            for (const n of Qt(this.formula)) {
+            for (const n of bn(this.formula))
+                if (sb(n)) {
+                    const {
+                        field: i,
+                        as: r,
+                        timeUnit: s
+                    } = n, {
+                        unit: a,
+                        utc: o,
+                        ...l
+                    } = an(s);
+                    t.push({
+                        field: Ji(i),
+                        type: "timeunit",
+                        ...a ? {
+                            units: ly(a)
+                        } : {},
+                        ...o ? {
+                            timezone: "utc"
+                        } : {},
+                        ...l,
+                        as: [r, `${r}_end`]
+                    })
+                } else if (n) {
                 const {
                     field: i,
-                    as: r,
-                    timeUnit: s
-                } = n, {
-                    unit: a,
-                    utc: o,
-                    ...l
-                } = en(s);
+                    timeUnit: r
+                } = n, s = P6(r == null ? void 0 : r.unit), {
+                    part: a,
+                    step: o
+                } = B6(s, r.step);
                 t.push({
-                    field: Pi(i),
-                    type: "timeunit",
-                    ...a ? {
-                        units: M1(a)
-                    } : {},
-                    ...o ? {
-                        timezone: "utc"
-                    } : {},
-                    ...l,
-                    as: [r, `${r}_end`]
+                    type: "formula",
+                    expr: `timeOffset('${a}', datum['${i}'], ${o})`,
+                    as: SM(i)
                 })
             }
             return t
         }
     }
-    const Ld = "_tuple_fields";
-    class Xge {
+    const dg = "_tuple_fields";
+    class gge {
         constructor(...t) {
             this.items = t, this.hasChannel = {}, this.hasField = {}, this.hasSelectionId = !1
         }
     }
-    const Vge = {
+    const pge = {
             defined: () => !0,
             parse: (e, t, n) => {
                 const i = t.name,
-                    r = t.project ?? (t.project = new Xge),
+                    r = t.project ?? (t.project = new gge),
                     s = {},
                     a = {},
                     o = new Set,
                     l = (g, p) => {
                         const m = p === "visual" ? g.channel : g.field;
-                        let y = ft(`${i}_${m}`);
-                        for (let v = 1; o.has(y); v++) y = ft(`${i}_${m}_${v}`);
+                        let y = Et(`${i}_${m}`);
+                        for (let v = 1; o.has(y); v++) y = Et(`${i}_${m}_${v}`);
                         return o.add(y), {
                             [p]: y
                         }
                     },
                     u = t.type,
                     c = e.config.selection[u],
-                    f = n.value !== void 0 ? se(n.value) : null;
+                    f = n.value !== void 0 ? ue(n.value) : null;
                 let {
                     fields: h,
                     encodings: d
-                } = ae(n.select) ? n.select : {};
+                } = ce(n.select) ? n.select : {};
                 if (!h && !d && f) {
                     for (const g of f)
-                        if (ae(g))
-                            for (const p of H(g)) mce(p) ? (d || (d = [])).push(p) : u === "interval" ? (X(Vce), d = c.encodings) : (h ?? (h = [])).push(p)
+                        if (ce(g))
+                            for (const p of K(g)) Rue(p) ? (d || (d = [])).push(p) : u === "interval" ? (J(hce), d = c.encodings) : (h ?? (h = [])).push(p)
                 }!h && !d && (d = c.encodings, "fields" in c && (h = c.fields));
                 for (const g of d ?? []) {
                     const p = e.fieldDef(g);
                     if (p) {
                         let m = p.field;
                         if (p.aggregate) {
-                            X(jce(g, p.aggregate));
+                            J(rce(g, p.aggregate));
                             continue
                         } else if (!m) {
-                            X($5(g));
+                            J(V5(g));
                             continue
                         }
-                        if (p.timeUnit) {
+                        if (p.timeUnit && !ru(p.timeUnit)) {
                             m = e.vgField(g);
                             const y = {
                                 timeUnit: p.timeUnit,
                                 as: m,
                                 field: p.field
                             };
-                            a[Ne(y)] = y
+                            a[ze(y)] = y
                         }
                         if (!s[m]) {
-                            const y = u === "interval" && Qs(g) && wi(e.getScaleComponent(g).get("type")) ? "R" : p.bin ? "R-RE" : "E",
+                            const y = u === "interval" && ha(g) && Ni(e.getScaleComponent(g).get("type")) ? "R" : p.bin ? "R-RE" : "E",
                                 v = {
                                     field: m,
                                     channel: g,
                                     type: y,
                                     index: r.items.length
                                 };
                             v.signals = {
                                 ...l(v, "data"),
                                 ...l(v, "visual")
-                            }, r.items.push(s[m] = v), r.hasField[m] = s[m], r.hasSelectionId = r.hasSelectionId || m === pr, SI(g) ? (v.geoChannel = g, v.channel = wI(g), r.hasChannel[v.channel] = s[m]) : r.hasChannel[g] = s[m]
+                            }, r.items.push(s[m] = v), r.hasField[m] = s[m], r.hasSelectionId = r.hasSelectionId || m === Mr, s6(g) ? (v.geoChannel = g, v.channel = r6(g), r.hasChannel[v.channel] = s[m]) : r.hasChannel[g] = s[m]
                         }
-                    } else X($5(g))
+                    } else J(V5(g))
                 }
                 for (const g of h ?? []) {
                     if (r.hasField[g]) continue;
                     const p = {
                         type: "E",
                         field: g,
                         index: r.items.length
                     };
                     p.signals = {
                         ...l(p, "data")
-                    }, r.items.push(p), r.hasField[g] = p, r.hasSelectionId = r.hasSelectionId || g === pr
+                    }, r.items.push(p), r.hasField[g] = p, r.hasSelectionId = r.hasSelectionId || g === Mr
                 }
-                f && (t.init = f.map(g => r.items.map(p => ae(g) ? g[p.geoChannel || p.channel] !== void 0 ? g[p.geoChannel || p.channel] : g[p.field] : g))), et(a) || (r.timeUnit = new jr(null, a))
+                f && (t.init = f.map(g => r.items.map(p => ce(g) ? g[p.geoChannel || p.channel] !== void 0 ? g[p.geoChannel || p.channel] : g[p.field] : g))), ft(a) || (r.timeUnit = new is(null, a))
             },
             signals: (e, t, n) => {
-                const i = t.name + Ld;
+                const i = t.name + dg;
                 return n.filter(s => s.name === i).length > 0 || t.project.hasSelectionId ? n : n.concat({
                     name: i,
-                    value: t.project.items.map(vz)
+                    value: t.project.items.map(nz)
                 })
             }
         },
-        Ns = {
+        Js = {
             defined: e => e.type === "interval" && e.resolve === "global" && e.bind && e.bind === "scales",
             parse: (e, t) => {
                 const n = t.scales = [];
                 for (const i of t.project.items) {
                     const r = i.channel;
-                    if (!Qs(r)) continue;
+                    if (!ha(r)) continue;
                     const s = e.getScaleComponent(r),
                         a = s ? s.get("type") : void 0;
-                    if (!s || !wi(a)) {
-                        X(Wce);
+                    if (!s || !Ni(a)) {
+                        J(oce);
                         continue
                     }
                     s.set("selectionExtent", {
                         param: t.name,
                         field: i.field
                     }, !0), n.push(i)
                 }
             },
             topLevelSignals: (e, t, n) => {
                 const i = t.scales.filter(a => n.filter(o => o.name === a.signals.data).length === 0);
-                if (!e.parent || n3(e) || i.length === 0) return n;
+                if (!e.parent || EM(e) || i.length === 0) return n;
                 const r = n.filter(a => a.name === t.name)[0];
                 let s = r.update;
-                if (s.indexOf(Nz) >= 0) r.update = `{${i.map(a=>`${Z(Pi(a.field))}: ${a.signals.data}`).join(", ")}}`;
+                if (s.indexOf(bz) >= 0) r.update = `{${i.map(a=>`${te(Ji(a.field))}: ${a.signals.data}`).join(", ")}}`;
                 else {
                     for (const a of i) {
-                        const o = `${Z(Pi(a.field))}: ${a.signals.data}`;
+                        const o = `${te(Ji(a.field))}: ${a.signals.data}`;
                         s.includes(o) || (s = `${s.substring(0,s.length-1)}, ${o}}`)
                     }
                     r.update = s
                 }
                 return n.concat(i.map(a => ({
                     name: a.signals.data
                 })))
             },
             signals: (e, t, n) => {
-                if (e.parent && !n3(e))
+                if (e.parent && !EM(e))
                     for (const i of t.scales) {
                         const r = n.filter(s => s.name === i.signals.data)[0];
                         r.push = "outer", delete r.value, delete r.update
                     }
                 return n
             }
         };
 
-    function ix(e, t) {
-        return `domain(${Z(e.scaleName(t))})`
+    function Dx(e, t) {
+        return `domain(${te(e.scaleName(t))})`
     }
 
-    function n3(e) {
-        return e.parent && Ic(e.parent) && !e.parent.parent
+    function EM(e) {
+        return e.parent && cf(e.parent) && !e.parent.parent
     }
-    const Au = "_brush",
-        xz = "_scale_trigger",
-        ff = "geo_interval_init_tick",
-        _z = "_init",
-        Kge = "_center",
-        Jge = {
+    const Qu = "_brush",
+        rz = "_scale_trigger",
+        Lf = "geo_interval_init_tick",
+        sz = "_init",
+        mge = "_center",
+        yge = {
             defined: e => e.type === "interval",
             parse: (e, t, n) => {
                 var i;
                 if (e.hasProjection) {
                     const r = {
-                        ...ae(n.select) ? n.select : {}
+                        ...ce(n.select) ? n.select : {}
                     };
-                    r.fields = [pr], r.encodings || (r.encodings = n.value ? H(n.value) : [Sr, wr]), n.select = {
+                    r.fields = [Mr], r.encodings || (r.encodings = n.value ? K(n.value) : [Lr, Pr]), n.select = {
                         type: "interval",
                         ...r
                     }
                 }
-                if (t.translate && !Ns.defined(t)) {
-                    const r = `!event.item || event.item.mark.name !== ${Z(t.name+Au)}`;
+                if (t.translate && !Js.defined(t)) {
+                    const r = `!event.item || event.item.mark.name !== ${te(t.name+Qu)}`;
                     for (const s of t.events) {
                         if (!s.between) {
-                            X(`${s} is not an ordered event stream for interval selections.`);
+                            J(`${s} is not an ordered event stream for interval selections.`);
                             continue
                         }
-                        const a = se((i = s.between[0]).filter ?? (i.filter = []));
+                        const a = ue((i = s.between[0]).filter ?? (i.filter = []));
                         a.indexOf(r) < 0 && a.push(r)
                     }
                 }
             },
             signals: (e, t, n) => {
                 const i = t.name,
-                    r = i + Wa,
-                    s = Qt(t.project.hasChannel).filter(o => o.channel === ht || o.channel === Gt),
+                    r = i + ho,
+                    s = bn(t.project.hasChannel).filter(o => o.channel === kt || o.channel === un),
                     a = t.init ? t.init[0] : null;
-                if (n.push(...s.reduce((o, l) => o.concat(Qge(e, t, l, a && a[l.index])), [])), e.hasProjection) {
-                    const o = Z(e.projectionName()),
-                        l = e.projectionName() + Kge,
+                if (n.push(...s.reduce((o, l) => o.concat(vge(e, t, l, a && a[l.index])), [])), e.hasProjection) {
+                    const o = te(e.projectionName()),
+                        l = e.projectionName() + mge,
                         {
                             x: u,
                             y: c
                         } = t.project.hasChannel,
                         f = u && u.signals.visual,
                         h = c && c.signals.visual,
                         d = u ? a && a[u.index] : `${l}[0]`,
                         g = c ? a && a[c.index] : `${l}[1]`,
                         p = _ => e.getSizeSignalRef(_).signal,
                         m = `[[${f?f+"[0]":"0"}, ${h?h+"[0]":"0"}],[${f?f+"[1]":p("width")}, ${h?h+"[1]":p("height")}]]`;
                     a && (n.unshift({
-                        name: i + _z,
+                        name: i + sz,
                         init: `[scale(${o}, [${u?d[0]:d}, ${c?g[0]:g}]), scale(${o}, [${u?d[1]:d}, ${c?g[1]:g}])]`
                     }), (!u || !c) && (n.find(S => S.name === l) || n.unshift({
                         name: l,
                         update: `invert(${o}, [${p("width")}/2, ${p("height")}/2])`
                     })));
-                    const y = `intersect(${m}, {markname: ${Z(e.getName("marks"))}}, unit.mark)`,
-                        v = `{unit: ${Yo(e)}}`,
+                    const y = `intersect(${m}, {markname: ${te(e.getName("marks"))}}, unit.mark)`,
+                        v = `{unit: ${yl(e)}}`,
                         b = `vlSelectionTuples(${y}, ${v})`,
                         x = s.map(_ => _.signals.visual);
                     return n.concat({
                         name: r,
                         on: [{
                             events: [...x.length ? [{
                                 signal: x.join(" || ")
                             }] : [], ...a ? [{
-                                signal: ff
+                                signal: Lf
                             }] : []],
                             update: b
                         }]
                     })
                 } else {
-                    if (!Ns.defined(t)) {
-                        const u = i + xz,
+                    if (!Js.defined(t)) {
+                        const u = i + rz,
                             c = s.map(f => {
                                 const h = f.channel,
                                     {
                                         data: d,
                                         visual: g
                                     } = f.signals,
-                                    p = Z(e.scaleName(h)),
+                                    p = te(e.scaleName(h)),
                                     m = e.getScaleComponent(h).get("type"),
-                                    y = wi(m) ? "+" : "";
+                                    y = Ni(m) ? "+" : "";
                                 return `(!isArray(${d}) || (${y}invert(${p}, ${g})[0] === ${y}${d}[0] && ${y}invert(${p}, ${g})[1] === ${y}${d}[1]))`
                             });
                         c.length && n.push({
                             name: u,
                             value: {},
                             on: [{
                                 events: s.map(f => ({
                                     scale: e.scaleName(f.channel)
                                 })),
                                 update: c.join(" && ") + ` ? ${u} : {}`
                             }]
                         })
                     }
                     const o = s.map(u => u.signals.data),
-                        l = `unit: ${Yo(e)}, fields: ${i+Ld}, values`;
+                        l = `unit: ${yl(e)}, fields: ${i+dg}, values`;
                     return n.concat({
                         name: r,
                         ...a ? {
-                            init: `{${l}: ${pl(a)}}`
+                            init: `{${l}: ${zl(a)}}`
                         } : {},
                         ...o.length ? {
                             on: [{
                                 events: [{
                                     signal: o.join(" || ")
                                 }],
                                 update: `${o.join(" && ")} ? {${l}: [${o}]} : null`
                             }]
                         } : {}
                     })
                 }
             },
-            topLevelSignals: (e, t, n) => (Et(e) && e.hasProjection && t.init && (n.filter(r => r.name === ff).length || n.unshift({
-                name: ff,
+            topLevelSignals: (e, t, n) => (Dt(e) && e.hasProjection && t.init && (n.filter(r => r.name === Lf).length || n.unshift({
+                name: Lf,
                 value: null,
                 on: [{
                     events: "timer{1}",
-                    update: `${ff} === null ? {} : ${ff}`
+                    update: `${Lf} === null ? {} : ${Lf}`
                 }]
             })), n),
             marks: (e, t, n) => {
                 const i = t.name,
                     {
                         x: r,
                         y: s
                     } = t.project.hasChannel,
                     a = r == null ? void 0 : r.signals.visual,
                     o = s == null ? void 0 : s.signals.visual,
-                    l = `data(${Z(t.name+ml)})`;
-                if (Ns.defined(t) || !r && !s) return n;
+                    l = `data(${te(t.name+Bl)})`;
+                if (Js.defined(t) || !r && !s) return n;
                 const u = {
                     x: r !== void 0 ? {
                         signal: `${a}[0]`
                     } : {
                         value: 0
                     },
                     y: s !== void 0 ? {
@@ -43149,48 +36488,48 @@
                     } : {
                         field: {
                             group: "height"
                         }
                     }
                 };
                 if (t.resolve === "global")
-                    for (const p of H(u)) u[p] = [{
-                        test: `${l}.length && ${l}[0].unit === ${Yo(e)}`,
+                    for (const p of K(u)) u[p] = [{
+                        test: `${l}.length && ${l}[0].unit === ${yl(e)}`,
                         ...u[p]
                     }, {
                         value: 0
                     }];
                 const {
                     fill: c,
                     fillOpacity: f,
                     cursor: h,
                     ...d
-                } = t.mark, g = H(d).reduce((p, m) => (p[m] = [{
+                } = t.mark, g = K(d).reduce((p, m) => (p[m] = [{
                     test: [r !== void 0 && `${a}[0] !== ${a}[1]`, s !== void 0 && `${o}[0] !== ${o}[1]`].filter(y => y).join(" && "),
                     value: d[m]
                 }, {
                     value: null
                 }], p), {});
                 return [{
-                    name: `${i+Au}_bg`,
+                    name: `${i+Qu}_bg`,
                     type: "rect",
                     clip: !0,
                     encode: {
                         enter: {
                             fill: {
                                 value: c
                             },
                             fillOpacity: {
                                 value: f
                             }
                         },
                         update: u
                     }
                 }, ...n, {
-                    name: i + Au,
+                    name: i + Qu,
                     type: "rect",
                     clip: !0,
                     encode: {
                         enter: {
                             ...h ? {
                                 cursor: {
                                     value: h
@@ -43205,463 +36544,463 @@
                             ...g
                         }
                     }
                 }]
             }
         };
 
-    function Qge(e, t, n, i) {
+    function vge(e, t, n, i) {
         const r = !e.hasProjection,
             s = n.channel,
             a = n.signals.visual,
-            o = Z(r ? e.scaleName(s) : e.projectionName()),
+            o = te(r ? e.scaleName(s) : e.projectionName()),
             l = h => `scale(${o}, ${h})`,
-            u = e.getSizeSignalRef(s === ht ? "width" : "height").signal,
+            u = e.getSizeSignalRef(s === kt ? "width" : "height").signal,
             c = `${s}(unit)`,
             f = t.events.reduce((h, d) => [...h, {
                 events: d.between[0],
                 update: `[${c}, ${c}]`
             }, {
                 events: d,
                 update: `[${a}[0], clamp(${c}, 0, ${u})]`
             }], []);
         if (r) {
             const h = n.signals.data,
-                d = Ns.defined(t),
+                d = Js.defined(t),
                 g = e.getScaleComponent(s),
                 p = g ? g.get("type") : void 0,
                 m = i ? {
-                    init: pl(i, !0, l)
+                    init: zl(i, !0, l)
                 } : {
                     value: []
                 };
             return f.push({
                 events: {
-                    signal: t.name + xz
+                    signal: t.name + rz
                 },
-                update: wi(p) ? `[${l(`${h}[0]`)}, ${l(`${h}[1]`)}]` : "[0, 0]"
+                update: Ni(p) ? `[${l(`${h}[0]`)}, ${l(`${h}[1]`)}]` : "[0, 0]"
             }), d ? [{
                 name: h,
                 on: []
             }] : [{
                 name: a,
                 ...m,
                 on: f
             }, {
                 name: h,
                 ...i ? {
-                    init: pl(i)
+                    init: zl(i)
                 } : {},
                 on: [{
                     events: {
                         signal: a
                     },
                     update: `${a}[0] === ${a}[1] ? null : invert(${o}, ${a})`
                 }]
             }]
         } else {
-            const h = s === ht ? 0 : 1,
-                d = t.name + _z,
+            const h = s === kt ? 0 : 1,
+                d = t.name + sz,
                 g = i ? {
                     init: `[${d}[0][${h}], ${d}[1][${h}]]`
                 } : {
                     value: []
                 };
             return [{
                 name: a,
                 ...g,
                 on: f
             }]
         }
     }
-    const Zge = {
+    const bge = {
         defined: e => e.type === "point",
         signals: (e, t, n) => {
             const i = t.name,
-                r = i + Ld,
+                r = i + dg,
                 s = t.project,
                 a = "(item().isVoronoi ? datum.datum : datum)",
-                o = Qt(e.component.selection ?? {}).reduce((f, h) => h.type === "interval" ? f.concat(h.name + Au) : f, []).map(f => `indexof(item().mark.name, '${f}') < 0`).join(" && "),
+                o = bn(e.component.selection ?? {}).reduce((f, h) => h.type === "interval" ? f.concat(h.name + Qu) : f, []).map(f => `indexof(item().mark.name, '${f}') < 0`).join(" && "),
                 l = `datum && item().mark.marktype !== 'group' && indexof(item().mark.role, 'legend') < 0${o?` && ${o}`:""}`;
-            let u = `unit: ${Yo(e)}, `;
-            if (t.project.hasSelectionId) u += `${pr}: ${a}[${Z(pr)}]`;
+            let u = `unit: ${yl(e)}, `;
+            if (t.project.hasSelectionId) u += `${Mr}: ${a}[${te(Mr)}]`;
             else {
                 const f = s.items.map(h => {
                     const d = e.fieldDef(h.channel);
-                    return d != null && d.bin ? `[${a}[${Z(e.vgField(h.channel,{}))}], ${a}[${Z(e.vgField(h.channel,{binSuffix:"end"}))}]]` : `${a}[${Z(h.field)}]`
+                    return d != null && d.bin ? `[${a}[${te(e.vgField(h.channel,{}))}], ${a}[${te(e.vgField(h.channel,{binSuffix:"end"}))}]]` : `${a}[${te(h.field)}]`
                 }).join(", ");
                 u += `fields: ${r}, values: [${f}]`
             }
             const c = t.events;
             return n.concat([{
-                name: i + Wa,
+                name: i + ho,
                 on: c ? [{
                     events: c,
                     update: `${l} ? {${u}} : null`,
                     force: !0
                 }] : []
             }])
         }
     };
 
-    function Dc(e, t, n, i) {
-        const r = L1(t) && t.condition,
+    function af(e, t, n, i) {
+        const r = py(t) && t.condition,
             s = i(t);
         if (r) {
-            const o = se(r).map(l => {
+            const o = ue(r).map(l => {
                 const u = i(l);
-                if (Xhe(l)) {
+                if (dhe(l)) {
                     const {
                         param: c,
                         empty: f
                     } = l;
                     return {
-                        test: zz(e, {
+                        test: Sz(e, {
                             param: c,
                             empty: f
                         }),
                         ...u
                     }
                 } else return {
-                    test: V0(e, l.test),
+                    test: M0(e, l.test),
                     ...u
                 }
             });
             return {
                 [n]: [...o, ...s !== void 0 ? [s] : []]
             }
         } else return s !== void 0 ? {
             [n]: s
         } : {}
     }
 
-    function xC(e, t = "text") {
+    function cC(e, t = "text") {
         const n = e.encoding[t];
-        return Dc(e, n, t, i => H1(i, e.config))
+        return af(e, n, t, i => Ey(i, e.config))
     }
 
-    function H1(e, t, n = "datum") {
+    function Ey(e, t, n = "datum") {
         if (e) {
-            if (gr(e)) return ut(e.value);
-            if (Ce(e)) {
+            if (Tr(e)) return bt(e.value);
+            if (De(e)) {
                 const {
                     format: i,
                     formatType: r
-                } = U0(e);
-                return ZE({
+                } = S0(e);
+                return Uk({
                     fieldOrDatumDef: e,
                     format: i,
                     formatType: r,
                     expr: n,
                     config: t
                 })
             }
         }
     }
 
-    function wz(e, t = {}) {
+    function az(e, t = {}) {
         const {
             encoding: n,
             markDef: i,
             config: r,
             stack: s
         } = e, a = n.tooltip;
-        if (W(a)) return {
-            tooltip: i3({
+        if (H(a)) return {
+            tooltip: kM({
                 tooltip: a
             }, s, r, t)
         }; {
             const o = t.reactiveGeom ? "datum.datum" : "datum";
-            return Dc(e, a, "tooltip", l => {
-                const u = H1(l, r, o);
+            return af(e, a, "tooltip", l => {
+                const u = Ey(l, r, o);
                 if (u) return u;
                 if (l === null) return;
-                let c = Xe("tooltip", i, r);
+                let c = st("tooltip", i, r);
                 if (c === !0 && (c = {
                         content: "encoding"
-                    }), re(c)) return {
+                    }), le(c)) return {
                     value: c
                 };
-                if (ae(c)) return he(c) ? c : c.content === "encoding" ? i3(n, s, r, t) : {
+                if (ce(c)) return xe(c) ? c : c.content === "encoding" ? kM(n, s, r, t) : {
                     signal: o
                 }
             })
         }
     }
 
-    function Sz(e, t, n, {
+    function oz(e, t, n, {
         reactiveGeom: i
     } = {}) {
         const r = {
                 ...n,
                 ...n.tooltipFormat
             },
             s = {},
             a = i ? "datum.datum" : "datum",
             o = [];
 
         function l(c, f) {
-            const h = Nl(f),
-                d = zn(c) ? c : {
+            const h = tu(f),
+                d = Jn(c) ? c : {
                     ...c,
                     type: e[h].type
                 },
-                g = d.title || iC(d, r),
-                p = se(g).join(", ");
+                g = d.title || Yk(d, r),
+                p = ue(g).join(", ");
             let m;
-            if (Wt(f)) {
+            if (cn(f)) {
                 const y = f === "x" ? "x2" : "y2",
-                    v = Kr(e[y]);
-                if (Xt(d.bin) && v) {
-                    const b = ie(d, {
+                    v = hs(e[y]);
+                if (pn(d.bin) && v) {
+                    const b = oe(d, {
                             expr: a
                         }),
-                        x = ie(v, {
+                        x = oe(v, {
                             expr: a
                         }),
                         {
                             format: _,
                             formatType: S
-                        } = U0(d);
-                    m = Fd(b, x, _, S, r), s[y] = !0
+                        } = S0(d);
+                    m = lg(b, x, _, S, r), s[y] = !0
                 }
             }
-            if ((Wt(f) || f === zi || f === _r) && t && t.fieldChannel === f && t.offset === "normalize") {
+            if ((cn(f) || f === nr || f === Nr) && t && t.fieldChannel === f && t.offset === "normalize") {
                 const {
                     format: y,
                     formatType: v
-                } = U0(d);
-                m = ZE({
+                } = S0(d);
+                m = Uk({
                     fieldOrDatumDef: d,
                     format: y,
                     formatType: v,
                     expr: a,
                     config: r,
                     normalizeStack: !0
                 }).signal
             }
-            m ?? (m = H1(d, r, a).signal), o.push({
+            m ?? (m = Ey(d, r, a).signal), o.push({
                 channel: f,
                 key: p,
                 value: m
             })
         }
-        aC(e, (c, f) => {
-            K(c) ? l(c, f) : I1(c) && l(c.condition, f)
+        Kk(e, (c, f) => {
+            Z(c) ? l(c, f) : my(c) && l(c.condition, f)
         });
         const u = {};
         for (const {
                 channel: c,
                 key: f,
                 value: h
             }
             of o) !s[c] && !u[f] && (u[f] = h);
         return u
     }
 
-    function i3(e, t, n, {
+    function kM(e, t, n, {
         reactiveGeom: i
     } = {}) {
-        const r = Sz(e, t, n, {
+        const r = oz(e, t, n, {
                 reactiveGeom: i
             }),
-            s = Ba(r).map(([a, o]) => `"${a}": ${o}`);
+            s = lo(r).map(([a, o]) => `"${a}": ${o}`);
         return s.length > 0 ? {
             signal: `{${s.join(", ")}}`
         } : void 0
     }
 
-    function epe(e) {
+    function xge(e) {
         const {
             markDef: t,
             config: n
-        } = e, i = Xe("aria", t, n);
+        } = e, i = st("aria", t, n);
         return i === !1 ? {} : {
             ...i ? {
                 aria: i
             } : {},
-            ...tpe(e),
-            ...npe(e)
+            ..._ge(e),
+            ...wge(e)
         }
     }
 
-    function tpe(e) {
+    function _ge(e) {
         const {
             mark: t,
             markDef: n,
             config: i
         } = e;
         if (i.aria === !1) return {};
-        const r = Xe("ariaRoleDescription", n, i);
+        const r = st("ariaRoleDescription", n, i);
         return r != null ? {
             ariaRoleDescription: {
                 value: r
             }
-        } : t in Lce ? {} : {
+        } : t in ece ? {} : {
             ariaRoleDescription: {
                 value: t
             }
         }
     }
 
-    function npe(e) {
+    function wge(e) {
         const {
             encoding: t,
             markDef: n,
             config: i,
             stack: r
         } = e, s = t.description;
-        if (s) return Dc(e, s, "description", l => H1(l, e.config));
-        const a = Xe("description", n, i);
+        if (s) return af(e, s, "description", l => Ey(l, e.config));
+        const a = st("description", n, i);
         if (a != null) return {
-            description: ut(a)
+            description: bt(a)
         };
         if (i.aria === !1) return {};
-        const o = Sz(t, r, i);
-        if (!et(o)) return {
+        const o = oz(t, r, i);
+        if (!ft(o)) return {
             description: {
-                signal: Ba(o).map(([l, u], c) => `"${c>0?"; ":""}${l}: " + (${u})`).join(" + ")
+                signal: lo(o).map(([l, u], c) => `"${c>0?"; ":""}${l}: " + (${u})`).join(" + ")
             }
         }
     }
 
-    function Lt(e, t, n = {}) {
+    function Zt(e, t, n = {}) {
         const {
             markDef: i,
             encoding: r,
             config: s
         } = t, {
             vgChannel: a
         } = n;
         let {
             defaultRef: o,
             defaultValue: l
         } = n;
-        o === void 0 && (l ?? (l = Xe(e, i, s, {
+        o === void 0 && (l ?? (l = st(e, i, s, {
             vgChannel: a,
             ignoreVgConfig: !0
-        })), l !== void 0 && (o = ut(l)));
+        })), l !== void 0 && (o = bt(l)));
         const u = r[e];
-        return Dc(t, u, a ?? e, c => QE({
+        return af(t, u, a ?? e, c => Gk({
             channel: e,
             channelDef: c,
             markDef: i,
             config: s,
             scaleName: t.scaleName(e),
             scale: t.getScaleComponent(e),
             stack: null,
             defaultRef: o
         }))
     }
 
-    function Ez(e, t = {
+    function lz(e, t = {
         filled: void 0
     }) {
         const {
             markDef: n,
             encoding: i,
             config: r
         } = e, {
             type: s
-        } = n, a = t.filled ?? Xe("filled", n, r), o = Fe(["bar", "point", "circle", "square", "geoshape"], s) ? "transparent" : void 0, l = Xe(a === !0 ? "color" : void 0, n, r, {
+        } = n, a = t.filled ?? st("filled", n, r), o = Be(["bar", "point", "circle", "square", "geoshape"], s) ? "transparent" : void 0, l = st(a === !0 ? "color" : void 0, n, r, {
             vgChannel: "fill"
-        }) ?? r.mark[a === !0 && "color"] ?? o, u = Xe(a === !1 ? "color" : void 0, n, r, {
+        }) ?? r.mark[a === !0 && "color"] ?? o, u = st(a === !1 ? "color" : void 0, n, r, {
             vgChannel: "stroke"
         }) ?? r.mark[a === !1 && "color"], c = a ? "fill" : "stroke", f = {
             ...l ? {
-                fill: ut(l)
+                fill: bt(l)
             } : {},
             ...u ? {
-                stroke: ut(u)
+                stroke: bt(u)
             } : {}
         };
-        return n.color && (a ? n.fill : n.stroke) && X(qI("property", {
+        return n.color && (a ? n.fill : n.stroke) && J(A6("property", {
             fill: "fill" in n,
             stroke: "stroke" in n
         })), {
             ...f,
-            ...Lt("color", e, {
+            ...Zt("color", e, {
                 vgChannel: c,
                 defaultValue: a ? l : u
             }),
-            ...Lt("fill", e, {
+            ...Zt("fill", e, {
                 defaultValue: i.fill ? l : void 0
             }),
-            ...Lt("stroke", e, {
+            ...Zt("stroke", e, {
                 defaultValue: i.stroke ? u : void 0
             })
         }
     }
 
-    function ipe(e) {
+    function Sge(e) {
         const {
             encoding: t,
             mark: n
         } = e, i = t.order;
-        return !uo(n) && gr(i) ? Dc(e, i, "zindex", r => ut(r.value)) : {}
+        return !Mo(n) && Tr(i) ? af(e, i, "zindex", r => bt(r.value)) : {}
     }
 
-    function jh({
+    function Dc({
         channel: e,
         markDef: t,
         encoding: n = {},
         model: i,
         bandPosition: r
     }) {
         const s = `${e}Offset`,
             a = t[s],
             o = n[s];
         if ((s === "xOffset" || s === "yOffset") && o) return {
             offsetType: "encoding",
-            offset: QE({
+            offset: Gk({
                 channel: s,
                 channelDef: o,
                 markDef: t,
                 config: i == null ? void 0 : i.config,
                 scaleName: i.scaleName(s),
                 scale: i.getScaleComponent(s),
                 stack: null,
-                defaultRef: ut(a),
+                defaultRef: bt(a),
                 bandPosition: r
             })
         };
         const l = t[s];
         return l ? {
             offsetType: "visual",
             offset: l
         } : {}
     }
 
-    function dn(e, t, {
+    function Mn(e, t, {
         defaultPos: n,
         vgChannel: i
     }) {
         const {
             encoding: r,
             markDef: s,
             config: a,
             stack: o
-        } = t, l = r[e], u = r[us(e)], c = t.scaleName(e), f = t.getScaleComponent(e), {
+        } = t, l = r[e], u = r[Ss(e)], c = t.scaleName(e), f = t.getScaleComponent(e), {
             offset: h,
             offsetType: d
-        } = jh({
+        } = Dc({
             channel: e,
             markDef: s,
             encoding: r,
             model: t,
             bandPosition: .5
-        }), g = _C({
+        }), g = fC({
             model: t,
             defaultPos: n,
             channel: e,
             scaleName: c,
             scale: f
-        }), p = !l && Wt(e) && (r.latitude || r.longitude) ? {
+        }), p = !l && cn(e) && (r.latitude || r.longitude) ? {
             field: t.getName(e)
-        } : rpe({
+        } : Ege({
             channel: e,
             channelDef: l,
             channel2Def: u,
             markDef: s,
             config: a,
             scaleName: c,
             scale: f,
@@ -43671,67 +37010,67 @@
             bandPosition: d === "encoding" ? 0 : void 0
         });
         return p ? {
             [i || e]: p
         } : void 0
     }
 
-    function rpe(e) {
+    function Ege(e) {
         const {
             channel: t,
             channelDef: n,
             scaleName: i,
             stack: r,
             offset: s,
             markDef: a
         } = e;
-        if (Ce(n) && r && t === r.fieldChannel) {
-            if (K(n)) {
+        if (De(n) && r && t === r.fieldChannel) {
+            if (Z(n)) {
                 let o = n.bandPosition;
-                if (o === void 0 && a.type === "text" && (t === "radius" || t === "theta") && (o = .5), o !== void 0) return z0({
+                if (o === void 0 && a.type === "text" && (t === "radius" || t === "theta") && (o = .5), o !== void 0) return x0({
                     scaleName: i,
                     fieldOrDatumDef: n,
                     startSuffix: "start",
                     bandPosition: o,
                     offset: s
                 })
             }
-            return qo(n, i, {
+            return pl(n, i, {
                 suffix: "end"
             }, {
                 offset: s
             })
         }
-        return KE(e)
+        return Bk(e)
     }
 
-    function _C({
+    function fC({
         model: e,
         defaultPos: t,
         channel: n,
         scaleName: i,
         scale: r
     }) {
         const {
             markDef: s,
             config: a
         } = e;
         return () => {
-            const o = Nl(n),
-                l = ja(n),
-                u = Xe(n, s, a, {
+            const o = tu(n),
+                l = uo(n),
+                u = st(n, s, a, {
                     vgChannel: l
                 });
-            if (u !== void 0) return lh(n, u);
+            if (u !== void 0) return Ph(n, u);
             switch (t) {
                 case "zeroOrMin":
                 case "zeroOrMax":
                     if (i) {
                         const c = r.get("type");
-                        if (!Fe([Qn.LOG, Qn.TIME, Qn.UTC], c)) {
+                        if (!Be([ui.LOG, ui.TIME, ui.UTC], c)) {
                             if (r.domainDefinitelyIncludesZero()) return {
                                 scale: i,
                                 value: 0
                             }
                         }
                     }
                     if (t === "zeroOrMin") return o === "y" ? {
@@ -43760,552 +37099,567 @@
                             return {
                                 value: 0
                             }
                     }
                     break;
                 case "mid":
                     return {
-                        ...e[oi(n)], mult: .5
+                        ...e[yi(n)], mult: .5
                     }
             }
         }
     }
-    const spe = {
+    const kge = {
             left: "x",
             center: "xc",
             right: "x2"
         },
-        ape = {
+        Cge = {
             top: "y",
             middle: "yc",
             bottom: "y2"
         };
 
-    function Cz(e, t, n, i = "middle") {
-        if (e === "radius" || e === "theta") return ja(e);
+    function uz(e, t, n, i = "middle") {
+        if (e === "radius" || e === "theta") return uo(e);
         const r = e === "x" ? "align" : "baseline",
-            s = Xe(r, t, n);
+            s = st(r, t, n);
         let a;
-        return he(s) ? (X(mfe(r)), a = void 0) : a = s, e === "x" ? spe[a || (i === "top" ? "left" : "center")] : ape[a || i]
+        return xe(s) ? (J(Rce(r)), a = void 0) : a = s, e === "x" ? kge[a || (i === "top" ? "left" : "center")] : Cge[a || i]
     }
 
-    function Y0(e, t, {
+    function $0(e, t, {
         defaultPos: n,
         defaultPos2: i,
         range: r
     }) {
-        return r ? kz(e, t, {
+        return r ? cz(e, t, {
             defaultPos: n,
             defaultPos2: i
-        }) : dn(e, t, {
+        }) : Mn(e, t, {
             defaultPos: n
         })
     }
 
-    function kz(e, t, {
+    function cz(e, t, {
         defaultPos: n,
         defaultPos2: i
     }) {
         const {
             markDef: r,
             config: s
-        } = t, a = us(e), o = oi(e), l = ope(t, i, a), u = l[o] ? Cz(e, r, s) : ja(e);
+        } = t, a = Ss(e), o = yi(e), l = Age(t, i, a), u = l[o] ? uz(e, r, s) : uo(e);
         return {
-            ...dn(e, t, {
+            ...Mn(e, t, {
                 defaultPos: n,
                 vgChannel: u
             }),
             ...l
         }
     }
 
-    function ope(e, t, n) {
+    function Age(e, t, n) {
         const {
             encoding: i,
             mark: r,
             markDef: s,
             stack: a,
             config: o
-        } = e, l = Nl(n), u = oi(n), c = ja(n), f = i[l], h = e.scaleName(l), d = e.getScaleComponent(l), {
+        } = e, l = tu(n), u = yi(n), c = uo(n), f = i[l], h = e.scaleName(l), d = e.getScaleComponent(l), {
             offset: g
-        } = n in i || n in s ? jh({
+        } = n in i || n in s ? Dc({
             channel: n,
             markDef: s,
             encoding: i,
             model: e
-        }) : jh({
+        }) : Dc({
             channel: l,
             markDef: s,
             encoding: i,
             model: e
         });
         if (!f && (n === "x2" || n === "y2") && (i.latitude || i.longitude)) {
-            const m = oi(n),
+            const m = yi(n),
                 y = e.markDef[m];
             return y != null ? {
                 [m]: {
                     value: y
                 }
             } : {
                 [c]: {
                     field: e.getName(n)
                 }
             }
         }
-        const p = lpe({
+        const p = $ge({
             channel: n,
             channelDef: f,
             channel2Def: i[n],
             markDef: s,
             config: o,
             scaleName: h,
             scale: d,
             stack: a,
             offset: g,
             defaultRef: void 0
         });
         return p !== void 0 ? {
             [c]: p
-        } : Tg(n, s) || Tg(n, {
-            [n]: P0(n, s, o.style),
-            [u]: P0(u, s, o.style)
-        }) || Tg(n, o[r]) || Tg(n, o.mark) || {
-            [c]: _C({
+        } : Vg(n, s) || Vg(n, {
+            [n]: y0(n, s, o.style),
+            [u]: y0(u, s, o.style)
+        }) || Vg(n, o[r]) || Vg(n, o.mark) || {
+            [c]: fC({
                 model: e,
                 defaultPos: t,
                 channel: n,
                 scaleName: h,
                 scale: d
             })()
         }
     }
 
-    function lpe({
+    function $ge({
         channel: e,
         channelDef: t,
         channel2Def: n,
         markDef: i,
         config: r,
         scaleName: s,
         scale: a,
         stack: o,
         offset: l,
         defaultRef: u
     }) {
-        return Ce(t) && o && e.charAt(0) === o.fieldChannel.charAt(0) ? qo(t, s, {
+        return De(t) && o && e.charAt(0) === o.fieldChannel.charAt(0) ? pl(t, s, {
             suffix: "start"
         }, {
             offset: l
-        }) : KE({
+        }) : Bk({
             channel: e,
             channelDef: n,
             scaleName: s,
             scale: a,
             stack: o,
             markDef: i,
             config: r,
             offset: l,
             defaultRef: u
         })
     }
 
-    function Tg(e, t) {
-        const n = oi(e),
-            i = ja(e);
+    function Vg(e, t) {
+        const n = yi(e),
+            i = uo(e);
         if (t[i] !== void 0) return {
-            [i]: lh(e, t[i])
+            [i]: Ph(e, t[i])
         };
         if (t[e] !== void 0) return {
-            [i]: lh(e, t[e])
+            [i]: Ph(e, t[e])
         };
         if (t[n]) {
             const r = t[n];
-            if (dl(r)) X(ufe(n));
+            if (Ll(r)) J(Cce(n));
             else return {
-                [n]: lh(e, r)
+                [n]: Ph(e, r)
             }
         }
     }
 
-    function Ga(e, t) {
+    function fo(e, t) {
         const {
             config: n,
             encoding: i,
             markDef: r
-        } = e, s = r.type, a = us(t), o = oi(t), l = i[t], u = i[a], c = e.getScaleComponent(t), f = c ? c.get("type") : void 0, h = r.orient, d = i[o] ?? i.size ?? Xe("size", r, n, {
+        } = e, s = r.type, a = Ss(t), o = yi(t), l = i[t], u = i[a], c = e.getScaleComponent(t), f = c ? c.get("type") : void 0, h = r.orient, d = i[o] ?? i.size ?? st("size", r, n, {
             vgChannel: o
-        }), g = AI(t), p = s === "bar" && (t === "x" ? h === "vertical" : h === "horizontal");
-        return K(l) && (ot(l.bin) || Xt(l.bin) || l.timeUnit && !u) && !(d && !dl(d)) && !i[g] && !qt(f) ? fpe({
+        }), g = u6(t), p = s === "bar" && (t === "x" ? h === "vertical" : h === "horizontal");
+        return Z(l) && (yt(l.bin) || pn(l.bin) || l.timeUnit && !u) && !(d && !Ll(d)) && !i[g] && !fn(f) ? Oge({
             fieldDef: l,
             fieldDef2: u,
             channel: t,
             model: e
-        }) : (Ce(l) && qt(f) || p) && !u ? cpe(l, t, e) : kz(t, e, {
+        }) : (De(l) && fn(f) || p) && !u ? Mge(l, t, e) : cz(t, e, {
             defaultPos: "zeroOrMax",
             defaultPos2: "zeroOrMin"
         })
     }
 
-    function upe(e, t, n, i, r, s, a) {
-        if (dl(r))
+    function Tge(e, t, n, i, r, s, a) {
+        if (Ll(r))
             if (n) {
                 const l = n.get("type");
                 if (l === "band") {
                     let u = `bandwidth('${t}')`;
-                    return r.band !== 1 && (u = `${r.band} * ${u}`), {
-                        signal: `max(0.25, ${u})`
+                    r.band !== 1 && (u = `${r.band} * ${u}`);
+                    const c = ia("minBandSize", {
+                        type: a
+                    }, i);
+                    return {
+                        signal: c ? `max(${br(c)}, ${u})` : u
                     }
-                } else r.band !== 1 && (X(xfe(l)), r = void 0)
+                } else r.band !== 1 && (J(Lce(l)), r = void 0)
             } else return {
                 mult: r.band,
                 field: {
                     group: e
                 }
             };
         else {
-            if (he(r)) return r;
+            if (xe(r)) return r;
             if (r) return {
                 value: r
             }
         }
         if (n) {
             const l = n.get("range");
-            if (lo(l) && Ze(l.step)) return {
+            if (To(l) && lt(l.step)) return {
                 value: l.step - 2
             }
         }
         if (!s) {
             const {
                 bandPaddingInner: l,
                 barBandPaddingInner: u,
                 rectBandPaddingInner: c
-            } = i.scale, f = Ct(l, a === "bar" ? u : c);
-            if (he(f)) return {
+            } = i.scale, f = Gt(l, a === "bar" ? u : c);
+            if (xe(f)) return {
                 signal: `(1 - (${f.signal})) * ${e}`
             };
-            if (Ze(f)) return {
+            if (lt(f)) return {
                 signal: `${1-f} * ${e}`
-            };
-            if (Fc(f)) return {
-                signal: `(1 - (${f.expr})) * ${e}`
             }
         }
         return {
-            value: q0(i.view, e) - 2
+            value: C0(i.view, e) - 2
         }
     }
 
-    function cpe(e, t, n) {
+    function Mge(e, t, n) {
         const {
             markDef: i,
             encoding: r,
             config: s,
             stack: a
-        } = n, o = i.orient, l = n.scaleName(t), u = n.getScaleComponent(t), c = oi(t), f = us(t), h = AI(t), d = n.scaleName(h), g = n.getScaleComponent(AE(t)), p = o === "horizontal" && t === "y" || o === "vertical" && t === "x";
+        } = n, o = i.orient, l = n.scaleName(t), u = n.getScaleComponent(t), c = yi(t), f = Ss(t), h = u6(t), d = n.scaleName(h), g = n.getScaleComponent(mk(t)), p = o === "horizontal" && t === "y" || o === "vertical" && t === "x";
         let m;
-        (r.size || i.size) && (p ? m = Lt("size", n, {
+        (r.size || i.size) && (p ? m = Zt("size", n, {
             vgChannel: c,
-            defaultRef: ut(i.size)
-        }) : X(Efe(i.type)));
+            defaultRef: bt(i.size)
+        }) : J(jce(i.type)));
         const y = !!m,
-            v = C6({
+            v = u8({
                 channel: t,
                 fieldDef: e,
                 markDef: i,
                 config: s,
                 scaleType: u == null ? void 0 : u.get("type"),
                 useVlSizeChannel: p
             });
         m = m || {
-            [c]: upe(c, d || l, g || u, s, v, !!e, i.type)
+            [c]: Tge(c, d || l, g || u, s, v, !!e, i.type)
         };
-        const b = (u == null ? void 0 : u.get("type")) === "band" && dl(v) && !y ? "top" : "middle",
-            x = Cz(t, i, s, b),
+        const b = (u == null ? void 0 : u.get("type")) === "band" && Ll(v) && !y ? "top" : "middle",
+            x = uz(t, i, s, b),
             _ = x === "xc" || x === "yc",
             {
                 offset: S,
                 offsetType: w
-            } = jh({
+            } = Dc({
                 channel: t,
                 markDef: i,
                 encoding: r,
                 model: n,
                 bandPosition: _ ? .5 : 0
             }),
-            E = KE({
+            E = Bk({
                 channel: t,
                 channelDef: e,
                 markDef: i,
                 config: s,
                 scaleName: l,
                 scale: u,
                 stack: a,
                 offset: S,
-                defaultRef: _C({
+                defaultRef: fC({
                     model: n,
                     defaultPos: "mid",
                     channel: t,
                     scaleName: l,
                     scale: u
                 }),
-                bandPosition: _ ? w === "encoding" ? 0 : .5 : he(v) ? {
+                bandPosition: _ ? w === "encoding" ? 0 : .5 : xe(v) ? {
                     signal: `(1-${v})/2`
-                } : dl(v) ? (1 - v.band) / 2 : 0
+                } : Ll(v) ? (1 - v.band) / 2 : 0
             });
         if (c) return {
             [x]: E,
             ...m
         }; {
-            const A = ja(f),
-                C = m[c],
-                k = S ? {
-                    ...C,
+            const C = uo(f),
+                k = m[c],
+                A = S ? {
+                    ...k,
                     offset: S
-                } : C;
+                } : k;
             return {
                 [x]: E,
-                [A]: W(E) ? [E[0], {
+                [C]: H(E) ? [E[0], {
                     ...E[1],
-                    offset: k
+                    offset: A
                 }] : {
                     ...E,
-                    offset: k
+                    offset: A
                 }
             }
         }
     }
 
-    function hf(e, t, n, i, r) {
-        if (_I(e)) return 0;
-        const s = e === "x" || e === "y2" ? -t / 2 : t / 2;
-        if (he(n) || he(r) || he(i)) {
-            const a = Ds(n),
-                o = Ds(r),
-                l = Ds(i),
-                u = l ? `${l} + ` : "",
-                c = a ? `(${a} ? -1 : 1) * ` : "",
-                f = o ? `(${o} + ${s})` : s;
+    function CM(e, t, n, i, r, s, a) {
+        if (i6(e)) return 0;
+        const o = e === "x" || e === "y2",
+            l = o ? -t / 2 : t / 2;
+        if (xe(n) || xe(r) || xe(i) || s) {
+            const u = br(n),
+                c = br(r),
+                f = br(i),
+                h = br(s),
+                g = s ? `(${a} < ${h} ? ${o?"":"-"}0.5 * (${h} - (${a})) : ${l})` : l,
+                p = f ? `${f} + ` : "",
+                m = u ? `(${u} ? -1 : 1) * ` : "",
+                y = c ? `(${c} + ${g})` : g;
             return {
-                signal: u + c + f
+                signal: p + m + y
             }
-        } else return r = r || 0, i + (n ? -r - s : +r + s)
+        } else return r = r || 0, i + (n ? -r - l : +r + l)
     }
 
-    function fpe({
+    function Oge({
         fieldDef: e,
         fieldDef2: t,
         channel: n,
         model: i
     }) {
-        var x;
+        var C;
         const {
             config: r,
             markDef: s,
             encoding: a
-        } = i, o = i.getScaleComponent(n), l = i.scaleName(n), u = o ? o.get("type") : void 0, c = o.get("reverse"), f = C6({
+        } = i, o = i.getScaleComponent(n), l = i.scaleName(n), u = o ? o.get("type") : void 0, c = o.get("reverse"), f = u8({
             channel: n,
             fieldDef: e,
             markDef: s,
             config: r,
             scaleType: u
-        }), h = (x = i.component.axes[n]) == null ? void 0 : x[0], d = (h == null ? void 0 : h.get("translate")) ?? .5, g = Wt(n) ? Xe("binSpacing", s, r) ?? 0 : 0, p = us(n), m = ja(n), y = ja(p), {
-            offset: v
-        } = jh({
+        }), h = (C = i.component.axes[n]) == null ? void 0 : C[0], d = (h == null ? void 0 : h.get("translate")) ?? .5, g = cn(n) ? st("binSpacing", s, r) ?? 0 : 0, p = Ss(n), m = uo(n), y = uo(p), v = ia("minBandSize", s, r), {
+            offset: b
+        } = Dc({
             channel: n,
             markDef: s,
             encoding: a,
             model: i,
             bandPosition: 0
-        }), b = he(f) ? {
+        }), {
+            offset: x
+        } = Dc({
+            channel: p,
+            markDef: s,
+            encoding: a,
+            model: i,
+            bandPosition: 0
+        }), _ = lhe({
+            fieldDef: e,
+            scaleName: l
+        }), S = CM(n, g, c, d, b, v, _), w = CM(p, g, c, d, x ?? b, v, _), E = xe(f) ? {
             signal: `(1-${f.signal})/2`
-        } : dl(f) ? (1 - f.band) / 2 : .5;
-        if (ot(e.bin) || e.timeUnit) return {
-            [y]: r3({
+        } : Ll(f) ? (1 - f.band) / 2 : .5;
+        if (yt(e.bin) || e.timeUnit) return {
+            [y]: AM({
                 fieldDef: e,
                 scaleName: l,
-                bandPosition: b,
-                offset: hf(p, g, c, d, v)
+                bandPosition: E,
+                offset: w
             }),
-            [m]: r3({
+            [m]: AM({
                 fieldDef: e,
                 scaleName: l,
-                bandPosition: he(b) ? {
-                    signal: `1-${b.signal}`
-                } : 1 - b,
-                offset: hf(n, g, c, d, v)
+                bandPosition: xe(E) ? {
+                    signal: `1-${E.signal}`
+                } : 1 - E,
+                offset: S
             })
         };
-        if (Xt(e.bin)) {
-            const _ = qo(e, l, {}, {
-                offset: hf(p, g, c, d, v)
+        if (pn(e.bin)) {
+            const k = pl(e, l, {}, {
+                offset: w
             });
-            if (K(t)) return {
-                [y]: _,
-                [m]: qo(t, l, {}, {
-                    offset: hf(n, g, c, d, v)
+            if (Z(t)) return {
+                [y]: k,
+                [m]: pl(t, l, {}, {
+                    offset: S
                 })
             };
-            if (Pl(e.bin) && e.bin.step) return {
-                [y]: _,
+            if (nu(e.bin) && e.bin.step) return {
+                [y]: k,
                 [m]: {
-                    signal: `scale("${l}", ${ie(e,{expr:"datum"})} + ${e.bin.step})`,
-                    offset: hf(n, g, c, d, v)
+                    signal: `scale("${l}", ${oe(e,{expr:"datum"})} + ${e.bin.step})`,
+                    offset: S
                 }
             }
         }
-        X(XI(p))
+        J(M6(p))
     }
 
-    function r3({
+    function AM({
         fieldDef: e,
         scaleName: t,
         bandPosition: n,
         offset: i
     }) {
-        return z0({
+        return x0({
             scaleName: t,
             fieldOrDatumDef: e,
             bandPosition: n,
             offset: i
         })
     }
-    const hpe = new Set(["aria", "width", "height"]);
+    const Fge = new Set(["aria", "width", "height"]);
 
-    function Bi(e, t) {
+    function ir(e, t) {
         const {
             fill: n = void 0,
             stroke: i = void 0
-        } = t.color === "include" ? Ez(e) : {};
+        } = t.color === "include" ? lz(e) : {};
         return {
-            ...dpe(e.markDef, t),
-            ...s3(e, "fill", n),
-            ...s3(e, "stroke", i),
-            ...Lt("opacity", e),
-            ...Lt("fillOpacity", e),
-            ...Lt("strokeOpacity", e),
-            ...Lt("strokeWidth", e),
-            ...Lt("strokeDash", e),
-            ...ipe(e),
-            ...wz(e),
-            ...xC(e, "href"),
-            ...epe(e)
+            ...Rge(e.markDef, t),
+            ...$M(e, "fill", n),
+            ...$M(e, "stroke", i),
+            ...Zt("opacity", e),
+            ...Zt("fillOpacity", e),
+            ...Zt("strokeOpacity", e),
+            ...Zt("strokeWidth", e),
+            ...Zt("strokeDash", e),
+            ...Sge(e),
+            ...az(e),
+            ...cC(e, "href"),
+            ...xge(e)
         }
     }
 
-    function s3(e, t, n) {
+    function $M(e, t, n) {
         const {
             config: i,
             mark: r,
             markDef: s
         } = e;
-        if (Xe("invalid", s, i) === "hide" && n && !uo(r)) {
-            const o = gpe(e, {
+        if (st("invalid", s, i) === "hide" && n && !Mo(r)) {
+            const o = Dge(e, {
                 invalid: !0,
-                channels: A1
+                channels: sy
             });
             if (o) return {
                 [t]: [{
                     test: o,
                     value: null
-                }, ...se(n)]
+                }, ...ue(n)]
             }
         }
         return n ? {
             [t]: n
         } : {}
     }
 
-    function dpe(e, t) {
-        return Pce.reduce((n, i) => (!hpe.has(i) && e[i] !== void 0 && t[i] !== "ignore" && (n[i] = ut(e[i])), n), {})
+    function Rge(e, t) {
+        return Zue.reduce((n, i) => (!Fge.has(i) && e[i] !== void 0 && t[i] !== "ignore" && (n[i] = bt(e[i])), n), {})
     }
 
-    function gpe(e, {
+    function Dge(e, {
         invalid: t = !1,
         channels: n
     }) {
         const i = n.reduce((s, a) => {
                 const o = e.getScaleComponent(a);
                 if (o) {
                     const l = o.get("type"),
                         u = e.vgField(a, {
                             expr: "datum"
                         });
-                    u && wi(l) && (s[u] = !0)
+                    u && Ni(l) && (s[u] = !0)
                 }
                 return s
             }, {}),
-            r = H(i);
+            r = K(i);
         if (r.length > 0) {
             const s = t ? "||" : "&&";
-            return r.map(a => JE(a, t)).join(` ${s} `)
+            return r.map(a => jk(a, t)).join(` ${s} `)
         }
     }
 
-    function wC(e) {
+    function hC(e) {
         const {
             config: t,
             markDef: n
         } = e;
-        if (Xe("invalid", n, t)) {
-            const r = ppe(e, {
-                channels: cs
+        if (st("invalid", n, t)) {
+            const r = Nge(e, {
+                channels: Es
             });
             if (r) return {
                 defined: {
                     signal: r
                 }
             }
         }
         return {}
     }
 
-    function ppe(e, {
+    function Nge(e, {
         invalid: t = !1,
         channels: n
     }) {
         const i = n.reduce((s, a) => {
                 var l;
                 const o = e.getScaleComponent(a);
                 if (o) {
                     const u = o.get("type"),
                         c = e.vgField(a, {
                             expr: "datum",
                             binSuffix: (l = e.stack) != null && l.impute ? "mid" : void 0
                         });
-                    c && wi(u) && (s[c] = !0)
+                    c && Ni(u) && (s[c] = !0)
                 }
                 return s
             }, {}),
-            r = H(i);
+            r = K(i);
         if (r.length > 0) {
             const s = t ? "||" : "&&";
-            return r.map(a => JE(a, t)).join(` ${s} `)
+            return r.map(a => jk(a, t)).join(` ${s} `)
         }
     }
 
-    function a3(e, t) {
+    function TM(e, t) {
         if (t !== void 0) return {
-            [e]: ut(t)
+            [e]: bt(t)
         }
     }
-    const Mv = "voronoi",
-        Az = {
+    const ab = "voronoi",
+        fz = {
             defined: e => e.type === "point" && e.nearest,
             parse: (e, t) => {
                 if (t.events)
-                    for (const n of t.events) n.markname = e.getName(Mv)
+                    for (const n of t.events) n.markname = e.getName(ab)
             },
             marks: (e, t, n) => {
                 const {
                     x: i,
                     y: r
                 } = t.project.hasChannel, s = e.mark;
-                if (uo(s)) return X(Uce(s)), n;
+                if (Mo(s)) return J(sce(s)), n;
                 const a = {
-                    name: e.getName(Mv),
+                    name: e.getName(ab),
                     type: "path",
                     interactive: !0,
                     from: {
                         data: e.getName("marks")
                     },
                     encode: {
                         update: {
@@ -44317,15 +37671,15 @@
                             },
                             stroke: {
                                 value: "transparent"
                             },
                             isVoronoi: {
                                 value: !0
                             },
-                            ...wz(e, {
+                            ...az(e, {
                                 reactiveGeom: !0
                             })
                         }
                     },
                     transform: [{
                         type: "voronoi",
                         x: {
@@ -44337,80 +37691,80 @@
                         size: [e.getSizeSignalRef("width"), e.getSizeSignalRef("height")]
                     }]
                 };
                 let o = 0,
                     l = !1;
                 return n.forEach((u, c) => {
                     const f = u.name ?? "";
-                    f === e.component.mark[0].name ? o = c : f.indexOf(Mv) >= 0 && (l = !0)
+                    f === e.component.mark[0].name ? o = c : f.indexOf(ab) >= 0 && (l = !0)
                 }), l || n.splice(o + 1, 0, a), n
             }
         },
-        $z = {
-            defined: e => e.type === "point" && e.resolve === "global" && e.bind && e.bind !== "scales" && !hC(e.bind),
-            parse: (e, t, n) => Pz(t, n),
+        hz = {
+            defined: e => e.type === "point" && e.resolve === "global" && e.bind && e.bind !== "scales" && !nC(e.bind),
+            parse: (e, t, n) => xz(t, n),
             topLevelSignals: (e, t, n) => {
                 const i = t.name,
                     r = t.project,
                     s = t.bind,
                     a = t.init && t.init[0],
-                    o = Az.defined(t) ? "(item().isVoronoi ? datum.datum : datum)" : "datum";
+                    o = fz.defined(t) ? "(item().isVoronoi ? datum.datum : datum)" : "datum";
                 return r.items.forEach((l, u) => {
-                    const c = ft(`${i}_${l.field}`);
+                    const c = Et(`${i}_${l.field}`);
                     n.filter(h => h.name === c).length || n.unshift({
                         name: c,
                         ...a ? {
-                            init: pl(a[u])
+                            init: zl(a[u])
                         } : {
                             value: null
                         },
                         on: t.events ? [{
                             events: t.events,
-                            update: `datum && item().mark.marktype !== 'group' ? ${o}[${Z(l.field)}] : null`
+                            update: `datum && item().mark.marktype !== 'group' ? ${o}[${te(l.field)}] : null`
                         }] : [],
                         bind: s[l.field] ?? s[l.channel] ?? s
                     })
                 }), n
             },
             signals: (e, t, n) => {
                 const i = t.name,
                     r = t.project,
-                    s = n.filter(u => u.name === i + Wa)[0],
-                    a = i + Ld,
-                    o = r.items.map(u => ft(`${i}_${u.field}`)),
+                    s = n.filter(u => u.name === i + ho)[0],
+                    a = i + dg,
+                    o = r.items.map(u => Et(`${i}_${u.field}`)),
                     l = o.map(u => `${u} !== null`).join(" && ");
                 return o.length && (s.update = `${l} ? {fields: ${a}, values: [${o.join(", ")}]} : null`), delete s.value, delete s.on, n
             }
         },
-        X0 = "_toggle",
-        Tz = {
+        T0 = "_toggle",
+        dz = {
             defined: e => e.type === "point" && !!e.toggle,
             signals: (e, t, n) => n.concat({
-                name: t.name + X0,
+                name: t.name + T0,
                 value: !1,
                 on: [{
                     events: t.events,
                     update: t.toggle
                 }]
             }),
             modifyExpr: (e, t) => {
-                const n = t.name + Wa,
-                    i = t.name + X0;
-                return `${i} ? null : ${n}, ` + (t.resolve === "global" ? `${i} ? null : true, ` : `${i} ? null : {unit: ${Yo(e)}}, `) + `${i} ? ${n} : null`
+                const n = t.name + ho,
+                    i = t.name + T0;
+                return `${i} ? null : ${n}, ` + (t.resolve === "global" ? `${i} ? null : true, ` : `${i} ? null : {unit: ${yl(e)}}, `) + `${i} ? ${n} : null`
             }
         },
-        mpe = {
+        Pge = {
             defined: e => e.clear !== void 0 && e.clear !== !1,
             parse: (e, t) => {
-                t.clear && (t.clear = re(t.clear) ? to(t.clear, "view") : t.clear)
+                t.clear && (t.clear = le(t.clear) ? wo(t.clear, "view") : t.clear)
             },
             topLevelSignals: (e, t, n) => {
-                if ($z.defined(t))
+                if (hz.defined(t))
                     for (const i of t.project.items) {
-                        const r = n.findIndex(s => s.name === ft(`${t.name}_${i.field}`));
+                        const r = n.findIndex(s => s.name === Et(`${t.name}_${i.field}`));
                         r !== -1 && n[r].on.push({
                             events: t.clear,
                             update: "null"
                         })
                     }
                 return n
             },
@@ -44425,56 +37779,56 @@
                     for (const r of t.project.items) {
                         const s = n.findIndex(a => a.name === r.signals.visual);
                         if (i(s, "[0, 0]"), s === -1) {
                             const a = n.findIndex(o => o.name === r.signals.data);
                             i(a, "null")
                         }
                     } else {
-                        let r = n.findIndex(s => s.name === t.name + Wa);
-                        i(r, "null"), Tz.defined(t) && (r = n.findIndex(s => s.name === t.name + X0), i(r, "false"))
+                        let r = n.findIndex(s => s.name === t.name + ho);
+                        i(r, "null"), dz.defined(t) && (r = n.findIndex(s => s.name === t.name + T0), i(r, "false"))
                     }
                 return n
             }
         },
-        Mz = {
+        gz = {
             defined: e => {
-                const t = e.resolve === "global" && e.bind && hC(e.bind),
-                    n = e.project.items.length === 1 && e.project.items[0].field !== pr;
-                return t && !n && X(qce), t && n
+                const t = e.resolve === "global" && e.bind && nC(e.bind),
+                    n = e.project.items.length === 1 && e.project.items[0].field !== Mr;
+                return t && !n && J(lce), t && n
             },
             parse: (e, t, n) => {
-                const i = ke(n);
-                if (i.select = re(i.select) ? {
+                const i = Fe(n);
+                if (i.select = le(i.select) ? {
                         type: i.select,
                         toggle: t.toggle
                     } : {
                         ...i.select,
                         toggle: t.toggle
-                    }, Pz(t, i), ae(n.select) && (n.select.on || n.select.clear)) {
+                    }, xz(t, i), ce(n.select) && (n.select.on || n.select.clear)) {
                     const a = 'event.item && indexof(event.item.mark.role, "legend") < 0';
-                    for (const o of t.events) o.filter = se(o.filter ?? []), o.filter.includes(a) || o.filter.push(a)
+                    for (const o of t.events) o.filter = ue(o.filter ?? []), o.filter.includes(a) || o.filter.push(a)
                 }
-                const r = Av(t.bind) ? t.bind.legend : "click",
-                    s = re(r) ? to(r, "view") : se(r);
+                const r = nb(t.bind) ? t.bind.legend : "click",
+                    s = le(r) ? wo(r, "view") : ue(r);
                 t.bind = {
                     legend: {
                         merge: s
                     }
                 }
             },
             topLevelSignals: (e, t, n) => {
                 const i = t.name,
-                    r = Av(t.bind) && t.bind.legend,
+                    r = nb(t.bind) && t.bind.legend,
                     s = a => o => {
-                        const l = ke(o);
+                        const l = Fe(o);
                         return l.markname = a, l
                     };
                 for (const a of t.project.items) {
                     if (!a.hasLegend) continue;
-                    const o = `${ft(a.field)}_legend`,
+                    const o = `${Et(a.field)}_legend`,
                         l = `${i}_${o}`;
                     if (n.filter(c => c.name === l).length === 0) {
                         const c = r.merge.map(s(`${o}_symbols`)).concat(r.merge.map(s(`${o}_labels`))).concat(r.merge.map(s(`${o}_entries`)));
                         n.unshift({
                             name: l,
                             ...t.init ? {} : {
                                 value: null
@@ -44492,210 +37846,210 @@
                     }
                 }
                 return n
             },
             signals: (e, t, n) => {
                 const i = t.name,
                     r = t.project,
-                    s = n.find(h => h.name === i + Wa),
-                    a = i + Ld,
-                    o = r.items.filter(h => h.hasLegend).map(h => ft(`${i}_${ft(h.field)}_legend`)),
+                    s = n.find(h => h.name === i + ho),
+                    a = i + dg,
+                    o = r.items.filter(h => h.hasLegend).map(h => Et(`${i}_${Et(h.field)}_legend`)),
                     u = `${o.map(h=>`${h} !== null`).join(" && ")} ? {fields: ${a}, values: [${o.join(", ")}]} : null`;
                 t.events && o.length > 0 ? s.on.push({
                     events: o.map(h => ({
                         signal: h
                     })),
                     update: u
                 }) : o.length > 0 && (s.update = u, delete s.value, delete s.on);
-                const c = n.find(h => h.name === i + X0),
-                    f = Av(t.bind) && t.bind.legend;
+                const c = n.find(h => h.name === i + T0),
+                    f = nb(t.bind) && t.bind.legend;
                 return c && (t.events ? c.on.push({
                     ...c.on[0],
                     events: f
                 }) : c.on[0].events = f), n
             }
         };
 
-    function ype(e, t, n) {
+    function Lge(e, t, n) {
         var r;
         const i = (r = e.fieldDef(t)) == null ? void 0 : r.field;
-        for (const s of Qt(e.component.selection ?? {})) {
+        for (const s of bn(e.component.selection ?? {})) {
             const a = s.project.hasField[i] ?? s.project.hasChannel[t];
-            if (a && Mz.defined(s)) {
+            if (a && gz.defined(s)) {
                 const o = n.get("selections") ?? [];
                 o.push(s.name), n.set("selections", o, !1), a.hasLegend = !0
             }
         }
     }
-    const Oz = "_translate_anchor",
-        Fz = "_translate_delta",
-        vpe = {
+    const pz = "_translate_anchor",
+        mz = "_translate_delta",
+        Ige = {
             defined: e => e.type === "interval" && e.translate,
             signals: (e, t, n) => {
                 const i = t.name,
-                    r = Ns.defined(t),
-                    s = i + Oz,
+                    r = Js.defined(t),
+                    s = i + pz,
                     {
                         x: a,
                         y: o
                     } = t.project.hasChannel;
-                let l = to(t.translate, "scope");
-                return r || (l = l.map(u => (u.between[0].markname = i + Au, u))), n.push({
+                let l = wo(t.translate, "scope");
+                return r || (l = l.map(u => (u.between[0].markname = i + Qu, u))), n.push({
                     name: s,
                     value: {},
                     on: [{
                         events: l.map(u => u.between[0]),
-                        update: "{x: x(unit), y: y(unit)" + (a !== void 0 ? `, extent_x: ${r?ix(e,ht):`slice(${a.signals.visual})`}` : "") + (o !== void 0 ? `, extent_y: ${r?ix(e,Gt):`slice(${o.signals.visual})`}` : "") + "}"
+                        update: "{x: x(unit), y: y(unit)" + (a !== void 0 ? `, extent_x: ${r?Dx(e,kt):`slice(${a.signals.visual})`}` : "") + (o !== void 0 ? `, extent_y: ${r?Dx(e,un):`slice(${o.signals.visual})`}` : "") + "}"
                     }]
                 }, {
-                    name: i + Fz,
+                    name: i + mz,
                     value: {},
                     on: [{
                         events: l,
                         update: `{x: ${s}.x - x(unit), y: ${s}.y - y(unit)}`
                     }]
-                }), a !== void 0 && o3(e, t, a, "width", n), o !== void 0 && o3(e, t, o, "height", n), n
+                }), a !== void 0 && MM(e, t, a, "width", n), o !== void 0 && MM(e, t, o, "height", n), n
             }
         };
 
-    function o3(e, t, n, i, r) {
+    function MM(e, t, n, i, r) {
         const s = t.name,
-            a = s + Oz,
-            o = s + Fz,
+            a = s + pz,
+            o = s + mz,
             l = n.channel,
-            u = Ns.defined(t),
+            u = Js.defined(t),
             c = r.filter(_ => _.name === n.signals[u ? "data" : "visual"])[0],
             f = e.getSizeSignalRef(i).signal,
             h = e.getScaleComponent(l),
             d = h && h.get("type"),
             g = h && h.get("reverse"),
-            p = u ? l === ht ? g ? "" : "-" : g ? "-" : "" : "",
+            p = u ? l === kt ? g ? "" : "-" : g ? "-" : "" : "",
             m = `${a}.extent_${l}`,
             y = `${p}${o}.${l} / ${u?`${f}`:`span(${m})`}`,
             v = !u || !h ? "panLinear" : d === "log" ? "panLog" : d === "symlog" ? "panSymlog" : d === "pow" ? "panPow" : "panLinear",
             b = u ? d === "pow" ? `, ${h.get("exponent")??1}` : d === "symlog" ? `, ${h.get("constant")??1}` : "" : "",
             x = `${v}(${m}, ${y}${b})`;
         c.on.push({
             events: {
                 signal: o
             },
             update: u ? x : `clampRange(${x}, 0, ${f})`
         })
     }
-    const Rz = "_zoom_anchor",
-        Dz = "_zoom_delta",
-        bpe = {
+    const yz = "_zoom_anchor",
+        vz = "_zoom_delta",
+        zge = {
             defined: e => e.type === "interval" && e.zoom,
             signals: (e, t, n) => {
                 const i = t.name,
-                    r = Ns.defined(t),
-                    s = i + Dz,
+                    r = Js.defined(t),
+                    s = i + vz,
                     {
                         x: a,
                         y: o
                     } = t.project.hasChannel,
-                    l = Z(e.scaleName(ht)),
-                    u = Z(e.scaleName(Gt));
-                let c = to(t.zoom, "scope");
-                return r || (c = c.map(f => (f.markname = i + Au, f))), n.push({
-                    name: i + Rz,
+                    l = te(e.scaleName(kt)),
+                    u = te(e.scaleName(un));
+                let c = wo(t.zoom, "scope");
+                return r || (c = c.map(f => (f.markname = i + Qu, f))), n.push({
+                    name: i + yz,
                     on: [{
                         events: c,
                         update: r ? "{" + [l ? `x: invert(${l}, x(unit))` : "", u ? `y: invert(${u}, y(unit))` : ""].filter(f => f).join(", ") + "}" : "{x: x(unit), y: y(unit)}"
                     }]
                 }, {
                     name: s,
                     on: [{
                         events: c,
                         force: !0,
                         update: "pow(1.001, event.deltaY * pow(16, event.deltaMode))"
                     }]
-                }), a !== void 0 && l3(e, t, a, "width", n), o !== void 0 && l3(e, t, o, "height", n), n
+                }), a !== void 0 && OM(e, t, a, "width", n), o !== void 0 && OM(e, t, o, "height", n), n
             }
         };
 
-    function l3(e, t, n, i, r) {
+    function OM(e, t, n, i, r) {
         const s = t.name,
             a = n.channel,
-            o = Ns.defined(t),
+            o = Js.defined(t),
             l = r.filter(v => v.name === n.signals[o ? "data" : "visual"])[0],
             u = e.getSizeSignalRef(i).signal,
             c = e.getScaleComponent(a),
             f = c && c.get("type"),
-            h = o ? ix(e, a) : l.name,
-            d = s + Dz,
-            g = `${s}${Rz}.${a}`,
+            h = o ? Dx(e, a) : l.name,
+            d = s + vz,
+            g = `${s}${yz}.${a}`,
             p = !o || !c ? "zoomLinear" : f === "log" ? "zoomLog" : f === "symlog" ? "zoomSymlog" : f === "pow" ? "zoomPow" : "zoomLinear",
             m = o ? f === "pow" ? `, ${c.get("exponent")??1}` : f === "symlog" ? `, ${c.get("constant")??1}` : "" : "",
             y = `${p}(${h}, ${g}, ${d}${m})`;
         l.on.push({
             events: {
                 signal: d
             },
             update: o ? y : `clampRange(${y}, 0, ${u})`
         })
     }
-    const ml = "_store",
-        Wa = "_tuple",
-        xpe = "_modify",
-        Nz = "vlSelectionResolve",
-        Y1 = [Zge, Jge, Vge, Tz, $z, Ns, Mz, mpe, vpe, bpe, Az];
+    const Bl = "_store",
+        ho = "_tuple",
+        Bge = "_modify",
+        bz = "vlSelectionResolve",
+        ky = [bge, yge, pge, dz, hz, Js, gz, Pge, Ige, zge, fz];
 
-    function _pe(e) {
+    function jge(e) {
         let t = e.parent;
-        for (; t && !lr(t);) t = t.parent;
+        for (; t && !kr(t);) t = t.parent;
         return t
     }
 
-    function Yo(e, {
+    function yl(e, {
         escape: t
     } = {
         escape: !0
     }) {
-        let n = t ? Z(e.name) : e.name;
-        const i = _pe(e);
+        let n = t ? te(e.name) : e.name;
+        const i = jge(e);
         if (i) {
             const {
                 facet: r
             } = i;
-            for (const s of Ti) r[s] && (n += ` + '__facet_${s}_' + (facet[${Z(i.vgField(s))}])`)
+            for (const s of Ui) r[s] && (n += ` + '__facet_${s}_' + (facet[${te(i.vgField(s))}])`)
         }
         return n
     }
 
-    function SC(e) {
-        return Qt(e.component.selection ?? {}).reduce((t, n) => t || n.project.hasSelectionId, !1)
+    function dC(e) {
+        return bn(e.component.selection ?? {}).reduce((t, n) => t || n.project.hasSelectionId, !1)
     }
 
-    function Pz(e, t) {
-        (re(t.select) || !t.select.on) && delete e.events, (re(t.select) || !t.select.clear) && delete e.clear, (re(t.select) || !t.select.toggle) && delete e.toggle
+    function xz(e, t) {
+        (le(t.select) || !t.select.on) && delete e.events, (le(t.select) || !t.select.clear) && delete e.clear, (le(t.select) || !t.select.toggle) && delete e.toggle
     }
 
-    function rx(e) {
+    function Nx(e) {
         const t = [];
-        return e.type === "Identifier" ? [e.name] : e.type === "Literal" ? [e.value] : (e.type === "MemberExpression" && (t.push(...rx(e.object)), t.push(...rx(e.property))), t)
+        return e.type === "Identifier" ? [e.name] : e.type === "Literal" ? [e.value] : (e.type === "MemberExpression" && (t.push(...Nx(e.object)), t.push(...Nx(e.property))), t)
     }
 
-    function Lz(e) {
-        return e.object.type === "MemberExpression" ? Lz(e.object) : e.object.name === "datum"
+    function _z(e) {
+        return e.object.type === "MemberExpression" ? _z(e.object) : e.object.name === "datum"
     }
 
-    function Iz(e) {
-        const t = jS(e),
+    function wz(e) {
+        const t = ME(e),
             n = new Set;
         return t.visit(i => {
-            i.type === "MemberExpression" && Lz(i) && n.add(rx(i).slice(1).join("."))
+            i.type === "MemberExpression" && _z(i) && n.add(Nx(i).slice(1).join("."))
         }), n
     }
-    class Nc extends nt {
+    class of extends ut {
         clone() {
-            return new Nc(null, this.model, ke(this.filter))
+            return new of(null, this.model, Fe(this.filter))
         }
         constructor(t, n, i) {
-            super(t), this.model = n, this.filter = i, this.expr = V0(this.model, this.filter, this), this._dependentFields = Iz(this.expr)
+            super(t), this.model = n, this.filter = i, this.expr = M0(this.model, this.filter, this), this._dependentFields = wz(this.expr)
         }
         dependentFields() {
             return this._dependentFields
         }
         producedFields() {
             return new Set
         }
@@ -44706,565 +38060,565 @@
             }
         }
         hash() {
             return `Filter ${this.expr}`
         }
     }
 
-    function wpe(e, t) {
+    function Gge(e, t) {
         const n = {},
             i = e.config.selection;
         if (!t || !t.length) return n;
         for (const r of t) {
-            const s = ft(r.name),
+            const s = Et(r.name),
                 a = r.select,
-                o = re(a) ? a : a.type,
-                l = ae(a) ? ke(a) : {
+                o = le(a) ? a : a.type,
+                l = ce(a) ? Fe(a) : {
                     type: o
                 },
                 u = i[o];
             for (const h in u) h === "fields" || h === "encodings" || (h === "mark" && (l[h] = {
                 ...u[h],
                 ...l[h]
-            }), (l[h] === void 0 || l[h] === !0) && (l[h] = ke(u[h] ?? l[h])));
+            }), (l[h] === void 0 || l[h] === !0) && (l[h] = Fe(u[h] ?? l[h])));
             const c = n[s] = {
                     ...l,
                     name: s,
                     type: o,
                     init: r.value,
                     bind: r.bind,
-                    events: re(l.on) ? to(l.on, "scope") : se(ke(l.on))
+                    events: le(l.on) ? wo(l.on, "scope") : ue(Fe(l.on))
                 },
-                f = ke(r);
-            for (const h of Y1) h.defined(c) && h.parse && h.parse(e, c, f)
+                f = Fe(r);
+            for (const h of ky) h.defined(c) && h.parse && h.parse(e, c, f)
         }
         return n
     }
 
-    function zz(e, t, n, i = "datum") {
-        const r = re(t) ? t : t.param,
-            s = ft(r),
-            a = Z(s + ml);
+    function Sz(e, t, n, i = "datum") {
+        const r = le(t) ? t : t.param,
+            s = Et(r),
+            a = te(s + Bl);
         let o;
         try {
             o = e.getSelectionComponent(s, r)
         } catch {
             return `!!${s}`
         }
         if (o.project.timeUnit) {
             const h = n ?? e.component.data.raw,
                 d = o.project.timeUnit.clone();
             h.parent ? d.insertAsParentOf(h) : h.parent = d
         }
         const l = o.project.hasSelectionId ? "vlSelectionIdTest(" : "vlSelectionTest(",
-            u = o.resolve === "global" ? ")" : `, ${Z(o.resolve)})`,
+            u = o.resolve === "global" ? ")" : `, ${te(o.resolve)})`,
             c = `${l}${a}, ${i}${u}`,
             f = `length(data(${a}))`;
         return t.empty === !1 ? `${f} && ${c}` : `!${f} || ${c}`
     }
 
-    function Bz(e, t, n) {
-        const i = ft(t),
+    function Ez(e, t, n) {
+        const i = Et(t),
             r = n.encoding;
         let s = n.field,
             a;
         try {
             a = e.getSelectionComponent(i, t)
         } catch {
             return i
         }
-        if (!r && !s) s = a.project.items[0].field, a.project.items.length > 1 && X(`A "field" or "encoding" must be specified when using a selection as a scale domain. Using "field": ${Z(s)}.`);
+        if (!r && !s) s = a.project.items[0].field, a.project.items.length > 1 && J(`A "field" or "encoding" must be specified when using a selection as a scale domain. Using "field": ${te(s)}.`);
         else if (r && !s) {
             const o = a.project.items.filter(l => l.channel === r);
-            !o.length || o.length > 1 ? (s = a.project.items[0].field, X((o.length ? "Multiple " : "No ") + `matching ${Z(r)} encoding found for selection ${Z(n.param)}. Using "field": ${Z(s)}.`)) : s = o[0].field
+            !o.length || o.length > 1 ? (s = a.project.items[0].field, J((o.length ? "Multiple " : "No ") + `matching ${te(r)} encoding found for selection ${te(n.param)}. Using "field": ${te(s)}.`)) : s = o[0].field
         }
-        return `${a.name}[${Z(Pi(s))}]`
+        return `${a.name}[${te(Ji(s))}]`
     }
 
-    function Spe(e, t) {
-        for (const [n, i] of Ba(e.component.selection ?? {})) {
+    function Uge(e, t) {
+        for (const [n, i] of lo(e.component.selection ?? {})) {
             const r = e.getName(`lookup_${n}`);
-            e.component.data.outputNodes[r] = i.materialized = new Dn(new Nc(t, e, {
+            e.component.data.outputNodes[r] = i.materialized = new Xn(new of(t, e, {
                 param: n
-            }), r, st.Lookup, e.component.data.outputNodeRefCounts)
+            }), r, pt.Lookup, e.component.data.outputNodeRefCounts)
         }
     }
 
-    function V0(e, t, n) {
-        return oh(t, i => re(i) ? i : ahe(i) ? zz(e, i, n) : i6(i))
+    function M0(e, t, n) {
+        return Nh(t, i => le(i) ? i : Efe(i) ? Sz(e, i, n) : G6(i))
     }
 
-    function Epe(e, t) {
-        if (e) return W(e) && !ca(e) ? e.map(n => iC(n, t)).join(", ") : e
+    function Wge(e, t) {
+        if (e) return H(e) && !Ta(e) ? e.map(n => Yk(n, t)).join(", ") : e
     }
 
-    function Ov(e, t, n, i) {
+    function ob(e, t, n, i) {
         var r, s;
         e.encode ?? (e.encode = {}), (r = e.encode)[t] ?? (r[t] = {}), (s = e.encode[t]).update ?? (s.update = {}), e.encode[t].update[n] = i
     }
 
-    function Gf(e, t, n, i = {
+    function gh(e, t, n, i = {
         header: !1
     }) {
         var f, h;
         const {
             disable: r,
             orient: s,
             scale: a,
             labelExpr: o,
             title: l,
             zindex: u,
             ...c
         } = e.combine();
         if (!r) {
             for (const d in c) {
-                const g = lde[d],
+                const g = Ahe[d],
                     p = c[d];
                 if (g && g !== t && g !== "both") delete c[d];
-                else if (Pd(p)) {
+                else if (hg(p)) {
                     const {
                         condition: m,
                         ...y
-                    } = p, v = se(m), b = B5[d];
+                    } = p, v = ue(m), b = oM[d];
                     if (b) {
                         const {
                             vgProp: x,
                             part: _
                         } = b, S = [...v.map(w => {
                             const {
                                 test: E,
-                                ...A
+                                ...C
                             } = w;
                             return {
-                                test: V0(null, E),
-                                ...A
+                                test: M0(null, E),
+                                ...C
                             }
                         }), y];
-                        Ov(c, _, x, S), delete c[d]
+                        ob(c, _, x, S), delete c[d]
                     } else if (b === null) {
                         const x = {
                             signal: v.map(_ => {
                                 const {
                                     test: S,
                                     ...w
                                 } = _;
-                                return `${V0(null,S)} ? ${E5(w)} : `
-                            }).join("") + E5(y)
+                                return `${M0(null,S)} ? ${q5(w)} : `
+                            }).join("") + q5(y)
                         };
                         c[d] = x
                     }
-                } else if (he(p)) {
-                    const m = B5[d];
+                } else if (xe(p)) {
+                    const m = oM[d];
                     if (m) {
                         const {
                             vgProp: y,
                             part: v
                         } = m;
-                        Ov(c, v, y, p), delete c[d]
+                        ob(c, v, y, p), delete c[d]
                     }
                 }
-                Fe(["labelAlign", "labelBaseline"], d) && c[d] === null && delete c[d]
+                Be(["labelAlign", "labelBaseline"], d) && c[d] === null && delete c[d]
             }
             if (t === "grid") {
                 if (!c.grid) return;
                 if (c.encode) {
                     const {
                         grid: d
                     } = c.encode;
                     c.encode = {
                         ...d ? {
                             grid: d
                         } : {}
-                    }, et(c.encode) && delete c.encode
+                    }, ft(c.encode) && delete c.encode
                 }
                 return {
                     scale: a,
                     orient: s,
                     ...c,
                     domain: !1,
                     labels: !1,
                     aria: !1,
                     maxExtent: 0,
                     minExtent: 0,
                     ticks: !1,
-                    zindex: Ct(u, 0)
+                    zindex: Gt(u, 0)
                 }
             } else {
                 if (!i.header && e.mainExtracted) return;
                 if (o !== void 0) {
                     let g = o;
-                    (h = (f = c.encode) == null ? void 0 : f.labels) != null && h.update && he(c.encode.labels.update.text) && (g = ll(o, "datum.label", c.encode.labels.update.text.signal)), Ov(c, "labels", "text", {
+                    (h = (f = c.encode) == null ? void 0 : f.labels) != null && h.update && xe(c.encode.labels.update.text) && (g = Rl(o, "datum.label", c.encode.labels.update.text.signal)), ob(c, "labels", "text", {
                         signal: g
                     })
                 }
                 if (c.labelAlign === null && delete c.labelAlign, c.encode) {
-                    for (const g of N6) e.hasAxisPart(g) || delete c.encode[g];
-                    et(c.encode) && delete c.encode
+                    for (const g of b8) e.hasAxisPart(g) || delete c.encode[g];
+                    ft(c.encode) && delete c.encode
                 }
-                const d = Epe(l, n);
+                const d = Wge(l, n);
                 return {
                     scale: a,
                     orient: s,
                     grid: !1,
                     ...d ? {
                         title: d
                     } : {},
                     ...c,
                     ...n.aria === !1 ? {
                         aria: !1
                     } : {},
-                    zindex: Ct(u, 0)
+                    zindex: Gt(u, 0)
                 }
             }
         }
     }
 
-    function jz(e) {
+    function kz(e) {
         const {
             axes: t
         } = e.component, n = [];
-        for (const i of cs)
+        for (const i of Es)
             if (t[i]) {
                 for (const r of t[i])
                     if (!r.get("disable") && !r.get("gridScale")) {
                         const s = i === "x" ? "height" : "width",
                             a = e.getSizeSignalRef(s).signal;
                         s !== a && n.push({
                             name: s,
                             update: a
                         })
                     }
             } return n
     }
 
-    function Cpe(e, t) {
+    function qge(e, t) {
         const {
             x: n = [],
             y: i = []
         } = e;
-        return [...n.map(r => Gf(r, "grid", t)), ...i.map(r => Gf(r, "grid", t)), ...n.map(r => Gf(r, "main", t)), ...i.map(r => Gf(r, "main", t))].filter(r => r)
+        return [...n.map(r => gh(r, "grid", t)), ...i.map(r => gh(r, "grid", t)), ...n.map(r => gh(r, "main", t)), ...i.map(r => gh(r, "main", t))].filter(r => r)
     }
 
-    function u3(e, t, n, i) {
+    function FM(e, t, n, i) {
         return Object.assign.apply(null, [{}, ...e.map(r => {
             if (r === "axisOrient") {
                 const s = n === "x" ? "bottom" : "left",
                     a = t[n === "x" ? "axisBottom" : "axisLeft"] || {},
                     o = t[n === "x" ? "axisTop" : "axisRight"] || {},
-                    l = new Set([...H(a), ...H(o)]),
+                    l = new Set([...K(a), ...K(o)]),
                     u = {};
                 for (const c of l.values()) u[c] = {
-                    signal: `${i.signal} === "${s}" ? ${Ds(a[c])} : ${Ds(o[c])}`
+                    signal: `${i.signal} === "${s}" ? ${br(a[c])} : ${br(o[c])}`
                 };
                 return u
             }
             return t[r]
         })])
     }
 
-    function kpe(e, t, n, i) {
-        const r = t === "band" ? ["axisDiscrete", "axisBand"] : t === "point" ? ["axisDiscrete", "axisPoint"] : o6(t) ? ["axisQuantitative"] : t === "time" || t === "utc" ? ["axisTemporal"] : [],
+    function Hge(e, t, n, i) {
+        const r = t === "band" ? ["axisDiscrete", "axisBand"] : t === "point" ? ["axisDiscrete", "axisPoint"] : H6(t) ? ["axisQuantitative"] : t === "time" || t === "utc" ? ["axisTemporal"] : [],
             s = e === "x" ? "axisX" : "axisY",
-            a = he(n) ? "axisOrient" : `axis${$d(n)}`,
+            a = xe(n) ? "axisOrient" : `axis${ig(n)}`,
             o = [...r, ...r.map(u => s + u.substr(4))],
             l = ["axis", a, s];
         return {
-            vlOnlyAxisConfig: u3(o, i, e, n),
-            vgAxisConfig: u3(l, i, e, n),
-            axisConfigStyle: Ape([...l, ...o], i)
+            vlOnlyAxisConfig: FM(o, i, e, n),
+            vgAxisConfig: FM(l, i, e, n),
+            axisConfigStyle: Yge([...l, ...o], i)
         }
     }
 
-    function Ape(e, t) {
+    function Yge(e, t) {
         var i;
         const n = [{}];
         for (const r of e) {
             let s = (i = t[r]) == null ? void 0 : i.style;
             if (s) {
-                s = se(s);
+                s = ue(s);
                 for (const a of s) n.push(t.style[a])
             }
         }
         return Object.assign.apply(null, n)
     }
 
-    function sx(e, t, n, i = {}) {
+    function Px(e, t, n, i = {}) {
         var s;
-        const r = II(e, n, t);
+        const r = x6(e, n, t);
         if (r !== void 0) return {
             configFrom: "style",
             configValue: r
         };
         for (const a of ["vlOnlyAxisConfig", "vgAxisConfig", "axisConfigStyle"])
             if (((s = i[a]) == null ? void 0 : s[e]) !== void 0) return {
                 configFrom: a,
                 configValue: i[a][e]
             };
         return {}
     }
-    const c3 = {
+    const RM = {
         scale: ({
             model: e,
             channel: t
         }) => e.scaleName(t),
         format: ({
             format: e
         }) => e,
         formatType: ({
             formatType: e
         }) => e,
         grid: ({
             fieldOrDatumDef: e,
             axis: t,
             scaleType: n
-        }) => t.grid ?? $pe(n, e),
+        }) => t.grid ?? Xge(n, e),
         gridScale: ({
             model: e,
             channel: t
-        }) => Tpe(e, t),
+        }) => Vge(e, t),
         labelAlign: ({
             axis: e,
             labelAngle: t,
             orient: n,
             channel: i
-        }) => e.labelAlign || Gz(t, n, i),
+        }) => e.labelAlign || Az(t, n, i),
         labelAngle: ({
             labelAngle: e
         }) => e,
         labelBaseline: ({
             axis: e,
             labelAngle: t,
             orient: n,
             channel: i
-        }) => e.labelBaseline || Uz(t, n, i),
+        }) => e.labelBaseline || Cz(t, n, i),
         labelFlush: ({
             axis: e,
             fieldOrDatumDef: t,
             channel: n
-        }) => e.labelFlush ?? Ope(t.type, n),
+        }) => e.labelFlush ?? Jge(t.type, n),
         labelOverlap: ({
             axis: e,
             fieldOrDatumDef: t,
             scaleType: n
-        }) => e.labelOverlap ?? Fpe(t.type, n, K(t) && !!t.timeUnit, K(t) ? t.sort : void 0),
+        }) => e.labelOverlap ?? Qge(t.type, n, Z(t) && !!t.timeUnit, Z(t) ? t.sort : void 0),
         orient: ({
             orient: e
         }) => e,
         tickCount: ({
             channel: e,
             model: t,
             axis: n,
             fieldOrDatumDef: i,
             scaleType: r
         }) => {
             const s = e === "x" ? "width" : e === "y" ? "height" : void 0,
                 a = s ? t.getSizeSignalRef(s) : void 0;
-            return n.tickCount ?? Dpe({
+            return n.tickCount ?? epe({
                 fieldOrDatumDef: i,
                 scaleType: r,
                 size: a,
                 values: n.values
             })
         },
-        tickMinStep: Npe,
+        tickMinStep: tpe,
         title: ({
             axis: e,
             model: t,
             channel: n
         }) => {
             if (e.title !== void 0) return e.title;
-            const i = Wz(t, n);
+            const i = $z(t, n);
             if (i !== void 0) return i;
             const r = t.typedFieldDef(n),
                 s = n === "x" ? "x2" : "y2",
                 a = t.fieldDef(s);
-            return BI(r ? [I5(r)] : [], K(a) ? [I5(a)] : [])
+            return w6(r ? [sM(r)] : [], Z(a) ? [sM(a)] : [])
         },
         values: ({
             axis: e,
             fieldOrDatumDef: t
-        }) => Ppe(e, t),
+        }) => npe(e, t),
         zindex: ({
             axis: e,
             fieldOrDatumDef: t,
             mark: n
-        }) => e.zindex ?? Lpe(n, t)
+        }) => e.zindex ?? ipe(n, t)
     };
 
-    function $pe(e, t) {
-        return !qt(e) && K(t) && !ot(t == null ? void 0 : t.bin) && !Xt(t == null ? void 0 : t.bin)
+    function Xge(e, t) {
+        return !fn(e) && Z(t) && !yt(t == null ? void 0 : t.bin) && !pn(t == null ? void 0 : t.bin)
     }
 
-    function Tpe(e, t) {
+    function Vge(e, t) {
         const n = t === "x" ? "y" : "x";
         if (e.getScaleComponent(n)) return e.scaleName(n)
     }
 
-    function Mpe(e, t, n, i, r) {
+    function Kge(e, t, n, i, r) {
         const s = t == null ? void 0 : t.labelAngle;
-        if (s !== void 0) return he(s) ? s : zh(s); {
+        if (s !== void 0) return xe(s) ? s : gd(s); {
             const {
                 configValue: a
-            } = sx("labelAngle", i, t == null ? void 0 : t.style, r);
-            return a !== void 0 ? zh(a) : n === ht && Fe([HE, qE], e.type) && !(K(e) && e.timeUnit) ? 270 : void 0
+            } = Px("labelAngle", i, t == null ? void 0 : t.style, r);
+            return a !== void 0 ? gd(a) : n === kt && Be([Nk, Dk], e.type) && !(Z(e) && e.timeUnit) ? 270 : void 0
         }
     }
 
-    function ax(e) {
+    function Lx(e) {
         return `(((${e.signal} % 360) + 360) % 360)`
     }
 
-    function Uz(e, t, n, i) {
+    function Cz(e, t, n, i) {
         if (e !== void 0)
             if (n === "x") {
-                if (he(e)) {
-                    const r = ax(e),
-                        s = he(t) ? `(${t.signal} === "top")` : t === "top";
+                if (xe(e)) {
+                    const r = Lx(e),
+                        s = xe(t) ? `(${t.signal} === "top")` : t === "top";
                     return {
                         signal: `(45 < ${r} && ${r} < 135) || (225 < ${r} && ${r} < 315) ? "middle" :(${r} <= 45 || 315 <= ${r}) === ${s} ? "bottom" : "top"`
                     }
                 }
                 if (45 < e && e < 135 || 225 < e && e < 315) return "middle";
-                if (he(t)) {
+                if (xe(t)) {
                     const r = e <= 45 || 315 <= e ? "===" : "!==";
                     return {
                         signal: `${t.signal} ${r} "top" ? "bottom" : "top"`
                     }
                 }
                 return (e <= 45 || 315 <= e) == (t === "top") ? "bottom" : "top"
             } else {
-                if (he(e)) {
-                    const r = ax(e),
-                        s = he(t) ? `(${t.signal} === "left")` : t === "left";
+                if (xe(e)) {
+                    const r = Lx(e),
+                        s = xe(t) ? `(${t.signal} === "left")` : t === "left";
                     return {
                         signal: `${r} <= 45 || 315 <= ${r} || (135 <= ${r} && ${r} <= 225) ? ${i?'"middle"':"null"} : (45 <= ${r} && ${r} <= 135) === ${s} ? "top" : "bottom"`
                     }
                 }
                 if (e <= 45 || 315 <= e || 135 <= e && e <= 225) return i ? "middle" : null;
-                if (he(t)) {
+                if (xe(t)) {
                     const r = 45 <= e && e <= 135 ? "===" : "!==";
                     return {
                         signal: `${t.signal} ${r} "left" ? "top" : "bottom"`
                     }
                 }
                 return (45 <= e && e <= 135) == (t === "left") ? "top" : "bottom"
             }
     }
 
-    function Gz(e, t, n) {
+    function Az(e, t, n) {
         if (e === void 0) return;
         const i = n === "x",
             r = i ? 0 : 90,
             s = i ? "bottom" : "left";
-        if (he(e)) {
-            const a = ax(e),
-                o = he(t) ? `(${t.signal} === "${s}")` : t === s;
+        if (xe(e)) {
+            const a = Lx(e),
+                o = xe(t) ? `(${t.signal} === "${s}")` : t === s;
             return {
                 signal: `(${r?`(${a} + 90)`:a} % 180 === 0) ? ${i?null:'"center"'} :(${r} < ${a} && ${a} < ${180+r}) === ${o} ? "left" : "right"`
             }
         }
         if ((e + r) % 180 === 0) return i ? null : "center";
-        if (he(t)) {
+        if (xe(t)) {
             const a = r < e && e < 180 + r ? "===" : "!==";
             return {
                 signal: `${`${t.signal} ${a} "${s}"`} ? "left" : "right"`
             }
         }
         return (r < e && e < 180 + r) == (t === s) ? "left" : "right"
     }
 
-    function Ope(e, t) {
-        if (t === "x" && Fe(["quantitative", "temporal"], e)) return !0
+    function Jge(e, t) {
+        if (t === "x" && Be(["quantitative", "temporal"], e)) return !0
     }
 
-    function Fpe(e, t, n, i) {
-        if (n && !ae(i) || e !== "nominal" && e !== "ordinal") return t === "log" || t === "symlog" ? "greedy" : !0
+    function Qge(e, t, n, i) {
+        if (n && !ce(i) || e !== "nominal" && e !== "ordinal") return t === "log" || t === "symlog" ? "greedy" : !0
     }
 
-    function Rpe(e) {
+    function Zge(e) {
         return e === "x" ? "bottom" : "left"
     }
 
-    function Dpe({
+    function epe({
         fieldOrDatumDef: e,
         scaleType: t,
         size: n,
         values: i
     }) {
         var r;
-        if (!i && !qt(t) && t !== "log") {
-            if (K(e)) {
-                if (ot(e.bin)) return {
+        if (!i && !fn(t) && t !== "log") {
+            if (Z(e)) {
+                if (yt(e.bin)) return {
                     signal: `ceil(${n.signal}/10)`
                 };
-                if (e.timeUnit && Fe(["month", "hours", "day", "quarter"], (r = en(e.timeUnit)) == null ? void 0 : r.unit)) return
+                if (e.timeUnit && Be(["month", "hours", "day", "quarter"], (r = an(e.timeUnit)) == null ? void 0 : r.unit)) return
             }
             return {
                 signal: `ceil(${n.signal}/40)`
             }
         }
     }
 
-    function Npe({
+    function tpe({
         format: e,
         fieldOrDatumDef: t
     }) {
         if (e === "d") return 1;
-        if (K(t)) {
+        if (Z(t)) {
             const {
                 timeUnit: n
             } = t;
             if (n) {
-                const i = t6(n);
+                const i = z6(n);
                 if (i) return {
                     signal: i
                 }
             }
         }
     }
 
-    function Wz(e, t) {
+    function $z(e, t) {
         const n = t === "x" ? "x2" : "y2",
             i = e.fieldDef(t),
             r = e.fieldDef(n),
             s = i ? i.title : void 0,
             a = r ? r.title : void 0;
-        if (s && a) return jI(s, a);
+        if (s && a) return S6(s, a);
         if (s) return s;
         if (a) return a;
         if (s !== void 0) return s;
         if (a !== void 0) return a
     }
 
-    function Ppe(e, t) {
+    function npe(e, t) {
         const n = e.values;
-        if (W(n)) return D6(t, n);
-        if (he(n)) return n
+        if (H(n)) return v8(t, n);
+        if (xe(n)) return n
     }
 
-    function Lpe(e, t) {
-        return e === "rect" && j0(t) ? 1 : 0
+    function ipe(e, t) {
+        return e === "rect" && w0(t) ? 1 : 0
     }
-    class lc extends nt {
+    class Nc extends ut {
         clone() {
-            return new lc(null, ke(this.transform))
+            return new Nc(null, Fe(this.transform))
         }
         constructor(t, n) {
-            super(t), this.transform = n, this._dependentFields = Iz(this.transform.calculate)
+            super(t), this.transform = n, this._dependentFields = wz(this.transform.calculate)
         }
         static parseAllForSortIndex(t, n) {
             return n.forEachFieldDef((i, r) => {
-                if (Il(i) && S6(i.sort)) {
+                if (su(i) && o8(i.sort)) {
                     const {
                         field: s,
                         timeUnit: a
-                    } = i, o = i.sort, l = o.map((u, c) => `${i6({field:s,timeUnit:a,equal:u})} ? ${c} : `).join("") + o.length;
-                    t = new lc(t, {
+                    } = i, o = i.sort, l = o.map((u, c) => `${G6({field:s,timeUnit:a,equal:u})} ? ${c} : `).join("") + o.length;
+                    t = new Nc(t, {
                         calculate: l,
-                        as: uc(i, r, {
+                        as: Pc(i, r, {
                             forAs: !0
                         })
                     })
                 }
             }), t
         }
         producedFields() {
@@ -45277,190 +38631,190 @@
             return {
                 type: "formula",
                 expr: this.transform.calculate,
                 as: this.transform.as
             }
         }
         hash() {
-            return `Calculate ${Ne(this.transform)}`
+            return `Calculate ${ze(this.transform)}`
         }
     }
 
-    function uc(e, t, n) {
-        return ie(e, {
+    function Pc(e, t, n) {
+        return oe(e, {
             prefix: t,
             suffix: "sort_index",
             ...n ?? {}
         })
     }
 
-    function X1(e, t) {
-        return Fe(["top", "bottom"], t) ? "column" : Fe(["left", "right"], t) || e === "row" ? "row" : "column"
+    function Cy(e, t) {
+        return Be(["top", "bottom"], t) ? "column" : Be(["left", "right"], t) || e === "row" ? "row" : "column"
     }
 
-    function cc(e, t, n, i) {
+    function Lc(e, t, n, i) {
         const r = i === "row" ? n.headerRow : i === "column" ? n.headerColumn : n.headerFacet;
-        return Ct((t || {})[e], r[e], n.header[e])
+        return Gt((t || {})[e], r[e], n.header[e])
     }
 
-    function V1(e, t, n, i) {
+    function Ay(e, t, n, i) {
         const r = {};
         for (const s of e) {
-            const a = cc(s, t || {}, n, i);
+            const a = Lc(s, t || {}, n, i);
             a !== void 0 && (r[s] = a)
         }
         return r
     }
-    const EC = ["row", "column"],
-        CC = ["header", "footer"];
+    const gC = ["row", "column"],
+        pC = ["header", "footer"];
 
-    function Ipe(e, t) {
+    function rpe(e, t) {
         const n = e.component.layoutHeaders[t].title,
             i = e.config ? e.config : void 0,
             r = e.component.layoutHeaders[t].facetFieldDef ? e.component.layoutHeaders[t].facetFieldDef : void 0,
             {
                 titleAnchor: s,
                 titleAngle: a,
                 titleOrient: o
-            } = V1(["titleAnchor", "titleAngle", "titleOrient"], r.header, i, t),
-            l = X1(t, o),
-            u = zh(a);
+            } = Ay(["titleAnchor", "titleAngle", "titleOrient"], r.header, i, t),
+            l = Cy(t, o),
+            u = gd(a);
         return {
             name: `${t}-title`,
             type: "group",
             role: `${l}-title`,
             title: {
                 text: n,
                 ...t === "row" ? {
                     orient: "left"
                 } : {},
                 style: "guide-title",
-                ...Hz(u, l),
-                ...qz(l, u, s),
-                ...Yz(i, r, t, Mde, J6)
+                ...Mz(u, l),
+                ...Tz(l, u, s),
+                ...Oz(i, r, t, Vhe, N8)
             }
         }
     }
 
-    function qz(e, t, n = "middle") {
+    function Tz(e, t, n = "middle") {
         switch (n) {
             case "start":
                 return {
                     align: "left"
                 };
             case "end":
                 return {
                     align: "right"
                 }
         }
-        const i = Gz(t, e === "row" ? "left" : "top", e === "row" ? "y" : "x");
+        const i = Az(t, e === "row" ? "left" : "top", e === "row" ? "y" : "x");
         return i ? {
             align: i
         } : {}
     }
 
-    function Hz(e, t) {
-        const n = Uz(e, t === "row" ? "left" : "top", t === "row" ? "y" : "x", !0);
+    function Mz(e, t) {
+        const n = Cz(e, t === "row" ? "left" : "top", t === "row" ? "y" : "x", !0);
         return n ? {
             baseline: n
         } : {}
     }
 
-    function zpe(e, t) {
+    function spe(e, t) {
         const n = e.component.layoutHeaders[t],
             i = [];
-        for (const r of CC)
+        for (const r of pC)
             if (n[r])
                 for (const s of n[r]) {
-                    const a = jpe(e, t, r, n, s);
+                    const a = ope(e, t, r, n, s);
                     a != null && i.push(a)
                 }
         return i
     }
 
-    function Bpe(e, t) {
+    function ape(e, t) {
         const {
             sort: n
         } = e;
-        return Br(n) ? {
-            field: ie(n, {
+        return ns(n) ? {
+            field: oe(n, {
                 expr: "datum"
             }),
             order: n.order ?? "ascending"
-        } : W(n) ? {
-            field: uc(e, t, {
+        } : H(n) ? {
+            field: Pc(e, t, {
                 expr: "datum"
             }),
             order: "ascending"
         } : {
-            field: ie(e, {
+            field: oe(e, {
                 expr: "datum"
             }),
             order: n ?? "ascending"
         }
     }
 
-    function ox(e, t, n) {
+    function Ix(e, t, n) {
         const {
             format: i,
             formatType: r,
             labelAngle: s,
             labelAnchor: a,
             labelOrient: o,
             labelExpr: l
-        } = V1(["format", "formatType", "labelAngle", "labelAnchor", "labelOrient", "labelExpr"], e.header, n, t), u = ZE({
+        } = Ay(["format", "formatType", "labelAngle", "labelAnchor", "labelOrient", "labelExpr"], e.header, n, t), u = Uk({
             fieldOrDatumDef: e,
             format: i,
             formatType: r,
             expr: "parent",
             config: n
-        }).signal, c = X1(t, o);
+        }).signal, c = Cy(t, o);
         return {
             text: {
-                signal: l ? ll(ll(l, "datum.label", u), "datum.value", ie(e, {
+                signal: l ? Rl(Rl(l, "datum.label", u), "datum.value", oe(e, {
                     expr: "parent"
                 })) : u
             },
             ...t === "row" ? {
                 orient: "left"
             } : {},
             style: "guide-label",
             frame: "group",
-            ...Hz(s, c),
-            ...qz(c, s, a),
-            ...Yz(n, e, t, Ode, Q6)
+            ...Mz(s, c),
+            ...Tz(c, s, a),
+            ...Oz(n, e, t, Khe, P8)
         }
     }
 
-    function jpe(e, t, n, i, r) {
+    function ope(e, t, n, i, r) {
         if (r) {
             let s = null;
             const {
                 facetFieldDef: a
             } = i, o = e.config ? e.config : void 0;
             if (a && r.labels) {
                 const {
                     labelOrient: f
-                } = V1(["labelOrient"], a.header, o, t);
-                (t === "row" && !Fe(["top", "bottom"], f) || t === "column" && !Fe(["left", "right"], f)) && (s = ox(a, t, o))
+                } = Ay(["labelOrient"], a.header, o, t);
+                (t === "row" && !Be(["top", "bottom"], f) || t === "column" && !Be(["left", "right"], f)) && (s = Ix(a, t, o))
             }
-            const l = lr(e) && !Rd(e.facet),
+            const l = kr(e) && !ug(e.facet),
                 u = r.axes,
                 c = (u == null ? void 0 : u.length) > 0;
             if (s || c) {
                 const f = t === "row" ? "height" : "width";
                 return {
                     name: e.getName(`${t}_${n}`),
                     type: "group",
                     role: `${t}-${n}`,
                     ...i.facetFieldDef ? {
                         from: {
                             data: e.getName(`${t}_domain`)
                         },
-                        sort: Bpe(a, t)
+                        sort: ape(a, t)
                     } : {},
                     ...c && l ? {
                         from: {
                             data: e.getName(`facet_domain_${t}`)
                         }
                     } : {},
                     ...s ? {
@@ -45477,81 +38831,81 @@
                         axes: u
                     } : {}
                 }
             }
         }
         return null
     }
-    const Upe = {
+    const lpe = {
         column: {
             start: 0,
             end: 1
         },
         row: {
             start: 1,
             end: 0
         }
     };
 
-    function Gpe(e, t) {
-        return Upe[t][e]
+    function upe(e, t) {
+        return lpe[t][e]
     }
 
-    function Wpe(e, t) {
+    function cpe(e, t) {
         const n = {};
-        for (const i of Ti) {
+        for (const i of Ui) {
             const r = e[i];
             if (r != null && r.facetFieldDef) {
                 const {
                     titleAnchor: s,
                     titleOrient: a
-                } = V1(["titleAnchor", "titleOrient"], r.facetFieldDef.header, t, i), o = X1(i, a), l = Gpe(s, o);
+                } = Ay(["titleAnchor", "titleOrient"], r.facetFieldDef.header, t, i), o = Cy(i, a), l = upe(s, o);
                 l !== void 0 && (n[o] = l)
             }
         }
-        return et(n) ? void 0 : n
+        return ft(n) ? void 0 : n
     }
 
-    function Yz(e, t, n, i, r) {
+    function Oz(e, t, n, i, r) {
         const s = {};
         for (const a of i) {
             if (!r[a]) continue;
-            const o = cc(a, t == null ? void 0 : t.header, e, n);
+            const o = Lc(a, t == null ? void 0 : t.header, e, n);
             o !== void 0 && (s[r[a]] = o)
         }
         return s
     }
 
-    function kC(e) {
-        return [...Mg(e, "width"), ...Mg(e, "height"), ...Mg(e, "childWidth"), ...Mg(e, "childHeight")]
+    function mC(e) {
+        return [...Kg(e, "width"), ...Kg(e, "height"), ...Kg(e, "childWidth"), ...Kg(e, "childHeight")]
     }
 
-    function Mg(e, t) {
+    function Kg(e, t) {
         const n = t === "width" ? "x" : "y",
             i = e.component.layoutSize.get(t);
         if (!i || i === "merged") return [];
         const r = e.getSizeSignalRef(t).signal;
         if (i === "step") {
             const s = e.getScaleComponent(n);
             if (s) {
                 const a = s.get("type"),
                     o = s.get("range");
-                if (qt(a) && lo(o)) {
+                if (fn(a) && To(o)) {
                     const l = e.scaleName(n);
-                    return lr(e.parent) && e.parent.component.resolve.scale[n] === "independent" ? [f3(l, o)] : [f3(l, o), {
+                    return kr(e.parent) && e.parent.component.resolve.scale[n] === "independent" ? [DM(l, o)] : [DM(l, o), {
                         name: r,
-                        update: Xz(l, s, `domain('${l}').length`)
+                        update: Fz(l, s, `domain('${l}').length`)
                     }]
                 }
             }
             throw new Error("layout size is step although width/height is not step.")
         } else if (i == "container") {
             const s = r.endsWith("width"),
                 a = s ? "containerSize()[0]" : "containerSize()[1]",
-                o = Z2(e.config.view, s ? "width" : "height"),
+                o = Mx(e.config.view, s ? "width" : "height"),
                 l = `isFinite(${a}) ? ${a} : ${o}`;
             return [{
                 name: r,
                 init: l,
                 on: [{
                     update: l,
                     events: "window:resize"
@@ -45559,189 +38913,189 @@
             }]
         } else return [{
             name: r,
             value: i
         }]
     }
 
-    function f3(e, t) {
+    function DM(e, t) {
         const n = `${e}_step`;
-        return he(t.step) ? {
+        return xe(t.step) ? {
             name: n,
             update: t.step.signal
         } : {
             name: n,
             value: t.step
         }
     }
 
-    function Xz(e, t, n) {
+    function Fz(e, t, n) {
         const i = t.get("type"),
             r = t.get("padding"),
-            s = Ct(t.get("paddingOuter"), r);
+            s = Gt(t.get("paddingOuter"), r);
         let a = t.get("paddingInner");
-        return a = i === "band" ? a !== void 0 ? a : r : 1, `bandspace(${n}, ${Ds(a)}, ${Ds(s)}) * ${e}_step`
+        return a = i === "band" ? a !== void 0 ? a : r : 1, `bandspace(${n}, ${br(a)}, ${br(s)}) * ${e}_step`
     }
 
-    function Vz(e) {
+    function Rz(e) {
         return e === "childWidth" ? "width" : e === "childHeight" ? "height" : e
     }
 
-    function Kz(e, t) {
-        return H(e).reduce((n, i) => {
+    function Dz(e, t) {
+        return K(e).reduce((n, i) => {
             const r = e[i];
             return {
                 ...n,
-                ...Dc(t, r, i, s => ut(s.value))
+                ...af(t, r, i, s => bt(s.value))
             }
         }, {})
     }
 
-    function Jz(e, t) {
-        if (lr(t)) return e === "theta" ? "independent" : "shared";
-        if (Ic(t)) return "shared";
-        if (RC(t)) return Wt(e) || e === "theta" || e === "radius" ? "independent" : "shared";
+    function Nz(e, t) {
+        if (kr(t)) return e === "theta" ? "independent" : "shared";
+        if (cf(t)) return "shared";
+        if (SC(t)) return cn(e) || e === "theta" || e === "radius" ? "independent" : "shared";
         throw new Error("invalid model type for resolve")
     }
 
-    function AC(e, t) {
+    function yC(e, t) {
         const n = e.scale[t],
-            i = Wt(t) ? "axis" : "legend";
-        return n === "independent" ? (e[i][t] === "shared" && X(Tfe(t)), "independent") : e[i][t] || "shared"
+            i = cn(t) ? "axis" : "legend";
+        return n === "independent" ? (e[i][t] === "shared" && J(Hce(t)), "independent") : e[i][t] || "shared"
     }
-    const qpe = {
-            ...Dde,
+    const fpe = {
+            ...Zhe,
             disable: 1,
             labelExpr: 1,
             selections: 1,
             opacity: 1,
             shape: 1,
             stroke: 1,
             fill: 1,
             size: 1,
             strokeWidth: 1,
             strokeDash: 1,
             encode: 1
         },
-        Qz = H(qpe);
-    class Hpe extends ea {}
-    const h3 = {
-        symbols: Ype,
-        gradient: Xpe,
-        labels: Vpe,
-        entries: Kpe
+        Pz = K(fpe);
+    class hpe extends ga {}
+    const NM = {
+        symbols: dpe,
+        gradient: gpe,
+        labels: ppe,
+        entries: mpe
     };
 
-    function Ype(e, {
+    function dpe(e, {
         fieldOrDatumDef: t,
         model: n,
         channel: i,
         legendCmpt: r,
         legendType: s
     }) {
         if (s !== "symbol") return;
         const {
             markDef: a,
             encoding: o,
             config: l,
             mark: u
         } = n, c = a.filled && u !== "trail";
         let f = {
-            ...zce({}, n, Ohe),
-            ...Ez(n, {
+            ...nce({}, n, Vfe),
+            ...lz(n, {
                 filled: c
             })
         };
         const h = r.get("symbolOpacity") ?? l.legend.symbolOpacity,
             d = r.get("symbolFillColor") ?? l.legend.symbolFillColor,
             g = r.get("symbolStrokeColor") ?? l.legend.symbolStrokeColor,
-            p = h === void 0 ? Zz(o.opacity) ?? a.opacity : void 0;
+            p = h === void 0 ? Lz(o.opacity) ?? a.opacity : void 0;
         if (f.fill) {
-            if (i === "fill" || c && i === si) delete f.fill;
-            else if (f.fill.field) d ? delete f.fill : (f.fill = ut(l.legend.symbolBaseFillColor ?? "black"), f.fillOpacity = ut(p ?? 1));
-            else if (W(f.fill)) {
-                const m = lx(o.fill ?? o.color) ?? a.fill ?? (c && a.color);
-                m && (f.fill = ut(m))
+            if (i === "fill" || c && i === pi) delete f.fill;
+            else if (f.fill.field) d ? delete f.fill : (f.fill = bt(l.legend.symbolBaseFillColor ?? "black"), f.fillOpacity = bt(p ?? 1));
+            else if (H(f.fill)) {
+                const m = zx(o.fill ?? o.color) ?? a.fill ?? (c && a.color);
+                m && (f.fill = bt(m))
             }
         }
         if (f.stroke) {
-            if (i === "stroke" || !c && i === si) delete f.stroke;
+            if (i === "stroke" || !c && i === pi) delete f.stroke;
             else if (f.stroke.field || g) delete f.stroke;
-            else if (W(f.stroke)) {
-                const m = Ct(lx(o.stroke || o.color), a.stroke, c ? a.color : void 0);
+            else if (H(f.stroke)) {
+                const m = Gt(zx(o.stroke || o.color), a.stroke, c ? a.color : void 0);
                 m && (f.stroke = {
                     value: m
                 })
             }
         }
-        if (i !== Js) {
-            const m = K(t) && t8(n, r, t);
+        if (i !== fa) {
+            const m = Z(t) && zz(n, r, t);
             m ? f.opacity = [{
                 test: m,
-                ...ut(p ?? 1)
-            }, ut(l.legend.unselectedOpacity)] : p && (f.opacity = ut(p))
+                ...bt(p ?? 1)
+            }, bt(l.legend.unselectedOpacity)] : p && (f.opacity = bt(p))
         }
         return f = {
             ...f,
             ...e
-        }, et(f) ? void 0 : f
+        }, ft(f) ? void 0 : f
     }
 
-    function Xpe(e, {
+    function gpe(e, {
         model: t,
         legendType: n,
         legendCmpt: i
     }) {
         if (n !== "gradient") return;
         const {
             config: r,
             markDef: s,
             encoding: a
         } = t;
         let o = {};
-        const u = (i.get("gradientOpacity") ?? r.legend.gradientOpacity) === void 0 ? Zz(a.opacity) || s.opacity : void 0;
-        return u && (o.opacity = ut(u)), o = {
+        const u = (i.get("gradientOpacity") ?? r.legend.gradientOpacity) === void 0 ? Lz(a.opacity) || s.opacity : void 0;
+        return u && (o.opacity = bt(u)), o = {
             ...o,
             ...e
-        }, et(o) ? void 0 : o
+        }, ft(o) ? void 0 : o
     }
 
-    function Vpe(e, {
+    function ppe(e, {
         fieldOrDatumDef: t,
         model: n,
         channel: i,
         legendCmpt: r
     }) {
         const s = n.legend(i) || {},
             a = n.config,
-            o = K(t) ? t8(n, r, t) : void 0,
+            o = Z(t) ? zz(n, r, t) : void 0,
             l = o ? [{
                 test: o,
                 value: 1
             }, {
                 value: a.legend.unselectedOpacity
             }] : void 0,
             {
                 format: u,
                 formatType: c
             } = s;
         let f;
-        gl(c) ? f = rr({
+        Il(c) ? f = _r({
             fieldOrDatumDef: t,
             field: "datum.value",
             format: u,
             formatType: c,
             config: a
-        }) : u === void 0 && c === void 0 && a.customFormatTypes && (t.type === "quantitative" && a.numberFormatType ? f = rr({
+        }) : u === void 0 && c === void 0 && a.customFormatTypes && (t.type === "quantitative" && a.numberFormatType ? f = _r({
             fieldOrDatumDef: t,
             field: "datum.value",
             format: a.numberFormat,
             formatType: a.numberFormatType,
             config: a
-        }) : t.type === "temporal" && a.timeFormatType && K(t) && t.timeUnit === void 0 && (f = rr({
+        }) : t.type === "temporal" && a.timeFormatType && Z(t) && t.timeUnit === void 0 && (f = _r({
             fieldOrDatumDef: t,
             field: "datum.value",
             format: a.timeFormat,
             formatType: a.timeFormatType,
             config: a
         })));
         const h = {
@@ -45749,122 +39103,122 @@
                 opacity: l
             } : {},
             ...f ? {
                 text: f
             } : {},
             ...e
         };
-        return et(h) ? void 0 : h
+        return ft(h) ? void 0 : h
     }
 
-    function Kpe(e, {
+    function mpe(e, {
         legendCmpt: t
     }) {
         const n = t.get("selections");
         return n != null && n.length ? {
             ...e,
             fill: {
                 value: "transparent"
             }
         } : e
     }
 
-    function Zz(e) {
-        return e8(e, (t, n) => Math.max(t, n.value))
+    function Lz(e) {
+        return Iz(e, (t, n) => Math.max(t, n.value))
     }
 
-    function lx(e) {
-        return e8(e, (t, n) => Ct(t, n.value))
+    function zx(e) {
+        return Iz(e, (t, n) => Gt(t, n.value))
     }
 
-    function e8(e, t) {
-        if (Khe(e)) return se(e.condition).reduce(t, e.value);
-        if (gr(e)) return e.value
+    function Iz(e, t) {
+        if (phe(e)) return ue(e.condition).reduce(t, e.value);
+        if (Tr(e)) return e.value
     }
 
-    function t8(e, t, n) {
+    function zz(e, t, n) {
         const i = t.get("selections");
         if (!(i != null && i.length)) return;
-        const r = Z(n.field);
-        return i.map(s => `(!length(data(${Z(ft(s)+ml)})) || (${s}[${r}] && indexof(${s}[${r}], datum.value) >= 0))`).join(" || ")
+        const r = te(n.field);
+        return i.map(s => `(!length(data(${te(Et(s)+Bl)})) || (${s}[${r}] && indexof(${s}[${r}], datum.value) >= 0))`).join(" || ")
     }
-    const d3 = {
+    const PM = {
         direction: ({
             direction: e
         }) => e,
         format: ({
             fieldOrDatumDef: e,
             legend: t,
             config: n
         }) => {
             const {
                 format: i,
                 formatType: r
             } = t;
-            return b6(e, e.type, i, r, n, !1)
+            return i8(e, e.type, i, r, n, !1)
         },
         formatType: ({
             legend: e,
             fieldOrDatumDef: t,
             scaleType: n
         }) => {
             const {
                 formatType: i
             } = e;
-            return x6(i, t, n)
+            return r8(i, t, n)
         },
         gradientLength: e => {
             const {
                 legend: t,
                 legendConfig: n
             } = e;
-            return t.gradientLength ?? n.gradientLength ?? i0e(e)
+            return t.gradientLength ?? n.gradientLength ?? Spe(e)
         },
         labelOverlap: ({
             legend: e,
             legendConfig: t,
             scaleType: n
-        }) => e.labelOverlap ?? t.labelOverlap ?? r0e(n),
+        }) => e.labelOverlap ?? t.labelOverlap ?? Epe(n),
         symbolType: ({
             legend: e,
             markDef: t,
             channel: n,
             encoding: i
-        }) => e.symbolType ?? Qpe(t.type, n, i.shape, t.shape),
+        }) => e.symbolType ?? vpe(t.type, n, i.shape, t.shape),
         title: ({
             fieldOrDatumDef: e,
             config: t
-        }) => ku(e, t, {
+        }) => Ju(e, t, {
             allowDisabling: !0
         }),
         type: ({
             legendType: e,
             scaleType: t,
             channel: n
         }) => {
-            if (Cu(n) && ir(t)) {
+            if (Ku(n) && xr(t)) {
                 if (e === "gradient") return
             } else if (e === "symbol") return;
             return e
         },
         values: ({
             fieldOrDatumDef: e,
             legend: t
-        }) => Jpe(t, e)
+        }) => ype(t, e)
     };
 
-    function Jpe(e, t) {
+    function ype(e, t) {
         const n = e.values;
-        if (W(n)) return D6(t, n);
-        if (he(n)) return n
+        if (H(n)) return v8(t, n);
+        if (xe(n)) return n
     }
 
-    function Qpe(e, t, n, i) {
+    function vpe(e, t, n, i) {
         if (t !== "shape") {
-            const r = lx(n) ?? i;
+            const r = zx(n) ?? i;
             if (r) return r
         }
         switch (e) {
             case "bar":
             case "rect":
             case "image":
             case "square":
@@ -45880,100 +39234,100 @@
             case "geoshape":
             case "area":
             case "text":
                 return "circle"
         }
     }
 
-    function Zpe(e) {
+    function bpe(e) {
         const {
             legend: t
         } = e;
-        return Ct(t.type, e0e(e))
+        return Gt(t.type, xpe(e))
     }
 
-    function e0e({
+    function xpe({
         channel: e,
         timeUnit: t,
         scaleType: n
     }) {
-        if (Cu(e)) {
-            if (Fe(["quarter", "month", "day"], t)) return "symbol";
-            if (ir(n)) return "gradient"
+        if (Ku(e)) {
+            if (Be(["quarter", "month", "day"], t)) return "symbol";
+            if (xr(n)) return "gradient"
         }
         return "symbol"
     }
 
-    function t0e({
+    function _pe({
         legendConfig: e,
         legendType: t,
         orient: n,
         legend: i
     }) {
-        return i.direction ?? e[t ? "gradientDirection" : "symbolDirection"] ?? n0e(n, t)
+        return i.direction ?? e[t ? "gradientDirection" : "symbolDirection"] ?? wpe(n, t)
     }
 
-    function n0e(e, t) {
+    function wpe(e, t) {
         switch (e) {
             case "top":
             case "bottom":
                 return "horizontal";
             case "left":
             case "right":
             case "none":
             case void 0:
                 return;
             default:
                 return t === "gradient" ? "horizontal" : void 0
         }
     }
 
-    function i0e({
+    function Spe({
         legendConfig: e,
         model: t,
         direction: n,
         orient: i,
         scaleType: r
     }) {
         const {
             gradientHorizontalMaxLength: s,
             gradientHorizontalMinLength: a,
             gradientVerticalMaxLength: o,
             gradientVerticalMinLength: l
         } = e;
-        if (ir(r)) return n === "horizontal" ? i === "top" || i === "bottom" ? g3(t, "width", a, s) : a : g3(t, "height", l, o)
+        if (xr(r)) return n === "horizontal" ? i === "top" || i === "bottom" ? LM(t, "width", a, s) : a : LM(t, "height", l, o)
     }
 
-    function g3(e, t, n, i) {
+    function LM(e, t, n, i) {
         return {
             signal: `clamp(${e.getSizeSignalRef(t).signal}, ${n}, ${i})`
         }
     }
 
-    function r0e(e) {
-        if (Fe(["quantile", "threshold", "log", "symlog"], e)) return "greedy"
+    function Epe(e) {
+        if (Be(["quantile", "threshold", "log", "symlog"], e)) return "greedy"
     }
 
-    function n8(e) {
-        const t = Et(e) ? s0e(e) : u0e(e);
+    function Bz(e) {
+        const t = Dt(e) ? kpe(e) : Tpe(e);
         return e.component.legends = t, t
     }
 
-    function s0e(e) {
+    function kpe(e) {
         const {
             encoding: t
         } = e, n = {};
-        for (const i of [si, ...ez]) {
-            const r = Mt(t[i]);
-            !r || !e.getScaleComponent(i) || i === ai && K(r) && r.type === Rc || (n[i] = l0e(e, i))
+        for (const i of [pi, ...I8]) {
+            const r = Yt(t[i]);
+            !r || !e.getScaleComponent(i) || i === mi && Z(r) && r.type === sf || (n[i] = $pe(e, i))
         }
         return n
     }
 
-    function a0e(e, t) {
+    function Cpe(e, t) {
         const n = e.scaleName(t);
         if (e.mark === "trail") {
             if (t === "color") return {
                 stroke: n
             };
             if (t === "size") return {
                 strokeWidth: n
@@ -45984,49 +39338,49 @@
         } : {
             stroke: n
         } : {
             [t]: n
         }
     }
 
-    function o0e(e, t, n, i) {
+    function Ape(e, t, n, i) {
         switch (t) {
             case "disable":
                 return n !== void 0;
             case "values":
                 return !!(n != null && n.values);
             case "title":
                 if (t === "title" && e === (i == null ? void 0 : i.title)) return !0
         }
         return e === (n || {})[t]
     }
 
-    function l0e(e, t) {
+    function $pe(e, t) {
         var x;
         let n = e.legend(t);
         const {
             markDef: i,
             encoding: r,
             config: s
-        } = e, a = s.legend, o = new Hpe({}, a0e(e, t));
-        ype(e, t, o);
+        } = e, a = s.legend, o = new hpe({}, Cpe(e, t));
+        Lge(e, t, o);
         const l = n !== void 0 ? !n : a.disable;
         if (o.set("disable", l, n !== void 0), l) return o;
         n = n || {};
         const u = e.getScaleComponent(t).get("type"),
-            c = Mt(r[t]),
-            f = K(c) ? (x = en(c.timeUnit)) == null ? void 0 : x.unit : void 0,
+            c = Yt(r[t]),
+            f = Z(c) ? (x = an(c.timeUnit)) == null ? void 0 : x.unit : void 0,
             h = n.orient || s.legend.orient || "right",
-            d = Zpe({
+            d = bpe({
                 legend: n,
                 channel: t,
                 timeUnit: f,
                 scaleType: u
             }),
-            g = t0e({
+            g = _pe({
                 legend: n,
                 legendType: d,
                 orient: h,
                 legendConfig: a
             }),
             p = {
                 legend: n,
@@ -46038,156 +39392,156 @@
                 legendConfig: a,
                 config: s,
                 scaleType: u,
                 orient: h,
                 legendType: d,
                 direction: g
             };
-        for (const _ of Qz) {
+        for (const _ of Pz) {
             if (d === "gradient" && _.startsWith("symbol") || d === "symbol" && _.startsWith("gradient")) continue;
-            const S = _ in d3 ? d3[_](p) : n[_];
+            const S = _ in PM ? PM[_](p) : n[_];
             if (S !== void 0) {
-                const w = o0e(S, _, n, e.fieldDef(t));
+                const w = Ape(S, _, n, e.fieldDef(t));
                 (w || s.legend[_] === void 0) && o.set(_, S, w)
             }
         }
         const m = (n == null ? void 0 : n.encoding) ?? {},
             y = o.get("selections"),
             v = {},
             b = {
                 fieldOrDatumDef: c,
                 model: e,
                 channel: t,
                 legendCmpt: o,
                 legendType: d
             };
         for (const _ of ["labels", "legend", "title", "symbols", "gradient", "entries"]) {
-            const S = Kz(m[_] ?? {}, e),
-                w = _ in h3 ? h3[_](S, b) : S;
-            w !== void 0 && !et(w) && (v[_] = {
-                ...y != null && y.length && K(c) ? {
-                    name: `${ft(c.field)}_legend_${_}`
+            const S = Dz(m[_] ?? {}, e),
+                w = _ in NM ? NM[_](S, b) : S;
+            w !== void 0 && !ft(w) && (v[_] = {
+                ...y != null && y.length && Z(c) ? {
+                    name: `${Et(c.field)}_legend_${_}`
                 } : {},
                 ...y != null && y.length ? {
                     interactive: !!y
                 } : {},
                 update: w
             })
         }
-        return et(v) || o.set("encode", v, !!(n != null && n.encoding)), o
+        return ft(v) || o.set("encode", v, !!(n != null && n.encoding)), o
     }
 
-    function u0e(e) {
+    function Tpe(e) {
         const {
             legends: t,
             resolve: n
         } = e.component;
         for (const i of e.children) {
-            n8(i);
-            for (const r of H(i.component.legends)) n.legend[r] = AC(e.component.resolve, r), n.legend[r] === "shared" && (t[r] = i8(t[r], i.component.legends[r]), t[r] || (n.legend[r] = "independent", delete t[r]))
+            Bz(i);
+            for (const r of K(i.component.legends)) n.legend[r] = yC(e.component.resolve, r), n.legend[r] === "shared" && (t[r] = jz(t[r], i.component.legends[r]), t[r] || (n.legend[r] = "independent", delete t[r]))
         }
-        for (const i of H(t))
+        for (const i of K(t))
             for (const r of e.children) r.component.legends[i] && n.legend[i] === "shared" && delete r.component.legends[i];
         return t
     }
 
-    function i8(e, t) {
+    function jz(e, t) {
         var s, a, o, l;
         if (!e) return t.clone();
         const n = e.getWithExplicit("orient"),
             i = t.getWithExplicit("orient");
         if (n.explicit && i.explicit && n.value !== i.value) return;
         let r = !1;
-        for (const u of Qz) {
-            const c = Ua(e.getWithExplicit(u), t.getWithExplicit(u), u, "legend", (f, h) => {
+        for (const u of Pz) {
+            const c = co(e.getWithExplicit(u), t.getWithExplicit(u), u, "legend", (f, h) => {
                 switch (u) {
                     case "symbolType":
-                        return c0e(f, h);
+                        return Mpe(f, h);
                     case "title":
-                        return UI(f, h);
+                        return E6(f, h);
                     case "type":
-                        return r = !0, ci("symbol")
+                        return r = !0, Si("symbol")
                 }
-                return q1(f, h, u, "legend")
+                return Sy(f, h, u, "legend")
             });
             e.setWithExplicit(u, c)
         }
-        return r && ((a = (s = e.implicit) == null ? void 0 : s.encode) != null && a.gradient && N0(e.implicit, ["encode", "gradient"]), (l = (o = e.explicit) == null ? void 0 : o.encode) != null && l.gradient && N0(e.explicit, ["encode", "gradient"])), e
+        return r && ((a = (s = e.implicit) == null ? void 0 : s.encode) != null && a.gradient && m0(e.implicit, ["encode", "gradient"]), (l = (o = e.explicit) == null ? void 0 : o.encode) != null && l.gradient && m0(e.explicit, ["encode", "gradient"])), e
     }
 
-    function c0e(e, t) {
+    function Mpe(e, t) {
         return t.value === "circle" ? t : e
     }
 
-    function f0e(e, t, n, i) {
+    function Ope(e, t, n, i) {
         var r, s;
         e.encode ?? (e.encode = {}), (r = e.encode)[t] ?? (r[t] = {}), (s = e.encode[t]).update ?? (s.update = {}), e.encode[t].update[n] = i
     }
 
-    function r8(e) {
+    function Gz(e) {
         const t = e.component.legends,
             n = {};
-        for (const r of H(t)) {
+        for (const r of K(t)) {
             const s = e.getScaleComponent(r),
-                a = at(s.get("domains"));
+                a = mt(s.get("domains"));
             if (n[a])
-                for (const o of n[a]) i8(o, t[r]) || n[a].push(t[r]);
+                for (const o of n[a]) jz(o, t[r]) || n[a].push(t[r]);
             else n[a] = [t[r].clone()]
         }
-        return Qt(n).flat().map(r => h0e(r, e.config)).filter(r => r !== void 0)
+        return bn(n).flat().map(r => Fpe(r, e.config)).filter(r => r !== void 0)
     }
 
-    function h0e(e, t) {
+    function Fpe(e, t) {
         var a, o, l;
         const {
             disable: n,
             labelExpr: i,
             selections: r,
             ...s
         } = e.combine();
         if (!n) {
             if (t.aria === !1 && s.aria == null && (s.aria = !1), (a = s.encode) != null && a.symbols) {
                 const u = s.encode.symbols.update;
                 u.fill && u.fill.value !== "transparent" && !u.stroke && !s.stroke && (u.stroke = {
                     value: "transparent"
                 });
-                for (const c of ez) s[c] && delete u[c]
+                for (const c of I8) s[c] && delete u[c]
             }
             if (s.title || delete s.title, i !== void 0) {
                 let u = i;
-                (l = (o = s.encode) == null ? void 0 : o.labels) != null && l.update && he(s.encode.labels.update.text) && (u = ll(i, "datum.label", s.encode.labels.update.text.signal)), f0e(s, "labels", "text", {
+                (l = (o = s.encode) == null ? void 0 : o.labels) != null && l.update && xe(s.encode.labels.update.text) && (u = Rl(i, "datum.label", s.encode.labels.update.text.signal)), Ope(s, "labels", "text", {
                     signal: u
                 })
             }
             return s
         }
     }
 
-    function d0e(e) {
-        return Ic(e) || RC(e) ? g0e(e) : s8(e)
+    function Rpe(e) {
+        return cf(e) || SC(e) ? Dpe(e) : Uz(e)
     }
 
-    function g0e(e) {
-        return e.children.reduce((t, n) => t.concat(n.assembleProjections()), s8(e))
+    function Dpe(e) {
+        return e.children.reduce((t, n) => t.concat(n.assembleProjections()), Uz(e))
     }
 
-    function s8(e) {
+    function Uz(e) {
         const t = e.component.projection;
         if (!t || t.merged) return [];
         const n = t.combine(),
             {
                 name: i
             } = n;
         if (t.data) {
             const r = {
                     signal: `[${t.size.map(a=>a.signal).join(", ")}]`
                 },
                 s = t.data.reduce((a, o) => {
-                    const l = he(o) ? o.signal : `data('${e.lookupDataSource(o)}')`;
-                    return Fe(a, l) || a.push(l), a
+                    const l = xe(o) ? o.signal : `data('${e.lookupDataSource(o)}')`;
+                    return Be(a, l) || a.push(l), a
                 }, []);
             if (s.length <= 0) throw new Error("Projection's fit didn't find any data sources");
             return [{
                 name: i,
                 size: r,
                 fit: {
                     signal: s.length > 1 ? `[${s.join(", ")}]` : s[0]
@@ -46198,157 +39552,157 @@
             name: i,
             translate: {
                 signal: "[width / 2, height / 2]"
             },
             ...n
         }]
     }
-    const p0e = ["type", "clipAngle", "clipExtent", "center", "rotate", "precision", "reflectX", "reflectY", "coefficient", "distance", "fraction", "lobes", "parallel", "radius", "ratio", "spacing", "tilt"];
-    class a8 extends ea {
+    const Npe = ["type", "clipAngle", "clipExtent", "center", "rotate", "precision", "reflectX", "reflectY", "coefficient", "distance", "fraction", "lobes", "parallel", "radius", "ratio", "spacing", "tilt"];
+    class Wz extends ga {
         constructor(t, n, i, r) {
             super({
                 ...n
             }, {
                 name: t
             }), this.specifiedProjection = n, this.size = i, this.data = r, this.merged = !1
         }
         get isFit() {
             return !!this.data
         }
     }
 
-    function o8(e) {
-        e.component.projection = Et(e) ? m0e(e) : b0e(e)
+    function qz(e) {
+        e.component.projection = Dt(e) ? Ppe(e) : zpe(e)
     }
 
-    function m0e(e) {
+    function Ppe(e) {
         if (e.hasProjection) {
-            const t = Hn(e.specifiedProjection),
+            const t = ii(e.specifiedProjection),
                 n = !(t && (t.scale != null || t.translate != null)),
                 i = n ? [e.getSizeSignalRef("width"), e.getSizeSignalRef("height")] : void 0,
-                r = n ? y0e(e) : void 0,
-                s = new a8(e.projectionName(!0), {
-                    ...Hn(e.config.projection) ?? {},
+                r = n ? Lpe(e) : void 0,
+                s = new Wz(e.projectionName(!0), {
+                    ...ii(e.config.projection) ?? {},
                     ...t ?? {}
                 }, i, r);
             return s.get("type") || s.set("type", "equalEarth", !1), s
         }
     }
 
-    function y0e(e) {
+    function Lpe(e) {
         const t = [],
             {
                 encoding: n
             } = e;
         for (const i of [
-                [Sr, wr],
-                [Li, Er]
-            ])(Mt(n[i[0]]) || Mt(n[i[1]])) && t.push({
+                [Lr, Pr],
+                [Qi, Ir]
+            ])(Yt(n[i[0]]) || Yt(n[i[1]])) && t.push({
             signal: e.getName(`geojson_${t.length}`)
         });
-        return e.channelHasField(ai) && e.typedFieldDef(ai).type === Rc && t.push({
+        return e.channelHasField(mi) && e.typedFieldDef(mi).type === sf && t.push({
             signal: e.getName(`geojson_${t.length}`)
-        }), t.length === 0 && t.push(e.requestDataName(st.Main)), t
+        }), t.length === 0 && t.push(e.requestDataName(pt.Main)), t
     }
 
-    function v0e(e, t) {
-        const n = bE(p0e, r => !!(!me(e.explicit, r) && !me(t.explicit, r) || me(e.explicit, r) && me(t.explicit, r) && Nr(e.get(r), t.get(r))));
-        if (Nr(e.size, t.size)) {
+    function Ipe(e, t) {
+        const n = lk(Npe, r => !!(!Ce(e.explicit, r) && !Ce(t.explicit, r) || Ce(e.explicit, r) && Ce(t.explicit, r) && Jr(e.get(r), t.get(r))));
+        if (Jr(e.size, t.size)) {
             if (n) return e;
-            if (Nr(e.explicit, {})) return t;
-            if (Nr(t.explicit, {})) return e
+            if (Jr(e.explicit, {})) return t;
+            if (Jr(t.explicit, {})) return e
         }
         return null
     }
 
-    function b0e(e) {
+    function zpe(e) {
         if (e.children.length === 0) return;
         let t;
-        for (const i of e.children) o8(i);
-        const n = bE(e.children, i => {
+        for (const i of e.children) qz(i);
+        const n = lk(e.children, i => {
             const r = i.component.projection;
             if (r)
                 if (t) {
-                    const s = v0e(t, r);
+                    const s = Ipe(t, r);
                     return s && (t = s), !!s
                 } else return t = r, !0;
             else return !0
         });
         if (t && n) {
             const i = e.projectionName(!0),
-                r = new a8(i, t.specifiedProjection, t.size, ke(t.data));
+                r = new Wz(i, t.specifiedProjection, t.size, Fe(t.data));
             for (const s of e.children) {
                 const a = s.component.projection;
                 a && (a.isFit && r.data.push(...s.component.projection.data), s.renameProjection(a.get("name"), i), a.merged = !0)
             }
             return r
         }
     }
 
-    function x0e(e, t, n, i) {
-        if (Nd(t, n)) {
-            const r = Et(e) ? e.axis(n) ?? e.legend(n) ?? {} : {},
-                s = ie(t, {
+    function Bpe(e, t, n, i) {
+        if (fg(t, n)) {
+            const r = Dt(e) ? e.axis(n) ?? e.legend(n) ?? {} : {},
+                s = oe(t, {
                     expr: "datum"
                 }),
-                a = ie(t, {
+                a = oe(t, {
                     expr: "datum",
                     binSuffix: "end"
                 });
             return {
-                formulaAs: ie(t, {
+                formulaAs: oe(t, {
                     binSuffix: "range",
                     forAs: !0
                 }),
-                formula: Fd(s, a, r.format, r.formatType, i)
+                formula: lg(s, a, r.format, r.formatType, i)
             }
         }
         return {}
     }
 
-    function l8(e, t) {
-        return `${DI(e)}_${t}`
+    function Hz(e, t) {
+        return `${m6(e)}_${t}`
     }
 
-    function _0e(e, t) {
+    function jpe(e, t) {
         return {
             signal: e.getName(`${t}_bins`),
             extentSignal: e.getName(`${t}_extent`)
         }
     }
 
-    function $C(e, t, n) {
-        const i = z1(n, void 0) ?? {},
-            r = l8(i, t);
+    function vC(e, t, n) {
+        const i = yy(n, void 0) ?? {},
+            r = Hz(i, t);
         return e.getName(`${r}_bins`)
     }
 
-    function w0e(e) {
+    function Gpe(e) {
         return "as" in e
     }
 
-    function p3(e, t, n) {
+    function IM(e, t, n) {
         let i, r;
-        w0e(e) ? i = re(e.as) ? [e.as, `${e.as}_end`] : [e.as[0], e.as[1]] : i = [ie(e, {
+        Gpe(e) ? i = le(e.as) ? [e.as, `${e.as}_end`] : [e.as[0], e.as[1]] : i = [oe(e, {
             forAs: !0
-        }), ie(e, {
+        }), oe(e, {
             binSuffix: "end",
             forAs: !0
         })];
         const s = {
-                ...z1(t, void 0)
+                ...yy(t, void 0)
             },
-            a = l8(s, e.field),
+            a = Hz(s, e.field),
             {
                 signal: o,
                 extentSignal: l
-            } = _0e(n, a);
-        if ($1(s.extent)) {
+            } = jpe(n, a);
+        if (ay(s.extent)) {
             const c = s.extent;
-            r = Bz(n, c.param, c), delete s.extent
+            r = Ez(n, c.param, c), delete s.extent
         }
         const u = {
             bin: s,
             field: e.field,
             as: [i],
             ...o ? {
                 signal: o
@@ -46361,97 +39715,97 @@
             } : {}
         };
         return {
             key: a,
             binComponent: u
         }
     }
-    class Ur extends nt {
+    class rs extends ut {
         clone() {
-            return new Ur(null, ke(this.bins))
+            return new rs(null, Fe(this.bins))
         }
         constructor(t, n) {
             super(t), this.bins = n
         }
         static makeFromEncoding(t, n) {
             const i = n.reduceFieldDef((r, s, a) => {
-                if (zn(s) && ot(s.bin)) {
+                if (Jn(s) && yt(s.bin)) {
                     const {
                         key: o,
                         binComponent: l
-                    } = p3(s, s.bin, n);
+                    } = IM(s, s.bin, n);
                     r[o] = {
                         ...l,
                         ...r[o],
-                        ...x0e(n, s, a, n.config)
+                        ...Bpe(n, s, a, n.config)
                     }
                 }
                 return r
             }, {});
-            return et(i) ? null : new Ur(t, i)
+            return ft(i) ? null : new rs(t, i)
         }
         static makeFromTransform(t, n, i) {
             const {
                 key: r,
                 binComponent: s
-            } = p3(n, n.bin, i);
-            return new Ur(t, {
+            } = IM(n, n.bin, i);
+            return new rs(t, {
                 [r]: s
             })
         }
         merge(t, n) {
-            for (const i of H(t.bins)) i in this.bins ? (n(t.bins[i].signal, this.bins[i].signal), this.bins[i].as = Pr([...this.bins[i].as, ...t.bins[i].as], Ne)) : this.bins[i] = t.bins[i];
+            for (const i of K(t.bins)) i in this.bins ? (n(t.bins[i].signal, this.bins[i].signal), this.bins[i].as = Qr([...this.bins[i].as, ...t.bins[i].as], ze)) : this.bins[i] = t.bins[i];
             for (const i of t.children) t.removeChild(i), i.parent = this;
             t.remove()
         }
         producedFields() {
-            return new Set(Qt(this.bins).map(t => t.as).flat(2))
+            return new Set(bn(this.bins).map(t => t.as).flat(2))
         }
         dependentFields() {
-            return new Set(Qt(this.bins).map(t => t.field))
+            return new Set(bn(this.bins).map(t => t.field))
         }
         hash() {
-            return `Bin ${Ne(this.bins)}`
+            return `Bin ${ze(this.bins)}`
         }
         assemble() {
-            return Qt(this.bins).flatMap(t => {
+            return bn(this.bins).flatMap(t => {
                 const n = [],
                     [i, ...r] = t.as,
                     {
                         extent: s,
                         ...a
                     } = t.bin,
                     o = {
                         type: "bin",
-                        field: Pi(t.field),
+                        field: Ji(t.field),
                         as: i,
                         signal: t.signal,
-                        ...$1(s) ? {
+                        ...ay(s) ? {
                             extent: null
                         } : {
                             extent: s
                         },
                         ...t.span ? {
                             span: {
                                 signal: `span(${t.span})`
                             }
                         } : {},
                         ...a
                     };
                 !s && t.extentSignal && (n.push({
                     type: "extent",
-                    field: Pi(t.field),
+                    field: Ji(t.field),
                     signal: t.extentSignal
                 }), o.extent = {
                     signal: t.extentSignal
                 }), n.push(o);
                 for (const l of r)
                     for (let u = 0; u < 2; u++) n.push({
                         type: "formula",
-                        expr: ie({
+                        expr: oe({
                             field: i[u]
                         }, {
                             expr: "datum"
                         }),
                         as: l[u]
                     });
                 return t.formula && n.push({
@@ -46459,40 +39813,40 @@
                     expr: t.formula,
                     as: t.formulaAs
                 }), n
             })
         }
     }
 
-    function S0e(e, t, n, i) {
+    function Upe(e, t, n, i) {
         var s;
-        const r = Et(i) ? i.encoding[us(t)] : void 0;
-        if (zn(n) && Et(i) && k6(n, r, i.markDef, i.config)) e.add(ie(n, {})), e.add(ie(n, {
+        const r = Dt(i) ? i.encoding[Ss(t)] : void 0;
+        if (Jn(n) && Dt(i) && c8(n, r, i.markDef, i.config)) e.add(oe(n, {})), e.add(oe(n, {
             suffix: "end"
-        })), n.bin && Nd(n, t) && e.add(ie(n, {
+        })), n.bin && fg(n, t) && e.add(oe(n, {
             binSuffix: "range"
         }));
-        else if (SI(t)) {
-            const a = wI(t);
+        else if (s6(t)) {
+            const a = r6(t);
             e.add(i.getName(a))
-        } else e.add(ie(n));
-        return Il(n) && bhe((s = n.scale) == null ? void 0 : s.range) && e.add(n.scale.range.field), e
+        } else e.add(oe(n));
+        return su(n) && Lfe((s = n.scale) == null ? void 0 : s.range) && e.add(n.scale.range.field), e
     }
 
-    function E0e(e, t) {
-        for (const n of H(t)) {
+    function Wpe(e, t) {
+        for (const n of K(t)) {
             const i = t[n];
-            for (const r of H(i)) n in e ? e[n][r] = new Set([...e[n][r] ?? [], ...i[r]]) : e[n] = {
+            for (const r of K(i)) n in e ? e[n][r] = new Set([...e[n][r] ?? [], ...i[r]]) : e[n] = {
                 [r]: i[r]
             }
         }
     }
-    class or extends nt {
+    class Er extends ut {
         clone() {
-            return new or(null, new Set(this.dimensions), ke(this.measures))
+            return new Er(null, new Set(this.dimensions), Fe(this.measures))
         }
         constructor(t, n, i) {
             super(t), this.dimensions = n, this.measures = i
         }
         get groupBy() {
             return this.dimensions
         }
@@ -46505,158 +39859,158 @@
                 s = new Set;
             return !i || (n.forEachFieldDef((a, o) => {
                 const {
                     aggregate: l,
                     field: u
                 } = a;
                 if (l)
-                    if (l === "count") r["*"] ?? (r["*"] = {}), r["*"].count = new Set([ie(a, {
+                    if (l === "count") r["*"] ?? (r["*"] = {}), r["*"].count = new Set([oe(a, {
                         forAs: !0
                     })]);
                     else {
-                        if (Bs(l) || oo(l)) {
-                            const c = Bs(l) ? "argmin" : "argmax",
+                        if (na(l) || $o(l)) {
+                            const c = na(l) ? "argmin" : "argmax",
                                 f = l[c];
-                            r[f] ?? (r[f] = {}), r[f][c] = new Set([ie({
+                            r[f] ?? (r[f] = {}), r[f][c] = new Set([oe({
                                 op: c,
                                 field: f
                             }, {
                                 forAs: !0
                             })])
-                        } else r[u] ?? (r[u] = {}), r[u][l] = new Set([ie(a, {
+                        } else r[u] ?? (r[u] = {}), r[u][l] = new Set([oe(a, {
                             forAs: !0
                         })]);
-                        Qs(o) && n.scaleDomain(o) === "unaggregated" && (r[u] ?? (r[u] = {}), r[u].min = new Set([ie({
+                        ha(o) && n.scaleDomain(o) === "unaggregated" && (r[u] ?? (r[u] = {}), r[u].min = new Set([oe({
                             field: u,
                             aggregate: "min"
                         }, {
                             forAs: !0
-                        })]), r[u].max = new Set([ie({
+                        })]), r[u].max = new Set([oe({
                             field: u,
                             aggregate: "max"
                         }, {
                             forAs: !0
                         })]))
                     }
-                else S0e(s, o, a, n)
-            }), s.size + H(r).length === 0) ? null : new or(t, s, r)
+                else Upe(s, o, a, n)
+            }), s.size + K(r).length === 0) ? null : new Er(t, s, r)
         }
         static makeFromTransform(t, n) {
             const i = new Set,
                 r = {};
             for (const s of n.aggregate) {
                 const {
                     op: a,
                     field: o,
                     as: l
                 } = s;
-                a && (a === "count" ? (r["*"] ?? (r["*"] = {}), r["*"].count = new Set([l || ie(s, {
+                a && (a === "count" ? (r["*"] ?? (r["*"] = {}), r["*"].count = new Set([l || oe(s, {
                     forAs: !0
-                })])) : (r[o] ?? (r[o] = {}), r[o][a] = new Set([l || ie(s, {
+                })])) : (r[o] ?? (r[o] = {}), r[o][a] = new Set([l || oe(s, {
                     forAs: !0
                 })])))
             }
             for (const s of n.groupby ?? []) i.add(s);
-            return i.size + H(r).length === 0 ? null : new or(t, i, r)
+            return i.size + K(r).length === 0 ? null : new Er(t, i, r)
         }
         merge(t) {
-            return gI(this.dimensions, t.dimensions) ? (E0e(this.measures, t.measures), !0) : (qfe("different dimensions, cannot merge"), !1)
+            return KI(this.dimensions, t.dimensions) ? (Wpe(this.measures, t.measures), !0) : (lfe("different dimensions, cannot merge"), !1)
         }
         addDimensions(t) {
             t.forEach(this.dimensions.add, this.dimensions)
         }
         dependentFields() {
-            return new Set([...this.dimensions, ...H(this.measures)])
+            return new Set([...this.dimensions, ...K(this.measures)])
         }
         producedFields() {
             const t = new Set;
-            for (const n of H(this.measures))
-                for (const i of H(this.measures[n])) {
+            for (const n of K(this.measures))
+                for (const i of K(this.measures[n])) {
                     const r = this.measures[n][i];
                     r.size === 0 ? t.add(`${i}_${n}`) : r.forEach(t.add, t)
                 }
             return t
         }
         hash() {
-            return `Aggregate ${Ne({dimensions:this.dimensions,measures:this.measures})}`
+            return `Aggregate ${ze({dimensions:this.dimensions,measures:this.measures})}`
         }
         assemble() {
             const t = [],
                 n = [],
                 i = [];
-            for (const s of H(this.measures))
-                for (const a of H(this.measures[s]))
-                    for (const o of this.measures[s][a]) i.push(o), t.push(a), n.push(s === "*" ? null : Pi(s));
+            for (const s of K(this.measures))
+                for (const a of K(this.measures[s]))
+                    for (const o of this.measures[s][a]) i.push(o), t.push(a), n.push(s === "*" ? null : Ji(s));
             return {
                 type: "aggregate",
-                groupby: [...this.dimensions].map(Pi),
+                groupby: [...this.dimensions].map(Ji),
                 ops: t,
                 fields: n,
                 as: i
             }
         }
     }
-    class Pc extends nt {
+    class lf extends ut {
         constructor(t, n, i, r) {
             super(t), this.model = n, this.name = i, this.data = r;
-            for (const s of Ti) {
+            for (const s of Ui) {
                 const a = n.facet[s];
                 if (a) {
                     const {
                         bin: o,
                         sort: l
                     } = a;
                     this[s] = {
                         name: n.getName(`${s}_domain`),
-                        fields: [ie(a), ...ot(o) ? [ie(a, {
+                        fields: [oe(a), ...yt(o) ? [oe(a, {
                             binSuffix: "end"
                         })] : []],
-                        ...Br(l) ? {
+                        ...ns(l) ? {
                             sortField: l
-                        } : W(l) ? {
-                            sortIndexField: uc(a, s)
+                        } : H(l) ? {
+                            sortIndexField: Pc(a, s)
                         } : {}
                     }
                 }
             }
             this.childModel = n.child
         }
         hash() {
             let t = "Facet";
-            for (const n of Ti) this[n] && (t += ` ${n.charAt(0)}:${Ne(this[n])}`);
+            for (const n of Ui) this[n] && (t += ` ${n.charAt(0)}:${ze(this[n])}`);
             return t
         }
         get fields() {
             var n;
             const t = [];
-            for (const i of Ti)(n = this[i]) != null && n.fields && t.push(...this[i].fields);
+            for (const i of Ui)(n = this[i]) != null && n.fields && t.push(...this[i].fields);
             return t
         }
         dependentFields() {
             const t = new Set(this.fields);
-            for (const n of Ti) this[n] && (this[n].sortField && t.add(this[n].sortField.field), this[n].sortIndexField && t.add(this[n].sortIndexField));
+            for (const n of Ui) this[n] && (this[n].sortField && t.add(this[n].sortField.field), this[n].sortIndexField && t.add(this[n].sortIndexField));
             return t
         }
         producedFields() {
             return new Set
         }
         getSource() {
             return this.name
         }
         getChildIndependentFieldsWithStep() {
             const t = {};
-            for (const n of cs) {
+            for (const n of Es) {
                 const i = this.childModel.component.scales[n];
                 if (i && !i.merged) {
                     const r = i.get("type"),
                         s = i.get("range");
-                    if (qt(r) && lo(s)) {
-                        const a = K1(this.childModel, n),
-                            o = FC(a);
-                        o ? t[n] = o : X(RE(n))
+                    if (fn(r) && To(s)) {
+                        const a = $y(this.childModel, n),
+                            o = wC(a);
+                        o ? t[n] = o : J(wk(n))
                     }
                 }
             }
             return t
         }
         assembleRowColumnHeaderData(t, n, i) {
             const r = {
@@ -46670,18 +40024,18 @@
             r && i && i[r] && (n ? (s.push(`distinct_${i[r]}`), a.push("max")) : (s.push(i[r]), a.push("distinct")), o.push(`distinct_${i[r]}`));
             const {
                 sortField: l,
                 sortIndexField: u
             } = this[t];
             if (l) {
                 const {
-                    op: c = N1,
+                    op: c = dy,
                     field: f
                 } = l;
-                s.push(f), a.push(c), o.push(ie(l, {
+                s.push(f), a.push(c), o.push(oe(l, {
                     forAs: !0
                 }))
             } else u && (s.push(u), a.push("max"), o.push(u));
             return {
                 name: this[t].name,
                 source: n ?? this.data,
                 transform: [{
@@ -46698,16 +40052,16 @@
         assembleFacetHeaderData(t) {
             var l;
             const {
                 columns: n
             } = this.model.layout, {
                 layoutHeaders: i
             } = this.model.component, r = [], s = {};
-            for (const u of EC) {
-                for (const c of CC) {
+            for (const u of gC) {
+                for (const c of pC) {
                     const f = (i[u] && i[u][c]) ?? [];
                     for (const h of f)
                         if (((l = h.axes) == null ? void 0 : l.length) > 0) {
                             s[u] = !0;
                             break
                         }
                 }
@@ -46756,252 +40110,252 @@
                         type: "aggregate",
                         groupby: this.fields,
                         fields: o,
                         ops: l
                     }]
                 })
             }
-            for (const o of [Rs, Fs]) this[o] && t.push(this.assembleRowColumnHeaderData(o, n, i));
+            for (const o of [Ks, Vs]) this[o] && t.push(this.assembleRowColumnHeaderData(o, n, i));
             if (a) {
                 const o = this.assembleFacetHeaderData(i);
                 o && t.push(...o)
             }
             return t
         }
     }
 
-    function m3(e) {
+    function zM(e) {
         return e.startsWith("'") && e.endsWith("'") || e.startsWith('"') && e.endsWith('"') ? e.slice(1, -1) : e
     }
 
-    function C0e(e, t) {
-        const n = wE(e);
+    function qpe(e, t) {
+        const n = fk(e);
         if (t === "number") return `toNumber(${n})`;
         if (t === "boolean") return `toBoolean(${n})`;
         if (t === "string") return `toString(${n})`;
         if (t === "date") return `toDate(${n})`;
         if (t === "flatten") return n;
         if (t.startsWith("date:")) {
-            const i = m3(t.slice(5, t.length));
+            const i = zM(t.slice(5, t.length));
             return `timeParse(${n},'${i}')`
         } else if (t.startsWith("utc:")) {
-            const i = m3(t.slice(4, t.length));
+            const i = zM(t.slice(4, t.length));
             return `utcParse(${n},'${i}')`
-        } else return X(Qce(t)), null
+        } else return J(pce(t)), null
     }
 
-    function k0e(e) {
+    function Hpe(e) {
         const t = {};
-        return gp(e.filter, n => {
-            if (n6(n)) {
+        return Wp(e.filter, n => {
+            if (j6(n)) {
                 let i = null;
-                LE(n) ? i = di(n.equal) : zE(n) ? i = di(n.lte) : IE(n) ? i = di(n.lt) : BE(n) ? i = di(n.gt) : jE(n) ? i = di(n.gte) : UE(n) ? i = n.range[0] : GE(n) && (i = (n.oneOf ?? n.in)[0]), i && (Ll(i) ? t[n.field] = "date" : Ze(i) ? t[n.field] = "number" : re(i) && (t[n.field] = "string")), n.timeUnit && (t[n.field] = "date")
+                Ck(n) ? i = Ci(n.equal) : $k(n) ? i = Ci(n.lte) : Ak(n) ? i = Ci(n.lt) : Tk(n) ? i = Ci(n.gt) : Mk(n) ? i = Ci(n.gte) : Ok(n) ? i = n.range[0] : Fk(n) && (i = (n.oneOf ?? n.in)[0]), i && (iu(i) ? t[n.field] = "date" : lt(i) ? t[n.field] = "number" : le(i) && (t[n.field] = "string")), n.timeUnit && (t[n.field] = "date")
             }
         }), t
     }
 
-    function A0e(e) {
+    function Ype(e) {
         const t = {};
 
         function n(i) {
-            ac(i) ? t[i.field] = "date" : i.type === "quantitative" && Mce(i.aggregate) ? t[i.field] = "number" : Zu(i.field) > 1 ? i.field in t || (t[i.field] = "flatten") : Il(i) && Br(i.sort) && Zu(i.sort.field) > 1 && (i.sort.field in t || (t[i.sort.field] = "flatten"))
+            Fc(i) ? t[i.field] = "date" : i.type === "quantitative" && Yue(i.aggregate) ? t[i.field] = "number" : kc(i.field) > 1 ? i.field in t || (t[i.field] = "flatten") : su(i) && ns(i.sort) && kc(i.sort.field) > 1 && (i.sort.field in t || (t[i.sort.field] = "flatten"))
         }
-        if ((Et(e) || lr(e)) && e.forEachFieldDef((i, r) => {
-                if (zn(i)) n(i);
+        if ((Dt(e) || kr(e)) && e.forEachFieldDef((i, r) => {
+                if (Jn(i)) n(i);
                 else {
-                    const s = Nl(r),
+                    const s = tu(r),
                         a = e.fieldDef(s);
                     n({
                         ...i,
                         type: a.type
                     })
                 }
-            }), Et(e)) {
+            }), Dt(e)) {
             const {
                 mark: i,
                 markDef: r,
                 encoding: s
             } = e;
-            if (uo(i) && !e.encoding.order) {
+            if (Mo(i) && !e.encoding.order) {
                 const a = r.orient === "horizontal" ? "y" : "x",
                     o = s[a];
-                K(o) && o.type === "quantitative" && !(o.field in t) && (t[o.field] = "number")
+                Z(o) && o.type === "quantitative" && !(o.field in t) && (t[o.field] = "number")
             }
         }
         return t
     }
 
-    function $0e(e) {
+    function Xpe(e) {
         const t = {};
-        if (Et(e) && e.component.selection)
-            for (const n of H(e.component.selection)) {
+        if (Dt(e) && e.component.selection)
+            for (const n of K(e.component.selection)) {
                 const i = e.component.selection[n];
-                for (const r of i.project.items) !r.channel && Zu(r.field) > 1 && (t[r.field] = "flatten")
+                for (const r of i.project.items) !r.channel && kc(r.field) > 1 && (t[r.field] = "flatten")
             }
         return t
     }
-    class gn extends nt {
+    class On extends ut {
         clone() {
-            return new gn(null, ke(this._parse))
+            return new On(null, Fe(this._parse))
         }
         constructor(t, n) {
             super(t), this._parse = n
         }
         hash() {
-            return `Parse ${Ne(this._parse)}`
+            return `Parse ${ze(this._parse)}`
         }
         static makeExplicit(t, n, i) {
             var a;
             let r = {};
             const s = n.data;
-            return !$a(s) && ((a = s == null ? void 0 : s.format) != null && a.parse) && (r = s.format.parse), this.makeWithAncestors(t, r, {}, i)
+            return !Xa(s) && ((a = s == null ? void 0 : s.format) != null && a.parse) && (r = s.format.parse), this.makeWithAncestors(t, r, {}, i)
         }
         static makeWithAncestors(t, n, i, r) {
-            for (const o of H(i)) {
+            for (const o of K(i)) {
                 const l = r.getWithExplicit(o);
-                l.value !== void 0 && (l.explicit || l.value === i[o] || l.value === "derived" || i[o] === "flatten" ? delete i[o] : X(M5(o, i[o], l.value)))
+                l.value !== void 0 && (l.explicit || l.value === i[o] || l.value === "derived" || i[o] === "flatten" ? delete i[o] : J(J5(o, i[o], l.value)))
             }
-            for (const o of H(n)) {
+            for (const o of K(n)) {
                 const l = r.get(o);
-                l !== void 0 && (l === n[o] ? delete n[o] : X(M5(o, n[o], l)))
+                l !== void 0 && (l === n[o] ? delete n[o] : J(J5(o, n[o], l)))
             }
-            const s = new ea(n, i);
+            const s = new ga(n, i);
             r.copyAll(s);
             const a = {};
-            for (const o of H(s.combine())) {
+            for (const o of K(s.combine())) {
                 const l = s.get(o);
                 l !== null && (a[o] = l)
             }
-            return H(a).length === 0 || r.parseNothing ? null : new gn(t, a)
+            return K(a).length === 0 || r.parseNothing ? null : new On(t, a)
         }
         get parse() {
             return this._parse
         }
         merge(t) {
             this._parse = {
                 ...this._parse,
                 ...t.parse
             }, t.remove()
         }
         assembleFormatParse() {
             const t = {};
-            for (const n of H(this._parse)) {
+            for (const n of K(this._parse)) {
                 const i = this._parse[n];
-                Zu(n) === 1 && (t[n] = i)
+                kc(n) === 1 && (t[n] = i)
             }
             return t
         }
         producedFields() {
-            return new Set(H(this._parse))
+            return new Set(K(this._parse))
         }
         dependentFields() {
-            return new Set(H(this._parse))
+            return new Set(K(this._parse))
         }
         assembleTransforms(t = !1) {
-            return H(this._parse).filter(n => t ? Zu(n) > 1 : !0).map(n => {
-                const i = C0e(n, this._parse[n]);
+            return K(this._parse).filter(n => t ? kc(n) > 1 : !0).map(n => {
+                const i = qpe(n, this._parse[n]);
                 return i ? {
                     type: "formula",
                     expr: i,
-                    as: SE(n)
+                    as: hk(n)
                 } : null
             }).filter(n => n !== null)
         }
     }
-    class qa extends nt {
+    class go extends ut {
         clone() {
-            return new qa(null)
+            return new go(null)
         }
         constructor(t) {
             super(t)
         }
         dependentFields() {
             return new Set
         }
         producedFields() {
-            return new Set([pr])
+            return new Set([Mr])
         }
         hash() {
             return "Identifier"
         }
         assemble() {
             return {
                 type: "identifier",
-                as: pr
+                as: Mr
             }
         }
     }
-    class Id extends nt {
+    class gg extends ut {
         clone() {
-            return new Id(null, this.params)
+            return new gg(null, this.params)
         }
         constructor(t, n) {
             super(t), this.params = n
         }
         dependentFields() {
             return new Set
         }
         producedFields() {}
         hash() {
-            return `Graticule ${Ne(this.params)}`
+            return `Graticule ${ze(this.params)}`
         }
         assemble() {
             return {
                 type: "graticule",
                 ...this.params === !0 ? {} : this.params
             }
         }
     }
-    class zd extends nt {
+    class pg extends ut {
         clone() {
-            return new zd(null, this.params)
+            return new pg(null, this.params)
         }
         constructor(t, n) {
             super(t), this.params = n
         }
         dependentFields() {
             return new Set
         }
         producedFields() {
             return new Set([this.params.as ?? "data"])
         }
         hash() {
-            return `Hash ${Ne(this.params)}`
+            return `Hash ${ze(this.params)}`
         }
         assemble() {
             return {
                 type: "sequence",
                 ...this.params
             }
         }
     }
-    class yl extends nt {
+    class jl extends ut {
         constructor(t) {
             super(null), t ?? (t = {
                 name: "source"
             });
             let n;
-            if ($a(t) || (n = t.format ? {
-                    ...Jn(t.format, ["parse"])
-                } : {}), Bh(t)) this._data = {
+            if (Xa(t) || (n = t.format ? {
+                    ...li(t.format, ["parse"])
+                } : {}), pd(t)) this._data = {
                 values: t.values
             };
-            else if (oc(t)) {
+            else if (Rc(t)) {
                 if (this._data = {
                         url: t.url
                     }, !n.type) {
                     let i = /(?:\.([^.]+))?$/.exec(t.url)[1];
-                    Fe(["json", "csv", "tsv", "dsv", "topojson"], i) || (i = "json"), n.type = i
+                    Be(["json", "csv", "tsv", "dsv", "topojson"], i) || (i = "json"), n.type = i
                 }
-            } else yz(t) ? this._data = {
+            } else tz(t) ? this._data = {
                 values: [{
                     type: "Sphere"
                 }]
-            } : (pz(t) || $a(t)) && (this._data = {});
-            this._generator = $a(t), t.name && (this._name = t.name), n && !et(n) && (this._data.format = n)
+            } : (Z8(t) || Xa(t)) && (this._data = {});
+            this._generator = Xa(t), t.name && (this._name = t.name), n && !ft(n) && (this._data.format = n)
         }
         dependentFields() {
             return new Set
         }
         producedFields() {}
         get data() {
             return this._data
@@ -47031,230 +40385,230 @@
             return {
                 name: this._name,
                 ...this._data,
                 transform: []
             }
         }
     }
-    var y3 = globalThis && globalThis.__classPrivateFieldSet || function(e, t, n, i, r) {
+    var BM = globalThis && globalThis.__classPrivateFieldSet || function(e, t, n, i, r) {
             if (i === "m") throw new TypeError("Private method is not writable");
             if (i === "a" && !r) throw new TypeError("Private accessor was defined without a setter");
             if (typeof t == "function" ? e !== t || !r : !t.has(e)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
             return i === "a" ? r.call(e, n) : r ? r.value = n : t.set(e, n), n
         },
-        T0e = globalThis && globalThis.__classPrivateFieldGet || function(e, t, n, i) {
+        Vpe = globalThis && globalThis.__classPrivateFieldGet || function(e, t, n, i) {
             if (n === "a" && !i) throw new TypeError("Private accessor was defined without a getter");
             if (typeof t == "function" ? e !== t || !i : !t.has(e)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
             return n === "m" ? i : n === "a" ? i.call(e) : i ? i.value : t.get(e)
         },
-        Wf;
+        ph;
 
-    function TC(e) {
-        return e instanceof yl || e instanceof Id || e instanceof zd
+    function bC(e) {
+        return e instanceof jl || e instanceof gg || e instanceof pg
     }
-    class MC {
+    class xC {
         constructor() {
-            Wf.set(this, void 0), y3(this, Wf, !1, "f")
+            ph.set(this, void 0), BM(this, ph, !1, "f")
         }
         setModified() {
-            y3(this, Wf, !0, "f")
+            BM(this, ph, !0, "f")
         }
         get modifiedFlag() {
-            return T0e(this, Wf, "f")
+            return Vpe(this, ph, "f")
         }
     }
-    Wf = new WeakMap;
-    class zl extends MC {
+    ph = new WeakMap;
+    class au extends xC {
         getNodeDepths(t, n, i) {
             i.set(t, n);
             for (const r of t.children) this.getNodeDepths(r, n + 1, i);
             return i
         }
         optimize(t) {
             const i = [...this.getNodeDepths(t, 0, new Map).entries()].sort((r, s) => s[1] - r[1]);
             for (const r of i) this.run(r[0]);
             return this.modifiedFlag
         }
     }
-    class OC extends MC {
+    class _C extends xC {
         optimize(t) {
             this.run(t);
             for (const n of t.children) this.optimize(n);
             return this.modifiedFlag
         }
     }
-    class M0e extends OC {
+    class Kpe extends _C {
         mergeNodes(t, n) {
             const i = n.shift();
             for (const r of n) t.removeChild(r), r.parent = i, r.remove()
         }
         run(t) {
             const n = t.children.map(r => r.hash()),
                 i = {};
             for (let r = 0; r < n.length; r++) i[n[r]] === void 0 ? i[n[r]] = [t.children[r]] : i[n[r]].push(t.children[r]);
-            for (const r of H(i)) i[r].length > 1 && (this.setModified(), this.mergeNodes(t, i[r]))
+            for (const r of K(i)) i[r].length > 1 && (this.setModified(), this.mergeNodes(t, i[r]))
         }
     }
-    class O0e extends OC {
+    class Jpe extends _C {
         constructor(t) {
-            super(), this.requiresSelectionId = t && SC(t)
+            super(), this.requiresSelectionId = t && dC(t)
         }
         run(t) {
-            t instanceof qa && (this.requiresSelectionId && (TC(t.parent) || t.parent instanceof or || t.parent instanceof gn) || (this.setModified(), t.remove()))
+            t instanceof go && (this.requiresSelectionId && (bC(t.parent) || t.parent instanceof Er || t.parent instanceof On) || (this.setModified(), t.remove()))
         }
     }
-    class F0e extends MC {
+    class Qpe extends xC {
         optimize(t) {
             return this.run(t, new Set), this.modifiedFlag
         }
         run(t, n) {
             let i = new Set;
-            t instanceof jr && (i = t.producedFields(), xE(i, n) && (this.setModified(), t.removeFormulas(n), t.producedFields.length === 0 && t.remove()));
+            t instanceof is && (i = t.producedFields(), uk(i, n) && (this.setModified(), t.removeFormulas(n), t.producedFields.length === 0 && t.remove()));
             for (const r of t.children) this.run(r, new Set([...n, ...i]))
         }
     }
-    class R0e extends OC {
+    class Zpe extends _C {
         constructor() {
             super()
         }
         run(t) {
-            t instanceof Dn && !t.isRequired() && (this.setModified(), t.remove())
+            t instanceof Xn && !t.isRequired() && (this.setModified(), t.remove())
         }
     }
-    class D0e extends zl {
+    class eme extends au {
         run(t) {
-            if (!TC(t) && !(t.numChildren() > 1)) {
+            if (!bC(t) && !(t.numChildren() > 1)) {
                 for (const n of t.children)
-                    if (n instanceof gn)
-                        if (t instanceof gn) this.setModified(), t.merge(n);
+                    if (n instanceof On)
+                        if (t instanceof On) this.setModified(), t.merge(n);
                         else {
-                            if (_E(t.producedFields(), n.dependentFields())) continue;
+                            if (ck(t.producedFields(), n.dependentFields())) continue;
                             this.setModified(), n.swapWithParent()
                         }
             }
         }
     }
-    class N0e extends zl {
+    class tme extends au {
         run(t) {
             const n = [...t.children],
-                i = t.children.filter(r => r instanceof gn);
+                i = t.children.filter(r => r instanceof On);
             if (t.numChildren() > 1 && i.length >= 1) {
                 const r = {},
                     s = new Set;
                 for (const a of i) {
                     const o = a.parse;
-                    for (const l of H(o)) l in r ? r[l] !== o[l] && s.add(l) : r[l] = o[l]
+                    for (const l of K(o)) l in r ? r[l] !== o[l] && s.add(l) : r[l] = o[l]
                 }
                 for (const a of s) delete r[a];
-                if (!et(r)) {
+                if (!ft(r)) {
                     this.setModified();
-                    const a = new gn(t, r);
+                    const a = new On(t, r);
                     for (const o of n) {
-                        if (o instanceof gn)
-                            for (const l of H(r)) delete o.parse[l];
-                        t.removeChild(o), o.parent = a, o instanceof gn && H(o.parse).length === 0 && o.remove()
+                        if (o instanceof On)
+                            for (const l of K(r)) delete o.parse[l];
+                        t.removeChild(o), o.parent = a, o instanceof On && K(o.parse).length === 0 && o.remove()
                     }
                 }
             }
         }
     }
-    class P0e extends zl {
+    class nme extends au {
         run(t) {
-            t instanceof Dn || t.numChildren() > 0 || t instanceof Pc || t instanceof yl || (this.setModified(), t.remove())
+            t instanceof Xn || t.numChildren() > 0 || t instanceof lf || t instanceof jl || (this.setModified(), t.remove())
         }
     }
-    class L0e extends zl {
+    class ime extends au {
         run(t) {
-            const n = t.children.filter(r => r instanceof jr),
+            const n = t.children.filter(r => r instanceof is),
                 i = n.pop();
             for (const r of n) this.setModified(), i.merge(r)
         }
     }
-    class I0e extends zl {
+    class rme extends au {
         run(t) {
-            const n = t.children.filter(r => r instanceof or),
+            const n = t.children.filter(r => r instanceof Er),
                 i = {};
             for (const r of n) {
-                const s = Ne(r.groupBy);
+                const s = ze(r.groupBy);
                 s in i || (i[s] = []), i[s].push(r)
             }
-            for (const r of H(i)) {
+            for (const r of K(i)) {
                 const s = i[r];
                 if (s.length > 1) {
                     const a = s.pop();
                     for (const o of s) a.merge(o) && (t.removeChild(o), o.parent = a, o.remove(), this.setModified())
                 }
             }
         }
     }
-    class z0e extends zl {
+    class sme extends au {
         constructor(t) {
             super(), this.model = t
         }
         run(t) {
-            const n = !(TC(t) || t instanceof Nc || t instanceof gn || t instanceof qa),
+            const n = !(bC(t) || t instanceof of || t instanceof On || t instanceof go),
                 i = [],
                 r = [];
-            for (const s of t.children) s instanceof Ur && (n && !_E(t.producedFields(), s.dependentFields()) ? i.push(s) : r.push(s));
+            for (const s of t.children) s instanceof rs && (n && !ck(t.producedFields(), s.dependentFields()) ? i.push(s) : r.push(s));
             if (i.length > 0) {
                 const s = i.pop();
                 for (const a of i) s.merge(a, this.model.renameSignal.bind(this.model));
-                this.setModified(), t instanceof Ur ? t.merge(s, this.model.renameSignal.bind(this.model)) : s.swapWithParent()
+                this.setModified(), t instanceof rs ? t.merge(s, this.model.renameSignal.bind(this.model)) : s.swapWithParent()
             }
             if (r.length > 1) {
                 const s = r.pop();
                 for (const a of r) s.merge(a, this.model.renameSignal.bind(this.model));
                 this.setModified()
             }
         }
     }
-    class B0e extends zl {
+    class ame extends au {
         run(t) {
             const n = [...t.children];
-            if (!ol(n, a => a instanceof Dn) || t.numChildren() <= 1) return;
+            if (!Fl(n, a => a instanceof Xn) || t.numChildren() <= 1) return;
             const r = [];
             let s;
             for (const a of n)
-                if (a instanceof Dn) {
+                if (a instanceof Xn) {
                     let o = a;
                     for (; o.numChildren() === 1;) {
                         const [l] = o.children;
-                        if (l instanceof Dn) o = l;
+                        if (l instanceof Xn) o = l;
                         else break
                     }
                     r.push(...o.children), s ? (t.removeChild(a), a.parent = s.parent, s.parent.removeChild(s), s.parent = o, this.setModified()) : s = o
                 } else r.push(a);
             if (r.length) {
                 this.setModified();
                 for (const a of r) a.parent.removeChild(a), a.parent = s
             }
         }
     }
-    class Bl extends nt {
+    class ou extends ut {
         clone() {
-            return new Bl(null, ke(this.transform))
+            return new ou(null, Fe(this.transform))
         }
         constructor(t, n) {
             super(t), this.transform = n
         }
         addDimensions(t) {
-            this.transform.groupby = Pr(this.transform.groupby.concat(t), n => n)
+            this.transform.groupby = Qr(this.transform.groupby.concat(t), n => n)
         }
         dependentFields() {
             const t = new Set;
             return this.transform.groupby && this.transform.groupby.forEach(t.add, t), this.transform.joinaggregate.map(n => n.field).filter(n => n !== void 0).forEach(t.add, t), t
         }
         producedFields() {
             return new Set(this.transform.joinaggregate.map(this.getDefaultName))
         }
         getDefaultName(t) {
-            return t.as ?? ie(t)
+            return t.as ?? oe(t)
         }
         hash() {
-            return `JoinAggregateTransform ${Ne(this.transform)}`
+            return `JoinAggregateTransform ${ze(this.transform)}`
         }
         assemble() {
             const t = [],
                 n = [],
                 i = [];
             for (const s of this.transform.joinaggregate) n.push(s.op), i.push(this.getDefaultName(s)), t.push(s.field === void 0 ? null : s.field);
             const r = this.transform.groupby;
@@ -47266,47 +40620,47 @@
                 ...r !== void 0 ? {
                     groupby: r
                 } : {}
             }
         }
     }
 
-    function j0e(e) {
+    function ome(e) {
         return e.stack.stackBy.reduce((t, n) => {
             const i = n.fieldDef,
-                r = ie(i);
+                r = oe(i);
             return r && t.push(r), t
         }, [])
     }
 
-    function U0e(e) {
-        return W(e) && e.every(t => re(t)) && e.length > 1
+    function lme(e) {
+        return H(e) && e.every(t => le(t)) && e.length > 1
     }
-    class Ps extends nt {
+    class Qs extends ut {
         clone() {
-            return new Ps(null, ke(this._stack))
+            return new Qs(null, Fe(this._stack))
         }
         constructor(t, n) {
             super(t), this._stack = n
         }
         static makeFromTransform(t, n) {
             const {
                 stack: i,
                 groupby: r,
                 as: s,
                 offset: a = "zero"
             } = n, o = [], l = [];
             if (n.sort !== void 0)
-                for (const f of n.sort) o.push(f.field), l.push(Ct(f.order, "ascending"));
+                for (const f of n.sort) o.push(f.field), l.push(Gt(f.order, "ascending"));
             const u = {
                 field: o,
                 order: l
             };
             let c;
-            return U0e(s) ? c = s : re(s) ? c = [s, `${s}_end`] : c = [`${n.stack}_start`, `${n.stack}_end`], new Ps(t, {
+            return lme(s) ? c = s : le(s) ? c = [s, `${s}_end`] : c = [`${n.stack}_start`, `${n.stack}_end`], new Qs(t, {
                 dimensionFieldDefs: [],
                 stackField: i,
                 groupby: r,
                 offset: a,
                 sort: u,
                 facetby: [],
                 as: c
@@ -47321,26 +40675,26 @@
             const {
                 groupbyChannels: s,
                 fieldChannel: a,
                 offset: o,
                 impute: l
             } = i, u = s.map(d => {
                 const g = r[d];
-                return Kr(g)
-            }).filter(d => !!d), c = j0e(n), f = n.encoding.order;
+                return hs(g)
+            }).filter(d => !!d), c = ome(n), f = n.encoding.order;
             let h;
-            if (W(f) || K(f)) h = zI(f);
+            if (H(f) || Z(f)) h = _6(f);
             else {
-                const d = A6(f) ? f.sort : a === "y" ? "descending" : "ascending";
+                const d = f8(f) ? f.sort : a === "y" ? "descending" : "ascending";
                 h = c.reduce((g, p) => (g.field.push(p), g.order.push(d), g), {
                     field: [],
                     order: []
                 })
             }
-            return new Ps(t, {
+            return new Qs(t, {
                 dimensionFieldDefs: u,
                 stackField: n.vgField(a),
                 facetby: [],
                 stackby: c,
                 sort: h,
                 offset: o,
                 impute: l,
@@ -47363,27 +40717,27 @@
             const t = new Set;
             return t.add(this._stack.stackField), this.getGroupbyFields().forEach(t.add, t), this._stack.facetby.forEach(t.add, t), this._stack.sort.field.forEach(t.add, t), t
         }
         producedFields() {
             return new Set(this._stack.as)
         }
         hash() {
-            return `Stack ${Ne(this._stack)}`
+            return `Stack ${ze(this._stack)}`
         }
         getGroupbyFields() {
             const {
                 dimensionFieldDefs: t,
                 impute: n,
                 groupby: i
             } = this._stack;
-            return t.length > 0 ? t.map(r => r.bin ? n ? [ie(r, {
+            return t.length > 0 ? t.map(r => r.bin ? n ? [oe(r, {
                 binSuffix: "mid"
-            })] : [ie(r, {}), ie(r, {
+            })] : [oe(r, {}), oe(r, {
                 binSuffix: "end"
-            })] : [ie(r)]).flat() : i ?? []
+            })] : [oe(r)]).flat() : i ?? []
         }
         assemble() {
             const t = [],
                 {
                     facetby: n,
                     dimensionFieldDefs: i,
                     stackField: r,
@@ -47396,35 +40750,35 @@
             if (l)
                 for (const c of i) {
                     const {
                         bandPosition: f = .5,
                         bin: h
                     } = c;
                     if (h) {
-                        const d = ie(c, {
+                        const d = oe(c, {
                                 expr: "datum"
                             }),
-                            g = ie(c, {
+                            g = oe(c, {
                                 expr: "datum",
                                 binSuffix: "end"
                             });
                         t.push({
                             type: "formula",
                             expr: `${f}*${d}+${1-f}*${g}`,
-                            as: ie(c, {
+                            as: oe(c, {
                                 binSuffix: "mid",
                                 forAs: !0
                             })
                         })
                     }
                     t.push({
                         type: "impute",
                         field: r,
                         groupby: [...s, ...n],
-                        key: ie(c, {
+                        key: oe(c, {
                             binSuffix: "mid"
                         }),
                         method: "value",
                         value: 0
                     })
                 }
             return t.push({
@@ -47433,46 +40787,46 @@
                 field: r,
                 sort: a,
                 as: u,
                 offset: o
             }), t
         }
     }
-    class Lc extends nt {
+    class uf extends ut {
         clone() {
-            return new Lc(null, ke(this.transform))
+            return new uf(null, Fe(this.transform))
         }
         constructor(t, n) {
             super(t), this.transform = n
         }
         addDimensions(t) {
-            this.transform.groupby = Pr(this.transform.groupby.concat(t), n => n)
+            this.transform.groupby = Qr(this.transform.groupby.concat(t), n => n)
         }
         dependentFields() {
             const t = new Set;
             return (this.transform.groupby ?? []).forEach(t.add, t), (this.transform.sort ?? []).forEach(n => t.add(n.field)), this.transform.window.map(n => n.field).filter(n => n !== void 0).forEach(t.add, t), t
         }
         producedFields() {
             return new Set(this.transform.window.map(this.getDefaultName))
         }
         getDefaultName(t) {
-            return t.as ?? ie(t)
+            return t.as ?? oe(t)
         }
         hash() {
-            return `WindowTransform ${Ne(this.transform)}`
+            return `WindowTransform ${ze(this.transform)}`
         }
         assemble() {
             const t = [],
                 n = [],
                 i = [],
                 r = [];
             for (const f of this.transform.window) n.push(f.op), i.push(this.getDefaultName(f)), r.push(f.param === void 0 ? null : f.param), t.push(f.field === void 0 ? null : f.field);
             const s = this.transform.frame,
                 a = this.transform.groupby;
-            if (s && s[0] === null && s[1] === null && n.every(f => OE(f))) return {
+            if (s && s[0] === null && s[1] === null && n.every(f => xk(f))) return {
                 type: "joinaggregate",
                 as: i,
                 ops: n,
                 fields: t,
                 ...a !== void 0 ? {
                     groupby: a
                 } : {}
@@ -47502,469 +40856,469 @@
                 ...s !== void 0 ? {
                     frame: s
                 } : {}
             }
         }
     }
 
-    function G0e(e) {
+    function ume(e) {
         function t(n) {
-            if (!(n instanceof Pc)) {
+            if (!(n instanceof lf)) {
                 const i = n.clone();
-                if (i instanceof Dn) {
-                    const r = cx + i.getSource();
+                if (i instanceof Xn) {
+                    const r = jx + i.getSource();
                     i.setSource(r), e.model.component.data.outputNodes[r] = i
-                } else(i instanceof or || i instanceof Ps || i instanceof Lc || i instanceof Bl) && i.addDimensions(e.fields);
+                } else(i instanceof Er || i instanceof Qs || i instanceof uf || i instanceof ou) && i.addDimensions(e.fields);
                 for (const r of n.children.flatMap(t)) r.parent = i;
                 return [i]
             }
             return n.children.flatMap(t)
         }
         return t
     }
 
-    function ux(e) {
-        if (e instanceof Pc)
-            if (e.numChildren() === 1 && !(e.children[0] instanceof Dn)) {
+    function Bx(e) {
+        if (e instanceof lf)
+            if (e.numChildren() === 1 && !(e.children[0] instanceof Xn)) {
                 const t = e.children[0];
-                (t instanceof or || t instanceof Ps || t instanceof Lc || t instanceof Bl) && t.addDimensions(e.fields), t.swapWithParent(), ux(e)
+                (t instanceof Er || t instanceof Qs || t instanceof uf || t instanceof ou) && t.addDimensions(e.fields), t.swapWithParent(), Bx(e)
             } else {
                 const t = e.model.component.data.main;
-                u8(t);
-                const n = G0e(e),
+                Yz(t);
+                const n = ume(e),
                     i = e.children.map(n).flat();
                 for (const r of i) r.parent = t
             }
-        else e.children.map(ux)
+        else e.children.map(Bx)
     }
 
-    function u8(e) {
-        if (e instanceof Dn && e.type === st.Main && e.numChildren() === 1) {
+    function Yz(e) {
+        if (e instanceof Xn && e.type === pt.Main && e.numChildren() === 1) {
             const t = e.children[0];
-            t instanceof Pc || (t.swapWithParent(), u8(e))
+            t instanceof lf || (t.swapWithParent(), Yz(e))
         }
     }
-    const cx = "scale_",
-        Og = 5;
+    const jx = "scale_",
+        Jg = 5;
 
-    function fx(e) {
+    function Gx(e) {
         for (const t of e) {
             for (const n of t.children)
                 if (n.parent !== t) return !1;
-            if (!fx(t.children)) return !1
+            if (!Gx(t.children)) return !1
         }
         return !0
     }
 
-    function ji(e, t) {
+    function rr(e, t) {
         let n = !1;
         for (const i of t) n = e.optimize(i) || n;
         return n
     }
 
-    function v3(e, t, n) {
+    function jM(e, t, n) {
         let i = e.sources,
             r = !1;
-        return r = ji(new R0e, i) || r, r = ji(new O0e(t), i) || r, i = i.filter(s => s.numChildren() > 0), r = ji(new P0e, i) || r, i = i.filter(s => s.numChildren() > 0), n || (r = ji(new D0e, i) || r, r = ji(new z0e(t), i) || r, r = ji(new F0e, i) || r, r = ji(new N0e, i) || r, r = ji(new I0e, i) || r, r = ji(new L0e, i) || r, r = ji(new M0e, i) || r, r = ji(new B0e, i) || r), e.sources = i, r
+        return r = rr(new Zpe, i) || r, r = rr(new Jpe(t), i) || r, i = i.filter(s => s.numChildren() > 0), r = rr(new nme, i) || r, i = i.filter(s => s.numChildren() > 0), n || (r = rr(new eme, i) || r, r = rr(new sme(t), i) || r, r = rr(new Qpe, i) || r, r = rr(new tme, i) || r, r = rr(new rme, i) || r, r = rr(new ime, i) || r, r = rr(new Kpe, i) || r, r = rr(new ame, i) || r), e.sources = i, r
     }
 
-    function W0e(e, t) {
-        fx(e.sources);
+    function cme(e, t) {
+        Gx(e.sources);
         let n = 0,
             i = 0;
-        for (let r = 0; r < Og && v3(e, t, !0); r++) n++;
-        e.sources.map(ux);
-        for (let r = 0; r < Og && v3(e, t, !1); r++) i++;
-        fx(e.sources), Math.max(n, i) === Og && X(`Maximum optimization runs(${Og}) reached.`)
+        for (let r = 0; r < Jg && jM(e, t, !0); r++) n++;
+        e.sources.map(Bx);
+        for (let r = 0; r < Jg && jM(e, t, !1); r++) i++;
+        Gx(e.sources), Math.max(n, i) === Jg && J(`Maximum optimization runs(${Jg}) reached.`)
     }
-    class Zn {
+    class ci {
         constructor(t) {
             Object.defineProperty(this, "signal", {
                 enumerable: !0,
                 get: t
             })
         }
         static fromName(t, n) {
-            return new Zn(() => t(n))
+            return new ci(() => t(n))
         }
     }
 
-    function c8(e) {
-        Et(e) ? q0e(e) : H0e(e)
+    function Xz(e) {
+        Dt(e) ? fme(e) : hme(e)
     }
 
-    function q0e(e) {
+    function fme(e) {
         const t = e.component.scales;
-        for (const n of H(t)) {
-            const i = X0e(e, n);
-            if (t[n].setWithExplicit("domains", i), K0e(e, n), e.component.data.isFaceted) {
+        for (const n of K(t)) {
+            const i = gme(e, n);
+            if (t[n].setWithExplicit("domains", i), mme(e, n), e.component.data.isFaceted) {
                 let s = e;
-                for (; !lr(s) && s.parent;) s = s.parent;
+                for (; !kr(s) && s.parent;) s = s.parent;
                 if (s.component.resolve.scale[n] === "shared")
-                    for (const o of i.value) $s(o) && (o.data = cx + o.data.replace(cx, ""))
+                    for (const o of i.value) qs(o) && (o.data = jx + o.data.replace(jx, ""))
             }
         }
     }
 
-    function H0e(e) {
-        for (const n of e.children) c8(n);
+    function hme(e) {
+        for (const n of e.children) Xz(n);
         const t = e.component.scales;
-        for (const n of H(t)) {
+        for (const n of K(t)) {
             let i, r = null;
             for (const s of e.children) {
                 const a = s.component.scales[n];
                 if (a) {
-                    i === void 0 ? i = a.getWithExplicit("domains") : i = Ua(i, a.getWithExplicit("domains"), "domains", "scale", hx);
+                    i === void 0 ? i = a.getWithExplicit("domains") : i = co(i, a.getWithExplicit("domains"), "domains", "scale", Ux);
                     const o = a.get("selectionExtent");
-                    r && o && r.param !== o.param && X(Xce), r = o
+                    r && o && r.param !== o.param && J(fce), r = o
                 }
             }
             t[n].setWithExplicit("domains", i), r && t[n].set("selectionExtent", r, !0)
         }
     }
 
-    function Y0e(e, t, n, i) {
+    function dme(e, t, n, i) {
         if (e === "unaggregated") {
             const {
                 valid: r,
                 reason: s
-            } = b3(t, n);
+            } = GM(t, n);
             if (!r) {
-                X(s);
+                J(s);
                 return
             }
         } else if (e === void 0 && i.useUnaggregatedDomain) {
             const {
                 valid: r
-            } = b3(t, n);
+            } = GM(t, n);
             if (r) return "unaggregated"
         }
         return e
     }
 
-    function X0e(e, t) {
+    function gme(e, t) {
         const n = e.getScaleComponent(t).get("type"),
             {
                 encoding: i
             } = e,
-            r = Y0e(e.scaleDomain(t), e.typedFieldDef(t), n, e.config.scale);
+            r = dme(e.scaleDomain(t), e.typedFieldDef(t), n, e.config.scale);
         return r !== e.scaleDomain(t) && (e.specifiedScales[t] = {
             ...e.specifiedScales[t],
             domain: r
-        }), t === "x" && Mt(i.x2) ? Mt(i.x) ? Ua(sa(n, r, e, "x"), sa(n, r, e, "x2"), "domain", "scale", hx) : sa(n, r, e, "x2") : t === "y" && Mt(i.y2) ? Mt(i.y) ? Ua(sa(n, r, e, "y"), sa(n, r, e, "y2"), "domain", "scale", hx) : sa(n, r, e, "y2") : sa(n, r, e, t)
+        }), t === "x" && Yt(i.x2) ? Yt(i.x) ? co(Sa(n, r, e, "x"), Sa(n, r, e, "x2"), "domain", "scale", Ux) : Sa(n, r, e, "x2") : t === "y" && Yt(i.y2) ? Yt(i.y) ? co(Sa(n, r, e, "y"), Sa(n, r, e, "y2"), "domain", "scale", Ux) : Sa(n, r, e, "y2") : Sa(n, r, e, t)
     }
 
-    function V0e(e, t, n) {
+    function pme(e, t, n) {
         return e.map(i => ({
-            signal: `{data: ${B1(i,{timeUnit:n,type:t})}}`
+            signal: `{data: ${vy(i,{timeUnit:n,type:t})}}`
         }))
     }
 
-    function Fv(e, t, n) {
+    function lb(e, t, n) {
         var r;
-        const i = (r = en(n)) == null ? void 0 : r.unit;
-        return t === "temporal" || i ? V0e(e, t, i) : [e]
+        const i = (r = an(n)) == null ? void 0 : r.unit;
+        return t === "temporal" || i ? pme(e, t, i) : [e]
     }
 
-    function sa(e, t, n, i) {
+    function Sa(e, t, n, i) {
         const {
             encoding: r
-        } = n, s = Mt(r[i]), {
+        } = n, s = Yt(r[i]), {
             type: a
         } = s, o = s.timeUnit;
-        if (vhe(t)) {
-            const f = sa(e, void 0, n, i),
-                h = Fv(t.unionWith, a, o);
-            return Mr([...h, ...f.value])
+        if (Pfe(t)) {
+            const f = Sa(e, void 0, n, i),
+                h = lb(t.unionWith, a, o);
+            return Hr([...h, ...f.value])
         } else {
-            if (he(t)) return Mr([t]);
-            if (t && t !== "unaggregated" && !u6(t)) return Mr(Fv(t, a, o))
+            if (xe(t)) return Hr([t]);
+            if (t && t !== "unaggregated" && !X6(t)) return Hr(lb(t, a, o))
         }
         const l = n.stack;
         if (l && i === l.fieldChannel) {
-            if (l.offset === "normalize") return ci([
+            if (l.offset === "normalize") return Si([
                 [0, 1]
             ]);
-            const f = n.requestDataName(st.Main);
-            return ci([{
+            const f = n.requestDataName(pt.Main);
+            return Si([{
                 data: f,
                 field: n.vgField(i, {
                     suffix: "start"
                 })
             }, {
                 data: f,
                 field: n.vgField(i, {
                     suffix: "end"
                 })
             }])
         }
-        const u = Qs(i) && K(s) ? J0e(n, i, e) : void 0;
-        if (fs(s)) {
-            const f = Fv([s.datum], a, o);
-            return ci(f)
+        const u = ha(i) && Z(s) ? yme(n, i, e) : void 0;
+        if (ks(s)) {
+            const f = lb([s.datum], a, o);
+            return Si(f)
         }
         const c = s;
         if (t === "unaggregated") {
-            const f = n.requestDataName(st.Main),
+            const f = n.requestDataName(pt.Main),
                 {
                     field: h
                 } = s;
-            return ci([{
+            return Si([{
                 data: f,
-                field: ie({
+                field: oe({
                     field: h,
                     aggregate: "min"
                 })
             }, {
                 data: f,
-                field: ie({
+                field: oe({
                     field: h,
                     aggregate: "max"
                 })
             }])
-        } else if (ot(c.bin)) {
-            if (qt(e)) return ci(e === "bin-ordinal" ? [] : [{
-                data: Ih(u) ? n.requestDataName(st.Main) : n.requestDataName(st.Raw),
-                field: n.vgField(i, Nd(c, i) ? {
+        } else if (yt(c.bin)) {
+            if (fn(e)) return Si(e === "bin-ordinal" ? [] : [{
+                data: dd(u) ? n.requestDataName(pt.Main) : n.requestDataName(pt.Raw),
+                field: n.vgField(i, fg(c, i) ? {
                     binSuffix: "range"
                 } : {}),
-                sort: u === !0 || !ae(u) ? {
+                sort: u === !0 || !ce(u) ? {
                     field: n.vgField(i, {}),
                     op: "min"
                 } : u
             }]); {
                 const {
                     bin: f
                 } = c;
-                if (ot(f)) {
-                    const h = $C(n, c.field, f);
-                    return ci([new Zn(() => {
+                if (yt(f)) {
+                    const h = vC(n, c.field, f);
+                    return Si([new ci(() => {
                         const d = n.getSignalName(h);
                         return `[${d}.start, ${d}.stop]`
                     })])
-                } else return ci([{
-                    data: n.requestDataName(st.Main),
+                } else return Si([{
+                    data: n.requestDataName(pt.Main),
                     field: n.vgField(i, {})
                 }])
             }
-        } else if (c.timeUnit && Fe(["time", "utc"], e) && k6(c, Et(n) ? n.encoding[us(i)] : void 0, n.markDef, n.config)) {
-            const f = n.requestDataName(st.Main);
-            return ci([{
+        } else if (c.timeUnit && Be(["time", "utc"], e) && c8(c, Dt(n) ? n.encoding[Ss(i)] : void 0, n.markDef, n.config)) {
+            const f = n.requestDataName(pt.Main);
+            return Si([{
                 data: f,
                 field: n.vgField(i)
             }, {
                 data: f,
                 field: n.vgField(i, {
                     suffix: "end"
                 })
             }])
-        } else return ci(u ? [{
-            data: Ih(u) ? n.requestDataName(st.Main) : n.requestDataName(st.Raw),
+        } else return Si(u ? [{
+            data: dd(u) ? n.requestDataName(pt.Main) : n.requestDataName(pt.Raw),
             field: n.vgField(i),
             sort: u
         }] : [{
-            data: n.requestDataName(st.Main),
+            data: n.requestDataName(pt.Main),
             field: n.vgField(i)
         }])
     }
 
-    function Rv(e, t) {
+    function ub(e, t) {
         const {
             op: n,
             field: i,
             order: r
         } = e;
         return {
-            op: n ?? (t ? "sum" : N1),
+            op: n ?? (t ? "sum" : dy),
             ...i ? {
-                field: Pi(i)
+                field: Ji(i)
             } : {},
             ...r ? {
                 order: r
             } : {}
         }
     }
 
-    function K0e(e, t) {
+    function mme(e, t) {
         var o;
         const n = e.component.scales[t],
             i = e.specifiedScales[t].domain,
             r = (o = e.fieldDef(t)) == null ? void 0 : o.bin,
-            s = u6(i) && i,
-            a = Pl(r) && $1(r.extent) && r.extent;
+            s = X6(i) && i,
+            a = nu(r) && ay(r.extent) && r.extent;
         (s || a) && n.set("selectionExtent", s ?? a, !0)
     }
 
-    function J0e(e, t, n) {
-        if (!qt(n)) return;
+    function yme(e, t, n) {
+        if (!fn(n)) return;
         const i = e.fieldDef(t),
             r = i.sort;
-        if (S6(r)) return {
+        if (o8(r)) return {
             op: "min",
-            field: uc(i, t),
+            field: Pc(i, t),
             order: "ascending"
         };
         const {
             stack: s
         } = e, a = s ? new Set([...s.groupbyFields, ...s.stackBy.map(o => o.fieldDef.field)]) : void 0;
-        if (Br(r)) {
+        if (ns(r)) {
             const o = s && !a.has(r.field);
-            return Rv(r, o)
-        } else if (w6(r)) {
+            return ub(r, o)
+        } else if (a8(r)) {
             const {
                 encoding: o,
                 order: l
             } = r, u = e.fieldDef(o), {
                 aggregate: c,
                 field: f
             } = u, h = s && !a.has(f);
-            if (Bs(c) || oo(c)) return Rv({
-                field: ie(u),
+            if (na(c) || $o(c)) return ub({
+                field: oe(u),
                 order: l
             }, h);
-            if (OE(c) || !c) return Rv({
+            if (xk(c) || !c) return ub({
                 op: c,
                 field: f,
                 order: l
             }, h)
         } else {
             if (r === "descending") return {
                 op: "min",
                 field: e.vgField(t),
                 order: "descending"
             };
-            if (Fe(["ascending", void 0], r)) return !0
+            if (Be(["ascending", void 0], r)) return !0
         }
     }
 
-    function b3(e, t) {
+    function GM(e, t) {
         const {
             aggregate: n,
             type: i
         } = e;
-        return n ? re(n) && !Fce.has(n) ? {
+        return n ? le(n) && !Vue.has(n) ? {
             valid: !1,
-            reason: wfe(n)
+            reason: zce(n)
         } : i === "quantitative" && t === "log" ? {
             valid: !1,
-            reason: Sfe(e)
+            reason: Bce(e)
         } : {
             valid: !0
         } : {
             valid: !1,
-            reason: _fe(e)
+            reason: Ice(e)
         }
     }
 
-    function hx(e, t, n, i) {
-        return e.explicit && t.explicit && X($fe(n, i, e.value, t.value)), {
+    function Ux(e, t, n, i) {
+        return e.explicit && t.explicit && J(qce(n, i, e.value, t.value)), {
             explicit: e.explicit,
             value: [...e.value, ...t.value]
         }
     }
 
-    function Q0e(e) {
-        const t = Pr(e.map(a => {
-                if ($s(a)) {
+    function vme(e) {
+        const t = Qr(e.map(a => {
+                if (qs(a)) {
                     const {
                         sort: o,
                         ...l
                     } = a;
                     return l
                 }
                 return a
-            }), Ne),
-            n = Pr(e.map(a => {
-                if ($s(a)) {
+            }), ze),
+            n = Qr(e.map(a => {
+                if (qs(a)) {
                     const o = a.sort;
-                    return o !== void 0 && !Ih(o) && ("op" in o && o.op === "count" && delete o.field, o.order === "ascending" && delete o.order), o
+                    return o !== void 0 && !dd(o) && ("op" in o && o.op === "count" && delete o.field, o.order === "ascending" && delete o.order), o
                 }
-            }).filter(a => a !== void 0), Ne);
+            }).filter(a => a !== void 0), ze);
         if (t.length === 0) return;
         if (t.length === 1) {
             const a = e[0];
-            if ($s(a) && n.length > 0) {
+            if (qs(a) && n.length > 0) {
                 let o = n[0];
                 if (n.length > 1) {
-                    X(F5);
-                    const l = n.filter(u => ae(u) && "op" in u && u.op !== "min");
-                    n.every(u => ae(u) && "op" in u) && l.length === 1 ? o = l[0] : o = !0
-                } else if (ae(o) && "field" in o) {
+                    J(Z5);
+                    const l = n.filter(u => ce(u) && "op" in u && u.op !== "min");
+                    n.every(u => ce(u) && "op" in u) && l.length === 1 ? o = l[0] : o = !0
+                } else if (ce(o) && "field" in o) {
                     const l = o.field;
                     a.field === l && (o = o.order ? {
                         order: o.order
                     } : !0)
                 }
                 return {
                     ...a,
                     sort: o
                 }
             }
             return a
         }
-        const i = Pr(n.map(a => Ih(a) || !("op" in a) || re(a.op) && a.op in $ce ? a : (X(Mfe(a)), !0)), Ne);
+        const i = Qr(n.map(a => dd(a) || !("op" in a) || le(a.op) && a.op in que ? a : (J(Yce(a)), !0)), ze);
         let r;
-        i.length === 1 ? r = i[0] : i.length > 1 && (X(F5), r = !0);
-        const s = Pr(e.map(a => $s(a) ? a.data : null), a => a);
+        i.length === 1 ? r = i[0] : i.length > 1 && (J(Z5), r = !0);
+        const s = Qr(e.map(a => qs(a) ? a.data : null), a => a);
         return s.length === 1 && s[0] !== null ? {
             data: s[0],
             fields: t.map(o => o.field),
             ...r ? {
                 sort: r
             } : {}
         } : {
             fields: t,
             ...r ? {
                 sort: r
             } : {}
         }
     }
 
-    function FC(e) {
-        if ($s(e) && re(e.field)) return e.field;
-        if (Rce(e)) {
+    function wC(e) {
+        if (qs(e) && le(e.field)) return e.field;
+        if (Kue(e)) {
             let t;
             for (const n of e.fields)
-                if ($s(n) && re(n.field)) {
+                if (qs(n) && le(n.field)) {
                     if (!t) t = n.field;
-                    else if (t !== n.field) return X(Ofe), t
-                } return X(Ffe), t
-        } else if (Dce(e)) {
-            X(Rfe);
+                    else if (t !== n.field) return J(Xce), t
+                } return J(Vce), t
+        } else if (Jue(e)) {
+            J(Kce);
             const t = e.fields[0];
-            return re(t) ? t : void 0
+            return le(t) ? t : void 0
         }
     }
 
-    function K1(e, t) {
-        const i = e.component.scales[t].get("domains").map(r => ($s(r) && (r.data = e.lookupDataSource(r.data)), r));
-        return Q0e(i)
+    function $y(e, t) {
+        const i = e.component.scales[t].get("domains").map(r => (qs(r) && (r.data = e.lookupDataSource(r.data)), r));
+        return vme(i)
     }
 
-    function f8(e) {
-        return Ic(e) || RC(e) ? e.children.reduce((t, n) => t.concat(f8(n)), x3(e)) : x3(e)
+    function Vz(e) {
+        return cf(e) || SC(e) ? e.children.reduce((t, n) => t.concat(Vz(n)), UM(e)) : UM(e)
     }
 
-    function x3(e) {
-        return H(e.component.scales).reduce((t, n) => {
+    function UM(e) {
+        return K(e.component.scales).reduce((t, n) => {
             const i = e.component.scales[n];
             if (i.merged) return t;
             const r = i.combine(),
                 {
                     name: s,
                     type: a,
                     selectionExtent: o,
                     domains: l,
                     range: u,
                     reverse: c,
                     ...f
                 } = r,
-                h = Z0e(r.range, s, n, e),
-                d = K1(e, n),
-                g = o ? Yge(e, o, i, d) : null;
+                h = bme(r.range, s, n, e),
+                d = $y(e, n),
+                g = o ? dge(e, o, i, d) : null;
             return t.push({
                 name: s,
                 type: a,
                 ...d ? {
                     domain: d
                 } : {},
                 ...g ? {
@@ -47975,308 +41329,308 @@
                     reverse: c
                 } : {},
                 ...f
             }), t
         }, [])
     }
 
-    function Z0e(e, t, n, i) {
-        if (Wt(n)) {
-            if (lo(e)) return {
+    function bme(e, t, n, i) {
+        if (cn(n)) {
+            if (To(e)) return {
                 step: {
                     signal: `${t}_step`
                 }
             }
-        } else if (ae(e) && $s(e)) return {
+        } else if (ce(e) && qs(e)) return {
             ...e,
             data: i.lookupDataSource(e.data)
         };
         return e
     }
-    class h8 extends ea {
+    class Kz extends ga {
         constructor(t, n) {
             super({}, {
                 name: t
             }), this.merged = !1, this.setWithExplicit("type", n)
         }
         domainDefinitelyIncludesZero() {
-            return this.get("zero") !== !1 ? !0 : ol(this.get("domains"), t => W(t) && t.length === 2 && t[0] <= 0 && t[1] >= 0)
+            return this.get("zero") !== !1 ? !0 : Fl(this.get("domains"), t => H(t) && t.length === 2 && t[0] <= 0 && t[1] >= 0)
         }
     }
-    const eme = ["range", "scheme"];
+    const xme = ["range", "scheme"];
 
-    function tme(e) {
+    function _me(e) {
         const t = e.component.scales;
-        for (const n of A1) {
+        for (const n of sy) {
             const i = t[n];
             if (!i) continue;
-            const r = nme(n, e);
+            const r = wme(n, e);
             i.setWithExplicit("range", r)
         }
     }
 
-    function _3(e, t) {
+    function WM(e, t) {
         const n = e.fieldDef(t);
         if (n != null && n.bin) {
             const {
                 bin: i,
                 field: r
-            } = n, s = oi(t), a = e.getName(s);
-            if (ae(i) && i.binned && i.step !== void 0) return new Zn(() => {
+            } = n, s = yi(t), a = e.getName(s);
+            if (ce(i) && i.binned && i.step !== void 0) return new ci(() => {
                 const o = e.scaleName(t),
                     l = `(domain("${o}")[1] - domain("${o}")[0]) / ${i.step}`;
                 return `${e.getSignalName(a)} / (${l})`
             });
-            if (ot(i)) {
-                const o = $C(e, r, i);
-                return new Zn(() => {
+            if (yt(i)) {
+                const o = vC(e, r, i);
+                return new ci(() => {
                     const l = e.getSignalName(o),
                         u = `(${l}.stop - ${l}.start) / ${l}.step`;
                     return `${e.getSignalName(a)} / (${u})`
                 })
             }
         }
     }
 
-    function nme(e, t) {
+    function wme(e, t) {
         const n = t.specifiedScales[e],
             {
                 size: i
             } = t,
             s = t.getScaleComponent(e).get("type");
-        for (const f of eme)
+        for (const f of xme)
             if (n[f] !== void 0) {
-                const h = V2(s, f),
-                    d = c6(e, f);
-                if (!h) X(HI(s, f, e));
-                else if (d) X(d);
+                const h = Cx(s, f),
+                    d = V6(e, f);
+                if (!h) J($6(s, f, e));
+                else if (d) J(d);
                 else switch (f) {
                     case "range": {
                         const g = n.range;
-                        if (W(g)) {
-                            if (Wt(e)) return Mr(g.map(p => {
+                        if (H(g)) {
+                            if (cn(e)) return Hr(g.map(p => {
                                 if (p === "width" || p === "height") {
                                     const m = t.getName(p),
                                         y = t.getSignalName.bind(t);
-                                    return Zn.fromName(y, m)
+                                    return ci.fromName(y, m)
                                 }
                                 return p
                             }))
-                        } else if (ae(g)) return Mr({
-                            data: t.requestDataName(st.Main),
+                        } else if (ce(g)) return Hr({
+                            data: t.requestDataName(pt.Main),
                             field: g.field,
                             sort: {
                                 op: "min",
                                 field: t.vgField(e)
                             }
                         });
-                        return Mr(g)
+                        return Hr(g)
                     }
                     case "scheme":
-                        return Mr(ime(n[f]))
+                        return Hr(Sme(n[f]))
                 }
-            } const a = e === ht || e === "xOffset" ? "width" : "height",
+            } const a = e === kt || e === "xOffset" ? "width" : "height",
             o = i[a];
-        if (Jr(o)) {
-            if (Wt(e))
-                if (qt(s)) {
-                    const f = d8(o, t, e);
-                    if (f) return Mr({
+        if (ds(o)) {
+            if (cn(e))
+                if (fn(s)) {
+                    const f = Jz(o, t, e);
+                    if (f) return Hr({
                         step: f
                     })
-                } else X(YI(a));
-            else if (Oc(e)) {
-                const f = e === no ? "x" : "y";
+                } else J(T6(a));
+            else if (rf(e)) {
+                const f = e === So ? "x" : "y";
                 if (t.getScaleComponent(f).get("type") === "band") {
-                    const g = g8(o, s);
-                    if (g) return Mr(g)
+                    const g = Qz(o, s);
+                    if (g) return Hr(g)
                 }
             }
         }
         const {
             rangeMin: l,
             rangeMax: u
-        } = n, c = rme(e, t);
-        return (l !== void 0 || u !== void 0) && V2(s, "rangeMin") && W(c) && c.length === 2 ? Mr([l ?? c[0], u ?? c[1]]) : ci(c)
+        } = n, c = Eme(e, t);
+        return (l !== void 0 || u !== void 0) && Cx(s, "rangeMin") && H(c) && c.length === 2 ? Hr([l ?? c[0], u ?? c[1]]) : Si(c)
     }
 
-    function ime(e) {
-        return yhe(e) ? {
+    function Sme(e) {
+        return Nfe(e) ? {
             scheme: e.name,
-            ...Jn(e, ["name"])
+            ...li(e, ["name"])
         } : {
             scheme: e
         }
     }
 
-    function rme(e, t) {
+    function Eme(e, t) {
         const {
             size: n,
             config: i,
             mark: r,
             encoding: s
         } = t, a = t.getSignalName.bind(t), {
             type: o
-        } = Mt(s[e]), u = t.getScaleComponent(e).get("type"), {
+        } = Yt(s[e]), u = t.getScaleComponent(e).get("type"), {
             domain: c,
             domainMid: f
         } = t.specifiedScales[e];
         switch (e) {
-            case ht:
-            case Gt: {
-                if (Fe(["point", "band"], u)) {
-                    const g = p8(e, n, i.view);
-                    if (Jr(g)) return {
-                        step: d8(g, t, e)
+            case kt:
+            case un: {
+                if (Be(["point", "band"], u)) {
+                    const g = Zz(e, n, i.view);
+                    if (ds(g)) return {
+                        step: Jz(g, t, e)
                     }
                 }
-                const h = oi(e),
+                const h = yi(e),
                     d = t.getName(h);
-                return e === Gt && wi(u) ? [Zn.fromName(a, d), 0] : [0, Zn.fromName(a, d)]
+                return e === un && Ni(u) ? [ci.fromName(a, d), 0] : [0, ci.fromName(a, d)]
             }
-            case no:
-            case Mc:
-                return sme(e, t, u);
-            case Ks: {
+            case So:
+            case nf:
+                return kme(e, t, u);
+            case ca: {
                 const h = t.component.scales[e].get("zero"),
-                    d = m8(r, h, i),
-                    g = lme(r, n, t, i);
-                return ic(u) ? ome(d, g, ame(u, i, c, e)) : [d, g]
+                    d = e9(r, h, i),
+                    g = $me(r, n, t, i);
+                return Tc(u) ? Ame(d, g, Cme(u, i, c, e)) : [d, g]
             }
-            case zi:
+            case nr:
                 return [0, Math.PI * 2];
-            case Dl:
+            case eu:
                 return [0, 360];
-            case _r:
-                return [0, new Zn(() => {
+            case Nr:
+                return [0, new ci(() => {
                     const h = t.getSignalName("width"),
                         d = t.getSignalName("height");
                     return `min(${h},${d})/2`
                 })];
-            case so:
+            case Co:
                 return [i.scale.minStrokeWidth, i.scale.maxStrokeWidth];
-            case ao:
+            case Ao:
                 return [
                     [1, 0],
                     [4, 2],
                     [2, 1],
                     [1, 1],
                     [1, 2, 4, 2]
                 ];
-            case ai:
+            case mi:
                 return "symbol";
-            case si:
-            case os:
-            case ls:
+            case pi:
+            case _s:
+            case ws:
                 return u === "ordinal" ? o === "nominal" ? "category" : "ordinal" : f !== void 0 ? "diverging" : r === "rect" || r === "geoshape" ? "heatmap" : "ramp";
-            case Js:
-            case io:
-            case ro:
+            case fa:
+            case Eo:
+            case ko:
                 return [i.scale.minOpacity, i.scale.maxOpacity]
         }
     }
 
-    function d8(e, t, n) {
+    function Jz(e, t, n) {
         const {
             encoding: i
-        } = t, r = t.getScaleComponent(n), s = AE(n), a = i[s];
-        if (nz({
+        } = t, r = t.getScaleComponent(n), s = mk(n), a = i[s];
+        if (B8({
                 step: e,
-                offsetIsDiscrete: Ce(a) && r6(a.type)
-            }) === "offset" && I6(i, s)) {
+                offsetIsDiscrete: De(a) && U6(a.type)
+            }) === "offset" && w8(i, s)) {
             const l = t.getScaleComponent(s);
             let c = `domain('${t.scaleName(s)}').length`;
             if (l.get("type") === "band") {
                 const h = l.get("paddingInner") ?? l.get("padding") ?? 0,
                     d = l.get("paddingOuter") ?? l.get("padding") ?? 0;
                 c = `bandspace(${c}, ${h}, ${d})`
             }
             const f = r.get("paddingInner") ?? r.get("padding");
             return {
-                signal: `${e.step} * ${c} / (1-${Ice(f)})`
+                signal: `${e.step} * ${c} / (1-${tce(f)})`
             }
         } else return e.step
     }
 
-    function g8(e, t) {
-        if (nz({
+    function Qz(e, t) {
+        if (B8({
                 step: e,
-                offsetIsDiscrete: qt(t)
+                offsetIsDiscrete: fn(t)
             }) === "offset") return {
             step: e.step
         }
     }
 
-    function sme(e, t, n) {
-        const i = e === no ? "x" : "y",
+    function kme(e, t, n) {
+        const i = e === So ? "x" : "y",
             s = t.getScaleComponent(i).get("type"),
             a = t.scaleName(i);
         if (s === "band") {
-            const o = p8(i, t.size, t.config.view);
-            if (Jr(o)) {
-                const l = g8(o, n);
+            const o = Zz(i, t.size, t.config.view);
+            if (ds(o)) {
+                const l = Qz(o, n);
                 if (l) return l
             }
             return [0, {
                 signal: `bandwidth('${a}')`
             }]
         } else {
             const o = t.encoding[i];
-            if (K(o) && o.timeUnit) {
-                const l = t6(o.timeUnit, c => `scale('${a}', ${c})`),
+            if (Z(o) && o.timeUnit) {
+                const l = z6(o.timeUnit, c => `scale('${a}', ${c})`),
                     u = t.config.scale.bandWithNestedOffsetPaddingInner;
                 if (u) {
-                    const c = he(u) ? `${u.signal}/2` : `${u/2}`,
-                        f = he(u) ? `(1 - ${u.signal}/2)` : `${1-u/2}`;
+                    const c = xe(u) ? `${u.signal}/2` : `${u/2}`,
+                        f = xe(u) ? `(1 - ${u.signal}/2)` : `${1-u/2}`;
                     return [{
                         signal: `${c} * (${l})`
                     }, {
                         signal: `${f} * (${l})`
                     }]
                 }
                 return [0, {
                     signal: l
                 }]
             }
-            return hI(`Cannot use ${e} scale if ${i} scale is not discrete.`)
+            return XI(`Cannot use ${e} scale if ${i} scale is not discrete.`)
         }
     }
 
-    function p8(e, t, n) {
-        const i = e === ht ? "width" : "height",
+    function Zz(e, t, n) {
+        const i = e === kt ? "width" : "height",
             r = t[i];
-        return r || H0(n, i)
+        return r || A0(n, i)
     }
 
-    function ame(e, t, n, i) {
+    function Cme(e, t, n, i) {
         switch (e) {
             case "quantile":
                 return t.scale.quantileCount;
             case "quantize":
                 return t.scale.quantizeCount;
             case "threshold":
-                return n !== void 0 && W(n) ? n.length + 1 : (X(Ufe(i)), 3)
+                return n !== void 0 && H(n) ? n.length + 1 : (J(sfe(i)), 3)
         }
     }
 
-    function ome(e, t, n) {
+    function Ame(e, t, n) {
         const i = () => {
-            const r = Ds(t),
-                s = Ds(e),
+            const r = br(t),
+                s = br(e),
                 a = `(${r} - ${s}) / (${n} - 1)`;
             return `sequence(${s}, ${r} + ${a}, ${a})`
         };
-        return he(t) ? new Zn(i) : {
+        return xe(t) ? new ci(i) : {
             signal: i()
         }
     }
 
-    function m8(e, t, n) {
-        if (t) return he(t) ? {
-            signal: `${t.signal} ? 0 : ${m8(e,!1,n)}`
+    function e9(e, t, n) {
+        if (t) return xe(t) ? {
+            signal: `${t.signal} ? 0 : ${e9(e,!1,n)}`
         } : 0;
         switch (e) {
             case "bar":
             case "tick":
                 return n.scale.minBandSize;
             case "line":
             case "trail":
@@ -48285,390 +41639,390 @@
             case "text":
                 return n.scale.minFontSize;
             case "point":
             case "square":
             case "circle":
                 return n.scale.minSize
         }
-        throw new Error(T1("size", e))
+        throw new Error(oy("size", e))
     }
-    const w3 = .95;
+    const qM = .95;
 
-    function lme(e, t, n, i) {
+    function $me(e, t, n, i) {
         const r = {
-            x: _3(n, "x"),
-            y: _3(n, "y")
+            x: WM(n, "x"),
+            y: WM(n, "y")
         };
         switch (e) {
             case "bar":
             case "tick": {
                 if (i.scale.maxBandSize !== void 0) return i.scale.maxBandSize;
-                const s = S3(t, r, i.view);
-                return Ze(s) ? s - 1 : new Zn(() => `${s.signal} - 1`)
+                const s = HM(t, r, i.view);
+                return lt(s) ? s - 1 : new ci(() => `${s.signal} - 1`)
             }
             case "line":
             case "trail":
             case "rule":
                 return i.scale.maxStrokeWidth;
             case "text":
                 return i.scale.maxFontSize;
             case "point":
             case "square":
             case "circle": {
                 if (i.scale.maxSize) return i.scale.maxSize;
-                const s = S3(t, r, i.view);
-                return Ze(s) ? Math.pow(w3 * s, 2) : new Zn(() => `pow(${w3} * ${s.signal}, 2)`)
+                const s = HM(t, r, i.view);
+                return lt(s) ? Math.pow(qM * s, 2) : new ci(() => `pow(${qM} * ${s.signal}, 2)`)
             }
         }
-        throw new Error(T1("size", e))
+        throw new Error(oy("size", e))
     }
 
-    function S3(e, t, n) {
-        const i = Jr(e.width) ? e.width.step : q0(n, "width"),
-            r = Jr(e.height) ? e.height.step : q0(n, "height");
-        return t.x || t.y ? new Zn(() => `min(${[t.x?t.x.signal:i,t.y?t.y.signal:r].join(", ")})`) : Math.min(i, r)
+    function HM(e, t, n) {
+        const i = ds(e.width) ? e.width.step : C0(n, "width"),
+            r = ds(e.height) ? e.height.step : C0(n, "height");
+        return t.x || t.y ? new ci(() => `min(${[t.x?t.x.signal:i,t.y?t.y.signal:r].join(", ")})`) : Math.min(i, r)
     }
 
-    function y8(e, t) {
-        Et(e) ? ume(e, t) : b8(e, t)
+    function t9(e, t) {
+        Dt(e) ? Tme(e, t) : i9(e, t)
     }
 
-    function ume(e, t) {
+    function Tme(e, t) {
         const n = e.component.scales,
             {
                 config: i,
                 encoding: r,
                 markDef: s,
                 specifiedScales: a
             } = e;
-        for (const o of H(n)) {
+        for (const o of K(n)) {
             const l = a[o],
                 u = n[o],
                 c = e.getScaleComponent(o),
-                f = Mt(r[o]),
+                f = Yt(r[o]),
                 h = l[t],
                 d = c.get("type"),
                 g = c.get("padding"),
                 p = c.get("paddingInner"),
-                m = V2(d, t),
-                y = c6(o, t);
-            if (h !== void 0 && (m ? y && X(y) : X(HI(d, t, o))), m && y === void 0)
+                m = Cx(d, t),
+                y = V6(o, t);
+            if (h !== void 0 && (m ? y && J(y) : J($6(d, t, o))), m && y === void 0)
                 if (h !== void 0) {
                     const v = f.timeUnit,
                         b = f.type;
                     switch (t) {
                         case "domainMax":
                         case "domainMin":
-                            Ll(l[t]) || b === "temporal" || v ? u.set(t, {
-                                signal: B1(l[t], {
+                            iu(l[t]) || b === "temporal" || v ? u.set(t, {
+                                signal: vy(l[t], {
                                     type: b,
                                     timeUnit: v
                                 })
                             }, !0) : u.set(t, l[t], !0);
                             break;
                         default:
                             u.copyKeyFromObject(t, l)
                     }
                 } else {
-                    const v = t in E3 ? E3[t]({
+                    const v = t in YM ? YM[t]({
                         model: e,
                         channel: o,
                         fieldOrDatumDef: f,
                         scaleType: d,
                         scalePadding: g,
                         scalePaddingInner: p,
                         domain: l.domain,
                         domainMin: l.domainMin,
                         domainMax: l.domainMax,
                         markDef: s,
                         config: i,
-                        hasNestedOffsetScale: J2(r, o),
-                        hasSecondaryRangeChannel: !!r[us(o)]
+                        hasNestedOffsetScale: $x(r, o),
+                        hasSecondaryRangeChannel: !!r[Ss(o)]
                     }) : i.scale[t];
                     v !== void 0 && u.set(t, v, !1)
                 }
         }
     }
-    const E3 = {
+    const YM = {
         bins: ({
             model: e,
             fieldOrDatumDef: t
-        }) => K(t) ? cme(e, t) : void 0,
+        }) => Z(t) ? Mme(e, t) : void 0,
         interpolate: ({
             channel: e,
             fieldOrDatumDef: t
-        }) => fme(e, t.type),
+        }) => Ome(e, t.type),
         nice: ({
             scaleType: e,
             channel: t,
             domain: n,
             domainMin: i,
             domainMax: r,
             fieldOrDatumDef: s
-        }) => hme(e, t, n, i, r, s),
+        }) => Fme(e, t, n, i, r, s),
         padding: ({
             channel: e,
             scaleType: t,
             fieldOrDatumDef: n,
             markDef: i,
             config: r
-        }) => dme(e, t, r.scale, n, i, r.bar),
+        }) => Rme(e, t, r.scale, n, i, r.bar),
         paddingInner: ({
             scalePadding: e,
             channel: t,
             markDef: n,
             scaleType: i,
             config: r,
             hasNestedOffsetScale: s
-        }) => gme(e, t, n.type, i, r.scale, s),
+        }) => Dme(e, t, n.type, i, r.scale, s),
         paddingOuter: ({
             scalePadding: e,
             channel: t,
             scaleType: n,
             scalePaddingInner: i,
             config: r,
             hasNestedOffsetScale: s
-        }) => pme(e, t, n, i, r.scale, s),
+        }) => Nme(e, t, n, i, r.scale, s),
         reverse: ({
             fieldOrDatumDef: e,
             scaleType: t,
             channel: n,
             config: i
         }) => {
-            const r = K(e) ? e.sort : void 0;
-            return mme(t, r, n, i.scale)
+            const r = Z(e) ? e.sort : void 0;
+            return Pme(t, r, n, i.scale)
         },
         zero: ({
             channel: e,
             fieldOrDatumDef: t,
             domain: n,
             markDef: i,
             scaleType: r,
             config: s,
             hasSecondaryRangeChannel: a
-        }) => yme(e, t, n, i, r, s.scale, a)
+        }) => Lme(e, t, n, i, r, s.scale, a)
     };
 
-    function v8(e) {
-        Et(e) ? tme(e) : b8(e, "range")
+    function n9(e) {
+        Dt(e) ? _me(e) : i9(e, "range")
     }
 
-    function b8(e, t) {
+    function i9(e, t) {
         const n = e.component.scales;
-        for (const i of e.children) t === "range" ? v8(i) : y8(i, t);
-        for (const i of H(n)) {
+        for (const i of e.children) t === "range" ? n9(i) : t9(i, t);
+        for (const i of K(n)) {
             let r;
             for (const s of e.children) {
                 const a = s.component.scales[i];
                 if (a) {
                     const o = a.getWithExplicit(t);
-                    r = Ua(r, o, t, "scale", gz((l, u) => {
+                    r = co(r, o, t, "scale", Q8((l, u) => {
                         switch (t) {
                             case "range":
                                 return l.step && u.step ? l.step - u.step : 0
                         }
                         return 0
                     }))
                 }
             }
             n[i].setWithExplicit(t, r)
         }
     }
 
-    function cme(e, t) {
+    function Mme(e, t) {
         const n = t.bin;
-        if (ot(n)) {
-            const i = $C(e, t.field, n);
-            return new Zn(() => e.getSignalName(i))
-        } else if (Xt(n) && Pl(n) && n.step !== void 0) return {
+        if (yt(n)) {
+            const i = vC(e, t.field, n);
+            return new ci(() => e.getSignalName(i))
+        } else if (pn(n) && nu(n) && n.step !== void 0) return {
             step: n.step
         }
     }
 
-    function fme(e, t) {
-        if (Fe([si, os, ls], e) && t !== "nominal") return "hcl"
+    function Ome(e, t) {
+        if (Be([pi, _s, ws], e) && t !== "nominal") return "hcl"
     }
 
-    function hme(e, t, n, i, r, s) {
+    function Fme(e, t, n, i, r, s) {
         var a;
-        if (!((a = Kr(s)) != null && a.bin || W(n) || r != null || i != null || Fe([Qn.TIME, Qn.UTC], e))) return Wt(t) ? !0 : void 0
+        if (!((a = hs(s)) != null && a.bin || H(n) || r != null || i != null || Be([ui.TIME, ui.UTC], e))) return cn(t) ? !0 : void 0
     }
 
-    function dme(e, t, n, i, r, s) {
-        if (Wt(e)) {
-            if (ir(t)) {
+    function Rme(e, t, n, i, r, s) {
+        if (cn(e)) {
+            if (xr(t)) {
                 if (n.continuousPadding !== void 0) return n.continuousPadding;
                 const {
                     type: a,
                     orient: o
                 } = r;
-                if (a === "bar" && !(K(i) && (i.bin || i.timeUnit)) && (o === "vertical" && e === "x" || o === "horizontal" && e === "y")) return s.continuousBandSize
+                if (a === "bar" && !(Z(i) && (i.bin || i.timeUnit)) && (o === "vertical" && e === "x" || o === "horizontal" && e === "y")) return s.continuousBandSize
             }
-            if (t === Qn.POINT) return n.pointPadding
+            if (t === ui.POINT) return n.pointPadding
         }
     }
 
-    function gme(e, t, n, i, r, s = !1) {
+    function Dme(e, t, n, i, r, s = !1) {
         if (e === void 0) {
-            if (Wt(t)) {
+            if (cn(t)) {
                 const {
                     bandPaddingInner: a,
                     barBandPaddingInner: o,
                     rectBandPaddingInner: l,
                     bandWithNestedOffsetPaddingInner: u
                 } = r;
-                return s ? u : Ct(a, n === "bar" ? o : l)
-            } else if (Oc(t) && i === Qn.BAND) return r.offsetBandPaddingInner
+                return s ? u : Gt(a, n === "bar" ? o : l)
+            } else if (rf(t) && i === ui.BAND) return r.offsetBandPaddingInner
         }
     }
 
-    function pme(e, t, n, i, r, s = !1) {
+    function Nme(e, t, n, i, r, s = !1) {
         if (e === void 0) {
-            if (Wt(t)) {
+            if (cn(t)) {
                 const {
                     bandPaddingOuter: a,
                     bandWithNestedOffsetPaddingOuter: o
                 } = r;
                 if (s) return o;
-                if (n === Qn.BAND) return Ct(a, he(i) ? {
+                if (n === ui.BAND) return Gt(a, xe(i) ? {
                     signal: `${i.signal}/2`
                 } : i / 2)
-            } else if (Oc(t)) {
-                if (n === Qn.POINT) return .5;
-                if (n === Qn.BAND) return r.offsetBandPaddingOuter
+            } else if (rf(t)) {
+                if (n === ui.POINT) return .5;
+                if (n === ui.BAND) return r.offsetBandPaddingOuter
             }
         }
     }
 
-    function mme(e, t, n, i) {
-        if (n === "x" && i.xReverse !== void 0) return wi(e) && t === "descending" ? he(i.xReverse) ? {
+    function Pme(e, t, n, i) {
+        if (n === "x" && i.xReverse !== void 0) return Ni(e) && t === "descending" ? xe(i.xReverse) ? {
             signal: `!${i.xReverse.signal}`
         } : !i.xReverse : i.xReverse;
-        if (wi(e) && t === "descending") return !0
+        if (Ni(e) && t === "descending") return !0
     }
 
-    function yme(e, t, n, i, r, s, a) {
-        if (!!n && n !== "unaggregated" && wi(r)) {
-            if (W(n)) {
+    function Lme(e, t, n, i, r, s, a) {
+        if (!!n && n !== "unaggregated" && Ni(r)) {
+            if (H(n)) {
                 const l = n[0],
                     u = n[n.length - 1];
                 if (l <= 0 && u >= 0) return !0
             }
             return !1
         }
-        if (e === "size" && t.type === "quantitative" && !ic(r)) return !0;
-        if (!(K(t) && t.bin) && Fe([...cs, ...xce], e)) {
+        if (e === "size" && t.type === "quantitative" && !Tc(r)) return !0;
+        if (!(Z(t) && t.bin) && Be([...Es, ...Lue], e)) {
             const {
                 orient: l,
                 type: u
             } = i;
-            return Fe(["bar", "area", "line", "trail"], u) && (l === "horizontal" && e === "y" || l === "vertical" && e === "x") ? !1 : Fe(["bar", "area"], u) && !a ? !0 : s == null ? void 0 : s.zero
+            return Be(["bar", "area", "line", "trail"], u) && (l === "horizontal" && e === "y" || l === "vertical" && e === "x") ? !1 : Be(["bar", "area"], u) && !a ? !0 : s == null ? void 0 : s.zero
         }
         return !1
     }
 
-    function vme(e, t, n, i, r = !1) {
-        const s = bme(t, n, i, r),
+    function Ime(e, t, n, i, r = !1) {
+        const s = zme(t, n, i, r),
             {
                 type: a
             } = e;
-        return Qs(t) ? a !== void 0 ? Ehe(t, a) ? K(n) && !She(a, n.type) ? (X(kfe(a, s)), s) : a : (X(Cfe(t, a, s)), s) : s : null
+        return ha(t) ? a !== void 0 ? Gfe(t, a) ? Z(n) && !jfe(a, n.type) ? (J(Uce(a, s)), s) : a : (J(Gce(t, a, s)), s) : s : null
     }
 
-    function bme(e, t, n, i) {
+    function zme(e, t, n, i) {
         var r;
         switch (t.type) {
             case "nominal":
             case "ordinal": {
-                if (Cu(e) || Cv(e) === "discrete") return e === "shape" && t.type === "ordinal" && X(kv(e, "ordinal")), "ordinal";
-                if (Wt(e) || Oc(e)) {
-                    if (Fe(["rect", "bar", "image", "rule"], n.type) || i) return "band"
-                } else if (n.type === "arc" && e in ME) return "band";
-                const s = n[oi(e)];
-                return dl(s) || sc(t) && ((r = t.axis) != null && r.tickBand) ? "band" : "point"
+                if (Ku(e) || eb(e) === "discrete") return e === "shape" && t.type === "ordinal" && J(tb(e, "ordinal")), "ordinal";
+                if (cn(e) || rf(e)) {
+                    if (Be(["rect", "bar", "image", "rule"], n.type) || i) return "band"
+                } else if (n.type === "arc" && e in bk) return "band";
+                const s = n[yi(e)];
+                return Ll(s) || Oc(t) && ((r = t.axis) != null && r.tickBand) ? "band" : "point"
             }
             case "temporal":
-                return Cu(e) ? "time" : Cv(e) === "discrete" ? (X(kv(e, "temporal")), "ordinal") : K(t) && t.timeUnit && en(t.timeUnit).utc ? "utc" : "time";
+                return Ku(e) ? "time" : eb(e) === "discrete" ? (J(tb(e, "temporal")), "ordinal") : Z(t) && t.timeUnit && an(t.timeUnit).utc ? "utc" : "time";
             case "quantitative":
-                return Cu(e) ? K(t) && ot(t.bin) ? "bin-ordinal" : "linear" : Cv(e) === "discrete" ? (X(kv(e, "quantitative")), "ordinal") : "linear";
+                return Ku(e) ? Z(t) && yt(t.bin) ? "bin-ordinal" : "linear" : eb(e) === "discrete" ? (J(tb(e, "quantitative")), "ordinal") : "linear";
             case "geojson":
                 return
         }
-        throw new Error(WI(t.type))
+        throw new Error(C6(t.type))
     }
 
-    function xme(e, {
+    function Bme(e, {
         ignoreRange: t
     } = {}) {
-        x8(e), c8(e);
-        for (const n of whe) y8(e, n);
-        t || v8(e)
+        r9(e), Xz(e);
+        for (const n of Bfe) t9(e, n);
+        t || n9(e)
     }
 
-    function x8(e) {
-        Et(e) ? e.component.scales = _me(e) : e.component.scales = Sme(e)
+    function r9(e) {
+        Dt(e) ? e.component.scales = jme(e) : e.component.scales = Ume(e)
     }
 
-    function _me(e) {
+    function jme(e) {
         const {
             encoding: t,
             mark: n,
             markDef: i
         } = e, r = {};
-        for (const s of A1) {
-            const a = Mt(t[s]);
-            if (a && n === d6 && s === ai && a.type === Rc) continue;
+        for (const s of sy) {
+            const a = Yt(t[s]);
+            if (a && n === Q6 && s === mi && a.type === sf) continue;
             let o = a && a.scale;
-            if (Oc(s)) {
-                const l = $I(s);
-                if (!J2(t, l)) {
-                    o && X(ffe(s));
+            if (rf(s)) {
+                const l = c6(s);
+                if (!$x(t, l)) {
+                    o && J($ce(s));
                     continue
                 }
             }
             if (a && o !== null && o !== !1) {
                 o ?? (o = {});
-                const l = J2(t, s),
-                    u = vme(o, s, a, i, l);
-                r[s] = new h8(e.scaleName(`${s}`, !0), {
+                const l = $x(t, s),
+                    u = Ime(o, s, a, i, l);
+                r[s] = new Kz(e.scaleName(`${s}`, !0), {
                     value: u,
                     explicit: o.type === u
                 })
             }
         }
         return r
     }
-    const wme = gz((e, t) => D5(e) - D5(t));
+    const Gme = Q8((e, t) => tM(e) - tM(t));
 
-    function Sme(e) {
+    function Ume(e) {
         var t;
         const n = e.component.scales = {},
             i = {},
             r = e.component.resolve;
         for (const s of e.children) {
-            x8(s);
-            for (const a of H(s.component.scales))
-                if ((t = r.scale)[a] ?? (t[a] = Jz(a, e)), r.scale[a] === "shared") {
+            r9(s);
+            for (const a of K(s.component.scales))
+                if ((t = r.scale)[a] ?? (t[a] = Nz(a, e)), r.scale[a] === "shared") {
                     const o = i[a],
                         l = s.component.scales[a].getWithExplicit("type");
-                    o ? hhe(o.value, l.value) ? i[a] = Ua(o, l, "type", "scale", wme) : (r.scale[a] = "independent", delete i[a]) : i[a] = l
+                    o ? Mfe(o.value, l.value) ? i[a] = co(o, l, "type", "scale", Gme) : (r.scale[a] = "independent", delete i[a]) : i[a] = l
                 }
         }
-        for (const s of H(i)) {
+        for (const s of K(i)) {
             const a = e.scaleName(s, !0),
                 o = i[s];
-            n[s] = new h8(a, o);
+            n[s] = new Kz(a, o);
             for (const l of e.children) {
                 const u = l.component.scales[s];
                 u && (l.renameScale(u.get("name"), a), u.merged = !0)
             }
         }
         return n
     }
-    class Dv {
+    class cb {
         constructor() {
             this.nameMap = {}
         }
         rename(t, n) {
             this.nameMap[t] = n
         }
         has(t) {
@@ -48676,55 +42030,55 @@
         }
         get(t) {
             for (; this.nameMap[t] && t !== this.nameMap[t];) t = this.nameMap[t];
             return t
         }
     }
 
-    function Et(e) {
+    function Dt(e) {
         return (e == null ? void 0 : e.type) === "unit"
     }
 
-    function lr(e) {
+    function kr(e) {
         return (e == null ? void 0 : e.type) === "facet"
     }
 
-    function RC(e) {
+    function SC(e) {
         return (e == null ? void 0 : e.type) === "concat"
     }
 
-    function Ic(e) {
+    function cf(e) {
         return (e == null ? void 0 : e.type) === "layer"
     }
-    class DC {
+    class EC {
         constructor(t, n, i, r, s, a, o) {
             this.type = n, this.parent = i, this.config = s, this.correctDataNames = l => {
                 var u, c, f;
                 return (u = l.from) != null && u.data && (l.from.data = this.lookupDataSource(l.from.data)), (f = (c = l.from) == null ? void 0 : c.facet) != null && f.data && (l.from.facet.data = this.lookupDataSource(l.from.facet.data)), l
-            }, this.parent = i, this.config = s, this.view = Hn(o), this.name = t.name ?? r, this.title = ca(t.title) ? {
+            }, this.parent = i, this.config = s, this.view = ii(o), this.name = t.name ?? r, this.title = Ta(t.title) ? {
                 text: t.title
-            } : t.title ? Hn(t.title) : void 0, this.scaleNameMap = i ? i.scaleNameMap : new Dv, this.projectionNameMap = i ? i.projectionNameMap : new Dv, this.signalNameMap = i ? i.signalNameMap : new Dv, this.data = t.data, this.description = t.description, this.transforms = Mge(t.transform ?? []), this.layout = n === "layer" || n === "unit" ? {} : zde(t, n, s), this.component = {
+            } : t.title ? ii(t.title) : void 0, this.scaleNameMap = i ? i.scaleNameMap : new cb, this.projectionNameMap = i ? i.projectionNameMap : new cb, this.signalNameMap = i ? i.signalNameMap : new cb, this.data = t.data, this.description = t.description, this.transforms = Kde(t.transform ?? []), this.layout = n === "layer" || n === "unit" ? {} : rde(t, n, s), this.component = {
                 data: {
                     sources: i ? i.component.data.sources : [],
                     outputNodes: i ? i.component.data.outputNodes : {},
                     outputNodeRefCounts: i ? i.component.data.outputNodeRefCounts : {},
-                    isFaceted: P1(t) || (i == null ? void 0 : i.component.data.isFaceted) && t.data === void 0
+                    isFaceted: gy(t) || (i == null ? void 0 : i.component.data.isFaceted) && t.data === void 0
                 },
-                layoutSize: new ea,
+                layoutSize: new ga,
                 layoutHeaders: {
                     row: {},
                     column: {},
                     facet: {}
                 },
                 mark: null,
                 resolve: {
                     scale: {},
                     axis: {},
                     legend: {},
-                    ...a ? ke(a) : {}
+                    ...a ? Fe(a) : {}
                 },
                 selection: null,
                 scales: null,
                 projection: null,
                 axes: {},
                 legends: {}
             }
@@ -48735,53 +42089,53 @@
         get height() {
             return this.getSizeSignalRef("height")
         }
         parse() {
             this.parseScale(), this.parseLayoutSize(), this.renameTopLevelLayoutSizeSignal(), this.parseSelections(), this.parseProjection(), this.parseData(), this.parseAxesAndHeaders(), this.parseLegends(), this.parseMarkGroup()
         }
         parseScale() {
-            xme(this)
+            Bme(this)
         }
         parseProjection() {
-            o8(this)
+            qz(this)
         }
         renameTopLevelLayoutSizeSignal() {
             this.getName("width") !== "width" && this.renameSignal(this.getName("width"), "width"), this.getName("height") !== "height" && this.renameSignal(this.getName("height"), "height")
         }
         parseLegends() {
-            n8(this)
+            Bz(this)
         }
         assembleEncodeFromView(t) {
             const {
                 style: n,
                 ...i
             } = t, r = {};
-            for (const s of H(i)) {
+            for (const s of K(i)) {
                 const a = i[s];
-                a !== void 0 && (r[s] = ut(a))
+                a !== void 0 && (r[s] = bt(a))
             }
             return r
         }
         assembleGroupEncodeEntry(t) {
             let n = {};
-            return this.view && (n = this.assembleEncodeFromView(this.view)), !t && (this.description && (n.description = ut(this.description)), this.type === "unit" || this.type === "layer") ? {
+            return this.view && (n = this.assembleEncodeFromView(this.view)), !t && (this.description && (n.description = bt(this.description)), this.type === "unit" || this.type === "layer") ? {
                 width: this.getSizeSignalRef("width"),
                 height: this.getSizeSignalRef("height"),
                 ...n ?? {}
-            } : et(n) ? void 0 : n
+            } : ft(n) ? void 0 : n
         }
         assembleLayout() {
             if (!this.layout) return;
             const {
                 spacing: t,
                 ...n
             } = this.layout, {
                 component: i,
                 config: r
-            } = this, s = Wpe(i.layoutHeaders, r);
+            } = this, s = cpe(i.layoutHeaders, r);
             return {
                 padding: t,
                 ...this.assembleDefaultLayout(),
                 ...n,
                 ...s ? {
                     titleBand: s
                 } : {}
@@ -48791,88 +42145,88 @@
             return {}
         }
         assembleHeaderMarks() {
             const {
                 layoutHeaders: t
             } = this.component;
             let n = [];
-            for (const i of Ti) t[i].title && n.push(Ipe(this, i));
-            for (const i of EC) n = n.concat(zpe(this, i));
+            for (const i of Ui) t[i].title && n.push(rpe(this, i));
+            for (const i of gC) n = n.concat(spe(this, i));
             return n
         }
         assembleAxes() {
-            return Cpe(this.component.axes, this.config)
+            return qge(this.component.axes, this.config)
         }
         assembleLegends() {
-            return r8(this)
+            return Gz(this)
         }
         assembleProjections() {
-            return d0e(this)
+            return Rpe(this)
         }
         assembleTitle() {
             const {
                 encoding: t,
                 ...n
             } = this.title ?? {}, i = {
-                ...NI(this.config.title).nonMarkTitleProperties,
+                ...y6(this.config.title).nonMarkTitleProperties,
                 ...n,
                 ...t ? {
                     encode: {
                         update: t
                     }
                 } : {}
             };
-            if (i.text) return Fe(["unit", "layer"], this.type) ? Fe(["middle", void 0], i.anchor) && (i.frame ?? (i.frame = "group")) : i.anchor ?? (i.anchor = "start"), et(i) ? void 0 : i
+            if (i.text) return Be(["unit", "layer"], this.type) ? Be(["middle", void 0], i.anchor) && (i.frame ?? (i.frame = "group")) : i.anchor ?? (i.anchor = "start"), ft(i) ? void 0 : i
         }
         assembleGroup(t = []) {
             const n = {};
             t = t.concat(this.assembleSignals()), t.length > 0 && (n.signals = t);
             const i = this.assembleLayout();
             i && (n.layout = i), n.marks = [].concat(this.assembleHeaderMarks(), this.assembleMarks());
-            const r = !this.parent || lr(this.parent) ? f8(this) : [];
+            const r = !this.parent || kr(this.parent) ? Vz(this) : [];
             r.length > 0 && (n.scales = r);
             const s = this.assembleAxes();
             s.length > 0 && (n.axes = s);
             const a = this.assembleLegends();
             return a.length > 0 && (n.legends = a), n
         }
         getName(t) {
-            return ft((this.name ? `${this.name}_` : "") + t)
+            return Et((this.name ? `${this.name}_` : "") + t)
         }
         getDataName(t) {
-            return this.getName(st[t].toLowerCase())
+            return this.getName(pt[t].toLowerCase())
         }
         requestDataName(t) {
             const n = this.getDataName(t),
                 i = this.component.data.outputNodeRefCounts;
             return i[n] = (i[n] || 0) + 1, n
         }
         getSizeSignalRef(t) {
-            if (lr(this.parent)) {
-                const n = Vz(t),
-                    i = k1(n),
+            if (kr(this.parent)) {
+                const n = Rz(t),
+                    i = ry(n),
                     r = this.component.scales[i];
                 if (r && !r.merged) {
                     const s = r.get("type"),
                         a = r.get("range");
-                    if (qt(s) && lo(a)) {
+                    if (fn(s) && To(a)) {
                         const o = r.get("name"),
-                            l = K1(this, i),
-                            u = FC(l);
+                            l = $y(this, i),
+                            u = wC(l);
                         if (u) {
-                            const c = ie({
+                            const c = oe({
                                 aggregate: "distinct",
                                 field: u
                             }, {
                                 expr: "datum"
                             });
                             return {
-                                signal: Xz(o, r, c)
+                                signal: Fz(o, r, c)
                             }
-                        } else return X(RE(i)), null
+                        } else return J(wk(i)), null
                     }
                 }
             }
             return {
                 signal: this.signalNameMap.get(this.getName(t))
             }
         }
@@ -48890,234 +42244,262 @@
             this.scaleNameMap.rename(t, n)
         }
         renameProjection(t, n) {
             this.projectionNameMap.rename(t, n)
         }
         scaleName(t, n) {
             if (n) return this.getName(t);
-            if (CI(t) && Qs(t) && this.component.scales[t] || this.scaleNameMap.has(this.getName(t))) return this.scaleNameMap.get(this.getName(t))
+            if (o6(t) && ha(t) && this.component.scales[t] || this.scaleNameMap.has(this.getName(t))) return this.scaleNameMap.get(this.getName(t))
         }
         projectionName(t) {
             if (t) return this.getName("projection");
             if (this.component.projection && !this.component.projection.merged || this.projectionNameMap.has(this.getName("projection"))) return this.projectionNameMap.get(this.getName("projection"))
         }
         getScaleComponent(t) {
             if (!this.component.scales) throw new Error("getScaleComponent cannot be called before parseScale(). Make sure you have called parseScale or use parseUnitModelWithScale().");
             const n = this.component.scales[t];
             return n && !n.merged ? n : this.parent ? this.parent.getScaleComponent(t) : void 0
         }
         getSelectionComponent(t, n) {
             let i = this.component.selection[t];
-            if (!i && this.parent && (i = this.parent.getSelectionComponent(t, n)), !i) throw new Error(Gce(n));
+            if (!i && this.parent && (i = this.parent.getSelectionComponent(t, n)), !i) throw new Error(ace(n));
             return i
         }
         hasAxisOrientSignalRef() {
             var t, n;
             return ((t = this.component.axes.x) == null ? void 0 : t.some(i => i.hasOrientSignalRef())) || ((n = this.component.axes.y) == null ? void 0 : n.some(i => i.hasOrientSignalRef()))
         }
     }
-    class _8 extends DC {
+    class s9 extends EC {
         vgField(t, n = {}) {
             const i = this.fieldDef(t);
-            if (i) return ie(i, n)
+            if (i) return oe(i, n)
         }
         reduceFieldDef(t, n) {
-            return gde(this.getMapping(), (i, r, s) => {
-                const a = Kr(r);
+            return Rhe(this.getMapping(), (i, r, s) => {
+                const a = hs(r);
                 return a ? t(i, a, s) : i
             }, n)
         }
         forEachFieldDef(t, n) {
-            aC(this.getMapping(), (i, r) => {
-                const s = Kr(i);
+            Kk(this.getMapping(), (i, r) => {
+                const s = hs(i);
                 s && t(s, r)
             }, n)
         }
     }
-    class J1 extends nt {
+    class Ty extends ut {
         clone() {
-            return new J1(null, ke(this.transform))
+            return new Ty(null, Fe(this.transform))
         }
         constructor(t, n) {
-            super(t), this.transform = n, this.transform = ke(n);
+            super(t), this.transform = n, this.transform = Fe(n);
             const i = this.transform.as ?? [void 0, void 0];
             this.transform.as = [i[0] ?? "value", i[1] ?? "density"], n.groupby && n.minsteps == null && n.maxsteps == null && n.steps == null && (this.transform.steps = 200)
         }
         dependentFields() {
             return new Set([this.transform.density, ...this.transform.groupby ?? []])
         }
         producedFields() {
             return new Set(this.transform.as)
         }
         hash() {
-            return `DensityTransform ${Ne(this.transform)}`
+            return `DensityTransform ${ze(this.transform)}`
         }
         assemble() {
             const {
                 density: t,
                 ...n
             } = this.transform;
             return {
                 type: "kde",
                 field: t,
                 ...n
             }
         }
     }
-    class Uh extends nt {
+    class My extends ut {
         clone() {
-            return new Uh(null, {
+            return new My(null, Fe(this.transform))
+        }
+        constructor(t, n) {
+            super(t), this.transform = n, this.transform = Fe(n)
+        }
+        dependentFields() {
+            return new Set([this.transform.extent])
+        }
+        producedFields() {
+            return new Set([])
+        }
+        hash() {
+            return `ExtentTransform ${ze(this.transform)}`
+        }
+        assemble() {
+            const {
+                extent: t,
+                param: n
+            } = this.transform;
+            return {
+                type: "extent",
+                field: t,
+                signal: n
+            }
+        }
+    }
+    class md extends ut {
+        clone() {
+            return new md(null, {
                 ...this.filter
             })
         }
         constructor(t, n) {
             super(t), this.filter = n
         }
         static make(t, n) {
             const {
                 config: i,
                 mark: r,
                 markDef: s
             } = n;
-            if (Xe("invalid", s, i) !== "filter") return null;
+            if (st("invalid", s, i) !== "filter") return null;
             const o = n.reduceFieldDef((l, u, c) => {
-                const f = Qs(c) && n.getScaleComponent(c);
+                const f = ha(c) && n.getScaleComponent(c);
                 if (f) {
                     const h = f.get("type");
-                    wi(h) && u.aggregate !== "count" && !uo(r) && (l[u.field] = u)
+                    Ni(h) && u.aggregate !== "count" && !Mo(r) && (l[u.field] = u)
                 }
                 return l
             }, {});
-            return H(o).length ? new Uh(t, o) : null
+            return K(o).length ? new md(t, o) : null
         }
         dependentFields() {
-            return new Set(H(this.filter))
+            return new Set(K(this.filter))
         }
         producedFields() {
             return new Set
         }
         hash() {
-            return `FilterInvalid ${Ne(this.filter)}`
+            return `FilterInvalid ${ze(this.filter)}`
         }
         assemble() {
-            const t = H(this.filter).reduce((n, i) => {
+            const t = K(this.filter).reduce((n, i) => {
                 const r = this.filter[i],
-                    s = ie(r, {
+                    s = oe(r, {
                         expr: "datum"
                     });
                 return r !== null && (r.type === "temporal" ? n.push(`(isDate(${s}) || (isValid(${s}) && isFinite(+${s})))`) : r.type === "quantitative" && (n.push(`isValid(${s})`), n.push(`isFinite(+${s})`))), n
             }, []);
             return t.length > 0 ? {
                 type: "filter",
                 expr: t.join(" && ")
             } : null
         }
     }
-    class Q1 extends nt {
+    class Oy extends ut {
         clone() {
-            return new Q1(this.parent, ke(this.transform))
+            return new Oy(this.parent, Fe(this.transform))
         }
         constructor(t, n) {
-            super(t), this.transform = n, this.transform = ke(n);
+            super(t), this.transform = n, this.transform = Fe(n);
             const {
                 flatten: i,
                 as: r = []
             } = this.transform;
             this.transform.as = i.map((s, a) => r[a] ?? s)
         }
         dependentFields() {
             return new Set(this.transform.flatten)
         }
         producedFields() {
             return new Set(this.transform.as)
         }
         hash() {
-            return `FlattenTransform ${Ne(this.transform)}`
+            return `FlattenTransform ${ze(this.transform)}`
         }
         assemble() {
             const {
                 flatten: t,
                 as: n
             } = this.transform;
             return {
                 type: "flatten",
                 fields: t,
                 as: n
             }
         }
     }
-    class Z1 extends nt {
+    class Fy extends ut {
         clone() {
-            return new Z1(null, ke(this.transform))
+            return new Fy(null, Fe(this.transform))
         }
         constructor(t, n) {
-            super(t), this.transform = n, this.transform = ke(n);
+            super(t), this.transform = n, this.transform = Fe(n);
             const i = this.transform.as ?? [void 0, void 0];
             this.transform.as = [i[0] ?? "key", i[1] ?? "value"]
         }
         dependentFields() {
             return new Set(this.transform.fold)
         }
         producedFields() {
             return new Set(this.transform.as)
         }
         hash() {
-            return `FoldTransform ${Ne(this.transform)}`
+            return `FoldTransform ${ze(this.transform)}`
         }
         assemble() {
             const {
                 fold: t,
                 as: n
             } = this.transform;
             return {
                 type: "fold",
                 fields: t,
                 as: n
             }
         }
     }
-    class $u extends nt {
+    class Zu extends ut {
         clone() {
-            return new $u(null, ke(this.fields), this.geojson, this.signal)
+            return new Zu(null, Fe(this.fields), this.geojson, this.signal)
         }
         static parseAll(t, n) {
             if (n.component.projection && !n.component.projection.isFit) return t;
             let i = 0;
             for (const r of [
-                    [Sr, wr],
-                    [Li, Er]
+                    [Lr, Pr],
+                    [Qi, Ir]
                 ]) {
                 const s = r.map(a => {
-                    const o = Mt(n.encoding[a]);
-                    return K(o) ? o.field : fs(o) ? {
+                    const o = Yt(n.encoding[a]);
+                    return Z(o) ? o.field : ks(o) ? {
                         expr: `${o.datum}`
-                    } : gr(o) ? {
+                    } : Tr(o) ? {
                         expr: `${o.value}`
                     } : void 0
                 });
-                (s[0] || s[1]) && (t = new $u(t, s, null, n.getName(`geojson_${i++}`)))
+                (s[0] || s[1]) && (t = new Zu(t, s, null, n.getName(`geojson_${i++}`)))
             }
-            if (n.channelHasField(ai)) {
-                const r = n.typedFieldDef(ai);
-                r.type === Rc && (t = new $u(t, null, r.field, n.getName(`geojson_${i++}`)))
+            if (n.channelHasField(mi)) {
+                const r = n.typedFieldDef(mi);
+                r.type === sf && (t = new Zu(t, null, r.field, n.getName(`geojson_${i++}`)))
             }
             return t
         }
         constructor(t, n, i, r) {
             super(t), this.fields = n, this.geojson = i, this.signal = r
         }
         dependentFields() {
-            const t = (this.fields ?? []).filter(re);
+            const t = (this.fields ?? []).filter(le);
             return new Set([...this.geojson ? [this.geojson] : [], ...t])
         }
         producedFields() {
             return new Set
         }
         hash() {
-            return `GeoJSON ${this.geojson} ${this.signal} ${Ne(this.fields)}`
+            return `GeoJSON ${this.geojson} ${this.signal} ${ze(this.fields)}`
         }
         assemble() {
             return [...this.geojson ? [{
                 type: "filter",
                 expr: `isValid(datum["${this.geojson}"])`
             }] : [], {
                 type: "geojson",
@@ -49127,61 +42509,61 @@
                 ...this.geojson ? {
                     geojson: this.geojson
                 } : {},
                 signal: this.signal
             }]
         }
     }
-    class Gh extends nt {
+    class yd extends ut {
         clone() {
-            return new Gh(null, this.projection, ke(this.fields), ke(this.as))
+            return new yd(null, this.projection, Fe(this.fields), Fe(this.as))
         }
         constructor(t, n, i, r) {
             super(t), this.projection = n, this.fields = i, this.as = r
         }
         static parseAll(t, n) {
             if (!n.projectionName()) return t;
             for (const i of [
-                    [Sr, wr],
-                    [Li, Er]
+                    [Lr, Pr],
+                    [Qi, Ir]
                 ]) {
                 const r = i.map(a => {
-                        const o = Mt(n.encoding[a]);
-                        return K(o) ? o.field : fs(o) ? {
+                        const o = Yt(n.encoding[a]);
+                        return Z(o) ? o.field : ks(o) ? {
                             expr: `${o.datum}`
-                        } : gr(o) ? {
+                        } : Tr(o) ? {
                             expr: `${o.value}`
                         } : void 0
                     }),
-                    s = i[0] === Li ? "2" : "";
-                (r[0] || r[1]) && (t = new Gh(t, n.projectionName(), r, [n.getName(`x${s}`), n.getName(`y${s}`)]))
+                    s = i[0] === Qi ? "2" : "";
+                (r[0] || r[1]) && (t = new yd(t, n.projectionName(), r, [n.getName(`x${s}`), n.getName(`y${s}`)]))
             }
             return t
         }
         dependentFields() {
-            return new Set(this.fields.filter(re))
+            return new Set(this.fields.filter(le))
         }
         producedFields() {
             return new Set(this.as)
         }
         hash() {
-            return `Geopoint ${this.projection} ${Ne(this.fields)} ${Ne(this.as)}`
+            return `Geopoint ${this.projection} ${ze(this.fields)} ${ze(this.as)}`
         }
         assemble() {
             return {
                 type: "geopoint",
                 projection: this.projection,
                 fields: this.fields,
                 as: this.as
             }
         }
     }
-    class Xo extends nt {
+    class vl extends ut {
         clone() {
-            return new Xo(null, ke(this.transform))
+            return new vl(null, Fe(this.transform))
         }
         constructor(t, n) {
             super(t), this.transform = n
         }
         dependentFields() {
             return new Set([this.transform.impute, this.transform.key, ...this.transform.groupby ?? []])
         }
@@ -49195,32 +42577,32 @@
                 step: r
             } = t;
             return {
                 signal: `sequence(${[n,i,...r?[r]:[]].join(",")})`
             }
         }
         static makeFromTransform(t, n) {
-            return new Xo(t, n)
+            return new vl(t, n)
         }
         static makeFromEncoding(t, n) {
             const i = n.encoding,
                 r = i.x,
                 s = i.y;
-            if (K(r) && K(s)) {
+            if (Z(r) && Z(s)) {
                 const a = r.impute ? r : s.impute ? s : void 0;
                 if (a === void 0) return;
                 const o = r.impute ? s : s.impute ? r : void 0,
                     {
                         method: l,
                         value: u,
                         frame: c,
                         keyvals: f
                     } = a.impute,
-                    h = B6(n.mark, i);
-                return new Xo(t, {
+                    h = E8(n.mark, i);
+                return new vl(t, {
                     impute: a.field,
                     key: o.field,
                     ...l ? {
                         method: l
                     } : {},
                     ...u !== void 0 ? {
                         value: u
@@ -49235,15 +42617,15 @@
                         groupby: h
                     } : {}
                 })
             }
             return null
         }
         hash() {
-            return `Impute ${Ne(this.transform)}`
+            return `Impute ${ze(this.transform)}`
         }
         assemble() {
             const {
                 impute: t,
                 key: n,
                 keyvals: i,
                 method: r,
@@ -49251,15 +42633,15 @@
                 value: a,
                 frame: o = [null, null]
             } = this.transform, l = {
                 type: "impute",
                 field: t,
                 key: n,
                 ...i ? {
-                    keyvals: hge(i) ? this.processSequence(i) : i
+                    keyvals: Ode(i) ? this.processSequence(i) : i
                 } : {},
                 method: "value",
                 ...s ? {
                     groupby: s
                 } : {},
                 value: !r || r === "value" ? a : null
             };
@@ -49280,31 +42662,31 @@
                         expr: `datum.${t} === null ? datum.imputed_${t}_value : datum.${t}`,
                         as: t
                     };
                 return [l, u, c]
             } else return [l]
         }
     }
-    class ey extends nt {
+    class Ry extends ut {
         clone() {
-            return new ey(null, ke(this.transform))
+            return new Ry(null, Fe(this.transform))
         }
         constructor(t, n) {
-            super(t), this.transform = n, this.transform = ke(n);
+            super(t), this.transform = n, this.transform = Fe(n);
             const i = this.transform.as ?? [void 0, void 0];
             this.transform.as = [i[0] ?? n.on, i[1] ?? n.loess]
         }
         dependentFields() {
             return new Set([this.transform.loess, this.transform.on, ...this.transform.groupby ?? []])
         }
         producedFields() {
             return new Set(this.transform.as)
         }
         hash() {
-            return `LoessTransform ${Ne(this.transform)}`
+            return `LoessTransform ${ze(this.transform)}`
         }
         assemble() {
             const {
                 loess: t,
                 on: n,
                 ...i
             } = this.transform;
@@ -49312,68 +42694,68 @@
                 type: "loess",
                 x: n,
                 y: t,
                 ...i
             }
         }
     }
-    class Wh extends nt {
+    class vd extends ut {
         clone() {
-            return new Wh(null, ke(this.transform), this.secondary)
+            return new vd(null, Fe(this.transform), this.secondary)
         }
         constructor(t, n, i) {
             super(t), this.transform = n, this.secondary = i
         }
         static make(t, n, i, r) {
             const s = n.component.data.sources,
                 {
                     from: a
                 } = i;
             let o = null;
-            if (dge(a)) {
-                let l = E8(a.data, s);
-                l || (l = new yl(a.data), s.push(l));
+            if (Fde(a)) {
+                let l = l9(a.data, s);
+                l || (l = new jl(a.data), s.push(l));
                 const u = n.getName(`lookup_${r}`);
-                o = new Dn(l, u, st.Lookup, n.component.data.outputNodeRefCounts), n.component.data.outputNodes[u] = o
-            } else if (gge(a)) {
+                o = new Xn(l, u, pt.Lookup, n.component.data.outputNodeRefCounts), n.component.data.outputNodes[u] = o
+            } else if (Rde(a)) {
                 const l = a.param;
                 i = {
                     as: l,
                     ...i
                 };
                 let u;
                 try {
-                    u = n.getSelectionComponent(ft(l), l)
+                    u = n.getSelectionComponent(Et(l), l)
                 } catch {
-                    throw new Error(Hce(l))
+                    throw new Error(uce(l))
                 }
-                if (o = u.materialized, !o) throw new Error(Yce(l))
+                if (o = u.materialized, !o) throw new Error(cce(l))
             }
-            return new Wh(t, i, o.getSource())
+            return new vd(t, i, o.getSource())
         }
         dependentFields() {
             return new Set([this.transform.lookup])
         }
         producedFields() {
-            return new Set(this.transform.as ? se(this.transform.as) : this.transform.from.fields)
+            return new Set(this.transform.as ? ue(this.transform.as) : this.transform.from.fields)
         }
         hash() {
-            return `Lookup ${Ne({transform:this.transform,secondary:this.secondary})}`
+            return `Lookup ${ze({transform:this.transform,secondary:this.secondary})}`
         }
         assemble() {
             let t;
             if (this.transform.from.fields) t = {
                 values: this.transform.from.fields,
                 ...this.transform.as ? {
-                    as: se(this.transform.as)
+                    as: ue(this.transform.as)
                 } : {}
             };
             else {
                 let n = this.transform.as;
-                re(n) || (X(tfe), n = "_lookup"), t = {
+                le(n) || (J(vce), n = "_lookup"), t = {
                     as: [n]
                 }
             }
             return {
                 type: "lookup",
                 from: this.secondary,
                 key: this.transform.from.key,
@@ -49381,61 +42763,61 @@
                 ...t,
                 ...this.transform.default ? {
                     default: this.transform.default
                 } : {}
             }
         }
     }
-    class ty extends nt {
+    class Dy extends ut {
         clone() {
-            return new ty(null, ke(this.transform))
+            return new Dy(null, Fe(this.transform))
         }
         constructor(t, n) {
-            super(t), this.transform = n, this.transform = ke(n);
+            super(t), this.transform = n, this.transform = Fe(n);
             const i = this.transform.as ?? [void 0, void 0];
             this.transform.as = [i[0] ?? "prob", i[1] ?? "value"]
         }
         dependentFields() {
             return new Set([this.transform.quantile, ...this.transform.groupby ?? []])
         }
         producedFields() {
             return new Set(this.transform.as)
         }
         hash() {
-            return `QuantileTransform ${Ne(this.transform)}`
+            return `QuantileTransform ${ze(this.transform)}`
         }
         assemble() {
             const {
                 quantile: t,
                 ...n
             } = this.transform;
             return {
                 type: "quantile",
                 field: t,
                 ...n
             }
         }
     }
-    class ny extends nt {
+    class Ny extends ut {
         clone() {
-            return new ny(null, ke(this.transform))
+            return new Ny(null, Fe(this.transform))
         }
         constructor(t, n) {
-            super(t), this.transform = n, this.transform = ke(n);
+            super(t), this.transform = n, this.transform = Fe(n);
             const i = this.transform.as ?? [void 0, void 0];
             this.transform.as = [i[0] ?? n.on, i[1] ?? n.regression]
         }
         dependentFields() {
             return new Set([this.transform.regression, this.transform.on, ...this.transform.groupby ?? []])
         }
         producedFields() {
             return new Set(this.transform.as)
         }
         hash() {
-            return `RegressionTransform ${Ne(this.transform)}`
+            return `RegressionTransform ${ze(this.transform)}`
         }
         assemble() {
             const {
                 regression: t,
                 on: n,
                 ...i
             } = this.transform;
@@ -49443,30 +42825,30 @@
                 type: "regression",
                 x: n,
                 y: t,
                 ...i
             }
         }
     }
-    class iy extends nt {
+    class Py extends ut {
         clone() {
-            return new iy(null, ke(this.transform))
+            return new Py(null, Fe(this.transform))
         }
         constructor(t, n) {
             super(t), this.transform = n
         }
         addDimensions(t) {
-            this.transform.groupby = Pr((this.transform.groupby ?? []).concat(t), n => n)
+            this.transform.groupby = Qr((this.transform.groupby ?? []).concat(t), n => n)
         }
         producedFields() {}
         dependentFields() {
             return new Set([this.transform.pivot, this.transform.value, ...this.transform.groupby ?? []])
         }
         hash() {
-            return `PivotTransform ${Ne(this.transform)}`
+            return `PivotTransform ${ze(this.transform)}`
         }
         assemble() {
             const {
                 pivot: t,
                 value: n,
                 groupby: i,
                 limit: r,
@@ -49484,60 +42866,60 @@
                 } : {},
                 ...i !== void 0 ? {
                     groupby: i
                 } : {}
             }
         }
     }
-    class ry extends nt {
+    class Ly extends ut {
         clone() {
-            return new ry(null, ke(this.transform))
+            return new Ly(null, Fe(this.transform))
         }
         constructor(t, n) {
             super(t), this.transform = n
         }
         dependentFields() {
             return new Set
         }
         producedFields() {
             return new Set
         }
         hash() {
-            return `SampleTransform ${Ne(this.transform)}`
+            return `SampleTransform ${ze(this.transform)}`
         }
         assemble() {
             return {
                 type: "sample",
                 size: this.transform.sample
             }
         }
     }
 
-    function w8(e) {
+    function a9(e) {
         let t = 0;
 
         function n(i, r) {
-            if (i instanceof yl && !i.isGenerator && !oc(i.data) && (e.push(r), r = {
+            if (i instanceof jl && !i.isGenerator && !Rc(i.data) && (e.push(r), r = {
                     name: null,
                     source: r.name,
                     transform: []
-                }), i instanceof gn && (i.parent instanceof yl && !r.source ? (r.format = {
+                }), i instanceof On && (i.parent instanceof jl && !r.source ? (r.format = {
                     ...r.format ?? {},
                     parse: i.assembleFormatParse()
-                }, r.transform.push(...i.assembleTransforms(!0))) : r.transform.push(...i.assembleTransforms())), i instanceof Pc) {
+                }, r.transform.push(...i.assembleTransforms(!0))) : r.transform.push(...i.assembleTransforms())), i instanceof lf) {
                 r.name || (r.name = `data_${t++}`), !r.source || r.transform.length > 0 ? (e.push(r), i.data = r.name) : i.data = r.source, e.push(...i.assemble());
                 return
             }
-            switch ((i instanceof Id || i instanceof zd || i instanceof Uh || i instanceof Nc || i instanceof lc || i instanceof Gh || i instanceof or || i instanceof Wh || i instanceof Lc || i instanceof Bl || i instanceof Z1 || i instanceof Q1 || i instanceof J1 || i instanceof ey || i instanceof ty || i instanceof ny || i instanceof qa || i instanceof ry || i instanceof iy) && r.transform.push(i.assemble()), (i instanceof Ur || i instanceof jr || i instanceof Xo || i instanceof Ps || i instanceof $u) && r.transform.push(...i.assemble()), i instanceof Dn && (r.source && r.transform.length === 0 ? i.setSource(r.source) : i.parent instanceof Dn ? i.setSource(r.name) : (r.name || (r.name = `data_${t++}`), i.setSource(r.name), i.numChildren() === 1 && (e.push(r), r = {
+            switch ((i instanceof gg || i instanceof pg || i instanceof md || i instanceof of || i instanceof Nc || i instanceof yd || i instanceof Er || i instanceof vd || i instanceof uf || i instanceof ou || i instanceof Fy || i instanceof Oy || i instanceof Ty || i instanceof Ry || i instanceof Dy || i instanceof Ny || i instanceof go || i instanceof Ly || i instanceof Py || i instanceof My) && r.transform.push(i.assemble()), (i instanceof rs || i instanceof is || i instanceof vl || i instanceof Qs || i instanceof Zu) && r.transform.push(...i.assemble()), i instanceof Xn && (r.source && r.transform.length === 0 ? i.setSource(r.source) : i.parent instanceof Xn ? i.setSource(r.name) : (r.name || (r.name = `data_${t++}`), i.setSource(r.name), i.numChildren() === 1 && (e.push(r), r = {
                     name: null,
                     source: r.name,
                     transform: []
                 }))), i.numChildren()) {
                 case 0:
-                    i instanceof Dn && (!r.source || r.transform.length > 0) && e.push(r);
+                    i instanceof Xn && (!r.source || r.transform.length > 0) && e.push(r);
                     break;
                 case 1:
                     n(i.children[0], r);
                     break;
                 default: {
                     r.name || (r.name = `data_${t++}`);
                     let s = r.name;
@@ -49550,28 +42932,28 @@
                     break
                 }
             }
         }
         return n
     }
 
-    function Eme(e) {
+    function Wme(e) {
         const t = [],
-            n = w8(t);
+            n = a9(t);
         for (const i of e.children) n(i, {
             source: e.name,
             name: null,
             transform: []
         });
         return t
     }
 
-    function Cme(e, t) {
+    function qme(e, t) {
         const n = [],
-            i = w8(n);
+            i = a9(n);
         let r = 0;
         for (const a of e.sources) {
             a.hasName() || (a.dataName = `source_${r++}`);
             const o = a.assemble();
             i(a, o)
         }
         for (const a of n) a.transform.length === 0 && delete a.transform;
@@ -49579,241 +42961,241 @@
         for (const [a, o] of n.entries())(o.transform ?? []).length === 0 && !o.source && n.splice(s++, 0, n.splice(a, 1)[0]);
         for (const a of n)
             for (const o of a.transform ?? []) o.type === "lookup" && (o.from = e.outputNodes[o.from].getSource());
         for (const a of n) a.name in t && (a.values = t[a.name]);
         return n
     }
 
-    function kme(e) {
-        return e === "top" || e === "left" || he(e) ? "header" : "footer"
+    function Hme(e) {
+        return e === "top" || e === "left" || xe(e) ? "header" : "footer"
     }
 
-    function Ame(e) {
-        for (const t of Ti) $me(e, t);
-        C3(e, "x"), C3(e, "y")
+    function Yme(e) {
+        for (const t of Ui) Xme(e, t);
+        XM(e, "x"), XM(e, "y")
     }
 
-    function $me(e, t) {
+    function Xme(e, t) {
         var a;
         const {
             facet: n,
             config: i,
             child: r,
             component: s
         } = e;
         if (e.channelHasField(t)) {
             const o = n[t],
-                l = cc("title", null, i, t);
-            let u = ku(o, i, {
+                l = Lc("title", null, i, t);
+            let u = Ju(o, i, {
                 allowDisabling: !0,
                 includeDefault: l === void 0 || !!l
             });
-            r.component.layoutHeaders[t].title && (u = W(u) ? u.join(", ") : u, u += ` / ${r.component.layoutHeaders[t].title}`, r.component.layoutHeaders[t].title = null);
-            const c = cc("labelOrient", o.header, i, t),
-                f = o.header !== null ? Ct((a = o.header) == null ? void 0 : a.labels, i.header.labels, !0) : !1,
-                h = Fe(["bottom", "right"], c) ? "footer" : "header";
+            r.component.layoutHeaders[t].title && (u = H(u) ? u.join(", ") : u, u += ` / ${r.component.layoutHeaders[t].title}`, r.component.layoutHeaders[t].title = null);
+            const c = Lc("labelOrient", o.header, i, t),
+                f = o.header !== null ? Gt((a = o.header) == null ? void 0 : a.labels, i.header.labels, !0) : !1,
+                h = Be(["bottom", "right"], c) ? "footer" : "header";
             s.layoutHeaders[t] = {
                 title: o.header !== null ? u : null,
                 facetFieldDef: o,
-                [h]: t === "facet" ? [] : [S8(e, t, f)]
+                [h]: t === "facet" ? [] : [o9(e, t, f)]
             }
         }
     }
 
-    function S8(e, t, n) {
+    function o9(e, t, n) {
         const i = t === "row" ? "height" : "width";
         return {
             labels: n,
             sizeSignal: e.child.component.layoutSize.get(i) ? e.child.getSizeSignalRef(i) : void 0,
             axes: []
         }
     }
 
-    function C3(e, t) {
+    function XM(e, t) {
         const {
             child: n
         } = e;
         if (n.component.axes[t]) {
             const {
                 layoutHeaders: i,
                 resolve: r
             } = e.component;
-            if (r.axis[t] = AC(r, t), r.axis[t] === "shared") {
+            if (r.axis[t] = yC(r, t), r.axis[t] === "shared") {
                 const s = t === "x" ? "column" : "row",
                     a = i[s];
                 for (const o of n.component.axes[t]) {
-                    const l = kme(o.get("orient"));
-                    a[l] ?? (a[l] = [S8(e, s, !1)]);
-                    const u = Gf(o, "main", e.config, {
+                    const l = Hme(o.get("orient"));
+                    a[l] ?? (a[l] = [o9(e, s, !1)]);
+                    const u = gh(o, "main", e.config, {
                         header: !0
                     });
                     u && a[l][0].axes.push(u), o.mainExtracted = !0
                 }
             }
         }
     }
 
-    function Tme(e) {
-        NC(e), K0(e, "width"), K0(e, "height")
+    function Vme(e) {
+        kC(e), O0(e, "width"), O0(e, "height")
     }
 
-    function Mme(e) {
-        NC(e);
+    function Kme(e) {
+        kC(e);
         const t = e.layout.columns === 1 ? "width" : "childWidth",
             n = e.layout.columns === void 0 ? "height" : "childHeight";
-        K0(e, t), K0(e, n)
+        O0(e, t), O0(e, n)
     }
 
-    function NC(e) {
+    function kC(e) {
         for (const t of e.children) t.parseLayoutSize()
     }
 
-    function K0(e, t) {
-        const n = Vz(t),
-            i = k1(n),
+    function O0(e, t) {
+        const n = Rz(t),
+            i = ry(n),
             r = e.component.resolve,
             s = e.component.layoutSize;
         let a;
         for (const o of e.children) {
             const l = o.component.layoutSize.getWithExplicit(n),
-                u = r.scale[i] ?? Jz(i, e);
+                u = r.scale[i] ?? Nz(i, e);
             if (u === "independent" && l.value === "step") {
                 a = void 0;
                 break
             }
             if (a) {
                 if (u === "independent" && a.value !== l.value) {
                     a = void 0;
                     break
                 }
-                a = Ua(a, l, n, "")
+                a = co(a, l, n, "")
             } else a = l
         }
         if (a) {
             for (const o of e.children) e.renameSignal(o.getName(n), e.getName(t)), o.component.layoutSize.set(n, "merged", !1);
             s.setWithExplicit(t, a)
         } else s.setWithExplicit(t, {
             explicit: !1,
             value: void 0
         })
     }
 
-    function Ome(e) {
+    function Jme(e) {
         const {
             size: t,
             component: n
         } = e;
-        for (const i of cs) {
-            const r = oi(i);
+        for (const i of Es) {
+            const r = yi(i);
             if (t[r]) {
                 const s = t[r];
-                n.layoutSize.set(r, Jr(s) ? "step" : s, !0)
+                n.layoutSize.set(r, ds(s) ? "step" : s, !0)
             } else {
-                const s = Fme(e, r);
+                const s = Qme(e, r);
                 n.layoutSize.set(r, s, !1)
             }
         }
     }
 
-    function Fme(e, t) {
+    function Qme(e, t) {
         const n = t === "width" ? "x" : "y",
             i = e.config,
             r = e.getScaleComponent(n);
         if (r) {
             const s = r.get("type"),
                 a = r.get("range");
-            if (qt(s)) {
-                const o = H0(i.view, t);
-                return lo(a) || Jr(o) ? "step" : o
-            } else return Z2(i.view, t)
+            if (fn(s)) {
+                const o = A0(i.view, t);
+                return To(a) || ds(o) ? "step" : o
+            } else return Mx(i.view, t)
         } else {
-            if (e.hasProjection || e.mark === "arc") return Z2(i.view, t); {
-                const s = H0(i.view, t);
-                return Jr(s) ? s.step : s
+            if (e.hasProjection || e.mark === "arc") return Mx(i.view, t); {
+                const s = A0(i.view, t);
+                return ds(s) ? s.step : s
             }
         }
     }
 
-    function dx(e, t, n) {
-        return ie(t, {
-            suffix: `by_${ie(e)}`,
+    function Wx(e, t, n) {
+        return oe(t, {
+            suffix: `by_${oe(e)}`,
             ...n ?? {}
         })
     }
-    class uh extends _8 {
+    class Lh extends s9 {
         constructor(t, n, i, r) {
-            super(t, "facet", n, i, r, t.resolve), this.child = BC(t.spec, this, this.getName("child"), void 0, r), this.children = [this.child], this.facet = this.initFacet(t.facet)
+            super(t, "facet", n, i, r, t.resolve), this.child = MC(t.spec, this, this.getName("child"), void 0, r), this.children = [this.child], this.facet = this.initFacet(t.facet)
         }
         initFacet(t) {
-            if (!Rd(t)) return {
+            if (!ug(t)) return {
                 facet: this.initFacetFieldDef(t, "facet")
             };
-            const n = H(t),
+            const n = K(t),
                 i = {};
             for (const r of n) {
-                if (![Fs, Rs].includes(r)) {
-                    X(T1(r, "facet"));
+                if (![Vs, Ks].includes(r)) {
+                    J(oy(r, "facet"));
                     break
                 }
                 const s = t[r];
                 if (s.field === void 0) {
-                    X(Y2(s, r));
+                    J(Ex(s, r));
                     break
                 }
                 i[r] = this.initFacetFieldDef(s, r)
             }
             return i
         }
         initFacetFieldDef(t, n) {
-            const i = rC(t, n);
-            return i.header ? i.header = Hn(i.header) : i.header === null && (i.header = null), i
+            const i = Xk(t, n);
+            return i.header ? i.header = ii(i.header) : i.header === null && (i.header = null), i
         }
         channelHasField(t) {
             return !!this.facet[t]
         }
         fieldDef(t) {
             return this.facet[t]
         }
         parseData() {
-            this.component.data = sy(this), this.child.parseData()
+            this.component.data = Iy(this), this.child.parseData()
         }
         parseLayoutSize() {
-            NC(this)
+            kC(this)
         }
         parseSelections() {
             this.child.parseSelections(), this.component.selection = this.child.component.selection
         }
         parseMarkGroup() {
             this.child.parseMarkGroup()
         }
         parseAxesAndHeaders() {
-            this.child.parseAxesAndHeaders(), Ame(this)
+            this.child.parseAxesAndHeaders(), Yme(this)
         }
         assembleSelectionTopLevelSignals(t) {
             return this.child.assembleSelectionTopLevelSignals(t)
         }
         assembleSignals() {
             return this.child.assembleSignals(), []
         }
         assembleSelectionData(t) {
             return this.child.assembleSelectionData(t)
         }
         getHeaderLayoutMixins() {
             const t = {};
-            for (const n of Ti)
-                for (const i of CC) {
+            for (const n of Ui)
+                for (const i of pC) {
                     const r = this.component.layoutHeaders[n],
                         s = r[i],
                         {
                             facetFieldDef: a
                         } = r;
                     if (a) {
-                        const o = cc("titleOrient", a.header, this.config, n);
+                        const o = Lc("titleOrient", a.header, this.config, n);
                         if (["right", "bottom"].includes(o)) {
-                            const l = X1(n, o);
+                            const l = Cy(n, o);
                             t.titleAnchor ?? (t.titleAnchor = {}), t.titleAnchor[l] = "end"
                         }
                     }
                     if (s != null && s[0]) {
                         const o = n === "row" ? "height" : "width",
                             l = i === "header" ? "headerBand" : "footerBand";
                         n !== "facet" && !this.child.component.layoutSize.get(o) && (t[l] ?? (t[l] = {}), t[l][n] = .5), r.title && (t.offset ?? (t.offset = {}), t.offset[n === "row" ? "rowTitle" : "columnTitle"] = 10)
@@ -49836,54 +43218,54 @@
                 align: r
             }
         }
         assembleLayoutSignals() {
             return this.child.assembleLayoutSignals()
         }
         columnDistinctSignal() {
-            if (!(this.parent && this.parent instanceof uh)) return {
+            if (!(this.parent && this.parent instanceof Lh)) return {
                 signal: `length(data('${this.getName("column_domain")}'))`
             }
         }
         assembleGroupStyle() {}
         assembleGroup(t) {
-            return this.parent && this.parent instanceof uh ? {
+            return this.parent && this.parent instanceof Lh ? {
                 ...this.channelHasField("column") ? {
                     encode: {
                         update: {
                             columns: {
-                                field: ie(this.facet.column, {
+                                field: oe(this.facet.column, {
                                     prefix: "distinct"
                                 })
                             }
                         }
                     }
                 } : {},
                 ...super.assembleGroup(t)
             } : super.assembleGroup(t)
         }
         getCardinalityAggregateForChild() {
             const t = [],
                 n = [],
                 i = [];
-            if (this.child instanceof uh) {
+            if (this.child instanceof Lh) {
                 if (this.child.channelHasField("column")) {
-                    const r = ie(this.child.facet.column);
+                    const r = oe(this.child.facet.column);
                     t.push(r), n.push("distinct"), i.push(`distinct_${r}`)
                 }
             } else
-                for (const r of cs) {
+                for (const r of Es) {
                     const s = this.child.component.scales[r];
                     if (s && !s.merged) {
                         const a = s.get("type"),
                             o = s.get("range");
-                        if (qt(a) && lo(o)) {
-                            const l = K1(this.child, r),
-                                u = FC(l);
-                            u ? (t.push(u), n.push("distinct"), i.push(`distinct_${u}`)) : X(RE(r))
+                        if (fn(a) && To(o)) {
+                            const l = $y(this.child, r),
+                                u = wC(l);
+                            u ? (t.push(u), n.push("distinct"), i.push(`distinct_${u}`)) : J(wk(r))
                         }
                     }
                 }
             return {
                 fields: t,
                 ops: n,
                 as: i
@@ -49897,32 +43279,32 @@
                 row: i,
                 column: r
             } = this.facet, {
                 fields: s,
                 ops: a,
                 as: o
             } = this.getCardinalityAggregateForChild(), l = [];
-            for (const c of Ti) {
+            for (const c of Ui) {
                 const f = this.facet[c];
                 if (f) {
-                    l.push(ie(f));
+                    l.push(oe(f));
                     const {
                         bin: h,
                         sort: d
                     } = f;
-                    if (ot(h) && l.push(ie(f, {
+                    if (yt(h) && l.push(oe(f, {
                             binSuffix: "end"
-                        })), Br(d)) {
+                        })), ns(d)) {
                         const {
                             field: g,
-                            op: p = N1
-                        } = d, m = dx(f, d);
+                            op: p = dy
+                        } = d, m = Wx(f, d);
                         i && r ? (s.push(m), a.push("max"), o.push(m)) : (s.push(g), a.push(p), o.push(m))
-                    } else if (W(d)) {
-                        const g = uc(f, c);
+                    } else if (H(d)) {
+                        const g = Pc(f, c);
                         s.push(g), a.push("max"), o.push(g)
                     }
                 }
             }
             const u = !!i && !!r;
             return {
                 name: t,
@@ -49942,269 +43324,270 @@
                 } : {}
             }
         }
         facetSortFields(t) {
             const {
                 facet: n
             } = this, i = n[t];
-            return i ? Br(i.sort) ? [dx(i, i.sort, {
+            return i ? ns(i.sort) ? [Wx(i, i.sort, {
                 expr: "datum"
-            })] : W(i.sort) ? [uc(i, t, {
+            })] : H(i.sort) ? [Pc(i, t, {
                 expr: "datum"
-            })] : [ie(i, {
+            })] : [oe(i, {
                 expr: "datum"
             })] : []
         }
         facetSortOrder(t) {
             const {
                 facet: n
             } = this, i = n[t];
             if (i) {
                 const {
                     sort: r
                 } = i;
-                return [(Br(r) ? r.order : !W(r) && r) || "ascending"]
+                return [(ns(r) ? r.order : !H(r) && r) || "ascending"]
             }
             return []
         }
         assembleLabelTitle() {
             var r;
             const {
                 facet: t,
                 config: n
             } = this;
-            if (t.facet) return ox(t.facet, "facet", n);
+            if (t.facet) return Ix(t.facet, "facet", n);
             const i = {
                 row: ["top", "bottom"],
                 column: ["left", "right"]
             };
-            for (const s of EC)
+            for (const s of gC)
                 if (t[s]) {
-                    const a = cc("labelOrient", (r = t[s]) == null ? void 0 : r.header, n, s);
-                    if (i[s].includes(a)) return ox(t[s], s, n)
+                    const a = Lc("labelOrient", (r = t[s]) == null ? void 0 : r.header, n, s);
+                    if (i[s].includes(a)) return Ix(t[s], s, n)
                 }
         }
         assembleMarks() {
             const {
                 child: t
-            } = this, n = this.component.data.facetRoot, i = Eme(n), r = t.assembleGroupEncodeEntry(!1), s = this.assembleLabelTitle() || t.assembleTitle(), a = t.assembleGroupStyle();
+            } = this, n = this.component.data.facetRoot, i = Wme(n), r = t.assembleGroupEncodeEntry(!1), s = this.assembleLabelTitle() || t.assembleTitle(), a = t.assembleGroupStyle();
             return [{
                 name: this.getName("cell"),
                 type: "group",
                 ...s ? {
                     title: s
                 } : {},
                 ...a ? {
                     style: a
                 } : {},
                 from: {
                     facet: this.assembleFacet()
                 },
                 sort: {
-                    field: Ti.map(l => this.facetSortFields(l)).flat(),
-                    order: Ti.map(l => this.facetSortOrder(l)).flat()
+                    field: Ui.map(l => this.facetSortFields(l)).flat(),
+                    order: Ui.map(l => this.facetSortOrder(l)).flat()
                 },
                 ...i.length > 0 ? {
                     data: i
                 } : {},
                 ...r ? {
                     encode: {
                         update: r
                     }
                 } : {},
-                ...t.assembleGroup(Gge(this, []))
+                ...t.assembleGroup(uge(this, []))
             }]
         }
         getMapping() {
             return this.facet
         }
     }
 
-    function Rme(e, t) {
+    function Zme(e, t) {
         const {
             row: n,
             column: i
         } = t;
         if (n && i) {
             let r = null;
             for (const s of [n, i])
-                if (Br(s.sort)) {
+                if (ns(s.sort)) {
                     const {
                         field: a,
-                        op: o = N1
+                        op: o = dy
                     } = s.sort;
-                    e = r = new Bl(e, {
+                    e = r = new ou(e, {
                         joinaggregate: [{
                             op: o,
                             field: a,
-                            as: dx(s, s.sort, {
+                            as: Wx(s, s.sort, {
                                 forAs: !0
                             })
                         }],
-                        groupby: [ie(s)]
+                        groupby: [oe(s)]
                     })
                 } return r
         }
         return null
     }
 
-    function E8(e, t) {
+    function l9(e, t) {
         var n, i, r, s;
         for (const a of t) {
             const o = a.data;
             if (e.name && a.hasName() && e.name !== a.dataName) continue;
             const l = (n = e.format) == null ? void 0 : n.mesh,
                 u = (i = o.format) == null ? void 0 : i.feature;
             if (l && u) continue;
             const c = (r = e.format) == null ? void 0 : r.feature;
             if ((c || u) && c !== u) continue;
             const f = (s = o.format) == null ? void 0 : s.mesh;
             if (!((l || f) && l !== f)) {
-                if (Bh(e) && Bh(o)) {
-                    if (Nr(e.values, o.values)) return a
-                } else if (oc(e) && oc(o)) {
+                if (pd(e) && pd(o)) {
+                    if (Jr(e.values, o.values)) return a
+                } else if (Rc(e) && Rc(o)) {
                     if (e.url === o.url) return a
-                } else if (pz(e) && e.name === a.dataName) return a
+                } else if (Z8(e) && e.name === a.dataName) return a
             }
         }
         return null
     }
 
-    function Dme(e, t) {
+    function e0e(e, t) {
         if (e.data || !e.parent) {
             if (e.data === null) {
-                const i = new yl({
+                const i = new jl({
                     values: []
                 });
                 return t.push(i), i
             }
-            const n = E8(e.data, t);
-            if (n) return $a(e.data) || (n.data.format = dI({}, e.data.format, n.data.format)), !n.hasName() && e.data.name && (n.dataName = e.data.name), n; {
-                const i = new yl(e.data);
+            const n = l9(e.data, t);
+            if (n) return Xa(e.data) || (n.data.format = VI({}, e.data.format, n.data.format)), !n.hasName() && e.data.name && (n.dataName = e.data.name), n; {
+                const i = new jl(e.data);
                 return t.push(i), i
             }
         } else return e.parent.component.data.facetRoot ? e.parent.component.data.facetRoot : e.parent.component.data.main
     }
 
-    function Nme(e, t, n) {
+    function t0e(e, t, n) {
         let i = 0;
         for (const r of t.transforms) {
             let s, a;
-            if (Ege(r)) a = e = new lc(e, r), s = "derived";
-            else if (yC(r)) {
-                const o = k0e(r);
-                a = e = gn.makeWithAncestors(e, {}, o, n) ?? e, e = new Nc(e, t, r.filter)
-            } else if (cz(r)) a = e = Ur.makeFromTransform(e, r, t), s = "number";
-            else if (kge(r)) s = "date", n.getWithExplicit(r.field).value === void 0 && (e = new gn(e, {
+            if (Ude(r)) a = e = new Nc(e, r), s = "derived";
+            else if (oC(r)) {
+                const o = Hpe(r);
+                a = e = On.makeWithAncestors(e, {}, o, n) ?? e, e = new of(e, t, r.filter)
+            } else if (X8(r)) a = e = rs.makeFromTransform(e, r, t), s = "number";
+            else if (qde(r)) s = "date", n.getWithExplicit(r.field).value === void 0 && (e = new On(e, {
                 [r.field]: s
-            }), n.set(r.field, s, !1)), a = e = jr.makeFromTransform(e, r);
-            else if (Age(r)) a = e = or.makeFromTransform(e, r), s = "number", SC(t) && (e = new qa(e));
-            else if (uz(r)) a = e = Wh.make(e, t, r, i++), s = "derived";
-            else if (_ge(r)) a = e = new Lc(e, r), s = "number";
-            else if (wge(r)) a = e = new Bl(e, r), s = "number";
-            else if ($ge(r)) a = e = Ps.makeFromTransform(e, r), s = "derived";
-            else if (Tge(r)) a = e = new Z1(e, r), s = "derived";
-            else if (Sge(r)) a = e = new Q1(e, r), s = "derived";
-            else if (pge(r)) a = e = new iy(e, r), s = "derived";
-            else if (xge(r)) e = new ry(e, r);
-            else if (Cge(r)) a = e = Xo.makeFromTransform(e, r), s = "derived";
-            else if (mge(r)) a = e = new J1(e, r), s = "derived";
-            else if (yge(r)) a = e = new ty(e, r), s = "derived";
-            else if (vge(r)) a = e = new ny(e, r), s = "derived";
-            else if (bge(r)) a = e = new ey(e, r), s = "derived";
+            }), n.set(r.field, s, !1)), a = e = is.makeFromTransform(e, r);
+            else if (Hde(r)) a = e = Er.makeFromTransform(e, r), s = "number", dC(t) && (e = new go(e));
+            else if (Y8(r)) a = e = vd.make(e, t, r, i++), s = "derived";
+            else if (Bde(r)) a = e = new uf(e, r), s = "number";
+            else if (jde(r)) a = e = new ou(e, r), s = "number";
+            else if (Yde(r)) a = e = Qs.makeFromTransform(e, r), s = "derived";
+            else if (Xde(r)) a = e = new Fy(e, r), s = "derived";
+            else if (Vde(r)) a = e = new My(e, r), s = "derived";
+            else if (Gde(r)) a = e = new Oy(e, r), s = "derived";
+            else if (Dde(r)) a = e = new Py(e, r), s = "derived";
+            else if (zde(r)) e = new Ly(e, r);
+            else if (Wde(r)) a = e = vl.makeFromTransform(e, r), s = "derived";
+            else if (Nde(r)) a = e = new Ty(e, r), s = "derived";
+            else if (Pde(r)) a = e = new Dy(e, r), s = "derived";
+            else if (Lde(r)) a = e = new Ny(e, r), s = "derived";
+            else if (Ide(r)) a = e = new Ry(e, r), s = "derived";
             else {
-                X(efe(r));
+                J(yce(r));
                 continue
             }
             if (a && s !== void 0)
                 for (const o of a.producedFields() ?? []) n.set(o, s, !1)
         }
         return e
     }
 
-    function sy(e) {
+    function Iy(e) {
         var p;
-        let t = Dme(e, e.component.data.sources);
+        let t = e0e(e, e.component.data.sources);
         const {
             outputNodes: n,
             outputNodeRefCounts: i
-        } = e.component.data, r = e.data, a = !(r && ($a(r) || oc(r) || Bh(r))) && e.parent ? e.parent.component.data.ancestorParse.clone() : new jge;
-        $a(r) ? (mz(r) ? t = new zd(t, r.sequence) : vC(r) && (t = new Id(t, r.graticule)), a.parseNothing = !0) : ((p = r == null ? void 0 : r.format) == null ? void 0 : p.parse) === null && (a.parseNothing = !0), t = gn.makeExplicit(t, e, a) ?? t, t = new qa(t);
-        const o = e.parent && Ic(e.parent);
-        (Et(e) || lr(e)) && o && (t = Ur.makeFromEncoding(t, e) ?? t), e.transforms.length > 0 && (t = Nme(t, e, a));
-        const l = $0e(e),
-            u = A0e(e);
-        t = gn.makeWithAncestors(t, {}, {
+        } = e.component.data, r = e.data, a = !(r && (Xa(r) || Rc(r) || pd(r))) && e.parent ? e.parent.component.data.ancestorParse.clone() : new oge;
+        Xa(r) ? (ez(r) ? t = new pg(t, r.sequence) : lC(r) && (t = new gg(t, r.graticule)), a.parseNothing = !0) : ((p = r == null ? void 0 : r.format) == null ? void 0 : p.parse) === null && (a.parseNothing = !0), t = On.makeExplicit(t, e, a) ?? t, t = new go(t);
+        const o = e.parent && cf(e.parent);
+        (Dt(e) || kr(e)) && o && (t = rs.makeFromEncoding(t, e) ?? t), e.transforms.length > 0 && (t = t0e(t, e, a));
+        const l = Xpe(e),
+            u = Ype(e);
+        t = On.makeWithAncestors(t, {}, {
             ...l,
             ...u
-        }, a) ?? t, Et(e) && (t = $u.parseAll(t, e), t = Gh.parseAll(t, e)), (Et(e) || lr(e)) && (o || (t = Ur.makeFromEncoding(t, e) ?? t), t = jr.makeFromEncoding(t, e) ?? t, t = lc.parseAllForSortIndex(t, e));
-        const c = e.getDataName(st.Raw),
-            f = new Dn(t, c, st.Raw, i);
-        if (n[c] = f, t = f, Et(e)) {
-            const m = or.makeFromEncoding(t, e);
-            m && (t = m, SC(e) && (t = new qa(t))), t = Xo.makeFromEncoding(t, e) ?? t, t = Ps.makeFromEncoding(t, e) ?? t
-        }
-        Et(e) && (t = Uh.make(t, e) ?? t);
-        const h = e.getDataName(st.Main),
-            d = new Dn(t, h, st.Main, i);
-        n[h] = d, t = d, Et(e) && Spe(e, d);
+        }, a) ?? t, Dt(e) && (t = Zu.parseAll(t, e), t = yd.parseAll(t, e)), (Dt(e) || kr(e)) && (o || (t = rs.makeFromEncoding(t, e) ?? t), t = is.makeFromEncoding(t, e) ?? t, t = Nc.parseAllForSortIndex(t, e));
+        const c = e.getDataName(pt.Raw),
+            f = new Xn(t, c, pt.Raw, i);
+        if (n[c] = f, t = f, Dt(e)) {
+            const m = Er.makeFromEncoding(t, e);
+            m && (t = m, dC(e) && (t = new go(t))), t = vl.makeFromEncoding(t, e) ?? t, t = Qs.makeFromEncoding(t, e) ?? t
+        }
+        Dt(e) && (t = md.make(t, e) ?? t);
+        const h = e.getDataName(pt.Main),
+            d = new Xn(t, h, pt.Main, i);
+        n[h] = d, t = d, Dt(e) && Uge(e, d);
         let g = null;
-        if (lr(e)) {
+        if (kr(e)) {
             const m = e.getName("facet");
-            t = Rme(t, e.facet) ?? t, g = new Pc(t, e, m, d.getSource()), n[m] = g
+            t = Zme(t, e.facet) ?? t, g = new lf(t, e, m, d.getSource()), n[m] = g
         }
         return {
             ...e.component.data,
             outputNodes: n,
             outputNodeRefCounts: i,
             raw: f,
             main: d,
             facetRoot: g,
             ancestorParse: a
         }
     }
-    class Pme extends DC {
+    class n0e extends EC {
         constructor(t, n, i, r) {
             var s, a, o, l;
-            super(t, "concat", n, i, r, t.resolve), (((a = (s = t.resolve) == null ? void 0 : s.axis) == null ? void 0 : a.x) === "shared" || ((l = (o = t.resolve) == null ? void 0 : o.axis) == null ? void 0 : l.y) === "shared") && X(Jce), this.children = this.getChildren(t).map((u, c) => BC(u, this, this.getName(`concat_${c}`), void 0, r))
+            super(t, "concat", n, i, r, t.resolve), (((a = (s = t.resolve) == null ? void 0 : s.axis) == null ? void 0 : a.x) === "shared" || ((l = (o = t.resolve) == null ? void 0 : o.axis) == null ? void 0 : l.y) === "shared") && J(gce), this.children = this.getChildren(t).map((u, c) => MC(u, this, this.getName(`concat_${c}`), void 0, r))
         }
         parseData() {
-            this.component.data = sy(this);
+            this.component.data = Iy(this);
             for (const t of this.children) t.parseData()
         }
         parseSelections() {
             this.component.selection = {};
             for (const t of this.children) {
                 t.parseSelections();
-                for (const n of H(t.component.selection)) this.component.selection[n] = t.component.selection[n]
+                for (const n of K(t.component.selection)) this.component.selection[n] = t.component.selection[n]
             }
         }
         parseMarkGroup() {
             for (const t of this.children) t.parseMarkGroup()
         }
         parseAxesAndHeaders() {
             for (const t of this.children) t.parseAxesAndHeaders()
         }
         getChildren(t) {
-            return G1(t) ? t.vconcat : pC(t) ? t.hconcat : t.concat
+            return _y(t) ? t.vconcat : sC(t) ? t.hconcat : t.concat
         }
         parseLayoutSize() {
-            Mme(this)
+            Kme(this)
         }
         parseAxisGroup() {
             return null
         }
         assembleSelectionTopLevelSignals(t) {
             return this.children.reduce((n, i) => i.assembleSelectionTopLevelSignals(n), t)
         }
         assembleSignals() {
             return this.children.forEach(t => t.assembleSignals()), []
         }
         assembleLayoutSignals() {
-            const t = kC(this);
+            const t = mC(this);
             for (const n of this.children) t.push(...n.assembleLayoutSignals());
             return t
         }
         assembleSelectionData(t) {
             return this.children.reduce((n, i) => i.assembleSelectionData(n), t)
         }
         assembleMarks() {
@@ -50239,413 +43622,413 @@
                 } : {},
                 bounds: "full",
                 align: "each"
             }
         }
     }
 
-    function Lme(e) {
+    function i0e(e) {
         return e === !1 || e === null
     }
-    const Ime = {
+    const r0e = {
             disable: 1,
             gridScale: 1,
             scale: 1,
-            ...P6,
+            ...x8,
             labelExpr: 1,
             encode: 1
         },
-        C8 = H(Ime);
-    class PC extends ea {
+        u9 = K(r0e);
+    class CC extends ga {
         constructor(t = {}, n = {}, i = !1) {
             super(), this.explicit = t, this.implicit = n, this.mainExtracted = i
         }
         clone() {
-            return new PC(ke(this.explicit), ke(this.implicit), this.mainExtracted)
+            return new CC(Fe(this.explicit), Fe(this.implicit), this.mainExtracted)
         }
         hasAxisPart(t) {
-            return t === "axis" ? !0 : t === "grid" || t === "title" ? !!this.get(t) : !Lme(this.get(t))
+            return t === "axis" ? !0 : t === "grid" || t === "title" ? !!this.get(t) : !i0e(this.get(t))
         }
         hasOrientSignalRef() {
-            return he(this.explicit.orient)
+            return xe(this.explicit.orient)
         }
     }
 
-    function zme(e, t, n) {
+    function s0e(e, t, n) {
         const {
             encoding: i,
             config: r
-        } = e, s = Mt(i[t]) ?? Mt(i[us(t)]), a = e.axis(t) || {}, {
+        } = e, s = Yt(i[t]) ?? Yt(i[Ss(t)]), a = e.axis(t) || {}, {
             format: o,
             formatType: l
         } = a;
-        if (gl(l)) return {
-            text: rr({
+        if (Il(l)) return {
+            text: _r({
                 fieldOrDatumDef: s,
                 field: "datum.value",
                 format: o,
                 formatType: l,
                 config: r
             }),
             ...n
         };
         if (o === void 0 && l === void 0 && r.customFormatTypes) {
-            if (rc(s) === "quantitative") {
-                if (sc(s) && s.stack === "normalize" && r.normalizedNumberFormatType) return {
-                    text: rr({
+            if (Mc(s) === "quantitative") {
+                if (Oc(s) && s.stack === "normalize" && r.normalizedNumberFormatType) return {
+                    text: _r({
                         fieldOrDatumDef: s,
                         field: "datum.value",
                         format: r.normalizedNumberFormat,
                         formatType: r.normalizedNumberFormatType,
                         config: r
                     }),
                     ...n
                 };
                 if (r.numberFormatType) return {
-                    text: rr({
+                    text: _r({
                         fieldOrDatumDef: s,
                         field: "datum.value",
                         format: r.numberFormat,
                         formatType: r.numberFormatType,
                         config: r
                     }),
                     ...n
                 }
             }
-            if (rc(s) === "temporal" && r.timeFormatType && K(s) && !s.timeUnit) return {
-                text: rr({
+            if (Mc(s) === "temporal" && r.timeFormatType && Z(s) && !s.timeUnit) return {
+                text: _r({
                     fieldOrDatumDef: s,
                     field: "datum.value",
                     format: r.timeFormat,
                     formatType: r.timeFormatType,
                     config: r
                 }),
                 ...n
             }
         }
         return n
     }
 
-    function Bme(e) {
-        return cs.reduce((t, n) => (e.component.scales[n] && (t[n] = [Yme(n, e)]), t), {})
+    function a0e(e) {
+        return Es.reduce((t, n) => (e.component.scales[n] && (t[n] = [d0e(n, e)]), t), {})
     }
-    const jme = {
+    const o0e = {
         bottom: "top",
         top: "bottom",
         left: "right",
         right: "left"
     };
 
-    function Ume(e) {
+    function l0e(e) {
         const {
             axes: t,
             resolve: n
         } = e.component, i = {
             top: 0,
             bottom: 0,
             right: 0,
             left: 0
         };
         for (const r of e.children) {
             r.parseAxesAndHeaders();
-            for (const s of H(r.component.axes)) n.axis[s] = AC(e.component.resolve, s), n.axis[s] === "shared" && (t[s] = Gme(t[s], r.component.axes[s]), t[s] || (n.axis[s] = "independent", delete t[s]))
+            for (const s of K(r.component.axes)) n.axis[s] = yC(e.component.resolve, s), n.axis[s] === "shared" && (t[s] = u0e(t[s], r.component.axes[s]), t[s] || (n.axis[s] = "independent", delete t[s]))
         }
-        for (const r of cs) {
+        for (const r of Es) {
             for (const s of e.children)
                 if (s.component.axes[r]) {
                     if (n.axis[r] === "independent") {
                         t[r] = (t[r] ?? []).concat(s.component.axes[r]);
                         for (const a of s.component.axes[r]) {
                             const {
                                 value: o,
                                 explicit: l
                             } = a.getWithExplicit("orient");
-                            if (!he(o)) {
+                            if (!xe(o)) {
                                 if (i[o] > 0 && !l) {
-                                    const u = jme[o];
+                                    const u = o0e[o];
                                     i[o] > i[u] && a.set("orient", u, !1)
                                 }
                                 i[o]++
                             }
                         }
                     }
                     delete s.component.axes[r]
                 } if (n.axis[r] === "independent" && t[r] && t[r].length > 1)
-                for (const s of t[r]) s.get("grid") && !s.explicit.grid && (s.implicit.grid = !1)
+                for (const [s, a] of(t[r] || []).entries()) s > 0 && a.get("grid") && !a.explicit.grid && (a.implicit.grid = !1)
         }
     }
 
-    function Gme(e, t) {
+    function u0e(e, t) {
         if (e) {
             if (e.length !== t.length) return;
             const n = e.length;
             for (let i = 0; i < n; i++) {
                 const r = e[i],
                     s = t[i];
                 if (!!r != !!s) return;
                 if (r && s) {
                     const a = r.getWithExplicit("orient"),
                         o = s.getWithExplicit("orient");
                     if (a.explicit && o.explicit && a.value !== o.value) return;
-                    e[i] = Wme(r, s)
+                    e[i] = c0e(r, s)
                 }
             }
         } else return t.map(n => n.clone());
         return e
     }
 
-    function Wme(e, t) {
-        for (const n of C8) {
-            const i = Ua(e.getWithExplicit(n), t.getWithExplicit(n), n, "axis", (r, s) => {
+    function c0e(e, t) {
+        for (const n of u9) {
+            const i = co(e.getWithExplicit(n), t.getWithExplicit(n), n, "axis", (r, s) => {
                 switch (n) {
                     case "title":
-                        return UI(r, s);
+                        return E6(r, s);
                     case "gridScale":
                         return {
-                            explicit: r.explicit, value: Ct(r.value, s.value)
+                            explicit: r.explicit, value: Gt(r.value, s.value)
                         }
                 }
-                return q1(r, s, n, "axis")
+                return Sy(r, s, n, "axis")
             });
             e.setWithExplicit(n, i)
         }
         return e
     }
 
-    function qme(e, t, n, i, r) {
+    function f0e(e, t, n, i, r) {
         if (t === "disable") return n !== void 0;
         switch (n = n || {}, t) {
             case "titleAngle":
             case "labelAngle":
-                return e === (he(n.labelAngle) ? n.labelAngle : zh(n.labelAngle));
+                return e === (xe(n.labelAngle) ? n.labelAngle : gd(n.labelAngle));
             case "values":
                 return !!n.values;
             case "encode":
                 return !!n.encoding || !!n.labelAngle;
             case "title":
-                if (e === Wz(i, r)) return !0
+                if (e === $z(i, r)) return !0
         }
         return e === n[t]
     }
-    const Hme = new Set(["grid", "translate", "format", "formatType", "orient", "labelExpr", "tickCount", "position", "tickMinStep"]);
+    const h0e = new Set(["grid", "translate", "format", "formatType", "orient", "labelExpr", "tickCount", "position", "tickMinStep"]);
 
-    function Yme(e, t) {
+    function d0e(e, t) {
         var y, v;
         let n = t.axis(e);
-        const i = new PC,
-            r = Mt(t.encoding[e]),
+        const i = new CC,
+            r = Yt(t.encoding[e]),
             {
                 mark: s,
                 config: a
             } = t,
-            o = (n == null ? void 0 : n.orient) || ((y = a[e === "x" ? "axisX" : "axisY"]) == null ? void 0 : y.orient) || ((v = a.axis) == null ? void 0 : v.orient) || Rpe(e),
+            o = (n == null ? void 0 : n.orient) || ((y = a[e === "x" ? "axisX" : "axisY"]) == null ? void 0 : y.orient) || ((v = a.axis) == null ? void 0 : v.orient) || Zge(e),
             l = t.getScaleComponent(e).get("type"),
-            u = kpe(e, l, o, t.config),
-            c = n !== void 0 ? !n : sx("disable", a.style, n == null ? void 0 : n.style, u).configValue;
+            u = Hge(e, l, o, t.config),
+            c = n !== void 0 ? !n : Px("disable", a.style, n == null ? void 0 : n.style, u).configValue;
         if (i.set("disable", c, n !== void 0), c) return i;
         n = n || {};
-        const f = Mpe(r, n, e, a.style, u),
-            h = x6(n.formatType, r, l),
-            d = b6(r, r.type, n.format, n.formatType, a, !0),
+        const f = Kge(r, n, e, a.style, u),
+            h = r8(n.formatType, r, l),
+            d = i8(r, r.type, n.format, n.formatType, a, !0),
             g = {
                 fieldOrDatumDef: r,
                 axis: n,
                 channel: e,
                 model: t,
                 scaleType: l,
                 orient: o,
                 labelAngle: f,
                 format: d,
                 formatType: h,
                 mark: s,
                 config: a
             };
-        for (const b of C8) {
-            const x = b in c3 ? c3[b](g) : j5(b) ? n[b] : void 0,
+        for (const b of u9) {
+            const x = b in RM ? RM[b](g) : lM(b) ? n[b] : void 0,
                 _ = x !== void 0,
-                S = qme(x, b, n, t, e);
+                S = f0e(x, b, n, t, e);
             if (_ && S) i.set(b, x, S);
             else {
                 const {
                     configValue: w = void 0,
                     configFrom: E = void 0
-                } = j5(b) && b !== "values" ? sx(b, a.style, n.style, u) : {}, A = w !== void 0;
-                _ && !A ? i.set(b, x, S) : (E !== "vgAxisConfig" || Hme.has(b) && A || Pd(w) || he(w)) && i.set(b, w, !1)
+                } = lM(b) && b !== "values" ? Px(b, a.style, n.style, u) : {}, C = w !== void 0;
+                _ && !C ? i.set(b, x, S) : (E !== "vgAxisConfig" || h0e.has(b) && C || hg(w) || xe(w)) && i.set(b, w, !1)
             }
         }
         const p = n.encoding ?? {},
-            m = N6.reduce((b, x) => {
+            m = b8.reduce((b, x) => {
                 if (!i.hasAxisPart(x)) return b;
-                const _ = Kz(p[x] ?? {}, t),
-                    S = x === "labels" ? zme(t, e, _) : _;
-                return S !== void 0 && !et(S) && (b[x] = {
+                const _ = Dz(p[x] ?? {}, t),
+                    S = x === "labels" ? s0e(t, e, _) : _;
+                return S !== void 0 && !ft(S) && (b[x] = {
                     update: S
                 }), b
             }, {});
-        return et(m) || i.set("encode", m, !!n.encoding || n.labelAngle !== void 0), i
+        return ft(m) || i.set("encode", m, !!n.encoding || n.labelAngle !== void 0), i
     }
 
-    function Xme({
+    function g0e({
         encoding: e,
         size: t
     }) {
-        for (const n of cs) {
-            const i = oi(n);
-            Jr(t[i]) && _a(e[n]) && (delete t[i], X(YI(i)))
+        for (const n of Es) {
+            const i = yi(n);
+            ds(t[i]) && Ba(e[n]) && (delete t[i], J(T6(i)))
         }
         return t
     }
 
-    function Vme(e, t, n) {
-        const i = Hn(e),
-            r = Xe("orient", i, n);
-        if (i.orient = Zme(i.type, t, r), r !== void 0 && r !== i.orient && X(vfe(i.orient, r)), i.type === "bar" && i.orient) {
-            const o = Xe("cornerRadiusEnd", i, n);
+    function p0e(e, t, n) {
+        const i = ii(e),
+            r = st("orient", i, n);
+        if (i.orient = b0e(i.type, t, r), r !== void 0 && r !== i.orient && J(Nce(i.orient, r)), i.type === "bar" && i.orient) {
+            const o = st("cornerRadiusEnd", i, n);
             if (o !== void 0) {
-                const l = i.orient === "horizontal" && t.x2 || i.orient === "vertical" && t.y2 ? ["cornerRadius"] : Phe[i.orient];
+                const l = i.orient === "horizontal" && t.x2 || i.orient === "vertical" && t.y2 ? ["cornerRadius"] : ehe[i.orient];
                 for (const u of l) i[u] = o;
                 i.cornerRadiusEnd !== void 0 && delete i.cornerRadiusEnd
             }
         }
-        return Xe("opacity", i, n) === void 0 && (i.opacity = Jme(i.type, t)), Xe("cursor", i, n) === void 0 && (i.cursor = Kme(i, t, n)), i
+        return st("opacity", i, n) === void 0 && (i.opacity = y0e(i.type, t)), st("cursor", i, n) === void 0 && (i.cursor = m0e(i, t, n)), i
     }
 
-    function Kme(e, t, n) {
-        return t.href || e.href || Xe("href", e, n) ? "pointer" : e.cursor
+    function m0e(e, t, n) {
+        return t.href || e.href || st("href", e, n) ? "pointer" : e.cursor
     }
 
-    function Jme(e, t) {
-        if (Fe([D1, YE, XE, VE], e) && !sC(t)) return .7
+    function y0e(e, t) {
+        if (Be([hy, Pk, Lk, Ik], e) && !Vk(t)) return .7
     }
 
-    function Qme(e, t, {
+    function v0e(e, t, {
         graticule: n
     }) {
         if (n) return !1;
-        const i = cl("filled", e, t),
+        const i = ia("filled", e, t),
             r = e.type;
-        return Ct(i, r !== D1 && r !== R1 && r !== I0)
+        return Gt(i, r !== hy && r !== fy && r !== b0)
     }
 
-    function Zme(e, t, n) {
+    function b0e(e, t, n) {
         switch (e) {
-            case D1:
-            case XE:
-            case VE:
-            case h6:
-            case khe:
-            case Che:
+            case hy:
+            case Lk:
+            case Ik:
+            case J6:
+            case Wfe:
+            case Ufe:
                 return
         }
         const {
             x: i,
             y: r,
             x2: s,
             y2: a
         } = t;
         switch (e) {
-            case F1:
-                if (K(i) && (Xt(i.bin) || K(r) && r.aggregate && !i.aggregate)) return "vertical";
-                if (K(r) && (Xt(r.bin) || K(i) && i.aggregate && !r.aggregate)) return "horizontal";
+            case cy:
+                if (Z(i) && (pn(i.bin) || Z(r) && r.aggregate && !i.aggregate)) return "vertical";
+                if (Z(r) && (pn(r.bin) || Z(i) && i.aggregate && !r.aggregate)) return "horizontal";
                 if (a || s) {
                     if (n) return n;
-                    if (!s) return (K(i) && i.type === hl && !ot(i.bin) || B0(i)) && K(r) && Xt(r.bin) ? "horizontal" : "vertical";
-                    if (!a) return (K(r) && r.type === hl && !ot(r.bin) || B0(r)) && K(i) && Xt(i.bin) ? "vertical" : "horizontal"
+                    if (!s) return (Z(i) && i.type === Pl && !yt(i.bin) || _0(i)) && Z(r) && pn(r.bin) ? "horizontal" : "vertical";
+                    if (!a) return (Z(r) && r.type === Pl && !yt(r.bin) || _0(r)) && Z(i) && pn(i.bin) ? "vertical" : "horizontal"
                 }
-            case I0:
-                if (s && !(K(i) && Xt(i.bin)) && a && !(K(r) && Xt(r.bin))) return;
-            case O1:
-                if (a) return K(r) && Xt(r.bin) ? "horizontal" : "vertical";
-                if (s) return K(i) && Xt(i.bin) ? "vertical" : "horizontal";
-                if (e === I0) {
+            case b0:
+                if (s && !(Z(i) && pn(i.bin)) && a && !(Z(r) && pn(r.bin))) return;
+            case uy:
+                if (a) return Z(r) && pn(r.bin) ? "horizontal" : "vertical";
+                if (s) return Z(i) && pn(i.bin) ? "vertical" : "horizontal";
+                if (e === b0) {
                     if (i && !r) return "vertical";
                     if (r && !i) return "horizontal"
                 }
-            case R1:
-            case YE: {
-                const o = z5(i),
-                    l = z5(r);
+            case fy:
+            case Pk: {
+                const o = aM(i),
+                    l = aM(r);
                 if (n) return n;
                 if (o && !l) return e !== "tick" ? "horizontal" : "vertical";
                 if (!o && l) return e !== "tick" ? "vertical" : "horizontal";
                 if (o && l) return "vertical"; {
-                    const u = zn(i) && i.type === nc,
-                        c = zn(r) && r.type === nc;
+                    const u = Jn(i) && i.type === $c,
+                        c = Jn(r) && r.type === $c;
                     if (u && !c) return "vertical";
                     if (!u && c) return "horizontal"
                 }
                 return
             }
         }
         return "vertical"
     }
-    const e1e = {
+    const x0e = {
             vgMark: "arc",
             encodeEntry: e => ({
-                ...Bi(e, {
+                ...ir(e, {
                     align: "ignore",
                     baseline: "ignore",
                     color: "include",
                     size: "ignore",
                     orient: "ignore",
                     theta: "ignore"
                 }),
-                ...dn("x", e, {
+                ...Mn("x", e, {
                     defaultPos: "mid"
                 }),
-                ...dn("y", e, {
+                ...Mn("y", e, {
                     defaultPos: "mid"
                 }),
-                ...Ga(e, "radius"),
-                ...Ga(e, "theta")
+                ...fo(e, "radius"),
+                ...fo(e, "theta")
             })
         },
-        t1e = {
+        _0e = {
             vgMark: "area",
             encodeEntry: e => ({
-                ...Bi(e, {
+                ...ir(e, {
                     align: "ignore",
                     baseline: "ignore",
                     color: "include",
                     orient: "include",
                     size: "ignore",
                     theta: "ignore"
                 }),
-                ...Y0("x", e, {
+                ...$0("x", e, {
                     defaultPos: "zeroOrMin",
                     defaultPos2: "zeroOrMin",
                     range: e.markDef.orient === "horizontal"
                 }),
-                ...Y0("y", e, {
+                ...$0("y", e, {
                     defaultPos: "zeroOrMin",
                     defaultPos2: "zeroOrMin",
                     range: e.markDef.orient === "vertical"
                 }),
-                ...wC(e)
+                ...hC(e)
             })
         },
-        n1e = {
+        w0e = {
             vgMark: "rect",
             encodeEntry: e => ({
-                ...Bi(e, {
+                ...ir(e, {
                     align: "ignore",
                     baseline: "ignore",
                     color: "include",
                     orient: "ignore",
                     size: "ignore",
                     theta: "ignore"
                 }),
-                ...Ga(e, "x"),
-                ...Ga(e, "y")
+                ...fo(e, "x"),
+                ...fo(e, "y")
             })
         },
-        i1e = {
+        S0e = {
             vgMark: "shape",
             encodeEntry: e => ({
-                ...Bi(e, {
+                ...ir(e, {
                     align: "ignore",
                     baseline: "ignore",
                     color: "include",
                     size: "ignore",
                     orient: "ignore",
                     theta: "ignore"
                 })
@@ -50653,303 +44036,303 @@
             postEncodingTransform: e => {
                 const {
                     encoding: t
                 } = e, n = t.shape;
                 return [{
                     type: "geoshape",
                     projection: e.projectionName(),
-                    ...n && K(n) && n.type === Rc ? {
-                        field: ie(n, {
+                    ...n && Z(n) && n.type === sf ? {
+                        field: oe(n, {
                             expr: "datum"
                         })
                     } : {}
                 }]
             }
         },
-        r1e = {
+        E0e = {
             vgMark: "image",
             encodeEntry: e => ({
-                ...Bi(e, {
+                ...ir(e, {
                     align: "ignore",
                     baseline: "ignore",
                     color: "ignore",
                     orient: "ignore",
                     size: "ignore",
                     theta: "ignore"
                 }),
-                ...Ga(e, "x"),
-                ...Ga(e, "y"),
-                ...xC(e, "url")
+                ...fo(e, "x"),
+                ...fo(e, "y"),
+                ...cC(e, "url")
             })
         },
-        s1e = {
+        k0e = {
             vgMark: "line",
             encodeEntry: e => ({
-                ...Bi(e, {
+                ...ir(e, {
                     align: "ignore",
                     baseline: "ignore",
                     color: "include",
                     size: "ignore",
                     orient: "ignore",
                     theta: "ignore"
                 }),
-                ...dn("x", e, {
+                ...Mn("x", e, {
                     defaultPos: "mid"
                 }),
-                ...dn("y", e, {
+                ...Mn("y", e, {
                     defaultPos: "mid"
                 }),
-                ...Lt("size", e, {
+                ...Zt("size", e, {
                     vgChannel: "strokeWidth"
                 }),
-                ...wC(e)
+                ...hC(e)
             })
         },
-        a1e = {
+        C0e = {
             vgMark: "trail",
             encodeEntry: e => ({
-                ...Bi(e, {
+                ...ir(e, {
                     align: "ignore",
                     baseline: "ignore",
                     color: "include",
                     size: "include",
                     orient: "ignore",
                     theta: "ignore"
                 }),
-                ...dn("x", e, {
+                ...Mn("x", e, {
                     defaultPos: "mid"
                 }),
-                ...dn("y", e, {
+                ...Mn("y", e, {
                     defaultPos: "mid"
                 }),
-                ...Lt("size", e),
-                ...wC(e)
+                ...Zt("size", e),
+                ...hC(e)
             })
         };
 
-    function LC(e, t) {
+    function AC(e, t) {
         const {
             config: n
         } = e;
         return {
-            ...Bi(e, {
+            ...ir(e, {
                 align: "ignore",
                 baseline: "ignore",
                 color: "include",
                 size: "include",
                 orient: "ignore",
                 theta: "ignore"
             }),
-            ...dn("x", e, {
+            ...Mn("x", e, {
                 defaultPos: "mid"
             }),
-            ...dn("y", e, {
+            ...Mn("y", e, {
                 defaultPos: "mid"
             }),
-            ...Lt("size", e),
-            ...Lt("angle", e),
-            ...o1e(e, n, t)
+            ...Zt("size", e),
+            ...Zt("angle", e),
+            ...A0e(e, n, t)
         }
     }
 
-    function o1e(e, t, n) {
+    function A0e(e, t, n) {
         return n ? {
             shape: {
                 value: n
             }
-        } : Lt("shape", e)
+        } : Zt("shape", e)
     }
-    const l1e = {
+    const $0e = {
             vgMark: "symbol",
-            encodeEntry: e => LC(e)
+            encodeEntry: e => AC(e)
         },
-        u1e = {
+        T0e = {
             vgMark: "symbol",
-            encodeEntry: e => LC(e, "circle")
+            encodeEntry: e => AC(e, "circle")
         },
-        c1e = {
+        M0e = {
             vgMark: "symbol",
-            encodeEntry: e => LC(e, "square")
+            encodeEntry: e => AC(e, "square")
         },
-        f1e = {
+        O0e = {
             vgMark: "rect",
             encodeEntry: e => ({
-                ...Bi(e, {
+                ...ir(e, {
                     align: "ignore",
                     baseline: "ignore",
                     color: "include",
                     orient: "ignore",
                     size: "ignore",
                     theta: "ignore"
                 }),
-                ...Ga(e, "x"),
-                ...Ga(e, "y")
+                ...fo(e, "x"),
+                ...fo(e, "y")
             })
         },
-        h1e = {
+        F0e = {
             vgMark: "rule",
             encodeEntry: e => {
                 const {
                     markDef: t
                 } = e, n = t.orient;
                 return !e.encoding.x && !e.encoding.y && !e.encoding.latitude && !e.encoding.longitude ? {} : {
-                    ...Bi(e, {
+                    ...ir(e, {
                         align: "ignore",
                         baseline: "ignore",
                         color: "include",
                         orient: "ignore",
                         size: "ignore",
                         theta: "ignore"
                     }),
-                    ...Y0("x", e, {
+                    ...$0("x", e, {
                         defaultPos: n === "horizontal" ? "zeroOrMax" : "mid",
                         defaultPos2: "zeroOrMin",
                         range: n !== "vertical"
                     }),
-                    ...Y0("y", e, {
+                    ...$0("y", e, {
                         defaultPos: n === "vertical" ? "zeroOrMax" : "mid",
                         defaultPos2: "zeroOrMin",
                         range: n !== "horizontal"
                     }),
-                    ...Lt("size", e, {
+                    ...Zt("size", e, {
                         vgChannel: "strokeWidth"
                     })
                 }
             }
         },
-        d1e = {
+        R0e = {
             vgMark: "text",
             encodeEntry: e => {
                 const {
                     config: t,
                     encoding: n
                 } = e;
                 return {
-                    ...Bi(e, {
+                    ...ir(e, {
                         align: "include",
                         baseline: "include",
                         color: "include",
                         size: "ignore",
                         orient: "ignore",
                         theta: "include"
                     }),
-                    ...dn("x", e, {
+                    ...Mn("x", e, {
                         defaultPos: "mid"
                     }),
-                    ...dn("y", e, {
+                    ...Mn("y", e, {
                         defaultPos: "mid"
                     }),
-                    ...xC(e),
-                    ...Lt("size", e, {
+                    ...cC(e),
+                    ...Zt("size", e, {
                         vgChannel: "fontSize"
                     }),
-                    ...Lt("angle", e),
-                    ...a3("align", g1e(e.markDef, n, t)),
-                    ...a3("baseline", p1e(e.markDef, n, t)),
-                    ...dn("radius", e, {
+                    ...Zt("angle", e),
+                    ...TM("align", D0e(e.markDef, n, t)),
+                    ...TM("baseline", N0e(e.markDef, n, t)),
+                    ...Mn("radius", e, {
                         defaultPos: null
                     }),
-                    ...dn("theta", e, {
+                    ...Mn("theta", e, {
                         defaultPos: null
                     })
                 }
             }
         };
 
-    function g1e(e, t, n) {
-        if (Xe("align", e, n) === void 0) return "center"
+    function D0e(e, t, n) {
+        if (st("align", e, n) === void 0) return "center"
     }
 
-    function p1e(e, t, n) {
-        if (Xe("baseline", e, n) === void 0) return "middle"
+    function N0e(e, t, n) {
+        if (st("baseline", e, n) === void 0) return "middle"
     }
-    const m1e = {
+    const P0e = {
         vgMark: "rect",
         encodeEntry: e => {
             const {
                 config: t,
                 markDef: n
             } = e, i = n.orient, r = i === "horizontal" ? "width" : "height", s = i === "horizontal" ? "height" : "width";
             return {
-                ...Bi(e, {
+                ...ir(e, {
                     align: "ignore",
                     baseline: "ignore",
                     color: "include",
                     orient: "ignore",
                     size: "ignore",
                     theta: "ignore"
                 }),
-                ...dn("x", e, {
+                ...Mn("x", e, {
                     defaultPos: "mid",
                     vgChannel: "xc"
                 }),
-                ...dn("y", e, {
+                ...Mn("y", e, {
                     defaultPos: "mid",
                     vgChannel: "yc"
                 }),
-                ...Lt("size", e, {
-                    defaultValue: y1e(e),
+                ...Zt("size", e, {
+                    defaultValue: L0e(e),
                     vgChannel: r
                 }),
-                [s]: ut(Xe("thickness", n, t))
+                [s]: bt(st("thickness", n, t))
             }
         }
     };
 
-    function y1e(e) {
+    function L0e(e) {
         const {
             config: t,
             markDef: n
         } = e, {
             orient: i
-        } = n, r = i === "horizontal" ? "width" : "height", s = e.getScaleComponent(i === "horizontal" ? "x" : "y"), a = Xe("size", n, t, {
+        } = n, r = i === "horizontal" ? "width" : "height", s = e.getScaleComponent(i === "horizontal" ? "x" : "y"), a = st("size", n, t, {
             vgChannel: r
         }) ?? t.tick.bandSize;
         if (a !== void 0) return a; {
             const o = s ? s.get("range") : void 0;
-            return o && lo(o) && Ze(o.step) ? o.step * 3 / 4 : q0(t.view, r) * 3 / 4
+            return o && To(o) && lt(o.step) ? o.step * 3 / 4 : C0(t.view, r) * 3 / 4
         }
     }
-    const Fg = {
-        arc: e1e,
-        area: t1e,
-        bar: n1e,
-        circle: u1e,
-        geoshape: i1e,
-        image: r1e,
-        line: s1e,
-        point: l1e,
-        rect: f1e,
-        rule: h1e,
-        square: c1e,
-        text: d1e,
-        tick: m1e,
-        trail: a1e
-    };
-
-    function v1e(e) {
-        if (Fe([R1, O1, Ahe], e.mark)) {
-            const t = B6(e.mark, e.encoding);
-            if (t.length > 0) return b1e(e, t)
-        } else if (e.mark === F1) {
-            const t = H2.some(n => Xe(n, e.markDef, e.config));
-            if (e.stack && !e.fieldDef("size") && t) return x1e(e)
+    const Qg = {
+        arc: x0e,
+        area: _0e,
+        bar: w0e,
+        circle: T0e,
+        geoshape: S0e,
+        image: E0e,
+        line: k0e,
+        point: $0e,
+        rect: O0e,
+        rule: F0e,
+        square: M0e,
+        text: R0e,
+        tick: P0e,
+        trail: C0e
+    };
+
+    function I0e(e) {
+        if (Be([fy, uy, qfe], e.mark)) {
+            const t = E8(e.mark, e.encoding);
+            if (t.length > 0) return z0e(e, t)
+        } else if (e.mark === cy) {
+            const t = Sx.some(n => st(n, e.markDef, e.config));
+            if (e.stack && !e.fieldDef("size") && t) return B0e(e)
         }
-        return IC(e)
+        return $C(e)
     }
-    const k3 = "faceted_path_";
+    const VM = "faceted_path_";
 
-    function b1e(e, t) {
+    function z0e(e, t) {
         return [{
             name: e.getName("pathgroup"),
             type: "group",
             from: {
                 facet: {
-                    name: k3 + e.requestDataName(st.Main),
-                    data: e.requestDataName(st.Main),
+                    name: VM + e.requestDataName(pt.Main),
+                    data: e.requestDataName(pt.Main),
                     groupby: t
                 }
             },
             encode: {
                 update: {
                     width: {
                         field: {
@@ -50959,25 +44342,25 @@
                     height: {
                         field: {
                             group: "height"
                         }
                     }
                 }
             },
-            marks: IC(e, {
-                fromPrefix: k3
+            marks: $C(e, {
+                fromPrefix: VM
             })
         }]
     }
-    const A3 = "stack_group_";
+    const KM = "stack_group_";
 
-    function x1e(e) {
+    function B0e(e) {
         var u;
-        const [t] = IC(e, {
-            fromPrefix: A3
+        const [t] = $C(e, {
+            fromPrefix: KM
         }), n = e.scaleName(e.stack.fieldChannel), i = (c = {}) => e.vgField(e.stack.fieldChannel, c), r = (c, f) => {
             const h = [i({
                 prefix: "min",
                 suffix: "start",
                 expr: f
             }), i({
                 prefix: "max",
@@ -50992,15 +44375,15 @@
                 suffix: "end",
                 expr: f
             })];
             return `${c}(${h.map(d=>`scale('${n}',${d})`).join(",")})`
         };
         let s, a;
         e.stack.fieldChannel === "x" ? (s = {
-            ...Qu(t.encode.update, ["y", "yc", "y2", "height", ...H2]),
+            ...Ec(t.encode.update, ["y", "yc", "y2", "height", ...Sx]),
             x: {
                 signal: r("min", "datum")
             },
             x2: {
                 signal: r("max", "datum")
             },
             clip: {
@@ -51015,22 +44398,22 @@
             },
             height: {
                 field: {
                     group: "height"
                 }
             }
         }, t.encode.update = {
-            ...Jn(t.encode.update, ["y", "yc", "y2"]),
+            ...li(t.encode.update, ["y", "yc", "y2"]),
             height: {
                 field: {
                     group: "height"
                 }
             }
         }) : (s = {
-            ...Qu(t.encode.update, ["x", "xc", "x2", "width"]),
+            ...Ec(t.encode.update, ["x", "xc", "x2", "width"]),
             y: {
                 signal: r("min", "datum")
             },
             y2: {
                 signal: r("max", "datum")
             },
             clip: {
@@ -51045,57 +44428,57 @@
             },
             width: {
                 field: {
                     group: "width"
                 }
             }
         }, t.encode.update = {
-            ...Jn(t.encode.update, ["x", "xc", "x2"]),
+            ...li(t.encode.update, ["x", "xc", "x2"]),
             width: {
                 field: {
                     group: "width"
                 }
             }
         });
-        for (const c of H2) {
-            const f = cl(c, e.markDef, e.config);
-            t.encode.update[c] ? (s[c] = t.encode.update[c], delete t.encode.update[c]) : f && (s[c] = ut(f)), f && (t.encode.update[c] = {
+        for (const c of Sx) {
+            const f = ia(c, e.markDef, e.config);
+            t.encode.update[c] ? (s[c] = t.encode.update[c], delete t.encode.update[c]) : f && (s[c] = bt(f)), f && (t.encode.update[c] = {
                 value: 0
             })
         }
         const o = [];
         if (((u = e.stack.groupbyChannels) == null ? void 0 : u.length) > 0)
             for (const c of e.stack.groupbyChannels) {
                 const f = e.fieldDef(c),
-                    h = ie(f);
-                h && o.push(h), (f != null && f.bin || f != null && f.timeUnit) && o.push(ie(f, {
+                    h = oe(f);
+                h && o.push(h), (f != null && f.bin || f != null && f.timeUnit) && o.push(oe(f, {
                     binSuffix: "end"
                 }))
             }
         return s = ["stroke", "strokeWidth", "strokeJoin", "strokeCap", "strokeDash", "strokeDashOffset", "strokeMiterLimit", "strokeOpacity"].reduce((c, f) => {
             if (t.encode.update[f]) return {
                 ...c,
                 [f]: t.encode.update[f]
             }; {
-                const h = cl(f, e.markDef, e.config);
+                const h = ia(f, e.markDef, e.config);
                 return h !== void 0 ? {
                     ...c,
-                    [f]: ut(h)
+                    [f]: bt(h)
                 } : c
             }
         }, s), s.stroke && (s.strokeForeground = {
             value: !0
         }, s.strokeOffset = {
             value: 0
         }), [{
             type: "group",
             from: {
                 facet: {
-                    data: e.requestDataName(st.Main),
-                    name: A3 + e.requestDataName(st.Main),
+                    data: e.requestDataName(pt.Main),
+                    name: KM + e.requestDataName(pt.Main),
                     groupby: o,
                     aggregate: {
                         fields: [i({
                             suffix: "start"
                         }), i({
                             suffix: "start"
                         }), i({
@@ -51116,79 +44499,79 @@
                     update: a
                 },
                 marks: [t]
             }]
         }]
     }
 
-    function _1e(e) {
+    function j0e(e) {
         var o;
         const {
             encoding: t,
             stack: n,
             mark: i,
             markDef: r,
             config: s
         } = e, a = t.order;
-        if (!(!W(a) && gr(a) && W2(a.value) || !a && W2(Xe("order", r, s)))) {
-            if ((W(a) || K(a)) && !n) return zI(a, {
+        if (!(!H(a) && Tr(a) && _x(a.value) || !a && _x(st("order", r, s)))) {
+            if ((H(a) || Z(a)) && !n) return _6(a, {
                 expr: "datum"
             });
-            if (uo(i)) {
+            if (Mo(i)) {
                 const l = r.orient === "horizontal" ? "y" : "x",
                     u = t[l];
-                if (K(u)) {
+                if (Z(u)) {
                     const c = u.sort;
-                    if (W(c)) return {
-                        field: ie(u, {
+                    if (H(c)) return {
+                        field: oe(u, {
                             prefix: l,
                             suffix: "sort_index",
                             expr: "datum"
                         })
                     };
-                    if (Br(c)) return {
-                        field: ie({
-                            aggregate: sC(e.encoding) ? c.op : void 0,
+                    if (ns(c)) return {
+                        field: oe({
+                            aggregate: Vk(e.encoding) ? c.op : void 0,
                             field: c.field
                         }, {
                             expr: "datum"
                         })
                     };
-                    if (w6(c)) {
+                    if (a8(c)) {
                         const f = e.fieldDef(c.encoding);
                         return {
-                            field: ie(f, {
+                            field: oe(f, {
                                 expr: "datum"
                             }),
                             order: c.order
                         }
                     } else return c === null ? void 0 : {
-                        field: ie(u, {
+                        field: oe(u, {
                             binSuffix: (o = e.stack) != null && o.impute ? "mid" : void 0,
                             expr: "datum"
                         })
                     }
                 }
                 return
             }
         }
     }
 
-    function IC(e, t = {
+    function $C(e, t = {
         fromPrefix: ""
     }) {
         const {
             mark: n,
             markDef: i,
             encoding: r,
             config: s
-        } = e, a = Ct(i.clip, w1e(e), S1e(e)), o = LI(i), l = r.key, u = _1e(e), c = E1e(e), f = Xe("aria", i, s), h = Fg[n].postEncodingTransform ? Fg[n].postEncodingTransform(e) : null;
+        } = e, a = Gt(i.clip, G0e(e), U0e(e)), o = b6(i), l = r.key, u = j0e(e), c = W0e(e), f = st("aria", i, s), h = Qg[n].postEncodingTransform ? Qg[n].postEncodingTransform(e) : null;
         return [{
             name: e.getName("marks"),
-            type: Fg[n].vgMark,
+            type: Qg[n].vgMark,
             ...a ? {
                 clip: !0
             } : {},
             ...o ? {
                 style: o
             } : {},
             ...l ? {
@@ -51198,317 +44581,317 @@
                 sort: u
             } : {},
             ...c || {},
             ...f === !1 ? {
                 aria: f
             } : {},
             from: {
-                data: t.fromPrefix + e.requestDataName(st.Main)
+                data: t.fromPrefix + e.requestDataName(pt.Main)
             },
             encode: {
-                update: Fg[n].encodeEntry(e)
+                update: Qg[n].encodeEntry(e)
             },
             ...h ? {
                 transform: h
             } : {}
         }]
     }
 
-    function w1e(e) {
+    function G0e(e) {
         const t = e.getScaleComponent("x"),
             n = e.getScaleComponent("y");
         return t != null && t.get("selectionExtent") || n != null && n.get("selectionExtent") ? !0 : void 0
     }
 
-    function S1e(e) {
+    function U0e(e) {
         const t = e.component.projection;
         return t && !t.isFit ? !0 : void 0
     }
 
-    function E1e(e) {
+    function W0e(e) {
         if (!e.component.selection) return null;
-        const t = H(e.component.selection).length;
+        const t = K(e.component.selection).length;
         let n = t,
             i = e.parent;
-        for (; i && n === 0;) n = H(i.component.selection).length, i = i.parent;
+        for (; i && n === 0;) n = K(i.component.selection).length, i = i.parent;
         return n ? {
             interactive: t > 0 || e.mark === "geoshape" || !!e.encoding.tooltip
         } : null
     }
-    class k8 extends _8 {
+    class c9 extends s9 {
         constructor(t, n, i, r = {}, s) {
-            super(t, "unit", n, i, s, void 0, G5(t) ? t.view : void 0), this.specifiedScales = {}, this.specifiedAxes = {}, this.specifiedLegends = {}, this.specifiedProjection = {}, this.selection = [], this.children = [];
-            const a = Vr(t.mark) ? {
+            super(t, "unit", n, i, s, void 0, cM(t) ? t.view : void 0), this.specifiedScales = {}, this.specifiedAxes = {}, this.specifiedLegends = {}, this.specifiedProjection = {}, this.selection = [], this.children = [];
+            const a = fs(t.mark) ? {
                     ...t.mark
                 } : {
                     type: t.mark
                 },
                 o = a.type;
-            a.filled === void 0 && (a.filled = Qme(a, s, {
-                graticule: t.data && vC(t.data)
+            a.filled === void 0 && (a.filled = v0e(a, s, {
+                graticule: t.data && lC(t.data)
             }));
-            const l = this.encoding = hde(t.encoding || {}, o, a.filled, s);
-            this.markDef = Vme(a, l, s), this.size = Xme({
+            const l = this.encoding = Ohe(t.encoding || {}, o, a.filled, s);
+            this.markDef = p0e(a, l, s), this.size = g0e({
                 encoding: l,
-                size: G5(t) ? {
+                size: cM(t) ? {
                     ...r,
                     ...t.width ? {
                         width: t.width
                     } : {},
                     ...t.height ? {
                         height: t.height
                     } : {}
                 } : r
-            }), this.stack = az(this.markDef, l), this.specifiedScales = this.initScales(o, l), this.specifiedAxes = this.initAxes(l), this.specifiedLegends = this.initLegends(l), this.specifiedProjection = t.projection, this.selection = (t.params ?? []).filter(u => dC(u))
+            }), this.stack = W8(this.markDef, l), this.specifiedScales = this.initScales(o, l), this.specifiedAxes = this.initAxes(l), this.specifiedLegends = this.initLegends(l), this.specifiedProjection = t.projection, this.selection = (t.params ?? []).filter(u => iC(u))
         }
         get hasProjection() {
             const {
                 encoding: t
-            } = this, n = this.mark === d6, i = t && hce.some(r => Ce(t[r]));
+            } = this, n = this.mark === Q6, i = t && Tue.some(r => De(t[r]));
             return n || i
         }
         scaleDomain(t) {
             const n = this.specifiedScales[t];
             return n ? n.domain : void 0
         }
         axis(t) {
             return this.specifiedAxes[t]
         }
         legend(t) {
             return this.specifiedLegends[t]
         }
         initScales(t, n) {
-            return A1.reduce((i, r) => {
-                const s = Mt(n[r]);
+            return sy.reduce((i, r) => {
+                const s = Yt(n[r]);
                 return s && (i[r] = this.initScale(s.scale ?? {})), i
             }, {})
         }
         initScale(t) {
             const {
                 domain: n,
                 range: i
-            } = t, r = Hn(t);
-            return W(n) && (r.domain = n.map(di)), W(i) && (r.range = i.map(di)), r
+            } = t, r = ii(t);
+            return H(n) && (r.domain = n.map(Ci)), H(i) && (r.range = i.map(Ci)), r
         }
         initAxes(t) {
-            return cs.reduce((n, i) => {
+            return Es.reduce((n, i) => {
                 const r = t[i];
-                if (Ce(r) || i === ht && Ce(t.x2) || i === Gt && Ce(t.y2)) {
-                    const s = Ce(r) ? r.axis : void 0;
+                if (De(r) || i === kt && De(t.x2) || i === un && De(t.y2)) {
+                    const s = De(r) ? r.axis : void 0;
                     n[i] = s && this.initAxis({
                         ...s
                     })
                 }
                 return n
             }, {})
         }
         initAxis(t) {
-            const n = H(t),
+            const n = K(t),
                 i = {};
             for (const r of n) {
                 const s = t[r];
-                i[r] = Pd(s) ? PI(s) : di(s)
+                i[r] = hg(s) ? v6(s) : Ci(s)
             }
             return i
         }
         initLegends(t) {
-            return _ce.reduce((n, i) => {
-                const r = Mt(t[i]);
-                if (r && Sce(i)) {
+            return Iue.reduce((n, i) => {
+                const r = Yt(t[i]);
+                if (r && Bue(i)) {
                     const s = r.legend;
-                    n[i] = s && Hn(s)
+                    n[i] = s && ii(s)
                 }
                 return n
             }, {})
         }
         parseData() {
-            this.component.data = sy(this)
+            this.component.data = Iy(this)
         }
         parseLayoutSize() {
-            Ome(this)
+            Jme(this)
         }
         parseSelections() {
-            this.component.selection = wpe(this, this.selection)
+            this.component.selection = Gge(this, this.selection)
         }
         parseMarkGroup() {
-            this.component.mark = v1e(this)
+            this.component.mark = I0e(this)
         }
         parseAxesAndHeaders() {
-            this.component.axes = Bme(this)
+            this.component.axes = a0e(this)
         }
         assembleSelectionTopLevelSignals(t) {
-            return Wge(this, t)
+            return cge(this, t)
         }
         assembleSignals() {
-            return [...jz(this), ...Uge(this, [])]
+            return [...kz(this), ...lge(this, [])]
         }
         assembleSelectionData(t) {
-            return qge(this, t)
+            return fge(this, t)
         }
         assembleLayout() {
             return null
         }
         assembleLayoutSignals() {
-            return kC(this)
+            return mC(this)
         }
         assembleMarks() {
             let t = this.component.mark ?? [];
-            return (!this.parent || !Ic(this.parent)) && (t = bz(this, t)), t.map(this.correctDataNames)
+            return (!this.parent || !cf(this.parent)) && (t = iz(this, t)), t.map(this.correctDataNames)
         }
         assembleGroupStyle() {
             const {
                 style: t
             } = this.view || {};
             return t !== void 0 ? t : this.encoding.x || this.encoding.y ? "cell" : "view"
         }
         getMapping() {
             return this.encoding
         }
         get mark() {
             return this.markDef.type
         }
         channelHasField(t) {
-            return Ho(this.encoding, t)
+            return ml(this.encoding, t)
         }
         fieldDef(t) {
             const n = this.encoding[t];
-            return Kr(n)
+            return hs(n)
         }
         typedFieldDef(t) {
             const n = this.fieldDef(t);
-            return zn(n) ? n : null
+            return Jn(n) ? n : null
         }
     }
-    class zC extends DC {
+    class TC extends EC {
         constructor(t, n, i, r, s) {
             super(t, "layer", n, i, s, t.resolve, t.view);
             const a = {
                 ...r,
                 ...t.width ? {
                     width: t.width
                 } : {},
                 ...t.height ? {
                     height: t.height
                 } : {}
             };
             this.children = t.layer.map((o, l) => {
-                if (W1(o)) return new zC(o, this, this.getName(`layer_${l}`), a, s);
-                if (Zs(o)) return new k8(o, this, this.getName(`layer_${l}`), a, s);
-                throw new Error(FE(o))
+                if (wy(o)) return new TC(o, this, this.getName(`layer_${l}`), a, s);
+                if (da(o)) return new c9(o, this, this.getName(`layer_${l}`), a, s);
+                throw new Error(_k(o))
             })
         }
         parseData() {
-            this.component.data = sy(this);
+            this.component.data = Iy(this);
             for (const t of this.children) t.parseData()
         }
         parseLayoutSize() {
-            Tme(this)
+            Vme(this)
         }
         parseSelections() {
             this.component.selection = {};
             for (const t of this.children) {
                 t.parseSelections();
-                for (const n of H(t.component.selection)) this.component.selection[n] = t.component.selection[n]
+                for (const n of K(t.component.selection)) this.component.selection[n] = t.component.selection[n]
             }
         }
         parseMarkGroup() {
             for (const t of this.children) t.parseMarkGroup()
         }
         parseAxesAndHeaders() {
-            Ume(this)
+            l0e(this)
         }
         assembleSelectionTopLevelSignals(t) {
             return this.children.reduce((n, i) => i.assembleSelectionTopLevelSignals(n), t)
         }
         assembleSignals() {
-            return this.children.reduce((t, n) => t.concat(n.assembleSignals()), jz(this))
+            return this.children.reduce((t, n) => t.concat(n.assembleSignals()), kz(this))
         }
         assembleLayoutSignals() {
-            return this.children.reduce((t, n) => t.concat(n.assembleLayoutSignals()), kC(this))
+            return this.children.reduce((t, n) => t.concat(n.assembleLayoutSignals()), mC(this))
         }
         assembleSelectionData(t) {
             return this.children.reduce((n, i) => i.assembleSelectionData(n), t)
         }
         assembleGroupStyle() {
             const t = new Set;
             for (const i of this.children)
-                for (const r of se(i.assembleGroupStyle())) t.add(r);
+                for (const r of ue(i.assembleGroupStyle())) t.add(r);
             const n = Array.from(t);
             return n.length > 1 ? n : n.length === 1 ? n[0] : void 0
         }
         assembleTitle() {
             let t = super.assembleTitle();
             if (t) return t;
             for (const n of this.children)
                 if (t = n.assembleTitle(), t) return t
         }
         assembleLayout() {
             return null
         }
         assembleMarks() {
-            return Hge(this, this.children.flatMap(t => t.assembleMarks()))
+            return hge(this, this.children.flatMap(t => t.assembleMarks()))
         }
         assembleLegends() {
-            return this.children.reduce((t, n) => t.concat(n.assembleLegends()), r8(this))
+            return this.children.reduce((t, n) => t.concat(n.assembleLegends()), Gz(this))
         }
     }
 
-    function BC(e, t, n, i, r) {
-        if (P1(e)) return new uh(e, t, n, r);
-        if (W1(e)) return new zC(e, t, n, i, r);
-        if (Zs(e)) return new k8(e, t, n, i, r);
-        if (Pde(e)) return new Pme(e, t, n, r);
-        throw new Error(FE(e))
+    function MC(e, t, n, i, r) {
+        if (gy(e)) return new Lh(e, t, n, r);
+        if (wy(e)) return new TC(e, t, n, i, r);
+        if (da(e)) return new c9(e, t, n, i, r);
+        if (tde(e)) return new n0e(e, t, n, r);
+        throw new Error(_k(e))
     }
 
-    function C1e(e, t = {}) {
-        t.logger && Gfe(t.logger), t.fieldTitle && F6(t.fieldTitle);
+    function q0e(e, t = {}) {
+        t.logger && afe(t.logger), t.fieldTitle && m8(t.fieldTitle);
         try {
-            const n = sz(bc(t.config, e.config)),
-                i = dz(e, n),
-                r = BC(i, null, "", void 0, n);
-            return r.parse(), W0e(r.component.data, r), {
-                spec: A1e(r, k1e(e, i.autosize, n, r), e.datasets, e.usermeta),
+            const n = U8(jc(t.config, e.config)),
+                i = J8(e, n),
+                r = MC(i, null, "", void 0, n);
+            return r.parse(), cme(r.component.data, r), {
+                spec: Y0e(r, H0e(e, i.autosize, n, r), e.datasets, e.usermeta),
                 normalized: i
             }
         } finally {
-            t.logger && Wfe(), t.fieldTitle && ide()
+            t.logger && ofe(), t.fieldTitle && whe()
         }
     }
 
-    function k1e(e, t, n, i) {
+    function H0e(e, t, n, i) {
         const r = i.component.layoutSize.get("width"),
             s = i.component.layoutSize.get("height");
         if (t === void 0 ? (t = {
                 type: "pad"
-            }, i.hasAxisOrientSignalRef() && (t.resize = !0)) : re(t) && (t = {
+            }, i.hasAxisOrientSignalRef() && (t.resize = !0)) : le(t) && (t = {
                 type: t
-            }), r && s && Ige(t.type)) {
-            if (r === "step" && s === "step") X(A5()), t.type = "pad";
+            }), r && s && rge(t.type)) {
+            if (r === "step" && s === "step") J(X5()), t.type = "pad";
             else if (r === "step" || s === "step") {
                 const a = r === "step" ? "width" : "height";
-                X(A5(k1(a)));
+                J(X5(ry(a)));
                 const o = a === "width" ? "height" : "width";
-                t.type = zge(o)
+                t.type = sge(o)
             }
         }
         return {
-            ...H(t).length === 1 && t.type ? t.type === "pad" ? {} : {
+            ...K(t).length === 1 && t.type ? t.type === "pad" ? {} : {
                 autosize: t.type
             } : {
                 autosize: t
             },
-            ...t3(n, !1),
-            ...t3(e, !0)
+            ...wM(n, !1),
+            ...wM(e, !0)
         }
     }
 
-    function A1e(e, t, n = {}, i) {
-        const r = e.config ? Kde(e.config) : void 0,
-            s = [].concat(e.assembleSelectionData([]), Cme(e.component.data, n)),
+    function Y0e(e, t, n = {}, i) {
+        const r = e.config ? pde(e.config) : void 0,
+            s = [].concat(e.assembleSelectionData([]), qme(e.component.data, n)),
             a = e.assembleProjections(),
             o = e.assembleTitle(),
             l = e.assembleGroupStyle(),
             u = e.assembleGroupEncodeEntry(!0);
         let c = e.assembleLayoutSignals();
         c = c.filter(d => (d.name === "width" || d.name === "height") && d.value !== void 0 ? (t[d.name] = +d.value, !1) : !0);
         const {
@@ -51532,127 +44915,127 @@
                     update: u
                 }
             } : {},
             data: s,
             ...a.length > 0 ? {
                 projections: a
             } : {},
-            ...e.assembleGroup([...c, ...e.assembleSelectionTopLevelSignals([]), ...tz(f)]),
+            ...e.assembleGroup([...c, ...e.assembleSelectionTopLevelSignals([]), ...z8(f)]),
             ...r ? {
                 config: r
             } : {},
             ...i ? {
                 usermeta: i
             } : {}
         }
     }
-    const $1e = nce.version,
-        T1e = Object.freeze(Object.defineProperty({
+    const X0e = bue.version,
+        V0e = Object.freeze(Object.defineProperty({
             __proto__: null,
-            accessPathDepth: Zu,
-            accessPathWithDatum: wE,
-            compile: C1e,
-            contains: Fe,
-            deepEqual: Nr,
-            deleteNestedProperty: N0,
-            duplicate: ke,
-            entries: Ba,
-            every: bE,
-            fieldIntersection: _E,
-            flatAccessWithDatum: pI,
-            getFirstDefined: Ct,
-            hasIntersection: xE,
-            hash: Ne,
-            internalField: vI,
-            isBoolean: Ih,
-            isEmpty: et,
-            isEqual: lce,
-            isInternalField: bI,
-            isNullOrFalse: W2,
-            isNumeric: x1,
-            keys: H,
-            logicalExpr: oh,
-            mergeDeep: dI,
-            never: hI,
-            normalize: dz,
-            normalizeAngle: zh,
-            omit: Jn,
-            pick: Qu,
-            prefixGenerator: q2,
-            removePathFromField: SE,
-            replaceAll: ll,
-            replacePathInField: Pi,
-            resetIdCounter: cce,
-            setEqual: gI,
-            some: ol,
-            stringify: at,
-            titleCase: $d,
-            unique: Pr,
-            uniqueId: yI,
-            vals: Qt,
-            varName: ft,
-            version: $1e
+            accessPathDepth: kc,
+            accessPathWithDatum: fk,
+            compile: q0e,
+            contains: Be,
+            deepEqual: Jr,
+            deleteNestedProperty: m0,
+            duplicate: Fe,
+            entries: lo,
+            every: lk,
+            fieldIntersection: ck,
+            flatAccessWithDatum: JI,
+            getFirstDefined: Gt,
+            hasIntersection: uk,
+            hash: ze,
+            internalField: e6,
+            isBoolean: dd,
+            isEmpty: ft,
+            isEqual: kue,
+            isInternalField: t6,
+            isNullOrFalse: _x,
+            isNumeric: Q1,
+            keys: K,
+            logicalExpr: Nh,
+            mergeDeep: VI,
+            never: XI,
+            normalize: J8,
+            normalizeAngle: gd,
+            omit: li,
+            pick: Ec,
+            prefixGenerator: wx,
+            removePathFromField: hk,
+            replaceAll: Rl,
+            replacePathInField: Ji,
+            resetIdCounter: Aue,
+            setEqual: KI,
+            some: Fl,
+            stringify: mt,
+            titleCase: ig,
+            unique: Qr,
+            uniqueId: ZI,
+            vals: bn,
+            varName: Et,
+            version: X0e
         }, Symbol.toStringTag, {
             value: "Module"
         }));
 
-    function A8(e) {
+    function f9(e) {
         const [t, n] = /schema\/([\w-]+)\/([\w\.\-]+)\.json$/g.exec(e).slice(1, 3);
         return {
             library: t,
             version: n
         }
     }
-    var M1e = "vega-themes",
-        O1e = "2.13.0",
-        F1e = "Themes for stylized Vega and Vega-Lite visualizations.",
-        R1e = ["vega", "vega-lite", "themes", "style"],
-        D1e = "BSD-3-Clause",
-        N1e = {
+    var K0e = "vega-themes",
+        J0e = "2.13.0",
+        Q0e = "Themes for stylized Vega and Vega-Lite visualizations.",
+        Z0e = ["vega", "vega-lite", "themes", "style"],
+        e1e = "BSD-3-Clause",
+        t1e = {
             name: "UW Interactive Data Lab",
             url: "https://idl.cs.washington.edu"
         },
-        P1e = [{
+        n1e = [{
             name: "Emily Gu",
             url: "https://github.com/emilygu"
         }, {
             name: "Arvind Satyanarayan",
             url: "http://arvindsatya.com"
         }, {
             name: "Jeffrey Heer",
             url: "https://idl.cs.washington.edu"
         }, {
             name: "Dominik Moritz",
             url: "https://www.domoritz.de"
         }],
-        L1e = "build/vega-themes.js",
-        jC = "build/vega-themes.module.js",
-        I1e = "build/vega-themes.min.js",
-        z1e = "build/vega-themes.min.js",
-        B1e = "build/vega-themes.module.d.ts",
-        j1e = {
+        i1e = "build/vega-themes.js",
+        OC = "build/vega-themes.module.js",
+        r1e = "build/vega-themes.min.js",
+        s1e = "build/vega-themes.min.js",
+        a1e = "build/vega-themes.module.d.ts",
+        o1e = {
             type: "git",
             url: "https://github.com/vega/vega-themes.git"
         },
-        U1e = ["src", "build"],
-        G1e = {
+        l1e = ["src", "build"],
+        u1e = {
             prebuild: "yarn clean",
             build: "rollup -c",
             clean: "rimraf build && rimraf examples/build",
             "copy:data": "rsync -r node_modules/vega-datasets/data/* examples/data",
             "copy:build": "rsync -r build/* examples/build",
             "deploy:gh": "yarn build && mkdir -p examples/build && rsync -r build/* examples/build && gh-pages -d examples",
             preversion: "yarn lint",
             serve: "browser-sync start -s -f build examples --serveStatic examples",
             start: "yarn build && concurrently --kill-others -n Server,Rollup 'yarn serve' 'rollup -c -w'",
             format: "eslint . --fix",
             lint: "eslint .",
             release: "release-it"
         },
-        W1e = {
+        c1e = {
             "@babel/core": "^7.21.4",
             "@babel/plugin-transform-runtime": "^7.21.4",
             "@babel/preset-env": "^7.21.4",
             "@babel/preset-typescript": "^7.21.4",
             "@release-it/conventional-changelog": "^5.1.1",
             "@rollup/plugin-json": "^6.0.0",
             "@rollup/plugin-node-resolve": "^15.0.2",
@@ -51670,88 +45053,88 @@
             rollup: "^3.20.6",
             "rollup-plugin-bundle-size": "^1.0.3",
             "rollup-plugin-ts": "^3.2.0",
             typescript: "^5.0.4",
             vega: "^5.24.0",
             "vega-lite": "^5.7.1"
         },
-        q1e = {
+        f1e = {
             vega: "*",
             "vega-lite": "*"
         },
-        H1e = {},
-        Y1e = {
-            name: M1e,
-            version: O1e,
-            description: F1e,
-            keywords: R1e,
-            license: D1e,
-            author: N1e,
-            contributors: P1e,
-            main: L1e,
-            module: jC,
-            unpkg: I1e,
-            jsdelivr: z1e,
-            types: B1e,
-            repository: j1e,
-            files: U1e,
-            scripts: G1e,
-            devDependencies: W1e,
-            peerDependencies: q1e,
-            dependencies: H1e
-        };
-    const nu = "#fff",
-        $3 = "#888",
-        X1e = {
+        h1e = {},
+        d1e = {
+            name: K0e,
+            version: J0e,
+            description: Q0e,
+            keywords: Z0e,
+            license: e1e,
+            author: t1e,
+            contributors: n1e,
+            main: i1e,
+            module: OC,
+            unpkg: r1e,
+            jsdelivr: s1e,
+            types: a1e,
+            repository: o1e,
+            files: l1e,
+            scripts: u1e,
+            devDependencies: c1e,
+            peerDependencies: f1e,
+            dependencies: h1e
+        };
+    const Cu = "#fff",
+        JM = "#888",
+        g1e = {
             background: "#333",
             view: {
-                stroke: $3
+                stroke: JM
             },
             title: {
-                color: nu,
-                subtitleColor: nu
+                color: Cu,
+                subtitleColor: Cu
             },
             style: {
                 "guide-label": {
-                    fill: nu
+                    fill: Cu
                 },
                 "guide-title": {
-                    fill: nu
+                    fill: Cu
                 }
             },
             axis: {
-                domainColor: nu,
-                gridColor: $3,
-                tickColor: nu
+                domainColor: Cu,
+                gridColor: JM,
+                tickColor: Cu
             }
         },
-        yo = "#4572a7",
-        V1e = {
+        zo = "#4572a7",
+        p1e = {
             background: "#fff",
             arc: {
-                fill: yo
+                fill: zo
             },
             area: {
-                fill: yo
+                fill: zo
             },
             line: {
-                stroke: yo,
+                stroke: zo,
                 strokeWidth: 2
             },
             path: {
-                stroke: yo
+                stroke: zo
             },
             rect: {
-                fill: yo
+                fill: zo
             },
             shape: {
-                stroke: yo
+                stroke: zo
             },
             symbol: {
-                fill: yo,
+                fill: zo,
                 strokeWidth: 1.5,
                 size: 50
             },
             axis: {
                 bandPosition: .5,
                 grid: !0,
                 gridColor: "#000000",
@@ -51771,118 +45154,118 @@
                 symbolSize: 50,
                 symbolType: "square"
             },
             range: {
                 category: ["#4572a7", "#aa4643", "#8aa453", "#71598e", "#4598ae", "#d98445", "#94aace", "#d09393", "#b9cc98", "#a99cbc"]
             }
         },
-        vo = "#30a2da",
-        Nv = "#cbcbcb",
-        K1e = "#999",
-        J1e = "#333",
-        T3 = "#f0f0f0",
-        M3 = "#333",
-        Q1e = {
+        Bo = "#30a2da",
+        fb = "#cbcbcb",
+        m1e = "#999",
+        y1e = "#333",
+        QM = "#f0f0f0",
+        ZM = "#333",
+        v1e = {
             arc: {
-                fill: vo
+                fill: Bo
             },
             area: {
-                fill: vo
+                fill: Bo
             },
             axis: {
-                domainColor: Nv,
+                domainColor: fb,
                 grid: !0,
-                gridColor: Nv,
+                gridColor: fb,
                 gridWidth: 1,
-                labelColor: K1e,
+                labelColor: m1e,
                 labelFontSize: 10,
-                titleColor: J1e,
-                tickColor: Nv,
+                titleColor: y1e,
+                tickColor: fb,
                 tickSize: 10,
                 titleFontSize: 14,
                 titlePadding: 10,
                 labelPadding: 4
             },
             axisBand: {
                 grid: !1
             },
-            background: T3,
+            background: QM,
             group: {
-                fill: T3
+                fill: QM
             },
             legend: {
-                labelColor: M3,
+                labelColor: ZM,
                 labelFontSize: 11,
                 padding: 1,
                 symbolSize: 30,
                 symbolType: "square",
-                titleColor: M3,
+                titleColor: ZM,
                 titleFontSize: 14,
                 titlePadding: 10
             },
             line: {
-                stroke: vo,
+                stroke: Bo,
                 strokeWidth: 2
             },
             path: {
-                stroke: vo,
+                stroke: Bo,
                 strokeWidth: .5
             },
             rect: {
-                fill: vo
+                fill: Bo
             },
             range: {
                 category: ["#30a2da", "#fc4f30", "#e5ae38", "#6d904f", "#8b8b8b", "#b96db8", "#ff9e27", "#56cc60", "#52d2ca", "#52689e", "#545454", "#9fe4f8"],
                 diverging: ["#cc0020", "#e77866", "#f6e7e1", "#d6e8ed", "#91bfd9", "#1d78b5"],
                 heatmap: ["#d6e8ed", "#cee0e5", "#91bfd9", "#549cc6", "#1d78b5"]
             },
             point: {
                 filled: !0,
                 shape: "circle"
             },
             shape: {
-                stroke: vo
+                stroke: Bo
             },
             bar: {
                 binSpacing: 2,
-                fill: vo,
+                fill: Bo,
                 stroke: null
             },
             title: {
                 anchor: "start",
                 fontSize: 24,
                 fontWeight: 600,
                 offset: 20
             }
         },
-        bo = "#000",
-        Z1e = {
+        jo = "#000",
+        b1e = {
             group: {
                 fill: "#e5e5e5"
             },
             arc: {
-                fill: bo
+                fill: jo
             },
             area: {
-                fill: bo
+                fill: jo
             },
             line: {
-                stroke: bo
+                stroke: jo
             },
             path: {
-                stroke: bo
+                stroke: jo
             },
             rect: {
-                fill: bo
+                fill: jo
             },
             shape: {
-                stroke: bo
+                stroke: jo
             },
             symbol: {
-                fill: bo,
+                fill: jo,
                 size: 40
             },
             axis: {
                 domain: !1,
                 grid: !0,
                 gridColor: "#FFFFFF",
                 gridOpacity: 1,
@@ -51898,68 +45281,68 @@
                 labelFontSize: 11,
                 symbolSize: 40
             },
             range: {
                 category: ["#000000", "#7F7F7F", "#1A1A1A", "#999999", "#333333", "#B0B0B0", "#4D4D4D", "#C9C9C9", "#666666", "#DCDCDC"]
             }
         },
-        eye = 22,
-        tye = "normal",
-        O3 = "Benton Gothic, sans-serif",
-        F3 = 11.5,
-        nye = "normal",
-        xo = "#82c6df",
-        Pv = "Benton Gothic Bold, sans-serif",
-        R3 = "normal",
-        D3 = 13,
-        df = {
+        x1e = 22,
+        _1e = "normal",
+        e3 = "Benton Gothic, sans-serif",
+        t3 = 11.5,
+        w1e = "normal",
+        Go = "#82c6df",
+        hb = "Benton Gothic Bold, sans-serif",
+        n3 = "normal",
+        i3 = 13,
+        If = {
             "category-6": ["#ec8431", "#829eb1", "#c89d29", "#3580b1", "#adc839", "#ab7fb4"],
             "fire-7": ["#fbf2c7", "#f9e39c", "#f8d36e", "#f4bb6a", "#e68a4f", "#d15a40", "#ab4232"],
             "fireandice-6": ["#e68a4f", "#f4bb6a", "#f9e39c", "#dadfe2", "#a6b7c6", "#849eae"],
             "ice-7": ["#edefee", "#dadfe2", "#c4ccd2", "#a6b7c6", "#849eae", "#607785", "#47525d"]
         },
-        iye = {
+        S1e = {
             background: "#ffffff",
             title: {
                 anchor: "start",
                 color: "#000000",
-                font: Pv,
-                fontSize: eye,
-                fontWeight: tye
+                font: hb,
+                fontSize: x1e,
+                fontWeight: _1e
             },
             arc: {
-                fill: xo
+                fill: Go
             },
             area: {
-                fill: xo
+                fill: Go
             },
             line: {
-                stroke: xo,
+                stroke: Go,
                 strokeWidth: 2
             },
             path: {
-                stroke: xo
+                stroke: Go
             },
             rect: {
-                fill: xo
+                fill: Go
             },
             shape: {
-                stroke: xo
+                stroke: Go
             },
             symbol: {
-                fill: xo,
+                fill: Go,
                 size: 30
             },
             axis: {
-                labelFont: O3,
-                labelFontSize: F3,
-                labelFontWeight: nye,
-                titleFont: Pv,
-                titleFontSize: D3,
-                titleFontWeight: R3
+                labelFont: e3,
+                labelFontSize: t3,
+                labelFontWeight: w1e,
+                titleFont: hb,
+                titleFontSize: i3,
+                titleFontWeight: n3
             },
             axisX: {
                 labelAngle: 0,
                 labelPadding: 4,
                 tickSize: 3
             },
             axisY: {
@@ -51969,63 +45352,63 @@
                 tickSize: 2,
                 titleAlign: "left",
                 titleAngle: 0,
                 titleX: -45,
                 titleY: -11
             },
             legend: {
-                labelFont: O3,
-                labelFontSize: F3,
+                labelFont: e3,
+                labelFontSize: t3,
                 symbolType: "square",
-                titleFont: Pv,
-                titleFontSize: D3,
-                titleFontWeight: R3
+                titleFont: hb,
+                titleFontSize: i3,
+                titleFontWeight: n3
             },
             range: {
-                category: df["category-6"],
-                diverging: df["fireandice-6"],
-                heatmap: df["fire-7"],
-                ordinal: df["fire-7"],
-                ramp: df["fire-7"]
+                category: If["category-6"],
+                diverging: If["fireandice-6"],
+                heatmap: If["fire-7"],
+                ordinal: If["fire-7"],
+                ramp: If["fire-7"]
             }
         },
-        _o = "#ab5787",
-        Rg = "#979797",
-        rye = {
+        Uo = "#ab5787",
+        Zg = "#979797",
+        E1e = {
             background: "#f9f9f9",
             arc: {
-                fill: _o
+                fill: Uo
             },
             area: {
-                fill: _o
+                fill: Uo
             },
             line: {
-                stroke: _o
+                stroke: Uo
             },
             path: {
-                stroke: _o
+                stroke: Uo
             },
             rect: {
-                fill: _o
+                fill: Uo
             },
             shape: {
-                stroke: _o
+                stroke: Uo
             },
             symbol: {
-                fill: _o,
+                fill: Uo,
                 size: 30
             },
             axis: {
-                domainColor: Rg,
+                domainColor: Zg,
                 domainWidth: .5,
                 gridWidth: .2,
-                labelColor: Rg,
-                tickColor: Rg,
+                labelColor: Zg,
+                tickColor: Zg,
                 tickWidth: .2,
-                titleColor: Rg
+                titleColor: Zg
             },
             axisBand: {
                 grid: !1
             },
             axisX: {
                 grid: !0,
                 tickSize: 10
@@ -52041,37 +45424,37 @@
                 symbolSize: 30,
                 symbolType: "square"
             },
             range: {
                 category: ["#ab5787", "#51b2e5", "#703c5c", "#168dd9", "#d190b6", "#00609f", "#d365ba", "#154866", "#666666", "#c4c4c4"]
             }
         },
-        wo = "#3e5c69",
-        sye = {
+        Wo = "#3e5c69",
+        k1e = {
             background: "#fff",
             arc: {
-                fill: wo
+                fill: Wo
             },
             area: {
-                fill: wo
+                fill: Wo
             },
             line: {
-                stroke: wo
+                stroke: Wo
             },
             path: {
-                stroke: wo
+                stroke: Wo
             },
             rect: {
-                fill: wo
+                fill: Wo
             },
             shape: {
-                stroke: wo
+                stroke: Wo
             },
             symbol: {
-                fill: wo
+                fill: Wo
             },
             axis: {
                 domainWidth: .5,
                 grid: !0,
                 labelPadding: 2,
                 tickSize: 5,
                 tickWidth: .5,
@@ -52092,23 +45475,23 @@
                 padding: 1,
                 symbolType: "square"
             },
             range: {
                 category: ["#3e5c69", "#6793a6", "#182429", "#0570b0", "#3690c0", "#74a9cf", "#a6bddb", "#e2ddf2"]
             }
         },
-        Ei = "#1696d2",
-        N3 = "#000000",
-        aye = "#FFFFFF",
-        Dg = "Lato",
-        Lv = "Lato",
-        oye = "Lato",
-        lye = "#DEDDDD",
-        uye = 18,
-        gf = {
+        Ii = "#1696d2",
+        r3 = "#000000",
+        C1e = "#FFFFFF",
+        ep = "Lato",
+        db = "Lato",
+        A1e = "Lato",
+        $1e = "#DEDDDD",
+        T1e = 18,
+        zf = {
             "main-colors": ["#1696d2", "#d2d2d2", "#000000", "#fdbf11", "#ec008b", "#55b748", "#5c5859", "#db2b27"],
             "shades-blue": ["#CFE8F3", "#A2D4EC", "#73BFE2", "#46ABDB", "#1696D2", "#12719E", "#0A4C6A", "#062635"],
             "shades-gray": ["#F5F5F5", "#ECECEC", "#E3E3E3", "#DCDBDB", "#D2D2D2", "#9D9D9D", "#696969", "#353535"],
             "shades-yellow": ["#FFF2CF", "#FCE39E", "#FDD870", "#FCCB41", "#FDBF11", "#E88E2D", "#CA5800", "#843215"],
             "shades-magenta": ["#F5CBDF", "#EB99C2", "#E46AA7", "#E54096", "#EC008B", "#AF1F6B", "#761548", "#351123"],
             "shades-green": ["#DCEDD9", "#BCDEB4", "#98CF90", "#78C26D", "#55B748", "#408941", "#2C5C2D", "#1A2E19"],
             "shades-black": ["#D5D5D4", "#ADABAC", "#848081", "#5C5859", "#332D2F", "#262223", "#1A1717", "#0E0C0D"],
@@ -52127,3071 +45510,11684 @@
             "five-groups-cat-2": ["#1696d2", "#0a4c6a", "#d2d2d2", "#fdbf11", "#332d2f"],
             "five-groups-seq": ["#cfe8f3", "#73bf42", "#1696d2", "#0a4c6a", "#000000"],
             "six-groups-cat-1": ["#1696d2", "#ec008b", "#fdbf11", "#000000", "#d2d2d2", "#55b748"],
             "six-groups-cat-2": ["#1696d2", "#d2d2d2", "#ec008b", "#fdbf11", "#332d2f", "#0a4c6a"],
             "six-groups-seq": ["#cfe8f3", "#a2d4ec", "#73bfe2", "#46abdb", "#1696d2", "#12719e"],
             "diverging-colors": ["#ca5800", "#fdbf11", "#fdd870", "#fff2cf", "#cfe8f3", "#73bfe2", "#1696d2", "#0a4c6a"]
         },
-        cye = {
-            background: aye,
+        M1e = {
+            background: C1e,
             title: {
                 anchor: "start",
-                fontSize: uye,
-                font: Dg
+                fontSize: T1e,
+                font: ep
             },
             axisX: {
                 domain: !0,
-                domainColor: N3,
+                domainColor: r3,
                 domainWidth: 1,
                 grid: !1,
                 labelFontSize: 12,
-                labelFont: Lv,
+                labelFont: db,
                 labelAngle: 0,
-                tickColor: N3,
+                tickColor: r3,
                 tickSize: 5,
                 titleFontSize: 12,
                 titlePadding: 10,
-                titleFont: Dg
+                titleFont: ep
             },
             axisY: {
                 domain: !1,
                 domainWidth: 1,
                 grid: !0,
-                gridColor: lye,
+                gridColor: $1e,
                 gridWidth: 1,
                 labelFontSize: 12,
-                labelFont: Lv,
+                labelFont: db,
                 labelPadding: 8,
                 ticks: !1,
                 titleFontSize: 12,
                 titlePadding: 10,
-                titleFont: Dg,
+                titleFont: ep,
                 titleAngle: 0,
                 titleY: -10,
                 titleX: 18
             },
             legend: {
                 labelFontSize: 12,
-                labelFont: Lv,
+                labelFont: db,
                 symbolSize: 100,
                 titleFontSize: 12,
                 titlePadding: 10,
-                titleFont: Dg,
+                titleFont: ep,
                 orient: "right",
                 offset: 10
             },
             view: {
                 stroke: "transparent"
             },
             range: {
-                category: gf["six-groups-cat-1"],
-                diverging: gf["diverging-colors"],
-                heatmap: gf["diverging-colors"],
-                ordinal: gf["six-groups-seq"],
-                ramp: gf["shades-blue"]
+                category: zf["six-groups-cat-1"],
+                diverging: zf["diverging-colors"],
+                heatmap: zf["diverging-colors"],
+                ordinal: zf["six-groups-seq"],
+                ramp: zf["shades-blue"]
             },
             area: {
-                fill: Ei
+                fill: Ii
             },
             rect: {
-                fill: Ei
+                fill: Ii
             },
             line: {
-                color: Ei,
-                stroke: Ei,
+                color: Ii,
+                stroke: Ii,
                 strokeWidth: 5
             },
             trail: {
-                color: Ei,
-                stroke: Ei,
+                color: Ii,
+                stroke: Ii,
                 strokeWidth: 0,
                 size: 1
             },
             path: {
-                stroke: Ei,
+                stroke: Ii,
                 strokeWidth: .5
             },
             point: {
                 filled: !0
             },
             text: {
-                font: oye,
-                color: Ei,
+                font: A1e,
+                color: Ii,
                 fontSize: 11,
                 align: "center",
                 fontWeight: 400,
                 size: 11
             },
             style: {
                 bar: {
-                    fill: Ei,
+                    fill: Ii,
                     stroke: null
                 }
             },
             arc: {
-                fill: Ei
+                fill: Ii
             },
             shape: {
-                stroke: Ei
+                stroke: Ii
             },
             symbol: {
-                fill: Ei,
+                fill: Ii,
                 size: 30
             }
         },
-        So = "#3366CC",
-        P3 = "#ccc",
-        Ng = "Arial, sans-serif",
-        fye = {
+        qo = "#3366CC",
+        s3 = "#ccc",
+        tp = "Arial, sans-serif",
+        O1e = {
             arc: {
-                fill: So
+                fill: qo
             },
             area: {
-                fill: So
+                fill: qo
             },
             path: {
-                stroke: So
+                stroke: qo
             },
             rect: {
-                fill: So
+                fill: qo
             },
             shape: {
-                stroke: So
+                stroke: qo
             },
             symbol: {
-                stroke: So
+                stroke: qo
             },
             circle: {
-                fill: So
+                fill: qo
             },
             background: "#fff",
             padding: {
                 top: 10,
                 right: 10,
                 bottom: 10,
                 left: 10
             },
             style: {
                 "guide-label": {
-                    font: Ng,
+                    font: tp,
                     fontSize: 12
                 },
                 "guide-title": {
-                    font: Ng,
+                    font: tp,
                     fontSize: 12
                 },
                 "group-title": {
-                    font: Ng,
+                    font: tp,
                     fontSize: 12
                 }
             },
             title: {
-                font: Ng,
+                font: tp,
                 fontSize: 14,
                 fontWeight: "bold",
                 dy: -3,
                 anchor: "start"
             },
             axis: {
-                gridColor: P3,
-                tickColor: P3,
+                gridColor: s3,
+                tickColor: s3,
                 domain: !1,
                 grid: !0
             },
             range: {
                 category: ["#4285F4", "#DB4437", "#F4B400", "#0F9D58", "#AB47BC", "#00ACC1", "#FF7043", "#9E9D24", "#5C6BC0", "#F06292", "#00796B", "#C2185B"],
                 heatmap: ["#c6dafc", "#5e97f6", "#2a56c6"]
             }
         },
-        UC = e => e * (1 / 3 + 1),
-        L3 = UC(9),
-        I3 = UC(10),
-        z3 = UC(12),
-        pf = "Segoe UI",
-        B3 = "wf_standard-font, helvetica, arial, sans-serif",
-        j3 = "#252423",
-        mf = "#605E5C",
-        U3 = "transparent",
-        hye = "#C8C6C4",
-        Wi = "#118DFF",
-        dye = "#12239E",
-        gye = "#E66C37",
-        pye = "#6B007B",
-        mye = "#E044A7",
-        yye = "#744EC2",
-        vye = "#D9B300",
-        bye = "#D64550",
-        $8 = Wi,
-        T8 = "#DEEFFF",
-        G3 = [T8, $8],
-        xye = [T8, "#c7e4ff", "#b0d9ff", "#9aceff", "#83c3ff", "#6cb9ff", "#55aeff", "#3fa3ff", "#2898ff", $8],
-        _ye = {
+        FC = e => e * (1 / 3 + 1),
+        a3 = FC(9),
+        o3 = FC(10),
+        l3 = FC(12),
+        Bf = "Segoe UI",
+        u3 = "wf_standard-font, helvetica, arial, sans-serif",
+        c3 = "#252423",
+        jf = "#605E5C",
+        f3 = "transparent",
+        F1e = "#C8C6C4",
+        ar = "#118DFF",
+        R1e = "#12239E",
+        D1e = "#E66C37",
+        N1e = "#6B007B",
+        P1e = "#E044A7",
+        L1e = "#744EC2",
+        I1e = "#D9B300",
+        z1e = "#D64550",
+        h9 = ar,
+        d9 = "#DEEFFF",
+        h3 = [d9, h9],
+        B1e = [d9, "#c7e4ff", "#b0d9ff", "#9aceff", "#83c3ff", "#6cb9ff", "#55aeff", "#3fa3ff", "#2898ff", h9],
+        j1e = {
             view: {
-                stroke: U3
+                stroke: f3
             },
-            background: U3,
-            font: pf,
+            background: f3,
+            font: Bf,
             header: {
-                titleFont: B3,
-                titleFontSize: z3,
-                titleColor: j3,
-                labelFont: pf,
-                labelFontSize: I3,
-                labelColor: mf
+                titleFont: u3,
+                titleFontSize: l3,
+                titleColor: c3,
+                labelFont: Bf,
+                labelFontSize: o3,
+                labelColor: jf
             },
             axis: {
                 ticks: !1,
                 grid: !1,
                 domain: !1,
-                labelColor: mf,
-                labelFontSize: L3,
-                titleFont: B3,
-                titleColor: j3,
-                titleFontSize: z3,
+                labelColor: jf,
+                labelFontSize: a3,
+                titleFont: u3,
+                titleColor: c3,
+                titleFontSize: l3,
                 titleFontWeight: "normal"
             },
             axisQuantitative: {
                 tickCount: 3,
                 grid: !0,
-                gridColor: hye,
+                gridColor: F1e,
                 gridDash: [1, 5],
                 labelFlush: !1
             },
             axisBand: {
                 tickExtra: !0
             },
-            axisX: {
-                labelPadding: 5
+            axisX: {
+                labelPadding: 5
+            },
+            axisY: {
+                labelPadding: 10
+            },
+            bar: {
+                fill: ar
+            },
+            line: {
+                stroke: ar,
+                strokeWidth: 3,
+                strokeCap: "round",
+                strokeJoin: "round"
+            },
+            text: {
+                font: Bf,
+                fontSize: a3,
+                fill: jf
+            },
+            arc: {
+                fill: ar
+            },
+            area: {
+                fill: ar,
+                line: !0,
+                opacity: .6
+            },
+            path: {
+                stroke: ar
+            },
+            rect: {
+                fill: ar
+            },
+            point: {
+                fill: ar,
+                filled: !0,
+                size: 75
+            },
+            shape: {
+                stroke: ar
+            },
+            symbol: {
+                fill: ar,
+                strokeWidth: 1.5,
+                size: 50
+            },
+            legend: {
+                titleFont: Bf,
+                titleFontWeight: "bold",
+                titleColor: jf,
+                labelFont: Bf,
+                labelFontSize: o3,
+                labelColor: jf,
+                symbolType: "circle",
+                symbolSize: 75
+            },
+            range: {
+                category: [ar, R1e, D1e, N1e, P1e, L1e, I1e, z1e],
+                diverging: h3,
+                heatmap: h3,
+                ordinal: B1e
+            }
+        },
+        G1e = d1e.version,
+        U1e = Object.freeze(Object.defineProperty({
+            __proto__: null,
+            dark: g1e,
+            excel: p1e,
+            fivethirtyeight: v1e,
+            ggplot2: b1e,
+            googlecharts: O1e,
+            latimes: S1e,
+            powerbi: j1e,
+            quartz: E1e,
+            urbaninstitute: M1e,
+            version: G1e,
+            vox: k1e
+        }, Symbol.toStringTag, {
+            value: "Module"
+        }));
+
+    function bd(e) {
+        "@babel/helpers - typeof";
+        return bd = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
+            return typeof t
+        } : function(t) {
+            return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
+        }, bd(e)
+    }
+
+    function W1e(e, t) {
+        if (bd(e) !== "object" || e === null) return e;
+        var n = e[Symbol.toPrimitive];
+        if (n !== void 0) {
+            var i = n.call(e, t || "default");
+            if (bd(i) !== "object") return i;
+            throw new TypeError("@@toPrimitive must return a primitive value.")
+        }
+        return (t === "string" ? String : Number)(e)
+    }
+
+    function q1e(e) {
+        var t = W1e(e, "string");
+        return bd(t) === "symbol" ? t : String(t)
+    }
+
+    function H1e(e, t, n) {
+        return t = q1e(t), t in e ? Object.defineProperty(e, t, {
+            value: n,
+            enumerable: !0,
+            configurable: !0,
+            writable: !0
+        }) : e[t] = n, e
+    }
+
+    function Y1e(e, t) {
+        if (e == null) return {};
+        var n = {},
+            i = Object.keys(e),
+            r, s;
+        for (s = 0; s < i.length; s++) r = i[s], !(t.indexOf(r) >= 0) && (n[r] = e[r]);
+        return n
+    }
+
+    function X1e(e, t) {
+        if (e == null) return {};
+        var n = Y1e(e, t),
+            i, r;
+        if (Object.getOwnPropertySymbols) {
+            var s = Object.getOwnPropertySymbols(e);
+            for (r = 0; r < s.length; r++) i = s[r], !(t.indexOf(i) >= 0) && Object.prototype.propertyIsEnumerable.call(e, i) && (n[i] = e[i])
+        }
+        return n
+    }
+    const V1e = ["title", "image"];
+
+    function K1e(e, t, n) {
+        if (H(e)) return `[${e.map(i=>t(le(i)?i:d3(i,n))).join(", ")}]`;
+        if (ce(e)) {
+            let i = "";
+            const r = e,
+                {
+                    title: s,
+                    image: a
+                } = r,
+                o = X1e(r, V1e);
+            s && (i += `<h2>${t(s)}</h2>`), a && (i += `<img src="${t(a)}">`);
+            const l = Object.keys(o);
+            if (l.length > 0) {
+                i += "<table>";
+                for (const u of l) {
+                    let c = o[u];
+                    c !== void 0 && (ce(c) && (c = d3(c, n)), i += `<tr><td class="key">${t(u)}:</td><td class="value">${t(c)}</td></tr>`)
+                }
+                i += "</table>"
+            }
+            return i || "{}"
+        }
+        return t(e)
+    }
+
+    function J1e(e) {
+        const t = [];
+        return function(n, i) {
+            if (typeof i != "object" || i === null) return i;
+            const r = t.indexOf(this) + 1;
+            return t.length = r, t.length > e ? "[Object]" : t.indexOf(i) >= 0 ? "[Circular]" : (t.push(i), i)
+        }
+    }
+
+    function d3(e, t) {
+        return JSON.stringify(e, J1e(t))
+    }
+    var Q1e = `#vg-tooltip-element {
+  visibility: hidden;
+  padding: 8px;
+  position: fixed;
+  z-index: 1000;
+  font-family: sans-serif;
+  font-size: 11px;
+  border-radius: 3px;
+  box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
+  /* The default theme is the light theme. */
+  background-color: rgba(255, 255, 255, 0.95);
+  border: 1px solid #d9d9d9;
+  color: black;
+}
+#vg-tooltip-element.visible {
+  visibility: visible;
+}
+#vg-tooltip-element h2 {
+  margin-top: 0;
+  margin-bottom: 10px;
+  font-size: 13px;
+}
+#vg-tooltip-element table {
+  border-spacing: 0;
+}
+#vg-tooltip-element table tr {
+  border: none;
+}
+#vg-tooltip-element table tr td {
+  overflow: hidden;
+  text-overflow: ellipsis;
+  padding-top: 2px;
+  padding-bottom: 2px;
+}
+#vg-tooltip-element table tr td.key {
+  color: #808080;
+  max-width: 150px;
+  text-align: right;
+  padding-right: 4px;
+}
+#vg-tooltip-element table tr td.value {
+  display: block;
+  max-width: 300px;
+  max-height: 7em;
+  text-align: left;
+}
+#vg-tooltip-element.dark-theme {
+  background-color: rgba(32, 32, 32, 0.9);
+  border: 1px solid #f5f5f5;
+  color: white;
+}
+#vg-tooltip-element.dark-theme td.key {
+  color: #bfbfbf;
+}
+`;
+    const g9 = "vg-tooltip-element",
+        Z1e = {
+            offsetX: 10,
+            offsetY: 10,
+            id: g9,
+            styleId: "vega-tooltip-style",
+            theme: "light",
+            disableDefaultStyle: !1,
+            sanitize: eye,
+            maxDepth: 2,
+            formatTooltip: K1e
+        };
+
+    function eye(e) {
+        return String(e).replace(/&/g, "&amp;").replace(/</g, "&lt;")
+    }
+
+    function tye(e) {
+        if (!/^[A-Za-z]+[-:.\w]*$/.test(e)) throw new Error("Invalid HTML ID");
+        return Q1e.toString().replace(g9, e)
+    }
+
+    function nye(e, t, n, i) {
+        let r = e.clientX + n;
+        r + t.width > window.innerWidth && (r = +e.clientX - n - t.width);
+        let s = e.clientY + i;
+        return s + t.height > window.innerHeight && (s = +e.clientY - i - t.height), {
+            x: r,
+            y: s
+        }
+    }
+
+    function g3(e, t) {
+        var n = Object.keys(e);
+        if (Object.getOwnPropertySymbols) {
+            var i = Object.getOwnPropertySymbols(e);
+            t && (i = i.filter(function(r) {
+                return Object.getOwnPropertyDescriptor(e, r).enumerable
+            })), n.push.apply(n, i)
+        }
+        return n
+    }
+
+    function p3(e) {
+        for (var t = 1; t < arguments.length; t++) {
+            var n = arguments[t] != null ? arguments[t] : {};
+            t % 2 ? g3(Object(n), !0).forEach(function(i) {
+                H1e(e, i, n[i])
+            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : g3(Object(n)).forEach(function(i) {
+                Object.defineProperty(e, i, Object.getOwnPropertyDescriptor(n, i))
+            })
+        }
+        return e
+    }
+    class iye {
+        constructor(t) {
+            this.options = p3(p3({}, Z1e), t);
+            const n = this.options.id;
+            if (this.el = null, this.call = this.tooltipHandler.bind(this), !this.options.disableDefaultStyle && !document.getElementById(this.options.styleId)) {
+                const i = document.createElement("style");
+                i.setAttribute("id", this.options.styleId), i.innerHTML = tye(n);
+                const r = document.head;
+                r.childNodes.length > 0 ? r.insertBefore(i, r.childNodes[0]) : r.appendChild(i)
+            }
+        }
+        tooltipHandler(t, n, i, r) {
+            if (this.el = document.getElementById(this.options.id), this.el || (this.el = document.createElement("div"), this.el.setAttribute("id", this.options.id), this.el.classList.add("vg-tooltip"), (document.fullscreenElement ?? document.body).appendChild(this.el)), r == null || r === "") {
+                this.el.classList.remove("visible", `${this.options.theme}-theme`);
+                return
+            }
+            this.el.innerHTML = this.options.formatTooltip(r, this.options.sanitize, this.options.maxDepth), this.el.classList.add("visible", `${this.options.theme}-theme`);
+            const {
+                x: s,
+                y: a
+            } = nye(n, this.el.getBoundingClientRect(), this.options.offsetX, this.options.offsetY);
+            this.el.style.top = `${a}px`, this.el.style.left = `${s}px`
+        }
+    }
+
+    function xd(e) {
+        "@babel/helpers - typeof";
+        return xd = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
+            return typeof t
+        } : function(t) {
+            return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
+        }, xd(e)
+    }
+
+    function rye(e, t) {
+        if (xd(e) !== "object" || e === null) return e;
+        var n = e[Symbol.toPrimitive];
+        if (n !== void 0) {
+            var i = n.call(e, t || "default");
+            if (xd(i) !== "object") return i;
+            throw new TypeError("@@toPrimitive must return a primitive value.")
+        }
+        return (t === "string" ? String : Number)(e)
+    }
+
+    function sye(e) {
+        var t = rye(e, "string");
+        return xd(t) === "symbol" ? t : String(t)
+    }
+
+    function aye(e, t, n) {
+        return t = sye(t), t in e ? Object.defineProperty(e, t, {
+            value: n,
+            enumerable: !0,
+            configurable: !0,
+            writable: !0
+        }) : e[t] = n, e
+    }
+
+    function oye(e) {
+        return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e
+    }
+    var gb, m3;
+
+    function lye() {
+        return m3 || (m3 = 1, gb = function(e) {
+            e.prototype[Symbol.iterator] = function*() {
+                for (let t = this.head; t; t = t.next) yield t.value
+            }
+        }), gb
+    }
+    var uye = et;
+    et.Node = Gl;
+    et.create = et;
+
+    function et(e) {
+        var t = this;
+        if (t instanceof et || (t = new et), t.tail = null, t.head = null, t.length = 0, e && typeof e.forEach == "function") e.forEach(function(r) {
+            t.push(r)
+        });
+        else if (arguments.length > 0)
+            for (var n = 0, i = arguments.length; n < i; n++) t.push(arguments[n]);
+        return t
+    }
+    et.prototype.removeNode = function(e) {
+        if (e.list !== this) throw new Error("removing node which does not belong to this list");
+        var t = e.next,
+            n = e.prev;
+        return t && (t.prev = n), n && (n.next = t), e === this.head && (this.head = t), e === this.tail && (this.tail = n), e.list.length--, e.next = null, e.prev = null, e.list = null, t
+    };
+    et.prototype.unshiftNode = function(e) {
+        if (e !== this.head) {
+            e.list && e.list.removeNode(e);
+            var t = this.head;
+            e.list = this, e.next = t, t && (t.prev = e), this.head = e, this.tail || (this.tail = e), this.length++
+        }
+    };
+    et.prototype.pushNode = function(e) {
+        if (e !== this.tail) {
+            e.list && e.list.removeNode(e);
+            var t = this.tail;
+            e.list = this, e.prev = t, t && (t.next = e), this.tail = e, this.head || (this.head = e), this.length++
+        }
+    };
+    et.prototype.push = function() {
+        for (var e = 0, t = arguments.length; e < t; e++) fye(this, arguments[e]);
+        return this.length
+    };
+    et.prototype.unshift = function() {
+        for (var e = 0, t = arguments.length; e < t; e++) hye(this, arguments[e]);
+        return this.length
+    };
+    et.prototype.pop = function() {
+        if (this.tail) {
+            var e = this.tail.value;
+            return this.tail = this.tail.prev, this.tail ? this.tail.next = null : this.head = null, this.length--, e
+        }
+    };
+    et.prototype.shift = function() {
+        if (this.head) {
+            var e = this.head.value;
+            return this.head = this.head.next, this.head ? this.head.prev = null : this.tail = null, this.length--, e
+        }
+    };
+    et.prototype.forEach = function(e, t) {
+        t = t || this;
+        for (var n = this.head, i = 0; n !== null; i++) e.call(t, n.value, i, this), n = n.next
+    };
+    et.prototype.forEachReverse = function(e, t) {
+        t = t || this;
+        for (var n = this.tail, i = this.length - 1; n !== null; i--) e.call(t, n.value, i, this), n = n.prev
+    };
+    et.prototype.get = function(e) {
+        for (var t = 0, n = this.head; n !== null && t < e; t++) n = n.next;
+        if (t === e && n !== null) return n.value
+    };
+    et.prototype.getReverse = function(e) {
+        for (var t = 0, n = this.tail; n !== null && t < e; t++) n = n.prev;
+        if (t === e && n !== null) return n.value
+    };
+    et.prototype.map = function(e, t) {
+        t = t || this;
+        for (var n = new et, i = this.head; i !== null;) n.push(e.call(t, i.value, this)), i = i.next;
+        return n
+    };
+    et.prototype.mapReverse = function(e, t) {
+        t = t || this;
+        for (var n = new et, i = this.tail; i !== null;) n.push(e.call(t, i.value, this)), i = i.prev;
+        return n
+    };
+    et.prototype.reduce = function(e, t) {
+        var n, i = this.head;
+        if (arguments.length > 1) n = t;
+        else if (this.head) i = this.head.next, n = this.head.value;
+        else throw new TypeError("Reduce of empty list with no initial value");
+        for (var r = 0; i !== null; r++) n = e(n, i.value, r), i = i.next;
+        return n
+    };
+    et.prototype.reduceReverse = function(e, t) {
+        var n, i = this.tail;
+        if (arguments.length > 1) n = t;
+        else if (this.tail) i = this.tail.prev, n = this.tail.value;
+        else throw new TypeError("Reduce of empty list with no initial value");
+        for (var r = this.length - 1; i !== null; r--) n = e(n, i.value, r), i = i.prev;
+        return n
+    };
+    et.prototype.toArray = function() {
+        for (var e = new Array(this.length), t = 0, n = this.head; n !== null; t++) e[t] = n.value, n = n.next;
+        return e
+    };
+    et.prototype.toArrayReverse = function() {
+        for (var e = new Array(this.length), t = 0, n = this.tail; n !== null; t++) e[t] = n.value, n = n.prev;
+        return e
+    };
+    et.prototype.slice = function(e, t) {
+        t = t || this.length, t < 0 && (t += this.length), e = e || 0, e < 0 && (e += this.length);
+        var n = new et;
+        if (t < e || t < 0) return n;
+        e < 0 && (e = 0), t > this.length && (t = this.length);
+        for (var i = 0, r = this.head; r !== null && i < e; i++) r = r.next;
+        for (; r !== null && i < t; i++, r = r.next) n.push(r.value);
+        return n
+    };
+    et.prototype.sliceReverse = function(e, t) {
+        t = t || this.length, t < 0 && (t += this.length), e = e || 0, e < 0 && (e += this.length);
+        var n = new et;
+        if (t < e || t < 0) return n;
+        e < 0 && (e = 0), t > this.length && (t = this.length);
+        for (var i = this.length, r = this.tail; r !== null && i > t; i--) r = r.prev;
+        for (; r !== null && i > e; i--, r = r.prev) n.push(r.value);
+        return n
+    };
+    et.prototype.splice = function(e, t, ...n) {
+        e > this.length && (e = this.length - 1), e < 0 && (e = this.length + e);
+        for (var i = 0, r = this.head; r !== null && i < e; i++) r = r.next;
+        for (var s = [], i = 0; r && i < t; i++) s.push(r.value), r = this.removeNode(r);
+        r === null && (r = this.tail), r !== this.head && r !== this.tail && (r = r.prev);
+        for (var i = 0; i < n.length; i++) r = cye(this, r, n[i]);
+        return s
+    };
+    et.prototype.reverse = function() {
+        for (var e = this.head, t = this.tail, n = e; n !== null; n = n.prev) {
+            var i = n.prev;
+            n.prev = n.next, n.next = i
+        }
+        return this.head = t, this.tail = e, this
+    };
+
+    function cye(e, t, n) {
+        var i = t === e.head ? new Gl(n, null, t, e) : new Gl(n, t, t.next, e);
+        return i.next === null && (e.tail = i), i.prev === null && (e.head = i), e.length++, i
+    }
+
+    function fye(e, t) {
+        e.tail = new Gl(t, e.tail, null, e), e.head || (e.head = e.tail), e.length++
+    }
+
+    function hye(e, t) {
+        e.head = new Gl(t, null, e.head, e), e.tail || (e.tail = e.head), e.length++
+    }
+
+    function Gl(e, t, n, i) {
+        if (!(this instanceof Gl)) return new Gl(e, t, n, i);
+        this.list = i, this.value = e, t ? (t.next = this, this.prev = t) : this.prev = null, n ? (n.prev = this, this.next = n) : this.next = null
+    }
+    try {
+        lye()(et)
+    } catch {}
+    const dye = uye,
+        tl = Symbol("max"),
+        Is = Symbol("length"),
+        Au = Symbol("lengthCalculator"),
+        Ih = Symbol("allowStale"),
+        ll = Symbol("maxAge"),
+        Ns = Symbol("dispose"),
+        y3 = Symbol("noDisposeOnSet"),
+        Qt = Symbol("lruList"),
+        or = Symbol("cache"),
+        p9 = Symbol("updateAgeOnGet"),
+        pb = () => 1;
+    class gye {
+        constructor(t) {
+            if (typeof t == "number" && (t = {
+                    max: t
+                }), t || (t = {}), t.max && (typeof t.max != "number" || t.max < 0)) throw new TypeError("max must be a non-negative number");
+            this[tl] = t.max || 1 / 0;
+            const n = t.length || pb;
+            if (this[Au] = typeof n != "function" ? pb : n, this[Ih] = t.stale || !1, t.maxAge && typeof t.maxAge != "number") throw new TypeError("maxAge must be a number");
+            this[ll] = t.maxAge || 0, this[Ns] = t.dispose, this[y3] = t.noDisposeOnSet || !1, this[p9] = t.updateAgeOnGet || !1, this.reset()
+        }
+        set max(t) {
+            if (typeof t != "number" || t < 0) throw new TypeError("max must be a non-negative number");
+            this[tl] = t || 1 / 0, Gf(this)
+        }
+        get max() {
+            return this[tl]
+        }
+        set allowStale(t) {
+            this[Ih] = !!t
+        }
+        get allowStale() {
+            return this[Ih]
+        }
+        set maxAge(t) {
+            if (typeof t != "number") throw new TypeError("maxAge must be a non-negative number");
+            this[ll] = t, Gf(this)
+        }
+        get maxAge() {
+            return this[ll]
+        }
+        set lengthCalculator(t) {
+            typeof t != "function" && (t = pb), t !== this[Au] && (this[Au] = t, this[Is] = 0, this[Qt].forEach(n => {
+                n.length = this[Au](n.value, n.key), this[Is] += n.length
+            })), Gf(this)
+        }
+        get lengthCalculator() {
+            return this[Au]
+        }
+        get length() {
+            return this[Is]
+        }
+        get itemCount() {
+            return this[Qt].length
+        }
+        rforEach(t, n) {
+            n = n || this;
+            for (let i = this[Qt].tail; i !== null;) {
+                const r = i.prev;
+                v3(this, t, i, n), i = r
+            }
+        }
+        forEach(t, n) {
+            n = n || this;
+            for (let i = this[Qt].head; i !== null;) {
+                const r = i.next;
+                v3(this, t, i, n), i = r
+            }
+        }
+        keys() {
+            return this[Qt].toArray().map(t => t.key)
+        }
+        values() {
+            return this[Qt].toArray().map(t => t.value)
+        }
+        reset() {
+            this[Ns] && this[Qt] && this[Qt].length && this[Qt].forEach(t => this[Ns](t.key, t.value)), this[or] = new Map, this[Qt] = new dye, this[Is] = 0
+        }
+        dump() {
+            return this[Qt].map(t => F0(this, t) ? !1 : {
+                k: t.key,
+                v: t.value,
+                e: t.now + (t.maxAge || 0)
+            }).toArray().filter(t => t)
+        }
+        dumpLru() {
+            return this[Qt]
+        }
+        set(t, n, i) {
+            if (i = i || this[ll], i && typeof i != "number") throw new TypeError("maxAge must be a number");
+            const r = i ? Date.now() : 0,
+                s = this[Au](n, t);
+            if (this[or].has(t)) {
+                if (s > this[tl]) return ec(this, this[or].get(t)), !1;
+                const l = this[or].get(t).value;
+                return this[Ns] && (this[y3] || this[Ns](t, l.value)), l.now = r, l.maxAge = i, l.value = n, this[Is] += s - l.length, l.length = s, this.get(t), Gf(this), !0
+            }
+            const a = new pye(t, n, s, r, i);
+            return a.length > this[tl] ? (this[Ns] && this[Ns](t, n), !1) : (this[Is] += a.length, this[Qt].unshift(a), this[or].set(t, this[Qt].head), Gf(this), !0)
+        }
+        has(t) {
+            if (!this[or].has(t)) return !1;
+            const n = this[or].get(t).value;
+            return !F0(this, n)
+        }
+        get(t) {
+            return mb(this, t, !0)
+        }
+        peek(t) {
+            return mb(this, t, !1)
+        }
+        pop() {
+            const t = this[Qt].tail;
+            return t ? (ec(this, t), t.value) : null
+        }
+        del(t) {
+            ec(this, this[or].get(t))
+        }
+        load(t) {
+            this.reset();
+            const n = Date.now();
+            for (let i = t.length - 1; i >= 0; i--) {
+                const r = t[i],
+                    s = r.e || 0;
+                if (s === 0) this.set(r.k, r.v);
+                else {
+                    const a = s - n;
+                    a > 0 && this.set(r.k, r.v, a)
+                }
+            }
+        }
+        prune() {
+            this[or].forEach((t, n) => mb(this, n, !1))
+        }
+    }
+    const mb = (e, t, n) => {
+            const i = e[or].get(t);
+            if (i) {
+                const r = i.value;
+                if (F0(e, r)) {
+                    if (ec(e, i), !e[Ih]) return
+                } else n && (e[p9] && (i.value.now = Date.now()), e[Qt].unshiftNode(i));
+                return r.value
+            }
+        },
+        F0 = (e, t) => {
+            if (!t || !t.maxAge && !e[ll]) return !1;
+            const n = Date.now() - t.now;
+            return t.maxAge ? n > t.maxAge : e[ll] && n > e[ll]
+        },
+        Gf = e => {
+            if (e[Is] > e[tl])
+                for (let t = e[Qt].tail; e[Is] > e[tl] && t !== null;) {
+                    const n = t.prev;
+                    ec(e, t), t = n
+                }
+        },
+        ec = (e, t) => {
+            if (t) {
+                const n = t.value;
+                e[Ns] && e[Ns](n.key, n.value), e[Is] -= n.length, e[or].delete(n.key), e[Qt].removeNode(t)
+            }
+        };
+    class pye {
+        constructor(t, n, i, r, s) {
+            this.key = t, this.value = n, this.length = i, this.now = r, this.maxAge = s || 0
+        }
+    }
+    const v3 = (e, t, n, i) => {
+        let r = n.value;
+        F0(e, r) && (ec(e, n), e[Ih] || (r = void 0)), r && t.call(i, r.value, r.key, e)
+    };
+    var mye = gye;
+    const yye = Object.freeze({
+            loose: !0
+        }),
+        vye = Object.freeze({}),
+        bye = e => e ? typeof e != "object" ? yye : e : vye;
+    var RC = bye,
+        qx = {
+            exports: {}
+        };
+    const xye = "2.0.0",
+        _ye = 256,
+        wye = Number.MAX_SAFE_INTEGER || 9007199254740991,
+        Sye = 16,
+        Eye = ["major", "premajor", "minor", "preminor", "patch", "prepatch", "prerelease"];
+    var DC = {
+        MAX_LENGTH: _ye,
+        MAX_SAFE_COMPONENT_LENGTH: Sye,
+        MAX_SAFE_INTEGER: wye,
+        RELEASE_TYPES: Eye,
+        SEMVER_SPEC_VERSION: xye,
+        FLAG_INCLUDE_PRERELEASE: 1,
+        FLAG_LOOSE: 2
+    };
+    const kye = typeof process == "object" && process.env && {}.NODE_DEBUG && /\bsemver\b/i.test({}.NODE_DEBUG) ? (...e) => console.error("SEMVER", ...e) : () => {};
+    var zy = kye;
+    (function(e, t) {
+        const {
+            MAX_SAFE_COMPONENT_LENGTH: n
+        } = DC, i = zy;
+        t = e.exports = {};
+        const r = t.re = [],
+            s = t.src = [],
+            a = t.t = {};
+        let o = 0;
+        const l = (u, c, f) => {
+            const h = o++;
+            i(u, h, c), a[u] = h, s[h] = c, r[h] = new RegExp(c, f ? "g" : void 0)
+        };
+        l("NUMERICIDENTIFIER", "0|[1-9]\\d*"), l("NUMERICIDENTIFIERLOOSE", "[0-9]+"), l("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), l("MAINVERSION", `(${s[a.NUMERICIDENTIFIER]})\\.(${s[a.NUMERICIDENTIFIER]})\\.(${s[a.NUMERICIDENTIFIER]})`), l("MAINVERSIONLOOSE", `(${s[a.NUMERICIDENTIFIERLOOSE]})\\.(${s[a.NUMERICIDENTIFIERLOOSE]})\\.(${s[a.NUMERICIDENTIFIERLOOSE]})`), l("PRERELEASEIDENTIFIER", `(?:${s[a.NUMERICIDENTIFIER]}|${s[a.NONNUMERICIDENTIFIER]})`), l("PRERELEASEIDENTIFIERLOOSE", `(?:${s[a.NUMERICIDENTIFIERLOOSE]}|${s[a.NONNUMERICIDENTIFIER]})`), l("PRERELEASE", `(?:-(${s[a.PRERELEASEIDENTIFIER]}(?:\\.${s[a.PRERELEASEIDENTIFIER]})*))`), l("PRERELEASELOOSE", `(?:-?(${s[a.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${s[a.PRERELEASEIDENTIFIERLOOSE]})*))`), l("BUILDIDENTIFIER", "[0-9A-Za-z-]+"), l("BUILD", `(?:\\+(${s[a.BUILDIDENTIFIER]}(?:\\.${s[a.BUILDIDENTIFIER]})*))`), l("FULLPLAIN", `v?${s[a.MAINVERSION]}${s[a.PRERELEASE]}?${s[a.BUILD]}?`), l("FULL", `^${s[a.FULLPLAIN]}$`), l("LOOSEPLAIN", `[v=\\s]*${s[a.MAINVERSIONLOOSE]}${s[a.PRERELEASELOOSE]}?${s[a.BUILD]}?`), l("LOOSE", `^${s[a.LOOSEPLAIN]}$`), l("GTLT", "((?:<|>)?=?)"), l("XRANGEIDENTIFIERLOOSE", `${s[a.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), l("XRANGEIDENTIFIER", `${s[a.NUMERICIDENTIFIER]}|x|X|\\*`), l("XRANGEPLAIN", `[v=\\s]*(${s[a.XRANGEIDENTIFIER]})(?:\\.(${s[a.XRANGEIDENTIFIER]})(?:\\.(${s[a.XRANGEIDENTIFIER]})(?:${s[a.PRERELEASE]})?${s[a.BUILD]}?)?)?`), l("XRANGEPLAINLOOSE", `[v=\\s]*(${s[a.XRANGEIDENTIFIERLOOSE]})(?:\\.(${s[a.XRANGEIDENTIFIERLOOSE]})(?:\\.(${s[a.XRANGEIDENTIFIERLOOSE]})(?:${s[a.PRERELEASELOOSE]})?${s[a.BUILD]}?)?)?`), l("XRANGE", `^${s[a.GTLT]}\\s*${s[a.XRANGEPLAIN]}$`), l("XRANGELOOSE", `^${s[a.GTLT]}\\s*${s[a.XRANGEPLAINLOOSE]}$`), l("COERCE", `(^|[^\\d])(\\d{1,${n}})(?:\\.(\\d{1,${n}}))?(?:\\.(\\d{1,${n}}))?(?:$|[^\\d])`), l("COERCERTL", s[a.COERCE], !0), l("LONETILDE", "(?:~>?)"), l("TILDETRIM", `(\\s*)${s[a.LONETILDE]}\\s+`, !0), t.tildeTrimReplace = "$1~", l("TILDE", `^${s[a.LONETILDE]}${s[a.XRANGEPLAIN]}$`), l("TILDELOOSE", `^${s[a.LONETILDE]}${s[a.XRANGEPLAINLOOSE]}$`), l("LONECARET", "(?:\\^)"), l("CARETTRIM", `(\\s*)${s[a.LONECARET]}\\s+`, !0), t.caretTrimReplace = "$1^", l("CARET", `^${s[a.LONECARET]}${s[a.XRANGEPLAIN]}$`), l("CARETLOOSE", `^${s[a.LONECARET]}${s[a.XRANGEPLAINLOOSE]}$`), l("COMPARATORLOOSE", `^${s[a.GTLT]}\\s*(${s[a.LOOSEPLAIN]})$|^$`), l("COMPARATOR", `^${s[a.GTLT]}\\s*(${s[a.FULLPLAIN]})$|^$`), l("COMPARATORTRIM", `(\\s*)${s[a.GTLT]}\\s*(${s[a.LOOSEPLAIN]}|${s[a.XRANGEPLAIN]})`, !0), t.comparatorTrimReplace = "$1$2$3", l("HYPHENRANGE", `^\\s*(${s[a.XRANGEPLAIN]})\\s+-\\s+(${s[a.XRANGEPLAIN]})\\s*$`), l("HYPHENRANGELOOSE", `^\\s*(${s[a.XRANGEPLAINLOOSE]})\\s+-\\s+(${s[a.XRANGEPLAINLOOSE]})\\s*$`), l("STAR", "(<|>)?=?\\s*\\*"), l("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"), l("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$")
+    })(qx, qx.exports);
+    var NC = qx.exports;
+    const b3 = /^[0-9]+$/,
+        m9 = (e, t) => {
+            const n = b3.test(e),
+                i = b3.test(t);
+            return n && i && (e = +e, t = +t), e === t ? 0 : n && !i ? -1 : i && !n ? 1 : e < t ? -1 : 1
+        },
+        Cye = (e, t) => m9(t, e);
+    var Aye = {
+        compareIdentifiers: m9,
+        rcompareIdentifiers: Cye
+    };
+    const np = zy,
+        {
+            MAX_LENGTH: x3,
+            MAX_SAFE_INTEGER: ip
+        } = DC,
+        {
+            re: _3,
+            t: w3
+        } = NC,
+        $ye = RC,
+        {
+            compareIdentifiers: $u
+        } = Aye;
+    let Tye = class Wr {
+        constructor(t, n) {
+            if (n = $ye(n), t instanceof Wr) {
+                if (t.loose === !!n.loose && t.includePrerelease === !!n.includePrerelease) return t;
+                t = t.version
+            } else if (typeof t != "string") throw new TypeError(`Invalid Version: ${t}`);
+            if (t.length > x3) throw new TypeError(`version is longer than ${x3} characters`);
+            np("SemVer", t, n), this.options = n, this.loose = !!n.loose, this.includePrerelease = !!n.includePrerelease;
+            const i = t.trim().match(n.loose ? _3[w3.LOOSE] : _3[w3.FULL]);
+            if (!i) throw new TypeError(`Invalid Version: ${t}`);
+            if (this.raw = t, this.major = +i[1], this.minor = +i[2], this.patch = +i[3], this.major > ip || this.major < 0) throw new TypeError("Invalid major version");
+            if (this.minor > ip || this.minor < 0) throw new TypeError("Invalid minor version");
+            if (this.patch > ip || this.patch < 0) throw new TypeError("Invalid patch version");
+            i[4] ? this.prerelease = i[4].split(".").map(r => {
+                if (/^[0-9]+$/.test(r)) {
+                    const s = +r;
+                    if (s >= 0 && s < ip) return s
+                }
+                return r
+            }) : this.prerelease = [], this.build = i[5] ? i[5].split(".") : [], this.format()
+        }
+        format() {
+            return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version
+        }
+        toString() {
+            return this.version
+        }
+        compare(t) {
+            if (np("SemVer.compare", this.version, this.options, t), !(t instanceof Wr)) {
+                if (typeof t == "string" && t === this.version) return 0;
+                t = new Wr(t, this.options)
+            }
+            return t.version === this.version ? 0 : this.compareMain(t) || this.comparePre(t)
+        }
+        compareMain(t) {
+            return t instanceof Wr || (t = new Wr(t, this.options)), $u(this.major, t.major) || $u(this.minor, t.minor) || $u(this.patch, t.patch)
+        }
+        comparePre(t) {
+            if (t instanceof Wr || (t = new Wr(t, this.options)), this.prerelease.length && !t.prerelease.length) return -1;
+            if (!this.prerelease.length && t.prerelease.length) return 1;
+            if (!this.prerelease.length && !t.prerelease.length) return 0;
+            let n = 0;
+            do {
+                const i = this.prerelease[n],
+                    r = t.prerelease[n];
+                if (np("prerelease compare", n, i, r), i === void 0 && r === void 0) return 0;
+                if (r === void 0) return 1;
+                if (i === void 0) return -1;
+                if (i === r) continue;
+                return $u(i, r)
+            } while (++n)
+        }
+        compareBuild(t) {
+            t instanceof Wr || (t = new Wr(t, this.options));
+            let n = 0;
+            do {
+                const i = this.build[n],
+                    r = t.build[n];
+                if (np("prerelease compare", n, i, r), i === void 0 && r === void 0) return 0;
+                if (r === void 0) return 1;
+                if (i === void 0) return -1;
+                if (i === r) continue;
+                return $u(i, r)
+            } while (++n)
+        }
+        inc(t, n, i) {
+            switch (t) {
+                case "premajor":
+                    this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", n, i);
+                    break;
+                case "preminor":
+                    this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", n, i);
+                    break;
+                case "prepatch":
+                    this.prerelease.length = 0, this.inc("patch", n, i), this.inc("pre", n, i);
+                    break;
+                case "prerelease":
+                    this.prerelease.length === 0 && this.inc("patch", n, i), this.inc("pre", n, i);
+                    break;
+                case "major":
+                    (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
+                    break;
+                case "minor":
+                    (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
+                    break;
+                case "patch":
+                    this.prerelease.length === 0 && this.patch++, this.prerelease = [];
+                    break;
+                case "pre":
+                    if (this.prerelease.length === 0) this.prerelease = [0];
+                    else {
+                        let r = this.prerelease.length;
+                        for (; --r >= 0;) typeof this.prerelease[r] == "number" && (this.prerelease[r]++, r = -2);
+                        r === -1 && this.prerelease.push(0)
+                    }
+                    if (n) {
+                        const r = Number(i) ? 1 : 0;
+                        $u(this.prerelease[0], n) === 0 ? isNaN(this.prerelease[1]) && (this.prerelease = [n, r]) : this.prerelease = [n, r]
+                    }
+                    break;
+                default:
+                    throw new Error(`invalid increment argument: ${t}`)
+            }
+            return this.format(), this.raw = this.version, this
+        }
+    };
+    var PC = Tye;
+    const S3 = PC,
+        Mye = (e, t, n) => new S3(e, n).compare(new S3(t, n));
+    var ff = Mye;
+    const Oye = ff,
+        Fye = (e, t, n) => Oye(e, t, n) === 0;
+    var Rye = Fye;
+    const Dye = ff,
+        Nye = (e, t, n) => Dye(e, t, n) !== 0;
+    var Pye = Nye;
+    const Lye = ff,
+        Iye = (e, t, n) => Lye(e, t, n) > 0;
+    var zye = Iye;
+    const Bye = ff,
+        jye = (e, t, n) => Bye(e, t, n) >= 0;
+    var Gye = jye;
+    const Uye = ff,
+        Wye = (e, t, n) => Uye(e, t, n) < 0;
+    var qye = Wye;
+    const Hye = ff,
+        Yye = (e, t, n) => Hye(e, t, n) <= 0;
+    var Xye = Yye;
+    const Vye = Rye,
+        Kye = Pye,
+        Jye = zye,
+        Qye = Gye,
+        Zye = qye,
+        eve = Xye,
+        tve = (e, t, n, i) => {
+            switch (t) {
+                case "===":
+                    return typeof e == "object" && (e = e.version), typeof n == "object" && (n = n.version), e === n;
+                case "!==":
+                    return typeof e == "object" && (e = e.version), typeof n == "object" && (n = n.version), e !== n;
+                case "":
+                case "=":
+                case "==":
+                    return Vye(e, n, i);
+                case "!=":
+                    return Kye(e, n, i);
+                case ">":
+                    return Jye(e, n, i);
+                case ">=":
+                    return Qye(e, n, i);
+                case "<":
+                    return Zye(e, n, i);
+                case "<=":
+                    return eve(e, n, i);
+                default:
+                    throw new TypeError(`Invalid operator: ${t}`)
+            }
+        };
+    var nve = tve,
+        yb, E3;
+
+    function ive() {
+        if (E3) return yb;
+        E3 = 1;
+        const e = Symbol("SemVer ANY");
+        class t {
+            static get ANY() {
+                return e
+            }
+            constructor(c, f) {
+                if (f = n(f), c instanceof t) {
+                    if (c.loose === !!f.loose) return c;
+                    c = c.value
+                }
+                a("comparator", c, f), this.options = f, this.loose = !!f.loose, this.parse(c), this.semver === e ? this.value = "" : this.value = this.operator + this.semver.version, a("comp", this)
+            }
+            parse(c) {
+                const f = this.options.loose ? i[r.COMPARATORLOOSE] : i[r.COMPARATOR],
+                    h = c.match(f);
+                if (!h) throw new TypeError(`Invalid comparator: ${c}`);
+                this.operator = h[1] !== void 0 ? h[1] : "", this.operator === "=" && (this.operator = ""), h[2] ? this.semver = new o(h[2], this.options.loose) : this.semver = e
+            }
+            toString() {
+                return this.value
+            }
+            test(c) {
+                if (a("Comparator.test", c, this.options.loose), this.semver === e || c === e) return !0;
+                if (typeof c == "string") try {
+                    c = new o(c, this.options)
+                } catch {
+                    return !1
+                }
+                return s(c, this.operator, this.semver, this.options)
+            }
+            intersects(c, f) {
+                if (!(c instanceof t)) throw new TypeError("a Comparator is required");
+                return this.operator === "" ? this.value === "" ? !0 : new l(c.value, f).test(this.value) : c.operator === "" ? c.value === "" ? !0 : new l(this.value, f).test(c.semver) : (f = n(f), f.includePrerelease && (this.value === "<0.0.0-0" || c.value === "<0.0.0-0") || !f.includePrerelease && (this.value.startsWith("<0.0.0") || c.value.startsWith("<0.0.0")) ? !1 : !!(this.operator.startsWith(">") && c.operator.startsWith(">") || this.operator.startsWith("<") && c.operator.startsWith("<") || this.semver.version === c.semver.version && this.operator.includes("=") && c.operator.includes("=") || s(this.semver, "<", c.semver, f) && this.operator.startsWith(">") && c.operator.startsWith("<") || s(this.semver, ">", c.semver, f) && this.operator.startsWith("<") && c.operator.startsWith(">")))
+            }
+        }
+        yb = t;
+        const n = RC,
+            {
+                re: i,
+                t: r
+            } = NC,
+            s = nve,
+            a = zy,
+            o = PC,
+            l = y9();
+        return yb
+    }
+    var vb, k3;
+
+    function y9() {
+        if (k3) return vb;
+        k3 = 1;
+        class e {
+            constructor(T, M) {
+                if (M = i(M), T instanceof e) return T.loose === !!M.loose && T.includePrerelease === !!M.includePrerelease ? T : new e(T.raw, M);
+                if (T instanceof r) return this.raw = T.value, this.set = [
+                    [T]
+                ], this.format(), this;
+                if (this.options = M, this.loose = !!M.loose, this.includePrerelease = !!M.includePrerelease, this.raw = T, this.set = T.split("||").map(R => this.parseRange(R.trim())).filter(R => R.length), !this.set.length) throw new TypeError(`Invalid SemVer Range: ${T}`);
+                if (this.set.length > 1) {
+                    const R = this.set[0];
+                    if (this.set = this.set.filter(N => !g(N[0])), this.set.length === 0) this.set = [R];
+                    else if (this.set.length > 1) {
+                        for (const N of this.set)
+                            if (N.length === 1 && p(N[0])) {
+                                this.set = [N];
+                                break
+                            }
+                    }
+                }
+                this.format()
+            }
+            format() {
+                return this.range = this.set.map(T => T.join(" ").trim()).join("||").trim(), this.range
+            }
+            toString() {
+                return this.range
+            }
+            parseRange(T) {
+                T = T.trim();
+                const R = ((this.options.includePrerelease && h) | (this.options.loose && d)) + ":" + T,
+                    N = n.get(R);
+                if (N) return N;
+                const L = this.options.loose,
+                    I = L ? o[l.HYPHENRANGELOOSE] : o[l.HYPHENRANGE];
+                T = T.replace(I, A(this.options.includePrerelease)), s("hyphen replace", T), T = T.replace(o[l.COMPARATORTRIM], u), s("comparator trim", T), T = T.replace(o[l.TILDETRIM], c), T = T.replace(o[l.CARETTRIM], f), T = T.split(/\s+/).join(" ");
+                let G = T.split(" ").map(Te => y(Te, this.options)).join(" ").split(/\s+/).map(Te => k(Te, this.options));
+                L && (G = G.filter(Te => (s("loose invalid filter", Te, this.options), !!Te.match(o[l.COMPARATORLOOSE])))), s("range list", G);
+                const ie = new Map,
+                    ge = G.map(Te => new r(Te, this.options));
+                for (const Te of ge) {
+                    if (g(Te)) return [Te];
+                    ie.set(Te.value, Te)
+                }
+                ie.size > 1 && ie.has("") && ie.delete("");
+                const Re = [...ie.values()];
+                return n.set(R, Re), Re
+            }
+            intersects(T, M) {
+                if (!(T instanceof e)) throw new TypeError("a Range is required");
+                return this.set.some(R => m(R, M) && T.set.some(N => m(N, M) && R.every(L => N.every(I => L.intersects(I, M)))))
+            }
+            test(T) {
+                if (!T) return !1;
+                if (typeof T == "string") try {
+                    T = new a(T, this.options)
+                } catch {
+                    return !1
+                }
+                for (let M = 0; M < this.set.length; M++)
+                    if (F(this.set[M], T, this.options)) return !0;
+                return !1
+            }
+        }
+        vb = e;
+        const t = mye,
+            n = new t({
+                max: 1e3
+            }),
+            i = RC,
+            r = ive(),
+            s = zy,
+            a = PC,
+            {
+                re: o,
+                t: l,
+                comparatorTrimReplace: u,
+                tildeTrimReplace: c,
+                caretTrimReplace: f
+            } = NC,
+            {
+                FLAG_INCLUDE_PRERELEASE: h,
+                FLAG_LOOSE: d
+            } = DC,
+            g = $ => $.value === "<0.0.0-0",
+            p = $ => $.value === "",
+            m = ($, T) => {
+                let M = !0;
+                const R = $.slice();
+                let N = R.pop();
+                for (; M && R.length;) M = R.every(L => N.intersects(L, T)), N = R.pop();
+                return M
+            },
+            y = ($, T) => (s("comp", $, T), $ = _($, T), s("caret", $), $ = b($, T), s("tildes", $), $ = w($, T), s("xrange", $), $ = C($, T), s("stars", $), $),
+            v = $ => !$ || $.toLowerCase() === "x" || $ === "*",
+            b = ($, T) => $.trim().split(/\s+/).map(M => x(M, T)).join(" "),
+            x = ($, T) => {
+                const M = T.loose ? o[l.TILDELOOSE] : o[l.TILDE];
+                return $.replace(M, (R, N, L, I, G) => {
+                    s("tilde", $, R, N, L, I, G);
+                    let ie;
+                    return v(N) ? ie = "" : v(L) ? ie = `>=${N}.0.0 <${+N+1}.0.0-0` : v(I) ? ie = `>=${N}.${L}.0 <${N}.${+L+1}.0-0` : G ? (s("replaceTilde pr", G), ie = `>=${N}.${L}.${I}-${G} <${N}.${+L+1}.0-0`) : ie = `>=${N}.${L}.${I} <${N}.${+L+1}.0-0`, s("tilde return", ie), ie
+                })
+            },
+            _ = ($, T) => $.trim().split(/\s+/).map(M => S(M, T)).join(" "),
+            S = ($, T) => {
+                s("caret", $, T);
+                const M = T.loose ? o[l.CARETLOOSE] : o[l.CARET],
+                    R = T.includePrerelease ? "-0" : "";
+                return $.replace(M, (N, L, I, G, ie) => {
+                    s("caret", $, N, L, I, G, ie);
+                    let ge;
+                    return v(L) ? ge = "" : v(I) ? ge = `>=${L}.0.0${R} <${+L+1}.0.0-0` : v(G) ? L === "0" ? ge = `>=${L}.${I}.0${R} <${L}.${+I+1}.0-0` : ge = `>=${L}.${I}.0${R} <${+L+1}.0.0-0` : ie ? (s("replaceCaret pr", ie), L === "0" ? I === "0" ? ge = `>=${L}.${I}.${G}-${ie} <${L}.${I}.${+G+1}-0` : ge = `>=${L}.${I}.${G}-${ie} <${L}.${+I+1}.0-0` : ge = `>=${L}.${I}.${G}-${ie} <${+L+1}.0.0-0`) : (s("no pr"), L === "0" ? I === "0" ? ge = `>=${L}.${I}.${G}${R} <${L}.${I}.${+G+1}-0` : ge = `>=${L}.${I}.${G}${R} <${L}.${+I+1}.0-0` : ge = `>=${L}.${I}.${G} <${+L+1}.0.0-0`), s("caret return", ge), ge
+                })
+            },
+            w = ($, T) => (s("replaceXRanges", $, T), $.split(/\s+/).map(M => E(M, T)).join(" ")),
+            E = ($, T) => {
+                $ = $.trim();
+                const M = T.loose ? o[l.XRANGELOOSE] : o[l.XRANGE];
+                return $.replace(M, (R, N, L, I, G, ie) => {
+                    s("xRange", $, R, N, L, I, G, ie);
+                    const ge = v(L),
+                        Re = ge || v(I),
+                        Te = Re || v(G),
+                        tt = Te;
+                    return N === "=" && tt && (N = ""), ie = T.includePrerelease ? "-0" : "", ge ? N === ">" || N === "<" ? R = "<0.0.0-0" : R = "*" : N && tt ? (Re && (I = 0), G = 0, N === ">" ? (N = ">=", Re ? (L = +L + 1, I = 0, G = 0) : (I = +I + 1, G = 0)) : N === "<=" && (N = "<", Re ? L = +L + 1 : I = +I + 1), N === "<" && (ie = "-0"), R = `${N+L}.${I}.${G}${ie}`) : Re ? R = `>=${L}.0.0${ie} <${+L+1}.0.0-0` : Te && (R = `>=${L}.${I}.0${ie} <${L}.${+I+1}.0-0`), s("xRange return", R), R
+                })
+            },
+            C = ($, T) => (s("replaceStars", $, T), $.trim().replace(o[l.STAR], "")),
+            k = ($, T) => (s("replaceGTE0", $, T), $.trim().replace(o[T.includePrerelease ? l.GTE0PRE : l.GTE0], "")),
+            A = $ => (T, M, R, N, L, I, G, ie, ge, Re, Te, tt, wn) => (v(R) ? M = "" : v(N) ? M = `>=${R}.0.0${$?"-0":""}` : v(L) ? M = `>=${R}.${N}.0${$?"-0":""}` : I ? M = `>=${M}` : M = `>=${M}${$?"-0":""}`, v(ge) ? ie = "" : v(Re) ? ie = `<${+ge+1}.0.0-0` : v(Te) ? ie = `<${ge}.${+Re+1}.0-0` : tt ? ie = `<=${ge}.${Re}.${Te}-${tt}` : $ ? ie = `<${ge}.${Re}.${+Te+1}-0` : ie = `<=${ie}`, `${M} ${ie}`.trim()),
+            F = ($, T, M) => {
+                for (let R = 0; R < $.length; R++)
+                    if (!$[R].test(T)) return !1;
+                if (T.prerelease.length && !M.includePrerelease) {
+                    for (let R = 0; R < $.length; R++)
+                        if (s($[R].semver), $[R].semver !== r.ANY && $[R].semver.prerelease.length > 0) {
+                            const N = $[R].semver;
+                            if (N.major === T.major && N.minor === T.minor && N.patch === T.patch) return !0
+                        } return !1
+                }
+                return !0
+            };
+        return vb
+    }
+    const rve = y9(),
+        sve = (e, t, n) => {
+            try {
+                t = new rve(t, n)
+            } catch {
+                return !1
+            }
+            return t.test(e)
+        };
+    var ave = sve,
+        v9 = oye(ave);
+
+    function ove(e, t, n) {
+        const i = e.open(t),
+            r = 1e4,
+            s = 250,
+            {
+                origin: a
+            } = new URL(t);
+        let o = ~~(r / s);
+
+        function l(c) {
+            c.source === i && (o = 0, e.removeEventListener("message", l, !1))
+        }
+        e.addEventListener("message", l, !1);
+
+        function u() {
+            o <= 0 || (i.postMessage(n, a), setTimeout(u, s), o -= 1)
+        }
+        setTimeout(u, s)
+    }
+    var lve = `.vega-embed {
+  position: relative;
+  display: inline-block;
+  box-sizing: border-box;
+}
+.vega-embed.has-actions {
+  padding-right: 38px;
+}
+.vega-embed details:not([open]) > :not(summary) {
+  display: none !important;
+}
+.vega-embed summary {
+  list-style: none;
+  position: absolute;
+  top: 0;
+  right: 0;
+  padding: 6px;
+  z-index: 1000;
+  background: white;
+  box-shadow: 1px 1px 3px rgba(0, 0, 0, 0.1);
+  color: #1b1e23;
+  border: 1px solid #aaa;
+  border-radius: 999px;
+  opacity: 0.2;
+  transition: opacity 0.4s ease-in;
+  cursor: pointer;
+  line-height: 0px;
+}
+.vega-embed summary::-webkit-details-marker {
+  display: none;
+}
+.vega-embed summary:active {
+  box-shadow: #aaa 0px 0px 0px 1px inset;
+}
+.vega-embed summary svg {
+  width: 14px;
+  height: 14px;
+}
+.vega-embed details[open] summary {
+  opacity: 0.7;
+}
+.vega-embed:hover summary, .vega-embed:focus-within summary {
+  opacity: 1 !important;
+  transition: opacity 0.2s ease;
+}
+.vega-embed .vega-actions {
+  position: absolute;
+  z-index: 1001;
+  top: 35px;
+  right: -9px;
+  display: flex;
+  flex-direction: column;
+  padding-bottom: 8px;
+  padding-top: 8px;
+  border-radius: 4px;
+  box-shadow: 0 2px 8px 0 rgba(0, 0, 0, 0.2);
+  border: 1px solid #d9d9d9;
+  background: white;
+  animation-duration: 0.15s;
+  animation-name: scale-in;
+  animation-timing-function: cubic-bezier(0.2, 0, 0.13, 1.5);
+  text-align: left;
+}
+.vega-embed .vega-actions a {
+  padding: 8px 16px;
+  font-family: sans-serif;
+  font-size: 14px;
+  font-weight: 600;
+  white-space: nowrap;
+  color: #434a56;
+  text-decoration: none;
+}
+.vega-embed .vega-actions a:hover, .vega-embed .vega-actions a:focus {
+  background-color: #f7f7f9;
+  color: black;
+}
+.vega-embed .vega-actions::before, .vega-embed .vega-actions::after {
+  content: "";
+  display: inline-block;
+  position: absolute;
+}
+.vega-embed .vega-actions::before {
+  left: auto;
+  right: 14px;
+  top: -16px;
+  border: 8px solid rgba(0, 0, 0, 0);
+  border-bottom-color: #d9d9d9;
+}
+.vega-embed .vega-actions::after {
+  left: auto;
+  right: 15px;
+  top: -14px;
+  border: 7px solid rgba(0, 0, 0, 0);
+  border-bottom-color: #fff;
+}
+.vega-embed .chart-wrapper.fit-x {
+  width: 100%;
+}
+.vega-embed .chart-wrapper.fit-y {
+  height: 100%;
+}
+
+.vega-embed-wrapper {
+  max-width: 100%;
+  overflow: auto;
+  padding-right: 14px;
+}
+
+@keyframes scale-in {
+  from {
+    opacity: 0;
+    transform: scale(0.6);
+  }
+  to {
+    opacity: 1;
+    transform: scale(1);
+  }
+}
+`;
+
+    function b9(e, ...t) {
+        for (const n of t) uve(e, n);
+        return e
+    }
+
+    function uve(e, t) {
+        for (const n of Object.keys(t)) Gc(e, n, t[n], !0)
+    }
+
+    function C3(e, t) {
+        var n = Object.keys(e);
+        if (Object.getOwnPropertySymbols) {
+            var i = Object.getOwnPropertySymbols(e);
+            t && (i = i.filter(function(r) {
+                return Object.getOwnPropertyDescriptor(e, r).enumerable
+            })), n.push.apply(n, i)
+        }
+        return n
+    }
+
+    function Va(e) {
+        for (var t = 1; t < arguments.length; t++) {
+            var n = arguments[t] != null ? arguments[t] : {};
+            t % 2 ? C3(Object(n), !0).forEach(function(i) {
+                aye(e, i, n[i])
+            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : C3(Object(n)).forEach(function(i) {
+                Object.defineProperty(e, i, Object.getOwnPropertyDescriptor(n, i))
+            })
+        }
+        return e
+    }
+    const lr = Ble;
+    let _d = V0e;
+    const rp = typeof window < "u" ? window : void 0;
+    var NO;
+    _d === void 0 && ((NO = rp == null ? void 0 : rp.vl) != null && NO.compile) && (_d = rp.vl);
+    const cve = {
+            export: {
+                svg: !0,
+                png: !0
+            },
+            source: !0,
+            compiled: !0,
+            editor: !0
+        },
+        fve = {
+            CLICK_TO_VIEW_ACTIONS: "Click to view actions",
+            COMPILED_ACTION: "View Compiled Vega",
+            EDITOR_ACTION: "Open in Vega Editor",
+            PNG_ACTION: "Save as PNG",
+            SOURCE_ACTION: "View Source",
+            SVG_ACTION: "Save as SVG"
+        },
+        mh = {
+            vega: "Vega",
+            "vega-lite": "Vega-Lite"
+        },
+        R0 = {
+            vega: lr.version,
+            "vega-lite": _d ? _d.version : "not available"
+        },
+        hve = {
+            vega: e => e,
+            "vega-lite": (e, t) => _d.compile(e, {
+                config: t
+            }).spec
+        },
+        dve = `
+<svg viewBox="0 0 16 16" fill="currentColor" stroke="none" stroke-width="1" stroke-linecap="round" stroke-linejoin="round">
+  <circle r="2" cy="8" cx="2"></circle>
+  <circle r="2" cy="8" cx="8"></circle>
+  <circle r="2" cy="8" cx="14"></circle>
+</svg>`,
+        gve = "chart-wrapper";
+
+    function pve(e) {
+        return typeof e == "function"
+    }
+
+    function A3(e, t, n, i) {
+        const r = `<html><head>${t}</head><body><pre><code class="json">`,
+            s = `</code></pre>${n}</body></html>`,
+            a = window.open("");
+        a.document.write(r + e + s), a.document.title = `${mh[i]} JSON Source`
+    }
+
+    function mve(e, t) {
+        if (e.$schema) {
+            const n = f9(e.$schema);
+            t && t !== n.library && console.warn(`The given visualization spec is written in ${mh[n.library]}, but mode argument sets ${mh[t]??t}.`);
+            const i = n.library;
+            return v9(R0[i], `^${n.version.slice(1)}`) || console.warn(`The input spec uses ${mh[i]} ${n.version}, but the current version of ${mh[i]} is v${R0[i]}.`), i
+        }
+        return "mark" in e || "encoding" in e || "layer" in e || "hconcat" in e || "vconcat" in e || "facet" in e || "repeat" in e ? "vega-lite" : "marks" in e || "signals" in e || "scales" in e || "axes" in e ? "vega" : t ?? "vega"
+    }
+
+    function yve(e) {
+        return !!(e && "load" in e)
+    }
+
+    function $3(e) {
+        return yve(e) ? e : lr.loader(e)
+    }
+
+    function vve(e) {
+        var n;
+        const t = ((n = e.usermeta) == null ? void 0 : n.embedOptions) ?? {};
+        return le(t.defaultStyle) && (t.defaultStyle = !1), t
+    }
+    async function bve(e, t, n = {}) {
+        let i, r;
+        le(t) ? (r = $3(n.loader), i = JSON.parse(await r.load(t))) : i = t;
+        const s = vve(i),
+            a = s.loader;
+        (!r || a) && (r = $3(n.loader ?? a));
+        const o = await T3(s, r),
+            l = await T3(n, r),
+            u = Va(Va({}, b9(l, o)), {}, {
+                config: jc(l.config ?? {}, o.config ?? {})
+            });
+        return await _ve(e, i, u, r)
+    }
+    async function T3(e, t) {
+        const n = le(e.config) ? JSON.parse(await t.load(e.config)) : e.config ?? {},
+            i = le(e.patch) ? JSON.parse(await t.load(e.patch)) : e.patch;
+        return Va(Va(Va({}, e), i ? {
+            patch: i
+        } : {}), n ? {
+            config: n
+        } : {})
+    }
+
+    function xve(e) {
+        const t = e.getRootNode ? e.getRootNode() : document;
+        return t instanceof ShadowRoot ? {
+            root: t,
+            rootContainer: t
+        } : {
+            root: document,
+            rootContainer: document.head ?? document.body
+        }
+    }
+    async function _ve(e, t, n = {}, i) {
+        const r = n.theme ? jc(U1e[n.theme], n.config ?? {}) : n.config,
+            s = mo(n.actions) ? n.actions : b9({}, cve, n.actions ?? {}),
+            a = Va(Va({}, fve), n.i18n),
+            o = n.renderer ?? "canvas",
+            l = n.logLevel ?? lr.Warn,
+            u = n.downloadFileName ?? "visualization",
+            c = typeof e == "string" ? document.querySelector(e) : e;
+        if (!c) throw new Error(`${e} does not exist`);
+        if (n.defaultStyle !== !1) {
+            const _ = "vega-embed-style",
+                {
+                    root: S,
+                    rootContainer: w
+                } = xve(c);
+            if (!S.getElementById(_)) {
+                const E = document.createElement("style");
+                E.id = _, E.innerHTML = n.defaultStyle === void 0 || n.defaultStyle === !0 ? lve.toString() : n.defaultStyle, w.appendChild(E)
+            }
+        }
+        const f = mve(t, n.mode);
+        let h = hve[f](t, r);
+        if (f === "vega-lite" && h.$schema) {
+            const _ = f9(h.$schema);
+            v9(R0.vega, `^${_.version.slice(1)}`) || console.warn(`The compiled spec uses Vega ${_.version}, but current version is v${R0.vega}.`)
+        }
+        c.classList.add("vega-embed"), s && c.classList.add("has-actions"), c.innerHTML = "";
+        let d = c;
+        if (s) {
+            const _ = document.createElement("div");
+            _.classList.add(gve), c.appendChild(_), d = _
+        }
+        const g = n.patch;
+        if (g && (h = g instanceof Function ? g(h) : P0(h, g, !0, !1).newDocument), n.formatLocale && lr.formatLocale(n.formatLocale), n.timeFormatLocale && lr.timeFormatLocale(n.timeFormatLocale), n.expressionFunctions)
+            for (const _ in n.expressionFunctions) {
+                const S = n.expressionFunctions[_];
+                "fn" in S ? lr.expressionFunction(_, S.fn, S.visitor) : S instanceof Function && lr.expressionFunction(_, S)
+            }
+        const {
+            ast: p
+        } = n, m = lr.parse(h, f === "vega-lite" ? {} : r, {
+            ast: p
+        }), y = new(n.viewClass || lr.View)(m, Va({
+            loader: i,
+            logLevel: l,
+            renderer: o
+        }, p ? {
+            expr: lr.expressionInterpreter ?? n.expr ?? Kle
+        } : {}));
+        if (y.addSignalListener("autosize", (_, S) => {
+                const {
+                    type: w
+                } = S;
+                w == "fit-x" ? (d.classList.add("fit-x"), d.classList.remove("fit-y")) : w == "fit-y" ? (d.classList.remove("fit-x"), d.classList.add("fit-y")) : w == "fit" ? d.classList.add("fit-x", "fit-y") : d.classList.remove("fit-x", "fit-y")
+            }), n.tooltip !== !1) {
+            const _ = pve(n.tooltip) ? n.tooltip : new iye(n.tooltip === !0 ? {} : n.tooltip).call;
+            y.tooltip(_)
+        }
+        let {
+            hover: v
+        } = n;
+        if (v === void 0 && (v = f === "vega"), v) {
+            const {
+                hoverSet: _,
+                updateSet: S
+            } = typeof v == "boolean" ? {} : v;
+            y.hover(_, S)
+        }
+        n && (n.width != null && y.width(n.width), n.height != null && y.height(n.height), n.padding != null && y.padding(n.padding)), await y.initialize(d, n.bind).runAsync();
+        let b;
+        if (s !== !1) {
+            let _ = c;
+            if (n.defaultStyle !== !1) {
+                const w = document.createElement("details");
+                w.title = a.CLICK_TO_VIEW_ACTIONS, c.append(w), _ = w;
+                const E = document.createElement("summary");
+                E.innerHTML = dve, w.append(E), b = C => {
+                    w.contains(C.target) || w.removeAttribute("open")
+                }, document.addEventListener("click", b)
+            }
+            const S = document.createElement("div");
+            if (_.append(S), S.classList.add("vega-actions"), s === !0 || s.export !== !1) {
+                for (const w of ["svg", "png"])
+                    if (s === !0 || s.export === !0 || s.export[w]) {
+                        const E = a[`${w.toUpperCase()}_ACTION`],
+                            C = document.createElement("a"),
+                            k = ce(n.scaleFactor) ? n.scaleFactor[w] : n.scaleFactor;
+                        C.text = E, C.href = "#", C.target = "_blank", C.download = `${u}.${w}`, C.addEventListener("mousedown", async function(A) {
+                            A.preventDefault();
+                            const F = await y.toImageURL(w, k);
+                            this.href = F
+                        }), S.append(C)
+                    }
+            }
+            if (s === !0 || s.source !== !1) {
+                const w = document.createElement("a");
+                w.text = a.SOURCE_ACTION, w.href = "#", w.addEventListener("click", function(E) {
+                    A3(Yy(t), n.sourceHeader ?? "", n.sourceFooter ?? "", f), E.preventDefault()
+                }), S.append(w)
+            }
+            if (f === "vega-lite" && (s === !0 || s.compiled !== !1)) {
+                const w = document.createElement("a");
+                w.text = a.COMPILED_ACTION, w.href = "#", w.addEventListener("click", function(E) {
+                    A3(Yy(h), n.sourceHeader ?? "", n.sourceFooter ?? "", "vega"), E.preventDefault()
+                }), S.append(w)
+            }
+            if (s === !0 || s.editor !== !1) {
+                const w = n.editorUrl ?? "https://vega.github.io/editor/",
+                    E = document.createElement("a");
+                E.text = a.EDITOR_ACTION, E.href = "#", E.addEventListener("click", function(C) {
+                    ove(window, w, {
+                        config: r,
+                        mode: f,
+                        renderer: o,
+                        spec: Yy(t)
+                    }), C.preventDefault()
+                }), S.append(E)
+            }
+        }
+
+        function x() {
+            b && document.removeEventListener("click", b), y.finalize()
+        }
+        return {
+            view: y,
+            spec: t,
+            vgSpec: h,
+            finalize: x,
+            embedOptions: n
+        }
+    }
+    const wve = new Set(["width", "height"]);
+
+    function Sve(e, t) {
+        for (const [n, i] of Object.entries(t)) i && (i && {}.toString.call(i) === "[object Function]" ? i(e.data(n)) : e.change(n, lr.changeset().remove(() => !0).insert(i)))
+    }
+
+    function sp(e = {}, t = {}, n = new Set) {
+        const i = Object.keys(e),
+            r = Object.keys(t);
+        return e === t || i.length === r.length && i.filter(s => !n.has(s)).every(s => e[s] === t[s])
+    }
+
+    function M3(e, t) {
+        const n = Object.keys(t);
+        for (const i of n) try {
+            e.removeSignalListener(i, t[i])
+        } catch (r) {
+            console.warn("Cannot remove invalid signal listener.", r)
+        }
+        return n.length > 0
+    }
+
+    function bb(e, t) {
+        const n = Object.keys(t);
+        for (const i of n) try {
+            e.addSignalListener(i, t[i])
+        } catch (r) {
+            console.warn("Cannot add invalid signal listener.", r)
+        }
+        return n.length > 0
+    }
+
+    function Eve(e) {
+        return new Set(e.flatMap(t => Object.keys(t)))
+    }
+
+    function kve(e, t) {
+        if (e === t) return !1;
+        const n = {
+                width: !1,
+                height: !1,
+                isExpensive: !1
+            },
+            i = "width" in e || "width" in t,
+            r = "height" in e || "height" in t;
+        return i && (!("width" in e) || !("width" in t) || e.width !== t.width) && ("width" in e && typeof e.width == "number" ? n.width = e.width : n.isExpensive = !0), r && (!("height" in e) || !("height" in t) || e.height !== t.height) && ("height" in e && typeof e.height == "number" ? n.height = e.height : n.isExpensive = !0), [...Eve([e, t])].filter(a => a !== "width" && a !== "height").some(a => !(a in e) || !(a in t) || !YI(e[a], t[a])) && (n.isExpensive = !0), n.width !== !1 || n.height !== !1 || n.isExpensive ? n : !1
+    }
+
+    function O3(e, t) {
+        const {
+            width: n,
+            height: i
+        } = t;
+        return typeof n < "u" && typeof i < "u" ? {
+            ...e,
+            width: n,
+            height: i
+        } : typeof n < "u" ? {
+            ...e,
+            width: n
+        } : typeof i < "u" ? {
+            ...e,
+            height: i
+        } : e
+    }
+
+    function Cve(e) {
+        let t;
+        return {
+            c() {
+                t = V("div")
+            },
+            m(n, i) {
+                de(n, t, i), e[11](t)
+            },
+            p: Ue,
+            i: Ue,
+            o: Ue,
+            d(n) {
+                n && he(t), e[11](null)
+            }
+        }
+    }
+
+    function Ave(e, t, n) {
+        let {
+            options: i
+        } = t, {
+            spec: r
+        } = t, {
+            view: s
+        } = t, {
+            signalListeners: a = {}
+        } = t, {
+            data: o = {}
+        } = t;
+        const l = er();
+        let u, c = {},
+            f = {},
+            h = {},
+            d = {},
+            g;
+        Sd(() => {
+            m()
+        });
+        async function p() {
+            m();
+            try {
+                n(6, u = await bve(g, r, i)), n(1, s = u.view), bb(s, a) && s.runAsync(), v(s)
+            } catch (_) {
+                y(_)
+            }
+        }
+
+        function m() {
+            u && (u.finalize(), n(6, u = void 0), n(1, s = void 0))
+        }
+
+        function y(_) {
+            l("onError", {
+                error: _
+            }), console.warn(_)
+        }
+
+        function v(_) {
+            b(), l("onNewView", {
+                view: _
+            })
+        }
+        async function b() {
+            o && Object.keys(o).length > 0 && u !== void 0 && (n(1, s = u.view), Sve(s, o), await s.resize().runAsync())
+        }
+
+        function x(_) {
+            Hi[_ ? "unshift" : "push"](() => {
+                g = _, n(0, g)
+            })
+        }
+        return e.$$set = _ => {
+            "options" in _ && n(2, i = _.options), "spec" in _ && n(3, r = _.spec), "view" in _ && n(1, s = _.view), "signalListeners" in _ && n(4, a = _.signalListeners), "data" in _ && n(5, o = _.data)
+        }, e.$$.update = () => {
+            if (e.$$.dirty & 1056 && (sp(o, d) || b(), n(10, d = o)), e.$$.dirty & 991 && g !== void 0) {
+                if (!sp(i, c, wve)) p();
+                else {
+                    const _ = kve(O3(r, i), O3(h, c)),
+                        S = a,
+                        w = f;
+                    if (_) {
+                        if (_.isExpensive) p();
+                        else if (u !== void 0) {
+                            const E = !sp(S, w);
+                            n(1, s = u.view), _.width !== !1 && s.width(_.width), _.height !== !1 && s.height(_.height), E && (w && M3(s, w), S && bb(s, S)), s.runAsync()
+                        }
+                    } else !sp(S, w) && u !== void 0 && (n(1, s = u.view), w && M3(s, w), S && bb(s, S), s.runAsync())
+                }
+                n(7, c = i), n(8, f = a), n(9, h = r)
+            }
+        }, [g, s, i, r, a, o, u, c, f, h, d, x]
+    }
+    class $ve extends It {
+        constructor(t) {
+            super(), Lt(this, t, Ave, Cve, Tt, {
+                options: 2,
+                spec: 3,
+                view: 1,
+                signalListeners: 4,
+                data: 5
+            })
+        }
+    }
+
+    function Tve(e) {
+        let t, n, i;
+
+        function r(a) {
+            e[6](a)
+        }
+        let s = {
+            spec: e[1],
+            data: e[2],
+            signalListeners: e[3],
+            options: e[4]
+        };
+        return e[0] !== void 0 && (s.view = e[0]), t = new $ve({
+            props: s
+        }), Hi.push(() => xl(t, "view", r)), t.$on("onNewView", e[7]), t.$on("onError", e[8]), {
+            c() {
+                St(t.$$.fragment)
+            },
+            m(a, o) {
+                xt(t, a, o), i = !0
+            },
+            p(a, [o]) {
+                const l = {};
+                o & 2 && (l.spec = a[1]), o & 4 && (l.data = a[2]), o & 8 && (l.signalListeners = a[3]), o & 16 && (l.options = a[4]), !n && o & 1 && (n = !0, l.view = a[0], bl(() => n = !1)), t.$set(l)
+            },
+            i(a) {
+                i || (fe(t.$$.fragment, a), i = !0)
+            },
+            o(a) {
+                ve(t.$$.fragment, a), i = !1
+            },
+            d(a) {
+                _t(t, a)
+            }
+        }
+    }
+    const Mve = "vega-lite";
+
+    function Ove(e, t, n) {
+        let i, {
+                spec: r
+            } = t,
+            {
+                options: s = {}
+            } = t,
+            {
+                data: a = {}
+            } = t,
+            {
+                signalListeners: o = {}
+            } = t,
+            {
+                view: l = void 0
+            } = t;
+
+        function u(h) {
+            l = h, n(0, l)
+        }
+
+        function c(h) {
+            ZC.call(this, e, h)
+        }
+
+        function f(h) {
+            ZC.call(this, e, h)
+        }
+        return e.$$set = h => {
+            "spec" in h && n(1, r = h.spec), "options" in h && n(5, s = h.options), "data" in h && n(2, a = h.data), "signalListeners" in h && n(3, o = h.signalListeners), "view" in h && n(0, l = h.view)
+        }, e.$$.update = () => {
+            e.$$.dirty & 32 && n(4, i = {
+                ...s,
+                mode: Mve
+            })
+        }, [l, r, a, o, i, s, u, c, f]
+    }
+    class Fve extends It {
+        constructor(t) {
+            super(), Lt(this, t, Ove, Tve, Tt, {
+                spec: 1,
+                options: 5,
+                data: 2,
+                signalListeners: 3,
+                view: 0
+            })
+        }
+    }
+
+    function Rve(e) {
+        let t, n, i = e[0].name + "",
+            r, s, a, o, l;
+        return o = new Fve({
+            props: {
+                spec: e[1],
+                options: e[2]
+            }
+        }), {
+            c() {
+                t = V("div"), n = V("span"), r = Xe(i), s = we(), a = V("div"), St(o.$$.fragment), z(n, "class", "py-1 text-sm font-bold text-zinc-900"), z(a, "class", "max-h-48 w-full place-items-center overflow-y-scroll"), z(t, "class", "h-full w-full flex flex-col justify-center items-center border rounded-lg bg-zinc-100")
+            },
+            m(u, c) {
+                de(u, t, c), B(t, n), B(n, r), B(t, s), B(t, a), xt(o, a, null), l = !0
+            },
+            p(u, [c]) {
+                (!l || c & 1) && i !== (i = u[0].name + "") && At(r, i);
+                const f = {};
+                c & 2 && (f.spec = u[1]), o.$set(f)
+            },
+            i(u) {
+                l || (fe(o.$$.fragment, u), l = !0)
+            },
+            o(u) {
+                ve(o.$$.fragment, u), l = !1
+            },
+            d(u) {
+                u && he(t), _t(o)
+            }
+        }
+    }
+
+    function Dve(e, t, n) {
+        let {
+            hist: i
+        } = t, r = 10 * i.histogram.length;
+        r = r < 175 ? 175 : r;
+        let s = {
+            $schema: "https://vega.github.io/schema/vega-lite/v5.json",
+            config: {
+                style: {
+                    cell: {
+                        stroke: "transparent"
+                    }
+                }
+            },
+            params: [{
+                name: "highlight",
+                select: {
+                    type: "point",
+                    on: "mouseover"
+                }
+            }],
+            data: {
+                values: i.histogram
+            },
+            height: r,
+            width: 150,
+            background: "transparent",
+            mark: {
+                type: "bar",
+                tooltip: !0
+            },
+            encoding: {
+                x: {
+                    field: "counts",
+                    type: "quantitative",
+                    axis: {
+                        title: null,
+                        grid: !1,
+                        domain: !1,
+                        ticks: !1,
+                        labels: !1
+                    }
+                },
+                y: {
+                    field: i.name,
+                    type: "nominal",
+                    sort: "-x",
+                    axis: {
+                        title: null,
+                        domain: !1,
+                        grid: !1,
+                        ticks: !1,
+                        labelLimit: 50,
+                        labelPadding: 10
+                    }
+                },
+                color: {
+                    condition: [{
+                        param: "highlight",
+                        empty: !1,
+                        value: "grey"
+                    }],
+                    field: "split"
+                }
+            }
+        };
+        if (i.type == "numerical") {
+            for (let o = 0; o < i.histogram.length; ++o) {
+                let l = i.histogram[o];
+                l.bin_range = l.bin_start + "-" + l.bin_end
+            }
+            s.encoding.y.field = "bin_range", s.encoding.y.sort = null
+        }
+        const a = {
+            actions: !1
+        };
+        return e.$$set = o => {
+            "hist" in o && n(0, i = o.hist)
+        }, [i, s, a]
+    }
+    class x9 extends It {
+        constructor(t) {
+            super(), Lt(this, t, Dve, Rve, Tt, {
+                hist: 0
+            })
+        }
+    }
+
+    function Nve(e) {
+        let t, n;
+        return t = new x9({
+            props: {
+                hist: e[0]
+            }
+        }), {
+            c() {
+                St(t.$$.fragment)
+            },
+            m(i, r) {
+                xt(t, i, r), n = !0
+            },
+            p(i, [r]) {
+                const s = {};
+                r & 1 && (s.hist = i[0]), t.$set(s)
+            },
+            i(i) {
+                n || (fe(t.$$.fragment, i), n = !0)
+            },
+            o(i) {
+                ve(t.$$.fragment, i), n = !1
+            },
+            d(i) {
+                _t(t, i)
+            }
+        }
+    }
+
+    function Pve(e, t, n) {
+        let {
+            value: i
+        } = t;
+        return e.$$set = r => {
+            "value" in r && n(0, i = r.value)
+        }, [i]
+    }
+    class Lve extends It {
+        constructor(t) {
+            super(), Lt(this, t, Pve, Nve, Tt, {
+                value: 0
+            })
+        }
+    }
+
+    function Ive(e) {
+        let t, n, i;
+        var r = e[1][e[0].dtype];
+
+        function s(a) {
+            return {
+                props: {
+                    value: a[0].value
+                }
+            }
+        }
+        return r && (t = JC(r, s(e))), {
+            c() {
+                t && St(t.$$.fragment), n = Zi()
+            },
+            m(a, o) {
+                t && xt(t, a, o), de(a, n, o), i = !0
+            },
+            p(a, [o]) {
+                const l = {};
+                if (o & 1 && (l.value = a[0].value), o & 1 && r !== (r = a[1][a[0].dtype])) {
+                    if (t) {
+                        on();
+                        const u = t;
+                        ve(u.$$.fragment, 1, 0, () => {
+                            _t(u, 1)
+                        }), ln()
+                    }
+                    r ? (t = JC(r, s(a)), St(t.$$.fragment), fe(t.$$.fragment, 1), xt(t, n.parentNode, n)) : t = null
+                } else r && t.$set(l)
+            },
+            i(a) {
+                i || (t && fe(t.$$.fragment, a), i = !0)
+            },
+            o(a) {
+                t && ve(t.$$.fragment, a), i = !1
+            },
+            d(a) {
+                a && he(n), t && _t(t, a)
+            }
+        }
+    }
+
+    function zve(e, t, n) {
+        let {
+            data: i
+        } = t;
+        const r = {
+            number: tB,
+            text: rB,
+            image: oB,
+            histogram: Lve
+        };
+        return e.$$set = s => {
+            "data" in s && n(0, i = s.data)
+        }, [i, r]
+    }
+    class Bve extends It {
+        constructor(t) {
+            super(), Lt(this, t, zve, Ive, Tt, {
+                data: 0
+            })
+        }
+    }
+
+    function F3(e, t, n) {
+        const i = e.slice();
+        return i[5] = t[n], i
+    }
+
+    function R3(e, t, n) {
+        const i = e.slice();
+        return i[8] = t[n], i
+    }
+
+    function D3(e, t, n) {
+        const i = e.slice();
+        return i[11] = t[n].name, i[12] = t[n].type, i
+    }
+
+    function N3(e) {
+        let t, n = e[11] + "",
+            i;
+        return {
+            c() {
+                t = V("th"), i = Xe(n), z(t, "class", "pl-2 py-1")
+            },
+            m(r, s) {
+                de(r, t, s), B(t, i)
+            },
+            p(r, s) {
+                s & 1 && n !== (n = r[11] + "") && At(i, n)
+            },
+            d(r) {
+                r && he(t)
+            }
+        }
+    }
+
+    function P3(e) {
+        let t, n = e[12] != "hidden" && N3(e);
+        return {
+            c() {
+                n && n.c(), t = Zi()
+            },
+            m(i, r) {
+                n && n.m(i, r), de(i, t, r)
+            },
+            p(i, r) {
+                i[12] != "hidden" ? n ? n.p(i, r) : (n = N3(i), n.c(), n.m(t.parentNode, t)) : n && (n.d(1), n = null)
+            },
+            d(i) {
+                n && n.d(i), i && he(t)
+            }
+        }
+    }
+
+    function L3(e) {
+        let t, n, i;
+        return n = new Bve({
+            props: {
+                data: e[8]
+            }
+        }), {
+            c() {
+                t = V("td"), St(n.$$.fragment), z(t, "class", "border-b py-2")
+            },
+            m(r, s) {
+                de(r, t, s), xt(n, t, null), i = !0
+            },
+            p(r, s) {
+                const a = {};
+                s & 2 && (a.data = r[8]), n.$set(a)
+            },
+            i(r) {
+                i || (fe(n.$$.fragment, r), i = !0)
+            },
+            o(r) {
+                ve(n.$$.fragment, r), i = !1
+            },
+            d(r) {
+                r && he(t), _t(n)
+            }
+        }
+    }
+
+    function I3(e) {
+        let t, n, i = e[8].dtype != "hidden" && L3(e);
+        return {
+            c() {
+                i && i.c(), t = Zi()
+            },
+            m(r, s) {
+                i && i.m(r, s), de(r, t, s), n = !0
+            },
+            p(r, s) {
+                r[8].dtype != "hidden" ? i ? (i.p(r, s), s & 2 && fe(i, 1)) : (i = L3(r), i.c(), fe(i, 1), i.m(t.parentNode, t)) : i && (on(), ve(i, 1, 1, () => {
+                    i = null
+                }), ln())
+            },
+            i(r) {
+                n || (fe(i), n = !0)
+            },
+            o(r) {
+                ve(i), n = !1
+            },
+            d(r) {
+                i && i.d(r), r && he(t)
+            }
+        }
+    }
+
+    function z3(e) {
+        let t, n, i, r, s, a = e[5],
+            o = [];
+        for (let c = 0; c < a.length; c += 1) o[c] = I3(R3(e, a, c));
+        const l = c => ve(o[c], 1, 1, () => {
+            o[c] = null
+        });
+
+        function u() {
+            return e[3](e[5])
+        }
+        return {
+            c() {
+                t = V("tr");
+                for (let c = 0; c < o.length; c += 1) o[c].c();
+                n = we(), z(t, "class", "cursor-pointer hover:bg-zinc-100")
+            },
+            m(c, f) {
+                de(c, t, f);
+                for (let h = 0; h < o.length; h += 1) o[h] && o[h].m(t, null);
+                B(t, n), i = !0, r || (s = jt(t, "click", u), r = !0)
+            },
+            p(c, f) {
+                if (e = c, f & 2) {
+                    a = e[5];
+                    let h;
+                    for (h = 0; h < a.length; h += 1) {
+                        const d = R3(e, a, h);
+                        o[h] ? (o[h].p(d, f), fe(o[h], 1)) : (o[h] = I3(d), o[h].c(), fe(o[h], 1), o[h].m(t, n))
+                    }
+                    for (on(), h = a.length; h < o.length; h += 1) l(h);
+                    ln()
+                }
+            },
+            i(c) {
+                if (!i) {
+                    for (let f = 0; f < a.length; f += 1) fe(o[f]);
+                    i = !0
+                }
+            },
+            o(c) {
+                o = o.filter(Boolean);
+                for (let f = 0; f < o.length; f += 1) ve(o[f]);
+                i = !1
+            },
+            d(c) {
+                c && he(t), Ja(o, c), r = !1, s()
+            }
+        }
+    }
+
+    function jve(e) {
+        let t, n, i, r, s, a, o, l = e[0],
+            u = [];
+        for (let d = 0; d < l.length; d += 1) u[d] = P3(D3(e, l, d));
+        let c = e[1],
+            f = [];
+        for (let d = 0; d < c.length; d += 1) f[d] = z3(F3(e, c, d));
+        const h = d => ve(f[d], 1, 1, () => {
+            f[d] = null
+        });
+        return {
+            c() {
+                t = V("div"), n = V("table"), i = V("thead"), r = V("tr");
+                for (let d = 0; d < u.length; d += 1) u[d].c();
+                s = we(), a = V("tbody");
+                for (let d = 0; d < f.length; d += 1) f[d].c();
+                z(r, "class", "sticky p-2 top-0 bg-zinc-100 border-b-2"), z(i, "class", "text-xs text-zinc-700 uppercase"), z(n, "class", "table-auto w-full text-sm text-left"), z(t, "class", "h-full bg-white overflow-y-auto overflow-x-auto border rounded-lg")
+            },
+            m(d, g) {
+                de(d, t, g), B(t, n), B(n, i), B(i, r);
+                for (let p = 0; p < u.length; p += 1) u[p] && u[p].m(r, null);
+                B(n, s), B(n, a);
+                for (let p = 0; p < f.length; p += 1) f[p] && f[p].m(a, null);
+                o = !0
+            },
+            p(d, [g]) {
+                if (g & 1) {
+                    l = d[0];
+                    let p;
+                    for (p = 0; p < l.length; p += 1) {
+                        const m = D3(d, l, p);
+                        u[p] ? u[p].p(m, g) : (u[p] = P3(m), u[p].c(), u[p].m(r, null))
+                    }
+                    for (; p < u.length; p += 1) u[p].d(1);
+                    u.length = l.length
+                }
+                if (g & 6) {
+                    c = d[1];
+                    let p;
+                    for (p = 0; p < c.length; p += 1) {
+                        const m = F3(d, c, p);
+                        f[p] ? (f[p].p(m, g), fe(f[p], 1)) : (f[p] = z3(m), f[p].c(), fe(f[p], 1), f[p].m(a, null))
+                    }
+                    for (on(), p = c.length; p < f.length; p += 1) h(p);
+                    ln()
+                }
+            },
+            i(d) {
+                if (!o) {
+                    for (let g = 0; g < c.length; g += 1) fe(f[g]);
+                    o = !0
+                }
+            },
+            o(d) {
+                f = f.filter(Boolean);
+                for (let g = 0; g < f.length; g += 1) ve(f[g]);
+                o = !1
+            },
+            d(d) {
+                d && he(t), Ja(u, d), Ja(f, d)
+            }
+        }
+    }
+
+    function Gve(e, t, n) {
+        let {
+            featureNames: i
+        } = t, {
+            features: r
+        } = t;
+        const s = er();
+
+        function a(l) {
+            const u = l.find(c => c.name === "id");
+            s("itemclick", {
+                id: u.value
+            })
+        }
+        const o = l => {
+            a(l)
+        };
+        return e.$$set = l => {
+            "featureNames" in l && n(0, i = l.featureNames), "features" in l && n(1, r = l.features)
+        }, [i, r, a, o]
+    }
+    class Uve extends It {
+        constructor(t) {
+            super(), Lt(this, t, Gve, jve, Tt, {
+                featureNames: 0,
+                features: 1
+            })
+        }
+    }
+    const Tu = [];
+
+    function By(e, t = Ue) {
+        let n;
+        const i = new Set;
+
+        function r(o) {
+            if (Tt(e, o) && (e = o, n)) {
+                const l = !Tu.length;
+                for (const u of i) u[1](), Tu.push(u, e);
+                if (l) {
+                    for (let u = 0; u < Tu.length; u += 2) Tu[u][0](Tu[u + 1]);
+                    Tu.length = 0
+                }
+            }
+        }
+
+        function s(o) {
+            r(o(e))
+        }
+
+        function a(o, l = Ue) {
+            const u = [o, l];
+            return i.add(u), i.size === 1 && (n = t(r) || Ue), o(e), () => {
+                i.delete(u), i.size === 0 && n && (n(), n = null)
+            }
+        }
+        return {
+            set: r,
+            update: s,
+            subscribe: a
+        }
+    }
+    /**
+    @copyright CEA-LIST/DIASI/SIALV/LVA (2023)
+    @author CEA-LIST/DIASI/SIALV/LVA <pixano@cea.fr>
+    @license CECILL-C
+
+    This software is a collaborative computer program whose purpose is to
+    generate and explore labeled data for computer vision applications.
+    This software is governed by the CeCILL-C license under French law and
+    abiding by the rules of distribution of free software. You can use, 
+    modify and/ or redistribute the software under the terms of the CeCILL-C
+    license as circulated by CEA, CNRS and INRIA at the following URL
+
+    http://www.cecill.info
+    */
+    const qp = By(1);
+
+    function B3(e, t, n) {
+        const i = e.slice();
+        return i[9] = t[n], i
+    }
+
+    function Wve(e) {
+        let t;
+        return {
+            c() {
+                t = V("span"), t.textContent = "No stats available.", z(t, "class", "mt-80 italic text-zinc-500")
+            },
+            m(n, i) {
+                de(n, t, i)
+            },
+            p: Ue,
+            i: Ue,
+            o: Ue,
+            d(n) {
+                n && he(t)
+            }
+        }
+    }
+
+    function qve(e) {
+        let t, n, i = e[0],
+            r = [];
+        for (let a = 0; a < i.length; a += 1) r[a] = j3(B3(e, i, a));
+        const s = a => ve(r[a], 1, 1, () => {
+            r[a] = null
+        });
+        return {
+            c() {
+                t = V("div");
+                for (let a = 0; a < r.length; a += 1) r[a].c();
+                z(t, "class", "grid grid-cols-1 2xl:grid-cols-2 w-full gap-4 p-4")
+            },
+            m(a, o) {
+                de(a, t, o);
+                for (let l = 0; l < r.length; l += 1) r[l] && r[l].m(t, null);
+                n = !0
+            },
+            p(a, o) {
+                if (o & 1) {
+                    i = a[0];
+                    let l;
+                    for (l = 0; l < i.length; l += 1) {
+                        const u = B3(a, i, l);
+                        r[l] ? (r[l].p(u, o), fe(r[l], 1)) : (r[l] = j3(u), r[l].c(), fe(r[l], 1), r[l].m(t, null))
+                    }
+                    for (on(), l = i.length; l < r.length; l += 1) s(l);
+                    ln()
+                }
+            },
+            i(a) {
+                if (!n) {
+                    for (let o = 0; o < i.length; o += 1) fe(r[o]);
+                    n = !0
+                }
+            },
+            o(a) {
+                r = r.filter(Boolean);
+                for (let o = 0; o < r.length; o += 1) ve(r[o]);
+                n = !1
+            },
+            d(a) {
+                a && he(t), Ja(r, a)
+            }
+        }
+    }
+
+    function j3(e) {
+        let t, n, i, r;
+        return n = new x9({
+            props: {
+                hist: e[9]
+            }
+        }), {
+            c() {
+                t = V("div"), St(n.$$.fragment), i = we(), z(t, "class", "w-full")
+            },
+            m(s, a) {
+                de(s, t, a), xt(n, t, null), B(t, i), r = !0
+            },
+            p(s, a) {
+                const o = {};
+                a & 1 && (o.hist = s[9]), n.$set(o)
+            },
+            i(s) {
+                r || (fe(n.$$.fragment, s), r = !0)
+            },
+            o(s) {
+                ve(n.$$.fragment, s), r = !1
+            },
+            d(s) {
+                s && he(t), _t(n)
+            }
+        }
+    }
+
+    function Hve(e) {
+        let t;
+        return {
+            c() {
+                t = V("div"), t.innerHTML = '<span class="text-zinc-500 italic">Loading items ...</span>', z(t, "class", "h-full flex justify-center items-center")
+            },
+            m(n, i) {
+                de(n, t, i)
+            },
+            p: Ue,
+            i: Ue,
+            o: Ue,
+            d(n) {
+                n && he(t)
+            }
+        }
+    }
+
+    function Yve(e) {
+        let t, n, i, r, s, a = 1 + ja * (e[3] - 1) + "",
+            o, l, u = Math.min(ja * e[3], e[1].total) + "",
+            c, f, h = e[1].total + "",
+            d, g, p, m, y, v, b, x;
+        return n = new Uve({
+            props: {
+                features: e[1].items,
+                featureNames: e[2]
+            }
+        }), n.$on("itemclick", e[4]), {
+            c() {
+                t = V("div"), St(n.$$.fragment), i = we(), r = V("div"), s = V("span"), o = Xe(a), l = Xe(" - "), c = Xe(u), f = Xe(" of "), d = Xe(h), g = we(), p = V("button"), p.textContent = "PREV", m = we(), y = V("button"), y.textContent = "NEXT", z(t, "class", "h-[85vh] w-full max-w-7xl"), z(s, "class", "mr-2"), z(p, "class", "py-1 px-2 bg-white border-2 rounded-lg text-zinc-500 text-sm font-medium hover:bg-zinc-100 dark:bg-zinc-900 dark:border-zinc-800 dark:text-zinc-300 dark:hover:bg-zinc-700"), z(y, "class", "py-1 px-2 bg-white border-2 rounded-lg text-zinc-500 text-sm font-medium hover:bg-zinc-100 dark:bg-zinc-900 dark:border-zinc-800 dark:text-zinc-300 dark:hover:bg-zinc-700"), z(r, "class", "flex justify-end items-center w-full max-w-7xl space-x-2 p-4")
+            },
+            m(_, S) {
+                de(_, t, S), xt(n, t, null), de(_, i, S), de(_, r, S), B(r, s), B(s, o), B(s, l), B(s, c), B(s, f), B(s, d), B(r, g), B(r, p), B(r, m), B(r, y), v = !0, b || (x = [jt(p, "click", e[5]), jt(y, "click", e[6])], b = !0)
+            },
+            p(_, S) {
+                const w = {};
+                S & 2 && (w.features = _[1].items), S & 4 && (w.featureNames = _[2]), n.$set(w), (!v || S & 8) && a !== (a = 1 + ja * (_[3] - 1) + "") && At(o, a), (!v || S & 10) && u !== (u = Math.min(ja * _[3], _[1].total) + "") && At(c, u), (!v || S & 2) && h !== (h = _[1].total + "") && At(d, h)
+            },
+            i(_) {
+                v || (fe(n.$$.fragment, _), v = !0)
+            },
+            o(_) {
+                ve(n.$$.fragment, _), v = !1
+            },
+            d(_) {
+                _ && he(t), _t(n), _ && he(i), _ && he(r), b = !1, po(x)
+            }
+        }
+    }
+
+    function Xve(e) {
+        let t, n, i, r, s, a, o, l, u, c, f, h;
+        const d = [qve, Wve],
+            g = [];
+
+        function p(b, x) {
+            return b[0] != null && b[0].length != 0 ? 0 : 1
+        }
+        a = p(e), o = g[a] = d[a](e);
+        const m = [Yve, Hve],
+            y = [];
+
+        function v(b, x) {
+            return b[1] ? 0 : 1
+        }
+        return c = v(e), f = y[c] = m[c](e), {
+            c() {
+                t = V("div"), n = V("div"), i = V("div"), r = V("span"), r.textContent = "Stats", s = we(), o.c(), l = we(), u = V("div"), f.c(), z(r, "class", "font-bold text-xl mt-3"), z(i, "class", "w-1/2 h-[85vh] flex flex-col items-center border rounded-lg overflow-y-scroll max-w-5xl dark:border-zinc-700 dark:bg-zinc-800"), z(u, "class", "w-1/2 ml-4"), z(n, "class", "flex"), z(t, "class", "mt-4 px-2")
+            },
+            m(b, x) {
+                de(b, t, x), B(t, n), B(n, i), B(i, r), B(i, s), g[a].m(i, null), B(n, l), B(n, u), y[c].m(u, null), h = !0
+            },
+            p(b, [x]) {
+                let _ = a;
+                a = p(b), a === _ ? g[a].p(b, x) : (on(), ve(g[_], 1, 1, () => {
+                    g[_] = null
+                }), ln(), o = g[a], o ? o.p(b, x) : (o = g[a] = d[a](b), o.c()), fe(o, 1), o.m(i, null));
+                let S = c;
+                c = v(b), c === S ? y[c].p(b, x) : (on(), ve(y[S], 1, 1, () => {
+                    y[S] = null
+                }), ln(), f = y[c], f ? f.p(b, x) : (f = y[c] = m[c](b), f.c()), fe(f, 1), f.m(u, null))
+            },
+            i(b) {
+                h || (fe(o), fe(f), h = !0)
+            },
+            o(b) {
+                ve(o), ve(f), h = !1
+            },
+            d(b) {
+                b && he(t), g[a].d(), y[c].d()
+            }
+        }
+    }
+    let ja = 100;
+
+    function Vve(e, t, n) {
+        let {
+            dataset: i = null
+        } = t, r = null, s = null, a, o;
+        qp.subscribe(h => {
+            n(3, o = h)
+        });
+        const l = er();
+
+        function u(h) {
+            l("itemclick", {
+                id: h.detail.id
+            })
+        }
+        async function c() {
+            o > 1 ? (qp.update(h => h - 1), n(1, s = null), n(1, s = await Hy(i.id, o, ja))) : alert("There is no previous page.")
+        }
+        async function f() {
+            s.total > o * ja ? (qp.update(h => h + 1), n(1, s = null), n(1, s = await Hy(i.id, o, ja))) : alert("Last page reached.")
+        }
+        return ra(async () => {
+            n(1, s = await Hy(i.id, o, ja)), n(2, a = s.items[0].map(h => ({
+                name: h.name,
+                type: h.dtype
+            }))), n(0, r = await J7(i.id))
+        }), e.$$set = h => {
+            "dataset" in h && n(7, i = h.dataset)
+        }, [r, s, a, o, u, c, f, i]
+    }
+    class Kve extends It {
+        constructor(t) {
+            super(), Lt(this, t, Vve, Xve, Tt, {
+                dataset: 7
+            })
+        }
+    }
+    var Jve = Math.PI / 180;
+
+    function Qve() {
+        return typeof window < "u" && ({}.toString.call(window) === "[object Window]" || {}.toString.call(window) === "[object global]")
+    }
+    const tc = typeof global < "u" ? global : typeof window < "u" ? window : typeof WorkerGlobalScope < "u" ? self : {},
+        pe = {
+            _global: tc,
+            version: "8.4.3",
+            isBrowser: Qve(),
+            isUnminified: /param/.test((function(e) {}).toString()),
+            dblClickWindow: 400,
+            getAngle(e) {
+                return pe.angleDeg ? e * Jve : e
+            },
+            enableTrace: !1,
+            pointerEventsEnabled: !0,
+            autoDrawEnabled: !0,
+            hitOnDragEnabled: !1,
+            capturePointerEventsEnabled: !1,
+            _mouseListenClick: !1,
+            _touchListenClick: !1,
+            _pointerListenClick: !1,
+            _mouseInDblClickWindow: !1,
+            _touchInDblClickWindow: !1,
+            _pointerInDblClickWindow: !1,
+            _mouseDblClickPointerId: null,
+            _touchDblClickPointerId: null,
+            _pointerDblClickPointerId: null,
+            pixelRatio: typeof window < "u" && window.devicePixelRatio || 1,
+            dragDistance: 3,
+            angleDeg: !0,
+            showWarnings: !0,
+            dragButtons: [0, 1],
+            isDragging() {
+                return pe.DD.isDragging
+            },
+            isDragReady() {
+                return !!pe.DD.node
+            },
+            releaseCanvasOnDestroy: !0,
+            document: tc.document,
+            _injectGlobal(e) {
+                tc.Konva = e
+            }
+        },
+        Mt = e => {
+            pe[e.prototype.getClassName()] = e
+        };
+    pe._injectGlobal(pe);
+    let mr = class _9 {
+        constructor(t = [1, 0, 0, 1, 0, 0]) {
+            this.dirty = !1, this.m = t && t.slice() || [1, 0, 0, 1, 0, 0]
+        }
+        reset() {
+            this.m[0] = 1, this.m[1] = 0, this.m[2] = 0, this.m[3] = 1, this.m[4] = 0, this.m[5] = 0
+        }
+        copy() {
+            return new _9(this.m)
+        }
+        copyInto(t) {
+            t.m[0] = this.m[0], t.m[1] = this.m[1], t.m[2] = this.m[2], t.m[3] = this.m[3], t.m[4] = this.m[4], t.m[5] = this.m[5]
+        }
+        point(t) {
+            var n = this.m;
+            return {
+                x: n[0] * t.x + n[2] * t.y + n[4],
+                y: n[1] * t.x + n[3] * t.y + n[5]
+            }
+        }
+        translate(t, n) {
+            return this.m[4] += this.m[0] * t + this.m[2] * n, this.m[5] += this.m[1] * t + this.m[3] * n, this
+        }
+        scale(t, n) {
+            return this.m[0] *= t, this.m[1] *= t, this.m[2] *= n, this.m[3] *= n, this
+        }
+        rotate(t) {
+            var n = Math.cos(t),
+                i = Math.sin(t),
+                r = this.m[0] * n + this.m[2] * i,
+                s = this.m[1] * n + this.m[3] * i,
+                a = this.m[0] * -i + this.m[2] * n,
+                o = this.m[1] * -i + this.m[3] * n;
+            return this.m[0] = r, this.m[1] = s, this.m[2] = a, this.m[3] = o, this
+        }
+        getTranslation() {
+            return {
+                x: this.m[4],
+                y: this.m[5]
+            }
+        }
+        skew(t, n) {
+            var i = this.m[0] + this.m[2] * n,
+                r = this.m[1] + this.m[3] * n,
+                s = this.m[2] + this.m[0] * t,
+                a = this.m[3] + this.m[1] * t;
+            return this.m[0] = i, this.m[1] = r, this.m[2] = s, this.m[3] = a, this
+        }
+        multiply(t) {
+            var n = this.m[0] * t.m[0] + this.m[2] * t.m[1],
+                i = this.m[1] * t.m[0] + this.m[3] * t.m[1],
+                r = this.m[0] * t.m[2] + this.m[2] * t.m[3],
+                s = this.m[1] * t.m[2] + this.m[3] * t.m[3],
+                a = this.m[0] * t.m[4] + this.m[2] * t.m[5] + this.m[4],
+                o = this.m[1] * t.m[4] + this.m[3] * t.m[5] + this.m[5];
+            return this.m[0] = n, this.m[1] = i, this.m[2] = r, this.m[3] = s, this.m[4] = a, this.m[5] = o, this
+        }
+        invert() {
+            var t = 1 / (this.m[0] * this.m[3] - this.m[1] * this.m[2]),
+                n = this.m[3] * t,
+                i = -this.m[1] * t,
+                r = -this.m[2] * t,
+                s = this.m[0] * t,
+                a = t * (this.m[2] * this.m[5] - this.m[3] * this.m[4]),
+                o = t * (this.m[1] * this.m[4] - this.m[0] * this.m[5]);
+            return this.m[0] = n, this.m[1] = i, this.m[2] = r, this.m[3] = s, this.m[4] = a, this.m[5] = o, this
+        }
+        getMatrix() {
+            return this.m
+        }
+        decompose() {
+            var t = this.m[0],
+                n = this.m[1],
+                i = this.m[2],
+                r = this.m[3],
+                s = this.m[4],
+                a = this.m[5],
+                o = t * r - n * i;
+            let l = {
+                x: s,
+                y: a,
+                rotation: 0,
+                scaleX: 0,
+                scaleY: 0,
+                skewX: 0,
+                skewY: 0
+            };
+            if (t != 0 || n != 0) {
+                var u = Math.sqrt(t * t + n * n);
+                l.rotation = n > 0 ? Math.acos(t / u) : -Math.acos(t / u), l.scaleX = u, l.scaleY = o / u, l.skewX = (t * i + n * r) / o, l.skewY = 0
+            } else if (i != 0 || r != 0) {
+                var c = Math.sqrt(i * i + r * r);
+                l.rotation = Math.PI / 2 - (r > 0 ? Math.acos(-i / c) : -Math.acos(i / c)), l.scaleX = o / c, l.scaleY = c, l.skewX = 0, l.skewY = (t * i + n * r) / o
+            }
+            return l.rotation = D._getRotation(l.rotation), l
+        }
+    };
+    var Zve = "[object Array]",
+        ebe = "[object Number]",
+        tbe = "[object String]",
+        nbe = "[object Boolean]",
+        ibe = Math.PI / 180,
+        rbe = 180 / Math.PI,
+        xb = "#",
+        sbe = "",
+        abe = "0",
+        obe = "Konva warning: ",
+        G3 = "Konva error: ",
+        lbe = "rgb(",
+        _b = {
+            aliceblue: [240, 248, 255],
+            antiquewhite: [250, 235, 215],
+            aqua: [0, 255, 255],
+            aquamarine: [127, 255, 212],
+            azure: [240, 255, 255],
+            beige: [245, 245, 220],
+            bisque: [255, 228, 196],
+            black: [0, 0, 0],
+            blanchedalmond: [255, 235, 205],
+            blue: [0, 0, 255],
+            blueviolet: [138, 43, 226],
+            brown: [165, 42, 42],
+            burlywood: [222, 184, 135],
+            cadetblue: [95, 158, 160],
+            chartreuse: [127, 255, 0],
+            chocolate: [210, 105, 30],
+            coral: [255, 127, 80],
+            cornflowerblue: [100, 149, 237],
+            cornsilk: [255, 248, 220],
+            crimson: [220, 20, 60],
+            cyan: [0, 255, 255],
+            darkblue: [0, 0, 139],
+            darkcyan: [0, 139, 139],
+            darkgoldenrod: [184, 132, 11],
+            darkgray: [169, 169, 169],
+            darkgreen: [0, 100, 0],
+            darkgrey: [169, 169, 169],
+            darkkhaki: [189, 183, 107],
+            darkmagenta: [139, 0, 139],
+            darkolivegreen: [85, 107, 47],
+            darkorange: [255, 140, 0],
+            darkorchid: [153, 50, 204],
+            darkred: [139, 0, 0],
+            darksalmon: [233, 150, 122],
+            darkseagreen: [143, 188, 143],
+            darkslateblue: [72, 61, 139],
+            darkslategray: [47, 79, 79],
+            darkslategrey: [47, 79, 79],
+            darkturquoise: [0, 206, 209],
+            darkviolet: [148, 0, 211],
+            deeppink: [255, 20, 147],
+            deepskyblue: [0, 191, 255],
+            dimgray: [105, 105, 105],
+            dimgrey: [105, 105, 105],
+            dodgerblue: [30, 144, 255],
+            firebrick: [178, 34, 34],
+            floralwhite: [255, 255, 240],
+            forestgreen: [34, 139, 34],
+            fuchsia: [255, 0, 255],
+            gainsboro: [220, 220, 220],
+            ghostwhite: [248, 248, 255],
+            gold: [255, 215, 0],
+            goldenrod: [218, 165, 32],
+            gray: [128, 128, 128],
+            green: [0, 128, 0],
+            greenyellow: [173, 255, 47],
+            grey: [128, 128, 128],
+            honeydew: [240, 255, 240],
+            hotpink: [255, 105, 180],
+            indianred: [205, 92, 92],
+            indigo: [75, 0, 130],
+            ivory: [255, 255, 240],
+            khaki: [240, 230, 140],
+            lavender: [230, 230, 250],
+            lavenderblush: [255, 240, 245],
+            lawngreen: [124, 252, 0],
+            lemonchiffon: [255, 250, 205],
+            lightblue: [173, 216, 230],
+            lightcoral: [240, 128, 128],
+            lightcyan: [224, 255, 255],
+            lightgoldenrodyellow: [250, 250, 210],
+            lightgray: [211, 211, 211],
+            lightgreen: [144, 238, 144],
+            lightgrey: [211, 211, 211],
+            lightpink: [255, 182, 193],
+            lightsalmon: [255, 160, 122],
+            lightseagreen: [32, 178, 170],
+            lightskyblue: [135, 206, 250],
+            lightslategray: [119, 136, 153],
+            lightslategrey: [119, 136, 153],
+            lightsteelblue: [176, 196, 222],
+            lightyellow: [255, 255, 224],
+            lime: [0, 255, 0],
+            limegreen: [50, 205, 50],
+            linen: [250, 240, 230],
+            magenta: [255, 0, 255],
+            maroon: [128, 0, 0],
+            mediumaquamarine: [102, 205, 170],
+            mediumblue: [0, 0, 205],
+            mediumorchid: [186, 85, 211],
+            mediumpurple: [147, 112, 219],
+            mediumseagreen: [60, 179, 113],
+            mediumslateblue: [123, 104, 238],
+            mediumspringgreen: [0, 250, 154],
+            mediumturquoise: [72, 209, 204],
+            mediumvioletred: [199, 21, 133],
+            midnightblue: [25, 25, 112],
+            mintcream: [245, 255, 250],
+            mistyrose: [255, 228, 225],
+            moccasin: [255, 228, 181],
+            navajowhite: [255, 222, 173],
+            navy: [0, 0, 128],
+            oldlace: [253, 245, 230],
+            olive: [128, 128, 0],
+            olivedrab: [107, 142, 35],
+            orange: [255, 165, 0],
+            orangered: [255, 69, 0],
+            orchid: [218, 112, 214],
+            palegoldenrod: [238, 232, 170],
+            palegreen: [152, 251, 152],
+            paleturquoise: [175, 238, 238],
+            palevioletred: [219, 112, 147],
+            papayawhip: [255, 239, 213],
+            peachpuff: [255, 218, 185],
+            peru: [205, 133, 63],
+            pink: [255, 192, 203],
+            plum: [221, 160, 203],
+            powderblue: [176, 224, 230],
+            purple: [128, 0, 128],
+            rebeccapurple: [102, 51, 153],
+            red: [255, 0, 0],
+            rosybrown: [188, 143, 143],
+            royalblue: [65, 105, 225],
+            saddlebrown: [139, 69, 19],
+            salmon: [250, 128, 114],
+            sandybrown: [244, 164, 96],
+            seagreen: [46, 139, 87],
+            seashell: [255, 245, 238],
+            sienna: [160, 82, 45],
+            silver: [192, 192, 192],
+            skyblue: [135, 206, 235],
+            slateblue: [106, 90, 205],
+            slategray: [119, 128, 144],
+            slategrey: [119, 128, 144],
+            snow: [255, 255, 250],
+            springgreen: [0, 255, 127],
+            steelblue: [70, 130, 180],
+            tan: [210, 180, 140],
+            teal: [0, 128, 128],
+            thistle: [216, 191, 216],
+            transparent: [255, 255, 255, 0],
+            tomato: [255, 99, 71],
+            turquoise: [64, 224, 208],
+            violet: [238, 130, 238],
+            wheat: [245, 222, 179],
+            white: [255, 255, 255],
+            whitesmoke: [245, 245, 245],
+            yellow: [255, 255, 0],
+            yellowgreen: [154, 205, 5]
+        },
+        ube = /rgb\((\d{1,3}),(\d{1,3}),(\d{1,3})\)/,
+        ap = [];
+    const cbe = typeof requestAnimationFrame < "u" && requestAnimationFrame || function(e) {
+            setTimeout(e, 60)
+        },
+        D = {
+            _isElement(e) {
+                return !!(e && e.nodeType == 1)
+            },
+            _isFunction(e) {
+                return !!(e && e.constructor && e.call && e.apply)
+            },
+            _isPlainObject(e) {
+                return !!e && e.constructor === Object
+            },
+            _isArray(e) {
+                return Object.prototype.toString.call(e) === Zve
+            },
+            _isNumber(e) {
+                return Object.prototype.toString.call(e) === ebe && !isNaN(e) && isFinite(e)
+            },
+            _isString(e) {
+                return Object.prototype.toString.call(e) === tbe
+            },
+            _isBoolean(e) {
+                return Object.prototype.toString.call(e) === nbe
+            },
+            isObject(e) {
+                return e instanceof Object
+            },
+            isValidSelector(e) {
+                if (typeof e != "string") return !1;
+                var t = e[0];
+                return t === "#" || t === "." || t === t.toUpperCase()
+            },
+            _sign(e) {
+                return e === 0 || e > 0 ? 1 : -1
+            },
+            requestAnimFrame(e) {
+                ap.push(e), ap.length === 1 && cbe(function() {
+                    const t = ap;
+                    ap = [], t.forEach(function(n) {
+                        n()
+                    })
+                })
+            },
+            createCanvasElement() {
+                var e = document.createElement("canvas");
+                try {
+                    e.style = e.style || {}
+                } catch {}
+                return e
+            },
+            createImageElement() {
+                return document.createElement("img")
+            },
+            _isInDocument(e) {
+                for (; e = e.parentNode;)
+                    if (e == document) return !0;
+                return !1
+            },
+            _urlToImage(e, t) {
+                var n = D.createImageElement();
+                n.onload = function() {
+                    t(n)
+                }, n.src = e
+            },
+            _rgbToHex(e, t, n) {
+                return ((1 << 24) + (e << 16) + (t << 8) + n).toString(16).slice(1)
+            },
+            _hexToRgb(e) {
+                e = e.replace(xb, sbe);
+                var t = parseInt(e, 16);
+                return {
+                    r: t >> 16 & 255,
+                    g: t >> 8 & 255,
+                    b: t & 255
+                }
+            },
+            getRandomColor() {
+                for (var e = (Math.random() * 16777215 << 0).toString(16); e.length < 6;) e = abe + e;
+                return xb + e
+            },
+            getRGB(e) {
+                var t;
+                return e in _b ? (t = _b[e], {
+                    r: t[0],
+                    g: t[1],
+                    b: t[2]
+                }) : e[0] === xb ? this._hexToRgb(e.substring(1)) : e.substr(0, 4) === lbe ? (t = ube.exec(e.replace(/ /g, "")), {
+                    r: parseInt(t[1], 10),
+                    g: parseInt(t[2], 10),
+                    b: parseInt(t[3], 10)
+                }) : {
+                    r: 0,
+                    g: 0,
+                    b: 0
+                }
+            },
+            colorToRGBA(e) {
+                return e = e || "black", D._namedColorToRBA(e) || D._hex3ColorToRGBA(e) || D._hex4ColorToRGBA(e) || D._hex6ColorToRGBA(e) || D._hex8ColorToRGBA(e) || D._rgbColorToRGBA(e) || D._rgbaColorToRGBA(e) || D._hslColorToRGBA(e)
+            },
+            _namedColorToRBA(e) {
+                var t = _b[e.toLowerCase()];
+                return t ? {
+                    r: t[0],
+                    g: t[1],
+                    b: t[2],
+                    a: 1
+                } : null
+            },
+            _rgbColorToRGBA(e) {
+                if (e.indexOf("rgb(") === 0) {
+                    e = e.match(/rgb\(([^)]+)\)/)[1];
+                    var t = e.split(/ *, */).map(Number);
+                    return {
+                        r: t[0],
+                        g: t[1],
+                        b: t[2],
+                        a: 1
+                    }
+                }
+            },
+            _rgbaColorToRGBA(e) {
+                if (e.indexOf("rgba(") === 0) {
+                    e = e.match(/rgba\(([^)]+)\)/)[1];
+                    var t = e.split(/ *, */).map((n, i) => n.slice(-1) === "%" ? i === 3 ? parseInt(n) / 100 : parseInt(n) / 100 * 255 : Number(n));
+                    return {
+                        r: t[0],
+                        g: t[1],
+                        b: t[2],
+                        a: t[3]
+                    }
+                }
+            },
+            _hex8ColorToRGBA(e) {
+                if (e[0] === "#" && e.length === 9) return {
+                    r: parseInt(e.slice(1, 3), 16),
+                    g: parseInt(e.slice(3, 5), 16),
+                    b: parseInt(e.slice(5, 7), 16),
+                    a: parseInt(e.slice(7, 9), 16) / 255
+                }
+            },
+            _hex6ColorToRGBA(e) {
+                if (e[0] === "#" && e.length === 7) return {
+                    r: parseInt(e.slice(1, 3), 16),
+                    g: parseInt(e.slice(3, 5), 16),
+                    b: parseInt(e.slice(5, 7), 16),
+                    a: 1
+                }
+            },
+            _hex4ColorToRGBA(e) {
+                if (e[0] === "#" && e.length === 5) return {
+                    r: parseInt(e[1] + e[1], 16),
+                    g: parseInt(e[2] + e[2], 16),
+                    b: parseInt(e[3] + e[3], 16),
+                    a: parseInt(e[4] + e[4], 16) / 255
+                }
+            },
+            _hex3ColorToRGBA(e) {
+                if (e[0] === "#" && e.length === 4) return {
+                    r: parseInt(e[1] + e[1], 16),
+                    g: parseInt(e[2] + e[2], 16),
+                    b: parseInt(e[3] + e[3], 16),
+                    a: 1
+                }
+            },
+            _hslColorToRGBA(e) {
+                if (/hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.test(e)) {
+                    const [t, ...n] = /hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.exec(e), i = Number(n[0]) / 360, r = Number(n[1]) / 100, s = Number(n[2]) / 100;
+                    let a, o, l;
+                    if (r === 0) return l = s * 255, {
+                        r: Math.round(l),
+                        g: Math.round(l),
+                        b: Math.round(l),
+                        a: 1
+                    };
+                    s < .5 ? a = s * (1 + r) : a = s + r - s * r;
+                    const u = 2 * s - a,
+                        c = [0, 0, 0];
+                    for (let f = 0; f < 3; f++) o = i + 1 / 3 * -(f - 1), o < 0 && o++, o > 1 && o--, 6 * o < 1 ? l = u + (a - u) * 6 * o : 2 * o < 1 ? l = a : 3 * o < 2 ? l = u + (a - u) * (2 / 3 - o) * 6 : l = u, c[f] = l * 255;
+                    return {
+                        r: Math.round(c[0]),
+                        g: Math.round(c[1]),
+                        b: Math.round(c[2]),
+                        a: 1
+                    }
+                }
+            },
+            haveIntersection(e, t) {
+                return !(t.x > e.x + e.width || t.x + t.width < e.x || t.y > e.y + e.height || t.y + t.height < e.y)
+            },
+            cloneObject(e) {
+                var t = {};
+                for (var n in e) this._isPlainObject(e[n]) ? t[n] = this.cloneObject(e[n]) : this._isArray(e[n]) ? t[n] = this.cloneArray(e[n]) : t[n] = e[n];
+                return t
+            },
+            cloneArray(e) {
+                return e.slice(0)
+            },
+            degToRad(e) {
+                return e * ibe
+            },
+            radToDeg(e) {
+                return e * rbe
+            },
+            _degToRad(e) {
+                return D.warn("Util._degToRad is removed. Please use public Util.degToRad instead."), D.degToRad(e)
+            },
+            _radToDeg(e) {
+                return D.warn("Util._radToDeg is removed. Please use public Util.radToDeg instead."), D.radToDeg(e)
+            },
+            _getRotation(e) {
+                return pe.angleDeg ? D.radToDeg(e) : e
+            },
+            _capitalize(e) {
+                return e.charAt(0).toUpperCase() + e.slice(1)
+            },
+            throw (e) {
+                throw new Error(G3 + e)
+            },
+            error(e) {
+                console.error(G3 + e)
+            },
+            warn(e) {
+                pe.showWarnings && console.warn(obe + e)
+            },
+            each(e, t) {
+                for (var n in e) t(n, e[n])
+            },
+            _inRange(e, t, n) {
+                return t <= e && e < n
+            },
+            _getProjectionToSegment(e, t, n, i, r, s) {
+                var a, o, l, u = (e - n) * (e - n) + (t - i) * (t - i);
+                if (u == 0) a = e, o = t, l = (r - n) * (r - n) + (s - i) * (s - i);
+                else {
+                    var c = ((r - e) * (n - e) + (s - t) * (i - t)) / u;
+                    c < 0 ? (a = e, o = t, l = (e - r) * (e - r) + (t - s) * (t - s)) : c > 1 ? (a = n, o = i, l = (n - r) * (n - r) + (i - s) * (i - s)) : (a = e + c * (n - e), o = t + c * (i - t), l = (a - r) * (a - r) + (o - s) * (o - s))
+                }
+                return [a, o, l]
+            },
+            _getProjectionToLine(e, t, n) {
+                var i = D.cloneObject(e),
+                    r = Number.MAX_VALUE;
+                return t.forEach(function(s, a) {
+                    if (!(!n && a === t.length - 1)) {
+                        var o = t[(a + 1) % t.length],
+                            l = D._getProjectionToSegment(s.x, s.y, o.x, o.y, e.x, e.y),
+                            u = l[0],
+                            c = l[1],
+                            f = l[2];
+                        f < r && (i.x = u, i.y = c, r = f)
+                    }
+                }), i
+            },
+            _prepareArrayForTween(e, t, n) {
+                var i, r = [],
+                    s = [];
+                if (e.length > t.length) {
+                    var a = t;
+                    t = e, e = a
+                }
+                for (i = 0; i < e.length; i += 2) r.push({
+                    x: e[i],
+                    y: e[i + 1]
+                });
+                for (i = 0; i < t.length; i += 2) s.push({
+                    x: t[i],
+                    y: t[i + 1]
+                });
+                var o = [];
+                return s.forEach(function(l) {
+                    var u = D._getProjectionToLine(l, r, n);
+                    o.push(u.x), o.push(u.y)
+                }), o
+            },
+            _prepareToStringify(e) {
+                var t;
+                e.visitedByCircularReferenceRemoval = !0;
+                for (var n in e)
+                    if (e.hasOwnProperty(n) && e[n] && typeof e[n] == "object") {
+                        if (t = Object.getOwnPropertyDescriptor(e, n), e[n].visitedByCircularReferenceRemoval || D._isElement(e[n]))
+                            if (t.configurable) delete e[n];
+                            else return null;
+                        else if (D._prepareToStringify(e[n]) === null)
+                            if (t.configurable) delete e[n];
+                            else return null
+                    } return delete e.visitedByCircularReferenceRemoval, e
+            },
+            _assign(e, t) {
+                for (var n in t) e[n] = t[n];
+                return e
+            },
+            _getFirstPointerId(e) {
+                return e.touches ? e.changedTouches[0].identifier : e.pointerId || 999
+            },
+            releaseCanvas(...e) {
+                pe.releaseCanvasOnDestroy && e.forEach(t => {
+                    t.width = 0, t.height = 0
+                })
+            },
+            drawRoundedRectPath(e, t, n, i) {
+                let r = 0,
+                    s = 0,
+                    a = 0,
+                    o = 0;
+                typeof i == "number" ? r = s = a = o = Math.min(i, t / 2, n / 2) : (r = Math.min(i[0] || 0, t / 2, n / 2), s = Math.min(i[1] || 0, t / 2, n / 2), o = Math.min(i[2] || 0, t / 2, n / 2), a = Math.min(i[3] || 0, t / 2, n / 2)), e.moveTo(r, 0), e.lineTo(t - s, 0), e.arc(t - s, s, s, Math.PI * 3 / 2, 0, !1), e.lineTo(t, n - o), e.arc(t - o, n - o, o, 0, Math.PI / 2, !1), e.lineTo(a, n), e.arc(a, n - a, a, Math.PI / 2, Math.PI, !1), e.lineTo(0, r), e.arc(r, r, r, Math.PI, Math.PI * 3 / 2, !1)
+            }
+        };
+
+    function Oo(e) {
+        return D._isString(e) ? '"' + e + '"' : Object.prototype.toString.call(e) === "[object Number]" || D._isBoolean(e) ? e : Object.prototype.toString.call(e)
+    }
+
+    function w9(e) {
+        return e > 255 ? 255 : e < 0 ? 0 : Math.round(e)
+    }
+
+    function se() {
+        if (pe.isUnminified) return function(e, t) {
+            return D._isNumber(e) || D.warn(Oo(e) + ' is a not valid value for "' + t + '" attribute. The value should be a number.'), e
+        }
+    }
+
+    function LC(e) {
+        if (pe.isUnminified) return function(t, n) {
+            let i = D._isNumber(t),
+                r = D._isArray(t) && t.length == e;
+            return !i && !r && D.warn(Oo(t) + ' is a not valid value for "' + n + '" attribute. The value should be a number or Array<number>(' + e + ")"), t
+        }
+    }
+
+    function IC() {
+        if (pe.isUnminified) return function(e, t) {
+            var n = D._isNumber(e),
+                i = e === "auto";
+            return n || i || D.warn(Oo(e) + ' is a not valid value for "' + t + '" attribute. The value should be a number or "auto".'), e
+        }
+    }
+
+    function hf() {
+        if (pe.isUnminified) return function(e, t) {
+            return D._isString(e) || D.warn(Oo(e) + ' is a not valid value for "' + t + '" attribute. The value should be a string.'), e
+        }
+    }
+
+    function S9() {
+        if (pe.isUnminified) return function(e, t) {
+            const n = D._isString(e),
+                i = Object.prototype.toString.call(e) === "[object CanvasGradient]" || e && e.addColorStop;
+            return n || i || D.warn(Oo(e) + ' is a not valid value for "' + t + '" attribute. The value should be a string or a native gradient.'), e
+        }
+    }
+
+    function fbe() {
+        if (pe.isUnminified) return function(e, t) {
+            const n = Int8Array ? Object.getPrototypeOf(Int8Array) : null;
+            return n && e instanceof n || (D._isArray(e) ? e.forEach(function(i) {
+                D._isNumber(i) || D.warn('"' + t + '" attribute has non numeric element ' + i + ". Make sure that all elements are numbers.")
+            }) : D.warn(Oo(e) + ' is a not valid value for "' + t + '" attribute. The value should be a array of numbers.')), e
+        }
+    }
+
+    function zr() {
+        if (pe.isUnminified) return function(e, t) {
+            var n = e === !0 || e === !1;
+            return n || D.warn(Oo(e) + ' is a not valid value for "' + t + '" attribute. The value should be a boolean.'), e
+        }
+    }
+
+    function hbe(e) {
+        if (pe.isUnminified) return function(t, n) {
+            return t == null || D.isObject(t) || D.warn(Oo(t) + ' is a not valid value for "' + n + '" attribute. The value should be an object with properties ' + e), t
+        }
+    }
+    var Uf = "get",
+        Wf = "set";
+    const O = {
+        addGetterSetter(e, t, n, i, r) {
+            O.addGetter(e, t, n), O.addSetter(e, t, i, r), O.addOverloadedGetterSetter(e, t)
+        },
+        addGetter(e, t, n) {
+            var i = Uf + D._capitalize(t);
+            e.prototype[i] = e.prototype[i] || function() {
+                var r = this.attrs[t];
+                return r === void 0 ? n : r
+            }
+        },
+        addSetter(e, t, n, i) {
+            var r = Wf + D._capitalize(t);
+            e.prototype[r] || O.overWriteSetter(e, t, n, i)
+        },
+        overWriteSetter(e, t, n, i) {
+            var r = Wf + D._capitalize(t);
+            e.prototype[r] = function(s) {
+                return n && s !== void 0 && s !== null && (s = n.call(this, s, t)), this._setAttr(t, s), i && i.call(this), this
+            }
+        },
+        addComponentsGetterSetter(e, t, n, i, r) {
+            var s = n.length,
+                a = D._capitalize,
+                o = Uf + a(t),
+                l = Wf + a(t),
+                u, c;
+            e.prototype[o] = function() {
+                var h = {};
+                for (u = 0; u < s; u++) c = n[u], h[c] = this.getAttr(t + a(c));
+                return h
+            };
+            var f = hbe(n);
+            e.prototype[l] = function(h) {
+                var d = this.attrs[t],
+                    g;
+                i && (h = i.call(this, h)), f && f.call(this, h, t);
+                for (g in h) h.hasOwnProperty(g) && this._setAttr(t + a(g), h[g]);
+                return h || n.forEach(p => {
+                    this._setAttr(t + a(p), void 0)
+                }), this._fireChangeEvent(t, d, h), r && r.call(this), this
+            }, O.addOverloadedGetterSetter(e, t)
+        },
+        addOverloadedGetterSetter(e, t) {
+            var n = D._capitalize(t),
+                i = Wf + n,
+                r = Uf + n;
+            e.prototype[t] = function() {
+                return arguments.length ? (this[i](arguments[0]), this) : this[r]()
+            }
+        },
+        addDeprecatedGetterSetter(e, t, n, i) {
+            D.error("Adding deprecated " + t);
+            var r = Uf + D._capitalize(t),
+                s = t + " property is deprecated and will be removed soon. Look at Konva change log for more information.";
+            e.prototype[r] = function() {
+                D.error(s);
+                var a = this.attrs[t];
+                return a === void 0 ? n : a
+            }, O.addSetter(e, t, i, function() {
+                D.error(s)
+            }), O.addOverloadedGetterSetter(e, t)
+        },
+        backCompat(e, t) {
+            D.each(t, function(n, i) {
+                var r = e.prototype[i],
+                    s = Uf + D._capitalize(n),
+                    a = Wf + D._capitalize(n);
+
+                function o() {
+                    r.apply(this, arguments), D.error('"' + n + '" method is deprecated and will be removed soon. Use ""' + i + '" instead.')
+                }
+                e.prototype[n] = o, e.prototype[s] = o, e.prototype[a] = o
+            })
+        },
+        afterSetFilter() {
+            this._filterUpToDate = !1
+        }
+    };
+
+    function dbe(e) {
+        var t = [],
+            n = e.length,
+            i = D,
+            r, s;
+        for (r = 0; r < n; r++) s = e[r], i._isNumber(s) ? s = Math.round(s * 1e3) / 1e3 : i._isString(s) || (s = s + ""), t.push(s);
+        return t
+    }
+    var U3 = ",",
+        gbe = "(",
+        pbe = ")",
+        mbe = "([",
+        ybe = "])",
+        vbe = ";",
+        bbe = "()",
+        xbe = "=",
+        W3 = ["arc", "arcTo", "beginPath", "bezierCurveTo", "clearRect", "clip", "closePath", "createLinearGradient", "createPattern", "createRadialGradient", "drawImage", "ellipse", "fill", "fillText", "getImageData", "createImageData", "lineTo", "moveTo", "putImageData", "quadraticCurveTo", "rect", "restore", "rotate", "save", "scale", "setLineDash", "setTransform", "stroke", "strokeText", "transform", "translate"],
+        _be = ["fillStyle", "strokeStyle", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY", "lineCap", "lineDashOffset", "lineJoin", "lineWidth", "miterLimit", "font", "textAlign", "textBaseline", "globalAlpha", "globalCompositeOperation", "imageSmoothingEnabled"];
+    const wbe = 100;
+    class jy {
+        constructor(t) {
+            this.canvas = t, pe.enableTrace && (this.traceArr = [], this._enableTrace())
+        }
+        fillShape(t) {
+            t.fillEnabled() && this._fill(t)
+        }
+        _fill(t) {}
+        strokeShape(t) {
+            t.hasStroke() && this._stroke(t)
+        }
+        _stroke(t) {}
+        fillStrokeShape(t) {
+            t.attrs.fillAfterStrokeEnabled ? (this.strokeShape(t), this.fillShape(t)) : (this.fillShape(t), this.strokeShape(t))
+        }
+        getTrace(t, n) {
+            var i = this.traceArr,
+                r = i.length,
+                s = "",
+                a, o, l, u;
+            for (a = 0; a < r; a++) o = i[a], l = o.method, l ? (u = o.args, s += l, t ? s += bbe : D._isArray(u[0]) ? s += mbe + u.join(U3) + ybe : (n && (u = u.map(c => typeof c == "number" ? Math.floor(c) : c)), s += gbe + u.join(U3) + pbe)) : (s += o.property, t || (s += xbe + o.val)), s += vbe;
+            return s
+        }
+        clearTrace() {
+            this.traceArr = []
+        }
+        _trace(t) {
+            var n = this.traceArr,
+                i;
+            n.push(t), i = n.length, i >= wbe && n.shift()
+        }
+        reset() {
+            var t = this.getCanvas().getPixelRatio();
+            this.setTransform(1 * t, 0, 0, 1 * t, 0, 0)
+        }
+        getCanvas() {
+            return this.canvas
+        }
+        clear(t) {
+            var n = this.getCanvas();
+            t ? this.clearRect(t.x || 0, t.y || 0, t.width || 0, t.height || 0) : this.clearRect(0, 0, n.getWidth() / n.pixelRatio, n.getHeight() / n.pixelRatio)
+        }
+        _applyLineCap(t) {
+            const n = t.attrs.lineCap;
+            n && this.setAttr("lineCap", n)
+        }
+        _applyOpacity(t) {
+            var n = t.getAbsoluteOpacity();
+            n !== 1 && this.setAttr("globalAlpha", n)
+        }
+        _applyLineJoin(t) {
+            const n = t.attrs.lineJoin;
+            n && this.setAttr("lineJoin", n)
+        }
+        setAttr(t, n) {
+            this._context[t] = n
+        }
+        arc(t, n, i, r, s, a) {
+            this._context.arc(t, n, i, r, s, a)
+        }
+        arcTo(t, n, i, r, s) {
+            this._context.arcTo(t, n, i, r, s)
+        }
+        beginPath() {
+            this._context.beginPath()
+        }
+        bezierCurveTo(t, n, i, r, s, a) {
+            this._context.bezierCurveTo(t, n, i, r, s, a)
+        }
+        clearRect(t, n, i, r) {
+            this._context.clearRect(t, n, i, r)
+        }
+        clip() {
+            this._context.clip()
+        }
+        closePath() {
+            this._context.closePath()
+        }
+        createImageData(t, n) {
+            var i = arguments;
+            if (i.length === 2) return this._context.createImageData(t, n);
+            if (i.length === 1) return this._context.createImageData(t)
+        }
+        createLinearGradient(t, n, i, r) {
+            return this._context.createLinearGradient(t, n, i, r)
+        }
+        createPattern(t, n) {
+            return this._context.createPattern(t, n)
+        }
+        createRadialGradient(t, n, i, r, s, a) {
+            return this._context.createRadialGradient(t, n, i, r, s, a)
+        }
+        drawImage(t, n, i, r, s, a, o, l, u) {
+            var c = arguments,
+                f = this._context;
+            c.length === 3 ? f.drawImage(t, n, i) : c.length === 5 ? f.drawImage(t, n, i, r, s) : c.length === 9 && f.drawImage(t, n, i, r, s, a, o, l, u)
+        }
+        ellipse(t, n, i, r, s, a, o, l) {
+            this._context.ellipse(t, n, i, r, s, a, o, l)
+        }
+        isPointInPath(t, n, i, r) {
+            return i ? this._context.isPointInPath(i, t, n, r) : this._context.isPointInPath(t, n, r)
+        }
+        fill(t) {
+            t ? this._context.fill(t) : this._context.fill()
+        }
+        fillRect(t, n, i, r) {
+            this._context.fillRect(t, n, i, r)
+        }
+        strokeRect(t, n, i, r) {
+            this._context.strokeRect(t, n, i, r)
+        }
+        fillText(t, n, i, r) {
+            r ? this._context.fillText(t, n, i, r) : this._context.fillText(t, n, i)
+        }
+        measureText(t) {
+            return this._context.measureText(t)
+        }
+        getImageData(t, n, i, r) {
+            return this._context.getImageData(t, n, i, r)
+        }
+        lineTo(t, n) {
+            this._context.lineTo(t, n)
+        }
+        moveTo(t, n) {
+            this._context.moveTo(t, n)
+        }
+        rect(t, n, i, r) {
+            this._context.rect(t, n, i, r)
+        }
+        putImageData(t, n, i) {
+            this._context.putImageData(t, n, i)
+        }
+        quadraticCurveTo(t, n, i, r) {
+            this._context.quadraticCurveTo(t, n, i, r)
+        }
+        restore() {
+            this._context.restore()
+        }
+        rotate(t) {
+            this._context.rotate(t)
+        }
+        save() {
+            this._context.save()
+        }
+        scale(t, n) {
+            this._context.scale(t, n)
+        }
+        setLineDash(t) {
+            this._context.setLineDash ? this._context.setLineDash(t) : "mozDash" in this._context ? this._context.mozDash = t : "webkitLineDash" in this._context && (this._context.webkitLineDash = t)
+        }
+        getLineDash() {
+            return this._context.getLineDash()
+        }
+        setTransform(t, n, i, r, s, a) {
+            this._context.setTransform(t, n, i, r, s, a)
+        }
+        stroke(t) {
+            t ? this._context.stroke(t) : this._context.stroke()
+        }
+        strokeText(t, n, i, r) {
+            this._context.strokeText(t, n, i, r)
+        }
+        transform(t, n, i, r, s, a) {
+            this._context.transform(t, n, i, r, s, a)
+        }
+        translate(t, n) {
+            this._context.translate(t, n)
+        }
+        _enableTrace() {
+            var t = this,
+                n = W3.length,
+                i = this.setAttr,
+                r, s, a = function(o) {
+                    var l = t[o],
+                        u;
+                    t[o] = function() {
+                        return s = dbe(Array.prototype.slice.call(arguments, 0)), u = l.apply(t, arguments), t._trace({
+                            method: o,
+                            args: s
+                        }), u
+                    }
+                };
+            for (r = 0; r < n; r++) a(W3[r]);
+            t.setAttr = function() {
+                i.apply(t, arguments);
+                var o = arguments[0],
+                    l = arguments[1];
+                (o === "shadowOffsetX" || o === "shadowOffsetY" || o === "shadowBlur") && (l = l / this.canvas.getPixelRatio()), t._trace({
+                    property: o,
+                    val: l
+                })
+            }
+        }
+        _applyGlobalCompositeOperation(t) {
+            const n = t.attrs.globalCompositeOperation;
+            var i = !n || n === "source-over";
+            i || this.setAttr("globalCompositeOperation", n)
+        }
+    }
+    _be.forEach(function(e) {
+        Object.defineProperty(jy.prototype, e, {
+            get() {
+                return this._context[e]
+            },
+            set(t) {
+                this._context[e] = t
+            }
+        })
+    });
+    class Sbe extends jy {
+        constructor(t) {
+            super(t), this._context = t._canvas.getContext("2d")
+        }
+        _fillColor(t) {
+            var n = t.fill();
+            this.setAttr("fillStyle", n), t._fillFunc(this)
+        }
+        _fillPattern(t) {
+            this.setAttr("fillStyle", t._getFillPattern()), t._fillFunc(this)
+        }
+        _fillLinearGradient(t) {
+            var n = t._getLinearGradient();
+            n && (this.setAttr("fillStyle", n), t._fillFunc(this))
+        }
+        _fillRadialGradient(t) {
+            const n = t._getRadialGradient();
+            n && (this.setAttr("fillStyle", n), t._fillFunc(this))
+        }
+        _fill(t) {
+            const n = t.fill(),
+                i = t.getFillPriority();
+            if (n && i === "color") {
+                this._fillColor(t);
+                return
+            }
+            const r = t.getFillPatternImage();
+            if (r && i === "pattern") {
+                this._fillPattern(t);
+                return
+            }
+            const s = t.getFillLinearGradientColorStops();
+            if (s && i === "linear-gradient") {
+                this._fillLinearGradient(t);
+                return
+            }
+            const a = t.getFillRadialGradientColorStops();
+            if (a && i === "radial-gradient") {
+                this._fillRadialGradient(t);
+                return
+            }
+            n ? this._fillColor(t) : r ? this._fillPattern(t) : s ? this._fillLinearGradient(t) : a && this._fillRadialGradient(t)
+        }
+        _strokeLinearGradient(t) {
+            const n = t.getStrokeLinearGradientStartPoint(),
+                i = t.getStrokeLinearGradientEndPoint(),
+                r = t.getStrokeLinearGradientColorStops(),
+                s = this.createLinearGradient(n.x, n.y, i.x, i.y);
+            if (r) {
+                for (var a = 0; a < r.length; a += 2) s.addColorStop(r[a], r[a + 1]);
+                this.setAttr("strokeStyle", s)
+            }
+        }
+        _stroke(t) {
+            var n = t.dash(),
+                i = t.getStrokeScaleEnabled();
+            if (t.hasStroke()) {
+                if (!i) {
+                    this.save();
+                    var r = this.getCanvas().getPixelRatio();
+                    this.setTransform(r, 0, 0, r, 0, 0)
+                }
+                this._applyLineCap(t), n && t.dashEnabled() && (this.setLineDash(n), this.setAttr("lineDashOffset", t.dashOffset())), this.setAttr("lineWidth", t.strokeWidth()), t.getShadowForStrokeEnabled() || this.setAttr("shadowColor", "rgba(0,0,0,0)");
+                var s = t.getStrokeLinearGradientColorStops();
+                s ? this._strokeLinearGradient(t) : this.setAttr("strokeStyle", t.stroke()), t._strokeFunc(this), i || this.restore()
+            }
+        }
+        _applyShadow(t) {
+            var n, i, r, s = (n = t.getShadowRGBA()) !== null && n !== void 0 ? n : "black",
+                a = (i = t.getShadowBlur()) !== null && i !== void 0 ? i : 5,
+                o = (r = t.getShadowOffset()) !== null && r !== void 0 ? r : {
+                    x: 0,
+                    y: 0
+                },
+                l = t.getAbsoluteScale(),
+                u = this.canvas.getPixelRatio(),
+                c = l.x * u,
+                f = l.y * u;
+            this.setAttr("shadowColor", s), this.setAttr("shadowBlur", a * Math.min(Math.abs(c), Math.abs(f))), this.setAttr("shadowOffsetX", o.x * c), this.setAttr("shadowOffsetY", o.y * f)
+        }
+    }
+    class Ebe extends jy {
+        constructor(t) {
+            super(t), this._context = t._canvas.getContext("2d", {
+                willReadFrequently: !0
+            })
+        }
+        _fill(t) {
+            this.save(), this.setAttr("fillStyle", t.colorKey), t._fillFuncHit(this), this.restore()
+        }
+        strokeShape(t) {
+            t.hasHitStroke() && this._stroke(t)
+        }
+        _stroke(t) {
+            if (t.hasHitStroke()) {
+                const s = t.getStrokeScaleEnabled();
+                if (!s) {
+                    this.save();
+                    var n = this.getCanvas().getPixelRatio();
+                    this.setTransform(n, 0, 0, n, 0, 0)
+                }
+                this._applyLineCap(t);
+                var i = t.hitStrokeWidth(),
+                    r = i === "auto" ? t.strokeWidth() : i;
+                this.setAttr("lineWidth", r), this.setAttr("strokeStyle", t.colorKey), t._strokeFuncHit(this), s || this.restore()
+            }
+        }
+    }
+    var op;
+
+    function kbe() {
+        if (op) return op;
+        var e = D.createCanvasElement(),
+            t = e.getContext("2d");
+        return op = function() {
+            var n = pe._global.devicePixelRatio || 1,
+                i = t.webkitBackingStorePixelRatio || t.mozBackingStorePixelRatio || t.msBackingStorePixelRatio || t.oBackingStorePixelRatio || t.backingStorePixelRatio || 1;
+            return n / i
+        }(), D.releaseCanvas(e), op
+    }
+    class Gy {
+        constructor(t) {
+            this.pixelRatio = 1, this.width = 0, this.height = 0, this.isCache = !1;
+            var n = t || {},
+                i = n.pixelRatio || pe.pixelRatio || kbe();
+            this.pixelRatio = i, this._canvas = D.createCanvasElement(), this._canvas.style.padding = "0", this._canvas.style.margin = "0", this._canvas.style.border = "0", this._canvas.style.background = "transparent", this._canvas.style.position = "absolute", this._canvas.style.top = "0", this._canvas.style.left = "0"
+        }
+        getContext() {
+            return this.context
+        }
+        getPixelRatio() {
+            return this.pixelRatio
+        }
+        setPixelRatio(t) {
+            var n = this.pixelRatio;
+            this.pixelRatio = t, this.setSize(this.getWidth() / n, this.getHeight() / n)
+        }
+        setWidth(t) {
+            this.width = this._canvas.width = t * this.pixelRatio, this._canvas.style.width = t + "px";
+            var n = this.pixelRatio,
+                i = this.getContext()._context;
+            i.scale(n, n)
+        }
+        setHeight(t) {
+            this.height = this._canvas.height = t * this.pixelRatio, this._canvas.style.height = t + "px";
+            var n = this.pixelRatio,
+                i = this.getContext()._context;
+            i.scale(n, n)
+        }
+        getWidth() {
+            return this.width
+        }
+        getHeight() {
+            return this.height
+        }
+        setSize(t, n) {
+            this.setWidth(t || 0), this.setHeight(n || 0)
+        }
+        toDataURL(t, n) {
+            try {
+                return this._canvas.toDataURL(t, n)
+            } catch {
+                try {
+                    return this._canvas.toDataURL()
+                } catch (r) {
+                    return D.error("Unable to get data URL. " + r.message + " For more info read https://konvajs.org/docs/posts/Tainted_Canvas.html."), ""
+                }
+            }
+        }
+    }
+    O.addGetterSetter(Gy, "pixelRatio", void 0, se());
+    class nc extends Gy {
+        constructor(t = {
+            width: 0,
+            height: 0
+        }) {
+            super(t), this.context = new Sbe(this), this.setSize(t.width, t.height)
+        }
+    }
+    class zC extends Gy {
+        constructor(t = {
+            width: 0,
+            height: 0
+        }) {
+            super(t), this.hitCanvas = !0, this.context = new Ebe(this), this.setSize(t.width, t.height)
+        }
+    }
+    const Ke = {
+        get isDragging() {
+            var e = !1;
+            return Ke._dragElements.forEach(t => {
+                t.dragStatus === "dragging" && (e = !0)
+            }), e
+        },
+        justDragged: !1,
+        get node() {
+            var e;
+            return Ke._dragElements.forEach(t => {
+                e = t.node
+            }), e
+        },
+        _dragElements: new Map,
+        _drag(e) {
+            const t = [];
+            Ke._dragElements.forEach((n, i) => {
+                const {
+                    node: r
+                } = n, s = r.getStage();
+                s.setPointersPositions(e), n.pointerId === void 0 && (n.pointerId = D._getFirstPointerId(e));
+                const a = s._changedPointerPositions.find(u => u.id === n.pointerId);
+                if (a) {
+                    if (n.dragStatus !== "dragging") {
+                        var o = r.dragDistance(),
+                            l = Math.max(Math.abs(a.x - n.startPointerPos.x), Math.abs(a.y - n.startPointerPos.y));
+                        if (l < o || (r.startDrag({
+                                evt: e
+                            }), !r.isDragging())) return
+                    }
+                    r._setDragPosition(e, n), t.push(r)
+                }
+            }), t.forEach(n => {
+                n.fire("dragmove", {
+                    type: "dragmove",
+                    target: n,
+                    evt: e
+                }, !0)
+            })
+        },
+        _endDragBefore(e) {
+            const t = [];
+            Ke._dragElements.forEach(n => {
+                const {
+                    node: i
+                } = n, r = i.getStage();
+                if (e && r.setPointersPositions(e), !r._changedPointerPositions.find(o => o.id === n.pointerId)) return;
+                (n.dragStatus === "dragging" || n.dragStatus === "stopped") && (Ke.justDragged = !0, pe._mouseListenClick = !1, pe._touchListenClick = !1, pe._pointerListenClick = !1, n.dragStatus = "stopped");
+                const a = n.node.getLayer() || n.node instanceof pe.Stage && n.node;
+                a && t.indexOf(a) === -1 && t.push(a)
+            }), t.forEach(n => {
+                n.draw()
+            })
+        },
+        _endDragAfter(e) {
+            Ke._dragElements.forEach((t, n) => {
+                t.dragStatus === "stopped" && t.node.fire("dragend", {
+                    type: "dragend",
+                    target: t.node,
+                    evt: e
+                }, !0), t.dragStatus !== "dragging" && Ke._dragElements.delete(n)
+            })
+        }
+    };
+    pe.isBrowser && (window.addEventListener("mouseup", Ke._endDragBefore, !0), window.addEventListener("touchend", Ke._endDragBefore, !0), window.addEventListener("mousemove", Ke._drag), window.addEventListener("touchmove", Ke._drag), window.addEventListener("mouseup", Ke._endDragAfter, !1), window.addEventListener("touchend", Ke._endDragAfter, !1));
+    var Hp = "absoluteOpacity",
+        lp = "allEventListeners",
+        Rs = "absoluteTransform",
+        q3 = "absoluteScale",
+        Ho = "canvas",
+        Cbe = "Change",
+        Abe = "children",
+        $be = "konva",
+        Hx = "listening",
+        H3 = "mouseenter",
+        Y3 = "mouseleave",
+        X3 = "set",
+        V3 = "Shape",
+        Yp = " ",
+        K3 = "stage",
+        Ea = "transform",
+        Tbe = "Stage",
+        Yx = "visible",
+        Mbe = ["xChange.konva", "yChange.konva", "scaleXChange.konva", "scaleYChange.konva", "skewXChange.konva", "skewYChange.konva", "rotationChange.konva", "offsetXChange.konva", "offsetYChange.konva", "transformsEnabledChange.konva"].join(Yp);
+    let Obe = 1;
+    class re {
+        constructor(t) {
+            this._id = Obe++, this.eventListeners = {}, this.attrs = {}, this.index = 0, this._allEventListeners = null, this.parent = null, this._cache = new Map, this._attachedDepsListeners = new Map, this._lastPos = null, this._batchingTransformChange = !1, this._needClearTransformCache = !1, this._filterUpToDate = !1, this._isUnderCache = !1, this._dragEventId = null, this._shouldFireChangeEvents = !1, this.setAttrs(t), this._shouldFireChangeEvents = !0
+        }
+        hasChildren() {
+            return !1
+        }
+        _clearCache(t) {
+            (t === Ea || t === Rs) && this._cache.get(t) ? this._cache.get(t).dirty = !0 : t ? this._cache.delete(t) : this._cache.clear()
+        }
+        _getCache(t, n) {
+            var i = this._cache.get(t),
+                r = t === Ea || t === Rs,
+                s = i === void 0 || r && i.dirty === !0;
+            return s && (i = n.call(this), this._cache.set(t, i)), i
+        }
+        _calculate(t, n, i) {
+            if (!this._attachedDepsListeners.get(t)) {
+                const r = n.map(s => s + "Change.konva").join(Yp);
+                this.on(r, () => {
+                    this._clearCache(t)
+                }), this._attachedDepsListeners.set(t, !0)
+            }
+            return this._getCache(t, i)
+        }
+        _getCanvasCache() {
+            return this._cache.get(Ho)
+        }
+        _clearSelfAndDescendantCache(t) {
+            this._clearCache(t), t === Rs && this.fire("absoluteTransformChange")
+        }
+        clearCache() {
+            if (this._cache.has(Ho)) {
+                const {
+                    scene: t,
+                    filter: n,
+                    hit: i
+                } = this._cache.get(Ho);
+                D.releaseCanvas(t, n, i), this._cache.delete(Ho)
+            }
+            return this._clearSelfAndDescendantCache(), this._requestDraw(), this
+        }
+        cache(t) {
+            var n = t || {},
+                i = {};
+            (n.x === void 0 || n.y === void 0 || n.width === void 0 || n.height === void 0) && (i = this.getClientRect({
+                skipTransform: !0,
+                relativeTo: this.getParent()
+            }));
+            var r = Math.ceil(n.width || i.width),
+                s = Math.ceil(n.height || i.height),
+                a = n.pixelRatio,
+                o = n.x === void 0 ? Math.floor(i.x) : n.x,
+                l = n.y === void 0 ? Math.floor(i.y) : n.y,
+                u = n.offset || 0,
+                c = n.drawBorder || !1,
+                f = n.hitCanvasPixelRatio || 1;
+            if (!r || !s) {
+                D.error("Can not cache the node. Width or height of the node equals 0. Caching is skipped.");
+                return
+            }
+            r += u * 2 + 1, s += u * 2 + 1, o -= u, l -= u;
+            var h = new nc({
+                    pixelRatio: a,
+                    width: r,
+                    height: s
+                }),
+                d = new nc({
+                    pixelRatio: a,
+                    width: 0,
+                    height: 0
+                }),
+                g = new zC({
+                    pixelRatio: f,
+                    width: r,
+                    height: s
+                }),
+                p = h.getContext(),
+                m = g.getContext();
+            return g.isCache = !0, h.isCache = !0, this._cache.delete(Ho), this._filterUpToDate = !1, n.imageSmoothingEnabled === !1 && (h.getContext()._context.imageSmoothingEnabled = !1, d.getContext()._context.imageSmoothingEnabled = !1), p.save(), m.save(), p.translate(-o, -l), m.translate(-o, -l), this._isUnderCache = !0, this._clearSelfAndDescendantCache(Hp), this._clearSelfAndDescendantCache(q3), this.drawScene(h, this), this.drawHit(g, this), this._isUnderCache = !1, p.restore(), m.restore(), c && (p.save(), p.beginPath(), p.rect(0, 0, r, s), p.closePath(), p.setAttr("strokeStyle", "red"), p.setAttr("lineWidth", 5), p.stroke(), p.restore()), this._cache.set(Ho, {
+                scene: h,
+                filter: d,
+                hit: g,
+                x: o,
+                y: l
+            }), this._requestDraw(), this
+        }
+        isCached() {
+            return this._cache.has(Ho)
+        }
+        getClientRect(t) {
+            throw new Error('abstract "getClientRect" method call')
+        }
+        _transformedRect(t, n) {
+            var i = [{
+                    x: t.x,
+                    y: t.y
+                }, {
+                    x: t.x + t.width,
+                    y: t.y
+                }, {
+                    x: t.x + t.width,
+                    y: t.y + t.height
+                }, {
+                    x: t.x,
+                    y: t.y + t.height
+                }],
+                r, s, a, o, l = this.getAbsoluteTransform(n);
+            return i.forEach(function(u) {
+                var c = l.point(u);
+                r === void 0 && (r = a = c.x, s = o = c.y), r = Math.min(r, c.x), s = Math.min(s, c.y), a = Math.max(a, c.x), o = Math.max(o, c.y)
+            }), {
+                x: r,
+                y: s,
+                width: a - r,
+                height: o - s
+            }
+        }
+        _drawCachedSceneCanvas(t) {
+            t.save(), t._applyOpacity(this), t._applyGlobalCompositeOperation(this);
+            const n = this._getCanvasCache();
+            t.translate(n.x, n.y);
+            var i = this._getCachedSceneCanvas(),
+                r = i.pixelRatio;
+            t.drawImage(i._canvas, 0, 0, i.width / r, i.height / r), t.restore()
+        }
+        _drawCachedHitCanvas(t) {
+            var n = this._getCanvasCache(),
+                i = n.hit;
+            t.save(), t.translate(n.x, n.y), t.drawImage(i._canvas, 0, 0, i.width / i.pixelRatio, i.height / i.pixelRatio), t.restore()
+        }
+        _getCachedSceneCanvas() {
+            var t = this.filters(),
+                n = this._getCanvasCache(),
+                i = n.scene,
+                r = n.filter,
+                s = r.getContext(),
+                a, o, l, u;
+            if (t) {
+                if (!this._filterUpToDate) {
+                    var c = i.pixelRatio;
+                    r.setSize(i.width / i.pixelRatio, i.height / i.pixelRatio);
+                    try {
+                        for (a = t.length, s.clear(), s.drawImage(i._canvas, 0, 0, i.getWidth() / c, i.getHeight() / c), o = s.getImageData(0, 0, r.getWidth(), r.getHeight()), l = 0; l < a; l++) {
+                            if (u = t[l], typeof u != "function") {
+                                D.error("Filter should be type of function, but got " + typeof u + " instead. Please check correct filters");
+                                continue
+                            }
+                            u.call(this, o), s.putImageData(o, 0, 0)
+                        }
+                    } catch (f) {
+                        D.error("Unable to apply filter. " + f.message + " This post my help you https://konvajs.org/docs/posts/Tainted_Canvas.html.")
+                    }
+                    this._filterUpToDate = !0
+                }
+                return r
+            }
+            return i
+        }
+        on(t, n) {
+            if (this._cache && this._cache.delete(lp), arguments.length === 3) return this._delegate.apply(this, arguments);
+            var i = t.split(Yp),
+                r = i.length,
+                s, a, o, l, u;
+            for (s = 0; s < r; s++) a = i[s], o = a.split("."), l = o[0], u = o[1] || "", this.eventListeners[l] || (this.eventListeners[l] = []), this.eventListeners[l].push({
+                name: u,
+                handler: n
+            });
+            return this
+        }
+        off(t, n) {
+            var i = (t || "").split(Yp),
+                r = i.length,
+                s, a, o, l, u, c;
+            if (this._cache && this._cache.delete(lp), !t)
+                for (a in this.eventListeners) this._off(a);
+            for (s = 0; s < r; s++)
+                if (o = i[s], l = o.split("."), u = l[0], c = l[1], u) this.eventListeners[u] && this._off(u, c, n);
+                else
+                    for (a in this.eventListeners) this._off(a, c, n);
+            return this
+        }
+        dispatchEvent(t) {
+            var n = {
+                target: this,
+                type: t.type,
+                evt: t
+            };
+            return this.fire(t.type, n), this
+        }
+        addEventListener(t, n) {
+            return this.on(t, function(i) {
+                n.call(this, i.evt)
+            }), this
+        }
+        removeEventListener(t) {
+            return this.off(t), this
+        }
+        _delegate(t, n, i) {
+            var r = this;
+            this.on(t, function(s) {
+                for (var a = s.target.findAncestors(n, !0, r), o = 0; o < a.length; o++) s = D.cloneObject(s), s.currentTarget = a[o], i.call(a[o], s)
+            })
+        }
+        remove() {
+            return this.isDragging() && this.stopDrag(), Ke._dragElements.delete(this._id), this._remove(), this
+        }
+        _clearCaches() {
+            this._clearSelfAndDescendantCache(Rs), this._clearSelfAndDescendantCache(Hp), this._clearSelfAndDescendantCache(q3), this._clearSelfAndDescendantCache(K3), this._clearSelfAndDescendantCache(Yx), this._clearSelfAndDescendantCache(Hx)
+        }
+        _remove() {
+            this._clearCaches();
+            var t = this.getParent();
+            t && t.children && (t.children.splice(this.index, 1), t._setChildrenIndices(), this.parent = null)
+        }
+        destroy() {
+            return this.remove(), this.clearCache(), this
+        }
+        getAttr(t) {
+            var n = "get" + D._capitalize(t);
+            return D._isFunction(this[n]) ? this[n]() : this.attrs[t]
+        }
+        getAncestors() {
+            for (var t = this.getParent(), n = []; t;) n.push(t), t = t.getParent();
+            return n
+        }
+        getAttrs() {
+            return this.attrs || {}
+        }
+        setAttrs(t) {
+            return this._batchTransformChanges(() => {
+                var n, i;
+                if (!t) return this;
+                for (n in t) n !== Abe && (i = X3 + D._capitalize(n), D._isFunction(this[i]) ? this[i](t[n]) : this._setAttr(n, t[n]))
+            }), this
+        }
+        isListening() {
+            return this._getCache(Hx, this._isListening)
+        }
+        _isListening(t) {
+            if (!this.listening()) return !1;
+            const i = this.getParent();
+            return i && i !== t && this !== t ? i._isListening(t) : !0
+        }
+        isVisible() {
+            return this._getCache(Yx, this._isVisible)
+        }
+        _isVisible(t) {
+            if (!this.visible()) return !1;
+            const i = this.getParent();
+            return i && i !== t && this !== t ? i._isVisible(t) : !0
+        }
+        shouldDrawHit(t, n = !1) {
+            if (t) return this._isVisible(t) && this._isListening(t);
+            var i = this.getLayer(),
+                r = !1;
+            Ke._dragElements.forEach(a => {
+                a.dragStatus === "dragging" && (a.node.nodeType === "Stage" || a.node.getLayer() === i) && (r = !0)
+            });
+            var s = !n && !pe.hitOnDragEnabled && r;
+            return this.isListening() && this.isVisible() && !s
+        }
+        show() {
+            return this.visible(!0), this
+        }
+        hide() {
+            return this.visible(!1), this
+        }
+        getZIndex() {
+            return this.index || 0
+        }
+        getAbsoluteZIndex() {
+            var t = this.getDepth(),
+                n = this,
+                i = 0,
+                r, s, a, o;
+
+            function l(u) {
+                for (r = [], s = u.length, a = 0; a < s; a++) o = u[a], i++, o.nodeType !== V3 && (r = r.concat(o.getChildren().slice())), o._id === n._id && (a = s);
+                r.length > 0 && r[0].getDepth() <= t && l(r)
+            }
+            return n.nodeType !== Tbe && l(n.getStage().getChildren()), i
+        }
+        getDepth() {
+            for (var t = 0, n = this.parent; n;) t++, n = n.parent;
+            return t
+        }
+        _batchTransformChanges(t) {
+            this._batchingTransformChange = !0, t(), this._batchingTransformChange = !1, this._needClearTransformCache && (this._clearCache(Ea), this._clearSelfAndDescendantCache(Rs)), this._needClearTransformCache = !1
+        }
+        setPosition(t) {
+            return this._batchTransformChanges(() => {
+                this.x(t.x), this.y(t.y)
+            }), this
+        }
+        getPosition() {
+            return {
+                x: this.x(),
+                y: this.y()
+            }
+        }
+        getRelativePointerPosition() {
+            if (!this.getStage()) return null;
+            var t = this.getStage().getPointerPosition();
+            if (!t) return null;
+            var n = this.getAbsoluteTransform().copy();
+            return n.invert(), n.point(t)
+        }
+        getAbsolutePosition(t) {
+            let n = !1,
+                i = this.parent;
+            for (; i;) {
+                if (i.isCached()) {
+                    n = !0;
+                    break
+                }
+                i = i.parent
+            }
+            n && !t && (t = !0);
+            var r = this.getAbsoluteTransform(t).getMatrix(),
+                s = new mr,
+                a = this.offset();
+            return s.m = r.slice(), s.translate(a.x, a.y), s.getTranslation()
+        }
+        setAbsolutePosition(t) {
+            var n = this._clearTransform();
+            this.attrs.x = n.x, this.attrs.y = n.y, delete n.x, delete n.y, this._clearCache(Ea);
+            var i = this._getAbsoluteTransform().copy();
+            return i.invert(), i.translate(t.x, t.y), t = {
+                x: this.attrs.x + i.getTranslation().x,
+                y: this.attrs.y + i.getTranslation().y
+            }, this._setTransform(n), this.setPosition({
+                x: t.x,
+                y: t.y
+            }), this._clearCache(Ea), this._clearSelfAndDescendantCache(Rs), this
+        }
+        _setTransform(t) {
+            var n;
+            for (n in t) this.attrs[n] = t[n]
+        }
+        _clearTransform() {
+            var t = {
+                x: this.x(),
+                y: this.y(),
+                rotation: this.rotation(),
+                scaleX: this.scaleX(),
+                scaleY: this.scaleY(),
+                offsetX: this.offsetX(),
+                offsetY: this.offsetY(),
+                skewX: this.skewX(),
+                skewY: this.skewY()
+            };
+            return this.attrs.x = 0, this.attrs.y = 0, this.attrs.rotation = 0, this.attrs.scaleX = 1, this.attrs.scaleY = 1, this.attrs.offsetX = 0, this.attrs.offsetY = 0, this.attrs.skewX = 0, this.attrs.skewY = 0, t
+        }
+        move(t) {
+            var n = t.x,
+                i = t.y,
+                r = this.x(),
+                s = this.y();
+            return n !== void 0 && (r += n), i !== void 0 && (s += i), this.setPosition({
+                x: r,
+                y: s
+            }), this
+        }
+        _eachAncestorReverse(t, n) {
+            var i = [],
+                r = this.getParent(),
+                s, a;
+            if (!(n && n._id === this._id)) {
+                for (i.unshift(this); r && (!n || r._id !== n._id);) i.unshift(r), r = r.parent;
+                for (s = i.length, a = 0; a < s; a++) t(i[a])
+            }
+        }
+        rotate(t) {
+            return this.rotation(this.rotation() + t), this
+        }
+        moveToTop() {
+            if (!this.parent) return D.warn("Node has no parent. moveToTop function is ignored."), !1;
+            var t = this.index,
+                n = this.parent.getChildren().length;
+            return t < n - 1 ? (this.parent.children.splice(t, 1), this.parent.children.push(this), this.parent._setChildrenIndices(), !0) : !1
+        }
+        moveUp() {
+            if (!this.parent) return D.warn("Node has no parent. moveUp function is ignored."), !1;
+            var t = this.index,
+                n = this.parent.getChildren().length;
+            return t < n - 1 ? (this.parent.children.splice(t, 1), this.parent.children.splice(t + 1, 0, this), this.parent._setChildrenIndices(), !0) : !1
+        }
+        moveDown() {
+            if (!this.parent) return D.warn("Node has no parent. moveDown function is ignored."), !1;
+            var t = this.index;
+            return t > 0 ? (this.parent.children.splice(t, 1), this.parent.children.splice(t - 1, 0, this), this.parent._setChildrenIndices(), !0) : !1
+        }
+        moveToBottom() {
+            if (!this.parent) return D.warn("Node has no parent. moveToBottom function is ignored."), !1;
+            var t = this.index;
+            return t > 0 ? (this.parent.children.splice(t, 1), this.parent.children.unshift(this), this.parent._setChildrenIndices(), !0) : !1
+        }
+        setZIndex(t) {
+            if (!this.parent) return D.warn("Node has no parent. zIndex parameter is ignored."), this;
+            (t < 0 || t >= this.parent.children.length) && D.warn("Unexpected value " + t + " for zIndex property. zIndex is just index of a node in children of its parent. Expected value is from 0 to " + (this.parent.children.length - 1) + ".");
+            var n = this.index;
+            return this.parent.children.splice(n, 1), this.parent.children.splice(t, 0, this), this.parent._setChildrenIndices(), this
+        }
+        getAbsoluteOpacity() {
+            return this._getCache(Hp, this._getAbsoluteOpacity)
+        }
+        _getAbsoluteOpacity() {
+            var t = this.opacity(),
+                n = this.getParent();
+            return n && !n._isUnderCache && (t *= n.getAbsoluteOpacity()), t
+        }
+        moveTo(t) {
+            return this.getParent() !== t && (this._remove(), t.add(this)), this
+        }
+        toObject() {
+            var t = {},
+                n = this.getAttrs(),
+                i, r, s, a, o;
+            t.attrs = {};
+            for (i in n) r = n[i], o = D.isObject(r) && !D._isPlainObject(r) && !D._isArray(r), !o && (s = typeof this[i] == "function" && this[i], delete n[i], a = s ? s.call(this) : null, n[i] = r, a !== r && (t.attrs[i] = r));
+            return t.className = this.getClassName(), D._prepareToStringify(t)
+        }
+        toJSON() {
+            return JSON.stringify(this.toObject())
+        }
+        getParent() {
+            return this.parent
+        }
+        findAncestors(t, n, i) {
+            var r = [];
+            n && this._isMatch(t) && r.push(this);
+            for (var s = this.parent; s;) {
+                if (s === i) return r;
+                s._isMatch(t) && r.push(s), s = s.parent
+            }
+            return r
+        }
+        isAncestorOf(t) {
+            return !1
+        }
+        findAncestor(t, n, i) {
+            return this.findAncestors(t, n, i)[0]
+        }
+        _isMatch(t) {
+            if (!t) return !1;
+            if (typeof t == "function") return t(this);
+            var n = t.replace(/ /g, "").split(","),
+                i = n.length,
+                r, s;
+            for (r = 0; r < i; r++)
+                if (s = n[r], D.isValidSelector(s) || (D.warn('Selector "' + s + '" is invalid. Allowed selectors examples are "#foo", ".bar" or "Group".'), D.warn('If you have a custom shape with such className, please change it to start with upper letter like "Triangle".'), D.warn("Konva is awesome, right?")), s.charAt(0) === "#") {
+                    if (this.id() === s.slice(1)) return !0
+                } else if (s.charAt(0) === ".") {
+                if (this.hasName(s.slice(1))) return !0
+            } else if (this.className === s || this.nodeType === s) return !0;
+            return !1
+        }
+        getLayer() {
+            var t = this.getParent();
+            return t ? t.getLayer() : null
+        }
+        getStage() {
+            return this._getCache(K3, this._getStage)
+        }
+        _getStage() {
+            var t = this.getParent();
+            if (t) return t.getStage()
+        }
+        fire(t, n = {}, i) {
+            return n.target = n.target || this, i ? this._fireAndBubble(t, n) : this._fire(t, n), this
+        }
+        getAbsoluteTransform(t) {
+            return t ? this._getAbsoluteTransform(t) : this._getCache(Rs, this._getAbsoluteTransform)
+        }
+        _getAbsoluteTransform(t) {
+            var n;
+            if (t) return n = new mr, this._eachAncestorReverse(function(r) {
+                var s = r.transformsEnabled();
+                s === "all" ? n.multiply(r.getTransform()) : s === "position" && n.translate(r.x() - r.offsetX(), r.y() - r.offsetY())
+            }, t), n;
+            n = this._cache.get(Rs) || new mr, this.parent ? this.parent.getAbsoluteTransform().copyInto(n) : n.reset();
+            var i = this.transformsEnabled();
+            if (i === "all") n.multiply(this.getTransform());
+            else if (i === "position") {
+                const r = this.attrs.x || 0,
+                    s = this.attrs.y || 0,
+                    a = this.attrs.offsetX || 0,
+                    o = this.attrs.offsetY || 0;
+                n.translate(r - a, s - o)
+            }
+            return n.dirty = !1, n
+        }
+        getAbsoluteScale(t) {
+            for (var n = this; n;) n._isUnderCache && (t = n), n = n.getParent();
+            const r = this.getAbsoluteTransform(t).decompose();
+            return {
+                x: r.scaleX,
+                y: r.scaleY
+            }
+        }
+        getAbsoluteRotation() {
+            return this.getAbsoluteTransform().decompose().rotation
+        }
+        getTransform() {
+            return this._getCache(Ea, this._getTransform)
+        }
+        _getTransform() {
+            var t, n, i = this._cache.get(Ea) || new mr;
+            i.reset();
+            var r = this.x(),
+                s = this.y(),
+                a = pe.getAngle(this.rotation()),
+                o = (t = this.attrs.scaleX) !== null && t !== void 0 ? t : 1,
+                l = (n = this.attrs.scaleY) !== null && n !== void 0 ? n : 1,
+                u = this.attrs.skewX || 0,
+                c = this.attrs.skewY || 0,
+                f = this.attrs.offsetX || 0,
+                h = this.attrs.offsetY || 0;
+            return (r !== 0 || s !== 0) && i.translate(r, s), a !== 0 && i.rotate(a), (u !== 0 || c !== 0) && i.skew(u, c), (o !== 1 || l !== 1) && i.scale(o, l), (f !== 0 || h !== 0) && i.translate(-1 * f, -1 * h), i.dirty = !1, i
+        }
+        clone(t) {
+            var n = D.cloneObject(this.attrs),
+                i, r, s, a, o;
+            for (i in t) n[i] = t[i];
+            var l = new this.constructor(n);
+            for (i in this.eventListeners)
+                for (r = this.eventListeners[i], s = r.length, a = 0; a < s; a++) o = r[a], o.name.indexOf($be) < 0 && (l.eventListeners[i] || (l.eventListeners[i] = []), l.eventListeners[i].push(o));
+            return l
+        }
+        _toKonvaCanvas(t) {
+            t = t || {};
+            var n = this.getClientRect(),
+                i = this.getStage(),
+                r = t.x !== void 0 ? t.x : Math.floor(n.x),
+                s = t.y !== void 0 ? t.y : Math.floor(n.y),
+                a = t.pixelRatio || 1,
+                o = new nc({
+                    width: t.width || Math.ceil(n.width) || (i ? i.width() : 0),
+                    height: t.height || Math.ceil(n.height) || (i ? i.height() : 0),
+                    pixelRatio: a
+                }),
+                l = o.getContext();
+            return t.imageSmoothingEnabled === !1 && (l._context.imageSmoothingEnabled = !1), l.save(), (r || s) && l.translate(-1 * r, -1 * s), this.drawScene(o), l.restore(), o
+        }
+        toCanvas(t) {
+            return this._toKonvaCanvas(t)._canvas
+        }
+        toDataURL(t) {
+            t = t || {};
+            var n = t.mimeType || null,
+                i = t.quality || null,
+                r = this._toKonvaCanvas(t).toDataURL(n, i);
+            return t.callback && t.callback(r), r
+        }
+        toImage(t) {
+            return new Promise((n, i) => {
+                try {
+                    const r = t == null ? void 0 : t.callback;
+                    r && delete t.callback, D._urlToImage(this.toDataURL(t), function(s) {
+                        n(s), r == null || r(s)
+                    })
+                } catch (r) {
+                    i(r)
+                }
+            })
+        }
+        toBlob(t) {
+            return new Promise((n, i) => {
+                try {
+                    const r = t == null ? void 0 : t.callback;
+                    r && delete t.callback, this.toCanvas(t).toBlob(s => {
+                        n(s), r == null || r(s)
+                    })
+                } catch (r) {
+                    i(r)
+                }
+            })
+        }
+        setSize(t) {
+            return this.width(t.width), this.height(t.height), this
+        }
+        getSize() {
+            return {
+                width: this.width(),
+                height: this.height()
+            }
+        }
+        getClassName() {
+            return this.className || this.nodeType
+        }
+        getType() {
+            return this.nodeType
+        }
+        getDragDistance() {
+            return this.attrs.dragDistance !== void 0 ? this.attrs.dragDistance : this.parent ? this.parent.getDragDistance() : pe.dragDistance
+        }
+        _off(t, n, i) {
+            var r = this.eventListeners[t],
+                s, a, o;
+            for (s = 0; s < r.length; s++)
+                if (a = r[s].name, o = r[s].handler, (a !== "konva" || n === "konva") && (!n || a === n) && (!i || i === o)) {
+                    if (r.splice(s, 1), r.length === 0) {
+                        delete this.eventListeners[t];
+                        break
+                    }
+                    s--
+                }
+        }
+        _fireChangeEvent(t, n, i) {
+            this._fire(t + Cbe, {
+                oldVal: n,
+                newVal: i
+            })
+        }
+        addName(t) {
+            if (!this.hasName(t)) {
+                var n = this.name(),
+                    i = n ? n + " " + t : t;
+                this.name(i)
+            }
+            return this
+        }
+        hasName(t) {
+            if (!t) return !1;
+            const n = this.name();
+            if (!n) return !1;
+            var i = (n || "").split(/\s/g);
+            return i.indexOf(t) !== -1
+        }
+        removeName(t) {
+            var n = (this.name() || "").split(/\s/g),
+                i = n.indexOf(t);
+            return i !== -1 && (n.splice(i, 1), this.name(n.join(" "))), this
+        }
+        setAttr(t, n) {
+            var i = this[X3 + D._capitalize(t)];
+            return D._isFunction(i) ? i.call(this, n) : this._setAttr(t, n), this
+        }
+        _requestDraw() {
+            if (pe.autoDrawEnabled) {
+                const t = this.getLayer() || this.getStage();
+                t == null || t.batchDraw()
+            }
+        }
+        _setAttr(t, n) {
+            var i = this.attrs[t];
+            i === n && !D.isObject(n) || (n == null ? delete this.attrs[t] : this.attrs[t] = n, this._shouldFireChangeEvents && this._fireChangeEvent(t, i, n), this._requestDraw())
+        }
+        _setComponentAttr(t, n, i) {
+            var r;
+            i !== void 0 && (r = this.attrs[t], r || (this.attrs[t] = this.getAttr(t)), this.attrs[t][n] = i, this._fireChangeEvent(t, r, i))
+        }
+        _fireAndBubble(t, n, i) {
+            n && this.nodeType === V3 && (n.target = this);
+            var r = (t === H3 || t === Y3) && (i && (this === i || this.isAncestorOf && this.isAncestorOf(i)) || this.nodeType === "Stage" && !i);
+            if (!r) {
+                this._fire(t, n);
+                var s = (t === H3 || t === Y3) && i && i.isAncestorOf && i.isAncestorOf(this) && !i.isAncestorOf(this.parent);
+                (n && !n.cancelBubble || !n) && this.parent && this.parent.isListening() && !s && (i && i.parent ? this._fireAndBubble.call(this.parent, t, n, i) : this._fireAndBubble.call(this.parent, t, n))
+            }
+        }
+        _getProtoListeners(t) {
+            let n = this._cache.get(lp);
+            if (!n) {
+                n = {};
+                let r = Object.getPrototypeOf(this);
+                for (; r;) {
+                    if (!r.eventListeners) {
+                        r = Object.getPrototypeOf(r);
+                        continue
+                    }
+                    for (var i in r.eventListeners) {
+                        const s = r.eventListeners[i],
+                            a = n[i] || [];
+                        n[i] = s.concat(a)
+                    }
+                    r = Object.getPrototypeOf(r)
+                }
+                this._cache.set(lp, n)
+            }
+            return n[t]
+        }
+        _fire(t, n) {
+            n = n || {}, n.currentTarget = this, n.type = t;
+            const i = this._getProtoListeners(t);
+            if (i)
+                for (var r = 0; r < i.length; r++) i[r].handler.call(this, n);
+            const s = this.eventListeners[t];
+            if (s)
+                for (var r = 0; r < s.length; r++) s[r].handler.call(this, n)
+        }
+        draw() {
+            return this.drawScene(), this.drawHit(), this
+        }
+        _createDragElement(t) {
+            var n = t ? t.pointerId : void 0,
+                i = this.getStage(),
+                r = this.getAbsolutePosition(),
+                s = i._getPointerById(n) || i._changedPointerPositions[0] || r;
+            Ke._dragElements.set(this._id, {
+                node: this,
+                startPointerPos: s,
+                offset: {
+                    x: s.x - r.x,
+                    y: s.y - r.y
+                },
+                dragStatus: "ready",
+                pointerId: n
+            })
+        }
+        startDrag(t, n = !0) {
+            Ke._dragElements.has(this._id) || this._createDragElement(t);
+            const i = Ke._dragElements.get(this._id);
+            i.dragStatus = "dragging", this.fire("dragstart", {
+                type: "dragstart",
+                target: this,
+                evt: t && t.evt
+            }, n)
+        }
+        _setDragPosition(t, n) {
+            const i = this.getStage()._getPointerById(n.pointerId);
+            if (i) {
+                var r = {
+                        x: i.x - n.offset.x,
+                        y: i.y - n.offset.y
+                    },
+                    s = this.dragBoundFunc();
+                if (s !== void 0) {
+                    const a = s.call(this, r, t);
+                    a ? r = a : D.warn("dragBoundFunc did not return any value. That is unexpected behavior. You must return new absolute position from dragBoundFunc.")
+                }(!this._lastPos || this._lastPos.x !== r.x || this._lastPos.y !== r.y) && (this.setAbsolutePosition(r), this._requestDraw()), this._lastPos = r
+            }
+        }
+        stopDrag(t) {
+            const n = Ke._dragElements.get(this._id);
+            n && (n.dragStatus = "stopped"), Ke._endDragBefore(t), Ke._endDragAfter(t)
+        }
+        setDraggable(t) {
+            this._setAttr("draggable", t), this._dragChange()
+        }
+        isDragging() {
+            const t = Ke._dragElements.get(this._id);
+            return t ? t.dragStatus === "dragging" : !1
+        }
+        _listenDrag() {
+            this._dragCleanup(), this.on("mousedown.konva touchstart.konva", function(t) {
+                var n = t.evt.button !== void 0,
+                    i = !n || pe.dragButtons.indexOf(t.evt.button) >= 0;
+                if (i && !this.isDragging()) {
+                    var r = !1;
+                    Ke._dragElements.forEach(s => {
+                        this.isAncestorOf(s.node) && (r = !0)
+                    }), r || this._createDragElement(t)
+                }
+            })
+        }
+        _dragChange() {
+            if (this.attrs.draggable) this._listenDrag();
+            else {
+                this._dragCleanup();
+                var t = this.getStage();
+                if (!t) return;
+                const n = Ke._dragElements.get(this._id),
+                    i = n && n.dragStatus === "dragging",
+                    r = n && n.dragStatus === "ready";
+                i ? this.stopDrag() : r && Ke._dragElements.delete(this._id)
+            }
+        }
+        _dragCleanup() {
+            this.off("mousedown.konva"), this.off("touchstart.konva")
+        }
+        isClientRectOnScreen(t = {
+            x: 0,
+            y: 0
+        }) {
+            const n = this.getStage();
+            if (!n) return !1;
+            const i = {
+                x: -t.x,
+                y: -t.y,
+                width: n.width() + 2 * t.x,
+                height: n.height() + 2 * t.y
+            };
+            return D.haveIntersection(i, this.getClientRect())
+        }
+        static create(t, n) {
+            return D._isString(t) && (t = JSON.parse(t)), this._createNode(t, n)
+        }
+        static _createNode(t, n) {
+            var i = re.prototype.getClassName.call(t),
+                r = t.children,
+                s, a, o;
+            n && (t.attrs.container = n), pe[i] || (D.warn('Can not find a node with class name "' + i + '". Fallback to "Shape".'), i = "Shape");
+            const l = pe[i];
+            if (s = new l(t.attrs), r)
+                for (a = r.length, o = 0; o < a; o++) s.add(re._createNode(r[o]));
+            return s
+        }
+    }
+    re.prototype.nodeType = "Node";
+    re.prototype._attrsAffectingSize = [];
+    re.prototype.eventListeners = {};
+    re.prototype.on.call(re.prototype, Mbe, function() {
+        if (this._batchingTransformChange) {
+            this._needClearTransformCache = !0;
+            return
+        }
+        this._clearCache(Ea), this._clearSelfAndDescendantCache(Rs)
+    });
+    re.prototype.on.call(re.prototype, "visibleChange.konva", function() {
+        this._clearSelfAndDescendantCache(Yx)
+    });
+    re.prototype.on.call(re.prototype, "listeningChange.konva", function() {
+        this._clearSelfAndDescendantCache(Hx)
+    });
+    re.prototype.on.call(re.prototype, "opacityChange.konva", function() {
+        this._clearSelfAndDescendantCache(Hp)
+    });
+    const gt = O.addGetterSetter;
+    gt(re, "zIndex");
+    gt(re, "absolutePosition");
+    gt(re, "position");
+    gt(re, "x", 0, se());
+    gt(re, "y", 0, se());
+    gt(re, "globalCompositeOperation", "source-over", hf());
+    gt(re, "opacity", 1, se());
+    gt(re, "name", "", hf());
+    gt(re, "id", "", hf());
+    gt(re, "rotation", 0, se());
+    O.addComponentsGetterSetter(re, "scale", ["x", "y"]);
+    gt(re, "scaleX", 1, se());
+    gt(re, "scaleY", 1, se());
+    O.addComponentsGetterSetter(re, "skew", ["x", "y"]);
+    gt(re, "skewX", 0, se());
+    gt(re, "skewY", 0, se());
+    O.addComponentsGetterSetter(re, "offset", ["x", "y"]);
+    gt(re, "offsetX", 0, se());
+    gt(re, "offsetY", 0, se());
+    gt(re, "dragDistance", null, se());
+    gt(re, "width", 0, se());
+    gt(re, "height", 0, se());
+    gt(re, "listening", !0, zr());
+    gt(re, "preventDefault", !0, zr());
+    gt(re, "filters", null, function(e) {
+        return this._filterUpToDate = !1, e
+    });
+    gt(re, "visible", !0, zr());
+    gt(re, "transformsEnabled", "all", hf());
+    gt(re, "size");
+    gt(re, "dragBoundFunc");
+    gt(re, "draggable", !1, zr());
+    O.backCompat(re, {
+        rotateDeg: "rotate",
+        setRotationDeg: "setRotation",
+        getRotationDeg: "getRotation"
+    });
+    let Mi = class extends re {
+        constructor() {
+            super(...arguments), this.children = []
+        }
+        getChildren(t) {
+            if (!t) return this.children || [];
+            const n = this.children || [];
+            var i = [];
+            return n.forEach(function(r) {
+                t(r) && i.push(r)
+            }), i
+        }
+        hasChildren() {
+            return this.getChildren().length > 0
+        }
+        removeChildren() {
+            return this.getChildren().forEach(t => {
+                t.parent = null, t.index = 0, t.remove()
+            }), this.children = [], this._requestDraw(), this
+        }
+        destroyChildren() {
+            return this.getChildren().forEach(t => {
+                t.parent = null, t.index = 0, t.destroy()
+            }), this.children = [], this._requestDraw(), this
+        }
+        add(...t) {
+            if (t.length === 0) return this;
+            if (t.length > 1) {
+                for (var n = 0; n < t.length; n++) this.add(t[n]);
+                return this
+            }
+            const i = t[0];
+            return i.getParent() ? (i.moveTo(this), this) : (this._validateAdd(i), i.index = this.getChildren().length, i.parent = this, i._clearCaches(), this.getChildren().push(i), this._fire("add", {
+                child: i
+            }), this._requestDraw(), this)
+        }
+        destroy() {
+            return this.hasChildren() && this.destroyChildren(), super.destroy(), this
+        }
+        find(t) {
+            return this._generalFind(t, !1)
+        }
+        findOne(t) {
+            var n = this._generalFind(t, !0);
+            return n.length > 0 ? n[0] : void 0
+        }
+        _generalFind(t, n) {
+            var i = [];
+            return this._descendants(r => {
+                const s = r._isMatch(t);
+                return s && i.push(r), !!(s && n)
+            }), i
+        }
+        _descendants(t) {
+            let n = !1;
+            const i = this.getChildren();
+            for (const r of i) {
+                if (n = t(r), n) return !0;
+                if (r.hasChildren() && (n = r._descendants(t), n)) return !0
+            }
+            return !1
+        }
+        toObject() {
+            var t = re.prototype.toObject.call(this);
+            return t.children = [], this.getChildren().forEach(n => {
+                t.children.push(n.toObject())
+            }), t
+        }
+        isAncestorOf(t) {
+            for (var n = t.getParent(); n;) {
+                if (n._id === this._id) return !0;
+                n = n.getParent()
+            }
+            return !1
+        }
+        clone(t) {
+            var n = re.prototype.clone.call(this, t);
+            return this.getChildren().forEach(function(i) {
+                n.add(i.clone())
+            }), n
+        }
+        getAllIntersections(t) {
+            var n = [];
+            return this.find("Shape").forEach(function(i) {
+                i.isVisible() && i.intersects(t) && n.push(i)
+            }), n
+        }
+        _clearSelfAndDescendantCache(t) {
+            var n;
+            super._clearSelfAndDescendantCache(t), !this.isCached() && ((n = this.children) === null || n === void 0 || n.forEach(function(i) {
+                i._clearSelfAndDescendantCache(t)
+            }))
+        }
+        _setChildrenIndices() {
+            var t;
+            (t = this.children) === null || t === void 0 || t.forEach(function(n, i) {
+                n.index = i
+            }), this._requestDraw()
+        }
+        drawScene(t, n) {
+            var i = this.getLayer(),
+                r = t || i && i.getCanvas(),
+                s = r && r.getContext(),
+                a = this._getCanvasCache(),
+                o = a && a.scene,
+                l = r && r.isCache;
+            if (!this.isVisible() && !l) return this;
+            if (o) {
+                s.save();
+                var u = this.getAbsoluteTransform(n).getMatrix();
+                s.transform(u[0], u[1], u[2], u[3], u[4], u[5]), this._drawCachedSceneCanvas(s), s.restore()
+            } else this._drawChildren("drawScene", r, n);
+            return this
+        }
+        drawHit(t, n) {
+            if (!this.shouldDrawHit(n)) return this;
+            var i = this.getLayer(),
+                r = t || i && i.hitCanvas,
+                s = r && r.getContext(),
+                a = this._getCanvasCache(),
+                o = a && a.hit;
+            if (o) {
+                s.save();
+                var l = this.getAbsoluteTransform(n).getMatrix();
+                s.transform(l[0], l[1], l[2], l[3], l[4], l[5]), this._drawCachedHitCanvas(s), s.restore()
+            } else this._drawChildren("drawHit", r, n);
+            return this
+        }
+        _drawChildren(t, n, i) {
+            var r, s = n && n.getContext(),
+                a = this.clipWidth(),
+                o = this.clipHeight(),
+                l = this.clipFunc(),
+                u = a && o || l;
+            const c = i === this;
+            if (u) {
+                s.save();
+                var f = this.getAbsoluteTransform(i),
+                    h = f.getMatrix();
+                if (s.transform(h[0], h[1], h[2], h[3], h[4], h[5]), s.beginPath(), l) l.call(this, s, this);
+                else {
+                    var d = this.clipX(),
+                        g = this.clipY();
+                    s.rect(d, g, a, o)
+                }
+                s.clip(), h = f.copy().invert().getMatrix(), s.transform(h[0], h[1], h[2], h[3], h[4], h[5])
+            }
+            var p = !c && this.globalCompositeOperation() !== "source-over" && t === "drawScene";
+            p && (s.save(), s._applyGlobalCompositeOperation(this)), (r = this.children) === null || r === void 0 || r.forEach(function(m) {
+                m[t](n, i)
+            }), p && s.restore(), u && s.restore()
+        }
+        getClientRect(t) {
+            var n;
+            t = t || {};
+            var i = t.skipTransform,
+                r = t.relativeTo,
+                s, a, o, l, u = {
+                    x: 1 / 0,
+                    y: 1 / 0,
+                    width: 0,
+                    height: 0
+                },
+                c = this;
+            (n = this.children) === null || n === void 0 || n.forEach(function(p) {
+                if (p.visible()) {
+                    var m = p.getClientRect({
+                        relativeTo: c,
+                        skipShadow: t.skipShadow,
+                        skipStroke: t.skipStroke
+                    });
+                    m.width === 0 && m.height === 0 || (s === void 0 ? (s = m.x, a = m.y, o = m.x + m.width, l = m.y + m.height) : (s = Math.min(s, m.x), a = Math.min(a, m.y), o = Math.max(o, m.x + m.width), l = Math.max(l, m.y + m.height)))
+                }
+            });
+            for (var f = this.find("Shape"), h = !1, d = 0; d < f.length; d++) {
+                var g = f[d];
+                if (g._isVisible(this)) {
+                    h = !0;
+                    break
+                }
+            }
+            return h && s !== void 0 ? u = {
+                x: s,
+                y: a,
+                width: o - s,
+                height: l - a
+            } : u = {
+                x: 0,
+                y: 0,
+                width: 0,
+                height: 0
+            }, i ? u : this._transformedRect(u, r)
+        }
+    };
+    O.addComponentsGetterSetter(Mi, "clip", ["x", "y", "width", "height"]);
+    O.addGetterSetter(Mi, "clipX", void 0, se());
+    O.addGetterSetter(Mi, "clipY", void 0, se());
+    O.addGetterSetter(Mi, "clipWidth", void 0, se());
+    O.addGetterSetter(Mi, "clipHeight", void 0, se());
+    O.addGetterSetter(Mi, "clipFunc");
+    const wd = new Map,
+        E9 = pe._global.PointerEvent !== void 0;
+
+    function wb(e) {
+        return wd.get(e)
+    }
+
+    function BC(e) {
+        return {
+            evt: e,
+            pointerId: e.pointerId
+        }
+    }
+
+    function k9(e, t) {
+        return wd.get(e) === t
+    }
+
+    function C9(e, t) {
+        zh(e), t.getStage() && (wd.set(e, t), E9 && t._fire("gotpointercapture", BC(new PointerEvent("gotpointercapture"))))
+    }
+
+    function zh(e, t) {
+        const n = wd.get(e);
+        if (!n) return;
+        const i = n.getStage();
+        i && i.content, wd.delete(e), E9 && n._fire("lostpointercapture", BC(new PointerEvent("lostpointercapture")))
+    }
+    var Fbe = "Stage",
+        Rbe = "string",
+        J3 = "px",
+        Dbe = "mouseout",
+        A9 = "mouseleave",
+        $9 = "mouseover",
+        T9 = "mouseenter",
+        M9 = "mousemove",
+        O9 = "mousedown",
+        F9 = "mouseup",
+        yh = "pointermove",
+        vh = "pointerdown",
+        Gu = "pointerup",
+        bh = "pointercancel",
+        Nbe = "lostpointercapture",
+        up = "pointerout",
+        cp = "pointerleave",
+        fp = "pointerover",
+        hp = "pointerenter",
+        Xx = "contextmenu",
+        R9 = "touchstart",
+        D9 = "touchend",
+        N9 = "touchmove",
+        P9 = "touchcancel",
+        Vx = "wheel",
+        Pbe = 5,
+        Lbe = [
+            [T9, "_pointerenter"],
+            [O9, "_pointerdown"],
+            [M9, "_pointermove"],
+            [F9, "_pointerup"],
+            [A9, "_pointerleave"],
+            [R9, "_pointerdown"],
+            [N9, "_pointermove"],
+            [D9, "_pointerup"],
+            [P9, "_pointercancel"],
+            [$9, "_pointerover"],
+            [Vx, "_wheel"],
+            [Xx, "_contextmenu"],
+            [vh, "_pointerdown"],
+            [yh, "_pointermove"],
+            [Gu, "_pointerup"],
+            [bh, "_pointercancel"],
+            [Nbe, "_lostpointercapture"]
+        ];
+    const Sb = {
+            mouse: {
+                [up]: Dbe,
+                [cp]: A9,
+                [fp]: $9,
+                [hp]: T9,
+                [yh]: M9,
+                [vh]: O9,
+                [Gu]: F9,
+                [bh]: "mousecancel",
+                pointerclick: "click",
+                pointerdblclick: "dblclick"
+            },
+            touch: {
+                [up]: "touchout",
+                [cp]: "touchleave",
+                [fp]: "touchover",
+                [hp]: "touchenter",
+                [yh]: N9,
+                [vh]: R9,
+                [Gu]: D9,
+                [bh]: P9,
+                pointerclick: "tap",
+                pointerdblclick: "dbltap"
+            },
+            pointer: {
+                [up]: up,
+                [cp]: cp,
+                [fp]: fp,
+                [hp]: hp,
+                [yh]: yh,
+                [vh]: vh,
+                [Gu]: Gu,
+                [bh]: bh,
+                pointerclick: "pointerclick",
+                pointerdblclick: "pointerdblclick"
+            }
+        },
+        xh = e => e.indexOf("pointer") >= 0 ? "pointer" : e.indexOf("touch") >= 0 ? "touch" : "mouse",
+        Mu = e => {
+            const t = xh(e);
+            if (t === "pointer") return pe.pointerEventsEnabled && Sb.pointer;
+            if (t === "touch") return Sb.touch;
+            if (t === "mouse") return Sb.mouse
+        };
+
+    function Q3(e = {}) {
+        return (e.clipFunc || e.clipWidth || e.clipHeight) && D.warn("Stage does not support clipping. Please use clip for Layers or Groups."), e
+    }
+    const Ibe = "Pointer position is missing and not registered by the stage. Looks like it is outside of the stage container. You can set it manually from event: stage.setPointersPositions(event);",
+        Xp = [];
+    let Uy = class extends Mi {
+        constructor(t) {
+            super(Q3(t)), this._pointerPositions = [], this._changedPointerPositions = [], this._buildDOM(), this._bindContentEvents(), Xp.push(this), this.on("widthChange.konva heightChange.konva", this._resizeDOM), this.on("visibleChange.konva", this._checkVisibility), this.on("clipWidthChange.konva clipHeightChange.konva clipFuncChange.konva", () => {
+                Q3(this.attrs)
+            }), this._checkVisibility()
+        }
+        _validateAdd(t) {
+            const n = t.getType() === "Layer",
+                i = t.getType() === "FastLayer";
+            n || i || D.throw("You may only add layers to the stage.")
+        }
+        _checkVisibility() {
+            if (!this.content) return;
+            const t = this.visible() ? "" : "none";
+            this.content.style.display = t
+        }
+        setContainer(t) {
+            if (typeof t === Rbe) {
+                if (t.charAt(0) === ".") {
+                    var n = t.slice(1);
+                    t = document.getElementsByClassName(n)[0]
+                } else {
+                    var i;
+                    t.charAt(0) !== "#" ? i = t : i = t.slice(1), t = document.getElementById(i)
+                }
+                if (!t) throw "Can not find container in document with id " + i
+            }
+            return this._setAttr("container", t), this.content && (this.content.parentElement && this.content.parentElement.removeChild(this.content), t.appendChild(this.content)), this
+        }
+        shouldDrawHit() {
+            return !0
+        }
+        clear() {
+            var t = this.children,
+                n = t.length,
+                i;
+            for (i = 0; i < n; i++) t[i].clear();
+            return this
+        }
+        clone(t) {
+            return t || (t = {}), t.container = typeof document < "u" && document.createElement("div"), Mi.prototype.clone.call(this, t)
+        }
+        destroy() {
+            super.destroy();
+            var t = this.content;
+            t && D._isInDocument(t) && this.container().removeChild(t);
+            var n = Xp.indexOf(this);
+            return n > -1 && Xp.splice(n, 1), D.releaseCanvas(this.bufferCanvas._canvas, this.bufferHitCanvas._canvas), this
+        }
+        getPointerPosition() {
+            const t = this._pointerPositions[0] || this._changedPointerPositions[0];
+            return t ? {
+                x: t.x,
+                y: t.y
+            } : (D.warn(Ibe), null)
+        }
+        _getPointerById(t) {
+            return this._pointerPositions.find(n => n.id === t)
+        }
+        getPointersPositions() {
+            return this._pointerPositions
+        }
+        getStage() {
+            return this
+        }
+        getContent() {
+            return this.content
+        }
+        _toKonvaCanvas(t) {
+            t = t || {}, t.x = t.x || 0, t.y = t.y || 0, t.width = t.width || this.width(), t.height = t.height || this.height();
+            var n = new nc({
+                    width: t.width,
+                    height: t.height,
+                    pixelRatio: t.pixelRatio || 1
+                }),
+                i = n.getContext()._context,
+                r = this.children;
+            return (t.x || t.y) && i.translate(-1 * t.x, -1 * t.y), r.forEach(function(s) {
+                if (s.isVisible()) {
+                    var a = s._toKonvaCanvas(t);
+                    i.drawImage(a._canvas, t.x, t.y, a.getWidth() / a.getPixelRatio(), a.getHeight() / a.getPixelRatio())
+                }
+            }), n
+        }
+        getIntersection(t) {
+            if (!t) return null;
+            var n = this.children,
+                i = n.length,
+                r = i - 1,
+                s;
+            for (s = r; s >= 0; s--) {
+                const a = n[s].getIntersection(t);
+                if (a) return a
+            }
+            return null
+        }
+        _resizeDOM() {
+            var t = this.width(),
+                n = this.height();
+            this.content && (this.content.style.width = t + J3, this.content.style.height = n + J3), this.bufferCanvas.setSize(t, n), this.bufferHitCanvas.setSize(t, n), this.children.forEach(i => {
+                i.setSize({
+                    width: t,
+                    height: n
+                }), i.draw()
+            })
+        }
+        add(t, ...n) {
+            if (arguments.length > 1) {
+                for (var i = 0; i < arguments.length; i++) this.add(arguments[i]);
+                return this
+            }
+            super.add(t);
+            var r = this.children.length;
+            return r > Pbe && D.warn("The stage has " + r + " layers. Recommended maximum number of layers is 3-5. Adding more layers into the stage may drop the performance. Rethink your tree structure, you can use Konva.Group."), t.setSize({
+                width: this.width(),
+                height: this.height()
+            }), t.draw(), pe.isBrowser && this.content.appendChild(t.canvas._canvas), this
+        }
+        getParent() {
+            return null
+        }
+        getLayer() {
+            return null
+        }
+        hasPointerCapture(t) {
+            return k9(t, this)
+        }
+        setPointerCapture(t) {
+            C9(t, this)
+        }
+        releaseCapture(t) {
+            zh(t)
+        }
+        getLayers() {
+            return this.children
+        }
+        _bindContentEvents() {
+            pe.isBrowser && Lbe.forEach(([t, n]) => {
+                this.content.addEventListener(t, i => {
+                    this[n](i)
+                }, {
+                    passive: !1
+                })
+            })
+        }
+        _pointerenter(t) {
+            this.setPointersPositions(t);
+            const n = Mu(t.type);
+            this._fire(n.pointerenter, {
+                evt: t,
+                target: this,
+                currentTarget: this
+            })
+        }
+        _pointerover(t) {
+            this.setPointersPositions(t);
+            const n = Mu(t.type);
+            this._fire(n.pointerover, {
+                evt: t,
+                target: this,
+                currentTarget: this
+            })
+        }
+        _getTargetShape(t) {
+            let n = this[t + "targetShape"];
+            return n && !n.getStage() && (n = null), n
+        }
+        _pointerleave(t) {
+            const n = Mu(t.type),
+                i = xh(t.type);
+            if (n) {
+                this.setPointersPositions(t);
+                var r = this._getTargetShape(i),
+                    s = !Ke.isDragging || pe.hitOnDragEnabled;
+                r && s ? (r._fireAndBubble(n.pointerout, {
+                    evt: t
+                }), r._fireAndBubble(n.pointerleave, {
+                    evt: t
+                }), this._fire(n.pointerleave, {
+                    evt: t,
+                    target: this,
+                    currentTarget: this
+                }), this[i + "targetShape"] = null) : s && (this._fire(n.pointerleave, {
+                    evt: t,
+                    target: this,
+                    currentTarget: this
+                }), this._fire(n.pointerout, {
+                    evt: t,
+                    target: this,
+                    currentTarget: this
+                })), this.pointerPos = void 0, this._pointerPositions = []
+            }
+        }
+        _pointerdown(t) {
+            const n = Mu(t.type),
+                i = xh(t.type);
+            if (n) {
+                this.setPointersPositions(t);
+                var r = !1;
+                this._changedPointerPositions.forEach(s => {
+                    var a = this.getIntersection(s);
+                    if (Ke.justDragged = !1, pe["_" + i + "ListenClick"] = !0, !(a && a.isListening())) return;
+                    pe.capturePointerEventsEnabled && a.setPointerCapture(s.id), this[i + "ClickStartShape"] = a, a._fireAndBubble(n.pointerdown, {
+                        evt: t,
+                        pointerId: s.id
+                    }), r = !0;
+                    const l = t.type.indexOf("touch") >= 0;
+                    a.preventDefault() && t.cancelable && l && t.preventDefault()
+                }), r || this._fire(n.pointerdown, {
+                    evt: t,
+                    target: this,
+                    currentTarget: this,
+                    pointerId: this._pointerPositions[0].id
+                })
+            }
+        }
+        _pointermove(t) {
+            const n = Mu(t.type),
+                i = xh(t.type);
+            if (!n) return;
+            Ke.isDragging && Ke.node.preventDefault() && t.cancelable && t.preventDefault(), this.setPointersPositions(t);
+            var r = !Ke.isDragging || pe.hitOnDragEnabled;
+            if (!r) return;
+            var s = {};
+            let a = !1;
+            var o = this._getTargetShape(i);
+            this._changedPointerPositions.forEach(l => {
+                const u = wb(l.id) || this.getIntersection(l),
+                    c = l.id,
+                    f = {
+                        evt: t,
+                        pointerId: c
+                    };
+                var h = o !== u;
+                if (h && o && (o._fireAndBubble(n.pointerout, Object.assign({}, f), u), o._fireAndBubble(n.pointerleave, Object.assign({}, f), u)), u) {
+                    if (s[u._id]) return;
+                    s[u._id] = !0
+                }
+                u && u.isListening() ? (a = !0, h && (u._fireAndBubble(n.pointerover, Object.assign({}, f), o), u._fireAndBubble(n.pointerenter, Object.assign({}, f), o), this[i + "targetShape"] = u), u._fireAndBubble(n.pointermove, Object.assign({}, f))) : o && (this._fire(n.pointerover, {
+                    evt: t,
+                    target: this,
+                    currentTarget: this,
+                    pointerId: c
+                }), this[i + "targetShape"] = null)
+            }), a || this._fire(n.pointermove, {
+                evt: t,
+                target: this,
+                currentTarget: this,
+                pointerId: this._changedPointerPositions[0].id
+            })
+        }
+        _pointerup(t) {
+            const n = Mu(t.type),
+                i = xh(t.type);
+            if (!n) return;
+            this.setPointersPositions(t);
+            const r = this[i + "ClickStartShape"],
+                s = this[i + "ClickEndShape"];
+            var a = {};
+            let o = !1;
+            this._changedPointerPositions.forEach(l => {
+                const u = wb(l.id) || this.getIntersection(l);
+                if (u) {
+                    if (u.releaseCapture(l.id), a[u._id]) return;
+                    a[u._id] = !0
+                }
+                const c = l.id,
+                    f = {
+                        evt: t,
+                        pointerId: c
+                    };
+                let h = !1;
+                pe["_" + i + "InDblClickWindow"] ? (h = !0, clearTimeout(this[i + "DblTimeout"])) : Ke.justDragged || (pe["_" + i + "InDblClickWindow"] = !0, clearTimeout(this[i + "DblTimeout"])), this[i + "DblTimeout"] = setTimeout(function() {
+                    pe["_" + i + "InDblClickWindow"] = !1
+                }, pe.dblClickWindow), u && u.isListening() ? (o = !0, this[i + "ClickEndShape"] = u, u._fireAndBubble(n.pointerup, Object.assign({}, f)), pe["_" + i + "ListenClick"] && r && r === u && (u._fireAndBubble(n.pointerclick, Object.assign({}, f)), h && s && s === u && u._fireAndBubble(n.pointerdblclick, Object.assign({}, f)))) : (this[i + "ClickEndShape"] = null, pe["_" + i + "ListenClick"] && this._fire(n.pointerclick, {
+                    evt: t,
+                    target: this,
+                    currentTarget: this,
+                    pointerId: c
+                }), h && this._fire(n.pointerdblclick, {
+                    evt: t,
+                    target: this,
+                    currentTarget: this,
+                    pointerId: c
+                }))
+            }), o || this._fire(n.pointerup, {
+                evt: t,
+                target: this,
+                currentTarget: this,
+                pointerId: this._changedPointerPositions[0].id
+            }), pe["_" + i + "ListenClick"] = !1, t.cancelable && i !== "touch" && t.preventDefault()
+        }
+        _contextmenu(t) {
+            this.setPointersPositions(t);
+            var n = this.getIntersection(this.getPointerPosition());
+            n && n.isListening() ? n._fireAndBubble(Xx, {
+                evt: t
+            }) : this._fire(Xx, {
+                evt: t,
+                target: this,
+                currentTarget: this
+            })
+        }
+        _wheel(t) {
+            this.setPointersPositions(t);
+            var n = this.getIntersection(this.getPointerPosition());
+            n && n.isListening() ? n._fireAndBubble(Vx, {
+                evt: t
+            }) : this._fire(Vx, {
+                evt: t,
+                target: this,
+                currentTarget: this
+            })
+        }
+        _pointercancel(t) {
+            this.setPointersPositions(t);
+            const n = wb(t.pointerId) || this.getIntersection(this.getPointerPosition());
+            n && n._fireAndBubble(Gu, BC(t)), zh(t.pointerId)
+        }
+        _lostpointercapture(t) {
+            zh(t.pointerId)
+        }
+        setPointersPositions(t) {
+            var n = this._getContentPosition(),
+                i = null,
+                r = null;
+            t = t || window.event, t.touches !== void 0 ? (this._pointerPositions = [], this._changedPointerPositions = [], Array.prototype.forEach.call(t.touches, s => {
+                this._pointerPositions.push({
+                    id: s.identifier,
+                    x: (s.clientX - n.left) / n.scaleX,
+                    y: (s.clientY - n.top) / n.scaleY
+                })
+            }), Array.prototype.forEach.call(t.changedTouches || t.touches, s => {
+                this._changedPointerPositions.push({
+                    id: s.identifier,
+                    x: (s.clientX - n.left) / n.scaleX,
+                    y: (s.clientY - n.top) / n.scaleY
+                })
+            })) : (i = (t.clientX - n.left) / n.scaleX, r = (t.clientY - n.top) / n.scaleY, this.pointerPos = {
+                x: i,
+                y: r
+            }, this._pointerPositions = [{
+                x: i,
+                y: r,
+                id: D._getFirstPointerId(t)
+            }], this._changedPointerPositions = [{
+                x: i,
+                y: r,
+                id: D._getFirstPointerId(t)
+            }])
+        }
+        _setPointerPosition(t) {
+            D.warn('Method _setPointerPosition is deprecated. Use "stage.setPointersPositions(event)" instead.'), this.setPointersPositions(t)
+        }
+        _getContentPosition() {
+            if (!this.content || !this.content.getBoundingClientRect) return {
+                top: 0,
+                left: 0,
+                scaleX: 1,
+                scaleY: 1
+            };
+            var t = this.content.getBoundingClientRect();
+            return {
+                top: t.top,
+                left: t.left,
+                scaleX: t.width / this.content.clientWidth || 1,
+                scaleY: t.height / this.content.clientHeight || 1
+            }
+        }
+        _buildDOM() {
+            if (this.bufferCanvas = new nc({
+                    width: this.width(),
+                    height: this.height()
+                }), this.bufferHitCanvas = new zC({
+                    pixelRatio: 1,
+                    width: this.width(),
+                    height: this.height()
+                }), !!pe.isBrowser) {
+                var t = this.container();
+                if (!t) throw "Stage has no container. A container is required.";
+                t.innerHTML = "", this.content = document.createElement("div"), this.content.style.position = "relative", this.content.style.userSelect = "none", this.content.className = "konvajs-content", this.content.setAttribute("role", "presentation"), t.appendChild(this.content), this._resizeDOM()
+            }
+        }
+        cache() {
+            return D.warn("Cache function is not allowed for stage. You may use cache only for layers, groups and shapes."), this
+        }
+        clearCache() {
+            return this
+        }
+        batchDraw() {
+            return this.getChildren().forEach(function(t) {
+                t.batchDraw()
+            }), this
+        }
+    };
+    Uy.prototype.nodeType = Fbe;
+    Mt(Uy);
+    O.addGetterSetter(Uy, "container");
+    var L9 = "hasShadow",
+        I9 = "shadowRGBA",
+        z9 = "patternImage",
+        B9 = "linearGradient",
+        j9 = "radialGradient";
+    let dp;
+
+    function Eb() {
+        return dp || (dp = D.createCanvasElement().getContext("2d"), dp)
+    }
+    const Bh = {};
+
+    function zbe(e) {
+        e.fill()
+    }
+
+    function Bbe(e) {
+        e.stroke()
+    }
+
+    function jbe(e) {
+        e.fill()
+    }
+
+    function Gbe(e) {
+        e.stroke()
+    }
+
+    function Ube() {
+        this._clearCache(L9)
+    }
+
+    function Wbe() {
+        this._clearCache(I9)
+    }
+
+    function qbe() {
+        this._clearCache(z9)
+    }
+
+    function Hbe() {
+        this._clearCache(B9)
+    }
+
+    function Ybe() {
+        this._clearCache(j9)
+    }
+    class Q extends re {
+        constructor(t) {
+            super(t);
+            let n;
+            for (; n = D.getRandomColor(), !(n && !(n in Bh)););
+            this.colorKey = n, Bh[n] = this
+        }
+        getContext() {
+            return D.warn("shape.getContext() method is deprecated. Please do not use it."), this.getLayer().getContext()
+        }
+        getCanvas() {
+            return D.warn("shape.getCanvas() method is deprecated. Please do not use it."), this.getLayer().getCanvas()
+        }
+        getSceneFunc() {
+            return this.attrs.sceneFunc || this._sceneFunc
+        }
+        getHitFunc() {
+            return this.attrs.hitFunc || this._hitFunc
+        }
+        hasShadow() {
+            return this._getCache(L9, this._hasShadow)
+        }
+        _hasShadow() {
+            return this.shadowEnabled() && this.shadowOpacity() !== 0 && !!(this.shadowColor() || this.shadowBlur() || this.shadowOffsetX() || this.shadowOffsetY())
+        }
+        _getFillPattern() {
+            return this._getCache(z9, this.__getFillPattern)
+        }
+        __getFillPattern() {
+            if (this.fillPatternImage()) {
+                var t = Eb();
+                const n = t.createPattern(this.fillPatternImage(), this.fillPatternRepeat() || "repeat");
+                if (n && n.setTransform) {
+                    const i = new mr;
+                    i.translate(this.fillPatternX(), this.fillPatternY()), i.rotate(pe.getAngle(this.fillPatternRotation())), i.scale(this.fillPatternScaleX(), this.fillPatternScaleY()), i.translate(-1 * this.fillPatternOffsetX(), -1 * this.fillPatternOffsetY());
+                    const r = i.getMatrix(),
+                        s = typeof DOMMatrix > "u" ? {
+                            a: r[0],
+                            b: r[1],
+                            c: r[2],
+                            d: r[3],
+                            e: r[4],
+                            f: r[5]
+                        } : new DOMMatrix(r);
+                    n.setTransform(s)
+                }
+                return n
+            }
+        }
+        _getLinearGradient() {
+            return this._getCache(B9, this.__getLinearGradient)
+        }
+        __getLinearGradient() {
+            var t = this.fillLinearGradientColorStops();
+            if (t) {
+                for (var n = Eb(), i = this.fillLinearGradientStartPoint(), r = this.fillLinearGradientEndPoint(), s = n.createLinearGradient(i.x, i.y, r.x, r.y), a = 0; a < t.length; a += 2) s.addColorStop(t[a], t[a + 1]);
+                return s
+            }
+        }
+        _getRadialGradient() {
+            return this._getCache(j9, this.__getRadialGradient)
+        }
+        __getRadialGradient() {
+            var t = this.fillRadialGradientColorStops();
+            if (t) {
+                for (var n = Eb(), i = this.fillRadialGradientStartPoint(), r = this.fillRadialGradientEndPoint(), s = n.createRadialGradient(i.x, i.y, this.fillRadialGradientStartRadius(), r.x, r.y, this.fillRadialGradientEndRadius()), a = 0; a < t.length; a += 2) s.addColorStop(t[a], t[a + 1]);
+                return s
+            }
+        }
+        getShadowRGBA() {
+            return this._getCache(I9, this._getShadowRGBA)
+        }
+        _getShadowRGBA() {
+            if (this.hasShadow()) {
+                var t = D.colorToRGBA(this.shadowColor());
+                if (t) return "rgba(" + t.r + "," + t.g + "," + t.b + "," + t.a * (this.shadowOpacity() || 1) + ")"
+            }
+        }
+        hasFill() {
+            return this._calculate("hasFill", ["fillEnabled", "fill", "fillPatternImage", "fillLinearGradientColorStops", "fillRadialGradientColorStops"], () => this.fillEnabled() && !!(this.fill() || this.fillPatternImage() || this.fillLinearGradientColorStops() || this.fillRadialGradientColorStops()))
+        }
+        hasStroke() {
+            return this._calculate("hasStroke", ["strokeEnabled", "strokeWidth", "stroke", "strokeLinearGradientColorStops"], () => this.strokeEnabled() && this.strokeWidth() && !!(this.stroke() || this.strokeLinearGradientColorStops()))
+        }
+        hasHitStroke() {
+            const t = this.hitStrokeWidth();
+            return t === "auto" ? this.hasStroke() : this.strokeEnabled() && !!t
+        }
+        intersects(t) {
+            var n = this.getStage(),
+                i = n.bufferHitCanvas,
+                r;
+            return i.getContext().clear(), this.drawHit(i, null, !0), r = i.context.getImageData(Math.round(t.x), Math.round(t.y), 1, 1).data, r[3] > 0
+        }
+        destroy() {
+            return re.prototype.destroy.call(this), delete Bh[this.colorKey], delete this.colorKey, this
+        }
+        _useBufferCanvas(t) {
+            var n;
+            if (!this.getStage() || !((n = this.attrs.perfectDrawEnabled) !== null && n !== void 0 ? n : !0)) return !1;
+            const r = t || this.hasFill(),
+                s = this.hasStroke(),
+                a = this.getAbsoluteOpacity() !== 1;
+            if (r && s && a) return !0;
+            const o = this.hasShadow(),
+                l = this.shadowForStrokeEnabled();
+            return !!(r && s && o && l)
+        }
+        setStrokeHitEnabled(t) {
+            D.warn("strokeHitEnabled property is deprecated. Please use hitStrokeWidth instead."), t ? this.hitStrokeWidth("auto") : this.hitStrokeWidth(0)
+        }
+        getStrokeHitEnabled() {
+            return this.hitStrokeWidth() !== 0
+        }
+        getSelfRect() {
+            var t = this.size();
+            return {
+                x: this._centroid ? -t.width / 2 : 0,
+                y: this._centroid ? -t.height / 2 : 0,
+                width: t.width,
+                height: t.height
+            }
+        }
+        getClientRect(t = {}) {
+            const n = t.skipTransform,
+                i = t.relativeTo,
+                r = this.getSelfRect(),
+                a = !t.skipStroke && this.hasStroke() && this.strokeWidth() || 0,
+                o = r.width + a,
+                l = r.height + a,
+                u = !t.skipShadow && this.hasShadow(),
+                c = u ? this.shadowOffsetX() : 0,
+                f = u ? this.shadowOffsetY() : 0,
+                h = o + Math.abs(c),
+                d = l + Math.abs(f),
+                g = u && this.shadowBlur() || 0,
+                p = h + g * 2,
+                m = d + g * 2,
+                y = {
+                    width: p,
+                    height: m,
+                    x: -(a / 2 + g) + Math.min(c, 0) + r.x,
+                    y: -(a / 2 + g) + Math.min(f, 0) + r.y
+                };
+            return n ? y : this._transformedRect(y, i)
+        }
+        drawScene(t, n) {
+            var i = this.getLayer(),
+                r = t || i.getCanvas(),
+                s = r.getContext(),
+                a = this._getCanvasCache(),
+                o = this.getSceneFunc(),
+                l = this.hasShadow(),
+                u, c, f, h = r.isCache,
+                d = n === this;
+            if (!this.isVisible() && !d) return this;
+            if (a) {
+                s.save();
+                var g = this.getAbsoluteTransform(n).getMatrix();
+                return s.transform(g[0], g[1], g[2], g[3], g[4], g[5]), this._drawCachedSceneCanvas(s), s.restore(), this
+            }
+            if (!o) return this;
+            if (s.save(), this._useBufferCanvas() && !h) {
+                u = this.getStage(), c = u.bufferCanvas, f = c.getContext(), f.clear(), f.save(), f._applyLineJoin(this);
+                var p = this.getAbsoluteTransform(n).getMatrix();
+                f.transform(p[0], p[1], p[2], p[3], p[4], p[5]), o.call(this, f, this), f.restore();
+                var m = c.pixelRatio;
+                l && s._applyShadow(this), s._applyOpacity(this), s._applyGlobalCompositeOperation(this), s.drawImage(c._canvas, 0, 0, c.width / m, c.height / m)
+            } else {
+                if (s._applyLineJoin(this), !d) {
+                    var p = this.getAbsoluteTransform(n).getMatrix();
+                    s.transform(p[0], p[1], p[2], p[3], p[4], p[5]), s._applyOpacity(this), s._applyGlobalCompositeOperation(this)
+                }
+                l && s._applyShadow(this), o.call(this, s, this)
+            }
+            return s.restore(), this
+        }
+        drawHit(t, n, i = !1) {
+            if (!this.shouldDrawHit(n, i)) return this;
+            var r = this.getLayer(),
+                s = t || r.hitCanvas,
+                a = s && s.getContext(),
+                o = this.hitFunc() || this.sceneFunc(),
+                l = this._getCanvasCache(),
+                u = l && l.hit;
+            if (this.colorKey || D.warn("Looks like your canvas has a destroyed shape in it. Do not reuse shape after you destroyed it. If you want to reuse shape you should call remove() instead of destroy()"), u) {
+                a.save();
+                var c = this.getAbsoluteTransform(n).getMatrix();
+                return a.transform(c[0], c[1], c[2], c[3], c[4], c[5]), this._drawCachedHitCanvas(a), a.restore(), this
+            }
+            if (!o) return this;
+            if (a.save(), a._applyLineJoin(this), !(this === n)) {
+                var h = this.getAbsoluteTransform(n).getMatrix();
+                a.transform(h[0], h[1], h[2], h[3], h[4], h[5])
+            }
+            return o.call(this, a, this), a.restore(), this
+        }
+        drawHitFromCache(t = 0) {
+            var n = this._getCanvasCache(),
+                i = this._getCachedSceneCanvas(),
+                r = n.hit,
+                s = r.getContext(),
+                a = r.getWidth(),
+                o = r.getHeight(),
+                l, u, c, f, h, d;
+            s.clear(), s.drawImage(i._canvas, 0, 0, a, o);
+            try {
+                for (l = s.getImageData(0, 0, a, o), u = l.data, c = u.length, f = D._hexToRgb(this.colorKey), h = 0; h < c; h += 4) d = u[h + 3], d > t ? (u[h] = f.r, u[h + 1] = f.g, u[h + 2] = f.b, u[h + 3] = 255) : u[h + 3] = 0;
+                s.putImageData(l, 0, 0)
+            } catch (g) {
+                D.error("Unable to draw hit graph from cached scene canvas. " + g.message)
+            }
+            return this
+        }
+        hasPointerCapture(t) {
+            return k9(t, this)
+        }
+        setPointerCapture(t) {
+            C9(t, this)
+        }
+        releaseCapture(t) {
+            zh(t)
+        }
+    }
+    Q.prototype._fillFunc = zbe;
+    Q.prototype._strokeFunc = Bbe;
+    Q.prototype._fillFuncHit = jbe;
+    Q.prototype._strokeFuncHit = Gbe;
+    Q.prototype._centroid = !1;
+    Q.prototype.nodeType = "Shape";
+    Mt(Q);
+    Q.prototype.eventListeners = {};
+    Q.prototype.on.call(Q.prototype, "shadowColorChange.konva shadowBlurChange.konva shadowOffsetChange.konva shadowOpacityChange.konva shadowEnabledChange.konva", Ube);
+    Q.prototype.on.call(Q.prototype, "shadowColorChange.konva shadowOpacityChange.konva shadowEnabledChange.konva", Wbe);
+    Q.prototype.on.call(Q.prototype, "fillPriorityChange.konva fillPatternImageChange.konva fillPatternRepeatChange.konva fillPatternScaleXChange.konva fillPatternScaleYChange.konva fillPatternOffsetXChange.konva fillPatternOffsetYChange.konva fillPatternXChange.konva fillPatternYChange.konva fillPatternRotationChange.konva", qbe);
+    Q.prototype.on.call(Q.prototype, "fillPriorityChange.konva fillLinearGradientColorStopsChange.konva fillLinearGradientStartPointXChange.konva fillLinearGradientStartPointYChange.konva fillLinearGradientEndPointXChange.konva fillLinearGradientEndPointYChange.konva", Hbe);
+    Q.prototype.on.call(Q.prototype, "fillPriorityChange.konva fillRadialGradientColorStopsChange.konva fillRadialGradientStartPointXChange.konva fillRadialGradientStartPointYChange.konva fillRadialGradientEndPointXChange.konva fillRadialGradientEndPointYChange.konva fillRadialGradientStartRadiusChange.konva fillRadialGradientEndRadiusChange.konva", Ybe);
+    O.addGetterSetter(Q, "stroke", void 0, S9());
+    O.addGetterSetter(Q, "strokeWidth", 2, se());
+    O.addGetterSetter(Q, "fillAfterStrokeEnabled", !1);
+    O.addGetterSetter(Q, "hitStrokeWidth", "auto", IC());
+    O.addGetterSetter(Q, "strokeHitEnabled", !0, zr());
+    O.addGetterSetter(Q, "perfectDrawEnabled", !0, zr());
+    O.addGetterSetter(Q, "shadowForStrokeEnabled", !0, zr());
+    O.addGetterSetter(Q, "lineJoin");
+    O.addGetterSetter(Q, "lineCap");
+    O.addGetterSetter(Q, "sceneFunc");
+    O.addGetterSetter(Q, "hitFunc");
+    O.addGetterSetter(Q, "dash");
+    O.addGetterSetter(Q, "dashOffset", 0, se());
+    O.addGetterSetter(Q, "shadowColor", void 0, hf());
+    O.addGetterSetter(Q, "shadowBlur", 0, se());
+    O.addGetterSetter(Q, "shadowOpacity", 1, se());
+    O.addComponentsGetterSetter(Q, "shadowOffset", ["x", "y"]);
+    O.addGetterSetter(Q, "shadowOffsetX", 0, se());
+    O.addGetterSetter(Q, "shadowOffsetY", 0, se());
+    O.addGetterSetter(Q, "fillPatternImage");
+    O.addGetterSetter(Q, "fill", void 0, S9());
+    O.addGetterSetter(Q, "fillPatternX", 0, se());
+    O.addGetterSetter(Q, "fillPatternY", 0, se());
+    O.addGetterSetter(Q, "fillLinearGradientColorStops");
+    O.addGetterSetter(Q, "strokeLinearGradientColorStops");
+    O.addGetterSetter(Q, "fillRadialGradientStartRadius", 0);
+    O.addGetterSetter(Q, "fillRadialGradientEndRadius", 0);
+    O.addGetterSetter(Q, "fillRadialGradientColorStops");
+    O.addGetterSetter(Q, "fillPatternRepeat", "repeat");
+    O.addGetterSetter(Q, "fillEnabled", !0);
+    O.addGetterSetter(Q, "strokeEnabled", !0);
+    O.addGetterSetter(Q, "shadowEnabled", !0);
+    O.addGetterSetter(Q, "dashEnabled", !0);
+    O.addGetterSetter(Q, "strokeScaleEnabled", !0);
+    O.addGetterSetter(Q, "fillPriority", "color");
+    O.addComponentsGetterSetter(Q, "fillPatternOffset", ["x", "y"]);
+    O.addGetterSetter(Q, "fillPatternOffsetX", 0, se());
+    O.addGetterSetter(Q, "fillPatternOffsetY", 0, se());
+    O.addComponentsGetterSetter(Q, "fillPatternScale", ["x", "y"]);
+    O.addGetterSetter(Q, "fillPatternScaleX", 1, se());
+    O.addGetterSetter(Q, "fillPatternScaleY", 1, se());
+    O.addComponentsGetterSetter(Q, "fillLinearGradientStartPoint", ["x", "y"]);
+    O.addComponentsGetterSetter(Q, "strokeLinearGradientStartPoint", ["x", "y"]);
+    O.addGetterSetter(Q, "fillLinearGradientStartPointX", 0);
+    O.addGetterSetter(Q, "strokeLinearGradientStartPointX", 0);
+    O.addGetterSetter(Q, "fillLinearGradientStartPointY", 0);
+    O.addGetterSetter(Q, "strokeLinearGradientStartPointY", 0);
+    O.addComponentsGetterSetter(Q, "fillLinearGradientEndPoint", ["x", "y"]);
+    O.addComponentsGetterSetter(Q, "strokeLinearGradientEndPoint", ["x", "y"]);
+    O.addGetterSetter(Q, "fillLinearGradientEndPointX", 0);
+    O.addGetterSetter(Q, "strokeLinearGradientEndPointX", 0);
+    O.addGetterSetter(Q, "fillLinearGradientEndPointY", 0);
+    O.addGetterSetter(Q, "strokeLinearGradientEndPointY", 0);
+    O.addComponentsGetterSetter(Q, "fillRadialGradientStartPoint", ["x", "y"]);
+    O.addGetterSetter(Q, "fillRadialGradientStartPointX", 0);
+    O.addGetterSetter(Q, "fillRadialGradientStartPointY", 0);
+    O.addComponentsGetterSetter(Q, "fillRadialGradientEndPoint", ["x", "y"]);
+    O.addGetterSetter(Q, "fillRadialGradientEndPointX", 0);
+    O.addGetterSetter(Q, "fillRadialGradientEndPointY", 0);
+    O.addGetterSetter(Q, "fillPatternRotation", 0);
+    O.backCompat(Q, {
+        dashArray: "dash",
+        getDashArray: "getDash",
+        setDashArray: "getDash",
+        drawFunc: "sceneFunc",
+        getDrawFunc: "getSceneFunc",
+        setDrawFunc: "setSceneFunc",
+        drawHitFunc: "hitFunc",
+        getDrawHitFunc: "getHitFunc",
+        setDrawHitFunc: "setHitFunc"
+    });
+    var Xbe = "#",
+        Vbe = "beforeDraw",
+        Kbe = "draw",
+        G9 = [{
+            x: 0,
+            y: 0
+        }, {
+            x: -1,
+            y: -1
+        }, {
+            x: 1,
+            y: -1
+        }, {
+            x: 1,
+            y: 1
+        }, {
+            x: -1,
+            y: 1
+        }],
+        Jbe = G9.length;
+    let lu = class extends Mi {
+        constructor(t) {
+            super(t), this.canvas = new nc, this.hitCanvas = new zC({
+                pixelRatio: 1
+            }), this._waitingForDraw = !1, this.on("visibleChange.konva", this._checkVisibility), this._checkVisibility(), this.on("imageSmoothingEnabledChange.konva", this._setSmoothEnabled), this._setSmoothEnabled()
+        }
+        createPNGStream() {
+            return this.canvas._canvas.createPNGStream()
+        }
+        getCanvas() {
+            return this.canvas
+        }
+        getNativeCanvasElement() {
+            return this.canvas._canvas
+        }
+        getHitCanvas() {
+            return this.hitCanvas
+        }
+        getContext() {
+            return this.getCanvas().getContext()
+        }
+        clear(t) {
+            return this.getContext().clear(t), this.getHitCanvas().getContext().clear(t), this
+        }
+        setZIndex(t) {
+            super.setZIndex(t);
+            var n = this.getStage();
+            return n && n.content && (n.content.removeChild(this.getNativeCanvasElement()), t < n.children.length - 1 ? n.content.insertBefore(this.getNativeCanvasElement(), n.children[t + 1].getCanvas()._canvas) : n.content.appendChild(this.getNativeCanvasElement())), this
+        }
+        moveToTop() {
+            re.prototype.moveToTop.call(this);
+            var t = this.getStage();
+            return t && t.content && (t.content.removeChild(this.getNativeCanvasElement()), t.content.appendChild(this.getNativeCanvasElement())), !0
+        }
+        moveUp() {
+            var t = re.prototype.moveUp.call(this);
+            if (!t) return !1;
+            var n = this.getStage();
+            return !n || !n.content ? !1 : (n.content.removeChild(this.getNativeCanvasElement()), this.index < n.children.length - 1 ? n.content.insertBefore(this.getNativeCanvasElement(), n.children[this.index + 1].getCanvas()._canvas) : n.content.appendChild(this.getNativeCanvasElement()), !0)
+        }
+        moveDown() {
+            if (re.prototype.moveDown.call(this)) {
+                var t = this.getStage();
+                if (t) {
+                    var n = t.children;
+                    t.content && (t.content.removeChild(this.getNativeCanvasElement()), t.content.insertBefore(this.getNativeCanvasElement(), n[this.index + 1].getCanvas()._canvas))
+                }
+                return !0
+            }
+            return !1
+        }
+        moveToBottom() {
+            if (re.prototype.moveToBottom.call(this)) {
+                var t = this.getStage();
+                if (t) {
+                    var n = t.children;
+                    t.content && (t.content.removeChild(this.getNativeCanvasElement()), t.content.insertBefore(this.getNativeCanvasElement(), n[1].getCanvas()._canvas))
+                }
+                return !0
+            }
+            return !1
+        }
+        getLayer() {
+            return this
+        }
+        remove() {
+            var t = this.getNativeCanvasElement();
+            return re.prototype.remove.call(this), t && t.parentNode && D._isInDocument(t) && t.parentNode.removeChild(t), this
+        }
+        getStage() {
+            return this.parent
+        }
+        setSize({
+            width: t,
+            height: n
+        }) {
+            return this.canvas.setSize(t, n), this.hitCanvas.setSize(t, n), this._setSmoothEnabled(), this
+        }
+        _validateAdd(t) {
+            var n = t.getType();
+            n !== "Group" && n !== "Shape" && D.throw("You may only add groups and shapes to a layer.")
+        }
+        _toKonvaCanvas(t) {
+            return t = t || {}, t.width = t.width || this.getWidth(), t.height = t.height || this.getHeight(), t.x = t.x !== void 0 ? t.x : this.x(), t.y = t.y !== void 0 ? t.y : this.y(), re.prototype._toKonvaCanvas.call(this, t)
+        }
+        _checkVisibility() {
+            this.visible() ? this.canvas._canvas.style.display = "block" : this.canvas._canvas.style.display = "none"
+        }
+        _setSmoothEnabled() {
+            this.getContext()._context.imageSmoothingEnabled = this.imageSmoothingEnabled()
+        }
+        getWidth() {
+            if (this.parent) return this.parent.width()
+        }
+        setWidth() {
+            D.warn('Can not change width of layer. Use "stage.width(value)" function instead.')
+        }
+        getHeight() {
+            if (this.parent) return this.parent.height()
+        }
+        setHeight() {
+            D.warn('Can not change height of layer. Use "stage.height(value)" function instead.')
+        }
+        batchDraw() {
+            return this._waitingForDraw || (this._waitingForDraw = !0, D.requestAnimFrame(() => {
+                this.draw(), this._waitingForDraw = !1
+            })), this
+        }
+        getIntersection(t) {
+            if (!this.isListening() || !this.isVisible()) return null;
+            for (var n = 1, i = !1;;) {
+                for (let r = 0; r < Jbe; r++) {
+                    const s = G9[r],
+                        a = this._getIntersection({
+                            x: t.x + s.x * n,
+                            y: t.y + s.y * n
+                        }),
+                        o = a.shape;
+                    if (o) return o;
+                    if (i = !!a.antialiased, !a.antialiased) break
+                }
+                if (i) n += 1;
+                else return null
+            }
+        }
+        _getIntersection(t) {
+            const n = this.hitCanvas.pixelRatio,
+                i = this.hitCanvas.context.getImageData(Math.round(t.x * n), Math.round(t.y * n), 1, 1).data,
+                r = i[3];
+            if (r === 255) {
+                const s = D._rgbToHex(i[0], i[1], i[2]),
+                    a = Bh[Xbe + s];
+                return a ? {
+                    shape: a
+                } : {
+                    antialiased: !0
+                }
+            } else if (r > 0) return {
+                antialiased: !0
+            };
+            return {}
+        }
+        drawScene(t, n) {
+            var i = this.getLayer(),
+                r = t || i && i.getCanvas();
+            return this._fire(Vbe, {
+                node: this
+            }), this.clearBeforeDraw() && r.getContext().clear(), Mi.prototype.drawScene.call(this, r, n), this._fire(Kbe, {
+                node: this
+            }), this
+        }
+        drawHit(t, n) {
+            var i = this.getLayer(),
+                r = t || i && i.hitCanvas;
+            return i && i.clearBeforeDraw() && i.getHitCanvas().getContext().clear(), Mi.prototype.drawHit.call(this, r, n), this
+        }
+        enableHitGraph() {
+            return this.hitGraphEnabled(!0), this
+        }
+        disableHitGraph() {
+            return this.hitGraphEnabled(!1), this
+        }
+        setHitGraphEnabled(t) {
+            D.warn("hitGraphEnabled method is deprecated. Please use layer.listening() instead."), this.listening(t)
+        }
+        getHitGraphEnabled(t) {
+            return D.warn("hitGraphEnabled method is deprecated. Please use layer.listening() instead."), this.listening()
+        }
+        toggleHitCanvas() {
+            if (!(!this.parent || !this.parent.content)) {
+                var t = this.parent,
+                    n = !!this.hitCanvas._canvas.parentNode;
+                n ? t.content.removeChild(this.hitCanvas._canvas) : t.content.appendChild(this.hitCanvas._canvas)
+            }
+        }
+        destroy() {
+            return D.releaseCanvas(this.getNativeCanvasElement(), this.getHitCanvas()._canvas), super.destroy()
+        }
+    };
+    lu.prototype.nodeType = "Layer";
+    Mt(lu);
+    O.addGetterSetter(lu, "imageSmoothingEnabled", !0);
+    O.addGetterSetter(lu, "clearBeforeDraw", !0);
+    O.addGetterSetter(lu, "hitGraphEnabled", !0, zr());
+    class jC extends lu {
+        constructor(t) {
+            super(t), this.listening(!1), D.warn('Konva.Fast layer is deprecated. Please use "new Konva.Layer({ listening: false })" instead.')
+        }
+    }
+    jC.prototype.nodeType = "FastLayer";
+    Mt(jC);
+    let Ic = class extends Mi {
+        _validateAdd(t) {
+            var n = t.getType();
+            n !== "Group" && n !== "Shape" && D.throw("You may only add groups and shapes to groups.")
+        }
+    };
+    Ic.prototype.nodeType = "Group";
+    Mt(Ic);
+    var kb = function() {
+        return tc.performance && tc.performance.now ? function() {
+            return tc.performance.now()
+        } : function() {
+            return new Date().getTime()
+        }
+    }();
+    class zi {
+        constructor(t, n) {
+            this.id = zi.animIdCounter++, this.frame = {
+                time: 0,
+                timeDiff: 0,
+                lastTime: kb(),
+                frameRate: 0
+            }, this.func = t, this.setLayers(n)
+        }
+        setLayers(t) {
+            var n = [];
+            return t ? t.length > 0 ? n = t : n = [t] : n = [], this.layers = n, this
+        }
+        getLayers() {
+            return this.layers
+        }
+        addLayer(t) {
+            var n = this.layers,
+                i = n.length,
+                r;
+            for (r = 0; r < i; r++)
+                if (n[r]._id === t._id) return !1;
+            return this.layers.push(t), !0
+        }
+        isRunning() {
+            var t = zi,
+                n = t.animations,
+                i = n.length,
+                r;
+            for (r = 0; r < i; r++)
+                if (n[r].id === this.id) return !0;
+            return !1
+        }
+        start() {
+            return this.stop(), this.frame.timeDiff = 0, this.frame.lastTime = kb(), zi._addAnimation(this), this
+        }
+        stop() {
+            return zi._removeAnimation(this), this
+        }
+        _updateFrameObject(t) {
+            this.frame.timeDiff = t - this.frame.lastTime, this.frame.lastTime = t, this.frame.time += this.frame.timeDiff, this.frame.frameRate = 1e3 / this.frame.timeDiff
+        }
+        static _addAnimation(t) {
+            this.animations.push(t), this._handleAnimation()
+        }
+        static _removeAnimation(t) {
+            var n = t.id,
+                i = this.animations,
+                r = i.length,
+                s;
+            for (s = 0; s < r; s++)
+                if (i[s].id === n) {
+                    this.animations.splice(s, 1);
+                    break
+                }
+        }
+        static _runFrames() {
+            var t = {},
+                n = this.animations,
+                i, r, s, a, o, l, u, c, f;
+            for (a = 0; a < n.length; a++)
+                if (i = n[a], r = i.layers, s = i.func, i._updateFrameObject(kb()), l = r.length, s ? f = s.call(i, i.frame) !== !1 : f = !0, !!f)
+                    for (o = 0; o < l; o++) u = r[o], u._id !== void 0 && (t[u._id] = u);
+            for (c in t) t.hasOwnProperty(c) && t[c].batchDraw()
+        }
+        static _animationLoop() {
+            var t = zi;
+            t.animations.length ? (t._runFrames(), D.requestAnimFrame(t._animationLoop)) : t.animRunning = !1
+        }
+        static _handleAnimation() {
+            this.animRunning || (this.animRunning = !0, D.requestAnimFrame(this._animationLoop))
+        }
+    }
+    zi.animations = [];
+    zi.animIdCounter = 0;
+    zi.animRunning = !1;
+    var Qbe = {
+            node: 1,
+            duration: 1,
+            easing: 1,
+            onFinish: 1,
+            yoyo: 1
+        },
+        Zbe = 1,
+        Z3 = 2,
+        eO = 3,
+        e2e = 0,
+        tO = ["fill", "stroke", "shadowColor"];
+    class t2e {
+        constructor(t, n, i, r, s, a, o) {
+            this.prop = t, this.propFunc = n, this.begin = r, this._pos = r, this.duration = a, this._change = 0, this.prevPos = 0, this.yoyo = o, this._time = 0, this._position = 0, this._startTime = 0, this._finish = 0, this.func = i, this._change = s - this.begin, this.pause()
+        }
+        fire(t) {
+            var n = this[t];
+            n && n()
+        }
+        setTime(t) {
+            t > this.duration ? this.yoyo ? (this._time = this.duration, this.reverse()) : this.finish() : t < 0 ? this.yoyo ? (this._time = 0, this.play()) : this.reset() : (this._time = t, this.update())
+        }
+        getTime() {
+            return this._time
+        }
+        setPosition(t) {
+            this.prevPos = this._pos, this.propFunc(t), this._pos = t
+        }
+        getPosition(t) {
+            return t === void 0 && (t = this._time), this.func(t, this.begin, this._change, this.duration)
+        }
+        play() {
+            this.state = Z3, this._startTime = this.getTimer() - this._time, this.onEnterFrame(), this.fire("onPlay")
+        }
+        reverse() {
+            this.state = eO, this._time = this.duration - this._time, this._startTime = this.getTimer() - this._time, this.onEnterFrame(), this.fire("onReverse")
+        }
+        seek(t) {
+            this.pause(), this._time = t, this.update(), this.fire("onSeek")
+        }
+        reset() {
+            this.pause(), this._time = 0, this.update(), this.fire("onReset")
+        }
+        finish() {
+            this.pause(), this._time = this.duration, this.update(), this.fire("onFinish")
+        }
+        update() {
+            this.setPosition(this.getPosition(this._time)), this.fire("onUpdate")
+        }
+        onEnterFrame() {
+            var t = this.getTimer() - this._startTime;
+            this.state === Z3 ? this.setTime(t) : this.state === eO && this.setTime(this.duration - t)
+        }
+        pause() {
+            this.state = Zbe, this.fire("onPause")
+        }
+        getTimer() {
+            return new Date().getTime()
+        }
+    }
+    class zt {
+        constructor(t) {
+            var n = this,
+                i = t.node,
+                r = i._id,
+                s, a = t.easing || jh.Linear,
+                o = !!t.yoyo,
+                l;
+            typeof t.duration > "u" ? s = .3 : t.duration === 0 ? s = .001 : s = t.duration, this.node = i, this._id = e2e++;
+            var u = i.getLayer() || (i instanceof pe.Stage ? i.getLayers() : null);
+            u || D.error("Tween constructor have `node` that is not in a layer. Please add node into layer first."), this.anim = new zi(function() {
+                n.tween.onEnterFrame()
+            }, u), this.tween = new t2e(l, function(c) {
+                n._tweenFunc(c)
+            }, a, 0, 1, s * 1e3, o), this._addListeners(), zt.attrs[r] || (zt.attrs[r] = {}), zt.attrs[r][this._id] || (zt.attrs[r][this._id] = {}), zt.tweens[r] || (zt.tweens[r] = {});
+            for (l in t) Qbe[l] === void 0 && this._addAttr(l, t[l]);
+            this.reset(), this.onFinish = t.onFinish, this.onReset = t.onReset, this.onUpdate = t.onUpdate
+        }
+        _addAttr(t, n) {
+            var i = this.node,
+                r = i._id,
+                s, a, o, l, u, c, f, h;
+            if (o = zt.tweens[r][t], o && delete zt.attrs[r][o][t], s = i.getAttr(t), D._isArray(n))
+                if (a = [], u = Math.max(n.length, s.length), t === "points" && n.length !== s.length && (n.length > s.length ? (f = s, s = D._prepareArrayForTween(s, n, i.closed())) : (c = n, n = D._prepareArrayForTween(n, s, i.closed()))), t.indexOf("fill") === 0)
+                    for (l = 0; l < u; l++)
+                        if (l % 2 === 0) a.push(n[l] - s[l]);
+                        else {
+                            var d = D.colorToRGBA(s[l]);
+                            h = D.colorToRGBA(n[l]), s[l] = d, a.push({
+                                r: h.r - d.r,
+                                g: h.g - d.g,
+                                b: h.b - d.b,
+                                a: h.a - d.a
+                            })
+                        }
+            else
+                for (l = 0; l < u; l++) a.push(n[l] - s[l]);
+            else tO.indexOf(t) !== -1 ? (s = D.colorToRGBA(s), h = D.colorToRGBA(n), a = {
+                r: h.r - s.r,
+                g: h.g - s.g,
+                b: h.b - s.b,
+                a: h.a - s.a
+            }) : a = n - s;
+            zt.attrs[r][this._id][t] = {
+                start: s,
+                diff: a,
+                end: n,
+                trueEnd: c,
+                trueStart: f
+            }, zt.tweens[r][t] = this._id
+        }
+        _tweenFunc(t) {
+            var n = this.node,
+                i = zt.attrs[n._id][this._id],
+                r, s, a, o, l, u, c, f;
+            for (r in i) {
+                if (s = i[r], a = s.start, o = s.diff, f = s.end, D._isArray(a))
+                    if (l = [], c = Math.max(a.length, f.length), r.indexOf("fill") === 0)
+                        for (u = 0; u < c; u++) u % 2 === 0 ? l.push((a[u] || 0) + o[u] * t) : l.push("rgba(" + Math.round(a[u].r + o[u].r * t) + "," + Math.round(a[u].g + o[u].g * t) + "," + Math.round(a[u].b + o[u].b * t) + "," + (a[u].a + o[u].a * t) + ")");
+                    else
+                        for (u = 0; u < c; u++) l.push((a[u] || 0) + o[u] * t);
+                else tO.indexOf(r) !== -1 ? l = "rgba(" + Math.round(a.r + o.r * t) + "," + Math.round(a.g + o.g * t) + "," + Math.round(a.b + o.b * t) + "," + (a.a + o.a * t) + ")" : l = a + o * t;
+                n.setAttr(r, l)
+            }
+        }
+        _addListeners() {
+            this.tween.onPlay = () => {
+                this.anim.start()
+            }, this.tween.onReverse = () => {
+                this.anim.start()
+            }, this.tween.onPause = () => {
+                this.anim.stop()
+            }, this.tween.onFinish = () => {
+                var t = this.node,
+                    n = zt.attrs[t._id][this._id];
+                n.points && n.points.trueEnd && t.setAttr("points", n.points.trueEnd), this.onFinish && this.onFinish.call(this)
+            }, this.tween.onReset = () => {
+                var t = this.node,
+                    n = zt.attrs[t._id][this._id];
+                n.points && n.points.trueStart && t.points(n.points.trueStart), this.onReset && this.onReset()
+            }, this.tween.onUpdate = () => {
+                this.onUpdate && this.onUpdate.call(this)
+            }
+        }
+        play() {
+            return this.tween.play(), this
+        }
+        reverse() {
+            return this.tween.reverse(), this
+        }
+        reset() {
+            return this.tween.reset(), this
+        }
+        seek(t) {
+            return this.tween.seek(t * 1e3), this
+        }
+        pause() {
+            return this.tween.pause(), this
+        }
+        finish() {
+            return this.tween.finish(), this
+        }
+        destroy() {
+            var t = this.node._id,
+                n = this._id,
+                i = zt.tweens[t],
+                r;
+            this.pause();
+            for (r in i) delete zt.tweens[t][r];
+            delete zt.attrs[t][n]
+        }
+    }
+    zt.attrs = {};
+    zt.tweens = {};
+    re.prototype.to = function(e) {
+        var t = e.onFinish;
+        e.node = this, e.onFinish = function() {
+            this.destroy(), t && t()
+        };
+        var n = new zt(e);
+        n.play()
+    };
+    const jh = {
+            BackEaseIn(e, t, n, i) {
+                var r = 1.70158;
+                return n * (e /= i) * e * ((r + 1) * e - r) + t
+            },
+            BackEaseOut(e, t, n, i) {
+                var r = 1.70158;
+                return n * ((e = e / i - 1) * e * ((r + 1) * e + r) + 1) + t
+            },
+            BackEaseInOut(e, t, n, i) {
+                var r = 1.70158;
+                return (e /= i / 2) < 1 ? n / 2 * (e * e * (((r *= 1.525) + 1) * e - r)) + t : n / 2 * ((e -= 2) * e * (((r *= 1.525) + 1) * e + r) + 2) + t
             },
-            axisY: {
-                labelPadding: 10
+            ElasticEaseIn(e, t, n, i, r, s) {
+                var a = 0;
+                return e === 0 ? t : (e /= i) === 1 ? t + n : (s || (s = i * .3), !r || r < Math.abs(n) ? (r = n, a = s / 4) : a = s / (2 * Math.PI) * Math.asin(n / r), -(r * Math.pow(2, 10 * (e -= 1)) * Math.sin((e * i - a) * (2 * Math.PI) / s)) + t)
             },
-            bar: {
-                fill: Wi
+            ElasticEaseOut(e, t, n, i, r, s) {
+                var a = 0;
+                return e === 0 ? t : (e /= i) === 1 ? t + n : (s || (s = i * .3), !r || r < Math.abs(n) ? (r = n, a = s / 4) : a = s / (2 * Math.PI) * Math.asin(n / r), r * Math.pow(2, -10 * e) * Math.sin((e * i - a) * (2 * Math.PI) / s) + n + t)
             },
-            line: {
-                stroke: Wi,
-                strokeWidth: 3,
-                strokeCap: "round",
-                strokeJoin: "round"
+            ElasticEaseInOut(e, t, n, i, r, s) {
+                var a = 0;
+                return e === 0 ? t : (e /= i / 2) === 2 ? t + n : (s || (s = i * (.3 * 1.5)), !r || r < Math.abs(n) ? (r = n, a = s / 4) : a = s / (2 * Math.PI) * Math.asin(n / r), e < 1 ? -.5 * (r * Math.pow(2, 10 * (e -= 1)) * Math.sin((e * i - a) * (2 * Math.PI) / s)) + t : r * Math.pow(2, -10 * (e -= 1)) * Math.sin((e * i - a) * (2 * Math.PI) / s) * .5 + n + t)
             },
-            text: {
-                font: pf,
-                fontSize: L3,
-                fill: mf
+            BounceEaseOut(e, t, n, i) {
+                return (e /= i) < 1 / 2.75 ? n * (7.5625 * e * e) + t : e < 2 / 2.75 ? n * (7.5625 * (e -= 1.5 / 2.75) * e + .75) + t : e < 2.5 / 2.75 ? n * (7.5625 * (e -= 2.25 / 2.75) * e + .9375) + t : n * (7.5625 * (e -= 2.625 / 2.75) * e + .984375) + t
             },
-            arc: {
-                fill: Wi
+            BounceEaseIn(e, t, n, i) {
+                return n - jh.BounceEaseOut(i - e, 0, n, i) + t
             },
-            area: {
-                fill: Wi,
-                line: !0,
-                opacity: .6
+            BounceEaseInOut(e, t, n, i) {
+                return e < i / 2 ? jh.BounceEaseIn(e * 2, 0, n, i) * .5 + t : jh.BounceEaseOut(e * 2 - i, 0, n, i) * .5 + n * .5 + t
             },
-            path: {
-                stroke: Wi
+            EaseIn(e, t, n, i) {
+                return n * (e /= i) * e + t
             },
-            rect: {
-                fill: Wi
+            EaseOut(e, t, n, i) {
+                return -n * (e /= i) * (e - 2) + t
             },
-            point: {
-                fill: Wi,
-                filled: !0,
-                size: 75
+            EaseInOut(e, t, n, i) {
+                return (e /= i / 2) < 1 ? n / 2 * e * e + t : -n / 2 * (--e * (e - 2) - 1) + t
             },
-            shape: {
-                stroke: Wi
+            StrongEaseIn(e, t, n, i) {
+                return n * (e /= i) * e * e * e * e + t
             },
-            symbol: {
-                fill: Wi,
-                strokeWidth: 1.5,
-                size: 50
+            StrongEaseOut(e, t, n, i) {
+                return n * ((e = e / i - 1) * e * e * e * e + 1) + t
             },
-            legend: {
-                titleFont: pf,
-                titleFontWeight: "bold",
-                titleColor: mf,
-                labelFont: pf,
-                labelFontSize: I3,
-                labelColor: mf,
-                symbolType: "circle",
-                symbolSize: 75
+            StrongEaseInOut(e, t, n, i) {
+                return (e /= i / 2) < 1 ? n / 2 * e * e * e * e * e + t : n / 2 * ((e -= 2) * e * e * e * e + 2) + t
             },
-            range: {
-                category: [Wi, dye, gye, pye, mye, yye, vye, bye],
-                diverging: G3,
-                heatmap: G3,
-                ordinal: xye
+            Linear(e, t, n, i) {
+                return n * e / i + t
             }
         },
-        wye = Y1e.version,
-        Sye = Object.freeze(Object.defineProperty({
-            __proto__: null,
-            dark: X1e,
-            excel: V1e,
-            fivethirtyeight: Q1e,
-            ggplot2: Z1e,
-            googlecharts: fye,
-            latimes: iye,
-            powerbi: _ye,
-            quartz: rye,
-            urbaninstitute: cye,
-            version: wye,
-            vox: sye
-        }, Symbol.toStringTag, {
-            value: "Module"
-        }));
-
-    function qh(e) {
-        "@babel/helpers - typeof";
-        return qh = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
-            return typeof t
-        } : function(t) {
-            return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
-        }, qh(e)
-    }
-
-    function Eye(e, t) {
-        if (qh(e) !== "object" || e === null) return e;
-        var n = e[Symbol.toPrimitive];
-        if (n !== void 0) {
-            var i = n.call(e, t || "default");
-            if (qh(i) !== "object") return i;
-            throw new TypeError("@@toPrimitive must return a primitive value.")
+        nO = D._assign(pe, {
+            Util: D,
+            Transform: mr,
+            Node: re,
+            Container: Mi,
+            Stage: Uy,
+            stages: Xp,
+            Layer: lu,
+            FastLayer: jC,
+            Group: Ic,
+            DD: Ke,
+            Shape: Q,
+            shapes: Bh,
+            Animation: zi,
+            Tween: zt,
+            Easings: jh,
+            Context: jy,
+            Canvas: Gy
+        });
+    class pa extends Q {
+        _sceneFunc(t) {
+            var n = pe.getAngle(this.angle()),
+                i = this.clockwise();
+            t.beginPath(), t.arc(0, 0, this.outerRadius(), 0, n, i), t.arc(0, 0, this.innerRadius(), n, 0, !i), t.closePath(), t.fillStrokeShape(this)
+        }
+        getWidth() {
+            return this.outerRadius() * 2
+        }
+        getHeight() {
+            return this.outerRadius() * 2
+        }
+        setWidth(t) {
+            this.outerRadius(t / 2)
+        }
+        setHeight(t) {
+            this.outerRadius(t / 2)
+        }
+        getSelfRect() {
+            const t = this.innerRadius(),
+                n = this.outerRadius(),
+                i = this.clockwise(),
+                r = pe.getAngle(i ? 360 - this.angle() : this.angle()),
+                s = Math.cos(Math.min(r, Math.PI)),
+                a = 1,
+                o = Math.sin(Math.min(Math.max(Math.PI, r), 3 * Math.PI / 2)),
+                l = Math.sin(Math.min(r, Math.PI / 2)),
+                u = s * (s > 0 ? t : n),
+                c = a * n,
+                f = o * (o > 0 ? t : n),
+                h = l * (l > 0 ? n : t);
+            return {
+                x: u,
+                y: i ? -1 * h : f,
+                width: c - u,
+                height: h - f
+            }
         }
-        return (t === "string" ? String : Number)(e)
-    }
-
-    function Cye(e) {
-        var t = Eye(e, "string");
-        return qh(t) === "symbol" ? t : String(t)
     }
+    pa.prototype._centroid = !0;
+    pa.prototype.className = "Arc";
+    pa.prototype._attrsAffectingSize = ["innerRadius", "outerRadius"];
+    Mt(pa);
+    O.addGetterSetter(pa, "innerRadius", 0, se());
+    O.addGetterSetter(pa, "outerRadius", 0, se());
+    O.addGetterSetter(pa, "angle", 0, se());
+    O.addGetterSetter(pa, "clockwise", !1, zr());
 
-    function kye(e, t, n) {
-        return t = Cye(t), t in e ? Object.defineProperty(e, t, {
-            value: n,
-            enumerable: !0,
-            configurable: !0,
-            writable: !0
-        }) : e[t] = n, e
+    function Kx(e, t, n, i, r, s, a) {
+        var o = Math.sqrt(Math.pow(n - e, 2) + Math.pow(i - t, 2)),
+            l = Math.sqrt(Math.pow(r - n, 2) + Math.pow(s - i, 2)),
+            u = a * o / (o + l),
+            c = a * l / (o + l),
+            f = n - u * (r - e),
+            h = i - u * (s - t),
+            d = n + c * (r - e),
+            g = i + c * (s - t);
+        return [f, h, d, g]
     }
 
-    function Aye(e, t) {
-        if (e == null) return {};
-        var n = {},
-            i = Object.keys(e),
+    function iO(e, t) {
+        var n = e.length,
+            i = [],
             r, s;
-        for (s = 0; s < i.length; s++) r = i[s], !(t.indexOf(r) >= 0) && (n[r] = e[r]);
-        return n
+        for (r = 2; r < n - 2; r += 2) s = Kx(e[r - 2], e[r - 1], e[r], e[r + 1], e[r + 2], e[r + 3], t), !isNaN(s[0]) && (i.push(s[0]), i.push(s[1]), i.push(e[r]), i.push(e[r + 1]), i.push(s[2]), i.push(s[3]));
+        return i
     }
-
-    function $ye(e, t) {
-        if (e == null) return {};
-        var n = Aye(e, t),
-            i, r;
-        if (Object.getOwnPropertySymbols) {
-            var s = Object.getOwnPropertySymbols(e);
-            for (r = 0; r < s.length; r++) i = s[r], !(t.indexOf(i) >= 0) && Object.prototype.propertyIsEnumerable.call(e, i) && (n[i] = e[i])
+    class ma extends Q {
+        constructor(t) {
+            super(t), this.on("pointsChange.konva tensionChange.konva closedChange.konva bezierChange.konva", function() {
+                this._clearCache("tensionPoints")
+            })
+        }
+        _sceneFunc(t) {
+            var n = this.points(),
+                i = n.length,
+                r = this.tension(),
+                s = this.closed(),
+                a = this.bezier(),
+                o, l, u;
+            if (i) {
+                if (t.beginPath(), t.moveTo(n[0], n[1]), r !== 0 && i > 4) {
+                    for (o = this.getTensionPoints(), l = o.length, u = s ? 0 : 4, s || t.quadraticCurveTo(o[0], o[1], o[2], o[3]); u < l - 2;) t.bezierCurveTo(o[u++], o[u++], o[u++], o[u++], o[u++], o[u++]);
+                    s || t.quadraticCurveTo(o[l - 2], o[l - 1], n[i - 2], n[i - 1])
+                } else if (a)
+                    for (u = 2; u < i;) t.bezierCurveTo(n[u++], n[u++], n[u++], n[u++], n[u++], n[u++]);
+                else
+                    for (u = 2; u < i; u += 2) t.lineTo(n[u], n[u + 1]);
+                s ? (t.closePath(), t.fillStrokeShape(this)) : t.strokeShape(this)
+            }
+        }
+        getTensionPoints() {
+            return this._getCache("tensionPoints", this._getTensionPoints)
+        }
+        _getTensionPoints() {
+            return this.closed() ? this._getTensionPointsClosed() : iO(this.points(), this.tension())
+        }
+        _getTensionPointsClosed() {
+            var t = this.points(),
+                n = t.length,
+                i = this.tension(),
+                r = Kx(t[n - 2], t[n - 1], t[0], t[1], t[2], t[3], i),
+                s = Kx(t[n - 4], t[n - 3], t[n - 2], t[n - 1], t[0], t[1], i),
+                a = iO(t, i),
+                o = [r[2], r[3]].concat(a).concat([s[0], s[1], t[n - 2], t[n - 1], s[2], s[3], r[0], r[1], t[0], t[1]]);
+            return o
+        }
+        getWidth() {
+            return this.getSelfRect().width
+        }
+        getHeight() {
+            return this.getSelfRect().height
+        }
+        getSelfRect() {
+            var t = this.points();
+            if (t.length < 4) return {
+                x: t[0] || 0,
+                y: t[1] || 0,
+                width: 0,
+                height: 0
+            };
+            this.tension() !== 0 ? t = [t[0], t[1], ...this._getTensionPoints(), t[t.length - 2], t[t.length - 1]] : t = this.points();
+            for (var n = t[0], i = t[0], r = t[1], s = t[1], a, o, l = 0; l < t.length / 2; l++) a = t[l * 2], o = t[l * 2 + 1], n = Math.min(n, a), i = Math.max(i, a), r = Math.min(r, o), s = Math.max(s, o);
+            return {
+                x: n,
+                y: r,
+                width: i - n,
+                height: s - r
+            }
         }
-        return n
     }
-    const Tye = ["title", "image"];
-
-    function Mye(e, t, n) {
-        if (W(e)) return `[${e.map(i=>t(re(i)?i:W3(i,n))).join(", ")}]`;
-        if (ae(e)) {
-            let i = "";
-            const r = e,
-                {
-                    title: s,
-                    image: a
-                } = r,
-                o = $ye(r, Tye);
-            s && (i += `<h2>${t(s)}</h2>`), a && (i += `<img src="${t(a)}">`);
-            const l = Object.keys(o);
-            if (l.length > 0) {
-                i += "<table>";
-                for (const u of l) {
-                    let c = o[u];
-                    c !== void 0 && (ae(c) && (c = W3(c, n)), i += `<tr><td class="key">${t(u)}:</td><td class="value">${t(c)}</td></tr>`)
+    ma.prototype.className = "Line";
+    ma.prototype._attrsAffectingSize = ["points", "bezier", "tension"];
+    Mt(ma);
+    O.addGetterSetter(ma, "closed", !1);
+    O.addGetterSetter(ma, "bezier", !1);
+    O.addGetterSetter(ma, "tension", 0, se());
+    O.addGetterSetter(ma, "points", [], fbe());
+    class ct extends Q {
+        constructor(t) {
+            super(t), this.dataArray = [], this.pathLength = 0, this.dataArray = ct.parsePathData(this.data()), this.pathLength = 0;
+            for (var n = 0; n < this.dataArray.length; ++n) this.pathLength += this.dataArray[n].pathLength;
+            this.on("dataChange.konva", function() {
+                this.dataArray = ct.parsePathData(this.data()), this.pathLength = 0;
+                for (var i = 0; i < this.dataArray.length; ++i) this.pathLength += this.dataArray[i].pathLength
+            })
+        }
+        _sceneFunc(t) {
+            var n = this.dataArray;
+            t.beginPath();
+            for (var i = !1, r = 0; r < n.length; r++) {
+                var s = n[r].command,
+                    a = n[r].points;
+                switch (s) {
+                    case "L":
+                        t.lineTo(a[0], a[1]);
+                        break;
+                    case "M":
+                        t.moveTo(a[0], a[1]);
+                        break;
+                    case "C":
+                        t.bezierCurveTo(a[0], a[1], a[2], a[3], a[4], a[5]);
+                        break;
+                    case "Q":
+                        t.quadraticCurveTo(a[0], a[1], a[2], a[3]);
+                        break;
+                    case "A":
+                        var o = a[0],
+                            l = a[1],
+                            u = a[2],
+                            c = a[3],
+                            f = a[4],
+                            h = a[5],
+                            d = a[6],
+                            g = a[7],
+                            p = u > c ? u : c,
+                            m = u > c ? 1 : u / c,
+                            y = u > c ? c / u : 1;
+                        t.translate(o, l), t.rotate(d), t.scale(m, y), t.arc(0, 0, p, f, f + h, 1 - g), t.scale(1 / m, 1 / y), t.rotate(-d), t.translate(-o, -l);
+                        break;
+                    case "z":
+                        i = !0, t.closePath();
+                        break
                 }
-                i += "</table>"
+            }!i && !this.hasFill() ? t.strokeShape(this) : t.fillStrokeShape(this)
+        }
+        getSelfRect() {
+            var t = [];
+            this.dataArray.forEach(function(u) {
+                if (u.command === "A") {
+                    var c = u.points[4],
+                        f = u.points[5],
+                        h = u.points[4] + f,
+                        d = Math.PI / 180;
+                    if (Math.abs(c - h) < d && (d = Math.abs(c - h)), f < 0)
+                        for (let g = c - d; g > h; g -= d) {
+                            const p = ct.getPointOnEllipticalArc(u.points[0], u.points[1], u.points[2], u.points[3], g, 0);
+                            t.push(p.x, p.y)
+                        } else
+                            for (let g = c + d; g < h; g += d) {
+                                const p = ct.getPointOnEllipticalArc(u.points[0], u.points[1], u.points[2], u.points[3], g, 0);
+                                t.push(p.x, p.y)
+                            }
+                } else if (u.command === "C")
+                    for (let g = 0; g <= 1; g += .01) {
+                        const p = ct.getPointOnCubicBezier(g, u.start.x, u.start.y, u.points[0], u.points[1], u.points[2], u.points[3], u.points[4], u.points[5]);
+                        t.push(p.x, p.y)
+                    } else t = t.concat(u.points)
+            });
+            for (var n = t[0], i = t[0], r = t[1], s = t[1], a, o, l = 0; l < t.length / 2; l++) a = t[l * 2], o = t[l * 2 + 1], isNaN(a) || (n = Math.min(n, a), i = Math.max(i, a)), isNaN(o) || (r = Math.min(r, o), s = Math.max(s, o));
+            return {
+                x: n,
+                y: r,
+                width: i - n,
+                height: s - r
             }
-            return i || "{}"
         }
-        return t(e)
-    }
+        getLength() {
+            return this.pathLength
+        }
+        getPointAtLength(t) {
+            var n, i = 0,
+                r = this.dataArray.length;
+            if (!r) return null;
+            for (; i < r && t > this.dataArray[i].pathLength;) t -= this.dataArray[i].pathLength, ++i;
+            if (i === r) return n = this.dataArray[i - 1].points.slice(-2), {
+                x: n[0],
+                y: n[1]
+            };
+            if (t < .01) return n = this.dataArray[i].points.slice(0, 2), {
+                x: n[0],
+                y: n[1]
+            };
+            var s = this.dataArray[i],
+                a = s.points;
+            switch (s.command) {
+                case "L":
+                    return ct.getPointOnLine(t, s.start.x, s.start.y, a[0], a[1]);
+                case "C":
+                    return ct.getPointOnCubicBezier(t / s.pathLength, s.start.x, s.start.y, a[0], a[1], a[2], a[3], a[4], a[5]);
+                case "Q":
+                    return ct.getPointOnQuadraticBezier(t / s.pathLength, s.start.x, s.start.y, a[0], a[1], a[2], a[3]);
+                case "A":
+                    var o = a[0],
+                        l = a[1],
+                        u = a[2],
+                        c = a[3],
+                        f = a[4],
+                        h = a[5],
+                        d = a[6];
+                    return f += h * t / s.pathLength, ct.getPointOnEllipticalArc(o, l, u, c, f, d)
+            }
+            return null
+        }
+        static getLineLength(t, n, i, r) {
+            return Math.sqrt((i - t) * (i - t) + (r - n) * (r - n))
+        }
+        static getPointOnLine(t, n, i, r, s, a, o) {
+            a === void 0 && (a = n), o === void 0 && (o = i);
+            var l = (s - i) / (r - n + 1e-8),
+                u = Math.sqrt(t * t / (1 + l * l));
+            r < n && (u *= -1);
+            var c = l * u,
+                f;
+            if (r === n) f = {
+                x: a,
+                y: o + c
+            };
+            else if ((o - i) / (a - n + 1e-8) === l) f = {
+                x: a + u,
+                y: o + c
+            };
+            else {
+                var h, d, g = this.getLineLength(n, i, r, s),
+                    p = (a - n) * (r - n) + (o - i) * (s - i);
+                p = p / (g * g), h = n + p * (r - n), d = i + p * (s - i);
+                var m = this.getLineLength(a, o, h, d),
+                    y = Math.sqrt(t * t - m * m);
+                u = Math.sqrt(y * y / (1 + l * l)), r < n && (u *= -1), c = l * u, f = {
+                    x: h + u,
+                    y: d + c
+                }
+            }
+            return f
+        }
+        static getPointOnCubicBezier(t, n, i, r, s, a, o, l, u) {
+            function c(m) {
+                return m * m * m
+            }
 
-    function Oye(e) {
-        const t = [];
-        return function(n, i) {
-            if (typeof i != "object" || i === null) return i;
-            const r = t.indexOf(this) + 1;
-            return t.length = r, t.length > e ? "[Object]" : t.indexOf(i) >= 0 ? "[Circular]" : (t.push(i), i)
+            function f(m) {
+                return 3 * m * m * (1 - m)
+            }
+
+            function h(m) {
+                return 3 * m * (1 - m) * (1 - m)
+            }
+
+            function d(m) {
+                return (1 - m) * (1 - m) * (1 - m)
+            }
+            var g = l * c(t) + a * f(t) + r * h(t) + n * d(t),
+                p = u * c(t) + o * f(t) + s * h(t) + i * d(t);
+            return {
+                x: g,
+                y: p
+            }
         }
-    }
+        static getPointOnQuadraticBezier(t, n, i, r, s, a, o) {
+            function l(d) {
+                return d * d
+            }
 
-    function W3(e, t) {
-        return JSON.stringify(e, Oye(t))
-    }
-    var Fye = `#vg-tooltip-element {
-  visibility: hidden;
-  padding: 8px;
-  position: fixed;
-  z-index: 1000;
-  font-family: sans-serif;
-  font-size: 11px;
-  border-radius: 3px;
-  box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
-  /* The default theme is the light theme. */
-  background-color: rgba(255, 255, 255, 0.95);
-  border: 1px solid #d9d9d9;
-  color: black;
-}
-#vg-tooltip-element.visible {
-  visibility: visible;
-}
-#vg-tooltip-element h2 {
-  margin-top: 0;
-  margin-bottom: 10px;
-  font-size: 13px;
-}
-#vg-tooltip-element table {
-  border-spacing: 0;
-}
-#vg-tooltip-element table tr {
-  border: none;
-}
-#vg-tooltip-element table tr td {
-  overflow: hidden;
-  text-overflow: ellipsis;
-  padding-top: 2px;
-  padding-bottom: 2px;
-}
-#vg-tooltip-element table tr td.key {
-  color: #808080;
-  max-width: 150px;
-  text-align: right;
-  padding-right: 4px;
-}
-#vg-tooltip-element table tr td.value {
-  display: block;
-  max-width: 300px;
-  max-height: 7em;
-  text-align: left;
-}
-#vg-tooltip-element.dark-theme {
-  background-color: rgba(32, 32, 32, 0.9);
-  border: 1px solid #f5f5f5;
-  color: white;
-}
-#vg-tooltip-element.dark-theme td.key {
-  color: #bfbfbf;
-}
-`;
-    const M8 = "vg-tooltip-element",
-        Rye = {
-            offsetX: 10,
-            offsetY: 10,
-            id: M8,
-            styleId: "vega-tooltip-style",
-            theme: "light",
-            disableDefaultStyle: !1,
-            sanitize: Dye,
-            maxDepth: 2,
-            formatTooltip: Mye
-        };
+            function u(d) {
+                return 2 * d * (1 - d)
+            }
 
-    function Dye(e) {
-        return String(e).replace(/&/g, "&amp;").replace(/</g, "&lt;")
+            function c(d) {
+                return (1 - d) * (1 - d)
+            }
+            var f = a * l(t) + r * u(t) + n * c(t),
+                h = o * l(t) + s * u(t) + i * c(t);
+            return {
+                x: f,
+                y: h
+            }
+        }
+        static getPointOnEllipticalArc(t, n, i, r, s, a) {
+            var o = Math.cos(a),
+                l = Math.sin(a),
+                u = {
+                    x: i * Math.cos(s),
+                    y: r * Math.sin(s)
+                };
+            return {
+                x: t + (u.x * o - u.y * l),
+                y: n + (u.x * l + u.y * o)
+            }
+        }
+        static parsePathData(t) {
+            if (!t) return [];
+            var n = t,
+                i = ["m", "M", "l", "L", "v", "V", "h", "H", "z", "Z", "c", "C", "q", "Q", "t", "T", "s", "S", "a", "A"];
+            n = n.replace(new RegExp(" ", "g"), ",");
+            for (var r = 0; r < i.length; r++) n = n.replace(new RegExp(i[r], "g"), "|" + i[r]);
+            var s = n.split("|"),
+                a = [],
+                o = [],
+                l = 0,
+                u = 0,
+                c = /([-+]?((\d+\.\d+)|((\d+)|(\.\d+)))(?:e[-+]?\d+)?)/gi,
+                f;
+            for (r = 1; r < s.length; r++) {
+                var h = s[r],
+                    d = h.charAt(0);
+                for (h = h.slice(1), o.length = 0; f = c.exec(h);) o.push(f[0]);
+                for (var g = [], p = 0, m = o.length; p < m; p++) {
+                    if (o[p] === "00") {
+                        g.push(0, 0);
+                        continue
+                    }
+                    var y = parseFloat(o[p]);
+                    isNaN(y) ? g.push(0) : g.push(y)
+                }
+                for (; g.length > 0 && !isNaN(g[0]);) {
+                    var v = null,
+                        b = [],
+                        x = l,
+                        _ = u,
+                        S, w, E, C, k, A, F, $, T, M;
+                    switch (d) {
+                        case "l":
+                            l += g.shift(), u += g.shift(), v = "L", b.push(l, u);
+                            break;
+                        case "L":
+                            l = g.shift(), u = g.shift(), b.push(l, u);
+                            break;
+                        case "m":
+                            var R = g.shift(),
+                                N = g.shift();
+                            if (l += R, u += N, v = "M", a.length > 2 && a[a.length - 1].command === "z") {
+                                for (var L = a.length - 2; L >= 0; L--)
+                                    if (a[L].command === "M") {
+                                        l = a[L].points[0] + R, u = a[L].points[1] + N;
+                                        break
+                                    }
+                            }
+                            b.push(l, u), d = "l";
+                            break;
+                        case "M":
+                            l = g.shift(), u = g.shift(), v = "M", b.push(l, u), d = "L";
+                            break;
+                        case "h":
+                            l += g.shift(), v = "L", b.push(l, u);
+                            break;
+                        case "H":
+                            l = g.shift(), v = "L", b.push(l, u);
+                            break;
+                        case "v":
+                            u += g.shift(), v = "L", b.push(l, u);
+                            break;
+                        case "V":
+                            u = g.shift(), v = "L", b.push(l, u);
+                            break;
+                        case "C":
+                            b.push(g.shift(), g.shift(), g.shift(), g.shift()), l = g.shift(), u = g.shift(), b.push(l, u);
+                            break;
+                        case "c":
+                            b.push(l + g.shift(), u + g.shift(), l + g.shift(), u + g.shift()), l += g.shift(), u += g.shift(), v = "C", b.push(l, u);
+                            break;
+                        case "S":
+                            w = l, E = u, S = a[a.length - 1], S.command === "C" && (w = l + (l - S.points[2]), E = u + (u - S.points[3])), b.push(w, E, g.shift(), g.shift()), l = g.shift(), u = g.shift(), v = "C", b.push(l, u);
+                            break;
+                        case "s":
+                            w = l, E = u, S = a[a.length - 1], S.command === "C" && (w = l + (l - S.points[2]), E = u + (u - S.points[3])), b.push(w, E, l + g.shift(), u + g.shift()), l += g.shift(), u += g.shift(), v = "C", b.push(l, u);
+                            break;
+                        case "Q":
+                            b.push(g.shift(), g.shift()), l = g.shift(), u = g.shift(), b.push(l, u);
+                            break;
+                        case "q":
+                            b.push(l + g.shift(), u + g.shift()), l += g.shift(), u += g.shift(), v = "Q", b.push(l, u);
+                            break;
+                        case "T":
+                            w = l, E = u, S = a[a.length - 1], S.command === "Q" && (w = l + (l - S.points[0]), E = u + (u - S.points[1])), l = g.shift(), u = g.shift(), v = "Q", b.push(w, E, l, u);
+                            break;
+                        case "t":
+                            w = l, E = u, S = a[a.length - 1], S.command === "Q" && (w = l + (l - S.points[0]), E = u + (u - S.points[1])), l += g.shift(), u += g.shift(), v = "Q", b.push(w, E, l, u);
+                            break;
+                        case "A":
+                            C = g.shift(), k = g.shift(), A = g.shift(), F = g.shift(), $ = g.shift(), T = l, M = u, l = g.shift(), u = g.shift(), v = "A", b = this.convertEndpointToCenterParameterization(T, M, l, u, F, $, C, k, A);
+                            break;
+                        case "a":
+                            C = g.shift(), k = g.shift(), A = g.shift(), F = g.shift(), $ = g.shift(), T = l, M = u, l += g.shift(), u += g.shift(), v = "A", b = this.convertEndpointToCenterParameterization(T, M, l, u, F, $, C, k, A);
+                            break
+                    }
+                    a.push({
+                        command: v || d,
+                        points: b,
+                        start: {
+                            x,
+                            y: _
+                        },
+                        pathLength: this.calcLength(x, _, v || d, b)
+                    })
+                }(d === "z" || d === "Z") && a.push({
+                    command: "z",
+                    points: [],
+                    start: void 0,
+                    pathLength: 0
+                })
+            }
+            return a
+        }
+        static calcLength(t, n, i, r) {
+            var s, a, o, l, u = ct;
+            switch (i) {
+                case "L":
+                    return u.getLineLength(t, n, r[0], r[1]);
+                case "C":
+                    for (s = 0, a = u.getPointOnCubicBezier(0, t, n, r[0], r[1], r[2], r[3], r[4], r[5]), l = .01; l <= 1; l += .01) o = u.getPointOnCubicBezier(l, t, n, r[0], r[1], r[2], r[3], r[4], r[5]), s += u.getLineLength(a.x, a.y, o.x, o.y), a = o;
+                    return s;
+                case "Q":
+                    for (s = 0, a = u.getPointOnQuadraticBezier(0, t, n, r[0], r[1], r[2], r[3]), l = .01; l <= 1; l += .01) o = u.getPointOnQuadraticBezier(l, t, n, r[0], r[1], r[2], r[3]), s += u.getLineLength(a.x, a.y, o.x, o.y), a = o;
+                    return s;
+                case "A":
+                    s = 0;
+                    var c = r[4],
+                        f = r[5],
+                        h = r[4] + f,
+                        d = Math.PI / 180;
+                    if (Math.abs(c - h) < d && (d = Math.abs(c - h)), a = u.getPointOnEllipticalArc(r[0], r[1], r[2], r[3], c, 0), f < 0)
+                        for (l = c - d; l > h; l -= d) o = u.getPointOnEllipticalArc(r[0], r[1], r[2], r[3], l, 0), s += u.getLineLength(a.x, a.y, o.x, o.y), a = o;
+                    else
+                        for (l = c + d; l < h; l += d) o = u.getPointOnEllipticalArc(r[0], r[1], r[2], r[3], l, 0), s += u.getLineLength(a.x, a.y, o.x, o.y), a = o;
+                    return o = u.getPointOnEllipticalArc(r[0], r[1], r[2], r[3], h, 0), s += u.getLineLength(a.x, a.y, o.x, o.y), s
+            }
+            return 0
+        }
+        static convertEndpointToCenterParameterization(t, n, i, r, s, a, o, l, u) {
+            var c = u * (Math.PI / 180),
+                f = Math.cos(c) * (t - i) / 2 + Math.sin(c) * (n - r) / 2,
+                h = -1 * Math.sin(c) * (t - i) / 2 + Math.cos(c) * (n - r) / 2,
+                d = f * f / (o * o) + h * h / (l * l);
+            d > 1 && (o *= Math.sqrt(d), l *= Math.sqrt(d));
+            var g = Math.sqrt((o * o * (l * l) - o * o * (h * h) - l * l * (f * f)) / (o * o * (h * h) + l * l * (f * f)));
+            s === a && (g *= -1), isNaN(g) && (g = 0);
+            var p = g * o * h / l,
+                m = g * -l * f / o,
+                y = (t + i) / 2 + Math.cos(c) * p - Math.sin(c) * m,
+                v = (n + r) / 2 + Math.sin(c) * p + Math.cos(c) * m,
+                b = function(k) {
+                    return Math.sqrt(k[0] * k[0] + k[1] * k[1])
+                },
+                x = function(k, A) {
+                    return (k[0] * A[0] + k[1] * A[1]) / (b(k) * b(A))
+                },
+                _ = function(k, A) {
+                    return (k[0] * A[1] < k[1] * A[0] ? -1 : 1) * Math.acos(x(k, A))
+                },
+                S = _([1, 0], [(f - p) / o, (h - m) / l]),
+                w = [(f - p) / o, (h - m) / l],
+                E = [(-1 * f - p) / o, (-1 * h - m) / l],
+                C = _(w, E);
+            return x(w, E) <= -1 && (C = Math.PI), x(w, E) >= 1 && (C = 0), a === 0 && C > 0 && (C = C - 2 * Math.PI), a === 1 && C < 0 && (C = C + 2 * Math.PI), [y, v, o, l, S, C, c, a]
+        }
     }
-
-    function Nye(e) {
-        if (!/^[A-Za-z]+[-:.\w]*$/.test(e)) throw new Error("Invalid HTML ID");
-        return Fye.toString().replace(M8, e)
+    ct.prototype.className = "Path";
+    ct.prototype._attrsAffectingSize = ["data"];
+    Mt(ct);
+    O.addGetterSetter(ct, "data");
+    class uu extends ma {
+        _sceneFunc(t) {
+            super._sceneFunc(t);
+            var n = Math.PI * 2,
+                i = this.points(),
+                r = i,
+                s = this.tension() !== 0 && i.length > 4;
+            s && (r = this.getTensionPoints());
+            var a = this.pointerLength(),
+                o = i.length,
+                l, u;
+            if (s) {
+                const h = [r[r.length - 4], r[r.length - 3], r[r.length - 2], r[r.length - 1], i[o - 2], i[o - 1]],
+                    d = ct.calcLength(r[r.length - 4], r[r.length - 3], "C", h),
+                    g = ct.getPointOnQuadraticBezier(Math.min(1, 1 - a / d), h[0], h[1], h[2], h[3], h[4], h[5]);
+                l = i[o - 2] - g.x, u = i[o - 1] - g.y
+            } else l = i[o - 2] - i[o - 4], u = i[o - 1] - i[o - 3];
+            var c = (Math.atan2(u, l) + n) % n,
+                f = this.pointerWidth();
+            this.pointerAtEnding() && (t.save(), t.beginPath(), t.translate(i[o - 2], i[o - 1]), t.rotate(c), t.moveTo(0, 0), t.lineTo(-a, f / 2), t.lineTo(-a, -f / 2), t.closePath(), t.restore(), this.__fillStroke(t)), this.pointerAtBeginning() && (t.save(), t.beginPath(), t.translate(i[0], i[1]), s ? (l = (r[0] + r[2]) / 2 - i[0], u = (r[1] + r[3]) / 2 - i[1]) : (l = i[2] - i[0], u = i[3] - i[1]), t.rotate((Math.atan2(-u, -l) + n) % n), t.moveTo(0, 0), t.lineTo(-a, f / 2), t.lineTo(-a, -f / 2), t.closePath(), t.restore(), this.__fillStroke(t))
+        }
+        __fillStroke(t) {
+            var n = this.dashEnabled();
+            n && (this.attrs.dashEnabled = !1, t.setLineDash([])), t.fillStrokeShape(this), n && (this.attrs.dashEnabled = !0)
+        }
+        getSelfRect() {
+            const t = super.getSelfRect(),
+                n = this.pointerWidth() / 2;
+            return {
+                x: t.x - n,
+                y: t.y - n,
+                width: t.width + n * 2,
+                height: t.height + n * 2
+            }
+        }
     }
-
-    function Pye(e, t, n, i) {
-        let r = e.clientX + n;
-        r + t.width > window.innerWidth && (r = +e.clientX - n - t.width);
-        let s = e.clientY + i;
-        return s + t.height > window.innerHeight && (s = +e.clientY - i - t.height), {
-            x: r,
-            y: s
+    uu.prototype.className = "Arrow";
+    Mt(uu);
+    O.addGetterSetter(uu, "pointerLength", 10, se());
+    O.addGetterSetter(uu, "pointerWidth", 10, se());
+    O.addGetterSetter(uu, "pointerAtBeginning", !1);
+    O.addGetterSetter(uu, "pointerAtEnding", !0);
+    class df extends Q {
+        _sceneFunc(t) {
+            t.beginPath(), t.arc(0, 0, this.attrs.radius || 0, 0, Math.PI * 2, !1), t.closePath(), t.fillStrokeShape(this)
+        }
+        getWidth() {
+            return this.radius() * 2
+        }
+        getHeight() {
+            return this.radius() * 2
+        }
+        setWidth(t) {
+            this.radius() !== t / 2 && this.radius(t / 2)
+        }
+        setHeight(t) {
+            this.radius() !== t / 2 && this.radius(t / 2)
         }
     }
-
-    function q3(e, t) {
-        var n = Object.keys(e);
-        if (Object.getOwnPropertySymbols) {
-            var i = Object.getOwnPropertySymbols(e);
-            t && (i = i.filter(function(r) {
-                return Object.getOwnPropertyDescriptor(e, r).enumerable
-            })), n.push.apply(n, i)
+    df.prototype._centroid = !0;
+    df.prototype.className = "Circle";
+    df.prototype._attrsAffectingSize = ["radius"];
+    Mt(df);
+    O.addGetterSetter(df, "radius", 0, se());
+    class Fo extends Q {
+        _sceneFunc(t) {
+            var n = this.radiusX(),
+                i = this.radiusY();
+            t.beginPath(), t.save(), n !== i && t.scale(1, i / n), t.arc(0, 0, n, 0, Math.PI * 2, !1), t.restore(), t.closePath(), t.fillStrokeShape(this)
+        }
+        getWidth() {
+            return this.radiusX() * 2
+        }
+        getHeight() {
+            return this.radiusY() * 2
+        }
+        setWidth(t) {
+            this.radiusX(t / 2)
+        }
+        setHeight(t) {
+            this.radiusY(t / 2)
         }
-        return n
     }
-
-    function H3(e) {
-        for (var t = 1; t < arguments.length; t++) {
-            var n = arguments[t] != null ? arguments[t] : {};
-            t % 2 ? q3(Object(n), !0).forEach(function(i) {
-                kye(e, i, n[i])
-            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : q3(Object(n)).forEach(function(i) {
-                Object.defineProperty(e, i, Object.getOwnPropertyDescriptor(n, i))
+    Fo.prototype.className = "Ellipse";
+    Fo.prototype._centroid = !0;
+    Fo.prototype._attrsAffectingSize = ["radiusX", "radiusY"];
+    Mt(Fo);
+    O.addComponentsGetterSetter(Fo, "radius", ["x", "y"]);
+    O.addGetterSetter(Fo, "radiusX", 0, se());
+    O.addGetterSetter(Fo, "radiusY", 0, se());
+    let Cs = class U9 extends Q {
+        constructor(t) {
+            super(t), this.on("imageChange.konva", () => {
+                this._setImageLoad()
+            }), this._setImageLoad()
+        }
+        _setImageLoad() {
+            const t = this.image();
+            t && t.complete || t && t.readyState === 4 || t && t.addEventListener && t.addEventListener("load", () => {
+                this._requestDraw()
             })
         }
-        return e
-    }
-    class Lye {
+        _useBufferCanvas() {
+            return super._useBufferCanvas(!0)
+        }
+        _sceneFunc(t) {
+            const n = this.getWidth(),
+                i = this.getHeight(),
+                r = this.cornerRadius(),
+                s = this.attrs.image;
+            let a;
+            if (s) {
+                const o = this.attrs.cropWidth,
+                    l = this.attrs.cropHeight;
+                o && l ? a = [s, this.cropX(), this.cropY(), o, l, 0, 0, n, i] : a = [s, 0, 0, n, i]
+            }(this.hasFill() || this.hasStroke() || r) && (t.beginPath(), r ? D.drawRoundedRectPath(t, n, i, r) : t.rect(0, 0, n, i), t.closePath(), t.fillStrokeShape(this)), s && (r && t.clip(), t.drawImage.apply(t, a))
+        }
+        _hitFunc(t) {
+            var n = this.width(),
+                i = this.height(),
+                r = this.cornerRadius();
+            t.beginPath(), r ? D.drawRoundedRectPath(t, n, i, r) : t.rect(0, 0, n, i), t.closePath(), t.fillStrokeShape(this)
+        }
+        getWidth() {
+            var t, n;
+            return (t = this.attrs.width) !== null && t !== void 0 ? t : (n = this.image()) === null || n === void 0 ? void 0 : n.width
+        }
+        getHeight() {
+            var t, n;
+            return (t = this.attrs.height) !== null && t !== void 0 ? t : (n = this.image()) === null || n === void 0 ? void 0 : n.height
+        }
+        static fromURL(t, n, i = null) {
+            var r = D.createImageElement();
+            r.onload = function() {
+                var s = new U9({
+                    image: r
+                });
+                n(s)
+            }, r.onerror = i, r.crossOrigin = "Anonymous", r.src = t
+        }
+    };
+    Cs.prototype.className = "Image";
+    Mt(Cs);
+    O.addGetterSetter(Cs, "cornerRadius", 0, LC(4));
+    O.addGetterSetter(Cs, "image");
+    O.addComponentsGetterSetter(Cs, "crop", ["x", "y", "width", "height"]);
+    O.addGetterSetter(Cs, "cropX", 0, se());
+    O.addGetterSetter(Cs, "cropY", 0, se());
+    O.addGetterSetter(Cs, "cropWidth", 0, se());
+    O.addGetterSetter(Cs, "cropHeight", 0, se());
+    var W9 = ["fontFamily", "fontSize", "fontStyle", "padding", "lineHeight", "text", "width", "height", "pointerDirection", "pointerWidth", "pointerHeight"],
+        n2e = "Change.konva",
+        i2e = "none",
+        Jx = "up",
+        Qx = "right",
+        Zx = "down",
+        e_ = "left",
+        r2e = W9.length;
+    class GC extends Ic {
         constructor(t) {
-            this.options = H3(H3({}, Rye), t);
-            const n = this.options.id;
-            if (this.el = null, this.call = this.tooltipHandler.bind(this), !this.options.disableDefaultStyle && !document.getElementById(this.options.styleId)) {
-                const i = document.createElement("style");
-                i.setAttribute("id", this.options.styleId), i.innerHTML = Nye(n);
-                const r = document.head;
-                r.childNodes.length > 0 ? r.insertBefore(i, r.childNodes[0]) : r.appendChild(i)
-            }
+            super(t), this.on("add.konva", function(n) {
+                this._addListeners(n.child), this._sync()
+            })
         }
-        tooltipHandler(t, n, i, r) {
-            if (this.el = document.getElementById(this.options.id), this.el || (this.el = document.createElement("div"), this.el.setAttribute("id", this.options.id), this.el.classList.add("vg-tooltip"), (document.fullscreenElement ?? document.body).appendChild(this.el)), r == null || r === "") {
-                this.el.classList.remove("visible", `${this.options.theme}-theme`);
-                return
+        getText() {
+            return this.find("Text")[0]
+        }
+        getTag() {
+            return this.find("Tag")[0]
+        }
+        _addListeners(t) {
+            var n = this,
+                i, r = function() {
+                    n._sync()
+                };
+            for (i = 0; i < r2e; i++) t.on(W9[i] + n2e, r)
+        }
+        getWidth() {
+            return this.getText().width()
+        }
+        getHeight() {
+            return this.getText().height()
+        }
+        _sync() {
+            var t = this.getText(),
+                n = this.getTag(),
+                i, r, s, a, o, l, u;
+            if (t && n) {
+                switch (i = t.width(), r = t.height(), s = n.pointerDirection(), a = n.pointerWidth(), u = n.pointerHeight(), o = 0, l = 0, s) {
+                    case Jx:
+                        o = i / 2, l = -1 * u;
+                        break;
+                    case Qx:
+                        o = i + a, l = r / 2;
+                        break;
+                    case Zx:
+                        o = i / 2, l = r + u;
+                        break;
+                    case e_:
+                        o = -1 * a, l = r / 2;
+                        break
+                }
+                n.setAttrs({
+                    x: -1 * o,
+                    y: -1 * l,
+                    width: i,
+                    height: r
+                }), t.setAttrs({
+                    x: -1 * o,
+                    y: -1 * l
+                })
             }
-            this.el.innerHTML = this.options.formatTooltip(r, this.options.sanitize, this.options.maxDepth), this.el.classList.add("visible", `${this.options.theme}-theme`);
-            const {
-                x: s,
-                y: a
-            } = Pye(n, this.el.getBoundingClientRect(), this.options.offsetX, this.options.offsetY);
-            this.el.style.top = `${a}px`, this.el.style.left = `${s}px`
         }
     }
-
-    function Hh(e) {
-        "@babel/helpers - typeof";
-        return Hh = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
-            return typeof t
-        } : function(t) {
-            return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
-        }, Hh(e)
-    }
-
-    function Iye(e, t) {
-        if (Hh(e) !== "object" || e === null) return e;
-        var n = e[Symbol.toPrimitive];
-        if (n !== void 0) {
-            var i = n.call(e, t || "default");
-            if (Hh(i) !== "object") return i;
-            throw new TypeError("@@toPrimitive must return a primitive value.")
+    GC.prototype.className = "Label";
+    Mt(GC);
+    class cu extends Q {
+        _sceneFunc(t) {
+            var n = this.width(),
+                i = this.height(),
+                r = this.pointerDirection(),
+                s = this.pointerWidth(),
+                a = this.pointerHeight(),
+                o = this.cornerRadius();
+            let l = 0,
+                u = 0,
+                c = 0,
+                f = 0;
+            typeof o == "number" ? l = u = c = f = Math.min(o, n / 2, i / 2) : (l = Math.min(o[0] || 0, n / 2, i / 2), u = Math.min(o[1] || 0, n / 2, i / 2), f = Math.min(o[2] || 0, n / 2, i / 2), c = Math.min(o[3] || 0, n / 2, i / 2)), t.beginPath(), t.moveTo(l, 0), r === Jx && (t.lineTo((n - s) / 2, 0), t.lineTo(n / 2, -1 * a), t.lineTo((n + s) / 2, 0)), t.lineTo(n - u, 0), t.arc(n - u, u, u, Math.PI * 3 / 2, 0, !1), r === Qx && (t.lineTo(n, (i - a) / 2), t.lineTo(n + s, i / 2), t.lineTo(n, (i + a) / 2)), t.lineTo(n, i - f), t.arc(n - f, i - f, f, 0, Math.PI / 2, !1), r === Zx && (t.lineTo((n + s) / 2, i), t.lineTo(n / 2, i + a), t.lineTo((n - s) / 2, i)), t.lineTo(c, i), t.arc(c, i - c, c, Math.PI / 2, Math.PI, !1), r === e_ && (t.lineTo(0, (i + a) / 2), t.lineTo(-1 * s, i / 2), t.lineTo(0, (i - a) / 2)), t.lineTo(0, l), t.arc(l, l, l, Math.PI, Math.PI * 3 / 2, !1), t.closePath(), t.fillStrokeShape(this)
+        }
+        getSelfRect() {
+            var t = 0,
+                n = 0,
+                i = this.pointerWidth(),
+                r = this.pointerHeight(),
+                s = this.pointerDirection(),
+                a = this.width(),
+                o = this.height();
+            return s === Jx ? (n -= r, o += r) : s === Zx ? o += r : s === e_ ? (t -= i * 1.5, a += i) : s === Qx && (a += i * 1.5), {
+                x: t,
+                y: n,
+                width: a,
+                height: o
+            }
         }
-        return (t === "string" ? String : Number)(e)
     }
-
-    function zye(e) {
-        var t = Iye(e, "string");
-        return Hh(t) === "symbol" ? t : String(t)
+    cu.prototype.className = "Tag";
+    Mt(cu);
+    O.addGetterSetter(cu, "pointerDirection", i2e);
+    O.addGetterSetter(cu, "pointerWidth", 0, se());
+    O.addGetterSetter(cu, "pointerHeight", 0, se());
+    O.addGetterSetter(cu, "cornerRadius", 0, LC(4));
+    class mg extends Q {
+        _sceneFunc(t) {
+            var n = this.cornerRadius(),
+                i = this.width(),
+                r = this.height();
+            t.beginPath(), n ? D.drawRoundedRectPath(t, i, r, n) : t.rect(0, 0, i, r), t.closePath(), t.fillStrokeShape(this)
+        }
     }
-
-    function Bye(e, t, n) {
-        return t = zye(t), t in e ? Object.defineProperty(e, t, {
-            value: n,
-            enumerable: !0,
-            configurable: !0,
-            writable: !0
-        }) : e[t] = n, e
+    mg.prototype.className = "Rect";
+    Mt(mg);
+    O.addGetterSetter(mg, "cornerRadius", 0, LC(4));
+    class fu extends Q {
+        _sceneFunc(t) {
+            const n = this._getPoints();
+            t.beginPath(), t.moveTo(n[0].x, n[0].y);
+            for (var i = 1; i < n.length; i++) t.lineTo(n[i].x, n[i].y);
+            t.closePath(), t.fillStrokeShape(this)
+        }
+        _getPoints() {
+            const t = this.attrs.sides,
+                n = this.attrs.radius || 0,
+                i = [];
+            for (var r = 0; r < t; r++) i.push({
+                x: n * Math.sin(r * 2 * Math.PI / t),
+                y: -1 * n * Math.cos(r * 2 * Math.PI / t)
+            });
+            return i
+        }
+        getSelfRect() {
+            const t = this._getPoints();
+            var n = t[0].x,
+                i = t[0].y,
+                r = t[0].x,
+                s = t[0].y;
+            return t.forEach(a => {
+                n = Math.min(n, a.x), i = Math.max(i, a.x), r = Math.min(r, a.y), s = Math.max(s, a.y)
+            }), {
+                x: n,
+                y: r,
+                width: i - n,
+                height: s - r
+            }
+        }
+        getWidth() {
+            return this.radius() * 2
+        }
+        getHeight() {
+            return this.radius() * 2
+        }
+        setWidth(t) {
+            this.radius(t / 2)
+        }
+        setHeight(t) {
+            this.radius(t / 2)
+        }
     }
-
-    function jye(e) {
-        return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e
+    fu.prototype.className = "RegularPolygon";
+    fu.prototype._centroid = !0;
+    fu.prototype._attrsAffectingSize = ["radius"];
+    Mt(fu);
+    O.addGetterSetter(fu, "radius", 0, se());
+    O.addGetterSetter(fu, "sides", 0, se());
+    var rO = Math.PI * 2;
+    class hu extends Q {
+        _sceneFunc(t) {
+            t.beginPath(), t.arc(0, 0, this.innerRadius(), 0, rO, !1), t.moveTo(this.outerRadius(), 0), t.arc(0, 0, this.outerRadius(), rO, 0, !0), t.closePath(), t.fillStrokeShape(this)
+        }
+        getWidth() {
+            return this.outerRadius() * 2
+        }
+        getHeight() {
+            return this.outerRadius() * 2
+        }
+        setWidth(t) {
+            this.outerRadius(t / 2)
+        }
+        setHeight(t) {
+            this.outerRadius(t / 2)
+        }
     }
-    var Iv, Y3;
-
-    function Uye() {
-        return Y3 || (Y3 = 1, Iv = function(e) {
-            e.prototype[Symbol.iterator] = function*() {
-                for (let t = this.head; t; t = t.next) yield t.value
+    hu.prototype.className = "Ring";
+    hu.prototype._centroid = !0;
+    hu.prototype._attrsAffectingSize = ["innerRadius", "outerRadius"];
+    Mt(hu);
+    O.addGetterSetter(hu, "innerRadius", 0, se());
+    O.addGetterSetter(hu, "outerRadius", 0, se());
+    class As extends Q {
+        constructor(t) {
+            super(t), this._updated = !0, this.anim = new zi(() => {
+                var n = this._updated;
+                return this._updated = !1, n
+            }), this.on("animationChange.konva", function() {
+                this.frameIndex(0)
+            }), this.on("frameIndexChange.konva", function() {
+                this._updated = !0
+            }), this.on("frameRateChange.konva", function() {
+                this.anim.isRunning() && (clearInterval(this.interval), this._setInterval())
+            })
+        }
+        _sceneFunc(t) {
+            var n = this.animation(),
+                i = this.frameIndex(),
+                r = i * 4,
+                s = this.animations()[n],
+                a = this.frameOffsets(),
+                o = s[r + 0],
+                l = s[r + 1],
+                u = s[r + 2],
+                c = s[r + 3],
+                f = this.image();
+            if ((this.hasFill() || this.hasStroke()) && (t.beginPath(), t.rect(0, 0, u, c), t.closePath(), t.fillStrokeShape(this)), f)
+                if (a) {
+                    var h = a[n],
+                        d = i * 2;
+                    t.drawImage(f, o, l, u, c, h[d + 0], h[d + 1], u, c)
+                } else t.drawImage(f, o, l, u, c, 0, 0, u, c)
+        }
+        _hitFunc(t) {
+            var n = this.animation(),
+                i = this.frameIndex(),
+                r = i * 4,
+                s = this.animations()[n],
+                a = this.frameOffsets(),
+                o = s[r + 2],
+                l = s[r + 3];
+            if (t.beginPath(), a) {
+                var u = a[n],
+                    c = i * 2;
+                t.rect(u[c + 0], u[c + 1], o, l)
+            } else t.rect(0, 0, o, l);
+            t.closePath(), t.fillShape(this)
+        }
+        _useBufferCanvas() {
+            return super._useBufferCanvas(!0)
+        }
+        _setInterval() {
+            var t = this;
+            this.interval = setInterval(function() {
+                t._updateIndex()
+            }, 1e3 / this.frameRate())
+        }
+        start() {
+            if (!this.isRunning()) {
+                var t = this.getLayer();
+                this.anim.setLayers(t), this._setInterval(), this.anim.start()
             }
-        }), Iv
-    }
-    var Gye = qe;
-    qe.Node = vl;
-    qe.create = qe;
-
-    function qe(e) {
-        var t = this;
-        if (t instanceof qe || (t = new qe), t.tail = null, t.head = null, t.length = 0, e && typeof e.forEach == "function") e.forEach(function(r) {
-            t.push(r)
-        });
-        else if (arguments.length > 0)
-            for (var n = 0, i = arguments.length; n < i; n++) t.push(arguments[n]);
-        return t
+        }
+        stop() {
+            this.anim.stop(), clearInterval(this.interval)
+        }
+        isRunning() {
+            return this.anim.isRunning()
+        }
+        _updateIndex() {
+            var t = this.frameIndex(),
+                n = this.animation(),
+                i = this.animations(),
+                r = i[n],
+                s = r.length / 4;
+            t < s - 1 ? this.frameIndex(t + 1) : this.frameIndex(0)
+        }
     }
-    qe.prototype.removeNode = function(e) {
-        if (e.list !== this) throw new Error("removing node which does not belong to this list");
-        var t = e.next,
-            n = e.prev;
-        return t && (t.prev = n), n && (n.next = t), e === this.head && (this.head = t), e === this.tail && (this.tail = n), e.list.length--, e.next = null, e.prev = null, e.list = null, t
-    };
-    qe.prototype.unshiftNode = function(e) {
-        if (e !== this.head) {
-            e.list && e.list.removeNode(e);
-            var t = this.head;
-            e.list = this, e.next = t, t && (t.prev = e), this.head = e, this.tail || (this.tail = e), this.length++
+    As.prototype.className = "Sprite";
+    Mt(As);
+    O.addGetterSetter(As, "animation");
+    O.addGetterSetter(As, "animations");
+    O.addGetterSetter(As, "frameOffsets");
+    O.addGetterSetter(As, "image");
+    O.addGetterSetter(As, "frameIndex", 0, se());
+    O.addGetterSetter(As, "frameRate", 17, se());
+    O.backCompat(As, {
+        index: "frameIndex",
+        getIndex: "getFrameIndex",
+        setIndex: "setFrameIndex"
+    });
+    class Ro extends Q {
+        _sceneFunc(t) {
+            var n = this.innerRadius(),
+                i = this.outerRadius(),
+                r = this.numPoints();
+            t.beginPath(), t.moveTo(0, 0 - i);
+            for (var s = 1; s < r * 2; s++) {
+                var a = s % 2 === 0 ? i : n,
+                    o = a * Math.sin(s * Math.PI / r),
+                    l = -1 * a * Math.cos(s * Math.PI / r);
+                t.lineTo(o, l)
+            }
+            t.closePath(), t.fillStrokeShape(this)
         }
-    };
-    qe.prototype.pushNode = function(e) {
-        if (e !== this.tail) {
-            e.list && e.list.removeNode(e);
-            var t = this.tail;
-            e.list = this, e.prev = t, t && (t.next = e), this.tail = e, this.head || (this.head = e), this.length++
+        getWidth() {
+            return this.outerRadius() * 2
         }
-    };
-    qe.prototype.push = function() {
-        for (var e = 0, t = arguments.length; e < t; e++) qye(this, arguments[e]);
-        return this.length
-    };
-    qe.prototype.unshift = function() {
-        for (var e = 0, t = arguments.length; e < t; e++) Hye(this, arguments[e]);
-        return this.length
-    };
-    qe.prototype.pop = function() {
-        if (this.tail) {
-            var e = this.tail.value;
-            return this.tail = this.tail.prev, this.tail ? this.tail.next = null : this.head = null, this.length--, e
+        getHeight() {
+            return this.outerRadius() * 2
         }
-    };
-    qe.prototype.shift = function() {
-        if (this.head) {
-            var e = this.head.value;
-            return this.head = this.head.next, this.head ? this.head.prev = null : this.tail = null, this.length--, e
+        setWidth(t) {
+            this.outerRadius(t / 2)
         }
-    };
-    qe.prototype.forEach = function(e, t) {
-        t = t || this;
-        for (var n = this.head, i = 0; n !== null; i++) e.call(t, n.value, i, this), n = n.next
-    };
-    qe.prototype.forEachReverse = function(e, t) {
-        t = t || this;
-        for (var n = this.tail, i = this.length - 1; n !== null; i--) e.call(t, n.value, i, this), n = n.prev
-    };
-    qe.prototype.get = function(e) {
-        for (var t = 0, n = this.head; n !== null && t < e; t++) n = n.next;
-        if (t === e && n !== null) return n.value
-    };
-    qe.prototype.getReverse = function(e) {
-        for (var t = 0, n = this.tail; n !== null && t < e; t++) n = n.prev;
-        if (t === e && n !== null) return n.value
-    };
-    qe.prototype.map = function(e, t) {
-        t = t || this;
-        for (var n = new qe, i = this.head; i !== null;) n.push(e.call(t, i.value, this)), i = i.next;
-        return n
-    };
-    qe.prototype.mapReverse = function(e, t) {
-        t = t || this;
-        for (var n = new qe, i = this.tail; i !== null;) n.push(e.call(t, i.value, this)), i = i.prev;
-        return n
-    };
-    qe.prototype.reduce = function(e, t) {
-        var n, i = this.head;
-        if (arguments.length > 1) n = t;
-        else if (this.head) i = this.head.next, n = this.head.value;
-        else throw new TypeError("Reduce of empty list with no initial value");
-        for (var r = 0; i !== null; r++) n = e(n, i.value, r), i = i.next;
-        return n
-    };
-    qe.prototype.reduceReverse = function(e, t) {
-        var n, i = this.tail;
-        if (arguments.length > 1) n = t;
-        else if (this.tail) i = this.tail.prev, n = this.tail.value;
-        else throw new TypeError("Reduce of empty list with no initial value");
-        for (var r = this.length - 1; i !== null; r--) n = e(n, i.value, r), i = i.prev;
-        return n
-    };
-    qe.prototype.toArray = function() {
-        for (var e = new Array(this.length), t = 0, n = this.head; n !== null; t++) e[t] = n.value, n = n.next;
-        return e
-    };
-    qe.prototype.toArrayReverse = function() {
-        for (var e = new Array(this.length), t = 0, n = this.tail; n !== null; t++) e[t] = n.value, n = n.prev;
-        return e
-    };
-    qe.prototype.slice = function(e, t) {
-        t = t || this.length, t < 0 && (t += this.length), e = e || 0, e < 0 && (e += this.length);
-        var n = new qe;
-        if (t < e || t < 0) return n;
-        e < 0 && (e = 0), t > this.length && (t = this.length);
-        for (var i = 0, r = this.head; r !== null && i < e; i++) r = r.next;
-        for (; r !== null && i < t; i++, r = r.next) n.push(r.value);
-        return n
-    };
-    qe.prototype.sliceReverse = function(e, t) {
-        t = t || this.length, t < 0 && (t += this.length), e = e || 0, e < 0 && (e += this.length);
-        var n = new qe;
-        if (t < e || t < 0) return n;
-        e < 0 && (e = 0), t > this.length && (t = this.length);
-        for (var i = this.length, r = this.tail; r !== null && i > t; i--) r = r.prev;
-        for (; r !== null && i > e; i--, r = r.prev) n.push(r.value);
-        return n
-    };
-    qe.prototype.splice = function(e, t, ...n) {
-        e > this.length && (e = this.length - 1), e < 0 && (e = this.length + e);
-        for (var i = 0, r = this.head; r !== null && i < e; i++) r = r.next;
-        for (var s = [], i = 0; r && i < t; i++) s.push(r.value), r = this.removeNode(r);
-        r === null && (r = this.tail), r !== this.head && r !== this.tail && (r = r.prev);
-        for (var i = 0; i < n.length; i++) r = Wye(this, r, n[i]);
-        return s
-    };
-    qe.prototype.reverse = function() {
-        for (var e = this.head, t = this.tail, n = e; n !== null; n = n.prev) {
-            var i = n.prev;
-            n.prev = n.next, n.next = i
+        setHeight(t) {
+            this.outerRadius(t / 2)
         }
-        return this.head = t, this.tail = e, this
-    };
+    }
+    Ro.prototype.className = "Star";
+    Ro.prototype._centroid = !0;
+    Ro.prototype._attrsAffectingSize = ["innerRadius", "outerRadius"];
+    Mt(Ro);
+    O.addGetterSetter(Ro, "numPoints", 5, se());
+    O.addGetterSetter(Ro, "innerRadius", 0, se());
+    O.addGetterSetter(Ro, "outerRadius", 0, se());
 
-    function Wye(e, t, n) {
-        var i = t === e.head ? new vl(n, null, t, e) : new vl(n, t, t.next, e);
-        return i.next === null && (e.tail = i), i.prev === null && (e.head = i), e.length++, i
+    function q9(e) {
+        return Array.from(e)
+    }
+    var Ou = "auto",
+        s2e = "center",
+        qf = "justify",
+        a2e = "Change.konva",
+        o2e = "2d",
+        sO = "-",
+        H9 = "left",
+        l2e = "text",
+        u2e = "Text",
+        c2e = "top",
+        f2e = "bottom",
+        aO = "middle",
+        Y9 = "normal",
+        h2e = "px ",
+        gp = " ",
+        d2e = "right",
+        g2e = "word",
+        p2e = "char",
+        oO = "none",
+        Cb = "…",
+        X9 = ["fontFamily", "fontSize", "fontStyle", "fontVariant", "padding", "align", "verticalAlign", "lineHeight", "text", "width", "height", "wrap", "ellipsis", "letterSpacing"],
+        m2e = X9.length;
+
+    function y2e(e) {
+        return e.split(",").map(t => {
+            t = t.trim();
+            const n = t.indexOf(" ") >= 0,
+                i = t.indexOf('"') >= 0 || t.indexOf("'") >= 0;
+            return n && !i && (t = `"${t}"`), t
+        }).join(", ")
+    }
+    var pp;
+
+    function Ab() {
+        return pp || (pp = D.createCanvasElement().getContext(o2e), pp)
     }
 
-    function qye(e, t) {
-        e.tail = new vl(t, e.tail, null, e), e.head || (e.head = e.tail), e.length++
+    function v2e(e) {
+        e.fillText(this._partialText, this._partialTextX, this._partialTextY)
     }
 
-    function Hye(e, t) {
-        e.head = new vl(t, null, e.head, e), e.tail || (e.tail = e.head), e.length++
+    function b2e(e) {
+        e.strokeText(this._partialText, this._partialTextX, this._partialTextY)
     }
 
-    function vl(e, t, n, i) {
-        if (!(this instanceof vl)) return new vl(e, t, n, i);
-        this.list = i, this.value = e, t ? (t.next = this, this.prev = t) : this.prev = null, n ? (n.prev = this, this.next = n) : this.next = null
+    function x2e(e) {
+        return e = e || {}, !e.fillLinearGradientColorStops && !e.fillRadialGradientColorStops && !e.fillPatternImage && (e.fill = e.fill || "black"), e
     }
-    try {
-        Uye()(qe)
-    } catch {}
-    const Yye = Gye,
-        Fo = Symbol("max"),
-        _s = Symbol("length"),
-        iu = Symbol("lengthCalculator"),
-        ch = Symbol("allowStale"),
-        Io = Symbol("maxAge"),
-        vs = Symbol("dispose"),
-        X3 = Symbol("noDisposeOnSet"),
-        Pt = Symbol("lruList"),
-        qi = Symbol("cache"),
-        O8 = Symbol("updateAgeOnGet"),
-        zv = () => 1;
-    class Xye {
+    class $t extends Q {
         constructor(t) {
-            if (typeof t == "number" && (t = {
-                    max: t
-                }), t || (t = {}), t.max && (typeof t.max != "number" || t.max < 0)) throw new TypeError("max must be a non-negative number");
-            this[Fo] = t.max || 1 / 0;
-            const n = t.length || zv;
-            if (this[iu] = typeof n != "function" ? zv : n, this[ch] = t.stale || !1, t.maxAge && typeof t.maxAge != "number") throw new TypeError("maxAge must be a number");
-            this[Io] = t.maxAge || 0, this[vs] = t.dispose, this[X3] = t.noDisposeOnSet || !1, this[O8] = t.updateAgeOnGet || !1, this.reset()
+            super(x2e(t)), this._partialTextX = 0, this._partialTextY = 0;
+            for (var n = 0; n < m2e; n++) this.on(X9[n] + a2e, this._setTextData);
+            this._setTextData()
         }
-        set max(t) {
-            if (typeof t != "number" || t < 0) throw new TypeError("max must be a non-negative number");
-            this[Fo] = t || 1 / 0, yf(this)
+        _sceneFunc(t) {
+            var n = this.textArr,
+                i = n.length;
+            if (this.text()) {
+                var r = this.padding(),
+                    s = this.fontSize(),
+                    a = this.lineHeight() * s,
+                    o = this.verticalAlign(),
+                    l = 0,
+                    u = this.align(),
+                    c = this.getWidth(),
+                    f = this.letterSpacing(),
+                    h = this.fill(),
+                    d = this.textDecoration(),
+                    g = d.indexOf("underline") !== -1,
+                    p = d.indexOf("line-through") !== -1,
+                    m, y = 0,
+                    y = a / 2,
+                    v = 0,
+                    b = 0;
+                for (t.setAttr("font", this._getContextFont()), t.setAttr("textBaseline", aO), t.setAttr("textAlign", H9), o === aO ? l = (this.getHeight() - i * a - r * 2) / 2 : o === f2e && (l = this.getHeight() - i * a - r * 2), t.translate(r, l + r), m = 0; m < i; m++) {
+                    var v = 0,
+                        b = 0,
+                        x = n[m],
+                        _ = x.text,
+                        S = x.width,
+                        w = x.lastInParagraph,
+                        E, C, k;
+                    if (t.save(), u === d2e ? v += c - S - r * 2 : u === s2e && (v += (c - S - r * 2) / 2), g) {
+                        t.save(), t.beginPath(), t.moveTo(v, y + b + Math.round(s / 2)), E = _.split(" ").length - 1, C = E === 0, k = u === qf && !w ? c - r * 2 : S, t.lineTo(v + Math.round(k), y + b + Math.round(s / 2)), t.lineWidth = s / 15;
+                        const R = this._getLinearGradient();
+                        t.strokeStyle = R || h, t.stroke(), t.restore()
+                    }
+                    if (p) {
+                        t.save(), t.beginPath(), t.moveTo(v, y + b), E = _.split(" ").length - 1, C = E === 0, k = u === qf && w && !C ? c - r * 2 : S, t.lineTo(v + Math.round(k), y + b), t.lineWidth = s / 15;
+                        const R = this._getLinearGradient();
+                        t.strokeStyle = R || h, t.stroke(), t.restore()
+                    }
+                    if (f !== 0 || u === qf) {
+                        E = _.split(" ").length - 1;
+                        for (var A = q9(_), F = 0; F < A.length; F++) {
+                            var $ = A[F];
+                            $ === " " && !w && u === qf && (v += (c - r * 2 - S) / E), this._partialTextX = v, this._partialTextY = y + b, this._partialText = $, t.fillStrokeShape(this), v += this.measureSize($).width + f
+                        }
+                    } else this._partialTextX = v, this._partialTextY = y + b, this._partialText = _, t.fillStrokeShape(this);
+                    t.restore(), i > 1 && (y += a)
+                }
+            }
         }
-        get max() {
-            return this[Fo]
+        _hitFunc(t) {
+            var n = this.getWidth(),
+                i = this.getHeight();
+            t.beginPath(), t.rect(0, 0, n, i), t.closePath(), t.fillStrokeShape(this)
         }
-        set allowStale(t) {
-            this[ch] = !!t
+        setText(t) {
+            var n = D._isString(t) ? t : t == null ? "" : t + "";
+            return this._setAttr(l2e, n), this
         }
-        get allowStale() {
-            return this[ch]
+        getWidth() {
+            var t = this.attrs.width === Ou || this.attrs.width === void 0;
+            return t ? this.getTextWidth() + this.padding() * 2 : this.attrs.width
         }
-        set maxAge(t) {
-            if (typeof t != "number") throw new TypeError("maxAge must be a non-negative number");
-            this[Io] = t, yf(this)
+        getHeight() {
+            var t = this.attrs.height === Ou || this.attrs.height === void 0;
+            return t ? this.fontSize() * this.textArr.length * this.lineHeight() + this.padding() * 2 : this.attrs.height
         }
-        get maxAge() {
-            return this[Io]
+        getTextWidth() {
+            return this.textWidth
         }
-        set lengthCalculator(t) {
-            typeof t != "function" && (t = zv), t !== this[iu] && (this[iu] = t, this[_s] = 0, this[Pt].forEach(n => {
-                n.length = this[iu](n.value, n.key), this[_s] += n.length
-            })), yf(this)
+        getTextHeight() {
+            return D.warn("text.getTextHeight() method is deprecated. Use text.height() - for full height and text.fontSize() - for one line height."), this.textHeight
         }
-        get lengthCalculator() {
-            return this[iu]
+        measureSize(t) {
+            var n = Ab(),
+                i = this.fontSize(),
+                r;
+            return n.save(), n.font = this._getContextFont(), r = n.measureText(t), n.restore(), {
+                width: r.width,
+                height: i
+            }
         }
-        get length() {
-            return this[_s]
+        _getContextFont() {
+            return this.fontStyle() + gp + this.fontVariant() + gp + (this.fontSize() + h2e) + y2e(this.fontFamily())
         }
-        get itemCount() {
-            return this[Pt].length
+        _addTextLine(t) {
+            this.align() === qf && (t = t.trim());
+            var i = this._getTextWidth(t);
+            return this.textArr.push({
+                text: t,
+                width: i,
+                lastInParagraph: !1
+            })
         }
-        rforEach(t, n) {
-            n = n || this;
-            for (let i = this[Pt].tail; i !== null;) {
-                const r = i.prev;
-                V3(this, t, i, n), i = r
-            }
+        _getTextWidth(t) {
+            var n = this.letterSpacing(),
+                i = t.length;
+            return Ab().measureText(t).width + (i ? n * (i - 1) : 0)
         }
-        forEach(t, n) {
-            n = n || this;
-            for (let i = this[Pt].head; i !== null;) {
-                const r = i.next;
-                V3(this, t, i, n), i = r
+        _setTextData() {
+            var t = this.text().split(`
+`),
+                n = +this.fontSize(),
+                i = 0,
+                r = this.lineHeight() * n,
+                s = this.attrs.width,
+                a = this.attrs.height,
+                o = s !== Ou && s !== void 0,
+                l = a !== Ou && a !== void 0,
+                u = this.padding(),
+                c = s - u * 2,
+                f = a - u * 2,
+                h = 0,
+                d = this.wrap(),
+                g = d !== oO,
+                p = d !== p2e && g,
+                m = this.ellipsis();
+            this.textArr = [], Ab().font = this._getContextFont();
+            for (var y = m ? this._getTextWidth(Cb) : 0, v = 0, b = t.length; v < b; ++v) {
+                var x = t[v],
+                    _ = this._getTextWidth(x);
+                if (o && _ > c)
+                    for (; x.length > 0;) {
+                        for (var S = 0, w = x.length, E = "", C = 0; S < w;) {
+                            var k = S + w >>> 1,
+                                A = x.slice(0, k + 1),
+                                F = this._getTextWidth(A) + y;
+                            F <= c ? (S = k + 1, E = A, C = F) : w = k
+                        }
+                        if (E) {
+                            if (p) {
+                                var $, T = x[E.length],
+                                    M = T === gp || T === sO;
+                                M && C <= c ? $ = E.length : $ = Math.max(E.lastIndexOf(gp), E.lastIndexOf(sO)) + 1, $ > 0 && (S = $, E = E.slice(0, S), C = this._getTextWidth(E))
+                            }
+                            E = E.trimRight(), this._addTextLine(E), i = Math.max(i, C), h += r;
+                            var R = this._shouldHandleEllipsis(h);
+                            if (R) {
+                                this._tryToAddEllipsisToLastLine();
+                                break
+                            }
+                            if (x = x.slice(S), x = x.trimLeft(), x.length > 0 && (_ = this._getTextWidth(x), _ <= c)) {
+                                this._addTextLine(x), h += r, i = Math.max(i, _);
+                                break
+                            }
+                        } else break
+                    } else this._addTextLine(x), h += r, i = Math.max(i, _), this._shouldHandleEllipsis(h) && v < b - 1 && this._tryToAddEllipsisToLastLine();
+                if (this.textArr[this.textArr.length - 1] && (this.textArr[this.textArr.length - 1].lastInParagraph = !0), l && h + r > f) break
             }
+            this.textHeight = n, this.textWidth = i
         }
-        keys() {
-            return this[Pt].toArray().map(t => t.key)
+        _shouldHandleEllipsis(t) {
+            var n = +this.fontSize(),
+                i = this.lineHeight() * n,
+                r = this.attrs.height,
+                s = r !== Ou && r !== void 0,
+                a = this.padding(),
+                o = r - a * 2,
+                l = this.wrap(),
+                u = l !== oO;
+            return !u || s && t + i > o
         }
-        values() {
-            return this[Pt].toArray().map(t => t.value)
+        _tryToAddEllipsisToLastLine() {
+            var t = this.attrs.width,
+                n = t !== Ou && t !== void 0,
+                i = this.padding(),
+                r = t - i * 2,
+                s = this.ellipsis(),
+                a = this.textArr[this.textArr.length - 1];
+            if (!(!a || !s)) {
+                if (n) {
+                    var o = this._getTextWidth(a.text + Cb) < r;
+                    o || (a.text = a.text.slice(0, a.text.length - 3))
+                }
+                this.textArr.splice(this.textArr.length - 1, 1), this._addTextLine(a.text + Cb)
+            }
         }
-        reset() {
-            this[vs] && this[Pt] && this[Pt].length && this[Pt].forEach(t => this[vs](t.key, t.value)), this[qi] = new Map, this[Pt] = new Yye, this[_s] = 0
+        getStrokeScaleEnabled() {
+            return !0
         }
-        dump() {
-            return this[Pt].map(t => J0(this, t) ? !1 : {
-                k: t.key,
-                v: t.value,
-                e: t.now + (t.maxAge || 0)
-            }).toArray().filter(t => t)
+    }
+    $t.prototype._fillFunc = v2e;
+    $t.prototype._strokeFunc = b2e;
+    $t.prototype.className = u2e;
+    $t.prototype._attrsAffectingSize = ["text", "fontSize", "padding", "wrap", "lineHeight", "letterSpacing"];
+    Mt($t);
+    O.overWriteSetter($t, "width", IC());
+    O.overWriteSetter($t, "height", IC());
+    O.addGetterSetter($t, "fontFamily", "Arial");
+    O.addGetterSetter($t, "fontSize", 12, se());
+    O.addGetterSetter($t, "fontStyle", Y9);
+    O.addGetterSetter($t, "fontVariant", Y9);
+    O.addGetterSetter($t, "padding", 0, se());
+    O.addGetterSetter($t, "align", H9);
+    O.addGetterSetter($t, "verticalAlign", c2e);
+    O.addGetterSetter($t, "lineHeight", 1, se());
+    O.addGetterSetter($t, "wrap", g2e);
+    O.addGetterSetter($t, "ellipsis", !1, zr());
+    O.addGetterSetter($t, "letterSpacing", 0, se());
+    O.addGetterSetter($t, "text", "", hf());
+    O.addGetterSetter($t, "textDecoration", "");
+    var _2e = "",
+        V9 = "normal";
+
+    function K9(e) {
+        e.fillText(this.partialText, 0, 0)
+    }
+
+    function J9(e) {
+        e.strokeText(this.partialText, 0, 0)
+    }
+    class Jt extends Q {
+        constructor(t) {
+            super(t), this.dummyCanvas = D.createCanvasElement(), this.dataArray = [], this.dataArray = ct.parsePathData(this.attrs.data), this.on("dataChange.konva", function() {
+                this.dataArray = ct.parsePathData(this.attrs.data), this._setTextData()
+            }), this.on("textChange.konva alignChange.konva letterSpacingChange.konva kerningFuncChange.konva fontSizeChange.konva fontFamilyChange.konva", this._setTextData), this._setTextData()
         }
-        dumpLru() {
-            return this[Pt]
+        _sceneFunc(t) {
+            t.setAttr("font", this._getContextFont()), t.setAttr("textBaseline", this.textBaseline()), t.setAttr("textAlign", "left"), t.save();
+            var n = this.textDecoration(),
+                i = this.fill(),
+                r = this.fontSize(),
+                s = this.glyphInfo;
+            n === "underline" && t.beginPath();
+            for (var a = 0; a < s.length; a++) {
+                t.save();
+                var o = s[a].p0;
+                t.translate(o.x, o.y), t.rotate(s[a].rotation), this.partialText = s[a].text, t.fillStrokeShape(this), n === "underline" && (a === 0 && t.moveTo(0, r / 2 + 1), t.lineTo(r, r / 2 + 1)), t.restore()
+            }
+            n === "underline" && (t.strokeStyle = i, t.lineWidth = r / 20, t.stroke()), t.restore()
         }
-        set(t, n, i) {
-            if (i = i || this[Io], i && typeof i != "number") throw new TypeError("maxAge must be a number");
-            const r = i ? Date.now() : 0,
-                s = this[iu](n, t);
-            if (this[qi].has(t)) {
-                if (s > this[Fo]) return Tu(this, this[qi].get(t)), !1;
-                const l = this[qi].get(t).value;
-                return this[vs] && (this[X3] || this[vs](t, l.value)), l.now = r, l.maxAge = i, l.value = n, this[_s] += s - l.length, l.length = s, this.get(t), yf(this), !0
+        _hitFunc(t) {
+            t.beginPath();
+            var n = this.glyphInfo;
+            if (n.length >= 1) {
+                var i = n[0].p0;
+                t.moveTo(i.x, i.y)
+            }
+            for (var r = 0; r < n.length; r++) {
+                var s = n[r].p1;
+                t.lineTo(s.x, s.y)
             }
-            const a = new Vye(t, n, s, r, i);
-            return a.length > this[Fo] ? (this[vs] && this[vs](t, n), !1) : (this[_s] += a.length, this[Pt].unshift(a), this[qi].set(t, this[Pt].head), yf(this), !0)
+            t.setAttr("lineWidth", this.fontSize()), t.setAttr("strokeStyle", this.colorKey), t.stroke()
         }
-        has(t) {
-            if (!this[qi].has(t)) return !1;
-            const n = this[qi].get(t).value;
-            return !J0(this, n)
+        getTextWidth() {
+            return this.textWidth
         }
-        get(t) {
-            return Bv(this, t, !0)
+        getTextHeight() {
+            return D.warn("text.getTextHeight() method is deprecated. Use text.height() - for full height and text.fontSize() - for one line height."), this.textHeight
         }
-        peek(t) {
-            return Bv(this, t, !1)
+        setText(t) {
+            return $t.prototype.setText.call(this, t)
         }
-        pop() {
-            const t = this[Pt].tail;
-            return t ? (Tu(this, t), t.value) : null
+        _getContextFont() {
+            return $t.prototype._getContextFont.call(this)
         }
-        del(t) {
-            Tu(this, this[qi].get(t))
+        _getTextSize(t) {
+            var n = this.dummyCanvas,
+                i = n.getContext("2d");
+            i.save(), i.font = this._getContextFont();
+            var r = i.measureText(t);
+            return i.restore(), {
+                width: r.width,
+                height: parseInt(this.attrs.fontSize, 10)
+            }
         }
-        load(t) {
-            this.reset();
-            const n = Date.now();
-            for (let i = t.length - 1; i >= 0; i--) {
-                const r = t[i],
-                    s = r.e || 0;
-                if (s === 0) this.set(r.k, r.v);
-                else {
-                    const a = s - n;
-                    a > 0 && this.set(r.k, r.v, a)
+        _setTextData() {
+            var t = this,
+                n = this._getTextSize(this.attrs.text),
+                i = this.letterSpacing(),
+                r = this.align(),
+                s = this.kerningFunc();
+            this.textWidth = n.width, this.textHeight = n.height;
+            var a = Math.max(this.textWidth + ((this.attrs.text || "").length - 1) * i, 0);
+            this.glyphInfo = [];
+            for (var o = 0, l = 0; l < t.dataArray.length; l++) t.dataArray[l].pathLength > 0 && (o += t.dataArray[l].pathLength);
+            var u = 0;
+            r === "center" && (u = Math.max(0, o / 2 - a / 2)), r === "right" && (u = Math.max(0, o - a));
+            for (var c = q9(this.text()), f = this.text().split(" ").length - 1, h, d, g, p = -1, m = 0, y = function() {
+                    m = 0;
+                    for (var F = t.dataArray, $ = p + 1; $ < F.length; $++) {
+                        if (F[$].pathLength > 0) return p = $, F[$];
+                        F[$].command === "M" && (h = {
+                            x: F[$].points[0],
+                            y: F[$].points[1]
+                        })
+                    }
+                    return {}
+                }, v = function(F) {
+                    var $ = t._getTextSize(F).width + i;
+                    F === " " && r === "justify" && ($ += (o - a) / f);
+                    var T = 0,
+                        M = 0;
+                    for (d = void 0; Math.abs($ - T) / $ > .01 && M < 20;) {
+                        M++;
+                        for (var R = T; g === void 0;) g = y(), g && R + g.pathLength < $ && (R += g.pathLength, g = void 0);
+                        if (Object.keys(g).length === 0 || h === void 0) return;
+                        var N = !1;
+                        switch (g.command) {
+                            case "L":
+                                ct.getLineLength(h.x, h.y, g.points[0], g.points[1]) > $ ? d = ct.getPointOnLine($, h.x, h.y, g.points[0], g.points[1], h.x, h.y) : g = void 0;
+                                break;
+                            case "A":
+                                var L = g.points[4],
+                                    I = g.points[5],
+                                    G = g.points[4] + I;
+                                m === 0 ? m = L + 1e-8 : $ > T ? m += Math.PI / 180 * I / Math.abs(I) : m -= Math.PI / 360 * I / Math.abs(I), (I < 0 && m < G || I >= 0 && m > G) && (m = G, N = !0), d = ct.getPointOnEllipticalArc(g.points[0], g.points[1], g.points[2], g.points[3], m, g.points[6]);
+                                break;
+                            case "C":
+                                m === 0 ? $ > g.pathLength ? m = 1e-8 : m = $ / g.pathLength : $ > T ? m += ($ - T) / g.pathLength / 2 : m = Math.max(m - (T - $) / g.pathLength / 2, 0), m > 1 && (m = 1, N = !0), d = ct.getPointOnCubicBezier(m, g.start.x, g.start.y, g.points[0], g.points[1], g.points[2], g.points[3], g.points[4], g.points[5]);
+                                break;
+                            case "Q":
+                                m === 0 ? m = $ / g.pathLength : $ > T ? m += ($ - T) / g.pathLength : m -= (T - $) / g.pathLength, m > 1 && (m = 1, N = !0), d = ct.getPointOnQuadraticBezier(m, g.start.x, g.start.y, g.points[0], g.points[1], g.points[2], g.points[3]);
+                                break
+                        }
+                        d !== void 0 && (T = ct.getLineLength(h.x, h.y, d.x, d.y)), N && (N = !1, g = void 0)
+                    }
+                }, b = "C", x = t._getTextSize(b).width + i, _ = u / x - 1, S = 0; S < _ && (v(b), !(h === void 0 || d === void 0)); S++) h = d;
+            for (var w = 0; w < c.length && (v(c[w]), !(h === void 0 || d === void 0)); w++) {
+                var E = ct.getLineLength(h.x, h.y, d.x, d.y),
+                    C = 0;
+                if (s) try {
+                    C = s(c[w - 1], c[w]) * this.fontSize()
+                } catch {
+                    C = 0
                 }
+                h.x += C, d.x += C, this.textWidth += C;
+                var k = ct.getPointOnLine(C + E / 2, h.x, h.y, d.x, d.y),
+                    A = Math.atan2(d.y - h.y, d.x - h.x);
+                this.glyphInfo.push({
+                    transposeX: k.x,
+                    transposeY: k.y,
+                    text: c[w],
+                    rotation: A,
+                    p0: h,
+                    p1: d
+                }), h = d
             }
         }
-        prune() {
-            this[qi].forEach((t, n) => Bv(this, n, !1))
+        getSelfRect() {
+            if (!this.glyphInfo.length) return {
+                x: 0,
+                y: 0,
+                width: 0,
+                height: 0
+            };
+            var t = [];
+            this.glyphInfo.forEach(function(c) {
+                t.push(c.p0.x), t.push(c.p0.y), t.push(c.p1.x), t.push(c.p1.y)
+            });
+            for (var n = t[0] || 0, i = t[0] || 0, r = t[1] || 0, s = t[1] || 0, a, o, l = 0; l < t.length / 2; l++) a = t[l * 2], o = t[l * 2 + 1], n = Math.min(n, a), i = Math.max(i, a), r = Math.min(r, o), s = Math.max(s, o);
+            var u = this.fontSize();
+            return {
+                x: n - u / 2,
+                y: r - u / 2,
+                width: i - n + u,
+                height: s - r + u
+            }
+        }
+        destroy() {
+            return D.releaseCanvas(this.dummyCanvas), super.destroy()
         }
     }
-    const Bv = (e, t, n) => {
-            const i = e[qi].get(t);
-            if (i) {
-                const r = i.value;
-                if (J0(e, r)) {
-                    if (Tu(e, i), !e[ch]) return
-                } else n && (e[O8] && (i.value.now = Date.now()), e[Pt].unshiftNode(i));
-                return r.value
-            }
-        },
-        J0 = (e, t) => {
-            if (!t || !t.maxAge && !e[Io]) return !1;
-            const n = Date.now() - t.now;
-            return t.maxAge ? n > t.maxAge : e[Io] && n > e[Io]
-        },
-        yf = e => {
-            if (e[_s] > e[Fo])
-                for (let t = e[Pt].tail; e[_s] > e[Fo] && t !== null;) {
-                    const n = t.prev;
-                    Tu(e, t), t = n
-                }
-        },
-        Tu = (e, t) => {
-            if (t) {
-                const n = t.value;
-                e[vs] && e[vs](n.key, n.value), e[_s] -= n.length, e[qi].delete(n.key), e[Pt].removeNode(t)
-            }
+    Jt.prototype._fillFunc = K9;
+    Jt.prototype._strokeFunc = J9;
+    Jt.prototype._fillFuncHit = K9;
+    Jt.prototype._strokeFuncHit = J9;
+    Jt.prototype.className = "TextPath";
+    Jt.prototype._attrsAffectingSize = ["text", "fontSize", "data"];
+    Mt(Jt);
+    O.addGetterSetter(Jt, "data");
+    O.addGetterSetter(Jt, "fontFamily", "Arial");
+    O.addGetterSetter(Jt, "fontSize", 12, se());
+    O.addGetterSetter(Jt, "fontStyle", V9);
+    O.addGetterSetter(Jt, "align", "left");
+    O.addGetterSetter(Jt, "letterSpacing", 0, se());
+    O.addGetterSetter(Jt, "textBaseline", "middle");
+    O.addGetterSetter(Jt, "fontVariant", V9);
+    O.addGetterSetter(Jt, "text", _2e);
+    O.addGetterSetter(Jt, "textDecoration", null);
+    O.addGetterSetter(Jt, "kerningFunc", null);
+    var Q9 = "tr-konva",
+        w2e = ["resizeEnabledChange", "rotateAnchorOffsetChange", "rotateEnabledChange", "enabledAnchorsChange", "anchorSizeChange", "borderEnabledChange", "borderStrokeChange", "borderStrokeWidthChange", "borderDashChange", "anchorStrokeChange", "anchorStrokeWidthChange", "anchorFillChange", "anchorCornerRadiusChange", "ignoreStrokeChange"].map(e => e + `.${Q9}`).join(" "),
+        lO = "nodesRect",
+        S2e = ["widthChange", "heightChange", "scaleXChange", "scaleYChange", "skewXChange", "skewYChange", "rotationChange", "offsetXChange", "offsetYChange", "transformsEnabledChange", "strokeWidthChange"],
+        E2e = {
+            "top-left": -45,
+            "top-center": 0,
+            "top-right": 45,
+            "middle-right": -90,
+            "middle-left": 90,
+            "bottom-left": -135,
+            "bottom-center": 180,
+            "bottom-right": 135
         };
-    class Vye {
-        constructor(t, n, i, r, s) {
-            this.key = t, this.value = n, this.length = i, this.now = r, this.maxAge = s || 0
+    const k2e = "ontouchstart" in pe._global;
+
+    function C2e(e, t) {
+        if (e === "rotater") return "crosshair";
+        t += D.degToRad(E2e[e] || 0);
+        var n = (D.radToDeg(t) % 360 + 360) % 360;
+        return D._inRange(n, 315 + 22.5, 360) || D._inRange(n, 0, 22.5) ? "ns-resize" : D._inRange(n, 45 - 22.5, 45 + 22.5) ? "nesw-resize" : D._inRange(n, 90 - 22.5, 90 + 22.5) ? "ew-resize" : D._inRange(n, 135 - 22.5, 135 + 22.5) ? "nwse-resize" : D._inRange(n, 180 - 22.5, 180 + 22.5) ? "ns-resize" : D._inRange(n, 225 - 22.5, 225 + 22.5) ? "nesw-resize" : D._inRange(n, 270 - 22.5, 270 + 22.5) ? "ew-resize" : D._inRange(n, 315 - 22.5, 315 + 22.5) ? "nwse-resize" : (D.error("Transformer has unknown angle for cursor detection: " + n), "pointer")
+    }
+    var D0 = ["top-left", "top-center", "top-right", "middle-right", "middle-left", "bottom-left", "bottom-center", "bottom-right"],
+        uO = 1e8;
+
+    function A2e(e) {
+        return {
+            x: e.x + e.width / 2 * Math.cos(e.rotation) + e.height / 2 * Math.sin(-e.rotation),
+            y: e.y + e.height / 2 * Math.cos(e.rotation) + e.width / 2 * Math.sin(e.rotation)
         }
     }
-    const V3 = (e, t, n, i) => {
-        let r = n.value;
-        J0(e, r) && (Tu(e, n), e[ch] || (r = void 0)), r && t.call(i, r.value, r.key, e)
-    };
-    var Kye = Xye;
-    const Jye = Object.freeze({
-            loose: !0
-        }),
-        Qye = Object.freeze({}),
-        Zye = e => e ? typeof e != "object" ? Jye : e : Qye;
-    var GC = Zye,
-        gx = {
-            exports: {}
-        };
-    const eve = "2.0.0",
-        tve = 256,
-        nve = Number.MAX_SAFE_INTEGER || 9007199254740991,
-        ive = 16,
-        rve = ["major", "premajor", "minor", "preminor", "patch", "prepatch", "prerelease"];
-    var WC = {
-        MAX_LENGTH: tve,
-        MAX_SAFE_COMPONENT_LENGTH: ive,
-        MAX_SAFE_INTEGER: nve,
-        RELEASE_TYPES: rve,
-        SEMVER_SPEC_VERSION: eve,
-        FLAG_INCLUDE_PRERELEASE: 1,
-        FLAG_LOOSE: 2
-    };
-    const sve = typeof process == "object" && process.env && {}.NODE_DEBUG && /\bsemver\b/i.test({}.NODE_DEBUG) ? (...e) => console.error("SEMVER", ...e) : () => {};
-    var ay = sve;
-    (function(e, t) {
-        const {
-            MAX_SAFE_COMPONENT_LENGTH: n
-        } = WC, i = ay;
-        t = e.exports = {};
-        const r = t.re = [],
-            s = t.src = [],
-            a = t.t = {};
-        let o = 0;
-        const l = (u, c, f) => {
-            const h = o++;
-            i(u, h, c), a[u] = h, s[h] = c, r[h] = new RegExp(c, f ? "g" : void 0)
-        };
-        l("NUMERICIDENTIFIER", "0|[1-9]\\d*"), l("NUMERICIDENTIFIERLOOSE", "[0-9]+"), l("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), l("MAINVERSION", `(${s[a.NUMERICIDENTIFIER]})\\.(${s[a.NUMERICIDENTIFIER]})\\.(${s[a.NUMERICIDENTIFIER]})`), l("MAINVERSIONLOOSE", `(${s[a.NUMERICIDENTIFIERLOOSE]})\\.(${s[a.NUMERICIDENTIFIERLOOSE]})\\.(${s[a.NUMERICIDENTIFIERLOOSE]})`), l("PRERELEASEIDENTIFIER", `(?:${s[a.NUMERICIDENTIFIER]}|${s[a.NONNUMERICIDENTIFIER]})`), l("PRERELEASEIDENTIFIERLOOSE", `(?:${s[a.NUMERICIDENTIFIERLOOSE]}|${s[a.NONNUMERICIDENTIFIER]})`), l("PRERELEASE", `(?:-(${s[a.PRERELEASEIDENTIFIER]}(?:\\.${s[a.PRERELEASEIDENTIFIER]})*))`), l("PRERELEASELOOSE", `(?:-?(${s[a.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${s[a.PRERELEASEIDENTIFIERLOOSE]})*))`), l("BUILDIDENTIFIER", "[0-9A-Za-z-]+"), l("BUILD", `(?:\\+(${s[a.BUILDIDENTIFIER]}(?:\\.${s[a.BUILDIDENTIFIER]})*))`), l("FULLPLAIN", `v?${s[a.MAINVERSION]}${s[a.PRERELEASE]}?${s[a.BUILD]}?`), l("FULL", `^${s[a.FULLPLAIN]}$`), l("LOOSEPLAIN", `[v=\\s]*${s[a.MAINVERSIONLOOSE]}${s[a.PRERELEASELOOSE]}?${s[a.BUILD]}?`), l("LOOSE", `^${s[a.LOOSEPLAIN]}$`), l("GTLT", "((?:<|>)?=?)"), l("XRANGEIDENTIFIERLOOSE", `${s[a.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), l("XRANGEIDENTIFIER", `${s[a.NUMERICIDENTIFIER]}|x|X|\\*`), l("XRANGEPLAIN", `[v=\\s]*(${s[a.XRANGEIDENTIFIER]})(?:\\.(${s[a.XRANGEIDENTIFIER]})(?:\\.(${s[a.XRANGEIDENTIFIER]})(?:${s[a.PRERELEASE]})?${s[a.BUILD]}?)?)?`), l("XRANGEPLAINLOOSE", `[v=\\s]*(${s[a.XRANGEIDENTIFIERLOOSE]})(?:\\.(${s[a.XRANGEIDENTIFIERLOOSE]})(?:\\.(${s[a.XRANGEIDENTIFIERLOOSE]})(?:${s[a.PRERELEASELOOSE]})?${s[a.BUILD]}?)?)?`), l("XRANGE", `^${s[a.GTLT]}\\s*${s[a.XRANGEPLAIN]}$`), l("XRANGELOOSE", `^${s[a.GTLT]}\\s*${s[a.XRANGEPLAINLOOSE]}$`), l("COERCE", `(^|[^\\d])(\\d{1,${n}})(?:\\.(\\d{1,${n}}))?(?:\\.(\\d{1,${n}}))?(?:$|[^\\d])`), l("COERCERTL", s[a.COERCE], !0), l("LONETILDE", "(?:~>?)"), l("TILDETRIM", `(\\s*)${s[a.LONETILDE]}\\s+`, !0), t.tildeTrimReplace = "$1~", l("TILDE", `^${s[a.LONETILDE]}${s[a.XRANGEPLAIN]}$`), l("TILDELOOSE", `^${s[a.LONETILDE]}${s[a.XRANGEPLAINLOOSE]}$`), l("LONECARET", "(?:\\^)"), l("CARETTRIM", `(\\s*)${s[a.LONECARET]}\\s+`, !0), t.caretTrimReplace = "$1^", l("CARET", `^${s[a.LONECARET]}${s[a.XRANGEPLAIN]}$`), l("CARETLOOSE", `^${s[a.LONECARET]}${s[a.XRANGEPLAINLOOSE]}$`), l("COMPARATORLOOSE", `^${s[a.GTLT]}\\s*(${s[a.LOOSEPLAIN]})$|^$`), l("COMPARATOR", `^${s[a.GTLT]}\\s*(${s[a.FULLPLAIN]})$|^$`), l("COMPARATORTRIM", `(\\s*)${s[a.GTLT]}\\s*(${s[a.LOOSEPLAIN]}|${s[a.XRANGEPLAIN]})`, !0), t.comparatorTrimReplace = "$1$2$3", l("HYPHENRANGE", `^\\s*(${s[a.XRANGEPLAIN]})\\s+-\\s+(${s[a.XRANGEPLAIN]})\\s*$`), l("HYPHENRANGELOOSE", `^\\s*(${s[a.XRANGEPLAINLOOSE]})\\s+-\\s+(${s[a.XRANGEPLAINLOOSE]})\\s*$`), l("STAR", "(<|>)?=?\\s*\\*"), l("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"), l("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$")
-    })(gx, gx.exports);
-    var qC = gx.exports;
-    const K3 = /^[0-9]+$/,
-        F8 = (e, t) => {
-            const n = K3.test(e),
-                i = K3.test(t);
-            return n && i && (e = +e, t = +t), e === t ? 0 : n && !i ? -1 : i && !n ? 1 : e < t ? -1 : 1
-        },
-        ave = (e, t) => F8(t, e);
-    var ove = {
-        compareIdentifiers: F8,
-        rcompareIdentifiers: ave
-    };
-    const Pg = ay,
-        {
-            MAX_LENGTH: J3,
-            MAX_SAFE_INTEGER: Lg
-        } = WC,
-        {
-            re: Q3,
-            t: Z3
-        } = qC,
-        lve = GC,
-        {
-            compareIdentifiers: ru
-        } = ove;
-    let uve = class $r {
-        constructor(t, n) {
-            if (n = lve(n), t instanceof $r) {
-                if (t.loose === !!n.loose && t.includePrerelease === !!n.includePrerelease) return t;
-                t = t.version
-            } else if (typeof t != "string") throw new TypeError(`Invalid Version: ${t}`);
-            if (t.length > J3) throw new TypeError(`version is longer than ${J3} characters`);
-            Pg("SemVer", t, n), this.options = n, this.loose = !!n.loose, this.includePrerelease = !!n.includePrerelease;
-            const i = t.trim().match(n.loose ? Q3[Z3.LOOSE] : Q3[Z3.FULL]);
-            if (!i) throw new TypeError(`Invalid Version: ${t}`);
-            if (this.raw = t, this.major = +i[1], this.minor = +i[2], this.patch = +i[3], this.major > Lg || this.major < 0) throw new TypeError("Invalid major version");
-            if (this.minor > Lg || this.minor < 0) throw new TypeError("Invalid minor version");
-            if (this.patch > Lg || this.patch < 0) throw new TypeError("Invalid patch version");
-            i[4] ? this.prerelease = i[4].split(".").map(r => {
-                if (/^[0-9]+$/.test(r)) {
-                    const s = +r;
-                    if (s >= 0 && s < Lg) return s
-                }
-                return r
-            }) : this.prerelease = [], this.build = i[5] ? i[5].split(".") : [], this.format()
+
+    function Z9(e, t, n) {
+        const i = n.x + (e.x - n.x) * Math.cos(t) - (e.y - n.y) * Math.sin(t),
+            r = n.y + (e.x - n.x) * Math.sin(t) + (e.y - n.y) * Math.cos(t);
+        return Object.assign(Object.assign({}, e), {
+            rotation: e.rotation + t,
+            x: i,
+            y: r
+        })
+    }
+
+    function $2e(e, t) {
+        const n = A2e(e);
+        return Z9(e, t, n)
+    }
+
+    function T2e(e, t, n) {
+        let i = t;
+        for (let r = 0; r < e.length; r++) {
+            const s = pe.getAngle(e[r]),
+                a = Math.abs(s - t) % (Math.PI * 2);
+            Math.min(a, Math.PI * 2 - a) < n && (i = s)
         }
-        format() {
-            return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version
+        return i
+    }
+    class at extends Ic {
+        constructor(t) {
+            super(t), this._transforming = !1, this._createElements(), this._handleMouseMove = this._handleMouseMove.bind(this), this._handleMouseUp = this._handleMouseUp.bind(this), this.update = this.update.bind(this), this.on(w2e, this.update), this.getNode() && this.update()
         }
-        toString() {
-            return this.version
+        attachTo(t) {
+            return this.setNode(t), this
         }
-        compare(t) {
-            if (Pg("SemVer.compare", this.version, this.options, t), !(t instanceof $r)) {
-                if (typeof t == "string" && t === this.version) return 0;
-                t = new $r(t, this.options)
-            }
-            return t.version === this.version ? 0 : this.compareMain(t) || this.comparePre(t)
+        setNode(t) {
+            return D.warn("tr.setNode(shape), tr.node(shape) and tr.attachTo(shape) methods are deprecated. Please use tr.nodes(nodesArray) instead."), this.setNodes([t])
         }
-        compareMain(t) {
-            return t instanceof $r || (t = new $r(t, this.options)), ru(this.major, t.major) || ru(this.minor, t.minor) || ru(this.patch, t.patch)
+        getNode() {
+            return this._nodes && this._nodes[0]
         }
-        comparePre(t) {
-            if (t instanceof $r || (t = new $r(t, this.options)), this.prerelease.length && !t.prerelease.length) return -1;
-            if (!this.prerelease.length && t.prerelease.length) return 1;
-            if (!this.prerelease.length && !t.prerelease.length) return 0;
-            let n = 0;
-            do {
-                const i = this.prerelease[n],
-                    r = t.prerelease[n];
-                if (Pg("prerelease compare", n, i, r), i === void 0 && r === void 0) return 0;
-                if (r === void 0) return 1;
-                if (i === void 0) return -1;
-                if (i === r) continue;
-                return ru(i, r)
-            } while (++n)
+        _getEventNamespace() {
+            return Q9 + this._id
         }
-        compareBuild(t) {
-            t instanceof $r || (t = new $r(t, this.options));
-            let n = 0;
-            do {
-                const i = this.build[n],
-                    r = t.build[n];
-                if (Pg("prerelease compare", n, i, r), i === void 0 && r === void 0) return 0;
-                if (r === void 0) return 1;
-                if (i === void 0) return -1;
-                if (i === r) continue;
-                return ru(i, r)
-            } while (++n)
+        setNodes(t = []) {
+            this._nodes && this._nodes.length && this.detach();
+            const n = t.filter(r => r.isAncestorOf(this) ? (D.error("Konva.Transformer cannot be an a child of the node you are trying to attach"), !1) : !0);
+            this._nodes = t = n, t.length === 1 && this.useSingleNodeRotation() ? this.rotation(t[0].getAbsoluteRotation()) : this.rotation(0), this._nodes.forEach(r => {
+                const s = () => {
+                        this.nodes().length === 1 && this.useSingleNodeRotation() && this.rotation(this.nodes()[0].getAbsoluteRotation()), this._resetTransformCache(), !this._transforming && !this.isDragging() && this.update()
+                    },
+                    a = r._attrsAffectingSize.map(o => o + "Change." + this._getEventNamespace()).join(" ");
+                r.on(a, s), r.on(S2e.map(o => o + `.${this._getEventNamespace()}`).join(" "), s), r.on(`absoluteTransformChange.${this._getEventNamespace()}`, s), this._proxyDrag(r)
+            }), this._resetTransformCache();
+            var i = !!this.findOne(".top-left");
+            return i && this.update(), this
         }
-        inc(t, n, i) {
-            switch (t) {
-                case "premajor":
-                    this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", n, i);
-                    break;
-                case "preminor":
-                    this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", n, i);
-                    break;
-                case "prepatch":
-                    this.prerelease.length = 0, this.inc("patch", n, i), this.inc("pre", n, i);
-                    break;
-                case "prerelease":
-                    this.prerelease.length === 0 && this.inc("patch", n, i), this.inc("pre", n, i);
-                    break;
-                case "major":
-                    (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
-                    break;
-                case "minor":
-                    (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
-                    break;
-                case "patch":
-                    this.prerelease.length === 0 && this.patch++, this.prerelease = [];
-                    break;
-                case "pre":
-                    if (this.prerelease.length === 0) this.prerelease = [0];
-                    else {
-                        let r = this.prerelease.length;
-                        for (; --r >= 0;) typeof this.prerelease[r] == "number" && (this.prerelease[r]++, r = -2);
-                        r === -1 && this.prerelease.push(0)
-                    }
-                    if (n) {
-                        const r = Number(i) ? 1 : 0;
-                        ru(this.prerelease[0], n) === 0 ? isNaN(this.prerelease[1]) && (this.prerelease = [n, r]) : this.prerelease = [n, r]
-                    }
-                    break;
-                default:
-                    throw new Error(`invalid increment argument: ${t}`)
-            }
-            return this.format(), this.raw = this.version, this
+        _proxyDrag(t) {
+            let n;
+            t.on(`dragstart.${this._getEventNamespace()}`, i => {
+                n = t.getAbsolutePosition(), !this.isDragging() && t !== this.findOne(".back") && this.startDrag(i, !1)
+            }), t.on(`dragmove.${this._getEventNamespace()}`, i => {
+                if (!n) return;
+                const r = t.getAbsolutePosition(),
+                    s = r.x - n.x,
+                    a = r.y - n.y;
+                this.nodes().forEach(o => {
+                    if (o === t || o.isDragging()) return;
+                    const l = o.getAbsolutePosition();
+                    o.setAbsolutePosition({
+                        x: l.x + s,
+                        y: l.y + a
+                    }), o.startDrag(i)
+                }), n = null
+            })
         }
-    };
-    var HC = uve;
-    const eM = HC,
-        cve = (e, t, n) => new eM(e, n).compare(new eM(t, n));
-    var zc = cve;
-    const fve = zc,
-        hve = (e, t, n) => fve(e, t, n) === 0;
-    var dve = hve;
-    const gve = zc,
-        pve = (e, t, n) => gve(e, t, n) !== 0;
-    var mve = pve;
-    const yve = zc,
-        vve = (e, t, n) => yve(e, t, n) > 0;
-    var bve = vve;
-    const xve = zc,
-        _ve = (e, t, n) => xve(e, t, n) >= 0;
-    var wve = _ve;
-    const Sve = zc,
-        Eve = (e, t, n) => Sve(e, t, n) < 0;
-    var Cve = Eve;
-    const kve = zc,
-        Ave = (e, t, n) => kve(e, t, n) <= 0;
-    var $ve = Ave;
-    const Tve = dve,
-        Mve = mve,
-        Ove = bve,
-        Fve = wve,
-        Rve = Cve,
-        Dve = $ve,
-        Nve = (e, t, n, i) => {
-            switch (t) {
-                case "===":
-                    return typeof e == "object" && (e = e.version), typeof n == "object" && (n = n.version), e === n;
-                case "!==":
-                    return typeof e == "object" && (e = e.version), typeof n == "object" && (n = n.version), e !== n;
-                case "":
-                case "=":
-                case "==":
-                    return Tve(e, n, i);
-                case "!=":
-                    return Mve(e, n, i);
-                case ">":
-                    return Ove(e, n, i);
-                case ">=":
-                    return Fve(e, n, i);
-                case "<":
-                    return Rve(e, n, i);
-                case "<=":
-                    return Dve(e, n, i);
-                default:
-                    throw new TypeError(`Invalid operator: ${t}`)
-            }
-        };
-    var Pve = Nve,
-        jv, tM;
-
-    function Lve() {
-        if (tM) return jv;
-        tM = 1;
-        const e = Symbol("SemVer ANY");
-        class t {
-            static get ANY() {
-                return e
-            }
-            constructor(c, f) {
-                if (f = n(f), c instanceof t) {
-                    if (c.loose === !!f.loose) return c;
-                    c = c.value
-                }
-                a("comparator", c, f), this.options = f, this.loose = !!f.loose, this.parse(c), this.semver === e ? this.value = "" : this.value = this.operator + this.semver.version, a("comp", this)
-            }
-            parse(c) {
-                const f = this.options.loose ? i[r.COMPARATORLOOSE] : i[r.COMPARATOR],
-                    h = c.match(f);
-                if (!h) throw new TypeError(`Invalid comparator: ${c}`);
-                this.operator = h[1] !== void 0 ? h[1] : "", this.operator === "=" && (this.operator = ""), h[2] ? this.semver = new o(h[2], this.options.loose) : this.semver = e
-            }
-            toString() {
-                return this.value
+        getNodes() {
+            return this._nodes || []
+        }
+        getActiveAnchor() {
+            return this._movingAnchorName
+        }
+        detach() {
+            this._nodes && this._nodes.forEach(t => {
+                t.off("." + this._getEventNamespace())
+            }), this._nodes = [], this._resetTransformCache()
+        }
+        _resetTransformCache() {
+            this._clearCache(lO), this._clearCache("transform"), this._clearSelfAndDescendantCache("absoluteTransform")
+        }
+        _getNodeRect() {
+            return this._getCache(lO, this.__getNodeRect)
+        }
+        __getNodeShape(t, n = this.rotation(), i) {
+            var r = t.getClientRect({
+                    skipTransform: !0,
+                    skipShadow: !0,
+                    skipStroke: this.ignoreStroke()
+                }),
+                s = t.getAbsoluteScale(i),
+                a = t.getAbsolutePosition(i),
+                o = r.x * s.x - t.offsetX() * s.x,
+                l = r.y * s.y - t.offsetY() * s.y;
+            const u = (pe.getAngle(t.getAbsoluteRotation()) + Math.PI * 2) % (Math.PI * 2),
+                c = {
+                    x: a.x + o * Math.cos(u) + l * Math.sin(-u),
+                    y: a.y + l * Math.cos(u) + o * Math.sin(u),
+                    width: r.width * s.x,
+                    height: r.height * s.y,
+                    rotation: u
+                };
+            return Z9(c, -pe.getAngle(n), {
+                x: 0,
+                y: 0
+            })
+        }
+        __getNodeRect() {
+            var t = this.getNode();
+            if (!t) return {
+                x: -uO,
+                y: -uO,
+                width: 0,
+                height: 0,
+                rotation: 0
+            };
+            const n = [];
+            this.nodes().map(u => {
+                const c = u.getClientRect({
+                    skipTransform: !0,
+                    skipShadow: !0,
+                    skipStroke: this.ignoreStroke()
+                });
+                var f = [{
+                        x: c.x,
+                        y: c.y
+                    }, {
+                        x: c.x + c.width,
+                        y: c.y
+                    }, {
+                        x: c.x + c.width,
+                        y: c.y + c.height
+                    }, {
+                        x: c.x,
+                        y: c.y + c.height
+                    }],
+                    h = u.getAbsoluteTransform();
+                f.forEach(function(d) {
+                    var g = h.point(d);
+                    n.push(g)
+                })
+            });
+            const i = new mr;
+            i.rotate(-pe.getAngle(this.rotation()));
+            var r, s, a, o;
+            n.forEach(function(u) {
+                var c = i.point(u);
+                r === void 0 && (r = a = c.x, s = o = c.y), r = Math.min(r, c.x), s = Math.min(s, c.y), a = Math.max(a, c.x), o = Math.max(o, c.y)
+            }), i.invert();
+            const l = i.point({
+                x: r,
+                y: s
+            });
+            return {
+                x: l.x,
+                y: l.y,
+                width: a - r,
+                height: o - s,
+                rotation: pe.getAngle(this.rotation())
             }
-            test(c) {
-                if (a("Comparator.test", c, this.options.loose), this.semver === e || c === e) return !0;
-                if (typeof c == "string") try {
-                    c = new o(c, this.options)
-                } catch {
-                    return !1
+        }
+        getX() {
+            return this._getNodeRect().x
+        }
+        getY() {
+            return this._getNodeRect().y
+        }
+        getWidth() {
+            return this._getNodeRect().width
+        }
+        getHeight() {
+            return this._getNodeRect().height
+        }
+        _createElements() {
+            this._createBack(), D0.forEach((function(t) {
+                this._createAnchor(t)
+            }).bind(this)), this._createAnchor("rotater")
+        }
+        _createAnchor(t) {
+            var n = new mg({
+                    stroke: "rgb(0, 161, 255)",
+                    fill: "white",
+                    strokeWidth: 1,
+                    name: t + " _anchor",
+                    dragDistance: 0,
+                    draggable: !0,
+                    hitStrokeWidth: k2e ? 10 : "auto"
+                }),
+                i = this;
+            n.on("mousedown touchstart", function(r) {
+                i._handleMouseDown(r)
+            }), n.on("dragstart", r => {
+                n.stopDrag(), r.cancelBubble = !0
+            }), n.on("dragend", r => {
+                r.cancelBubble = !0
+            }), n.on("mouseenter", () => {
+                var r = pe.getAngle(this.rotation()),
+                    s = C2e(t, r);
+                n.getStage().content && (n.getStage().content.style.cursor = s), this._cursorChange = !0
+            }), n.on("mouseout", () => {
+                n.getStage().content && (n.getStage().content.style.cursor = ""), this._cursorChange = !1
+            }), this.add(n)
+        }
+        _createBack() {
+            var t = new Q({
+                name: "back",
+                width: 0,
+                height: 0,
+                draggable: !0,
+                sceneFunc(n) {
+                    var i = this.getParent(),
+                        r = i.padding();
+                    n.beginPath(), n.rect(-r, -r, this.width() + r * 2, this.height() + r * 2), n.moveTo(this.width() / 2, -r), i.rotateEnabled() && n.lineTo(this.width() / 2, -i.rotateAnchorOffset() * D._sign(this.height()) - r), n.fillStrokeShape(this)
+                },
+                hitFunc: (n, i) => {
+                    if (this.shouldOverdrawWholeArea()) {
+                        var r = this.padding();
+                        n.beginPath(), n.rect(-r, -r, i.width() + r * 2, i.height() + r * 2), n.fillStrokeShape(i)
+                    }
                 }
-                return s(c, this.operator, this.semver, this.options)
-            }
-            intersects(c, f) {
-                if (!(c instanceof t)) throw new TypeError("a Comparator is required");
-                return this.operator === "" ? this.value === "" ? !0 : new l(c.value, f).test(this.value) : c.operator === "" ? c.value === "" ? !0 : new l(this.value, f).test(c.semver) : (f = n(f), f.includePrerelease && (this.value === "<0.0.0-0" || c.value === "<0.0.0-0") || !f.includePrerelease && (this.value.startsWith("<0.0.0") || c.value.startsWith("<0.0.0")) ? !1 : !!(this.operator.startsWith(">") && c.operator.startsWith(">") || this.operator.startsWith("<") && c.operator.startsWith("<") || this.semver.version === c.semver.version && this.operator.includes("=") && c.operator.includes("=") || s(this.semver, "<", c.semver, f) && this.operator.startsWith(">") && c.operator.startsWith("<") || s(this.semver, ">", c.semver, f) && this.operator.startsWith("<") && c.operator.startsWith(">")))
-            }
+            });
+            this.add(t), this._proxyDrag(t), t.on("dragstart", n => {
+                n.cancelBubble = !0
+            }), t.on("dragmove", n => {
+                n.cancelBubble = !0
+            }), t.on("dragend", n => {
+                n.cancelBubble = !0
+            }), this.on("dragmove", n => {
+                this.update()
+            })
         }
-        jv = t;
-        const n = GC,
-            {
-                re: i,
-                t: r
-            } = qC,
-            s = Pve,
-            a = ay,
-            o = HC,
-            l = R8();
-        return jv
-    }
-    var Uv, nM;
-
-    function R8() {
-        if (nM) return Uv;
-        nM = 1;
-        class e {
-            constructor(T, M) {
-                if (M = i(M), T instanceof e) return T.loose === !!M.loose && T.includePrerelease === !!M.includePrerelease ? T : new e(T.raw, M);
-                if (T instanceof r) return this.raw = T.value, this.set = [
-                    [T]
-                ], this.format(), this;
-                if (this.options = M, this.loose = !!M.loose, this.includePrerelease = !!M.includePrerelease, this.raw = T, this.set = T.split("||").map(F => this.parseRange(F.trim())).filter(F => F.length), !this.set.length) throw new TypeError(`Invalid SemVer Range: ${T}`);
-                if (this.set.length > 1) {
-                    const F = this.set[0];
-                    if (this.set = this.set.filter(N => !g(N[0])), this.set.length === 0) this.set = [F];
-                    else if (this.set.length > 1) {
-                        for (const N of this.set)
-                            if (N.length === 1 && p(N[0])) {
-                                this.set = [N];
-                                break
-                            }
+        _handleMouseDown(t) {
+            this._movingAnchorName = t.target.name().split(" ")[0];
+            var n = this._getNodeRect(),
+                i = n.width,
+                r = n.height,
+                s = Math.sqrt(Math.pow(i, 2) + Math.pow(r, 2));
+            this.sin = Math.abs(r / s), this.cos = Math.abs(i / s), typeof window < "u" && (window.addEventListener("mousemove", this._handleMouseMove), window.addEventListener("touchmove", this._handleMouseMove), window.addEventListener("mouseup", this._handleMouseUp, !0), window.addEventListener("touchend", this._handleMouseUp, !0)), this._transforming = !0;
+            var a = t.target.getAbsolutePosition(),
+                o = t.target.getStage().getPointerPosition();
+            this._anchorDragOffset = {
+                x: o.x - a.x,
+                y: o.y - a.y
+            }, this._fire("transformstart", {
+                evt: t.evt,
+                target: this.getNode()
+            }), this._nodes.forEach(l => {
+                l._fire("transformstart", {
+                    evt: t.evt,
+                    target: l
+                })
+            })
+        }
+        _handleMouseMove(t) {
+            var n, i, r, s = this.findOne("." + this._movingAnchorName),
+                a = s.getStage();
+            a.setPointersPositions(t);
+            const o = a.getPointerPosition();
+            let l = {
+                x: o.x - this._anchorDragOffset.x,
+                y: o.y - this._anchorDragOffset.y
+            };
+            const u = s.getAbsolutePosition();
+            this.anchorDragBoundFunc() && (l = this.anchorDragBoundFunc()(u, l, t)), s.setAbsolutePosition(l);
+            const c = s.getAbsolutePosition();
+            if (!(u.x === c.x && u.y === c.y)) {
+                if (this._movingAnchorName === "rotater") {
+                    var f = this._getNodeRect();
+                    n = s.x() - f.width / 2, i = -s.y() + f.height / 2;
+                    let F = Math.atan2(-i, n) + Math.PI / 2;
+                    f.height < 0 && (F -= Math.PI);
+                    var h = pe.getAngle(this.rotation());
+                    const $ = h + F,
+                        T = pe.getAngle(this.rotationSnapTolerance()),
+                        R = T2e(this.rotationSnaps(), $, T) - f.rotation,
+                        N = $2e(f, R);
+                    this._fitNodesInto(N, t);
+                    return
+                }
+                var d = this.keepRatio() || t.shiftKey,
+                    v = this.centeredScaling() || t.altKey;
+                if (this._movingAnchorName === "top-left") {
+                    if (d) {
+                        var g = v ? {
+                            x: this.width() / 2,
+                            y: this.height() / 2
+                        } : {
+                            x: this.findOne(".bottom-right").x(),
+                            y: this.findOne(".bottom-right").y()
+                        };
+                        r = Math.sqrt(Math.pow(g.x - s.x(), 2) + Math.pow(g.y - s.y(), 2));
+                        var p = this.findOne(".top-left").x() > g.x ? -1 : 1,
+                            m = this.findOne(".top-left").y() > g.y ? -1 : 1;
+                        n = r * this.cos * p, i = r * this.sin * m, this.findOne(".top-left").x(g.x - n), this.findOne(".top-left").y(g.y - i)
+                    }
+                } else if (this._movingAnchorName === "top-center") this.findOne(".top-left").y(s.y());
+                else if (this._movingAnchorName === "top-right") {
+                    if (d) {
+                        var g = v ? {
+                            x: this.width() / 2,
+                            y: this.height() / 2
+                        } : {
+                            x: this.findOne(".bottom-left").x(),
+                            y: this.findOne(".bottom-left").y()
+                        };
+                        r = Math.sqrt(Math.pow(s.x() - g.x, 2) + Math.pow(g.y - s.y(), 2));
+                        var p = this.findOne(".top-right").x() < g.x ? -1 : 1,
+                            m = this.findOne(".top-right").y() > g.y ? -1 : 1;
+                        n = r * this.cos * p, i = r * this.sin * m, this.findOne(".top-right").x(g.x + n), this.findOne(".top-right").y(g.y - i)
+                    }
+                    var y = s.position();
+                    this.findOne(".top-left").y(y.y), this.findOne(".bottom-right").x(y.x)
+                } else if (this._movingAnchorName === "middle-left") this.findOne(".top-left").x(s.x());
+                else if (this._movingAnchorName === "middle-right") this.findOne(".bottom-right").x(s.x());
+                else if (this._movingAnchorName === "bottom-left") {
+                    if (d) {
+                        var g = v ? {
+                            x: this.width() / 2,
+                            y: this.height() / 2
+                        } : {
+                            x: this.findOne(".top-right").x(),
+                            y: this.findOne(".top-right").y()
+                        };
+                        r = Math.sqrt(Math.pow(g.x - s.x(), 2) + Math.pow(s.y() - g.y, 2));
+                        var p = g.x < s.x() ? -1 : 1,
+                            m = s.y() < g.y ? -1 : 1;
+                        n = r * this.cos * p, i = r * this.sin * m, s.x(g.x - n), s.y(g.y + i)
+                    }
+                    y = s.position(), this.findOne(".top-left").x(y.x), this.findOne(".bottom-right").y(y.y)
+                } else if (this._movingAnchorName === "bottom-center") this.findOne(".bottom-right").y(s.y());
+                else if (this._movingAnchorName === "bottom-right") {
+                    if (d) {
+                        var g = v ? {
+                            x: this.width() / 2,
+                            y: this.height() / 2
+                        } : {
+                            x: this.findOne(".top-left").x(),
+                            y: this.findOne(".top-left").y()
+                        };
+                        r = Math.sqrt(Math.pow(s.x() - g.x, 2) + Math.pow(s.y() - g.y, 2));
+                        var p = this.findOne(".bottom-right").x() < g.x ? -1 : 1,
+                            m = this.findOne(".bottom-right").y() < g.y ? -1 : 1;
+                        n = r * this.cos * p, i = r * this.sin * m, this.findOne(".bottom-right").x(g.x + n), this.findOne(".bottom-right").y(g.y + i)
                     }
+                } else console.error(new Error("Wrong position argument of selection resizer: " + this._movingAnchorName));
+                var v = this.centeredScaling() || t.altKey;
+                if (v) {
+                    var b = this.findOne(".top-left"),
+                        x = this.findOne(".bottom-right"),
+                        _ = b.x(),
+                        S = b.y(),
+                        w = this.getWidth() - x.x(),
+                        E = this.getHeight() - x.y();
+                    x.move({
+                        x: -_,
+                        y: -S
+                    }), b.move({
+                        x: w,
+                        y: E
+                    })
                 }
-                this.format()
+                var C = this.findOne(".top-left").getAbsolutePosition();
+                n = C.x, i = C.y;
+                var k = this.findOne(".bottom-right").x() - this.findOne(".top-left").x(),
+                    A = this.findOne(".bottom-right").y() - this.findOne(".top-left").y();
+                this._fitNodesInto({
+                    x: n,
+                    y: i,
+                    width: k,
+                    height: A,
+                    rotation: pe.getAngle(this.rotation())
+                }, t)
             }
-            format() {
-                return this.range = this.set.map(T => T.join(" ").trim()).join("||").trim(), this.range
+        }
+        _handleMouseUp(t) {
+            this._removeEvents(t)
+        }
+        getAbsoluteTransform() {
+            return this.getTransform()
+        }
+        _removeEvents(t) {
+            if (this._transforming) {
+                this._transforming = !1, typeof window < "u" && (window.removeEventListener("mousemove", this._handleMouseMove), window.removeEventListener("touchmove", this._handleMouseMove), window.removeEventListener("mouseup", this._handleMouseUp, !0), window.removeEventListener("touchend", this._handleMouseUp, !0));
+                var n = this.getNode();
+                this._fire("transformend", {
+                    evt: t,
+                    target: n
+                }), n && this._nodes.forEach(i => {
+                    i._fire("transformend", {
+                        evt: t,
+                        target: i
+                    })
+                }), this._movingAnchorName = null
             }
-            toString() {
-                return this.range
+        }
+        _fitNodesInto(t, n) {
+            var i = this._getNodeRect();
+            const r = 1;
+            if (D._inRange(t.width, -this.padding() * 2 - r, r)) {
+                this.update();
+                return
             }
-            parseRange(T) {
-                T = T.trim();
-                const F = ((this.options.includePrerelease && h) | (this.options.loose && d)) + ":" + T,
-                    N = n.get(F);
-                if (N) return N;
-                const P = this.options.loose,
-                    z = P ? o[l.HYPHENRANGELOOSE] : o[l.HYPHENRANGE];
-                T = T.replace(z, k(this.options.includePrerelease)), s("hyphen replace", T), T = T.replace(o[l.COMPARATORTRIM], u), s("comparator trim", T), T = T.replace(o[l.TILDETRIM], c), T = T.replace(o[l.CARETTRIM], f), T = T.split(/\s+/).join(" ");
-                let I = T.split(" ").map(ye => y(ye, this.options)).join(" ").split(/\s+/).map(ye => C(ye, this.options));
-                P && (I = I.filter(ye => (s("loose invalid filter", ye, this.options), !!ye.match(o[l.COMPARATORLOOSE])))), s("range list", I);
-                const Q = new Map,
-                    oe = I.map(ye => new r(ye, this.options));
-                for (const ye of oe) {
-                    if (g(ye)) return [ye];
-                    Q.set(ye.value, ye)
-                }
-                Q.size > 1 && Q.has("") && Q.delete("");
-                const Se = [...Q.values()];
-                return n.set(F, Se), Se
+            if (D._inRange(t.height, -this.padding() * 2 - r, r)) {
+                this.update();
+                return
             }
-            intersects(T, M) {
-                if (!(T instanceof e)) throw new TypeError("a Range is required");
-                return this.set.some(F => m(F, M) && T.set.some(N => m(N, M) && F.every(P => N.every(z => P.intersects(z, M)))))
+            const s = this.flipEnabled();
+            var a = new mr;
+            if (a.rotate(pe.getAngle(this.rotation())), this._movingAnchorName && t.width < 0 && this._movingAnchorName.indexOf("left") >= 0) {
+                const f = a.point({
+                    x: -this.padding() * 2,
+                    y: 0
+                });
+                if (t.x += f.x, t.y += f.y, t.width += this.padding() * 2, this._movingAnchorName = this._movingAnchorName.replace("left", "right"), this._anchorDragOffset.x -= f.x, this._anchorDragOffset.y -= f.y, !s) {
+                    this.update();
+                    return
+                }
+            } else if (this._movingAnchorName && t.width < 0 && this._movingAnchorName.indexOf("right") >= 0) {
+                const f = a.point({
+                    x: this.padding() * 2,
+                    y: 0
+                });
+                if (this._movingAnchorName = this._movingAnchorName.replace("right", "left"), this._anchorDragOffset.x -= f.x, this._anchorDragOffset.y -= f.y, t.width += this.padding() * 2, !s) {
+                    this.update();
+                    return
+                }
             }
-            test(T) {
-                if (!T) return !1;
-                if (typeof T == "string") try {
-                    T = new a(T, this.options)
-                } catch {
-                    return !1
+            if (this._movingAnchorName && t.height < 0 && this._movingAnchorName.indexOf("top") >= 0) {
+                const f = a.point({
+                    x: 0,
+                    y: -this.padding() * 2
+                });
+                if (t.x += f.x, t.y += f.y, this._movingAnchorName = this._movingAnchorName.replace("top", "bottom"), this._anchorDragOffset.x -= f.x, this._anchorDragOffset.y -= f.y, t.height += this.padding() * 2, !s) {
+                    this.update();
+                    return
+                }
+            } else if (this._movingAnchorName && t.height < 0 && this._movingAnchorName.indexOf("bottom") >= 0) {
+                const f = a.point({
+                    x: 0,
+                    y: this.padding() * 2
+                });
+                if (this._movingAnchorName = this._movingAnchorName.replace("bottom", "top"), this._anchorDragOffset.x -= f.x, this._anchorDragOffset.y -= f.y, t.height += this.padding() * 2, !s) {
+                    this.update();
+                    return
                 }
-                for (let M = 0; M < this.set.length; M++)
-                    if (R(this.set[M], T, this.options)) return !0;
-                return !1
             }
+            if (this.boundBoxFunc()) {
+                const f = this.boundBoxFunc()(i, t);
+                f ? t = f : D.warn("boundBoxFunc returned falsy. You should return new bound rect from it!")
+            }
+            const o = 1e7,
+                l = new mr;
+            l.translate(i.x, i.y), l.rotate(i.rotation), l.scale(i.width / o, i.height / o);
+            const u = new mr;
+            u.translate(t.x, t.y), u.rotate(t.rotation), u.scale(t.width / o, t.height / o);
+            const c = u.multiply(l.invert());
+            this._nodes.forEach(f => {
+                var h;
+                const d = f.getParent().getAbsoluteTransform(),
+                    g = f.getTransform().copy();
+                g.translate(f.offsetX(), f.offsetY());
+                const p = new mr;
+                p.multiply(d.copy().invert()).multiply(c).multiply(d).multiply(g);
+                const m = p.decompose();
+                f.setAttrs(m), this._fire("transform", {
+                    evt: n,
+                    target: f
+                }), f._fire("transform", {
+                    evt: n,
+                    target: f
+                }), (h = f.getLayer()) === null || h === void 0 || h.batchDraw()
+            }), this.rotation(D._getRotation(t.rotation)), this._resetTransformCache(), this.update(), this.getLayer().batchDraw()
         }
-        Uv = e;
-        const t = Kye,
-            n = new t({
-                max: 1e3
-            }),
-            i = GC,
-            r = Lve(),
-            s = ay,
-            a = HC,
-            {
-                re: o,
-                t: l,
-                comparatorTrimReplace: u,
-                tildeTrimReplace: c,
-                caretTrimReplace: f
-            } = qC,
-            {
-                FLAG_INCLUDE_PRERELEASE: h,
-                FLAG_LOOSE: d
-            } = WC,
-            g = $ => $.value === "<0.0.0-0",
-            p = $ => $.value === "",
-            m = ($, T) => {
-                let M = !0;
-                const F = $.slice();
-                let N = F.pop();
-                for (; M && F.length;) M = F.every(P => N.intersects(P, T)), N = F.pop();
-                return M
-            },
-            y = ($, T) => (s("comp", $, T), $ = _($, T), s("caret", $), $ = b($, T), s("tildes", $), $ = w($, T), s("xrange", $), $ = A($, T), s("stars", $), $),
-            v = $ => !$ || $.toLowerCase() === "x" || $ === "*",
-            b = ($, T) => $.trim().split(/\s+/).map(M => x(M, T)).join(" "),
-            x = ($, T) => {
-                const M = T.loose ? o[l.TILDELOOSE] : o[l.TILDE];
-                return $.replace(M, (F, N, P, z, I) => {
-                    s("tilde", $, F, N, P, z, I);
-                    let Q;
-                    return v(N) ? Q = "" : v(P) ? Q = `>=${N}.0.0 <${+N+1}.0.0-0` : v(z) ? Q = `>=${N}.${P}.0 <${N}.${+P+1}.0-0` : I ? (s("replaceTilde pr", I), Q = `>=${N}.${P}.${z}-${I} <${N}.${+P+1}.0-0`) : Q = `>=${N}.${P}.${z} <${N}.${+P+1}.0-0`, s("tilde return", Q), Q
-                })
-            },
-            _ = ($, T) => $.trim().split(/\s+/).map(M => S(M, T)).join(" "),
-            S = ($, T) => {
-                s("caret", $, T);
-                const M = T.loose ? o[l.CARETLOOSE] : o[l.CARET],
-                    F = T.includePrerelease ? "-0" : "";
-                return $.replace(M, (N, P, z, I, Q) => {
-                    s("caret", $, N, P, z, I, Q);
-                    let oe;
-                    return v(P) ? oe = "" : v(z) ? oe = `>=${P}.0.0${F} <${+P+1}.0.0-0` : v(I) ? P === "0" ? oe = `>=${P}.${z}.0${F} <${P}.${+z+1}.0-0` : oe = `>=${P}.${z}.0${F} <${+P+1}.0.0-0` : Q ? (s("replaceCaret pr", Q), P === "0" ? z === "0" ? oe = `>=${P}.${z}.${I}-${Q} <${P}.${z}.${+I+1}-0` : oe = `>=${P}.${z}.${I}-${Q} <${P}.${+z+1}.0-0` : oe = `>=${P}.${z}.${I}-${Q} <${+P+1}.0.0-0`) : (s("no pr"), P === "0" ? z === "0" ? oe = `>=${P}.${z}.${I}${F} <${P}.${z}.${+I+1}-0` : oe = `>=${P}.${z}.${I}${F} <${P}.${+z+1}.0-0` : oe = `>=${P}.${z}.${I} <${+P+1}.0.0-0`), s("caret return", oe), oe
-                })
-            },
-            w = ($, T) => (s("replaceXRanges", $, T), $.split(/\s+/).map(M => E(M, T)).join(" ")),
-            E = ($, T) => {
-                $ = $.trim();
-                const M = T.loose ? o[l.XRANGELOOSE] : o[l.XRANGE];
-                return $.replace(M, (F, N, P, z, I, Q) => {
-                    s("xRange", $, F, N, P, z, I, Q);
-                    const oe = v(P),
-                        Se = oe || v(z),
-                        ye = Se || v(I),
-                        Pe = ye;
-                    return N === "=" && Pe && (N = ""), Q = T.includePrerelease ? "-0" : "", oe ? N === ">" || N === "<" ? F = "<0.0.0-0" : F = "*" : N && Pe ? (Se && (z = 0), I = 0, N === ">" ? (N = ">=", Se ? (P = +P + 1, z = 0, I = 0) : (z = +z + 1, I = 0)) : N === "<=" && (N = "<", Se ? P = +P + 1 : z = +z + 1), N === "<" && (Q = "-0"), F = `${N+P}.${z}.${I}${Q}`) : Se ? F = `>=${P}.0.0${Q} <${+P+1}.0.0-0` : ye && (F = `>=${P}.${z}.0${Q} <${P}.${+z+1}.0-0`), s("xRange return", F), F
+        forceUpdate() {
+            this._resetTransformCache(), this.update()
+        }
+        _batchChangeChild(t, n) {
+            this.findOne(t).setAttrs(n)
+        }
+        update() {
+            var t, n = this._getNodeRect();
+            this.rotation(D._getRotation(n.rotation));
+            var i = n.width,
+                r = n.height,
+                s = this.enabledAnchors(),
+                a = this.resizeEnabled(),
+                o = this.padding(),
+                l = this.anchorSize();
+            this.find("._anchor").forEach(u => {
+                u.setAttrs({
+                    width: l,
+                    height: l,
+                    offsetX: l / 2,
+                    offsetY: l / 2,
+                    stroke: this.anchorStroke(),
+                    strokeWidth: this.anchorStrokeWidth(),
+                    fill: this.anchorFill(),
+                    cornerRadius: this.anchorCornerRadius()
                 })
-            },
-            A = ($, T) => (s("replaceStars", $, T), $.trim().replace(o[l.STAR], "")),
-            C = ($, T) => (s("replaceGTE0", $, T), $.trim().replace(o[T.includePrerelease ? l.GTE0PRE : l.GTE0], "")),
-            k = $ => (T, M, F, N, P, z, I, Q, oe, Se, ye, Pe, xt) => (v(F) ? M = "" : v(N) ? M = `>=${F}.0.0${$?"-0":""}` : v(P) ? M = `>=${F}.${N}.0${$?"-0":""}` : z ? M = `>=${M}` : M = `>=${M}${$?"-0":""}`, v(oe) ? Q = "" : v(Se) ? Q = `<${+oe+1}.0.0-0` : v(ye) ? Q = `<${oe}.${+Se+1}.0-0` : Pe ? Q = `<=${oe}.${Se}.${ye}-${Pe}` : $ ? Q = `<${oe}.${Se}.${+ye+1}-0` : Q = `<=${Q}`, `${M} ${Q}`.trim()),
-            R = ($, T, M) => {
-                for (let F = 0; F < $.length; F++)
-                    if (!$[F].test(T)) return !1;
-                if (T.prerelease.length && !M.includePrerelease) {
-                    for (let F = 0; F < $.length; F++)
-                        if (s($[F].semver), $[F].semver !== r.ANY && $[F].semver.prerelease.length > 0) {
-                            const N = $[F].semver;
-                            if (N.major === T.major && N.minor === T.minor && N.patch === T.patch) return !0
-                        } return !1
-                }
-                return !0
-            };
-        return Uv
-    }
-    const Ive = R8(),
-        zve = (e, t, n) => {
-            try {
-                t = new Ive(t, n)
-            } catch {
-                return !1
+            }), this._batchChangeChild(".top-left", {
+                x: 0,
+                y: 0,
+                offsetX: l / 2 + o,
+                offsetY: l / 2 + o,
+                visible: a && s.indexOf("top-left") >= 0
+            }), this._batchChangeChild(".top-center", {
+                x: i / 2,
+                y: 0,
+                offsetY: l / 2 + o,
+                visible: a && s.indexOf("top-center") >= 0
+            }), this._batchChangeChild(".top-right", {
+                x: i,
+                y: 0,
+                offsetX: l / 2 - o,
+                offsetY: l / 2 + o,
+                visible: a && s.indexOf("top-right") >= 0
+            }), this._batchChangeChild(".middle-left", {
+                x: 0,
+                y: r / 2,
+                offsetX: l / 2 + o,
+                visible: a && s.indexOf("middle-left") >= 0
+            }), this._batchChangeChild(".middle-right", {
+                x: i,
+                y: r / 2,
+                offsetX: l / 2 - o,
+                visible: a && s.indexOf("middle-right") >= 0
+            }), this._batchChangeChild(".bottom-left", {
+                x: 0,
+                y: r,
+                offsetX: l / 2 + o,
+                offsetY: l / 2 - o,
+                visible: a && s.indexOf("bottom-left") >= 0
+            }), this._batchChangeChild(".bottom-center", {
+                x: i / 2,
+                y: r,
+                offsetY: l / 2 - o,
+                visible: a && s.indexOf("bottom-center") >= 0
+            }), this._batchChangeChild(".bottom-right", {
+                x: i,
+                y: r,
+                offsetX: l / 2 - o,
+                offsetY: l / 2 - o,
+                visible: a && s.indexOf("bottom-right") >= 0
+            }), this._batchChangeChild(".rotater", {
+                x: i / 2,
+                y: -this.rotateAnchorOffset() * D._sign(r) - o,
+                visible: this.rotateEnabled()
+            }), this._batchChangeChild(".back", {
+                width: i,
+                height: r,
+                visible: this.borderEnabled(),
+                stroke: this.borderStroke(),
+                strokeWidth: this.borderStrokeWidth(),
+                dash: this.borderDash(),
+                x: 0,
+                y: 0
+            }), (t = this.getLayer()) === null || t === void 0 || t.batchDraw()
+        }
+        isTransforming() {
+            return this._transforming
+        }
+        stopTransform() {
+            if (this._transforming) {
+                this._removeEvents();
+                var t = this.findOne("." + this._movingAnchorName);
+                t && t.stopDrag()
             }
-            return t.test(e)
-        };
-    var Bve = zve,
-        D8 = jye(Bve);
-
-    function jve(e, t, n) {
-        const i = e.open(t),
-            r = 1e4,
-            s = 250,
-            {
-                origin: a
-            } = new URL(t);
-        let o = ~~(r / s);
-
-        function l(c) {
-            c.source === i && (o = 0, e.removeEventListener("message", l, !1))
         }
-        e.addEventListener("message", l, !1);
-
-        function u() {
-            o <= 0 || (i.postMessage(n, a), setTimeout(u, s), o -= 1)
+        destroy() {
+            return this.getStage() && this._cursorChange && this.getStage().content && (this.getStage().content.style.cursor = ""), Ic.prototype.destroy.call(this), this.detach(), this._removeEvents(), this
+        }
+        toObject() {
+            return re.prototype.toObject.call(this)
+        }
+        clone(t) {
+            var n = re.prototype.clone.call(this, t);
+            return n
+        }
+        getClientRect() {
+            return this.nodes().length > 0 ? super.getClientRect() : {
+                x: 0,
+                y: 0,
+                width: 0,
+                height: 0
+            }
         }
-        setTimeout(u, s)
     }
-    var Uve = `.vega-embed {
-  position: relative;
-  display: inline-block;
-  box-sizing: border-box;
-}
-.vega-embed.has-actions {
-  padding-right: 38px;
-}
-.vega-embed details:not([open]) > :not(summary) {
-  display: none !important;
-}
-.vega-embed summary {
-  list-style: none;
-  position: absolute;
-  top: 0;
-  right: 0;
-  padding: 6px;
-  z-index: 1000;
-  background: white;
-  box-shadow: 1px 1px 3px rgba(0, 0, 0, 0.1);
-  color: #1b1e23;
-  border: 1px solid #aaa;
-  border-radius: 999px;
-  opacity: 0.2;
-  transition: opacity 0.4s ease-in;
-  cursor: pointer;
-  line-height: 0px;
-}
-.vega-embed summary::-webkit-details-marker {
-  display: none;
-}
-.vega-embed summary:active {
-  box-shadow: #aaa 0px 0px 0px 1px inset;
-}
-.vega-embed summary svg {
-  width: 14px;
-  height: 14px;
-}
-.vega-embed details[open] summary {
-  opacity: 0.7;
-}
-.vega-embed:hover summary, .vega-embed:focus-within summary {
-  opacity: 1 !important;
-  transition: opacity 0.2s ease;
-}
-.vega-embed .vega-actions {
-  position: absolute;
-  z-index: 1001;
-  top: 35px;
-  right: -9px;
-  display: flex;
-  flex-direction: column;
-  padding-bottom: 8px;
-  padding-top: 8px;
-  border-radius: 4px;
-  box-shadow: 0 2px 8px 0 rgba(0, 0, 0, 0.2);
-  border: 1px solid #d9d9d9;
-  background: white;
-  animation-duration: 0.15s;
-  animation-name: scale-in;
-  animation-timing-function: cubic-bezier(0.2, 0, 0.13, 1.5);
-  text-align: left;
-}
-.vega-embed .vega-actions a {
-  padding: 8px 16px;
-  font-family: sans-serif;
-  font-size: 14px;
-  font-weight: 600;
-  white-space: nowrap;
-  color: #434a56;
-  text-decoration: none;
-}
-.vega-embed .vega-actions a:hover, .vega-embed .vega-actions a:focus {
-  background-color: #f7f7f9;
-  color: black;
-}
-.vega-embed .vega-actions::before, .vega-embed .vega-actions::after {
-  content: "";
-  display: inline-block;
-  position: absolute;
-}
-.vega-embed .vega-actions::before {
-  left: auto;
-  right: 14px;
-  top: -16px;
-  border: 8px solid rgba(0, 0, 0, 0);
-  border-bottom-color: #d9d9d9;
-}
-.vega-embed .vega-actions::after {
-  left: auto;
-  right: 15px;
-  top: -14px;
-  border: 7px solid rgba(0, 0, 0, 0);
-  border-bottom-color: #fff;
-}
-.vega-embed .chart-wrapper.fit-x {
-  width: 100%;
-}
-.vega-embed .chart-wrapper.fit-y {
-  height: 100%;
-}
-
-.vega-embed-wrapper {
-  max-width: 100%;
-  overflow: auto;
-  padding-right: 14px;
-}
-
-@keyframes scale-in {
-  from {
-    opacity: 0;
-    transform: scale(0.6);
-  }
-  to {
-    opacity: 1;
-    transform: scale(1);
-  }
-}
-`;
 
-    function N8(e, ...t) {
-        for (const n of t) Gve(e, n);
-        return e
+    function M2e(e) {
+        return e instanceof Array || D.warn("enabledAnchors value should be an array"), e instanceof Array && e.forEach(function(t) {
+            D0.indexOf(t) === -1 && D.warn("Unknown anchor name: " + t + ". Available names are: " + D0.join(", "))
+        }), e || []
+    }
+    at.prototype.className = "Transformer";
+    Mt(at);
+    O.addGetterSetter(at, "enabledAnchors", D0, M2e);
+    O.addGetterSetter(at, "flipEnabled", !0, zr());
+    O.addGetterSetter(at, "resizeEnabled", !0);
+    O.addGetterSetter(at, "anchorSize", 10, se());
+    O.addGetterSetter(at, "rotateEnabled", !0);
+    O.addGetterSetter(at, "rotationSnaps", []);
+    O.addGetterSetter(at, "rotateAnchorOffset", 50, se());
+    O.addGetterSetter(at, "rotationSnapTolerance", 5, se());
+    O.addGetterSetter(at, "borderEnabled", !0);
+    O.addGetterSetter(at, "anchorStroke", "rgb(0, 161, 255)");
+    O.addGetterSetter(at, "anchorStrokeWidth", 1, se());
+    O.addGetterSetter(at, "anchorFill", "white");
+    O.addGetterSetter(at, "anchorCornerRadius", 0, se());
+    O.addGetterSetter(at, "borderStroke", "rgb(0, 161, 255)");
+    O.addGetterSetter(at, "borderStrokeWidth", 1, se());
+    O.addGetterSetter(at, "borderDash");
+    O.addGetterSetter(at, "keepRatio", !0);
+    O.addGetterSetter(at, "centeredScaling", !1);
+    O.addGetterSetter(at, "ignoreStroke", !1);
+    O.addGetterSetter(at, "padding", 0, se());
+    O.addGetterSetter(at, "node");
+    O.addGetterSetter(at, "nodes");
+    O.addGetterSetter(at, "boundBoxFunc");
+    O.addGetterSetter(at, "anchorDragBoundFunc");
+    O.addGetterSetter(at, "shouldOverdrawWholeArea", !1);
+    O.addGetterSetter(at, "useSingleNodeRotation", !0);
+    O.backCompat(at, {
+        lineEnabled: "borderEnabled",
+        rotateHandlerOffset: "rotateAnchorOffset",
+        enabledHandlers: "enabledAnchors"
+    });
+    class ya extends Q {
+        _sceneFunc(t) {
+            t.beginPath(), t.arc(0, 0, this.radius(), 0, pe.getAngle(this.angle()), this.clockwise()), t.lineTo(0, 0), t.closePath(), t.fillStrokeShape(this)
+        }
+        getWidth() {
+            return this.radius() * 2
+        }
+        getHeight() {
+            return this.radius() * 2
+        }
+        setWidth(t) {
+            this.radius(t / 2)
+        }
+        setHeight(t) {
+            this.radius(t / 2)
+        }
     }
+    ya.prototype.className = "Wedge";
+    ya.prototype._centroid = !0;
+    ya.prototype._attrsAffectingSize = ["radius"];
+    Mt(ya);
+    O.addGetterSetter(ya, "radius", 0, se());
+    O.addGetterSetter(ya, "angle", 0, se());
+    O.addGetterSetter(ya, "clockwise", !1);
+    O.backCompat(ya, {
+        angleDeg: "angle",
+        getAngleDeg: "getAngle",
+        setAngleDeg: "setAngle"
+    });
 
-    function Gve(e, t) {
-        for (const n of Object.keys(t)) xc(e, n, t[n], !0)
+    function cO() {
+        this.r = 0, this.g = 0, this.b = 0, this.a = 0, this.next = null
     }
+    var O2e = [512, 512, 456, 512, 328, 456, 335, 512, 405, 328, 271, 456, 388, 335, 292, 512, 454, 405, 364, 328, 298, 271, 496, 456, 420, 388, 360, 335, 312, 292, 273, 512, 482, 454, 428, 405, 383, 364, 345, 328, 312, 298, 284, 271, 259, 496, 475, 456, 437, 420, 404, 388, 374, 360, 347, 335, 323, 312, 302, 292, 282, 273, 265, 512, 497, 482, 468, 454, 441, 428, 417, 405, 394, 383, 373, 364, 354, 345, 337, 328, 320, 312, 305, 298, 291, 284, 278, 271, 265, 259, 507, 496, 485, 475, 465, 456, 446, 437, 428, 420, 412, 404, 396, 388, 381, 374, 367, 360, 354, 347, 341, 335, 329, 323, 318, 312, 307, 302, 297, 292, 287, 282, 278, 273, 269, 265, 261, 512, 505, 497, 489, 482, 475, 468, 461, 454, 447, 441, 435, 428, 422, 417, 411, 405, 399, 394, 389, 383, 378, 373, 368, 364, 359, 354, 350, 345, 341, 337, 332, 328, 324, 320, 316, 312, 309, 305, 301, 298, 294, 291, 287, 284, 281, 278, 274, 271, 268, 265, 262, 259, 257, 507, 501, 496, 491, 485, 480, 475, 470, 465, 460, 456, 451, 446, 442, 437, 433, 428, 424, 420, 416, 412, 408, 404, 400, 396, 392, 388, 385, 381, 377, 374, 370, 367, 363, 360, 357, 354, 350, 347, 344, 341, 338, 335, 332, 329, 326, 323, 320, 318, 315, 312, 310, 307, 304, 302, 299, 297, 294, 292, 289, 287, 285, 282, 280, 278, 275, 273, 271, 269, 267, 265, 263, 261, 259],
+        F2e = [9, 11, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24];
 
-    function iM(e, t) {
-        var n = Object.keys(e);
-        if (Object.getOwnPropertySymbols) {
-            var i = Object.getOwnPropertySymbols(e);
-            t && (i = i.filter(function(r) {
-                return Object.getOwnPropertyDescriptor(e, r).enumerable
-            })), n.push.apply(n, i)
+    function R2e(e, t) {
+        var n = e.data,
+            i = e.width,
+            r = e.height,
+            s, a, o, l, u, c, f, h, d, g, p, m, y, v, b, x, _, S, w, E, C, k, A, F, $ = t + t + 1,
+            T = i - 1,
+            M = r - 1,
+            R = t + 1,
+            N = R * (R + 1) / 2,
+            L = new cO,
+            I = null,
+            G = L,
+            ie = null,
+            ge = null,
+            Re = O2e[t],
+            Te = F2e[t];
+        for (o = 1; o < $; o++) G = G.next = new cO, o === R && (I = G);
+        for (G.next = L, f = c = 0, a = 0; a < r; a++) {
+            for (x = _ = S = w = h = d = g = p = 0, m = R * (E = n[c]), y = R * (C = n[c + 1]), v = R * (k = n[c + 2]), b = R * (A = n[c + 3]), h += N * E, d += N * C, g += N * k, p += N * A, G = L, o = 0; o < R; o++) G.r = E, G.g = C, G.b = k, G.a = A, G = G.next;
+            for (o = 1; o < R; o++) l = c + ((T < o ? T : o) << 2), h += (G.r = E = n[l]) * (F = R - o), d += (G.g = C = n[l + 1]) * F, g += (G.b = k = n[l + 2]) * F, p += (G.a = A = n[l + 3]) * F, x += E, _ += C, S += k, w += A, G = G.next;
+            for (ie = L, ge = I, s = 0; s < i; s++) n[c + 3] = A = p * Re >> Te, A !== 0 ? (A = 255 / A, n[c] = (h * Re >> Te) * A, n[c + 1] = (d * Re >> Te) * A, n[c + 2] = (g * Re >> Te) * A) : n[c] = n[c + 1] = n[c + 2] = 0, h -= m, d -= y, g -= v, p -= b, m -= ie.r, y -= ie.g, v -= ie.b, b -= ie.a, l = f + ((l = s + t + 1) < T ? l : T) << 2, x += ie.r = n[l], _ += ie.g = n[l + 1], S += ie.b = n[l + 2], w += ie.a = n[l + 3], h += x, d += _, g += S, p += w, ie = ie.next, m += E = ge.r, y += C = ge.g, v += k = ge.b, b += A = ge.a, x -= E, _ -= C, S -= k, w -= A, ge = ge.next, c += 4;
+            f += i
+        }
+        for (s = 0; s < i; s++) {
+            for (_ = S = w = x = d = g = p = h = 0, c = s << 2, m = R * (E = n[c]), y = R * (C = n[c + 1]), v = R * (k = n[c + 2]), b = R * (A = n[c + 3]), h += N * E, d += N * C, g += N * k, p += N * A, G = L, o = 0; o < R; o++) G.r = E, G.g = C, G.b = k, G.a = A, G = G.next;
+            for (u = i, o = 1; o <= t; o++) c = u + s << 2, h += (G.r = E = n[c]) * (F = R - o), d += (G.g = C = n[c + 1]) * F, g += (G.b = k = n[c + 2]) * F, p += (G.a = A = n[c + 3]) * F, x += E, _ += C, S += k, w += A, G = G.next, o < M && (u += i);
+            for (c = s, ie = L, ge = I, a = 0; a < r; a++) l = c << 2, n[l + 3] = A = p * Re >> Te, A > 0 ? (A = 255 / A, n[l] = (h * Re >> Te) * A, n[l + 1] = (d * Re >> Te) * A, n[l + 2] = (g * Re >> Te) * A) : n[l] = n[l + 1] = n[l + 2] = 0, h -= m, d -= y, g -= v, p -= b, m -= ie.r, y -= ie.g, v -= ie.b, b -= ie.a, l = s + ((l = a + R) < M ? l : M) * i << 2, h += x += ie.r = n[l], d += _ += ie.g = n[l + 1], g += S += ie.b = n[l + 2], p += w += ie.a = n[l + 3], ie = ie.next, m += E = ge.r, y += C = ge.g, v += k = ge.b, b += A = ge.a, x -= E, _ -= C, S -= k, w -= A, ge = ge.next, c += i
         }
-        return n
     }
-
-    function Ta(e) {
-        for (var t = 1; t < arguments.length; t++) {
-            var n = arguments[t] != null ? arguments[t] : {};
-            t % 2 ? iM(Object(n), !0).forEach(function(i) {
-                Bye(e, i, n[i])
-            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : iM(Object(n)).forEach(function(i) {
-                Object.defineProperty(e, i, Object.getOwnPropertyDescriptor(n, i))
-            })
+    const D2e = function(t) {
+        var n = Math.round(this.blurRadius());
+        n > 0 && R2e(t, n)
+    };
+    O.addGetterSetter(re, "blurRadius", 0, se(), O.afterSetFilter);
+    const N2e = function(e) {
+        var t = this.brightness() * 255,
+            n = e.data,
+            i = n.length,
+            r;
+        for (r = 0; r < i; r += 4) n[r] += t, n[r + 1] += t, n[r + 2] += t
+    };
+    O.addGetterSetter(re, "brightness", 0, se(), O.afterSetFilter);
+    const P2e = function(e) {
+        var t = Math.pow((this.contrast() + 100) / 100, 2),
+            n = e.data,
+            i = n.length,
+            r = 150,
+            s = 150,
+            a = 150,
+            o;
+        for (o = 0; o < i; o += 4) r = n[o], s = n[o + 1], a = n[o + 2], r /= 255, r -= .5, r *= t, r += .5, r *= 255, s /= 255, s -= .5, s *= t, s += .5, s *= 255, a /= 255, a -= .5, a *= t, a += .5, a *= 255, r = r < 0 ? 0 : r > 255 ? 255 : r, s = s < 0 ? 0 : s > 255 ? 255 : s, a = a < 0 ? 0 : a > 255 ? 255 : a, n[o] = r, n[o + 1] = s, n[o + 2] = a
+    };
+    O.addGetterSetter(re, "contrast", 0, se(), O.afterSetFilter);
+    const L2e = function(e) {
+        var t = this.embossStrength() * 10,
+            n = this.embossWhiteLevel() * 255,
+            i = this.embossDirection(),
+            r = this.embossBlend(),
+            s = 0,
+            a = 0,
+            o = e.data,
+            l = e.width,
+            u = e.height,
+            c = l * 4,
+            f = u;
+        switch (i) {
+            case "top-left":
+                s = -1, a = -1;
+                break;
+            case "top":
+                s = -1, a = 0;
+                break;
+            case "top-right":
+                s = -1, a = 1;
+                break;
+            case "right":
+                s = 0, a = 1;
+                break;
+            case "bottom-right":
+                s = 1, a = 1;
+                break;
+            case "bottom":
+                s = 1, a = 0;
+                break;
+            case "bottom-left":
+                s = 1, a = -1;
+                break;
+            case "left":
+                s = 0, a = -1;
+                break;
+            default:
+                D.error("Unknown emboss direction: " + i)
         }
-        return e
+        do {
+            var h = (f - 1) * c,
+                d = s;
+            f + d < 1 && (d = 0), f + d > u && (d = 0);
+            var g = (f - 1 + d) * l * 4,
+                p = l;
+            do {
+                var m = h + (p - 1) * 4,
+                    y = a;
+                p + y < 1 && (y = 0), p + y > l && (y = 0);
+                var v = g + (p - 1 + y) * 4,
+                    b = o[m] - o[v],
+                    x = o[m + 1] - o[v + 1],
+                    _ = o[m + 2] - o[v + 2],
+                    S = b,
+                    w = S > 0 ? S : -S,
+                    E = x > 0 ? x : -x,
+                    C = _ > 0 ? _ : -_;
+                if (E > w && (S = x), C > w && (S = _), S *= t, r) {
+                    var k = o[m] + S,
+                        A = o[m + 1] + S,
+                        F = o[m + 2] + S;
+                    o[m] = k > 255 ? 255 : k < 0 ? 0 : k, o[m + 1] = A > 255 ? 255 : A < 0 ? 0 : A, o[m + 2] = F > 255 ? 255 : F < 0 ? 0 : F
+                } else {
+                    var $ = n - S;
+                    $ < 0 ? $ = 0 : $ > 255 && ($ = 255), o[m] = o[m + 1] = o[m + 2] = $
+                }
+            } while (--p)
+        } while (--f)
+    };
+    O.addGetterSetter(re, "embossStrength", .5, se(), O.afterSetFilter);
+    O.addGetterSetter(re, "embossWhiteLevel", .5, se(), O.afterSetFilter);
+    O.addGetterSetter(re, "embossDirection", "top-left", null, O.afterSetFilter);
+    O.addGetterSetter(re, "embossBlend", !1, null, O.afterSetFilter);
+
+    function $b(e, t, n, i, r) {
+        var s = n - t,
+            a = r - i,
+            o;
+        return s === 0 ? i + a / 2 : a === 0 ? i : (o = (e - t) / s, o = a * o + i, o)
     }
-    const Hi = Sue;
-    let Yh = T1e;
-    const Ig = typeof window < "u" ? window : void 0;
-    var wM;
-    Yh === void 0 && ((wM = Ig == null ? void 0 : Ig.vl) != null && wM.compile) && (Yh = Ig.vl);
-    const Wve = {
-            export: {
-                svg: !0,
-                png: !0
-            },
-            source: !0,
-            compiled: !0,
-            editor: !0
-        },
-        qve = {
-            CLICK_TO_VIEW_ACTIONS: "Click to view actions",
-            COMPILED_ACTION: "View Compiled Vega",
-            EDITOR_ACTION: "Open in Vega Editor",
-            PNG_ACTION: "Save as PNG",
-            SOURCE_ACTION: "View Source",
-            SVG_ACTION: "Save as SVG"
-        },
-        qf = {
-            vega: "Vega",
-            "vega-lite": "Vega-Lite"
-        },
-        Q0 = {
-            vega: Hi.version,
-            "vega-lite": Yh ? Yh.version : "not available"
+    const I2e = function(e) {
+        var t = e.data,
+            n = t.length,
+            i = t[0],
+            r = i,
+            s, a = t[1],
+            o = a,
+            l, u = t[2],
+            c = u,
+            f, h, d = this.enhance();
+        if (d !== 0) {
+            for (h = 0; h < n; h += 4) s = t[h + 0], s < i ? i = s : s > r && (r = s), l = t[h + 1], l < a ? a = l : l > o && (o = l), f = t[h + 2], f < u ? u = f : f > c && (c = f);
+            r === i && (r = 255, i = 0), o === a && (o = 255, a = 0), c === u && (c = 255, u = 0);
+            var g, p, m, y, v, b, x, _, S;
+            for (d > 0 ? (p = r + d * (255 - r), m = i - d * (i - 0), v = o + d * (255 - o), b = a - d * (a - 0), _ = c + d * (255 - c), S = u - d * (u - 0)) : (g = (r + i) * .5, p = r + d * (r - g), m = i + d * (i - g), y = (o + a) * .5, v = o + d * (o - y), b = a + d * (a - y), x = (c + u) * .5, _ = c + d * (c - x), S = u + d * (u - x)), h = 0; h < n; h += 4) t[h + 0] = $b(t[h + 0], i, r, m, p), t[h + 1] = $b(t[h + 1], a, o, b, v), t[h + 2] = $b(t[h + 2], u, c, S, _)
+        }
+    };
+    O.addGetterSetter(re, "enhance", 0, se(), O.afterSetFilter);
+    const z2e = function(e) {
+        var t = e.data,
+            n = t.length,
+            i, r;
+        for (i = 0; i < n; i += 4) r = .34 * t[i] + .5 * t[i + 1] + .16 * t[i + 2], t[i] = r, t[i + 1] = r, t[i + 2] = r
+    };
+    O.addGetterSetter(re, "hue", 0, se(), O.afterSetFilter);
+    O.addGetterSetter(re, "saturation", 0, se(), O.afterSetFilter);
+    O.addGetterSetter(re, "luminance", 0, se(), O.afterSetFilter);
+    const B2e = function(e) {
+            var t = e.data,
+                n = t.length,
+                i = 1,
+                r = Math.pow(2, this.saturation()),
+                s = Math.abs(this.hue() + 360) % 360,
+                a = this.luminance() * 127,
+                o, l = i * r * Math.cos(s * Math.PI / 180),
+                u = i * r * Math.sin(s * Math.PI / 180),
+                c = .299 * i + .701 * l + .167 * u,
+                f = .587 * i - .587 * l + .33 * u,
+                h = .114 * i - .114 * l - .497 * u,
+                d = .299 * i - .299 * l - .328 * u,
+                g = .587 * i + .413 * l + .035 * u,
+                p = .114 * i - .114 * l + .293 * u,
+                m = .299 * i - .3 * l + 1.25 * u,
+                y = .587 * i - .586 * l - 1.05 * u,
+                v = .114 * i + .886 * l - .2 * u,
+                b, x, _, S;
+            for (o = 0; o < n; o += 4) b = t[o + 0], x = t[o + 1], _ = t[o + 2], S = t[o + 3], t[o + 0] = c * b + f * x + h * _ + a, t[o + 1] = d * b + g * x + p * _ + a, t[o + 2] = m * b + y * x + v * _ + a, t[o + 3] = S
         },
-        Hve = {
-            vega: e => e,
-            "vega-lite": (e, t) => Yh.compile(e, {
-                config: t
-            }).spec
+        j2e = function(e) {
+            var t = e.data,
+                n = t.length,
+                i = Math.pow(2, this.value()),
+                r = Math.pow(2, this.saturation()),
+                s = Math.abs(this.hue() + 360) % 360,
+                a, o = i * r * Math.cos(s * Math.PI / 180),
+                l = i * r * Math.sin(s * Math.PI / 180),
+                u = .299 * i + .701 * o + .167 * l,
+                c = .587 * i - .587 * o + .33 * l,
+                f = .114 * i - .114 * o - .497 * l,
+                h = .299 * i - .299 * o - .328 * l,
+                d = .587 * i + .413 * o + .035 * l,
+                g = .114 * i - .114 * o + .293 * l,
+                p = .299 * i - .3 * o + 1.25 * l,
+                m = .587 * i - .586 * o - 1.05 * l,
+                y = .114 * i + .886 * o - .2 * l,
+                v, b, x, _;
+            for (a = 0; a < n; a += 4) v = t[a + 0], b = t[a + 1], x = t[a + 2], _ = t[a + 3], t[a + 0] = u * v + c * b + f * x, t[a + 1] = h * v + d * b + g * x, t[a + 2] = p * v + m * b + y * x, t[a + 3] = _
+        };
+    O.addGetterSetter(re, "hue", 0, se(), O.afterSetFilter);
+    O.addGetterSetter(re, "saturation", 0, se(), O.afterSetFilter);
+    O.addGetterSetter(re, "value", 0, se(), O.afterSetFilter);
+    const G2e = function(e) {
+        var t = e.data,
+            n = t.length,
+            i;
+        for (i = 0; i < n; i += 4) t[i] = 255 - t[i], t[i + 1] = 255 - t[i + 1], t[i + 2] = 255 - t[i + 2]
+    };
+    var U2e = function(e, t, n) {
+            var i = e.data,
+                r = t.data,
+                s = e.width,
+                a = e.height,
+                o = n.polarCenterX || s / 2,
+                l = n.polarCenterY || a / 2,
+                u, c, f, h = 0,
+                d = 0,
+                g = 0,
+                p = 0,
+                m, y = Math.sqrt(o * o + l * l);
+            c = s - o, f = a - l, m = Math.sqrt(c * c + f * f), y = m > y ? m : y;
+            var v = a,
+                b = s,
+                x, _, S = 360 / b * Math.PI / 180,
+                w, E;
+            for (_ = 0; _ < b; _ += 1)
+                for (w = Math.sin(_ * S), E = Math.cos(_ * S), x = 0; x < v; x += 1) c = Math.floor(o + y * x / v * E), f = Math.floor(l + y * x / v * w), u = (f * s + c) * 4, h = i[u + 0], d = i[u + 1], g = i[u + 2], p = i[u + 3], u = (_ + x * s) * 4, r[u + 0] = h, r[u + 1] = d, r[u + 2] = g, r[u + 3] = p
         },
-        Yve = `
-<svg viewBox="0 0 16 16" fill="currentColor" stroke="none" stroke-width="1" stroke-linecap="round" stroke-linejoin="round">
-  <circle r="2" cy="8" cx="2"></circle>
-  <circle r="2" cy="8" cx="8"></circle>
-  <circle r="2" cy="8" cx="14"></circle>
-</svg>`,
-        Xve = "chart-wrapper";
+        W2e = function(e, t, n) {
+            var i = e.data,
+                r = t.data,
+                s = e.width,
+                a = e.height,
+                o = n.polarCenterX || s / 2,
+                l = n.polarCenterY || a / 2,
+                u, c, f, h, d, g = 0,
+                p = 0,
+                m = 0,
+                y = 0,
+                v, b = Math.sqrt(o * o + l * l);
+            c = s - o, f = a - l, v = Math.sqrt(c * c + f * f), b = v > b ? v : b;
+            var x = a,
+                _ = s,
+                S, w, E = n.polarRotation || 0,
+                C, k;
+            for (c = 0; c < s; c += 1)
+                for (f = 0; f < a; f += 1) h = c - o, d = f - l, S = Math.sqrt(h * h + d * d) * x / b, w = (Math.atan2(d, h) * 180 / Math.PI + 360 + E) % 360, w = w * _ / 360, C = Math.floor(w), k = Math.floor(S), u = (k * s + C) * 4, g = i[u + 0], p = i[u + 1], m = i[u + 2], y = i[u + 3], u = (f * s + c) * 4, r[u + 0] = g, r[u + 1] = p, r[u + 2] = m, r[u + 3] = y
+        };
+    const q2e = function(e) {
+        var t = e.width,
+            n = e.height,
+            i, r, s, a, o, l, u, c, f, h, d = Math.round(this.kaleidoscopePower()),
+            g = Math.round(this.kaleidoscopeAngle()),
+            p = Math.floor(t * (g % 360) / 360);
+        if (!(d < 1)) {
+            var m = D.createCanvasElement();
+            m.width = t, m.height = n;
+            var y = m.getContext("2d").getImageData(0, 0, t, n);
+            D.releaseCanvas(m), U2e(e, y, {
+                polarCenterX: t / 2,
+                polarCenterY: n / 2
+            });
+            for (var v = t / Math.pow(2, d); v <= 8;) v = v * 2, d -= 1;
+            v = Math.ceil(v);
+            var b = v,
+                x = 0,
+                _ = b,
+                S = 1;
+            for (p + v > t && (x = b, _ = 0, S = -1), r = 0; r < n; r += 1)
+                for (i = x; i !== _; i += S) s = Math.round(i + p) % t, f = (t * r + s) * 4, o = y.data[f + 0], l = y.data[f + 1], u = y.data[f + 2], c = y.data[f + 3], h = (t * r + i) * 4, y.data[h + 0] = o, y.data[h + 1] = l, y.data[h + 2] = u, y.data[h + 3] = c;
+            for (r = 0; r < n; r += 1)
+                for (b = Math.floor(v), a = 0; a < d; a += 1) {
+                    for (i = 0; i < b + 1; i += 1) f = (t * r + i) * 4, o = y.data[f + 0], l = y.data[f + 1], u = y.data[f + 2], c = y.data[f + 3], h = (t * r + b * 2 - i - 1) * 4, y.data[h + 0] = o, y.data[h + 1] = l, y.data[h + 2] = u, y.data[h + 3] = c;
+                    b *= 2
+                }
+            W2e(y, e, {
+                polarRotation: 0
+            })
+        }
+    };
+    O.addGetterSetter(re, "kaleidoscopePower", 2, se(), O.afterSetFilter);
+    O.addGetterSetter(re, "kaleidoscopeAngle", 0, se(), O.afterSetFilter);
 
-    function Vve(e) {
-        return typeof e == "function"
+    function mp(e, t, n) {
+        var i = (n * e.width + t) * 4,
+            r = [];
+        return r.push(e.data[i++], e.data[i++], e.data[i++], e.data[i++]), r
     }
 
-    function rM(e, t, n, i) {
-        const r = `<html><head>${t}</head><body><pre><code class="json">`,
-            s = `</code></pre>${n}</body></html>`,
-            a = window.open("");
-        a.document.write(r + e + s), a.document.title = `${qf[i]} JSON Source`
+    function Hf(e, t) {
+        return Math.sqrt(Math.pow(e[0] - t[0], 2) + Math.pow(e[1] - t[1], 2) + Math.pow(e[2] - t[2], 2))
     }
 
-    function Kve(e, t) {
-        if (e.$schema) {
-            const n = A8(e.$schema);
-            t && t !== n.library && console.warn(`The given visualization spec is written in ${qf[n.library]}, but mode argument sets ${qf[t]??t}.`);
-            const i = n.library;
-            return D8(Q0[i], `^${n.version.slice(1)}`) || console.warn(`The input spec uses ${qf[i]} ${n.version}, but the current version of ${qf[i]} is v${Q0[i]}.`), i
-        }
-        return "mark" in e || "encoding" in e || "layer" in e || "hconcat" in e || "vconcat" in e || "facet" in e || "repeat" in e ? "vega-lite" : "marks" in e || "signals" in e || "scales" in e || "axes" in e ? "vega" : t ?? "vega"
+    function H2e(e) {
+        for (var t = [0, 0, 0], n = 0; n < e.length; n++) t[0] += e[n][0], t[1] += e[n][1], t[2] += e[n][2];
+        return t[0] /= e.length, t[1] /= e.length, t[2] /= e.length, t
     }
 
-    function Jve(e) {
-        return !!(e && "load" in e)
+    function Y2e(e, t) {
+        var n = mp(e, 0, 0),
+            i = mp(e, e.width - 1, 0),
+            r = mp(e, 0, e.height - 1),
+            s = mp(e, e.width - 1, e.height - 1),
+            a = t || 10;
+        if (Hf(n, i) < a && Hf(i, s) < a && Hf(s, r) < a && Hf(r, n) < a) {
+            for (var o = H2e([i, n, s, r]), l = [], u = 0; u < e.width * e.height; u++) {
+                var c = Hf(o, [e.data[u * 4], e.data[u * 4 + 1], e.data[u * 4 + 2]]);
+                l[u] = c < a ? 0 : 255
+            }
+            return l
+        }
     }
 
-    function sM(e) {
-        return Jve(e) ? e : Hi.loader(e)
+    function X2e(e, t) {
+        for (var n = 0; n < e.width * e.height; n++) e.data[4 * n + 3] = t[n]
     }
 
-    function Qve(e) {
-        var n;
-        const t = ((n = e.usermeta) == null ? void 0 : n.embedOptions) ?? {};
-        return re(t.defaultStyle) && (t.defaultStyle = !1), t
-    }
-    async function Zve(e, t, n = {}) {
-        let i, r;
-        re(t) ? (r = sM(n.loader), i = JSON.parse(await r.load(t))) : i = t;
-        const s = Qve(i),
-            a = s.loader;
-        (!r || a) && (r = sM(n.loader ?? a));
-        const o = await aM(s, r),
-            l = await aM(n, r),
-            u = Ta(Ta({}, N8(l, o)), {}, {
-                config: bc(l.config ?? {}, o.config ?? {})
-            });
-        return await tbe(e, i, u, r)
-    }
-    async function aM(e, t) {
-        const n = re(e.config) ? JSON.parse(await t.load(e.config)) : e.config ?? {},
-            i = re(e.patch) ? JSON.parse(await t.load(e.patch)) : e.patch;
-        return Ta(Ta(Ta({}, e), i ? {
-            patch: i
-        } : {}), n ? {
-            config: n
-        } : {})
+    function V2e(e, t, n) {
+        for (var i = [1, 1, 1, 1, 0, 1, 1, 1, 1], r = Math.round(Math.sqrt(i.length)), s = Math.floor(r / 2), a = [], o = 0; o < n; o++)
+            for (var l = 0; l < t; l++) {
+                for (var u = o * t + l, c = 0, f = 0; f < r; f++)
+                    for (var h = 0; h < r; h++) {
+                        var d = o + f - s,
+                            g = l + h - s;
+                        if (d >= 0 && d < n && g >= 0 && g < t) {
+                            var p = d * t + g,
+                                m = i[f * r + h];
+                            c += e[p] * m
+                        }
+                    }
+                a[u] = c === 255 * 8 ? 255 : 0
+            }
+        return a
     }
 
-    function ebe(e) {
-        const t = e.getRootNode ? e.getRootNode() : document;
-        return t instanceof ShadowRoot ? {
-            root: t,
-            rootContainer: t
-        } : {
-            root: document,
-            rootContainer: document.head ?? document.body
-        }
-    }
-    async function tbe(e, t, n = {}, i) {
-        const r = n.theme ? bc(Sye[n.theme], n.config ?? {}) : n.config,
-            s = Za(n.actions) ? n.actions : N8({}, Wve, n.actions ?? {}),
-            a = Ta(Ta({}, qve), n.i18n),
-            o = n.renderer ?? "canvas",
-            l = n.logLevel ?? Hi.Warn,
-            u = n.downloadFileName ?? "visualization",
-            c = typeof e == "string" ? document.querySelector(e) : e;
-        if (!c) throw new Error(`${e} does not exist`);
-        if (n.defaultStyle !== !1) {
-            const _ = "vega-embed-style",
-                {
-                    root: S,
-                    rootContainer: w
-                } = ebe(c);
-            if (!S.getElementById(_)) {
-                const E = document.createElement("style");
-                E.id = _, E.innerHTML = n.defaultStyle === void 0 || n.defaultStyle === !0 ? Uve.toString() : n.defaultStyle, w.appendChild(E)
-            }
-        }
-        const f = Kve(t, n.mode);
-        let h = Hve[f](t, r);
-        if (f === "vega-lite" && h.$schema) {
-            const _ = A8(h.$schema);
-            D8(Q0.vega, `^${_.version.slice(1)}`) || console.warn(`The compiled spec uses Vega ${_.version}, but current version is v${Q0.vega}.`)
-        }
-        c.classList.add("vega-embed"), s && c.classList.add("has-actions"), c.innerHTML = "";
-        let d = c;
-        if (s) {
-            const _ = document.createElement("div");
-            _.classList.add(Xve), c.appendChild(_), d = _
-        }
-        const g = n.patch;
-        if (g && (h = g instanceof Function ? g(h) : Em(h, g, !0, !1).newDocument), n.formatLocale && Hi.formatLocale(n.formatLocale), n.timeFormatLocale && Hi.timeFormatLocale(n.timeFormatLocale), n.expressionFunctions)
-            for (const _ in n.expressionFunctions) {
-                const S = n.expressionFunctions[_];
-                "fn" in S ? Hi.expressionFunction(_, S.fn, S.visitor) : S instanceof Function && Hi.expressionFunction(_, S)
-            }
-        const {
-            ast: p
-        } = n, m = Hi.parse(h, f === "vega-lite" ? {} : r, {
-            ast: p
-        }), y = new(n.viewClass || Hi.View)(m, Ta({
-            loader: i,
-            logLevel: l,
-            renderer: o
-        }, p ? {
-            expr: Hi.expressionInterpreter ?? n.expr ?? Rue
-        } : {}));
-        if (y.addSignalListener("autosize", (_, S) => {
-                const {
-                    type: w
-                } = S;
-                w == "fit-x" ? (d.classList.add("fit-x"), d.classList.remove("fit-y")) : w == "fit-y" ? (d.classList.remove("fit-x"), d.classList.add("fit-y")) : w == "fit" ? d.classList.add("fit-x", "fit-y") : d.classList.remove("fit-x", "fit-y")
-            }), n.tooltip !== !1) {
-            const _ = Vve(n.tooltip) ? n.tooltip : new Lye(n.tooltip === !0 ? {} : n.tooltip).call;
-            y.tooltip(_)
-        }
-        let {
-            hover: v
-        } = n;
-        if (v === void 0 && (v = f === "vega"), v) {
-            const {
-                hoverSet: _,
-                updateSet: S
-            } = typeof v == "boolean" ? {} : v;
-            y.hover(_, S)
-        }
-        n && (n.width != null && y.width(n.width), n.height != null && y.height(n.height), n.padding != null && y.padding(n.padding)), await y.initialize(d, n.bind).runAsync();
-        let b;
-        if (s !== !1) {
-            let _ = c;
-            if (n.defaultStyle !== !1) {
-                const w = document.createElement("details");
-                w.title = a.CLICK_TO_VIEW_ACTIONS, c.append(w), _ = w;
-                const E = document.createElement("summary");
-                E.innerHTML = Yve, w.append(E), b = A => {
-                    w.contains(A.target) || w.removeAttribute("open")
-                }, document.addEventListener("click", b)
-            }
-            const S = document.createElement("div");
-            if (_.append(S), S.classList.add("vega-actions"), s === !0 || s.export !== !1) {
-                for (const w of ["svg", "png"])
-                    if (s === !0 || s.export === !0 || s.export[w]) {
-                        const E = a[`${w.toUpperCase()}_ACTION`],
-                            A = document.createElement("a"),
-                            C = ae(n.scaleFactor) ? n.scaleFactor[w] : n.scaleFactor;
-                        A.text = E, A.href = "#", A.target = "_blank", A.download = `${u}.${w}`, A.addEventListener("mousedown", async function(k) {
-                            k.preventDefault();
-                            const R = await y.toImageURL(w, C);
-                            this.href = R
-                        }), S.append(A)
+    function K2e(e, t, n) {
+        for (var i = [1, 1, 1, 1, 1, 1, 1, 1, 1], r = Math.round(Math.sqrt(i.length)), s = Math.floor(r / 2), a = [], o = 0; o < n; o++)
+            for (var l = 0; l < t; l++) {
+                for (var u = o * t + l, c = 0, f = 0; f < r; f++)
+                    for (var h = 0; h < r; h++) {
+                        var d = o + f - s,
+                            g = l + h - s;
+                        if (d >= 0 && d < n && g >= 0 && g < t) {
+                            var p = d * t + g,
+                                m = i[f * r + h];
+                            c += e[p] * m
+                        }
                     }
+                a[u] = c >= 255 * 4 ? 255 : 0
             }
-            if (s === !0 || s.source !== !1) {
-                const w = document.createElement("a");
-                w.text = a.SOURCE_ACTION, w.href = "#", w.addEventListener("click", function(E) {
-                    rM(Hy(t), n.sourceHeader ?? "", n.sourceFooter ?? "", f), E.preventDefault()
-                }), S.append(w)
-            }
-            if (f === "vega-lite" && (s === !0 || s.compiled !== !1)) {
-                const w = document.createElement("a");
-                w.text = a.COMPILED_ACTION, w.href = "#", w.addEventListener("click", function(E) {
-                    rM(Hy(h), n.sourceHeader ?? "", n.sourceFooter ?? "", "vega"), E.preventDefault()
-                }), S.append(w)
+        return a
+    }
+
+    function J2e(e, t, n) {
+        for (var i = [.1111111111111111, .1111111111111111, .1111111111111111, .1111111111111111, .1111111111111111, .1111111111111111, .1111111111111111, .1111111111111111, .1111111111111111], r = Math.round(Math.sqrt(i.length)), s = Math.floor(r / 2), a = [], o = 0; o < n; o++)
+            for (var l = 0; l < t; l++) {
+                for (var u = o * t + l, c = 0, f = 0; f < r; f++)
+                    for (var h = 0; h < r; h++) {
+                        var d = o + f - s,
+                            g = l + h - s;
+                        if (d >= 0 && d < n && g >= 0 && g < t) {
+                            var p = d * t + g,
+                                m = i[f * r + h];
+                            c += e[p] * m
+                        }
+                    }
+                a[u] = c
             }
-            if (s === !0 || s.editor !== !1) {
-                const w = n.editorUrl ?? "https://vega.github.io/editor/",
-                    E = document.createElement("a");
-                E.text = a.EDITOR_ACTION, E.href = "#", E.addEventListener("click", function(A) {
-                    jve(window, w, {
-                        config: r,
-                        mode: f,
-                        renderer: o,
-                        spec: Hy(t)
-                    }), A.preventDefault()
-                }), S.append(E)
+        return a
+    }
+    const Q2e = function(e) {
+        var t = this.threshold(),
+            n = Y2e(e, t);
+        return n && (n = V2e(n, e.width, e.height), n = K2e(n, e.width, e.height), n = J2e(n, e.width, e.height), X2e(e, n)), e
+    };
+    O.addGetterSetter(re, "threshold", 0, se(), O.afterSetFilter);
+    const Z2e = function(e) {
+        var t = this.noise() * 255,
+            n = e.data,
+            i = n.length,
+            r = t / 2,
+            s;
+        for (s = 0; s < i; s += 4) n[s + 0] += r - 2 * r * Math.random(), n[s + 1] += r - 2 * r * Math.random(), n[s + 2] += r - 2 * r * Math.random()
+    };
+    O.addGetterSetter(re, "noise", .2, se(), O.afterSetFilter);
+    const exe = function(e) {
+        var t = Math.ceil(this.pixelSize()),
+            n = e.width,
+            i = e.height,
+            r, s, a, o, l, u, c, f = Math.ceil(n / t),
+            h = Math.ceil(i / t),
+            d, g, p, m, y, v, b, x = e.data;
+        if (t <= 0) {
+            D.error("pixelSize value can not be <= 0");
+            return
+        }
+        for (y = 0; y < f; y += 1)
+            for (v = 0; v < h; v += 1) {
+                for (o = 0, l = 0, u = 0, c = 0, d = y * t, g = d + t, p = v * t, m = p + t, b = 0, r = d; r < g; r += 1)
+                    if (!(r >= n))
+                        for (s = p; s < m; s += 1) s >= i || (a = (n * s + r) * 4, o += x[a + 0], l += x[a + 1], u += x[a + 2], c += x[a + 3], b += 1);
+                for (o = o / b, l = l / b, u = u / b, c = c / b, r = d; r < g; r += 1)
+                    if (!(r >= n))
+                        for (s = p; s < m; s += 1) s >= i || (a = (n * s + r) * 4, x[a + 0] = o, x[a + 1] = l, x[a + 2] = u, x[a + 3] = c)
             }
+    };
+    O.addGetterSetter(re, "pixelSize", 8, se(), O.afterSetFilter);
+    const txe = function(e) {
+        var t = Math.round(this.levels() * 254) + 1,
+            n = e.data,
+            i = n.length,
+            r = 255 / t,
+            s;
+        for (s = 0; s < i; s += 1) n[s] = Math.floor(n[s] / r) * r
+    };
+    O.addGetterSetter(re, "levels", .5, se(), O.afterSetFilter);
+    const nxe = function(e) {
+        var t = e.data,
+            n = t.length,
+            i = this.red(),
+            r = this.green(),
+            s = this.blue(),
+            a, o;
+        for (a = 0; a < n; a += 4) o = (.34 * t[a] + .5 * t[a + 1] + .16 * t[a + 2]) / 255, t[a] = o * i, t[a + 1] = o * r, t[a + 2] = o * s, t[a + 3] = t[a + 3]
+    };
+    O.addGetterSetter(re, "red", 0, function(e) {
+        return this._filterUpToDate = !1, e > 255 ? 255 : e < 0 ? 0 : Math.round(e)
+    });
+    O.addGetterSetter(re, "green", 0, function(e) {
+        return this._filterUpToDate = !1, e > 255 ? 255 : e < 0 ? 0 : Math.round(e)
+    });
+    O.addGetterSetter(re, "blue", 0, w9, O.afterSetFilter);
+    const ixe = function(e) {
+        var t = e.data,
+            n = t.length,
+            i = this.red(),
+            r = this.green(),
+            s = this.blue(),
+            a = this.alpha(),
+            o, l;
+        for (o = 0; o < n; o += 4) l = 1 - a, t[o] = i * a + t[o] * l, t[o + 1] = r * a + t[o + 1] * l, t[o + 2] = s * a + t[o + 2] * l
+    };
+    O.addGetterSetter(re, "red", 0, function(e) {
+        return this._filterUpToDate = !1, e > 255 ? 255 : e < 0 ? 0 : Math.round(e)
+    });
+    O.addGetterSetter(re, "green", 0, function(e) {
+        return this._filterUpToDate = !1, e > 255 ? 255 : e < 0 ? 0 : Math.round(e)
+    });
+    O.addGetterSetter(re, "blue", 0, w9, O.afterSetFilter);
+    O.addGetterSetter(re, "alpha", 1, function(e) {
+        return this._filterUpToDate = !1, e > 1 ? 1 : e < 0 ? 0 : e
+    });
+    const rxe = function(e) {
+            var t = e.data,
+                n = t.length,
+                i, r, s, a;
+            for (i = 0; i < n; i += 4) r = t[i + 0], s = t[i + 1], a = t[i + 2], t[i + 0] = Math.min(255, r * .393 + s * .769 + a * .189), t[i + 1] = Math.min(255, r * .349 + s * .686 + a * .168), t[i + 2] = Math.min(255, r * .272 + s * .534 + a * .131)
+        },
+        sxe = function(e) {
+            var t = e.data,
+                n = e.width,
+                i = e.height,
+                r = n * 4,
+                s = i;
+            do {
+                var a = (s - 1) * r,
+                    o = n;
+                do {
+                    var l = a + (o - 1) * 4,
+                        u = t[l],
+                        c = t[l + 1],
+                        f = t[l + 2];
+                    u > 127 && (u = 255 - u), c > 127 && (c = 255 - c), f > 127 && (f = 255 - f), t[l] = u, t[l + 1] = c, t[l + 2] = f
+                } while (--o)
+            } while (--s)
+        },
+        axe = function(e) {
+            var t = this.threshold() * 255,
+                n = e.data,
+                i = n.length,
+                r;
+            for (r = 0; r < i; r += 1) n[r] = n[r] < t ? 0 : 255
+        };
+    O.addGetterSetter(re, "threshold", .5, se(), O.afterSetFilter);
+    const Ot = nO.Util._assign(nO, {
+        Arc: pa,
+        Arrow: uu,
+        Circle: df,
+        Ellipse: Fo,
+        Image: Cs,
+        Label: GC,
+        Tag: cu,
+        Line: ma,
+        Path: ct,
+        Rect: mg,
+        RegularPolygon: fu,
+        Ring: hu,
+        Sprite: As,
+        Star: Ro,
+        Text: $t,
+        TextPath: Jt,
+        Transformer: at,
+        Wedge: ya,
+        Filters: {
+            Blur: D2e,
+            Brighten: N2e,
+            Contrast: P2e,
+            Emboss: L2e,
+            Enhance: I2e,
+            Grayscale: z2e,
+            HSL: B2e,
+            HSV: j2e,
+            Invert: G2e,
+            Kaleidoscope: q2e,
+            Mask: Q2e,
+            Noise: Z2e,
+            Pixelate: exe,
+            Posterize: txe,
+            RGB: nxe,
+            RGBA: ixe,
+            Sepia: rxe,
+            Solarize: sxe,
+            Threshold: axe
         }
+    });
+    var e7 = {
+            exports: {}
+        },
+        Vp = 1;
 
-        function x() {
-            b && document.removeEventListener("click", b), y.finalize()
-        }
-        return {
-            view: y,
-            spec: t,
-            vgSpec: h,
-            finalize: x,
-            embedOptions: n
-        }
+    function oxe() {
+        return Vp = (Vp * 9301 + 49297) % 233280, Vp / 233280
     }
-    const nbe = new Set(["width", "height"]);
 
-    function ibe(e, t) {
-        for (const [n, i] of Object.entries(t)) i && (i && {}.toString.call(i) === "[object Function]" ? i(e.data(n)) : e.change(n, Hi.changeset().remove(() => !0).insert(i)))
+    function lxe(e) {
+        Vp = e
     }
+    var uxe = {
+            nextValue: oxe,
+            seed: lxe
+        },
+        t_ = uxe,
+        nl = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-",
+        Ga, fO, _h;
 
-    function zg(e = {}, t = {}, n = new Set) {
-        const i = Object.keys(e),
-            r = Object.keys(t);
-        return e === t || i.length === r.length && i.filter(s => !n.has(s)).every(s => e[s] === t[s])
+    function n_() {
+        _h = !1
     }
 
-    function oM(e, t) {
-        const n = Object.keys(t);
-        for (const i of n) try {
-            e.removeSignalListener(i, t[i])
-        } catch (r) {
-            console.warn("Cannot remove invalid signal listener.", r)
+    function t7(e) {
+        if (!e) {
+            Ga !== nl && (Ga = nl, n_());
+            return
+        }
+        if (e !== Ga) {
+            if (e.length !== nl.length) throw new Error("Custom alphabet for shortid must be " + nl.length + " unique characters. You submitted " + e.length + " characters: " + e);
+            var t = e.split("").filter(function(n, i, r) {
+                return i !== r.lastIndexOf(n)
+            });
+            if (t.length) throw new Error("Custom alphabet for shortid must be " + nl.length + " unique characters. These characters were not unique: " + t.join(", "));
+            Ga = e, n_()
         }
-        return n.length > 0
     }
 
-    function Gv(e, t) {
-        const n = Object.keys(t);
-        for (const i of n) try {
-            e.addSignalListener(i, t[i])
-        } catch (r) {
-            console.warn("Cannot add invalid signal listener.", r)
-        }
-        return n.length > 0
+    function cxe(e) {
+        return t7(e), Ga
     }
 
-    function rbe(e) {
-        return new Set(e.flatMap(t => Object.keys(t)))
+    function fxe(e) {
+        t_.seed(e), fO !== e && (n_(), fO = e)
     }
 
-    function sbe(e, t) {
-        if (e === t) return !1;
-        const n = {
-                width: !1,
-                height: !1,
-                isExpensive: !1
-            },
-            i = "width" in e || "width" in t,
-            r = "height" in e || "height" in t;
-        return i && (!("width" in e) || !("width" in t) || e.width !== t.width) && ("width" in e && typeof e.width == "number" ? n.width = e.width : n.isExpensive = !0), r && (!("height" in e) || !("height" in t) || e.height !== t.height) && ("height" in e && typeof e.height == "number" ? n.height = e.height : n.isExpensive = !0), [...rbe([e, t])].filter(a => a !== "width" && a !== "height").some(a => !(a in e) || !(a in t) || !fI(e[a], t[a])) && (n.isExpensive = !0), n.width !== !1 || n.height !== !1 || n.isExpensive ? n : !1
+    function hxe() {
+        Ga || t7(nl);
+        for (var e = Ga.split(""), t = [], n = t_.nextValue(), i; e.length > 0;) n = t_.nextValue(), i = Math.floor(n * e.length), t.push(e.splice(i, 1)[0]);
+        return t.join("")
     }
 
-    function lM(e, t) {
-        const {
-            width: n,
-            height: i
-        } = t;
-        return typeof n < "u" && typeof i < "u" ? {
-            ...e,
-            width: n,
-            height: i
-        } : typeof n < "u" ? {
-            ...e,
-            width: n
-        } : typeof i < "u" ? {
-            ...e,
-            height: i
-        } : e
+    function n7() {
+        return _h || (_h = hxe(), _h)
     }
 
-    function abe(e) {
-        let t;
-        return {
-            c() {
-                t = J("div")
-            },
-            m(n, i) {
-                we(n, t, i), e[11](t)
-            },
-            p: Ve,
-            i: Ve,
-            o: Ve,
-            d(n) {
-                n && _e(t), e[11](null)
-            }
-        }
+    function dxe(e) {
+        var t = n7();
+        return t[e]
     }
 
-    function obe(e, t, n) {
-        let {
-            options: i
-        } = t, {
-            spec: r
-        } = t, {
-            view: s
-        } = t, {
-            signalListeners: a = {}
-        } = t, {
-            data: o = {}
-        } = t;
-        const l = fc();
-        let u, c = {},
-            f = {},
-            h = {},
-            d = {},
-            g;
-        G8(() => {
-            m()
-        });
-        async function p() {
-            m();
-            try {
-                n(6, u = await Zve(g, r, i)), n(1, s = u.view), Gv(s, a) && s.runAsync(), v(s)
-            } catch (_) {
-                y(_)
-            }
-        }
+    function gxe() {
+        return Ga || nl
+    }
+    var UC = {
+            get: gxe,
+            characters: cxe,
+            seed: fxe,
+            lookup: dxe,
+            shuffled: n7
+        },
+        Tb = typeof window == "object" && (window.crypto || window.msCrypto),
+        i_;
+    !Tb || !Tb.getRandomValues ? i_ = function(e) {
+        for (var t = [], n = 0; n < e; n++) t.push(Math.floor(Math.random() * 256));
+        return t
+    } : i_ = function(e) {
+        return Tb.getRandomValues(new Uint8Array(e))
+    };
+    var pxe = i_,
+        mxe = function(e, t, n) {
+            for (var i = (2 << Math.log(t.length - 1) / Math.LN2) - 1, r = -~(1.6 * i * n / t.length), s = "";;)
+                for (var a = e(r), o = r; o--;)
+                    if (s += t[a[o] & i] || "", s.length === +n) return s
+        },
+        yxe = UC,
+        vxe = pxe,
+        bxe = mxe;
 
-        function m() {
-            u && (u.finalize(), n(6, u = void 0), n(1, s = void 0))
-        }
+    function xxe(e) {
+        for (var t = 0, n, i = ""; !n;) i = i + bxe(vxe, yxe.get(), 1), n = e < Math.pow(16, t + 1), t++;
+        return i
+    }
+    var _xe = xxe,
+        yp = _xe,
+        wxe = 1567752802062,
+        Sxe = 7,
+        vp, hO;
+
+    function Exe(e) {
+        var t = "",
+            n = Math.floor((Date.now() - wxe) * .001);
+        return n === hO ? vp++ : (vp = 0, hO = n), t = t + yp(Sxe), t = t + yp(e), vp > 0 && (t = t + yp(vp)), t = t + yp(n), t
+    }
+    var kxe = Exe,
+        Cxe = UC;
+
+    function Axe(e) {
+        if (!e || typeof e != "string" || e.length < 6) return !1;
+        var t = new RegExp("[^" + Cxe.get().replace(/[|\\{}()[\]^$+*?.-]/g, "\\$&") + "]");
+        return !t.test(e)
+    }
+    var $xe = Axe;
+    (function(e) {
+        var t = UC,
+            n = kxe,
+            i = $xe,
+            r = 0;
 
-        function y(_) {
-            l("onError", {
-                error: _
-            }), console.warn(_)
+        function s(u) {
+            return t.seed(u), e.exports
         }
 
-        function v(_) {
-            b(), l("onNewView", {
-                view: _
-            })
+        function a(u) {
+            return r = u, e.exports
         }
-        async function b() {
-            o && Object.keys(o).length > 0 && u !== void 0 && (n(1, s = u.view), ibe(s, o), await s.resize().runAsync())
+
+        function o(u) {
+            return u !== void 0 && t.characters(u), t.shuffled()
         }
 
-        function x(_) {
-            pp[_ ? "unshift" : "push"](() => {
-                g = _, n(0, g)
-            })
+        function l() {
+            return n(r)
         }
-        return e.$$set = _ => {
-            "options" in _ && n(2, i = _.options), "spec" in _ && n(3, r = _.spec), "view" in _ && n(1, s = _.view), "signalListeners" in _ && n(4, a = _.signalListeners), "data" in _ && n(5, o = _.data)
-        }, e.$$.update = () => {
-            if (e.$$.dirty & 1056 && (zg(o, d) || b(), n(10, d = o)), e.$$.dirty & 991 && g !== void 0) {
-                if (!zg(i, c, nbe)) p();
-                else {
-                    const _ = sbe(lM(r, i), lM(h, c)),
-                        S = a,
-                        w = f;
-                    if (_) {
-                        if (_.isExpensive) p();
-                        else if (u !== void 0) {
-                            const E = !zg(S, w);
-                            n(1, s = u.view), _.width !== !1 && s.width(_.width), _.height !== !1 && s.height(_.height), E && (w && oM(s, w), S && Gv(s, S)), s.runAsync()
-                        }
-                    } else !zg(S, w) && u !== void 0 && (n(1, s = u.view), w && oM(s, w), S && Gv(s, S), s.runAsync())
-                }
-                n(7, c = i), n(8, f = a), n(9, h = r)
-            }
-        }, [g, s, i, r, a, o, u, c, f, h, d, x]
-    }
-    class lbe extends wn {
-        constructor(t) {
-            super(), _n(this, t, obe, abe, tn, {
-                options: 2,
-                spec: 3,
-                view: 1,
-                signalListeners: 4,
-                data: 5
+        e.exports = l, e.exports.generate = l, e.exports.seed = s, e.exports.worker = a, e.exports.characters = o, e.exports.isValid = i
+    })(e7);
+    var Txe = e7.exports,
+        Mxe = Txe;
+    const Oxe = Ed(Mxe),
+        Fxe = ["mouseover", "mouseout", "mouseenter", "mouseleave", "mousemove", "mousedown", "mouseup", "wheel", "click", "dblclick", "touchstart", "touchmove", "touchend", "tap", "dbltap", "pointerdown", "pointermove", "pointerup", "pointercancel", "pointerover", "pointerenter", "pointerout", "pointerleave", "pointerclick", "pointerdblclick", "dragstart", "dragmove", "dragend", "transformstart", "transform", "transformend"];
+
+    function Wy(e, t) {
+        Fxe.forEach(n => {
+            t.on(n, i => {
+                e(n, i, {
+                    cancelable: !0
+                }) || (i.cancelBubble = !0)
             })
+        })
+    }
+    const N0 = ["svelte-konva-stage", "svelte-konva-layer", "svelte-konva-group", "svelte-konva-label"];
+    var zc;
+    (function(e) {
+        e[e.Stage = 0] = "Stage", e[e.Layer = 1] = "Layer", e[e.Group = 2] = "Group", e[e.Label = 3] = "Label"
+    })(zc || (zc = {}));
+    const Rxe = "svelte-konva: Component does not have any parent container. Please make sure that the component is wrapped inside a Layer or Group.",
+        Dxe = "svelte-konva: A Layer needs to have a Stage as parent.";
+
+    function WC(e, t) {
+        N0.forEach(n => {
+            QC(n, null)
+        }), QC(N0[e], t)
+    }
+
+    function i7() {
+        for (let e = 1; e < 4; e++) {
+            const t = zO(N0[e]);
+            if (t) return t
         }
+        throw new Error(Rxe)
     }
 
-    function ube(e) {
-        let t, n, i;
+    function Nxe() {
+        const e = zO(N0[zc.Stage]);
+        if (e) return e;
+        throw new Error(Dxe)
+    }
 
-        function r(a) {
-            e[6](a)
+    function Ul(e, t) {
+        for (const n in e) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n])
+    }
+
+    function dO(e) {
+        let t;
+        const n = e[5].default,
+            i = a_(n, e, e[4], null);
+        return {
+            c() {
+                i && i.c()
+            },
+            m(r, s) {
+                i && i.m(r, s), t = !0
+            },
+            p(r, s) {
+                i && i.p && (!t || s & 16) && l_(i, n, r, r[4], t ? o_(n, r[4], s, null) : u_(r[4]), null)
+            },
+            i(r) {
+                t || (fe(i, r), t = !0)
+            },
+            o(r) {
+                ve(i, r), t = !1
+            },
+            d(r) {
+                i && i.d(r)
+            }
         }
-        let s = {
-            spec: e[1],
-            data: e[2],
-            signalListeners: e[3],
-            options: e[4]
-        };
-        return e[0] !== void 0 && (s.view = e[0]), t = new lbe({
-            props: s
-        }), pp.push(() => V8(t, "view", r)), t.$on("onNewView", e[7]), t.$on("onError", e[8]), {
+    }
+
+    function Pxe(e) {
+        let t, n, i = e[0] && dO(e);
+        return {
             c() {
-                ei(t.$$.fragment)
+                i && i.c(), t = Zi()
             },
-            m(a, o) {
-                Nn(t, a, o), i = !0
+            m(r, s) {
+                i && i.m(r, s), de(r, t, s), n = !0
             },
-            p(a, [o]) {
-                const l = {};
-                o & 2 && (l.spec = a[1]), o & 4 && (l.data = a[2]), o & 8 && (l.signalListeners = a[3]), o & 16 && (l.options = a[4]), !n && o & 1 && (n = !0, l.view = a[0], H8(() => n = !1)), t.$set(l)
+            p(r, [s]) {
+                r[0] ? i ? (i.p(r, s), s & 1 && fe(i, 1)) : (i = dO(r), i.c(), fe(i, 1), i.m(t.parentNode, t)) : i && (on(), ve(i, 1, 1, () => {
+                    i = null
+                }), ln())
             },
-            i(a) {
-                i || (Te(t.$$.fragment, a), i = !0)
+            i(r) {
+                n || (fe(i), n = !0)
             },
-            o(a) {
-                Ie(t.$$.fragment, a), i = !1
+            o(r) {
+                ve(i), n = !1
             },
-            d(a) {
-                Pn(t, a)
+            d(r) {
+                i && i.d(r), r && he(t)
             }
         }
     }
-    const cbe = "vega-lite";
 
-    function fbe(e, t, n) {
+    function Lxe(e, t, n) {
         let i, {
-                spec: r
+                $$slots: r = {},
+                $$scope: s
             } = t,
             {
-                options: s = {}
-            } = t,
-            {
-                data: a = {}
+                config: a = {}
             } = t,
             {
-                signalListeners: o = {}
+                handle: o = new Ot.Group(a)
             } = t,
-            {
-                view: l = void 0
-            } = t;
-
-        function u(h) {
-            l = h, n(0, l)
-        }
-
-        function c(h) {
-            QC.call(this, e, h)
+            l = By(null),
+            u = er(),
+            c = !1,
+            f = i7();
+        return s_(e, f, h => n(6, i = h)), ra(() => {
+            i.add(o), o.on("transformend", () => {
+                Ul(a, o.getAttrs()), n(2, a)
+            }), o.on("dragend", () => {
+                Ul(a, o.getAttrs()), n(2, a)
+            }), Wy(u, o), l.set(o), n(0, c = !0)
+        }), Sd(() => {
+            o && o.destroy()
+        }), WC(zc.Group, l), e.$$set = h => {
+            "config" in h && n(2, a = h.config), "handle" in h && n(3, o = h.handle), "$$scope" in h && n(4, s = h.$$scope)
+        }, e.$$.update = () => {
+            e.$$.dirty & 12 && o && o.setAttrs(a)
+        }, [c, f, a, o, s, r]
+    }
+    class bp extends It {
+        constructor(t) {
+            super(), Lt(this, t, Lxe, Pxe, Tt, {
+                config: 2,
+                handle: 3
+            })
         }
+    }
 
-        function f(h) {
-            QC.call(this, e, h)
-        }
-        return e.$$set = h => {
-            "spec" in h && n(1, r = h.spec), "options" in h && n(5, s = h.options), "data" in h && n(2, a = h.data), "signalListeners" in h && n(3, o = h.signalListeners), "view" in h && n(0, l = h.view)
+    function Ixe(e, t, n) {
+        let i, {
+                config: r
+            } = t,
+            {
+                handle: s = new Ot.Image(r)
+            } = t,
+            a = i7();
+        s_(e, a, l => n(3, i = l));
+        let o = er();
+        return ra(() => {
+            i.add(s), s.on("transformend", () => {
+                Ul(r, s.getAttrs()), n(1, r)
+            }), s.on("dragend", () => {
+                Ul(r, s.getAttrs()), n(1, r)
+            }), Wy(o, s)
+        }), Sd(() => {
+            s.destroy()
+        }), e.$$set = l => {
+            "config" in l && n(1, r = l.config), "handle" in l && n(2, s = l.handle)
         }, e.$$.update = () => {
-            e.$$.dirty & 32 && n(4, i = {
-                ...s,
-                mode: cbe
-            })
-        }, [l, r, a, o, i, s, u, c, f]
+            e.$$.dirty & 6 && s.setAttrs(r)
+        }, [a, r, s]
     }
-    class hbe extends wn {
+    let zxe = class extends It {
         constructor(t) {
-            super(), _n(this, t, fbe, ube, tn, {
-                spec: 1,
-                options: 5,
-                data: 2,
-                signalListeners: 3,
-                view: 0
+            super(), Lt(this, t, Ixe, null, Tt, {
+                config: 1,
+                handle: 2
             })
         }
-    }
+    };
 
-    function dbe(e) {
-        let t, n, i = e[0].name + "",
-            r, s, a, o, l;
-        return o = new hbe({
-            props: {
-                spec: e[1],
-                options: e[2]
-            }
-        }), {
+    function gO(e) {
+        let t;
+        const n = e[5].default,
+            i = a_(n, e, e[4], null);
+        return {
             c() {
-                t = J("div"), n = J("span"), r = Je(i), s = Ee(), a = J("div"), ei(o.$$.fragment), j(n, "class", "py-1 text-sm font-bold text-zinc-900"), j(a, "class", "max-h-48 overflow-y-scroll"), j(t, "class", "h-56 w-72 flex flex-col justify-center items-center border rounded-lg bg-zinc-100")
+                i && i.c()
             },
-            m(u, c) {
-                we(u, t, c), G(t, n), G(n, r), G(t, s), G(t, a), Nn(o, a, null), l = !0
+            m(r, s) {
+                i && i.m(r, s), t = !0
             },
-            p(u, [c]) {
-                (!l || c & 1) && i !== (i = u[0].name + "") && Ot(r, i);
-                const f = {};
-                c & 2 && (f.spec = u[1]), o.$set(f)
+            p(r, s) {
+                i && i.p && (!t || s & 16) && l_(i, n, r, r[4], t ? o_(n, r[4], s, null) : u_(r[4]), null)
             },
-            i(u) {
-                l || (Te(o.$$.fragment, u), l = !0)
+            i(r) {
+                t || (fe(i, r), t = !0)
             },
-            o(u) {
-                Ie(o.$$.fragment, u), l = !1
+            o(r) {
+                ve(i, r), t = !1
             },
-            d(u) {
-                u && _e(t), Pn(o)
+            d(r) {
+                i && i.d(r)
             }
         }
     }
 
-    function gbe(e, t, n) {
-        let {
-            hist: i
-        } = t, r = 10 * i.histogram.length;
-        r = r < 175 ? 175 : r;
-        let s = {
-            $schema: "https://vega.github.io/schema/vega-lite/v5.json",
-            config: {
-                style: {
-                    cell: {
-                        stroke: "transparent"
-                    }
-                }
+    function Bxe(e) {
+        let t, n, i = e[0] && gO(e);
+        return {
+            c() {
+                i && i.c(), t = Zi()
             },
-            params: [{
-                name: "highlight",
-                select: {
-                    type: "point",
-                    on: "mouseover"
-                }
-            }],
-            data: {
-                values: i.histogram
+            m(r, s) {
+                i && i.m(r, s), de(r, t, s), n = !0
             },
-            height: r,
-            width: 150,
-            background: "transparent",
-            mark: {
-                type: "bar",
-                tooltip: !0
+            p(r, [s]) {
+                r[0] ? i ? (i.p(r, s), s & 1 && fe(i, 1)) : (i = gO(r), i.c(), fe(i, 1), i.m(t.parentNode, t)) : i && (on(), ve(i, 1, 1, () => {
+                    i = null
+                }), ln())
             },
-            encoding: {
-                x: {
-                    field: "counts",
-                    type: "quantitative",
-                    axis: {
-                        title: null,
-                        grid: !1,
-                        domain: !1,
-                        ticks: !1,
-                        labels: !1
-                    }
-                },
-                y: {
-                    field: i.name,
-                    type: "nominal",
-                    sort: "-x",
-                    axis: {
-                        title: null,
-                        domain: !1,
-                        grid: !1,
-                        ticks: !1,
-                        labelLimit: 50,
-                        labelPadding: 10
-                    }
-                },
-                color: {
-                    condition: [{
-                        param: "highlight",
-                        empty: !1,
-                        value: "grey"
-                    }],
-                    field: "split"
-                }
-            }
-        };
-        if (i.type == "numerical") {
-            for (let o = 0; o < i.histogram.length; ++o) {
-                let l = i.histogram[o];
-                l.bin_range = l.bin_start + "-" + l.bin_end
+            i(r) {
+                n || (fe(i), n = !0)
+            },
+            o(r) {
+                ve(i), n = !1
+            },
+            d(r) {
+                i && i.d(r), r && he(t)
             }
-            s.encoding.y.field = "bin_range", s.encoding.y.sort = null
         }
-        const a = {
-            actions: !1
-        };
-        return e.$$set = o => {
-            "hist" in o && n(0, i = o.hist)
-        }, [i, s, a]
     }
-    class P8 extends wn {
+
+    function jxe(e, t, n) {
+        let i, {
+                $$slots: r = {},
+                $$scope: s
+            } = t,
+            {
+                config: a = {}
+            } = t,
+            {
+                handle: o = new Ot.Layer(a)
+            } = t,
+            l = By(null),
+            u = er(),
+            c = !1,
+            f = Nxe();
+        return s_(e, f, h => n(6, i = h)), ra(() => {
+            i.add(o), o.on("transformend", () => {
+                Ul(a, o.getAttrs()), n(2, a)
+            }), o.on("dragend", () => {
+                Ul(a, o.getAttrs()), n(2, a)
+            }), Wy(u, o), l.set(o), n(0, c = !0)
+        }), Sd(() => {
+            o && o.destroy()
+        }), WC(zc.Layer, l), e.$$set = h => {
+            "config" in h && n(2, a = h.config), "handle" in h && n(3, o = h.handle), "$$scope" in h && n(4, s = h.$$scope)
+        }, e.$$.update = () => {
+            e.$$.dirty & 12 && o && o.setAttrs(a)
+        }, [c, f, a, o, s, r]
+    }
+    class r7 extends It {
         constructor(t) {
-            super(), _n(this, t, gbe, dbe, tn, {
-                hist: 0
+            super(), Lt(this, t, jxe, Bxe, Tt, {
+                config: 2,
+                handle: 3
             })
         }
     }
 
-    function pbe(e) {
-        let t, n;
-        return t = new P8({
-            props: {
-                hist: e[0]
-            }
-        }), {
+    function pO(e) {
+        let t;
+        const n = e[6].default,
+            i = a_(n, e, e[5], null);
+        return {
             c() {
-                ei(t.$$.fragment)
+                i && i.c()
             },
-            m(i, r) {
-                Nn(t, i, r), n = !0
+            m(r, s) {
+                i && i.m(r, s), t = !0
             },
-            p(i, [r]) {
-                const s = {};
-                r & 1 && (s.hist = i[0]), t.$set(s)
+            p(r, s) {
+                i && i.p && (!t || s & 32) && l_(i, n, r, r[5], t ? o_(n, r[5], s, null) : u_(r[5]), null)
             },
-            i(i) {
-                n || (Te(t.$$.fragment, i), n = !0)
+            i(r) {
+                t || (fe(i, r), t = !0)
             },
-            o(i) {
-                Ie(t.$$.fragment, i), n = !1
+            o(r) {
+                ve(i, r), t = !1
             },
-            d(i) {
-                Pn(t, i)
+            d(r) {
+                i && i.d(r)
             }
         }
     }
 
-    function mbe(e, t, n) {
-        let {
-            value: i
-        } = t;
-        return e.$$set = r => {
-            "value" in r && n(0, i = r.value)
-        }, [i]
-    }
-    class ybe extends wn {
-        constructor(t) {
-            super(), _n(this, t, mbe, pbe, tn, {
-                value: 0
-            })
-        }
-    }
-
-    function vbe(e) {
-        let t, n, i;
-        var r = e[1][e[0].dtype];
-
-        function s(a) {
-            return {
-                props: {
-                    value: a[0].value
-                }
-            }
-        }
-        return r && (t = JC(r, s(e))), {
+    function Gxe(e) {
+        let t, n, i = e[1] && pO(e),
+            r = [e[2]],
+            s = {};
+        for (let a = 0; a < r.length; a += 1) s = Kp(s, r[a]);
+        return {
             c() {
-                t && ei(t.$$.fragment), n = bl()
+                t = V("div"), i && i.c(), XC(t, s)
             },
             m(a, o) {
-                t && Nn(t, a, o), we(a, n, o), i = !0
+                de(a, t, o), i && i.m(t, null), e[7](t), n = !0
             },
             p(a, [o]) {
-                const l = {};
-                if (o & 1 && (l.value = a[0].value), o & 1 && r !== (r = a[1][a[0].dtype])) {
-                    if (t) {
-                        ur();
-                        const u = t;
-                        Ie(u.$$.fragment, 1, 0, () => {
-                            Pn(u, 1)
-                        }), cr()
-                    }
-                    r ? (t = JC(r, s(a)), ei(t.$$.fragment), Te(t.$$.fragment, 1), Nn(t, n.parentNode, n)) : t = null
-                } else r && t.$set(l)
+                a[1] ? i ? (i.p(a, o), o & 2 && fe(i, 1)) : (i = pO(a), i.c(), fe(i, 1), i.m(t, null)) : i && (on(), ve(i, 1, 1, () => {
+                    i = null
+                }), ln()), XC(t, s = N7(r, [o & 4 && a[2]]))
             },
             i(a) {
-                i || (t && Te(t.$$.fragment, a), i = !0)
+                n || (fe(i), n = !0)
             },
             o(a) {
-                t && Ie(t.$$.fragment, a), i = !1
+                ve(i), n = !1
             },
             d(a) {
-                a && _e(n), t && Pn(t, a)
+                a && he(t), i && i.d(), e[7](null)
             }
         }
     }
 
-    function bbe(e, t, n) {
-        let {
-            data: i
-        } = t;
-        const r = {
-            number: pY,
-            text: vY,
-            image: _Y,
-            histogram: ybe
-        };
-        return e.$$set = s => {
-            "data" in s && n(0, i = s.data)
-        }, [i, r]
+    function Uxe(e, t, n) {
+        const i = ["config", "handle"];
+        let r = YC(t, i),
+            {
+                $$slots: s = {},
+                $$scope: a
+            } = t,
+            {
+                config: o
+            } = t,
+            {
+                handle: l = null
+            } = t,
+            u = By(null),
+            c, f = er(),
+            h = !1;
+        ra(() => {
+            n(4, l = new Ot.Stage({
+                container: c,
+                ...o
+            })), l.on("dragend", () => {
+                Ul(o, l.getAttrs()), n(3, o)
+            }), Wy(f, l), u.set(l), n(1, h = !0)
+        }), Sd(() => {
+            l && l.destroy()
+        }), WC(zc.Stage, u);
+
+        function d(g) {
+            Hi[g ? "unshift" : "push"](() => {
+                c = g, n(0, c)
+            })
+        }
+        return e.$$set = g => {
+            t = Kp(Kp({}, t), C7(g)), n(2, r = YC(t, i)), "config" in g && n(3, o = g.config), "handle" in g && n(4, l = g.handle), "$$scope" in g && n(5, a = g.$$scope)
+        }, e.$$.update = () => {
+            e.$$.dirty & 24 && l && l.setAttrs(o)
+        }, [c, h, r, o, l, a, s, d]
     }
-    class xbe extends wn {
+    class Wxe extends It {
         constructor(t) {
-            super(), _n(this, t, bbe, vbe, tn, {
-                data: 0
+            super(), Lt(this, t, Uxe, Gxe, Tt, {
+                config: 3,
+                handle: 4
             })
         }
     }
+    const qxe = "/assets/minus-327ad03c.svg",
+        Hxe = "/assets/plus-a5295245.svg",
+        Yxe = "/assets/point-23ee9036.svg",
+        Xxe = "/assets/box-86375780.svg",
+        Vxe = "/assets/pan-8dc436ff.svg";
+    /**
+      @copyright CEA-LIST/DIASI/SIALV/LVA (2023)
+      @author CEA-LIST/DIASI/SIALV/LVA <pixano@cea.fr>
+      @license CECILL-C
+
+      This software is a collaborative computer program whose purpose is to
+      generate and explore labeled data for computer vision applications.
+      This software is governed by the CeCILL-C license under French law and
+      abiding by the rules of distribution of free software. You can use, 
+      modify and/or redistribute the software under the terms of the CeCILL-C
+      license as circulated by CEA, CNRS and INRIA at the following URL
 
-    function uM(e, t, n) {
-        const i = e.slice();
-        return i[5] = t[n], i
+      http://www.cecill.info
+    */
+    var wi = (e => (e.LabeledPoint = "LABELED_POINT", e.Rectangle = "RECTANGLE", e.Pan = "PAN", e))(wi || {});
+
+    function Kxe(e, t) {
+        switch (e) {
+            case "LABELED_POINT":
+                switch (t) {
+                    case 0:
+                        return qxe;
+                    case 1:
+                        return Hxe;
+                    default:
+                        return Yxe
+                }
+            case "RECTANGLE":
+                return Xxe;
+            case "PAN":
+                return Vxe
+        }
     }
 
-    function cM(e, t, n) {
-        const i = e.slice();
-        return i[8] = t[n], i
+    function Jxe() {
+        return {
+            name: "Pan",
+            type: "PAN",
+            icon: Kxe("PAN"),
+            cursor: "move"
+        }
     }
 
-    function fM(e, t, n) {
+    function mO(e, t, n) {
         const i = e.slice();
-        return i[11] = t[n].name, i[12] = t[n].type, i
+        return i[68] = t[n], i
     }
 
-    function hM(e) {
-        let t, n = e[11] + "",
-            i;
-        return {
+    function yO(e) {
+        let t, n;
+
+        function i(...r) {
+            return e[24](e[68], ...r)
+        }
+        return t = new r7({
+            props: {
+                config: {
+                    id: e[68].viewId
+                },
+                $$slots: {
+                    default: [Qxe]
+                },
+                $$scope: {
+                    ctx: e
+                }
+            }
+        }), t.$on("wheel", i), {
             c() {
-                t = J("th"), i = Je(n), j(t, "class", "pl-2 py-1")
+                St(t.$$.fragment)
             },
             m(r, s) {
-                we(r, t, s), G(t, i)
+                xt(t, r, s), n = !0
             },
             p(r, s) {
-                s & 1 && n !== (n = r[11] + "") && Ot(i, n)
+                e = r;
+                const a = {};
+                s[0] & 2 && (a.config = {
+                    id: e[68].viewId
+                }), s[0] & 11 | s[2] & 512 && (a.$$scope = {
+                    dirty: s,
+                    ctx: e
+                }), t.$set(a)
+            },
+            i(r) {
+                n || (fe(t.$$.fragment, r), n = !0)
+            },
+            o(r) {
+                ve(t.$$.fragment, r), n = !1
             },
             d(r) {
-                r && _e(t)
+                _t(t, r)
             }
         }
     }
 
-    function dM(e) {
-        let t, n = e[12] != "hidden" && hM(e);
-        return {
-            c() {
-                n && n.c(), t = bl()
-            },
-            m(i, r) {
-                n && n.m(i, r), we(i, t, r)
-            },
-            p(i, r) {
-                i[12] != "hidden" ? n ? n.p(i, r) : (n = hM(i), n.c(), n.m(t.parentNode, t)) : n && (n.d(1), n = null)
-            },
-            d(i) {
-                n && n.d(i), i && _e(t)
-            }
+    function Qxe(e) {
+        let t, n, i, r, s, a, o, l, u, c;
+
+        function f(...g) {
+            return e[21](e[68], ...g)
         }
-    }
 
-    function gM(e) {
-        let t, n, i;
-        return n = new xbe({
+        function h(...g) {
+            return e[22](e[68], ...g)
+        }
+
+        function d(...g) {
+            return e[23](e[68], ...g)
+        }
+        return t = new zxe({
             props: {
-                data: e[8]
+                config: {
+                    image: e[3][e[68].viewId],
+                    id: e[0]
+                }
+            }
+        }), t.$on("pointerdown", f), t.$on("pointerup", h), t.$on("dblclick", d), i = new bp({
+            props: {
+                config: {
+                    id: "masks"
+                }
+            }
+        }), s = new bp({
+            props: {
+                config: {
+                    id: "masksGT"
+                }
+            }
+        }), o = new bp({
+            props: {
+                config: {
+                    id: "bboxes"
+                }
+            }
+        }), u = new bp({
+            props: {
+                config: {
+                    id: "input"
+                }
             }
         }), {
             c() {
-                t = J("td"), ei(n.$$.fragment), j(t, "class", "border-b dark:border-zinc-700 py-2")
+                St(t.$$.fragment), n = we(), St(i.$$.fragment), r = we(), St(s.$$.fragment), a = we(), St(o.$$.fragment), l = we(), St(u.$$.fragment)
             },
-            m(r, s) {
-                we(r, t, s), Nn(n, t, null), i = !0
+            m(g, p) {
+                xt(t, g, p), de(g, n, p), xt(i, g, p), de(g, r, p), xt(s, g, p), de(g, a, p), xt(o, g, p), de(g, l, p), xt(u, g, p), c = !0
             },
-            p(r, s) {
-                const a = {};
-                s & 2 && (a.data = r[8]), n.$set(a)
+            p(g, p) {
+                e = g;
+                const m = {};
+                p[0] & 11 && (m.config = {
+                    image: e[3][e[68].viewId],
+                    id: e[0]
+                }), t.$set(m)
             },
-            i(r) {
-                i || (Te(n.$$.fragment, r), i = !0)
+            i(g) {
+                c || (fe(t.$$.fragment, g), fe(i.$$.fragment, g), fe(s.$$.fragment, g), fe(o.$$.fragment, g), fe(u.$$.fragment, g), c = !0)
             },
-            o(r) {
-                Ie(n.$$.fragment, r), i = !1
+            o(g) {
+                ve(t.$$.fragment, g), ve(i.$$.fragment, g), ve(s.$$.fragment, g), ve(o.$$.fragment, g), ve(u.$$.fragment, g), c = !1
             },
-            d(r) {
-                r && _e(t), Pn(n)
+            d(g) {
+                _t(t, g), g && he(n), _t(i, g), g && he(r), _t(s, g), g && he(a), _t(o, g), g && he(l), _t(u, g)
             }
         }
     }
 
-    function pM(e) {
-        let t, n, i = e[8].dtype != "hidden" && gM(e);
+    function vO(e) {
+        let t, n, i = e[3][e[68].viewId] && yO(e);
         return {
             c() {
-                i && i.c(), t = bl()
+                i && i.c(), t = Zi()
             },
             m(r, s) {
-                i && i.m(r, s), we(r, t, s), n = !0
+                i && i.m(r, s), de(r, t, s), n = !0
             },
             p(r, s) {
-                r[8].dtype != "hidden" ? i ? (i.p(r, s), s & 2 && Te(i, 1)) : (i = gM(r), i.c(), Te(i, 1), i.m(t.parentNode, t)) : i && (ur(), Ie(i, 1, 1, () => {
+                r[3][r[68].viewId] ? i ? (i.p(r, s), s[0] & 10 && fe(i, 1)) : (i = yO(r), i.c(), fe(i, 1), i.m(t.parentNode, t)) : i && (on(), ve(i, 1, 1, () => {
                     i = null
-                }), cr())
+                }), ln())
             },
             i(r) {
-                n || (Te(i), n = !0)
+                n || (fe(i), n = !0)
             },
             o(r) {
-                Ie(i), n = !1
+                ve(i), n = !1
             },
             d(r) {
-                i && i.d(r), r && _e(t)
+                i && i.d(r), r && he(t)
             }
         }
     }
 
-    function mM(e) {
-        let t, n, i, r, s, a = e[5],
-            o = [];
-        for (let c = 0; c < a.length; c += 1) o[c] = pM(cM(e, a, c));
-        const l = c => Ie(o[c], 1, 1, () => {
-            o[c] = null
+    function Zxe(e) {
+        let t, n, i, r, s = e[1],
+            a = [];
+        for (let c = 0; c < s.length; c += 1) a[c] = vO(mO(e, s, c));
+        const o = c => ve(a[c], 1, 1, () => {
+            a[c] = null
         });
 
-        function u() {
-            return e[3](e[5])
+        function l(c) {
+            e[25](c)
         }
-        return {
+        let u = {
+            config: {
+                name: "tools"
+            }
+        };
+        return e[5] !== void 0 && (u.handle = e[5]), n = new r7({
+            props: u
+        }), Hi.push(() => xl(n, "handle", l)), {
             c() {
-                t = J("tr");
-                for (let c = 0; c < o.length; c += 1) o[c].c();
-                n = Ee(), j(t, "class", "cursor-pointer hover:bg-zinc-100 dark:hover:bg-zinc-700")
+                for (let c = 0; c < a.length; c += 1) a[c].c();
+                t = we(), St(n.$$.fragment)
             },
             m(c, f) {
-                we(c, t, f);
-                for (let h = 0; h < o.length; h += 1) o[h] && o[h].m(t, null);
-                G(t, n), i = !0, r || (s = wt(t, "click", u), r = !0)
+                for (let h = 0; h < a.length; h += 1) a[h] && a[h].m(c, f);
+                de(c, t, f), xt(n, c, f), r = !0
             },
             p(c, f) {
-                if (e = c, f & 2) {
-                    a = e[5];
-                    let h;
-                    for (h = 0; h < a.length; h += 1) {
-                        const d = cM(e, a, h);
-                        o[h] ? (o[h].p(d, f), Te(o[h], 1)) : (o[h] = pM(d), o[h].c(), Te(o[h], 1), o[h].m(t, n))
+                if (f[0] & 15371) {
+                    s = c[1];
+                    let d;
+                    for (d = 0; d < s.length; d += 1) {
+                        const g = mO(c, s, d);
+                        a[d] ? (a[d].p(g, f), fe(a[d], 1)) : (a[d] = vO(g), a[d].c(), fe(a[d], 1), a[d].m(t.parentNode, t))
                     }
-                    for (ur(), h = a.length; h < o.length; h += 1) l(h);
-                    cr()
+                    for (on(), d = s.length; d < a.length; d += 1) o(d);
+                    ln()
                 }
+                const h = {};
+                !i && f[0] & 32 && (i = !0, h.handle = c[5], bl(() => i = !1)), n.$set(h)
             },
             i(c) {
-                if (!i) {
-                    for (let f = 0; f < a.length; f += 1) Te(o[f]);
-                    i = !0
+                if (!r) {
+                    for (let f = 0; f < s.length; f += 1) fe(a[f]);
+                    fe(n.$$.fragment, c), r = !0
                 }
             },
             o(c) {
-                o = o.filter(Boolean);
-                for (let f = 0; f < o.length; f += 1) Ie(o[f]);
-                i = !1
+                a = a.filter(Boolean);
+                for (let f = 0; f < a.length; f += 1) ve(a[f]);
+                ve(n.$$.fragment, c), r = !1
             },
             d(c) {
-                c && _e(t), Vo(o, c), r = !1, s()
+                Ja(a, c), c && he(t), _t(n, c)
             }
         }
     }
 
-    function _be(e) {
-        let t, n, i, r, s, a, o, l = e[0],
-            u = [];
-        for (let d = 0; d < l.length; d += 1) u[d] = dM(fM(e, l, d));
-        let c = e[1],
-            f = [];
-        for (let d = 0; d < c.length; d += 1) f[d] = mM(uM(e, c, d));
-        const h = d => Ie(f[d], 1, 1, () => {
-            f[d] = null
-        });
-        return {
+    function e_e(e) {
+        let t, n, i, r, s, a, o;
+
+        function l(f) {
+            e[26](f)
+        }
+
+        function u(f) {
+            e[27](f)
+        }
+        let c = {
+            $$slots: {
+                default: [Zxe]
+            },
+            $$scope: {
+                ctx: e
+            }
+        };
+        return e[6] !== void 0 && (c.config = e[6]), e[4] !== void 0 && (c.handle = e[4]), n = new Wxe({
+            props: c
+        }), Hi.push(() => xl(n, "config", l)), Hi.push(() => xl(n, "handle", u)), n.$on("mousemove", e[7]), n.$on("mouseenter", e[8]), n.$on("mouseleave", e[9]), {
             c() {
-                t = J("div"), n = J("table"), i = J("thead"), r = J("tr");
-                for (let d = 0; d < u.length; d += 1) u[d].c();
-                s = Ee(), a = J("tbody");
-                for (let d = 0; d < f.length; d += 1) f[d].c();
-                j(r, "class", "sticky p-2 top-0 bg-zinc-100 border-b-2 dark:bg-zinc-900 dark:border-zinc-700 "), j(i, "class", "text-xs text-zinc-700 uppercase dark:text-zinc-400"), j(n, "class", "table-auto w-full text-sm text-left"), j(t, "class", "h-full bg-white overflow-y-auto overflow-x-auto border rounded-lg dark:bg-zinc-800 dark:border-zinc-700")
+                t = V("div"), St(n.$$.fragment), z(t, "class", "h-full w-full relative bg-zinc-100")
             },
-            m(d, g) {
-                we(d, t, g), G(t, n), G(n, i), G(i, r);
-                for (let p = 0; p < u.length; p += 1) u[p] && u[p].m(r, null);
-                G(n, s), G(n, a);
-                for (let p = 0; p < f.length; p += 1) f[p] && f[p].m(a, null);
-                o = !0
+            m(f, h) {
+                de(f, t, h), xt(n, t, null), e[28](t), s = !0, a || (o = jt(window, "keydown", e[14]), a = !0)
             },
-            p(d, [g]) {
-                if (g & 1) {
-                    l = d[0];
-                    let p;
-                    for (p = 0; p < l.length; p += 1) {
-                        const m = fM(d, l, p);
-                        u[p] ? u[p].p(m, g) : (u[p] = dM(m), u[p].c(), u[p].m(r, null))
-                    }
-                    for (; p < u.length; p += 1) u[p].d(1);
-                    u.length = l.length
-                }
-                if (g & 6) {
-                    c = d[1];
-                    let p;
-                    for (p = 0; p < c.length; p += 1) {
-                        const m = uM(d, c, p);
-                        f[p] ? (f[p].p(m, g), Te(f[p], 1)) : (f[p] = mM(m), f[p].c(), Te(f[p], 1), f[p].m(a, null))
-                    }
-                    for (ur(), p = c.length; p < f.length; p += 1) h(p);
-                    cr()
-                }
+            p(f, h) {
+                const d = {};
+                h[0] & 43 | h[2] & 512 && (d.$$scope = {
+                    dirty: h,
+                    ctx: f
+                }), !i && h[0] & 64 && (i = !0, d.config = f[6], bl(() => i = !1)), !r && h[0] & 16 && (r = !0, d.handle = f[4], bl(() => r = !1)), n.$set(d)
             },
-            i(d) {
-                if (!o) {
-                    for (let g = 0; g < c.length; g += 1) Te(f[g]);
-                    o = !0
-                }
+            i(f) {
+                s || (fe(n.$$.fragment, f), s = !0)
             },
-            o(d) {
-                f = f.filter(Boolean);
-                for (let g = 0; g < f.length; g += 1) Ie(f[g]);
-                o = !1
+            o(f) {
+                ve(n.$$.fragment, f), s = !1
             },
-            d(d) {
-                d && _e(t), Vo(u, d), Vo(f, d)
+            d(f) {
+                f && he(t), _t(n), e[28](null), a = !1, o()
             }
         }
     }
+    const Yf = 6,
+        Mb = 3,
+        bO = 1.5,
+        t_e = 1;
+
+    function n_e(e, t, n) {
+        const r = e.findOne(`#${n}`),
+            s = r.scaleX(),
+            a = e.getRelativePointerPosition(),
+            o = {
+                x: (a.x - r.x()) / s,
+                y: (a.y - r.y()) / s
+            },
+            l = t > 0 ? s * 1.05 : s / 1.05,
+            u = {
+                x: a.x - o.x * l,
+                y: a.y - o.y * l
+            };
+        return r.scale({
+            x: l,
+            y: l
+        }), r.position(u), l
+    }
 
-    function wbe(e, t, n) {
+    function i_e(e, t, n) {
         let {
-            featureNames: i
+            embedding: i = null
         } = t, {
-            features: r
+            itemId: r
+        } = t, {
+            views: s
+        } = t, {
+            masksGT: a
+        } = t, {
+            bboxes: o
+        } = t, {
+            selectedTool: l
+        } = t, {
+            categoryColor: u = null
+        } = t, {
+            prediction: c
         } = t;
-        const s = fc();
+        const f = Oxe;
+        let h = {},
+            d, g, p = {},
+            m, y, v = null,
+            b = {
+                width: 1024,
+                height: 780,
+                name: "konva"
+            },
+            x = {
+                rows: 0,
+                cols: 0
+            },
+            _;
+        const S = new ResizeObserver(P => {
+            for (const U of P)
+                if (U.target === g) {
+                    let X, ee;
+                    if (U.contentBoxSize) {
+                        const ye = Array.isArray(U.contentBoxSize) ? U.contentBoxSize[0] : U.contentBoxSize;
+                        X = ye.inlineSize, ee = ye.blockSize
+                    } else X = U.contentRect.width, ee = U.contentRect.height;
+                    m.width(X), m.height(ee), m.batchDraw()
+                }
+        });
+        async function w(P, U) {
+            n(3, p[U] = P.target, p)
+        }
 
-        function a(l) {
-            const u = l.find(c => c.name === "id");
-            s("itemclick", {
-                id: u.value
+        function E(P) {
+            const U = m.findOne(`#${P.viewId}`);
+            if (U) {
+                let X = m.width() / x.cols,
+                    ee = m.height() / x.rows,
+                    ye = 0;
+                for (let gf of s) {
+                    if (gf.viewId === P.viewId) break;
+                    ye++
+                }
+                let Oe = {
+                        x: ye % x.cols,
+                        y: Math.floor(ye / x.cols)
+                    },
+                    nt = ee / p[P.viewId].height,
+                    Ve = X / p[P.viewId].width,
+                    He = Math.min(Ve, nt);
+                h[P.viewId] = He, U.scale({
+                    x: He,
+                    y: He
+                });
+                let gn = (X - p[P.viewId].width * He) / 2 + Oe.x * X,
+                    _i = (ee - p[P.viewId].height * He) / 2 + Oe.y * ee;
+                U.x(gn), U.y(_i)
+            } else console.log("   CANNOT scale")
+        }
+        ra(() => {
+            for (let P of s) {
+                h[P.viewId] = 1;
+                const U = new Image;
+                U.src = P.imageURL, U.onload = X => {
+                    w(X, P.viewId).then(() => {
+                        E(P), n(15, a)
+                    })
+                }
+            }
+            _ = s, x.cols = Math.ceil(Math.sqrt(s.length)), x.rows = Math.ceil(s.length / x.cols), S.observe(g)
+        }), IO(() => {
+            if (l ? G() : m.container().style.cursor = "default", c && c.validated && I(c.viewId), a)
+                for (let P of s) L(P.viewId, r);
+            if (o)
+                for (let P of s) $(P.viewId, r);
+            if (s !== _) {
+                for (let P of s) {
+                    const U = m.findOne(`#${P.viewId}`);
+                    A(P.viewId), F(P.viewId), h[P.viewId] = 1;
+                    const X = new Image;
+                    X.src = P.imageURL, X.onload = ee => {
+                        w(ee, P.viewId).then(() => {
+                            U.findOne(`#${r}`).image(X), E(P), n(15, a)
+                        })
+                    }
+                }
+                _ = s
+            }
+        });
+
+        function C(P) {
+            let U = null,
+                ee = m.findOne(`#${P}`).findOne("#input");
+            for (let ye of ee.children)
+                if (ye instanceof Ot.Rect) {
+                    let Oe = ye.size(),
+                        nt = ye.position();
+                    U = {
+                        x: nt.x,
+                        y: nt.y,
+                        width: Oe.width,
+                        height: Oe.height
+                    };
+                    break
+                } return U
+        }
+
+        function k(P) {
+            let U = [],
+                ee = m.findOne(`#${P}`).findOne("#input");
+            for (let ye of ee.children)
+                if (ye instanceof Ot.Circle) {
+                    let Oe = {
+                        x: ye.x(),
+                        y: ye.y(),
+                        label: parseInt(ye.name())
+                    };
+                    U.push(Oe)
+                } return U
+        }
+
+        function A(P) {
+            m.findOne(`#${P}`).findOne("#input").destroyChildren()
+        }
+
+        function F(P) {
+            let ee = m.findOne(`#${P}`).findOne("#masks").findOne("#predictedMasks");
+            ee && ee.destroy()
+        }
+
+        function $(P, U) {
+            const X = m.findOne(`#${P}`);
+            if (X) {
+                const ee = X.findOne("#bboxes"),
+                    ye = X.findOne(`#${U}`),
+                    Oe = [];
+                for (let Ve = 0; Ve < o.length; ++Ve)
+                    if (o[Ve].viewId === P) {
+                        Oe.push(o[Ve].id);
+                        let He = ee.findOne(`#${o[Ve].id}`);
+                        He ? He.visible(o[Ve].visible) : T(o[Ve], ye, u(o[Ve].catId), ee)
+                    } const nt = [];
+                for (let Ve of ee.children) Oe.includes(Ve.id()) || nt.push(Ve);
+                for (let Ve of nt) Ve.destroy()
+            }
+        }
+
+        function T(P, U, X, ee) {
+            const ye = U.image().naturalWidth,
+                Oe = U.image().naturalHeight,
+                nt = U.x() + P.bbox[0] * ye,
+                Ve = U.y() + P.bbox[1] * Oe,
+                He = P.bbox[2] * ye,
+                gn = P.bbox[3] * Oe,
+                _i = new Ot.Group({
+                    id: P.id,
+                    visible: P.visible,
+                    listening: !1
+                }),
+                gf = new Ot.Rect({
+                    x: nt,
+                    y: Ve,
+                    width: He,
+                    height: gn,
+                    stroke: X,
+                    strokeWidth: 1,
+                    scale: U.scale()
+                });
+            _i.add(gf);
+            const pf = new Ot.Label({
+                x: nt + 1,
+                y: Ve + 1
+            });
+            pf.add(new Ot.Tag({
+                fill: X,
+                stroke: X
+            })), pf.add(new Ot.Text({
+                text: P.label,
+                fontSize: 6,
+                fontStyle: "bold",
+                fontFamily: "poppins",
+                padding: 0,
+                x: nt + 1,
+                y: Ve + 1
+            })), _i.add(pf), ee.add(_i)
+        }
+
+        function M(P, U, X, ee, ye, Oe, nt, Ve, He) {
+            let gn;
+            switch (Oe) {
+                case "green":
+                    gn = "rgba(0, 255, 0, 0.25)";
+                    break;
+                case "blue":
+                    gn = "rgba(0, 0, 255, 0.25)";
+                    break;
+                default:
+                    var _i = new Option().style;
+                    _i.color = Oe, _i.color !== "" ? gn = `rgba(${_i.color.replace("rgb(","").replace(")","")}, 0.35)` : gn = "rgba(255, 255, 255, 0.35)";
+                    break
+            }
+
+            function gf(va) {
+                const Br = va.split(" "),
+                    ba = Br[0].slice(1);
+                return {
+                    x: parseInt(ba),
+                    y: parseInt(Br[1])
+                }
+            }
+
+            function pf(va) {
+                const Br = va.split(" "),
+                    ba = Br[2].slice(1),
+                    mf = [{
+                        x: parseInt(ba),
+                        y: parseInt(Br[3])
+                    }];
+                for (let du = 4; du < Br.length; du += 2) mf.push({
+                    x: parseInt(Br[du]),
+                    y: parseInt(Br[du + 1])
+                });
+                return mf
+            }
+            const w7 = new Ot.Shape({
+                id: U,
+                x: X,
+                y: ee,
+                width: m.width(),
+                height: m.height(),
+                fill: gn,
+                stroke: Oe,
+                strokeWidth: t_e,
+                scale: ye,
+                visible: nt,
+                opacity: Ve,
+                listening: !1,
+                sceneFunc: (va, Br) => {
+                    va.beginPath();
+                    for (let ba = 0; ba < P.length; ++ba) {
+                        const mf = gf(P[ba]);
+                        va.moveTo(mf.x, mf.y);
+                        const du = pf(P[ba]);
+                        for (let qC of du) va.lineTo(qC.x, qC.y)
+                    }
+                    va.fillStrokeShape(Br)
+                }
+            });
+            He.add(w7)
+        }
+
+        function R(P) {
+            let X = m.findOne(`#${P}`).findOne("#masks"),
+                ee = X.findOne("#predictedMasks");
+            return ee || (ee = new Ot.Group({
+                id: "predictedMasks"
+            }), X.add(ee)), ee
+        }
+        async function N(P, U) {
+            const X = k(U),
+                ee = C(U),
+                ye = {
+                    image: p[U],
+                    embedding: i,
+                    points: X,
+                    box: ee
+                };
+            if (l.postProcessor == null) alert(`No interactive model set up, cannot segment. 
+
+Please refer to the interactive annotation notebook for information on how to export your model to ONNX.`);
+            else if (i == null) alert(`No embedding directory found, cannot segment.
+
+Please refer to the interactive annotation notebook for information on how to precompute embeddings on your dataset.`);
+            else {
+                const Oe = await l.postProcessor.segmentImage(ye);
+                if (Oe) {
+                    const nt = R(U),
+                        He = m.findOne(`#${U}`).findOne(`#${P}`);
+                    nt.removeChildren();
+                    const gn = f.generate();
+                    n(16, c = {
+                        id: gn,
+                        viewId: U,
+                        label: "",
+                        catId: -1,
+                        output: Oe,
+                        input_points: X,
+                        input_box: ee,
+                        validated: !1
+                    }), M(Oe.masksImageSVG, gn, He.x(), He.y(), He.scale(), "green", !0, 1, nt)
+                }
+            }
+        }
+
+        function L(P, U) {
+            const X = m.findOne(`#${P}`);
+            if (X) {
+                const ye = X.findOne("#masksGT"),
+                    Oe = X.findOne(`#${U}`);
+                let nt = [];
+                for (let He = 0; He < a.length; ++He)
+                    if (nt.push(a[He].id), a[He].viewId === P) {
+                        let gn = ye.findOne(`#${a[He].id}`);
+                        if (!gn) M(a[He].mask, a[He].id, Oe.x(), Oe.y(), Oe.scale(), u(a[He].catId), a[He].visible, 1, ye);
+                        else {
+                            gn.visible(a[He].visible), gn.opacity(a[He].opacity);
+                            let _i = gn;
+                            if (typeof _i.fill == "function") {
+                                var ee = new Option().style;
+                                ee.color = u(a[He].catId), _i.fill(`rgba(${ee.color.replace("rgb(","").replace(")","")}, 0.35)`), _i.stroke(ee.color)
+                            }
+                        }
+                    } const Ve = [];
+                for (let He of ye.children) nt.includes(He.id()) || Ve.push(He);
+                for (let He of Ve) He.destroy()
+            }
+        }
+
+        function I(P) {
+            if (c.validated) {
+                const X = m.findOne(`#${P}`);
+                let ee = R(P);
+                if (ee) {
+                    const ye = X.findOne("#masksGT");
+                    ee.id(c.id);
+                    for (let Oe of ee.children) {
+                        let nt = Oe;
+                        var U = new Option().style;
+                        U.color = u(c.catId), nt.fill(`rgba(${U.color.replace("rgb(","").replace(")","")}, 0.35)`), nt.stroke(U.color)
+                    }
+                    ee.moveTo(ye), a.push({
+                        viewId: P,
+                        id: c.id,
+                        mask: c.output.masksImageSVG,
+                        rle: c.output.rle,
+                        catId: c.catId,
+                        visible: !0,
+                        opacity: 1
+                    }), v && qe(v), A(c.viewId), n(16, c = null)
+                }
+            }
+        }
+
+        function G() {
+            switch (y && y.moveToTop(), l.type) {
+                case wi.LabeledPoint:
+                    l7(l);
+                    break;
+                case wi.Rectangle:
+                    c7(l);
+                    break;
+                case wi.Pan:
+                    f7(l);
+                    break
+            }
+        }
+
+        function ie() {
+            const P = m.getRelativePointerPosition();
+            (l == null ? void 0 : l.type) == wi.LabeledPoint && h7(P), (l == null ? void 0 : l.type) == wi.Rectangle && d7(P)
+        }
+
+        function ge(P) {
+            for (let U of y.children) U.show()
+        }
+
+        function Re(P) {
+            for (let U of y.children) U.hide()
+        }
+
+        function Te() {
+            ie()
+        }
+
+        function tt(P) {
+            const U = m.findOne(`#${P}`);
+            U.draggable(!1), U.off("dragend dragmove")
+        }
+
+        function wn(P, U) {
+            const X = m.findOne(`#${U}`);
+            if (X.draggable(!1), X.off("dragend dragmove"), v) {
+                const ee = X.getRelativePointerPosition(),
+                    ye = v.position();
+                (ee.x !== ye.x || ee.y !== ye.y) && qe(v, U)
+            }
+        }
+
+        function Pi(P) {
+            const X = m.findOne(`#${P}`).findOne("#input");
+            for (let ee of X.children) ee instanceof Ot.Circle && (ee.radius(Yf / h[P]), ee.strokeWidth(Mb / h[P])), ee instanceof Ot.Rect && ee.strokeWidth(bO / h[P])
+        }
+
+        function xi(P, U) {
+            P.detail.evt.preventDefault();
+            let X = P.detail.evt.deltaY < 0 ? 1 : -1;
+            P.detail.evt.ctrlKey && (X = -X), h[U] = n_e(m, X, U), Pi(U), v && be(v, U)
+        }
+
+        function ae(P, U) {
+            m.findOne(`#${U}`).moveToTop(), y.moveToTop()
+        }
+        async function _e(P, U, X) {
+            const ee = m.findOne(`#${X}`);
+            if ((l == null ? void 0 : l.type) == wi.Pan || P.detail.evt.which == 2) ee.draggable(!0), ee.on("dragmove", Te), ee.on("dragend", () => tt(X));
+            else if ((l == null ? void 0 : l.type) == wi.LabeledPoint) {
+                const ye = ee.getRelativePointerPosition(),
+                    Oe = new Ot.Circle({
+                        name: `${l.label}`,
+                        x: ye.x,
+                        y: ye.y,
+                        radius: Yf / h[X],
+                        stroke: "white",
+                        fill: l.label === 1 ? "green" : "red",
+                        strokeWidth: Mb / h[X],
+                        visible: !0,
+                        listening: !0,
+                        opacity: .75,
+                        draggable: !0
+                    });
+                Oe.on("pointerenter", Ve => be(Ve.target, X)), Oe.on("pointerout", Ve => qe(Ve.target, X)), Oe.on("dragmove", Ve => $s(Ve.target, U, X)), Oe.on("dragend", Ve => dn(Ve.target)), ee.findOne("#input").add(Oe), be(Oe, X), N(U, X)
+            } else if ((l == null ? void 0 : l.type) == wi.Rectangle) {
+                const ye = ee.getRelativePointerPosition(),
+                    Oe = ee.findOne("#input");
+                let nt = Oe.findOne("#drag-rect");
+                nt ? (nt.position({
+                    x: ye.x,
+                    y: ye.y
+                }), nt.size({
+                    width: 0,
+                    height: 0
+                })) : (nt = new Ot.Rect({
+                    id: "drag-rect",
+                    x: ye.x + 1,
+                    y: ye.y + 1,
+                    width: 0,
+                    height: 0,
+                    stroke: "white",
+                    dash: [10, 5],
+                    fill: "rgba(255, 255, 255, 0.25)",
+                    strokeWidth: bO / h[X],
+                    listening: !1
+                }), Oe.add(nt)), ee.on("pointermove", () => Ae(X)), ee.on("pointerup", () => Y(X))
+            }
+        }
+
+        function Ae(P) {
+            if ((l == null ? void 0 : l.type) == wi.Rectangle) {
+                const U = m.findOne(`#${P}`),
+                    ee = U.findOne("#input").findOne("#drag-rect");
+                if (ee) {
+                    const ye = U.getRelativePointerPosition();
+                    ee.width(ye.x - ee.x()), ee.size({
+                        width: ye.x - ee.x(),
+                        height: ye.y - ee.y()
+                    })
+                }
+            }
+        }
+
+        function Y(P) {
+            if ((l == null ? void 0 : l.type) == wi.Rectangle) {
+                const U = m.findOne(`#${P}`),
+                    ee = U.findOne("#input").findOne("#drag-rect");
+                if (ee) {
+                    const {
+                        width: ye,
+                        height: Oe
+                    } = ee.size();
+                    ye == 0 || Oe == 0 ? ee.destroy() : N(r, P), U.off("pointermove"), U.off("pointerup")
+                }
+            }
+        }
+
+        function je(P) {
+            let U;
+            return v.getAncestors().forEach(X => {
+                X instanceof Ot.Layer && (U = X.id())
+            }), U
+        }
+
+        function be(P, U) {
+            Do(l.type, U).hide(), v = P, v.radius(1.5 * Yf / h[U]), m.container().style.cursor = "grab"
+        }
+
+        function qe(P, U = null) {
+            Do(l.type, U).show(), U || (U = je()), P.radius(Yf / h[U]), v = null, m.container().style.cursor = l.cursor, m.batchDraw()
+        }
+
+        function dn(P, U) {
+            m.container().style.cursor = "grab"
+        }
+
+        function $s(P, U, X) {
+            m.container().style.cursor = "grabbing";
+            const Oe = m.findOne(`#${X}`).findOne(`#${U}`).getSize();
+            P.x() < 0 ? P.x(0) : P.x() > Oe.width && P.x(Oe.width), P.y() < 0 ? P.y(0) : P.y() > Oe.height && P.y(Oe.height), clearTimeout(d), d = setTimeout(() => N(U, X), 50)
+        }
+
+        function Do(P, U = null) {
+            let X = m.findOne(`#${P}`);
+            if (!X) {
+                let ee = 1;
+                U && (ee = h[U]), X = new Ot.Circle({
+                    id: P,
+                    x: 0,
+                    y: 0,
+                    radius: Yf / ee,
+                    fill: "white",
+                    strokeWidth: Mb / ee,
+                    visible: !1,
+                    listening: !1,
+                    opacity: .5
+                }), y.add(X)
+            }
+            return X
+        }
+
+        function o7() {
+            const P = m.height(),
+                U = m.width();
+            let X = y.findOne("#crossline"),
+                ee, ye;
+            return X ? (ee = X.findOne("#xline"), ye = X.findOne("#yline")) : (X = new Ot.Group({
+                id: "crossline"
+            }), ee = new Ot.Line({
+                id: "xline",
+                points: [0, 0, 0, P],
+                stroke: "red",
+                strokeWidth: 1,
+                opacity: .75,
+                dash: [5, 1]
+            }), ye = new Ot.Line({
+                id: "yline",
+                points: [0, 0, U, 0],
+                stroke: "red",
+                strokeWidth: 1,
+                opacity: .75,
+                dash: [5, 1]
+            }), X.add(ee), X.add(ye), y.add(X)), {
+                xLimit: ee,
+                yLimit: ye
+            }
+        }
+
+        function l7(P) {
+            if (y) {
+                let U = y.findOne("#crossline");
+                U && U.destroy();
+                let X = Do(P.type);
+                const ee = P.label === 1 ? "green" : "red";
+                X.stroke(ee), v || (m.container().style.cursor = P.cursor)
+            }
+        }
+
+        function u7(P) {
+            var U;
+            if (P.key == "Delete" && v != null) {
+                const X = je(),
+                    ee = v;
+                qe(v, X), ee.destroy(), m.findOne(`#${X}`).findOne("#input").children.length > 0 ? N(r, X) : F(X)
+            }
+            if (P.key == "Escape") {
+                for (let X of s) A(X.viewId), F(X.viewId);
+                m.container().style.cursor = l.cursor, n(16, c = null)
+            }
+            if (P.key == "i") {
+                console.log("INFOS"), console.log("masksGT", a), console.log("prediction", c), console.log("stage", m);
+                for (let X of s) {
+                    const ye = m.findOne(`#${X.viewId}`).findOne("#masksGT");
+                    console.log("masksGT Konva group:", ye), console.log("masksGT children length:", (U = ye.children) == null ? void 0 : U.length)
+                }
+            }
+        }
+
+        function c7(P) {
+            if (y) {
+                let U = m.findOne(`#${wi.LabeledPoint}`);
+                U && U.destroy(), v || (m.container().style.cursor = P.cursor)
+            }
+        }
+
+        function f7(P) {
+            if (y) {
+                let U = m.findOne(`#${wi.LabeledPoint}`);
+                U && U.destroy();
+                let X = m.findOne("#crossline");
+                X && X.destroy(), v || (m.container().style.cursor = P.cursor)
+            }
+        }
+
+        function h7(P) {
+            let U = Do(l.type);
+            const X = m.scaleX(),
+                ee = Math.max(1, 1 / X);
+            U.scaleX(ee), U.scaleY(ee), U.x(P.x + 1), U.y(P.y + 1)
+        }
+
+        function d7(P) {
+            const U = m.scaleX(),
+                X = Math.max(1, 1 / U);
+            let {
+                xLimit: ee,
+                yLimit: ye
+            } = o7();
+            const Oe = m.height();
+            ee.scaleY(X), ee.points([P.x, 0, P.x, Oe]);
+            const nt = m.width();
+            ye.scaleX(X), ye.points([0, P.y, nt, P.y])
+        }
+        const g7 = (P, U) => _e(U, r, P.viewId),
+            p7 = (P, U) => wn(U, P.viewId),
+            m7 = (P, U) => ae(U, P.viewId),
+            y7 = (P, U) => xi(U, P.viewId);
+
+        function v7(P) {
+            y = P, n(5, y)
+        }
+
+        function b7(P) {
+            b = P, n(6, b)
+        }
+
+        function x7(P) {
+            m = P, n(4, m)
+        }
+
+        function _7(P) {
+            Hi[P ? "unshift" : "push"](() => {
+                g = P, n(2, g)
             })
         }
-        const o = l => {
-            a(l)
-        };
-        return e.$$set = l => {
-            "featureNames" in l && n(0, i = l.featureNames), "features" in l && n(1, r = l.features)
-        }, [i, r, a, o]
+        return e.$$set = P => {
+            "embedding" in P && n(17, i = P.embedding), "itemId" in P && n(0, r = P.itemId), "views" in P && n(1, s = P.views), "masksGT" in P && n(15, a = P.masksGT), "bboxes" in P && n(18, o = P.bboxes), "selectedTool" in P && n(19, l = P.selectedTool), "categoryColor" in P && n(20, u = P.categoryColor), "prediction" in P && n(16, c = P.prediction)
+        }, [r, s, g, p, m, y, b, ie, ge, Re, wn, xi, ae, _e, u7, a, c, i, o, l, u, g7, p7, m7, y7, v7, b7, x7, _7]
     }
-    class Sbe extends wn {
+    class r_e extends It {
         constructor(t) {
-            super(), _n(this, t, wbe, _be, tn, {
-                featureNames: 0,
-                features: 1
-            })
+            super(), Lt(this, t, i_e, e_e, Tt, {
+                embedding: 17,
+                itemId: 0,
+                views: 1,
+                masksGT: 15,
+                bboxes: 18,
+                selectedTool: 19,
+                categoryColor: 20,
+                prediction: 16
+            }, null, [-1, -1, -1])
+        }
+    }
+
+    function s_e(e) {
+        for (var t = e.length / 6 | 0, n = new Array(t), i = 0; i < t;) n[i] = "#" + e.slice(i * 6, ++i * 6);
+        return n
+    }
+    const a_e = s_e("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f");
+
+    function wh(e, t, n) {
+        this.k = e, this.x = t, this.y = n
+    }
+    wh.prototype = {
+        constructor: wh,
+        scale: function(e) {
+            return e === 1 ? this : new wh(this.k * e, this.x, this.y)
+        },
+        translate: function(e, t) {
+            return e === 0 & t === 0 ? this : new wh(this.k, this.x + this.k * e, this.y + this.k * t)
+        },
+        apply: function(e) {
+            return [e[0] * this.k + this.x, e[1] * this.k + this.y]
+        },
+        applyX: function(e) {
+            return e * this.k + this.x
+        },
+        applyY: function(e) {
+            return e * this.k + this.y
+        },
+        invert: function(e) {
+            return [(e[0] - this.x) / this.k, (e[1] - this.y) / this.k]
+        },
+        invertX: function(e) {
+            return (e - this.x) / this.k
+        },
+        invertY: function(e) {
+            return (e - this.y) / this.k
+        },
+        rescaleX: function(e) {
+            return e.copy().domain(e.range().map(this.invertX, this).map(e.invert, e))
+        },
+        rescaleY: function(e) {
+            return e.copy().domain(e.range().map(this.invertY, this).map(e.invert, e))
+        },
+        toString: function() {
+            return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")"
         }
+    };
+    wh.prototype;
+    /**
+    @copyright CEA-LIST/DIASI/SIALV/LVA (2023)
+    @author CEA-LIST/DIASI/SIALV/LVA <pixano@cea.fr>
+    @license CECILL-C
+
+    This software is a collaborative computer program whose purpose is to
+    generate and explore labeled data for computer vision applications.
+    This software is governed by the CeCILL-C license under French law and
+    abiding by the rules of distribution of free software. You can use, 
+    modify and/ or redistribute the software under the terms of the CeCILL-C
+    license as circulated by CEA, CNRS and INRIA at the following URL
+
+    http://www.cecill.info
+    */
+    function s7(e) {
+        return l1().domain(e).range(a_e)
     }
 
-    function yM(e, t, n) {
+    function xO(e, t, n) {
         const i = e.slice();
-        return i[9] = t[n], i
+        return i[23] = t[n], i
     }
 
-    function Ebe(e) {
-        let t;
+    function _O(e, t, n) {
+        const i = e.slice();
+        return i[26] = t[n], i
+    }
+
+    function wO(e) {
+        let t, n, i, r, s = e[0].id + "",
+            a;
         return {
             c() {
-                t = J("span"), t.textContent = "No stats available.", j(t, "class", "mt-80 italic text-zinc-500")
+                t = V("div"), n = V("span"), n.textContent = "id :", i = we(), r = V("span"), a = Xe(s), z(n, "class", "font-bold")
             },
-            m(n, i) {
-                we(n, t, i)
+            m(o, l) {
+                de(o, t, l), B(t, n), B(t, i), B(t, r), B(r, a)
             },
-            p: Ve,
-            i: Ve,
-            o: Ve,
-            d(n) {
-                n && _e(t)
+            p(o, l) {
+                l & 1 && s !== (s = o[0].id + "") && At(a, s)
+            },
+            d(o) {
+                o && he(t)
             }
         }
     }
 
-    function Cbe(e) {
-        let t, n, i = e[0],
-            r = [];
-        for (let a = 0; a < i.length; a += 1) r[a] = vM(yM(e, i, a));
-        const s = a => Ie(r[a], 1, 1, () => {
-            r[a] = null
-        });
+    function SO(e) {
+        let t, n, i, r, s = e[0].filename + "",
+            a;
         return {
             c() {
-                t = J("div");
-                for (let a = 0; a < r.length; a += 1) r[a].c();
-                j(t, "class", "grid grid-cols-3 my-2")
+                t = V("div"), n = V("span"), n.textContent = "Filename :", i = we(), r = V("span"), a = Xe(s), z(n, "class", "font-bold")
             },
-            m(a, o) {
-                we(a, t, o);
-                for (let l = 0; l < r.length; l += 1) r[l] && r[l].m(t, null);
-                n = !0
+            m(o, l) {
+                de(o, t, l), B(t, n), B(t, i), B(t, r), B(r, a)
             },
-            p(a, o) {
-                if (o & 1) {
-                    i = a[0];
-                    let l;
-                    for (l = 0; l < i.length; l += 1) {
-                        const u = yM(a, i, l);
-                        r[l] ? (r[l].p(u, o), Te(r[l], 1)) : (r[l] = vM(u), r[l].c(), Te(r[l], 1), r[l].m(t, null))
-                    }
-                    for (ur(), l = i.length; l < r.length; l += 1) s(l);
-                    cr()
-                }
+            p(o, l) {
+                l & 1 && s !== (s = o[0].filename + "") && At(a, s)
             },
-            i(a) {
-                if (!n) {
-                    for (let o = 0; o < i.length; o += 1) Te(r[o]);
-                    n = !0
-                }
+            d(o) {
+                o && he(t)
+            }
+        }
+    }
+
+    function EO(e) {
+        let t, n, i, r, s = e[0].width + "",
+            a, o, l = e[0].height + "",
+            u, c;
+        return {
+            c() {
+                t = V("div"), n = V("span"), n.textContent = "Size :", i = we(), r = V("span"), a = Xe(s), o = Xe("x"), u = Xe(l), c = Xe("px"), z(n, "class", "font-bold")
             },
-            o(a) {
-                r = r.filter(Boolean);
-                for (let o = 0; o < r.length; o += 1) Ie(r[o]);
-                n = !1
+            m(f, h) {
+                de(f, t, h), B(t, n), B(t, i), B(t, r), B(r, a), B(r, o), B(r, u), B(r, c)
             },
-            d(a) {
-                a && _e(t), Vo(r, a)
+            p(f, h) {
+                h & 1 && s !== (s = f[0].width + "") && At(a, s), h & 1 && l !== (l = f[0].height + "") && At(u, l)
+            },
+            d(f) {
+                f && he(t)
             }
         }
     }
 
-    function vM(e) {
-        let t, n, i, r;
-        return n = new P8({
-            props: {
-                hist: e[9]
-            }
-        }), {
+    function kO(e) {
+        let t, n = e[0].categoryStats,
+            i = [];
+        for (let r = 0; r < n.length; r += 1) i[r] = AO(_O(e, n, r));
+        return {
             c() {
-                t = J("div"), ei(n.$$.fragment), i = Ee(), j(t, "class", "ml-2 mb-2")
+                for (let r = 0; r < i.length; r += 1) i[r].c();
+                t = Zi()
             },
-            m(s, a) {
-                we(s, t, a), Nn(n, t, null), G(t, i), r = !0
+            m(r, s) {
+                for (let a = 0; a < i.length; a += 1) i[a] && i[a].m(r, s);
+                de(r, t, s)
             },
-            p(s, a) {
-                const o = {};
-                a & 1 && (o.hist = s[9]), n.$set(o)
+            p(r, s) {
+                if (s & 131) {
+                    n = r[0].categoryStats;
+                    let a;
+                    for (a = 0; a < n.length; a += 1) {
+                        const o = _O(r, n, a);
+                        i[a] ? i[a].p(o, s) : (i[a] = AO(o), i[a].c(), i[a].m(t.parentNode, t))
+                    }
+                    for (; a < i.length; a += 1) i[a].d(1);
+                    i.length = n.length
+                }
             },
-            i(s) {
-                r || (Te(n.$$.fragment, s), r = !0)
+            d(r) {
+                Ja(i, r), r && he(t)
+            }
+        }
+    }
+
+    function CO(e) {
+        let t, n = e[26].count + "",
+            i;
+        return {
+            c() {
+                t = V("span"), i = Xe(n), z(t, "class", "block absolute -right-3 -top-2 h-fit px-1 text-xs rounded-full bg-rose-500 text-white font-bold")
             },
-            o(s) {
-                Ie(n.$$.fragment, s), r = !1
+            m(r, s) {
+                de(r, t, s), B(t, i)
             },
-            d(s) {
-                s && _e(t), Pn(n)
+            p(r, s) {
+                s & 1 && n !== (n = r[26].count + "") && At(i, n)
+            },
+            d(r) {
+                r && he(t)
             }
         }
     }
 
-    function kbe(e) {
-        let t;
+    function AO(e) {
+        let t, n = e[26].name + "",
+            i, r, s, a, o, l, u = e[26].count != 1 && CO(e);
+
+        function c() {
+            return e[14](e[26])
+        }
         return {
             c() {
-                t = J("div"), t.innerHTML = '<span class="text-zinc-500 italic">Loading items ...</span>', j(t, "class", "h-full flex justify-center items-center")
+                t = V("button"), i = Xe(n), r = we(), u && u.c(), s = we(), z(t, "class", "relative px-1 mb-2 mr-4 rounded-lg text-sm text-zinc-900 font-bold border-2 border-transparent hover:border-rose-500"), KC(t, "background-color", e[1](e[26].id)), z(t, "id", a = "cat-" + e[26].id)
             },
-            m(n, i) {
-                we(n, t, i)
+            m(f, h) {
+                de(f, t, h), B(t, i), B(t, r), u && u.m(t, null), B(t, s), o || (l = jt(t, "click", c), o = !0)
             },
-            p: Ve,
-            i: Ve,
-            o: Ve,
-            d(n) {
-                n && _e(t)
+            p(f, h) {
+                e = f, h & 1 && n !== (n = e[26].name + "") && At(i, n), e[26].count != 1 ? u ? u.p(e, h) : (u = CO(e), u.c(), u.m(t, s)) : u && (u.d(1), u = null), h & 3 && KC(t, "background-color", e[1](e[26].id)), h & 1 && a !== (a = "cat-" + e[26].id) && z(t, "id", a)
+            },
+            d(f) {
+                f && he(t), u && u.d(), o = !1, l()
             }
         }
     }
 
-    function Abe(e) {
-        let t, n, i, r, s, a = 1 + wa * (e[3] - 1) + "",
-            o, l, u = wa * e[3] + "",
-            c, f, h = e[1].total + "",
-            d, g, p, m, y, v, b, x;
-        return n = new Sbe({
-            props: {
-                features: e[1].items,
-                featureNames: e[2]
-            }
-        }), n.$on("itemclick", e[4]), {
+    function $O(e) {
+        let t, n, i, r, s, a, o, l, u, c, f, h, d, g = e[1] != null && TO(e);
+        return {
             c() {
-                t = J("div"), ei(n.$$.fragment), i = Ee(), r = J("div"), s = J("span"), o = Je(a), l = Je(" - "), c = Je(u), f = Je(" of "), d = Je(h), g = Ee(), p = J("button"), p.textContent = "PREV", m = Ee(), y = J("button"), y.textContent = "NEXT", j(t, "class", "h-[85vh] w-full mb-1"), j(s, "class", "mr-2"), j(p, "class", "py-1 px-2 bg-white border-2 rounded-lg text-zinc-500 text-sm font-medium hover:bg-zinc-100 dark:bg-zinc-900 dark:border-zinc-800 dark:text-zinc-300 dark:hover:bg-zinc-700"), j(y, "class", "py-1 px-2 bg-white border-2 rounded-lg text-zinc-500 text-sm font-medium hover:bg-zinc-100 dark:bg-zinc-900 dark:border-zinc-800 dark:text-zinc-300 dark:hover:bg-zinc-700"), j(r, "class", "flex justify-end items-center w-full space-x-2")
+                t = V("div"), n = V("span"), n.textContent = "Views", i = we(), r = V("div"), s = V("input"), a = we(), o = V("label"), o.textContent = "Show all views", l = we(), u = V("span"), u.textContent = "Views :", c = we(), f = V("div"), g && g.c(), z(n, "class", "mb-2 self-center text-center text-sm text-zinc-500 font-medium uppercase dark:text-zinc-400"), z(s, "class", "cursor-pointer checked:accent-rose-500"), z(s, "type", "checkbox"), z(s, "id", "toggle-views"), s.checked = !0, z(o, "class", "font-bold cursor-pointer"), z(o, "for", "toggle-views"), z(r, "class", "mb-2 flex items-center space-x-2"), z(t, "class", "mt-2 pt-2 flex flex-col border-t dark:border-zinc-700"), z(u, "class", "font-bold"), z(f, "class", "flex flex-col")
             },
-            m(_, S) {
-                we(_, t, S), Nn(n, t, null), we(_, i, S), we(_, r, S), G(r, s), G(s, o), G(s, l), G(s, c), G(s, f), G(s, d), G(r, g), G(r, p), G(r, m), G(r, y), v = !0, b || (x = [wt(p, "click", e[5]), wt(y, "click", e[6])], b = !0)
+            m(p, m) {
+                de(p, t, m), B(t, n), B(t, i), B(t, r), B(r, s), B(r, a), B(r, o), de(p, l, m), de(p, u, m), de(p, c, m), de(p, f, m), g && g.m(f, null), h || (d = jt(s, "change", e[10]), h = !0)
             },
-            p(_, S) {
-                const w = {};
-                S & 2 && (w.features = _[1].items), S & 4 && (w.featureNames = _[2]), n.$set(w), (!v || S & 8) && a !== (a = 1 + wa * (_[3] - 1) + "") && Ot(o, a), (!v || S & 8) && u !== (u = wa * _[3] + "") && Ot(c, u), (!v || S & 2) && h !== (h = _[1].total + "") && Ot(d, h)
+            p(p, m) {
+                p[1] != null ? g ? g.p(p, m) : (g = TO(p), g.c(), g.m(f, null)) : g && (g.d(1), g = null)
             },
-            i(_) {
-                v || (Te(n.$$.fragment, _), v = !0)
+            d(p) {
+                p && he(t), p && he(l), p && he(u), p && he(c), p && he(f), g && g.d(), h = !1, d()
+            }
+        }
+    }
+
+    function TO(e) {
+        let t, n = Object.keys(e[0].views),
+            i = [];
+        for (let r = 0; r < n.length; r += 1) i[r] = MO(xO(e, n, r));
+        return {
+            c() {
+                for (let r = 0; r < i.length; r += 1) i[r].c();
+                t = Zi()
             },
-            o(_) {
-                Ie(n.$$.fragment, _), v = !1
+            m(r, s) {
+                for (let a = 0; a < i.length; a += 1) i[a] && i[a].m(r, s);
+                de(r, t, s)
             },
-            d(_) {
-                _ && _e(t), Pn(n), _ && _e(i), _ && _e(r), b = !1, js(x)
+            p(r, s) {
+                if (s & 513) {
+                    n = Object.keys(r[0].views);
+                    let a;
+                    for (a = 0; a < n.length; a += 1) {
+                        const o = xO(r, n, a);
+                        i[a] ? i[a].p(o, s) : (i[a] = MO(o), i[a].c(), i[a].m(t.parentNode, t))
+                    }
+                    for (; a < i.length; a += 1) i[a].d(1);
+                    i.length = n.length
+                }
+            },
+            d(r) {
+                Ja(i, r), r && he(t)
             }
         }
     }
 
-    function $be(e) {
-        let t, n, i, r, s, a, o, l, u, c, f, h;
-        const d = [Cbe, Ebe],
-            g = [];
-
-        function p(b, x) {
-            return b[0] != null && b[0].length != 0 ? 0 : 1
-        }
-        a = p(e), o = g[a] = d[a](e);
-        const m = [Abe, kbe],
-            y = [];
+    function MO(e) {
+        let t, n, i, r, s, a = e[23] + "",
+            o, l, u, c, f;
 
-        function v(b, x) {
-            return b[1] ? 0 : 1
+        function h() {
+            return e[15](e[23])
         }
-        return c = v(e), f = y[c] = m[c](e), {
+        return {
             c() {
-                t = J("div"), n = J("div"), i = J("div"), r = J("span"), r.textContent = "Stats", s = Ee(), o.c(), l = Ee(), u = J("div"), f.c(), j(r, "class", "font-bold text-xl mt-3"), j(i, "class", "w-1/2 h-[85vh] pr-4 flex flex-col items-center border rounded-lg overflow-y-scroll dark:border-zinc-700 dark:bg-zinc-800"), j(u, "class", "w-1/2 ml-4"), j(n, "class", "flex"), j(t, "class", "mt-4 px-2")
+                t = V("div"), n = V("input"), r = we(), s = V("label"), o = Xe(a), u = we(), z(n, "class", "cursor-pointer checked:accent-rose-500"), z(n, "type", "checkbox"), z(n, "id", i = "view-" + e[23]), n.checked = !0, z(s, "class", "font-medium cursor-pointer"), z(s, "for", l = "view-" + e[23]), z(t, "class", "ml-1 flex items-center space-x-2")
             },
-            m(b, x) {
-                we(b, t, x), G(t, n), G(n, i), G(i, r), G(i, s), g[a].m(i, null), G(n, l), G(n, u), y[c].m(u, null), h = !0
+            m(d, g) {
+                de(d, t, g), B(t, n), B(t, r), B(t, s), B(s, o), B(t, u), c || (f = jt(n, "change", h), c = !0)
             },
-            p(b, [x]) {
-                let _ = a;
-                a = p(b), a === _ ? g[a].p(b, x) : (ur(), Ie(g[_], 1, 1, () => {
-                    g[_] = null
-                }), cr(), o = g[a], o ? o.p(b, x) : (o = g[a] = d[a](b), o.c()), Te(o, 1), o.m(i, null));
-                let S = c;
-                c = v(b), c === S ? y[c].p(b, x) : (ur(), Ie(y[S], 1, 1, () => {
-                    y[S] = null
-                }), cr(), f = y[c], f ? f.p(b, x) : (f = y[c] = m[c](b), f.c()), Te(f, 1), f.m(u, null))
+            p(d, g) {
+                e = d, g & 1 && i !== (i = "view-" + e[23]) && z(n, "id", i), g & 1 && a !== (a = e[23] + "") && At(o, a), g & 1 && l !== (l = "view-" + e[23]) && z(s, "for", l)
             },
-            i(b) {
-                h || (Te(o), Te(f), h = !0)
+            d(d) {
+                d && he(t), c = !1, f()
+            }
+        }
+    }
+
+    function o_e(e) {
+        let t, n, i, r, s, a, o, l, u, c, f, h, d, g, p, m, y, v, b, x, _, S, w, E = e[2] * 100 + "",
+            C, k, A, F, $, T, M, R = Math.round(e[3] * 100) + "",
+            N, L, I, G, ie, ge, Re, Te, tt, wn = Object.keys(e[0].views).length != 1,
+            Pi, xi, ae = e[0].id && wO(e),
+            _e = e[0].filename && SO(e),
+            Ae = e[0].width && e[0].height && EO(e),
+            Y = e[1] != null && kO(e),
+            je = wn && $O(e);
+        return {
+            c() {
+                t = V("div"), n = V("div"), i = V("span"), i.textContent = "Data", r = we(), s = V("div"), ae && ae.c(), a = we(), _e && _e.c(), o = we(), Ae && Ae.c(), l = we(), u = V("div"), c = V("span"), c.textContent = "Tools", f = we(), h = V("div"), d = V("input"), g = we(), p = V("label"), p.textContent = "Show all annotations", m = we(), y = V("div"), v = V("input"), b = we(), x = V("label"), x.textContent = "Show bounding boxes", _ = we(), S = V("label"), w = Xe("Mask opacity: "), C = Xe(E), k = Xe("%"), A = we(), F = V("input"), $ = we(), T = V("label"), M = Xe("Confidence threshold: "), N = Xe(R), L = Xe("%"), I = we(), G = V("input"), ie = we(), ge = V("span"), ge.textContent = "Labels:", Re = we(), Te = V("div"), Y && Y.c(), tt = we(), je && je.c(), z(i, "class", "mb-2 self-center text-sm text-zinc-500 font-bold uppercase dark:text-zinc-400"), z(s, "class", "flex flex-col"), z(n, "class", "flex flex-col"), z(c, "class", "mb-2 self-center text-center text-sm text-zinc-500 font-bold uppercase dark:text-zinc-400"), z(d, "class", "cursor-pointer checked:accent-rose-500"), z(d, "type", "checkbox"), z(d, "id", "toggle-items"), d.checked = !0, z(p, "class", "font-bold cursor-pointer"), z(p, "for", "toggle-items"), z(h, "class", "mb-2 flex items-center space-x-2"), z(v, "class", "cursor-pointer checked:accent-rose-500"), z(v, "type", "checkbox"), z(v, "id", "toggle-boxes"), v.checked = !0, z(x, "class", "font-bold cursor-pointer"), z(x, "for", "toggle-boxes"), z(y, "class", "mb-2 flex items-center space-x-2"), z(S, "class", "font-bold mt-2 mb-1"), z(S, "for", "slider"), z(F, "class", "cursor-pointer"), z(F, "type", "range"), z(F, "id", "slider"), z(F, "min", "0"), z(F, "max", "1"), z(F, "step", "0.1"), z(T, "class", "font-bold mt-2 mb-1"), z(T, "for", "slider"), z(G, "class", "cursor-pointer"), z(G, "type", "range"), z(G, "id", "slider"), z(G, "min", "0"), z(G, "max", "1"), z(G, "step", "0.01"), z(u, "class", "mt-2 pt-2 flex flex-col border-t dark:border-zinc-700"), z(ge, "class", "font-bold mb-2 mt-2"), z(Te, "class", "flex flex-wrap"), z(t, "class", "absolute w-72 top-1/2 -translate-y-1/2 right-6 py-2 px-4 flex flex-col bg-white text-zinc-900 border rounded-lg shadow-xl dark:text-zinc-300 dark:bg-zinc-900 dark:border-zinc-500")
             },
-            o(b) {
-                Ie(o), Ie(f), h = !1
+            m(be, qe) {
+                de(be, t, qe), B(t, n), B(n, i), B(n, r), B(n, s), ae && ae.m(s, null), B(s, a), _e && _e.m(s, null), B(s, o), Ae && Ae.m(s, null), B(t, l), B(t, u), B(u, c), B(u, f), B(u, h), B(h, d), B(h, g), B(h, p), B(u, m), B(u, y), B(y, v), B(y, b), B(y, x), B(u, _), B(u, S), B(S, w), B(S, C), B(S, k), B(u, A), B(u, F), vg(F, e[2]), B(u, $), B(u, T), B(T, M), B(T, N), B(T, L), B(u, I), B(u, G), vg(G, e[3]), B(t, ie), B(t, ge), B(t, Re), B(t, Te), Y && Y.m(Te, null), B(t, tt), je && je.m(t, null), Pi || (xi = [jt(d, "change", e[8]), jt(v, "change", e[6]), jt(F, "change", e[12]), jt(F, "input", e[12]), jt(F, "input", e[5]), jt(G, "change", e[13]), jt(G, "input", e[13]), jt(G, "input", e[4])], Pi = !0)
             },
-            d(b) {
-                b && _e(t), g[a].d(), y[c].d()
+            p(be, [qe]) {
+                be[0].id ? ae ? ae.p(be, qe) : (ae = wO(be), ae.c(), ae.m(s, a)) : ae && (ae.d(1), ae = null), be[0].filename ? _e ? _e.p(be, qe) : (_e = SO(be), _e.c(), _e.m(s, o)) : _e && (_e.d(1), _e = null), be[0].width && be[0].height ? Ae ? Ae.p(be, qe) : (Ae = EO(be), Ae.c(), Ae.m(s, null)) : Ae && (Ae.d(1), Ae = null), qe & 4 && E !== (E = be[2] * 100 + "") && At(C, E), qe & 4 && vg(F, be[2]), qe & 8 && R !== (R = Math.round(be[3] * 100) + "") && At(N, R), qe & 8 && vg(G, be[3]), be[1] != null ? Y ? Y.p(be, qe) : (Y = kO(be), Y.c(), Y.m(Te, null)) : Y && (Y.d(1), Y = null), qe & 1 && (wn = Object.keys(be[0].views).length != 1), wn ? je ? je.p(be, qe) : (je = $O(be), je.c(), je.m(t, null)) : je && (je.d(1), je = null)
+            },
+            i: Ue,
+            o: Ue,
+            d(be) {
+                be && he(t), ae && ae.d(), _e && _e.d(), Ae && Ae.d(), Y && Y.d(), je && je.d(), Pi = !1, po(xi)
             }
         }
     }
-    let wa = 100;
 
-    function Tbe(e, t, n) {
+    function l_e(e, t, n) {
         let {
-            dataset: i = null
-        } = t, r = null, s = null, a, o;
-        jg.subscribe(h => {
-            n(3, o = h)
-        });
-        const l = fc();
+            features: i = null
+        } = t, {
+            annotations: r
+        } = t;
+        const s = er();
+        let a, o = null,
+            l = 1,
+            u = .5,
+            c = [];
 
-        function u(h) {
-            l("itemclick", {
-                id: h.detail.id
-            })
+        function f(C) {
+            h(parseFloat(C.target.value))
         }
-        async function c() {
-            o > 1 ? (jg.update(h => h - 1), n(1, s = null), n(1, s = await ly(i.id, o, wa))) : alert("There is no previous page.")
+
+        function h(C) {
+            for (let k of r)
+                for (let A of k.items) A.confidence && (A.visible = A.confidence >= C);
+            s("toggleCatVis")
         }
-        async function f() {
-            s.total > o * wa ? (jg.update(h => h + 1), n(1, s = null), n(1, s = await ly(i.id, o, wa))) : alert("Last page reached.")
+
+        function d() {
+            for (let C of r)
+                for (let k of C.items) k.opacity = l;
+            s("changeMaskOpacity", l)
         }
-        return Z0(async () => {
-            n(1, s = await ly(i.id, o, wa)), n(2, a = s.items[0].map(h => ({
-                name: h.name,
-                type: h.dtype
-            }))), n(0, r = await l9(i.id))
-        }), e.$$set = h => {
-            "dataset" in h && n(7, i = h.dataset)
-        }, [r, s, a, o, u, c, f, i]
+
+        function g(C) {
+            s("toggleAllBBoxVis", C.target.checked)
+        }
+
+        function p(C) {
+            let k = !0;
+            for (let F of r) {
+                if (F.category_name === C) {
+                    F.visible = !F.visible;
+                    let $ = document.getElementById(`cat-${F.category_id}`);
+                    F.visible ? $.classList.remove("grayscale") : $.classList.add("grayscale");
+                    for (let T of F.items) T.visible = F.visible
+                }
+                k = k && F.visible
+            }
+            let A = document.getElementById("toggle-items");
+            A.checked = k, s("toggleCatVis"), x()
+        }
+
+        function m(C) {
+            for (let k of r) {
+                k.visible = C.target.checked;
+                for (let A of k.items) {
+                    let F = document.getElementById(`cat-${k.category_id}`);
+                    k.visible ? F.classList.remove("grayscale") : F.classList.add("grayscale"), A.visible !== k.visible && (A.visible = k.visible)
+                }
+            }
+            s("toggleCatVis"), x()
+        }
+
+        function y(C) {
+            if (c.includes(C)) {
+                const k = c.indexOf(C);
+                k > -1 && c.splice(k, 1)
+            } else c.push(C);
+            b()
+        }
+
+        function v() {
+            c.length == 0 ? Object.keys(i.views).forEach(C => c.push(C)) : c = [], b()
+        }
+
+        function b() {
+            console.log("TODO: update visibility"), x()
+        }
+
+        function x() {
+            Object.keys(i.views).length > 1 && (document.getElementById("toggle-views").checked = c.length == 0, Object.keys(i.views).forEach(C => {
+                document.getElementById(`view-${C}`).checked = !c.includes(C)
+            }))
+        }
+        ra(() => {
+            console.log("AnnInspector - onMount (anns):", r), console.log("AnnInspector - onMount (feats):", i), h(u)
+        }), M7(() => {
+            i.id != a && (n(1, o = s7(r.map(C => C.category_id))), Object.keys(i.views).length)
+        });
+
+        function _() {
+            l = VC(this.value), n(2, l)
+        }
+
+        function S() {
+            u = VC(this.value), n(3, u)
+        }
+        const w = C => p(C.name),
+            E = C => y(C);
+        return e.$$set = C => {
+            "features" in C && n(0, i = C.features), "annotations" in C && n(11, r = C.annotations)
+        }, [i, o, l, u, f, d, g, p, m, y, v, r, _, S, w, E]
     }
-    class Mbe extends wn {
+    class u_e extends It {
         constructor(t) {
-            super(), _n(this, t, Tbe, $be, tn, {
-                dataset: 7
+            super(), Lt(this, t, l_e, o_e, Tt, {
+                features: 0,
+                annotations: 11
             })
         }
     }
 
-    function bM(e) {
-        let t, n;
-        return t = new hY({
+    function OO(e) {
+        let t, n, i, r, s;
+        t = new r_e({
             props: {
-                features: e[0]
+                itemId: e[3].id,
+                views: e[3].views,
+                selectedTool: e[6],
+                prediction: null,
+                masksGT: e[0],
+                bboxes: e[1],
+                categoryColor: e[5]
             }
-        }), {
+        });
+
+        function a(l) {
+            e[11](l)
+        }
+        let o = {
+            features: e[4]
+        };
+        return e[2] !== void 0 && (o.annotations = e[2]), i = new u_e({
+            props: o
+        }), Hi.push(() => xl(i, "annotations", a)), i.$on("toggleCatVis", e[7]), i.$on("toggleAllBBoxVis", e[8]), i.$on("changeMaskOpacity", e[9]), {
             c() {
-                ei(t.$$.fragment)
+                St(t.$$.fragment), n = we(), St(i.$$.fragment)
             },
-            m(i, r) {
-                Nn(t, i, r), n = !0
+            m(l, u) {
+                xt(t, l, u), de(l, n, u), xt(i, l, u), s = !0
             },
-            p(i, r) {
-                const s = {};
-                r & 1 && (s.features = i[0]), t.$set(s)
+            p(l, u) {
+                const c = {};
+                u & 8 && (c.itemId = l[3].id), u & 8 && (c.views = l[3].views), u & 1 && (c.masksGT = l[0]), u & 2 && (c.bboxes = l[1]), u & 32 && (c.categoryColor = l[5]), t.$set(c);
+                const f = {};
+                u & 16 && (f.features = l[4]), !r && u & 4 && (r = !0, f.annotations = l[2], bl(() => r = !1)), i.$set(f)
             },
-            i(i) {
-                n || (Te(t.$$.fragment, i), n = !0)
+            i(l) {
+                s || (fe(t.$$.fragment, l), fe(i.$$.fragment, l), s = !0)
             },
-            o(i) {
-                Ie(t.$$.fragment, i), n = !1
+            o(l) {
+                ve(t.$$.fragment, l), ve(i.$$.fragment, l), s = !1
             },
-            d(i) {
-                Pn(t, i)
+            d(l) {
+                _t(t, l), l && he(n), _t(i, l)
             }
         }
     }
 
-    function Obe(e) {
-        let t, n, i, r, s, a, o, l, u = e[0] && bM(e);
+    function c_e(e) {
+        let t, n, i, r, s, a, o = e[3] && OO(e);
         return {
             c() {
-                t = J("div"), u && u.c(), n = Ee(), i = J("button"), i.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 28 28" class="fill-rose-600 hover:fill-rose-400"><path class="transition-colors" d="M12 10.59l4.95-4.95c0.39-0.39 1.02-0.39 1.41 0l1.41 1.41c0.39 0.39 0.39 1.02 0 1.41l-4.95 4.95l4.95 4.95c0.39 0.39 0.39 1.02 0 1.41l-1.41 1.41c-0.39 0.39-1.02 0.39-1.41 0l-4.95-4.95l-4.95 4.95c-0.39 0.39-1.02 0.39-1.41 0l-1.41-1.41c-0.39-0.39-0.39-1.02 0-1.41l4.95-4.95l-4.95-4.95c-0.39-0.39-0.39-1.02 0-1.41l1.41-1.41c0.39-0.39 1.02-0.39 1.41 0l4.95 4.95z"></path></svg>', r = Ee(), s = J("div"), s.textContent = "Pixano Explorer", j(i, "class", "absolute top-0 right-0 p-2 z-10"), j(t, "class", "absolute top-0 bg-white w-screen h-screen dark:bg-zinc-900"), j(s, "class", "absolute bottom-0 right-0 px-2 py-1 bg-zinc-50 text-zinc-500 text-sm border-t border-l rounded-tl-lg dark:bg-zinc-900 dark:text-zinc-300 dark:border-zinc-500")
+                t = V("div"), o && o.c(), n = we(), i = V("div"), i.textContent = "Pixano Explorer", z(t, "class", "flex h-full w-full"), z(i, "class", "absolute bottom-0 right-0 px-2 py-1 bg-zinc-50 text-zinc-500 text-sm border-t border-l rounded-tl-lg dark:bg-zinc-900 dark:text-zinc-300 dark:border-zinc-500")
             },
-            m(c, f) {
-                we(c, t, f), u && u.m(t, null), G(t, n), G(t, i), we(c, r, f), we(c, s, f), a = !0, o || (l = [wt(window, "keydown", e[2]), wt(i, "click", e[1])], o = !0)
+            m(l, u) {
+                de(l, t, u), o && o.m(t, null), de(l, n, u), de(l, i, u), r = !0, s || (a = jt(window, "keydown", e[10]), s = !0)
             },
-            p(c, [f]) {
-                c[0] ? u ? (u.p(c, f), f & 1 && Te(u, 1)) : (u = bM(c), u.c(), Te(u, 1), u.m(t, n)) : u && (ur(), Ie(u, 1, 1, () => {
-                    u = null
-                }), cr())
+            p(l, [u]) {
+                l[3] ? o ? (o.p(l, u), u & 8 && fe(o, 1)) : (o = OO(l), o.c(), fe(o, 1), o.m(t, null)) : o && (on(), ve(o, 1, 1, () => {
+                    o = null
+                }), ln())
             },
-            i(c) {
-                a || (Te(u), a = !0)
+            i(l) {
+                r || (fe(o), r = !0)
             },
-            o(c) {
-                Ie(u), a = !1
+            o(l) {
+                ve(o), r = !1
             },
-            d(c) {
-                c && _e(t), u && u.d(), c && _e(r), c && _e(s), o = !1, js(l)
+            d(l) {
+                l && he(t), o && o.d(), l && he(n), l && he(i), s = !1, a()
             }
         }
     }
 
-    function Fbe(e, t, n) {
+    function f_e(e, t, n) {
         let {
-            datasetId: i
+            itemData: i
+        } = t, {
+            masksGT: r
+        } = t, {
+            bboxes: s
         } = t, {
-            rowIndex: r
-        } = t, s = null;
-        const a = fc();
+            annotations: a
+        } = t, {
+            features: o = null
+        } = t, l = Jxe(), u, c = !0;
+        const f = er();
 
-        function o() {
-            a("closeclick")
+        function h() {
+            f("closeclick")
+        }
+
+        function d(b) {
+            for (let x of a)
+                for (let _ of x.items)
+                    if (_.id === b) return _
+        }
+
+        function g(b) {
+            if (c) {
+                for (let x of s) x.visible = d(x.id).visible;
+                n(1, s)
+            }
+            for (let x of r) x.visible = d(x.id).visible;
+            n(0, r)
+        }
+
+        function p(b) {
+            c = b.detail;
+            for (let x of s) x.visible = c && d(x.id).visible;
+            n(1, s)
+        }
+
+        function m(b) {
+            for (let x of r) x.opacity = d(x.id).opacity;
+            n(0, r)
+        }
+        async function y(b) {
+            b.keyCode == 27 && h()
         }
-        async function l(u) {
-            u.keyCode == 27 && o()
+        ra(async () => {
+            console.log("DatasetItemDetails - onMount", i, r, a)
+        }), IO(() => {
+            a && (n(5, u = s7(a.map(b => b.category_id))), n(2, a))
+        });
+
+        function v(b) {
+            a = b, n(2, a)
         }
-        return Z0(async () => {
-            n(0, s = await u9(i, r))
-        }), e.$$set = u => {
-            "datasetId" in u && n(3, i = u.datasetId), "rowIndex" in u && n(4, r = u.rowIndex)
-        }, [s, o, l, i, r]
+        return e.$$set = b => {
+            "itemData" in b && n(3, i = b.itemData), "masksGT" in b && n(0, r = b.masksGT), "bboxes" in b && n(1, s = b.bboxes), "annotations" in b && n(2, a = b.annotations), "features" in b && n(4, o = b.features)
+        }, [r, s, a, i, o, u, l, g, p, m, y, v]
     }
-    class Rbe extends wn {
+    class h_e extends It {
         constructor(t) {
-            super(), _n(this, t, Fbe, Obe, tn, {
-                datasetId: 3,
-                rowIndex: 4
+            super(), Lt(this, t, f_e, c_e, Tt, {
+                itemData: 3,
+                masksGT: 0,
+                bboxes: 1,
+                annotations: 2,
+                features: 4
             })
         }
     }
+    const d_e = "/assets/pixano-6dabc25a.png",
+        a7 = "/assets/next-66a71219.svg",
+        g_e = "/assets/close-adf8672f.svg";
+
+    function FO(e) {
+        let t, n, i, r, s, a = e[0].name + "",
+            o, l, u, c, f, h = e[1] && RO(e);
+        return {
+            c() {
+                t = V("img"), i = we(), r = V("button"), s = V("span"), o = Xe(a), l = we(), h && h.c(), u = Zi(), Ka(t.src, n = a7) || z(t, "src", n), z(t, "alt", "icon"), z(t, "class", "h-6 w-6 opacity-75"), z(s, "class", "transition-colors"), z(r, "class", "hover:text-rose-800 dark:hover:text-rose-300")
+            },
+            m(d, g) {
+                de(d, t, g), de(d, i, g), de(d, r, g), B(r, s), B(s, o), de(d, l, g), h && h.m(d, g), de(d, u, g), c || (f = jt(r, "click", e[3]), c = !0)
+            },
+            p(d, g) {
+                g & 1 && a !== (a = d[0].name + "") && At(o, a), d[1] ? h ? h.p(d, g) : (h = RO(d), h.c(), h.m(u.parentNode, u)) : h && (h.d(1), h = null)
+            },
+            d(d) {
+                d && he(t), d && he(i), d && he(r), d && he(l), h && h.d(d), d && he(u), c = !1, f()
+            }
+        }
+    }
 
-    function xM(e) {
-        let t, n = e[1].name + "",
-            i;
+    function RO(e) {
+        let t, n, i, r, s = e[1].id + "",
+            a;
         return {
             c() {
-                t = J("span"), i = Je(n), j(t, "class", "ml-8 px-2 py-1 flex items-center justify-center bg-zinc-100 text-zinc-600 border rounded-md border-zinc-300 dark:bg-zinc-700 dark:text-zinc-300 dark:border-zinc-600")
+                t = V("img"), i = we(), r = V("span"), a = Xe(s), Ka(t.src, n = a7) || z(t, "src", n), z(t, "alt", "icon"), z(t, "class", "h-6 w-6 opacity-75")
             },
-            m(r, s) {
-                we(r, t, s), G(t, i)
+            m(o, l) {
+                de(o, t, l), de(o, i, l), de(o, r, l), B(r, a)
             },
-            p(r, s) {
-                s & 2 && n !== (n = r[1].name + "") && Ot(i, n)
+            p(o, l) {
+                l & 2 && s !== (s = o[1].id + "") && At(a, s)
             },
-            d(r) {
-                r && _e(t)
+            d(o) {
+                o && he(t), o && he(i), o && he(r)
             }
         }
     }
 
-    function _M(e) {
-        let t, n, i;
+    function DO(e) {
+        let t, n, i, r, s;
         return {
             c() {
-                t = J("button"), t.textContent = "Back to Library", j(t, "class", "p-2 transition-colors hover:text-rose-800 dark:hover:text-rose-300")
+                t = V("button"), n = V("img"), Ka(n.src, i = g_e) || z(n, "src", i), z(n, "alt", "icon"), z(n, "class", "h-8 w-8 cursor-pointer opacity-75"), z(t, "class", "w-30 pr-4 flex justify-end")
             },
-            m(r, s) {
-                we(r, t, s), n || (i = wt(t, "click", e[6]), n = !0)
+            m(a, o) {
+                de(a, t, o), B(t, n), r || (s = jt(t, "click", function() {
+                    r_(e[1] ? e[3] : e[2]) && (e[1] ? e[3] : e[2]).apply(this, arguments)
+                }), r = !0)
             },
-            p: Ve,
-            d(r) {
-                r && _e(t), n = !1, i()
+            p(a, o) {
+                e = a
+            },
+            d(a) {
+                a && he(t), r = !1, s()
             }
         }
     }
 
-    function Dbe(e) {
-        let t, n;
-        return t = new r9({
-            props: {
-                datasets: e[0]
+    function p_e(e) {
+        let t, n, i, r, s, a, o, l, u, c, f, h, d = e[0] && FO(e),
+            g = e[0] && DO(e);
+        return {
+            c() {
+                t = V("header"), n = V("div"), i = V("div"), r = V("button"), s = V("img"), o = we(), l = V("span"), l.textContent = "Pixano Explorer", u = we(), d && d.c(), c = we(), g && g.c(), Ka(s.src, a = d_e) || z(s, "src", a), z(s, "alt", "Logo Pixano"), z(s, "class", "w-10"), z(l, "class", "transition-colors"), z(r, "class", "cursor-pointer flex items-center space-x-2 hover:text-rose-800 dark:hover:text-rose-300"), z(i, "class", "flex items-center grow space-x-2 font-bold text-3xl"), z(n, "class", "h-20 py-4 px-4 flex justify-start items-center shrink-0 bg-white border-b-2 dark:bg-zinc-800 dark:border-zinc-700"), z(t, "class", "w-full fixed")
+            },
+            m(p, m) {
+                de(p, t, m), B(t, n), B(n, i), B(i, r), B(r, s), B(r, o), B(r, l), B(i, u), d && d.m(i, null), B(n, c), g && g.m(n, null), f || (h = jt(r, "click", e[2]), f = !0)
+            },
+            p(p, [m]) {
+                p[0] ? d ? d.p(p, m) : (d = FO(p), d.c(), d.m(i, null)) : d && (d.d(1), d = null), p[0] ? g ? g.p(p, m) : (g = DO(p), g.c(), g.m(n, null)) : g && (g.d(1), g = null)
+            },
+            i: Ue,
+            o: Ue,
+            d(p) {
+                p && he(t), d && d.d(), g && g.d(), f = !1, h()
             }
-        }), t.$on("datasetclick", e[4]), {
+        }
+    }
+
+    function m_e(e, t, n) {
+        let {
+            selectedDataset: i = null
+        } = t, {
+            selectedItem: r
+        } = t;
+        const s = er();
+
+        function a() {
+            n(0, i = null), n(1, r = null), qp.update(l => 1)
+        }
+
+        function o() {
+            s("closeclick")
+        }
+        return e.$$set = l => {
+            "selectedDataset" in l && n(0, i = l.selectedDataset), "selectedItem" in l && n(1, r = l.selectedItem)
+        }, [i, r, a, o]
+    }
+    class y_e extends It {
+        constructor(t) {
+            super(), Lt(this, t, m_e, p_e, Tt, {
+                selectedDataset: 0,
+                selectedItem: 1
+            })
+        }
+    }
+
+    function v_e(e) {
+        let t, n;
+        return t = new I7({}), {
             c() {
-                ei(t.$$.fragment)
+                St(t.$$.fragment)
             },
             m(i, r) {
-                Nn(t, i, r), n = !0
-            },
-            p(i, r) {
-                const s = {};
-                r & 1 && (s.datasets = i[0]), t.$set(s)
+                xt(t, i, r), n = !0
             },
+            p: Ue,
             i(i) {
-                n || (Te(t.$$.fragment, i), n = !0)
+                n || (fe(t.$$.fragment, i), n = !0)
             },
             o(i) {
-                Ie(t.$$.fragment, i), n = !1
+                ve(t.$$.fragment, i), n = !1
             },
             d(i) {
-                Pn(t, i)
+                _t(t, i)
             }
         }
     }
 
-    function Nbe(e) {
+    function b_e(e) {
         let t, n, i, r;
-        const s = [Ibe, Lbe],
+        const s = [__e, x_e],
             a = [];
 
         function o(l, u) {
-            return l[3] ? 1 : 0
+            return l[1] ? 0 : 1
         }
         return t = o(e), n = a[t] = s[t](e), {
             c() {
-                n.c(), i = bl()
+                n.c(), i = Zi()
             },
             m(l, u) {
-                a[t].m(l, u), we(l, i, u), r = !0
+                a[t].m(l, u), de(l, i, u), r = !0
             },
             p(l, u) {
                 let c = t;
-                t = o(l), t === c ? a[t].p(l, u) : (ur(), Ie(a[c], 1, 1, () => {
+                t = o(l), t === c ? a[t].p(l, u) : (on(), ve(a[c], 1, 1, () => {
                     a[c] = null
-                }), cr(), n = a[t], n ? n.p(l, u) : (n = a[t] = s[t](l), n.c()), Te(n, 1), n.m(i.parentNode, i))
+                }), ln(), n = a[t], n ? n.p(l, u) : (n = a[t] = s[t](l), n.c()), fe(n, 1), n.m(i.parentNode, i))
             },
             i(l) {
-                r || (Te(n), r = !0)
+                r || (fe(n), r = !0)
             },
             o(l) {
-                Ie(n), r = !1
+                ve(n), r = !1
             },
             d(l) {
-                a[t].d(l), l && _e(i)
+                a[t].d(l), l && he(i)
             }
         }
     }
 
-    function Pbe(e) {
+    function x_e(e) {
         let t, n;
-        return t = new a9({}), {
+        return t = new H7({
+            props: {
+                datasets: e[0],
+                btn_label: "Explore"
+            }
+        }), t.$on("datasetclick", e[7]), {
             c() {
-                ei(t.$$.fragment)
+                St(t.$$.fragment)
             },
             m(i, r) {
-                Nn(t, i, r), n = !0
+                xt(t, i, r), n = !0
+            },
+            p(i, r) {
+                const s = {};
+                r & 1 && (s.datasets = i[0]), t.$set(s)
             },
-            p: Ve,
             i(i) {
-                n || (Te(t.$$.fragment, i), n = !0)
+                n || (fe(t.$$.fragment, i), n = !0)
             },
             o(i) {
-                Ie(t.$$.fragment, i), n = !1
+                ve(t.$$.fragment, i), n = !1
             },
             d(i) {
-                Pn(t, i)
+                _t(t, i)
+            }
+        }
+    }
+
+    function __e(e) {
+        let t, n, i, r;
+        const s = [S_e, w_e],
+            a = [];
+
+        function o(l, u) {
+            return l[2] ? 0 : 1
+        }
+        return t = o(e), n = a[t] = s[t](e), {
+            c() {
+                n.c(), i = Zi()
+            },
+            m(l, u) {
+                a[t].m(l, u), de(l, i, u), r = !0
+            },
+            p(l, u) {
+                let c = t;
+                t = o(l), t === c ? a[t].p(l, u) : (on(), ve(a[c], 1, 1, () => {
+                    a[c] = null
+                }), ln(), n = a[t], n ? n.p(l, u) : (n = a[t] = s[t](l), n.c()), fe(n, 1), n.m(i.parentNode, i))
+            },
+            i(l) {
+                r || (fe(n), r = !0)
+            },
+            o(l) {
+                ve(n), r = !1
+            },
+            d(l) {
+                a[t].d(l), l && he(i)
             }
         }
     }
 
-    function Lbe(e) {
+    function w_e(e) {
         let t, n;
-        return t = new Rbe({
+        return t = new Kve({
             props: {
-                datasetId: e[1].id,
-                rowIndex: e[2]
+                dataset: e[1]
             }
-        }), t.$on("closeclick", e[7]), {
+        }), t.$on("itemclick", e[8]), {
             c() {
-                ei(t.$$.fragment)
+                St(t.$$.fragment)
             },
             m(i, r) {
-                Nn(t, i, r), n = !0
+                xt(t, i, r), n = !0
             },
             p(i, r) {
                 const s = {};
-                r & 2 && (s.datasetId = i[1].id), r & 4 && (s.rowIndex = i[2]), t.$set(s)
+                r & 2 && (s.dataset = i[1]), t.$set(s)
             },
             i(i) {
-                n || (Te(t.$$.fragment, i), n = !0)
+                n || (fe(t.$$.fragment, i), n = !0)
             },
             o(i) {
-                Ie(t.$$.fragment, i), n = !1
+                ve(t.$$.fragment, i), n = !1
             },
             d(i) {
-                Pn(t, i)
+                _t(t, i)
             }
         }
     }
 
-    function Ibe(e) {
+    function S_e(e) {
         let t, n;
-        return t = new Mbe({
+        return t = new h_e({
             props: {
-                dataset: e[1]
+                itemData: e[2],
+                features: e[6],
+                annotations: e[5],
+                masksGT: e[3],
+                bboxes: e[4]
             }
-        }), t.$on("itemclick", e[5]), {
+        }), t.$on("closeclick", e[9]), {
             c() {
-                ei(t.$$.fragment)
+                St(t.$$.fragment)
             },
             m(i, r) {
-                Nn(t, i, r), n = !0
+                xt(t, i, r), n = !0
             },
             p(i, r) {
                 const s = {};
-                r & 2 && (s.dataset = i[1]), t.$set(s)
+                r & 4 && (s.itemData = i[2]), r & 64 && (s.features = i[6]), r & 32 && (s.annotations = i[5]), r & 8 && (s.masksGT = i[3]), r & 16 && (s.bboxes = i[4]), t.$set(s)
             },
             i(i) {
-                n || (Te(t.$$.fragment, i), n = !0)
+                n || (fe(t.$$.fragment, i), n = !0)
             },
             o(i) {
-                Ie(t.$$.fragment, i), n = !1
+                ve(t.$$.fragment, i), n = !1
             },
             d(i) {
-                Pn(t, i)
+                _t(t, i)
             }
         }
     }
 
-    function zbe(e) {
-        let t, n, i, r, s, a, o, l, u, c, f, h, d, g, p, m, y, v, b, x = e[1] && xM(e),
-            _ = e[1] && _M(e);
-        const S = [Pbe, Nbe, Dbe],
-            w = [];
+    function E_e(e) {
+        let t, n, i, r, s, a, o, l;
+
+        function u(p) {
+            e[10](p)
+        }
+
+        function c(p) {
+            e[11](p)
+        }
+        let f = {};
+        e[1] !== void 0 && (f.selectedDataset = e[1]), e[2] !== void 0 && (f.selectedItem = e[2]), t = new y_e({
+            props: f
+        }), Hi.push(() => xl(t, "selectedDataset", u)), Hi.push(() => xl(t, "selectedItem", c)), t.$on("closeclick", e[9]);
+        const h = [b_e, v_e],
+            d = [];
 
-        function E(A, C) {
-            return A[0] ? A[1] ? 1 : 2 : 0
+        function g(p, m) {
+            return p[0] ? 0 : 1
         }
-        return g = E(e), p = w[g] = S[g](e), {
+        return a = g(e), o = d[a] = h[a](e), {
             c() {
-                t = J("header"), n = J("div"), i = J("div"), r = J("img"), a = Ee(), o = J("span"), o.textContent = "Pixano Explorer", l = Ee(), x && x.c(), u = Ee(), c = J("div"), _ && _.c(), f = Ee(), h = J("div"), d = Ee(), p.c(), m = bl(), fh(r.src, s = Q8) || j(r, "src", s), j(r, "alt", "Logo Pixano"), j(r, "class", "w-10"), j(o, "class", "text-3xl font-bold transition-colors"), j(i, "class", "flex space-x-4 cursor-pointer hover:text-rose-800 dark:hover:text-rose-300"), j(c, "class", "mr-4 flex-grow text-right"), j(n, "class", "h-20 py-4 px-4 flex justify-start items-center bg-white border-b-2 dark:bg-zinc-800 dark:border-zinc-700"), j(t, "class", "w-full fixed"), j(h, "class", "pt-20")
+                St(t.$$.fragment), r = we(), s = V("div"), o.c(), z(s, "class", "pt-20 h-screen w-screen")
             },
-            m(A, C) {
-                we(A, t, C), G(t, n), G(n, i), G(i, r), G(i, a), G(i, o), G(n, l), x && x.m(n, null), G(n, u), G(n, c), _ && _.m(c, null), we(A, f, C), we(A, h, C), we(A, d, C), w[g].m(A, C), we(A, m, C), y = !0, v || (b = wt(i, "click", e[6]), v = !0)
+            m(p, m) {
+                xt(t, p, m), de(p, r, m), de(p, s, m), d[a].m(s, null), l = !0
             },
-            p(A, [C]) {
-                A[1] ? x ? x.p(A, C) : (x = xM(A), x.c(), x.m(n, u)) : x && (x.d(1), x = null), A[1] ? _ ? _.p(A, C) : (_ = _M(A), _.c(), _.m(c, null)) : _ && (_.d(1), _ = null);
-                let k = g;
-                g = E(A), g === k ? w[g].p(A, C) : (ur(), Ie(w[k], 1, 1, () => {
-                    w[k] = null
-                }), cr(), p = w[g], p ? p.p(A, C) : (p = w[g] = S[g](A), p.c()), Te(p, 1), p.m(m.parentNode, m))
+            p(p, [m]) {
+                const y = {};
+                !n && m & 2 && (n = !0, y.selectedDataset = p[1], bl(() => n = !1)), !i && m & 4 && (i = !0, y.selectedItem = p[2], bl(() => i = !1)), t.$set(y);
+                let v = a;
+                a = g(p), a === v ? d[a].p(p, m) : (on(), ve(d[v], 1, 1, () => {
+                    d[v] = null
+                }), ln(), o = d[a], o ? o.p(p, m) : (o = d[a] = h[a](p), o.c()), fe(o, 1), o.m(s, null))
             },
-            i(A) {
-                y || (Te(p), y = !0)
+            i(p) {
+                l || (fe(t.$$.fragment, p), fe(o), l = !0)
             },
-            o(A) {
-                Ie(p), y = !1
+            o(p) {
+                ve(t.$$.fragment, p), ve(o), l = !1
             },
-            d(A) {
-                A && _e(t), x && x.d(), _ && _.d(), A && _e(f), A && _e(h), A && _e(d), w[g].d(A), A && _e(m), v = !1, b()
+            d(p) {
+                _t(t, p), p && he(r), p && he(s), d[a].d()
             }
         }
     }
 
-    function Bbe(e, t, n) {
+    function k_e(e, t, n) {
         let i = null,
             r = null,
             s = null,
-            a = !1;
-        async function o(f) {
-            n(1, r = f.detail.dataset)
+            a = [],
+            o = [],
+            l = [],
+            u = null;
+        async function c(p) {
+            n(1, r = p.detail.dataset)
+        }
+        async function f(p) {
+            console.log("=== LOADING SELECTED ITEM ==="), n(6, u = await Q7(r.id, p.detail.id));
+            let m = [];
+            for (let v of Object.keys(u.views)) {
+                let b = {
+                    viewId: v,
+                    imageURL: u.views[v].image
+                };
+                m.push(b)
+            }
+            n(2, s = {
+                dbName: r.name,
+                id: p.detail.id,
+                views: m
+            }), console.log("item loaded:", s);
+            let y = {};
+            for (let v of Object.keys(u.views))
+                for (let b = 0; b < u.views[v].objects.id.length; ++b) {
+                    const x = u.views[v].objects.segmentation[b],
+                        _ = u.views[v].objects.boundingBox[b],
+                        S = u.views[v].objects.category[b].name;
+                    if (!y[S]) {
+                        let w = {
+                            viewId: v,
+                            category_name: S,
+                            category_id: u.views[v].objects.category[b].id,
+                            items: [],
+                            visible: !0
+                        };
+                        y[S] = w
+                    }
+                    if (!(_ || x)) {
+                        console.log("WARNING!, no mask nor bounding box!!");
+                        continue
+                    }
+                    if (x) {
+                        const w = x.counts,
+                            E = x.size,
+                            C = X7(w, E[0]),
+                            k = V7(C);
+                        a.push({
+                            viewId: v,
+                            id: u.views[v].objects.id[b],
+                            mask: k,
+                            rle: x,
+                            catId: u.views[v].objects.category[b].id,
+                            visible: !0,
+                            opacity: 1
+                        });
+                        let A = {
+                            id: u.views[v].objects.id[b],
+                            type: "mask",
+                            label: u.views[v].objects.category[b].name + "-" + y[S].items.length,
+                            visible: !0,
+                            opacity: 1
+                        };
+                        _ && _.is_predict && (A.confidence = _.confidence), y[S].items.push(A)
+                    }
+                    if (_) {
+                        o.push({
+                            viewId: v,
+                            id: u.views[v].objects.id[b],
+                            bbox: [_.x, _.y, _.width, _.height],
+                            label: u.views[v].objects.category[b].name + (_.is_predict ? " " + parseFloat(_.confidence).toFixed(2) : ""),
+                            catId: u.views[v].objects.category[b].id,
+                            visible: !0
+                        });
+                        let w = {
+                            id: u.views[v].objects.id[b],
+                            type: "bbox",
+                            label: u.views[v].objects.category[b].name + "-" + y[S].items.length,
+                            visible: !0,
+                            opacity: 1
+                        };
+                        _.is_predict && (w.confidence = _.confidence), y[S].items.push(w)
+                    }
+                }
+            for (let v in y) l.push(y[v]);
+            console.log("selectItem Done", a, o, l)
         }
 
-        function l(f) {
-            n(3, a = !0), n(2, s = f.detail.id)
+        function h() {
+            n(2, s = null), n(3, a = []), n(4, o = []), n(5, l = [])
         }
+        ra(async () => {
+            n(0, i = await K7())
+        });
 
-        function u() {
-            n(1, r = null), n(2, s = null), jg.update(f => 1)
+        function d(p) {
+            r = p, n(1, r)
         }
 
-        function c() {
-            n(3, a = !1)
+        function g(p) {
+            s = p, n(2, s)
         }
-        return Z0(async () => {
-            n(0, i = await o9())
-        }), [i, r, s, a, o, l, u, c]
+        return [i, r, s, a, o, l, u, c, f, h, d, g]
     }
-    class jbe extends wn {
+    class C_e extends It {
         constructor(t) {
-            super(), _n(this, t, Bbe, zbe, tn, {})
+            super(), Lt(this, t, k_e, E_e, Tt, {})
         }
     }
     /**
     @copyright CEA-LIST/DIASI/SIALV/LVA (2023)
     @author CEA-LIST/DIASI/SIALV/LVA <pixano@cea.fr>
     @license CECILL-C
 
@@ -55200,12 +57196,12 @@
     This software is governed by the CeCILL-C license under French law and
     abiding by the rules of distribution of free software. You can use, 
     modify and/ or redistribute the software under the terms of the CeCILL-C
     license as circulated by CEA, CNRS and INRIA at the following URL
 
     http://www.cecill.info
     */
-    new jbe({
+    new C_e({
         target: document.getElementById("app")
     })
 });
-export default Ube();
+export default A_e();
```

### Comparing `pixano-0.2.1/pixano/apps/explorer/dist/assets/index-f2b8d192.css` & `pixano-0.3.0/pixano/apps/explorer/dist/assets/index-c03d4dec.css`

 * *Files 4% similar despite different names*

```diff
@@ -1 +1 @@
-*,:before,:after{box-sizing:border-box;border-width:0;border-style:solid;border-color:#e5e7eb}:before,:after{--tw-content: ""}html{line-height:1.5;-webkit-text-size-adjust:100%;-moz-tab-size:4;-o-tab-size:4;tab-size:4;font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,"Apple Color Emoji","Segoe UI Emoji",Segoe UI Symbol,"Noto Color Emoji";font-feature-settings:normal;font-variation-settings:normal}body{margin:0;line-height:inherit}hr{height:0;color:inherit;border-top-width:1px}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,samp,pre{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}button,input,optgroup,select,textarea{font-family:inherit;font-size:100%;font-weight:inherit;line-height:inherit;color:inherit;margin:0;padding:0}button,select{text-transform:none}button,[type=button],[type=reset],[type=submit]{-webkit-appearance:button;background-color:transparent;background-image:none}:-moz-focusring{outline:auto}:-moz-ui-invalid{box-shadow:none}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}blockquote,dl,dd,h1,h2,h3,h4,h5,h6,hr,figure,p,pre{margin:0}fieldset{margin:0;padding:0}legend{padding:0}ol,ul,menu{list-style:none;margin:0;padding:0}textarea{resize:vertical}input::-moz-placeholder,textarea::-moz-placeholder{opacity:1;color:#9ca3af}input::placeholder,textarea::placeholder{opacity:1;color:#9ca3af}button,[role=button]{cursor:pointer}:disabled{cursor:default}img,svg,video,canvas,audio,iframe,embed,object{display:block;vertical-align:middle}img,video{max-width:100%;height:auto}[hidden]{display:none}*,:before,:after{--tw-border-spacing-x: 0;--tw-border-spacing-y: 0;--tw-translate-x: 0;--tw-translate-y: 0;--tw-rotate: 0;--tw-skew-x: 0;--tw-skew-y: 0;--tw-scale-x: 1;--tw-scale-y: 1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness: proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width: 0px;--tw-ring-offset-color: #fff;--tw-ring-color: rgb(59 130 246 / .5);--tw-ring-offset-shadow: 0 0 #0000;--tw-ring-shadow: 0 0 #0000;--tw-shadow: 0 0 #0000;--tw-shadow-colored: 0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: }::backdrop{--tw-border-spacing-x: 0;--tw-border-spacing-y: 0;--tw-translate-x: 0;--tw-translate-y: 0;--tw-rotate: 0;--tw-skew-x: 0;--tw-skew-y: 0;--tw-scale-x: 1;--tw-scale-y: 1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness: proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width: 0px;--tw-ring-offset-color: #fff;--tw-ring-color: rgb(59 130 246 / .5);--tw-ring-offset-shadow: 0 0 #0000;--tw-ring-shadow: 0 0 #0000;--tw-shadow: 0 0 #0000;--tw-shadow-colored: 0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: }.container{width:100%}@media (min-width: 640px){.container{max-width:640px}}@media (min-width: 768px){.container{max-width:768px}}@media (min-width: 1024px){.container{max-width:1024px}}@media (min-width: 1280px){.container{max-width:1280px}}@media (min-width: 1536px){.container{max-width:1536px}}.visible{visibility:visible}.fixed{position:fixed}.absolute{position:absolute}.relative{position:relative}.sticky{position:sticky}.-right-3{right:-.75rem}.-top-2{top:-.5rem}.bottom-0{bottom:0px}.left-0{left:0px}.right-0{right:0px}.right-6{right:1.5rem}.top-0{top:0px}.top-1\/2{top:50%}.z-10{z-index:10}.col-span-1{grid-column:span 1 / span 1}.col-span-2{grid-column:span 2 / span 2}.m-4{margin:1rem}.mx-auto{margin-left:auto;margin-right:auto}.my-2{margin-top:.5rem;margin-bottom:.5rem}.mb-1{margin-bottom:.25rem}.mb-2{margin-bottom:.5rem}.ml-1{margin-left:.25rem}.ml-2{margin-left:.5rem}.ml-4{margin-left:1rem}.ml-8{margin-left:2rem}.mr-2{margin-right:.5rem}.mr-4{margin-right:1rem}.mt-2{margin-top:.5rem}.mt-3{margin-top:.75rem}.mt-4{margin-top:1rem}.mt-8{margin-top:2rem}.mt-80{margin-top:20rem}.block{display:block}.flex{display:flex}.table{display:table}.grid{display:grid}.hidden{display:none}.h-1\/5{height:20%}.h-10{height:2.5rem}.h-2{height:.5rem}.h-20{height:5rem}.h-3\/5{height:60%}.h-56{height:14rem}.h-80{height:20rem}.h-\[85vh\]{height:85vh}.h-fit{height:-moz-fit-content;height:fit-content}.h-full{height:100%}.h-screen{height:100vh}.max-h-48{max-height:12rem}.min-h-screen{min-height:100vh}.w-1\/2{width:50%}.w-10{width:2.5rem}.w-56{width:14rem}.w-64{width:16rem}.w-72{width:18rem}.w-full{width:100%}.w-screen{width:100vw}.min-w-\[14rem\]{min-width:14rem}.max-w-sm{max-width:24rem}.flex-1{flex:1 1 0%}.flex-grow{flex-grow:1}.table-auto{table-layout:auto}.-translate-y-1\/2{--tw-translate-y: -50%;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}@keyframes pulse{50%{opacity:.5}}.animate-pulse{animation:pulse 2s cubic-bezier(.4,0,.6,1) infinite}.cursor-pointer{cursor:pointer}.grid-cols-3{grid-template-columns:repeat(3,minmax(0,1fr))}.grid-cols-6{grid-template-columns:repeat(6,minmax(0,1fr))}.flex-col{flex-direction:column}.flex-wrap{flex-wrap:wrap}.items-end{align-items:flex-end}.items-center{align-items:center}.justify-start{justify-content:flex-start}.justify-end{justify-content:flex-end}.justify-center{justify-content:center}.gap-4{gap:1rem}.space-x-2>:not([hidden])~:not([hidden]){--tw-space-x-reverse: 0;margin-right:calc(.5rem * var(--tw-space-x-reverse));margin-left:calc(.5rem * calc(1 - var(--tw-space-x-reverse)))}.space-x-4>:not([hidden])~:not([hidden]){--tw-space-x-reverse: 0;margin-right:calc(1rem * var(--tw-space-x-reverse));margin-left:calc(1rem * calc(1 - var(--tw-space-x-reverse)))}.space-y-3>:not([hidden])~:not([hidden]){--tw-space-y-reverse: 0;margin-top:calc(.75rem * calc(1 - var(--tw-space-y-reverse)));margin-bottom:calc(.75rem * var(--tw-space-y-reverse))}.space-y-6>:not([hidden])~:not([hidden]){--tw-space-y-reverse: 0;margin-top:calc(1.5rem * calc(1 - var(--tw-space-y-reverse)));margin-bottom:calc(1.5rem * var(--tw-space-y-reverse))}.self-center{align-self:center}.overflow-x-auto{overflow-x:auto}.overflow-y-auto{overflow-y:auto}.overflow-y-scroll{overflow-y:scroll}.rounded{border-radius:.25rem}.rounded-full{border-radius:9999px}.rounded-lg{border-radius:.5rem}.rounded-md{border-radius:.375rem}.rounded-tl-lg{border-top-left-radius:.5rem}.border{border-width:1px}.border-2{border-width:2px}.border-b{border-bottom-width:1px}.border-b-2{border-bottom-width:2px}.border-l{border-left-width:1px}.border-t{border-top-width:1px}.border-rose-500{--tw-border-opacity: 1;border-color:rgb(244 63 94 / var(--tw-border-opacity))}.border-transparent{border-color:transparent}.border-zinc-100{--tw-border-opacity: 1;border-color:rgb(244 244 245 / var(--tw-border-opacity))}.border-zinc-200{--tw-border-opacity: 1;border-color:rgb(228 228 231 / var(--tw-border-opacity))}.border-zinc-300{--tw-border-opacity: 1;border-color:rgb(212 212 216 / var(--tw-border-opacity))}.bg-rose-500{--tw-bg-opacity: 1;background-color:rgb(244 63 94 / var(--tw-bg-opacity))}.bg-slate-200{--tw-bg-opacity: 1;background-color:rgb(226 232 240 / var(--tw-bg-opacity))}.bg-white{--tw-bg-opacity: 1;background-color:rgb(255 255 255 / var(--tw-bg-opacity))}.bg-zinc-100{--tw-bg-opacity: 1;background-color:rgb(244 244 245 / var(--tw-bg-opacity))}.bg-zinc-50{--tw-bg-opacity: 1;background-color:rgb(250 250 250 / var(--tw-bg-opacity))}.fill-rose-600{fill:#e11d48}.object-cover{-o-object-fit:cover;object-fit:cover}.object-center{-o-object-position:center;object-position:center}.p-2{padding:.5rem}.p-4{padding:1rem}.px-1{padding-left:.25rem;padding-right:.25rem}.px-2{padding-left:.5rem;padding-right:.5rem}.px-3{padding-left:.75rem;padding-right:.75rem}.px-4{padding-left:1rem;padding-right:1rem}.px-8{padding-left:2rem;padding-right:2rem}.py-1{padding-top:.25rem;padding-bottom:.25rem}.py-2{padding-top:.5rem;padding-bottom:.5rem}.py-4{padding-top:1rem;padding-bottom:1rem}.pl-2{padding-left:.5rem}.pr-4{padding-right:1rem}.pt-2{padding-top:.5rem}.pt-20{padding-top:5rem}.text-left{text-align:left}.text-center{text-align:center}.text-right{text-align:right}.text-3xl{font-size:1.875rem;line-height:2.25rem}.text-lg{font-size:1.125rem;line-height:1.75rem}.text-sm{font-size:.875rem;line-height:1.25rem}.text-xl{font-size:1.25rem;line-height:1.75rem}.text-xs{font-size:.75rem;line-height:1rem}.font-bold{font-weight:700}.font-medium{font-weight:500}.uppercase{text-transform:uppercase}.italic{font-style:italic}.text-white{--tw-text-opacity: 1;color:rgb(255 255 255 / var(--tw-text-opacity))}.text-zinc-50{--tw-text-opacity: 1;color:rgb(250 250 250 / var(--tw-text-opacity))}.text-zinc-500{--tw-text-opacity: 1;color:rgb(113 113 122 / var(--tw-text-opacity))}.text-zinc-600{--tw-text-opacity: 1;color:rgb(82 82 91 / var(--tw-text-opacity))}.text-zinc-700{--tw-text-opacity: 1;color:rgb(63 63 70 / var(--tw-text-opacity))}.text-zinc-900{--tw-text-opacity: 1;color:rgb(24 24 27 / var(--tw-text-opacity))}.shadow{--tw-shadow: 0 1px 3px 0 rgb(0 0 0 / .1), 0 1px 2px -1px rgb(0 0 0 / .1);--tw-shadow-colored: 0 1px 3px 0 var(--tw-shadow-color), 0 1px 2px -1px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.outline{outline-style:solid}.grayscale{--tw-grayscale: grayscale(100%);filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)}.filter{filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)}.transition-all{transition-property:all;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}.transition-colors{transition-property:color,background-color,border-color,text-decoration-color,fill,stroke;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}.checked\:accent-rose-500:checked{accent-color:#f43f5e}.hover\:scale-\[102\.5\%\]:hover{--tw-scale-x: 102.5%;--tw-scale-y: 102.5%;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.hover\:border-rose-500:hover{--tw-border-opacity: 1;border-color:rgb(244 63 94 / var(--tw-border-opacity))}.hover\:bg-zinc-100:hover{--tw-bg-opacity: 1;background-color:rgb(244 244 245 / var(--tw-bg-opacity))}.hover\:bg-zinc-50:hover{--tw-bg-opacity: 1;background-color:rgb(250 250 250 / var(--tw-bg-opacity))}.hover\:fill-rose-400:hover{fill:#fb7185}.hover\:text-rose-600:hover{--tw-text-opacity: 1;color:rgb(225 29 72 / var(--tw-text-opacity))}.hover\:text-rose-800:hover{--tw-text-opacity: 1;color:rgb(159 18 57 / var(--tw-text-opacity))}@media (prefers-color-scheme: dark){.dark\:border-rose-800{--tw-border-opacity: 1;border-color:rgb(159 18 57 / var(--tw-border-opacity))}.dark\:border-zinc-500{--tw-border-opacity: 1;border-color:rgb(113 113 122 / var(--tw-border-opacity))}.dark\:border-zinc-600{--tw-border-opacity: 1;border-color:rgb(82 82 91 / var(--tw-border-opacity))}.dark\:border-zinc-700{--tw-border-opacity: 1;border-color:rgb(63 63 70 / var(--tw-border-opacity))}.dark\:border-zinc-800{--tw-border-opacity: 1;border-color:rgb(39 39 42 / var(--tw-border-opacity))}.dark\:bg-rose-800{--tw-bg-opacity: 1;background-color:rgb(159 18 57 / var(--tw-bg-opacity))}.dark\:bg-zinc-700{--tw-bg-opacity: 1;background-color:rgb(63 63 70 / var(--tw-bg-opacity))}.dark\:bg-zinc-800{--tw-bg-opacity: 1;background-color:rgb(39 39 42 / var(--tw-bg-opacity))}.dark\:bg-zinc-900{--tw-bg-opacity: 1;background-color:rgb(24 24 27 / var(--tw-bg-opacity))}.dark\:text-zinc-300{--tw-text-opacity: 1;color:rgb(212 212 216 / var(--tw-text-opacity))}.dark\:text-zinc-400{--tw-text-opacity: 1;color:rgb(161 161 170 / var(--tw-text-opacity))}.dark\:text-zinc-50{--tw-text-opacity: 1;color:rgb(250 250 250 / var(--tw-text-opacity))}.dark\:hover\:bg-zinc-700:hover{--tw-bg-opacity: 1;background-color:rgb(63 63 70 / var(--tw-bg-opacity))}.dark\:hover\:bg-zinc-800:hover{--tw-bg-opacity: 1;background-color:rgb(39 39 42 / var(--tw-bg-opacity))}.dark\:hover\:text-rose-300:hover{--tw-text-opacity: 1;color:rgb(253 164 175 / var(--tw-text-opacity))}.dark\:hover\:text-rose-700:hover{--tw-text-opacity: 1;color:rgb(190 18 60 / var(--tw-text-opacity))}}
+@import"https://fonts.googleapis.com/css2?family=Poppins&display=swap";*,:before,:after{box-sizing:border-box;border-width:0;border-style:solid;border-color:#e5e7eb}:before,:after{--tw-content: ""}html{line-height:1.5;-webkit-text-size-adjust:100%;-moz-tab-size:4;-o-tab-size:4;tab-size:4;font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,"Apple Color Emoji","Segoe UI Emoji",Segoe UI Symbol,"Noto Color Emoji";font-feature-settings:normal;font-variation-settings:normal}body{margin:0;line-height:inherit}hr{height:0;color:inherit;border-top-width:1px}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,samp,pre{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}button,input,optgroup,select,textarea{font-family:inherit;font-size:100%;font-weight:inherit;line-height:inherit;color:inherit;margin:0;padding:0}button,select{text-transform:none}button,[type=button],[type=reset],[type=submit]{-webkit-appearance:button;background-color:transparent;background-image:none}:-moz-focusring{outline:auto}:-moz-ui-invalid{box-shadow:none}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}blockquote,dl,dd,h1,h2,h3,h4,h5,h6,hr,figure,p,pre{margin:0}fieldset{margin:0;padding:0}legend{padding:0}ol,ul,menu{list-style:none;margin:0;padding:0}textarea{resize:vertical}input::-moz-placeholder,textarea::-moz-placeholder{opacity:1;color:#9ca3af}input::placeholder,textarea::placeholder{opacity:1;color:#9ca3af}button,[role=button]{cursor:pointer}:disabled{cursor:default}img,svg,video,canvas,audio,iframe,embed,object{display:block;vertical-align:middle}img,video{max-width:100%;height:auto}[hidden]{display:none}*,:before,:after{--tw-border-spacing-x: 0;--tw-border-spacing-y: 0;--tw-translate-x: 0;--tw-translate-y: 0;--tw-rotate: 0;--tw-skew-x: 0;--tw-skew-y: 0;--tw-scale-x: 1;--tw-scale-y: 1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness: proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width: 0px;--tw-ring-offset-color: #fff;--tw-ring-color: rgb(59 130 246 / .5);--tw-ring-offset-shadow: 0 0 #0000;--tw-ring-shadow: 0 0 #0000;--tw-shadow: 0 0 #0000;--tw-shadow-colored: 0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: }::backdrop{--tw-border-spacing-x: 0;--tw-border-spacing-y: 0;--tw-translate-x: 0;--tw-translate-y: 0;--tw-rotate: 0;--tw-skew-x: 0;--tw-skew-y: 0;--tw-scale-x: 1;--tw-scale-y: 1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness: proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width: 0px;--tw-ring-offset-color: #fff;--tw-ring-color: rgb(59 130 246 / .5);--tw-ring-offset-shadow: 0 0 #0000;--tw-ring-shadow: 0 0 #0000;--tw-shadow: 0 0 #0000;--tw-shadow-colored: 0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: }.visible{visibility:visible}.fixed{position:fixed}.absolute{position:absolute}.relative{position:relative}.sticky{position:sticky}.-right-3{right:-.75rem}.-top-2{top:-.5rem}.bottom-0{bottom:0px}.right-0{right:0px}.right-6{right:1.5rem}.top-0{top:0px}.top-1\/2{top:50%}.col-span-1{grid-column:span 1 / span 1}.col-span-2{grid-column:span 2 / span 2}.m-4{margin:1rem}.mx-auto{margin-left:auto;margin-right:auto}.mb-1{margin-bottom:.25rem}.mb-2{margin-bottom:.5rem}.ml-1{margin-left:.25rem}.ml-4{margin-left:1rem}.mr-2{margin-right:.5rem}.mr-4{margin-right:1rem}.mt-2{margin-top:.5rem}.mt-3{margin-top:.75rem}.mt-4{margin-top:1rem}.mt-8{margin-top:2rem}.mt-80{margin-top:20rem}.block{display:block}.flex{display:flex}.table{display:table}.grid{display:grid}.hidden{display:none}.h-1\/5{height:20%}.h-10{height:2.5rem}.h-2{height:.5rem}.h-20{height:5rem}.h-3\/5{height:60%}.h-56{height:14rem}.h-6{height:1.5rem}.h-8{height:2rem}.h-80{height:20rem}.h-\[85vh\]{height:85vh}.h-fit{height:-moz-fit-content;height:fit-content}.h-full{height:100%}.h-screen{height:100vh}.max-h-48{max-height:12rem}.min-h-screen{min-height:100vh}.w-1\/2{width:50%}.w-10{width:2.5rem}.w-56{width:14rem}.w-6{width:1.5rem}.w-64{width:16rem}.w-72{width:18rem}.w-8{width:2rem}.w-full{width:100%}.w-screen{width:100vw}.min-w-\[14rem\]{min-width:14rem}.max-w-5xl{max-width:64rem}.max-w-7xl{max-width:80rem}.max-w-sm{max-width:24rem}.flex-1{flex:1 1 0%}.shrink-0{flex-shrink:0}.grow{flex-grow:1}.table-auto{table-layout:auto}.-translate-y-1\/2{--tw-translate-y: -50%;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}@keyframes pulse{50%{opacity:.5}}.animate-pulse{animation:pulse 2s cubic-bezier(.4,0,.6,1) infinite}.cursor-pointer{cursor:pointer}.grid-cols-1{grid-template-columns:repeat(1,minmax(0,1fr))}.grid-cols-3{grid-template-columns:repeat(3,minmax(0,1fr))}.flex-col{flex-direction:column}.flex-wrap{flex-wrap:wrap}.place-items-center{place-items:center}.items-end{align-items:flex-end}.items-center{align-items:center}.justify-start{justify-content:flex-start}.justify-end{justify-content:flex-end}.justify-center{justify-content:center}.gap-4{gap:1rem}.space-x-2>:not([hidden])~:not([hidden]){--tw-space-x-reverse: 0;margin-right:calc(.5rem * var(--tw-space-x-reverse));margin-left:calc(.5rem * calc(1 - var(--tw-space-x-reverse)))}.space-x-4>:not([hidden])~:not([hidden]){--tw-space-x-reverse: 0;margin-right:calc(1rem * var(--tw-space-x-reverse));margin-left:calc(1rem * calc(1 - var(--tw-space-x-reverse)))}.space-y-3>:not([hidden])~:not([hidden]){--tw-space-y-reverse: 0;margin-top:calc(.75rem * calc(1 - var(--tw-space-y-reverse)));margin-bottom:calc(.75rem * var(--tw-space-y-reverse))}.space-y-6>:not([hidden])~:not([hidden]){--tw-space-y-reverse: 0;margin-top:calc(1.5rem * calc(1 - var(--tw-space-y-reverse)));margin-bottom:calc(1.5rem * var(--tw-space-y-reverse))}.self-center{align-self:center}.overflow-x-auto{overflow-x:auto}.overflow-y-auto{overflow-y:auto}.overflow-y-scroll{overflow-y:scroll}.truncate{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.rounded{border-radius:.25rem}.rounded-full{border-radius:9999px}.rounded-lg{border-radius:.5rem}.rounded-md{border-radius:.375rem}.rounded-tl-lg{border-top-left-radius:.5rem}.border{border-width:1px}.border-2{border-width:2px}.border-b{border-bottom-width:1px}.border-b-2{border-bottom-width:2px}.border-l{border-left-width:1px}.border-t{border-top-width:1px}.border-rose-500{--tw-border-opacity: 1;border-color:rgb(244 63 94 / var(--tw-border-opacity))}.border-transparent{border-color:transparent}.border-zinc-100{--tw-border-opacity: 1;border-color:rgb(244 244 245 / var(--tw-border-opacity))}.border-zinc-200{--tw-border-opacity: 1;border-color:rgb(228 228 231 / var(--tw-border-opacity))}.border-zinc-300{--tw-border-opacity: 1;border-color:rgb(212 212 216 / var(--tw-border-opacity))}.bg-rose-500{--tw-bg-opacity: 1;background-color:rgb(244 63 94 / var(--tw-bg-opacity))}.bg-slate-200{--tw-bg-opacity: 1;background-color:rgb(226 232 240 / var(--tw-bg-opacity))}.bg-white{--tw-bg-opacity: 1;background-color:rgb(255 255 255 / var(--tw-bg-opacity))}.bg-zinc-100{--tw-bg-opacity: 1;background-color:rgb(244 244 245 / var(--tw-bg-opacity))}.bg-zinc-50{--tw-bg-opacity: 1;background-color:rgb(250 250 250 / var(--tw-bg-opacity))}.object-cover{-o-object-fit:cover;object-fit:cover}.object-center{-o-object-position:center;object-position:center}.p-2{padding:.5rem}.p-4{padding:1rem}.px-1{padding-left:.25rem;padding-right:.25rem}.px-2{padding-left:.5rem;padding-right:.5rem}.px-3{padding-left:.75rem;padding-right:.75rem}.px-4{padding-left:1rem;padding-right:1rem}.px-8{padding-left:2rem;padding-right:2rem}.py-0{padding-top:0;padding-bottom:0}.py-1{padding-top:.25rem;padding-bottom:.25rem}.py-2{padding-top:.5rem;padding-bottom:.5rem}.py-4{padding-top:1rem;padding-bottom:1rem}.py-8{padding-top:2rem;padding-bottom:2rem}.pl-2{padding-left:.5rem}.pr-4{padding-right:1rem}.pt-2{padding-top:.5rem}.pt-20{padding-top:5rem}.text-left{text-align:left}.text-center{text-align:center}.font-poppins{font-family:Poppins,sans-serif}.text-3xl{font-size:1.875rem;line-height:2.25rem}.text-lg{font-size:1.125rem;line-height:1.75rem}.text-sm{font-size:.875rem;line-height:1.25rem}.text-xl{font-size:1.25rem;line-height:1.75rem}.text-xs{font-size:.75rem;line-height:1rem}.font-bold{font-weight:700}.font-medium{font-weight:500}.uppercase{text-transform:uppercase}.italic{font-style:italic}.text-white{--tw-text-opacity: 1;color:rgb(255 255 255 / var(--tw-text-opacity))}.text-zinc-50{--tw-text-opacity: 1;color:rgb(250 250 250 / var(--tw-text-opacity))}.text-zinc-500{--tw-text-opacity: 1;color:rgb(113 113 122 / var(--tw-text-opacity))}.text-zinc-700{--tw-text-opacity: 1;color:rgb(63 63 70 / var(--tw-text-opacity))}.text-zinc-900{--tw-text-opacity: 1;color:rgb(24 24 27 / var(--tw-text-opacity))}.opacity-75{opacity:.75}.shadow{--tw-shadow: 0 1px 3px 0 rgb(0 0 0 / .1), 0 1px 2px -1px rgb(0 0 0 / .1);--tw-shadow-colored: 0 1px 3px 0 var(--tw-shadow-color), 0 1px 2px -1px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.shadow-xl{--tw-shadow: 0 20px 25px -5px rgb(0 0 0 / .1), 0 8px 10px -6px rgb(0 0 0 / .1);--tw-shadow-colored: 0 20px 25px -5px var(--tw-shadow-color), 0 8px 10px -6px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.grayscale{--tw-grayscale: grayscale(100%);filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)}.filter{filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)}.transition-all{transition-property:all;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}.transition-colors{transition-property:color,background-color,border-color,text-decoration-color,fill,stroke;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}.checked\:accent-rose-500:checked{accent-color:#f43f5e}.hover\:scale-110:hover{--tw-scale-x: 1.1;--tw-scale-y: 1.1;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.hover\:border-rose-500:hover{--tw-border-opacity: 1;border-color:rgb(244 63 94 / var(--tw-border-opacity))}.hover\:bg-zinc-100:hover{--tw-bg-opacity: 1;background-color:rgb(244 244 245 / var(--tw-bg-opacity))}.hover\:bg-zinc-50:hover{--tw-bg-opacity: 1;background-color:rgb(250 250 250 / var(--tw-bg-opacity))}.hover\:text-rose-600:hover{--tw-text-opacity: 1;color:rgb(225 29 72 / var(--tw-text-opacity))}.hover\:text-rose-800:hover{--tw-text-opacity: 1;color:rgb(159 18 57 / var(--tw-text-opacity))}.group:hover .group-hover\:block{display:block}@media (prefers-color-scheme: dark){.dark\:border-rose-800{--tw-border-opacity: 1;border-color:rgb(159 18 57 / var(--tw-border-opacity))}.dark\:border-zinc-500{--tw-border-opacity: 1;border-color:rgb(113 113 122 / var(--tw-border-opacity))}.dark\:border-zinc-700{--tw-border-opacity: 1;border-color:rgb(63 63 70 / var(--tw-border-opacity))}.dark\:border-zinc-800{--tw-border-opacity: 1;border-color:rgb(39 39 42 / var(--tw-border-opacity))}.dark\:bg-rose-800{--tw-bg-opacity: 1;background-color:rgb(159 18 57 / var(--tw-bg-opacity))}.dark\:bg-zinc-800{--tw-bg-opacity: 1;background-color:rgb(39 39 42 / var(--tw-bg-opacity))}.dark\:bg-zinc-900{--tw-bg-opacity: 1;background-color:rgb(24 24 27 / var(--tw-bg-opacity))}.dark\:text-zinc-300{--tw-text-opacity: 1;color:rgb(212 212 216 / var(--tw-text-opacity))}.dark\:text-zinc-400{--tw-text-opacity: 1;color:rgb(161 161 170 / var(--tw-text-opacity))}.dark\:text-zinc-50{--tw-text-opacity: 1;color:rgb(250 250 250 / var(--tw-text-opacity))}.dark\:hover\:bg-zinc-700:hover{--tw-bg-opacity: 1;background-color:rgb(63 63 70 / var(--tw-bg-opacity))}.dark\:hover\:bg-zinc-800:hover{--tw-bg-opacity: 1;background-color:rgb(39 39 42 / var(--tw-bg-opacity))}.dark\:hover\:text-rose-300:hover{--tw-text-opacity: 1;color:rgb(253 164 175 / var(--tw-text-opacity))}.dark\:hover\:text-rose-700:hover{--tw-text-opacity: 1;color:rgb(190 18 60 / var(--tw-text-opacity))}}@media (min-width: 640px){.sm\:grid-cols-2{grid-template-columns:repeat(2,minmax(0,1fr))}}@media (min-width: 1024px){.lg\:grid-cols-3{grid-template-columns:repeat(3,minmax(0,1fr))}}@media (min-width: 1280px){.xl\:grid-cols-4{grid-template-columns:repeat(4,minmax(0,1fr))}}@media (min-width: 1536px){.\32xl\:grid-cols-2{grid-template-columns:repeat(2,minmax(0,1fr))}.\32xl\:grid-cols-5{grid-template-columns:repeat(5,minmax(0,1fr))}}
```

### Comparing `pixano-0.2.1/pixano/core/__init__.py` & `pixano-0.3.0/pixano/apps/core/__init__.py`

 * *Files 13% similar despite different names*

```diff
@@ -5,8 +5,14 @@
 # This software is a collaborative computer program whose purpose is to
 # generate and explore labeled data for computer vision applications.
 # This software is governed by the CeCILL-C license under French law and
 # abiding by the rules of distribution of free software. You can use,
 # modify and/ or redistribute the software under the terms of the CeCILL-C
 # license as circulated by CEA, CNRS and INRIA at the following URL
 #
-# http://www.cecill.info
+# http://www.cecill.info
+
+from .main import app
+
+__all__ = [
+    "app",
+]
```

### Comparing `pixano-0.2.1/pixano/core/dataset_test.py` & `pixano-0.3.0/pixano/core/dataset_test.py`

 * *Files 2% similar despite different names*

```diff
@@ -12,15 +12,15 @@
 # http://www.cecill.info
 
 import json
 import tempfile
 import unittest
 from pathlib import Path
 
-from pixano.core.dataset import Dataset
+from pixano.core import Dataset
 
 TARGET_INFO = {
     "name": "My dataset",
     "description": "Dataset from a great AI project",
     "features": [{"feat1": "int32"}, {"feat2": "image"}],
 }
```

### Comparing `pixano-0.2.1/pixano/core/arrow_types/__init__.py` & `pixano-0.3.0/pixano/core/arrow_types/__init__.py`

 * *Files 7% similar despite different names*

```diff
@@ -9,24 +9,34 @@
 # modify and/ or redistribute the software under the terms of the CeCILL-C
 # license as circulated by CEA, CNRS and INRIA at the following URL
 #
 # http://www.cecill.info
 
 import pyarrow as pa
 
-from .features import BBoxType, ObjectAnnotation, ObjectAnnotationType
+from .features import (
+    BBoxType,
+    Embedding,
+    EmbeddingType,
+    ObjectAnnotation,
+    ObjectAnnotationType,
+    is_embedding_type,
+)
 from .image import CompressedRLEType, Image, ImageType, is_image_type
 
 __all__ = [
     "BBoxType",
+    "Embedding",
+    "EmbeddingType",
     "ObjectAnnotation",
     "ObjectAnnotationType",
     "CompressedRLEType",
     "Image",
     "ImageType",
+    "is_embedding_type",
     "is_image_type",
 ]
 
 
 def convert_field(
     field_name: str, field_type: pa.DataType, field_data: list
 ) -> pa.Array:
@@ -81,14 +91,15 @@
 
 def register_extension_types():
     """Register PyArrow ExtensionTypes"""
 
     types = [
         BBoxType(),
         CompressedRLEType(),
+        EmbeddingType(),
         ImageType(),
     ]
 
     for t in types:
         # Register ExtensionType
         try:
             pa.register_extension_type(t)
```

### Comparing `pixano-0.2.1/pixano/core/arrow_types/features.py` & `pixano-0.3.0/pixano/core/arrow_types/features.py`

 * *Files 11% similar despite different names*

```diff
@@ -29,14 +29,38 @@
     def __arrow_ext_deserialize__(cls, storage_type, serialized):
         return BBoxType()
 
     def __arrow_ext_serialize__(self):
         return b""
 
 
+class EmbeddingType(pa.ExtensionType):
+    """Embedding type as PyArrow binary"""
+
+    def __init__(self):
+        super(EmbeddingType, self).__init__(pa.binary(), "embedding")
+
+    @classmethod
+    def __arrow_ext_deserialize__(cls, storage_type, serialized):
+        return EmbeddingType()
+
+    def __arrow_ext_serialize__(self):
+        return b""
+
+
+class Embedding(BaseModel):
+    """Embedding class
+
+    Attributes:
+        embedding (bytes): Embedding as binary
+    """
+
+    embedding: bytes
+
+
 class ObjectAnnotation(BaseModel):
     """ObjectAnnotation class to contain all annotation data
 
     Attributes:
         id (str): Annotation unique ID
         view_id (str, optional): View ID (e.g. 'image', 'cam_2')
         bbox (list[float], optional): Bounding box coordinates in xywh format (using top left point as reference)
@@ -54,28 +78,28 @@
         identity (str, optional): Identity
     """
 
     # Object ID and View ID
     id: str
     view_id: Optional[str] = None
     # Bounding Box
-    bbox: Optional[list[float]] = None
+    bbox: Optional[list[float]] = [0.0] * 4
     bbox_source: Optional[str] = None
     bbox_confidence: Optional[float] = None
     is_group_of: Optional[bool] = None
     is_difficult: Optional[bool] = None
     is_truncated: Optional[bool] = None
     # Mask
-    mask: Optional[dict[str, bytes]] = None
+    mask: Optional[dict] = None
     mask_source: Optional[str] = None
     area: Optional[float] = None
     # 6D Poses
     pose: Optional[dict[str, list[float]]] = {
-        "cam_R_m2c": [0] * 9,
-        "cam_t_m2c": [0] * 3,
+        "cam_R_m2c": [0.0] * 9,
+        "cam_t_m2c": [0.0] * 3,
     }
     # Category
     category_id: Optional[int] = None
     category_name: Optional[str] = None
     identity: Optional[str] = None
 
 
@@ -113,7 +137,19 @@
             pa.field("pose", pose_schema, nullable=True),
             # Category
             pa.field("category_id", pa.int32(), nullable=True),
             pa.field("category_name", pa.string(), nullable=True),
             pa.field("identity", pa.string(), nullable=True),
         ]
     )
+
+
+def is_embedding_type(t: pa.DataType) -> bool:
+    """Returns True if value is an instance of EmbeddingType
+
+    Args:
+        t (pa.DataType): Value to check
+
+    Returns:
+        bool: Type checking response
+    """
+    return isinstance(t, EmbeddingType)
```

### Comparing `pixano-0.2.1/pixano/core/arrow_types/image_test.py` & `pixano-0.3.0/pixano/core/arrow_types/image_test.py`

 * *Files identical despite different names*

### Comparing `pixano-0.2.1/pixano/data/__init__.py` & `pixano-0.3.0/pixano/analytics/__init__.py`

 * *Files 25% similar despite different names*

```diff
@@ -7,16 +7,13 @@
 # This software is governed by the CeCILL-C license under French law and
 # abiding by the rules of distribution of free software. You can use,
 # modify and/ or redistribute the software under the terms of the CeCILL-C
 # license as circulated by CEA, CNRS and INRIA at the following URL
 #
 # http://www.cecill.info
 
-from .coco_loader import CocoLoader
-from .data_loader import DataLoader
-from .pixano_loader import PixanoLoader
+from .feature_statistics import compute_additional_data, compute_stats
 
 __all__ = [
-    "DataLoader",
-    "PixanoLoader",
-    "CocoLoader",
+    "compute_additional_data",
+    "compute_stats",
 ]
```

### Comparing `pixano-0.2.1/pixano/inference/__init__.py` & `pixano-0.3.0/pixano/core/__init__.py`

 * *Files 23% similar despite different names*

```diff
@@ -7,16 +7,15 @@
 # This software is governed by the CeCILL-C license under French law and
 # abiding by the rules of distribution of free software. You can use,
 # modify and/ or redistribute the software under the terms of the CeCILL-C
 # license as circulated by CEA, CNRS and INRIA at the following URL
 #
 # http://www.cecill.info
 
-from .inference_model import InferenceModel
-from .offline_model import OfflineModel
-from .online_model import OnlineModel
+from .dataset import Dataset, DatasetInfo, EmbeddingDataset, InferenceDataset
 
 __all__ = [
-    "OfflineModel",
-    "OnlineModel",
-    "InferenceModel",
+    "DatasetInfo",
+    "Dataset",
+    "InferenceDataset",
+    "EmbeddingDataset",
 ]
```

### Comparing `pixano-0.2.1/pixano/notebook/display.py` & `pixano-0.3.0/pixano/apps/core/serve.py`

 * *Files 25% similar despite different names*

```diff
@@ -7,19 +7,28 @@
 # This software is governed by the CeCILL-C license under French law and
 # abiding by the rules of distribution of free software. You can use,
 # modify and/ or redistribute the software under the terms of the CeCILL-C
 # license as circulated by CEA, CNRS and INRIA at the following URL
 #
 # http://www.cecill.info
 
+import asyncio
 import html
 import json
+from pathlib import Path
 
+import fastapi
 import IPython.display
 import shortuuid
+import uvicorn
+from fastapi.responses import HTMLResponse
+from fastapi.staticfiles import StaticFiles
+from fastapi.templating import Jinja2Templates
+
+from .main import Settings, create_app
 
 
 def get_env() -> str:
     """Get current running environment
 
     Returns:
         str: Running environment
@@ -45,46 +54,26 @@
         if ipython is not None and ipython.has_trait("kernel"):
             return "ipython"
 
     # Else
     return "none"
 
 
-def display(url: str = "http://127.0.0.1", port: int = 8000, height: int = 1000):
-    """Display a Pixano app inside an environment
-
-    Args:
-        url (str, optional): Pixano app URL. Defaults to "127.0.0.1".
-        port (int, optional): Pixano app port. Defaults to 8000.
-        height (int, optional): Frame height. Defaults to 1000.
-    """
-
-    # Select function based on environment
-    f = {
-        "colab": display_colab,
-        "ipython": display_ipython,
-        "none": display_cli,
-    }[get_env()]
-
-    # Display Pixano app
-    f(url, port, height)
-
-
 def display_colab(url: str, port: int, height: int):
     """Display a Pixano app inside a Google Colab
 
     Args:
         url (str): Pixano app URL
         port (int): Pixano app port
         height (int): Frame height
     """
 
     # Define frame template
     shell = """
-        (async () => {
+        (() => {
             const url = new URL(%URL%);
             const port = %PORT%;
             if (port) {
                 url.port = port;
             }
             const iframe = document.createElement('iframe');
             iframe.src = url;
@@ -158,7 +147,81 @@
     Args:
         url (str): Pixano app URL
         port (int): Pixano app port
         height (int): Frame height
     """
 
     print(f"Please visit {url}:{port} in a web browser.")
+
+
+class PixanoApp:
+    """Pixano App
+
+    Attributes:
+        config (uvicorn.Config): App config
+        server (uvicorn.Server): App server
+        task_function (typing.Callable): Run task function for running environment
+        display_function (typing.Callable): Display function for running environment
+    """
+
+    def __init__(
+        self,
+        library_dir: str,
+        assets_path: str,
+        template_path: str,
+        host: str = "127.0.0.1",
+        port: int = 8000,
+    ):
+        """Initialize and run Pixano app
+
+        Args:
+            library_dir (str): Dataset library directory
+            host (str, optional): App host. Defaults to "127.0.0.1".
+            port (int, optional): App port. Defaults to 8000.
+        """
+
+        # Create app
+        templates = Jinja2Templates(directory=template_path)
+        settings = Settings(data_dir=Path(library_dir))
+        app = create_app(settings)
+
+        @app.get("/", response_class=HTMLResponse)
+        def main(request: fastapi.Request):
+            return templates.TemplateResponse("index.html", {"request": request})
+
+        app.mount("/assets", StaticFiles(directory=assets_path), name="assets")
+        self.config = uvicorn.Config(app, host=host, port=port)
+        self.server = uvicorn.Server(self.config)
+
+        # Get environmennt
+        self.task_function = {
+            "colab": asyncio.get_event_loop().create_task,
+            "ipython": asyncio.get_event_loop().create_task,
+            "none": asyncio.run,
+        }[get_env()]
+        self.display_function = {
+            "colab": display_colab,
+            "ipython": display_ipython,
+            "none": display_cli,
+        }[get_env()]
+
+        # Serve app
+        self.task_function(self.server.serve())
+
+    def display(self, height: int = 1000) -> None:
+        """Display Pixano app
+
+        Args:
+            height (int, optional): Frame height. Defaults to 1000.
+        """
+
+        # Wait for app to be online
+        while not self.server.started:
+            self.task_function(asyncio.wait(0.1))
+
+        # Display app
+        for server in self.server.servers:
+            for socket in server.sockets:
+                address = socket.getsockname()
+                self.display_function(
+                    url=f"http://{address[0]}", port=address[1], height=height
+                )
```

### Comparing `pixano-0.2.1/pixano/tools/converter/__init__.py` & `pixano-0.3.0/pixano/__version__.py`

 * *Files 9% similar despite different names*

```diff
@@ -7,12 +7,8 @@
 # This software is governed by the CeCILL-C license under French law and
 # abiding by the rules of distribution of free software. You can use,
 # modify and/ or redistribute the software under the terms of the CeCILL-C
 # license as circulated by CEA, CNRS and INRIA at the following URL
 #
 # http://www.cecill.info
 
-from .convert2parquet import convert
-
-__all__ = [
-    "convert",
-]
+__version__ = "0.3.0"
```

### Comparing `pixano-0.2.1/pixano/transforms/__init__.py` & `pixano-0.3.0/pixano/transforms/__init__.py`

 * *Files 19% similar despite different names*

```diff
@@ -7,40 +7,75 @@
 # This software is governed by the CeCILL-C license under French law and
 # abiding by the rules of distribution of free software. You can use,
 # modify and/ or redistribute the software under the terms of the CeCILL-C
 # license as circulated by CEA, CNRS and INRIA at the following URL
 #
 # http://www.cecill.info
 
-from .boxes import denormalize, mask_to_bbox, normalize, xywh_to_xyxy, xyxy_to_xywh
+import re
+
+from .boxes import (
+    denormalize,
+    format_bbox,
+    mask_to_bbox,
+    normalize,
+    urle_to_bbox,
+    xywh_to_xyxy,
+    xyxy_to_xywh,
+)
 from .image import (
-    binary_to_base64,
+    binary_to_url,
     depth_array_to_gray,
     depth_file_to_binary,
+    encode_rle,
     image_to_binary,
+    image_to_thumbnail,
     mask_to_polygons,
     mask_to_rle,
+    polygons_to_rle,
     rle_to_mask,
     rle_to_polygons,
     rle_to_urle,
+    urle_to_rle,
 )
-from .labels import coco_names_80, coco_names_91, voc_names
+from .labels import coco_ids_80to91, coco_names_80, coco_names_91, dota_ids, voc_names
 
 __all__ = [
     "normalize",
     "denormalize",
     "mask_to_bbox",
+    "urle_to_bbox",
+    "format_bbox",
     "xywh_to_xyxy",
     "xyxy_to_xywh",
     "image_to_binary",
-    "binary_to_base64",
+    "image_to_thumbnail",
+    "binary_to_url",
     "depth_file_to_binary",
     "depth_array_to_gray",
+    "encode_rle",
     "mask_to_rle",
     "rle_to_mask",
+    "polygons_to_rle",
     "rle_to_polygons",
     "mask_to_polygons",
+    "urle_to_rle",
     "rle_to_urle",
+    "coco_ids_80to91",
     "coco_names_80",
     "coco_names_91",
+    "dota_ids",
     "voc_names",
+    "natural_key",
 ]
+
+
+def natural_key(string: str) -> list:
+    """Return key for string natural sort
+
+    Args:
+        string (str): Input string
+
+    Returns:
+        list: Sort key
+    """
+    return [int(s) if s.isdecimal() else s for s in re.split(r"(\d+)", string)]
```

### Comparing `pixano-0.2.1/pixano/transforms/boxes.py` & `pixano-0.3.0/pixano/transforms/boxes.py`

 * *Files 22% similar despite different names*

```diff
@@ -10,87 +10,124 @@
 # license as circulated by CEA, CNRS and INRIA at the following URL
 #
 # http://www.cecill.info
 
 import numpy as np
 from PIL import Image
 
+from .image import rle_to_mask, urle_to_rle
 
-def denormalize(coord: list[float], w: int, h: int) -> list[float]:
+
+def denormalize(coord: list[float], height: int, width: int) -> list[float]:
     """Denormalize coordinates
 
     Args:
         coord (list[float]): Normalized coordinates
-        w (int): Width
-        h (int): Height
+        height (int): Height
+        width (int): Width
 
     Returns:
         list[float]: Unnormalized coordinates
     """
 
     denorm = []
 
     for i, c in enumerate(coord):
         if i % 2 == 0:
-            denorm.append(c * w)
+            denorm.append(c * width)
         else:
-            denorm.append(c * h)
+            denorm.append(c * height)
 
     return denorm
 
 
-def normalize(coord: list[float], w: int, h: int) -> list[float]:
+def normalize(coord: list[float], height: int, width: int) -> list[float]:
     """Normalize coordinates
 
     Args:
         coord (list[float]): Unnormalized coordinates
-        w (int): Width
-        h (int): Height
+        height (int): Height
+        width (int): Width
 
     Returns:
         list[float]: Normalized coordinates
     """
 
     norm = []
 
     for i, c in enumerate(coord):
         if i % 2 == 0:
-            norm.append(c / w)
+            norm.append(c / width)
         else:
-            norm.append(c / h)
+            norm.append(c / height)
 
     return norm
 
 
-def mask_to_bbox(mask: Image.Image) -> list[float]:
+def mask_to_bbox(mask: np.ndarray) -> list[float]:
     """Returns the smallest bounding box containing all the mask pixels
 
     Args:
-        mask (Image.Image): Mask as Pillow (or NumPy Array)
+        mask (np.ndarray): Mask as NumPy Array
 
     Returns:
         list[float]: Normalized xywh bounding box
     """
 
-    w_img, h_img = mask.size
+    height, width = mask.shape
     bool_mask = np.array(mask).astype(bool)
 
     # Find all columns and rows that contain ones
     rows = np.any(bool_mask, axis=1)
     cols = np.any(bool_mask, axis=0)
 
     # Find the min and max col/row index that contain ones
     rmin, rmax = np.where(rows)[0][[0, -1]]
     cmin, cmax = np.where(cols)[0][[0, -1]]
 
-    # Calculate height and width
-    h = (rmax - rmin + 1) / h_img
-    w = (cmax - cmin + 1) / w_img
+    # Calculate bbox height and width
+    w = (cmax - cmin + 1) / width
+    h = (rmax - rmin + 1) / height
+
+    return [cmin / width, rmin / height, w, h]
+
+
+def urle_to_bbox(urle: dict) -> list[float]:
+    """Returns the smallest bounding box containing all the mask pixels
+
+    Args:
+        urle (dict): Mask as uncompressed RLE
+
+    Returns:
+        list[float]: Normalized xywh bounding box
+    """
+
+    return mask_to_bbox(rle_to_mask(urle_to_rle(urle)))
+
+
+def format_bbox(bbox, is_predicted=False, confidence=None) -> dict:
+    """Convert bounding box to frontend format
+
+    Args:
+        bbox (list[float]): Bounding box
+        is_predicted (bool, optional): True for prediction, False for ground truth. Defaults to False.
+        confidence (float, optional): Bounding box confidence. Defaults to None.
+
+    Returns:
+        dict: Bounding box in frontend format
+    """
 
-    return [cmin / w_img, rmin / h_img, w, h]
+    return {
+        "x": float(bbox[0]),
+        "y": float(bbox[1]),
+        "width": float(bbox[2]),
+        "height": float(bbox[3]),
+        "is_predict": is_predicted,
+        "confidence": confidence,
+    }
 
 
 def xywh_to_xyxy(xywh: list[float]) -> list[float]:
     """Convert bounding box coordinates from xywh (using top left point as reference) to xyxy
 
     Args:
         xywh (list[float]): xywh coordinates
```

### Comparing `pixano-0.2.1/pixano/transforms/labels.py` & `pixano-0.3.0/pixano/transforms/labels.py`

 * *Files 18% similar despite different names*

```diff
@@ -8,22 +8,118 @@
 # abiding by the rules of distribution of free software. You can use,
 # modify and/ or redistribute the software under the terms of the CeCILL-C
 # license as circulated by CEA, CNRS and INRIA at the following URL
 #
 # http://www.cecill.info
 
 
-def coco_names_80(label: int) -> str:
+def coco_ids_80to91(id: int) -> int:
+    """Return COCO category ID (80 to 91 classes)
+
+    Args:
+        id (int): Category ID (80 classes)
+
+    Returns:
+        int: Category ID (91 classes)
+    """
+
+    coco_dict = {
+        1: 1,
+        2: 2,
+        3: 3,
+        4: 4,
+        5: 5,
+        6: 6,
+        7: 7,
+        8: 8,
+        9: 9,
+        10: 10,
+        11: 11,
+        12: 13,
+        13: 14,
+        14: 15,
+        15: 16,
+        16: 17,
+        17: 18,
+        18: 19,
+        19: 20,
+        20: 21,
+        21: 22,
+        22: 23,
+        23: 24,
+        24: 25,
+        25: 27,
+        26: 28,
+        27: 31,
+        28: 32,
+        29: 33,
+        30: 34,
+        31: 35,
+        32: 36,
+        33: 37,
+        34: 38,
+        35: 39,
+        36: 40,
+        37: 41,
+        38: 42,
+        39: 43,
+        40: 44,
+        41: 46,
+        42: 47,
+        43: 48,
+        44: 49,
+        45: 50,
+        46: 51,
+        47: 52,
+        48: 53,
+        49: 54,
+        50: 55,
+        51: 56,
+        52: 57,
+        53: 58,
+        54: 59,
+        55: 60,
+        56: 61,
+        57: 62,
+        58: 63,
+        59: 64,
+        60: 65,
+        61: 67,
+        62: 70,
+        63: 72,
+        64: 73,
+        65: 74,
+        66: 75,
+        67: 76,
+        68: 77,
+        69: 78,
+        70: 79,
+        71: 80,
+        72: 81,
+        73: 82,
+        74: 84,
+        75: 85,
+        76: 86,
+        77: 87,
+        78: 88,
+        79: 89,
+        80: 90,
+    }
+
+    return coco_dict[int(id)]
+
+
+def coco_names_80(id: int) -> str:
     """Return COCO category name (80 classes)
 
     Args:
-        label (int): Category ID
+        id (int): Category ID
 
     Returns:
-        name (str): Category name
+        str: Category name
     """
 
     coco_dict = {
         1: "person",
         2: "bicycle",
         3: "car",
         4: "motorcycle",
@@ -101,42 +197,42 @@
         76: "vase",
         77: "scissors",
         78: "teddy bear",
         79: "hair drier",
         80: "toothbrush",
     }
 
-    return coco_dict[int(label)]
+    return coco_dict[int(id)]
 
 
-def coco_names_91(label: int) -> str:
+def coco_names_91(id: int) -> str:
     """Return COCO category name (91 classes)
 
     Args:
-        label (int): Category ID
+        id (int): Category ID
 
     Returns:
-        name (str): Category name
+        str: Category name
     """
 
     coco_dict = {
         1: "person",
         2: "bicycle",
         3: "car",
-        4: "motorbike",
-        5: "aeroplane",
+        4: "motorcycle",
+        5: "airplane",
         6: "bus",
         7: "train",
         8: "truck",
         9: "boat",
-        10: "trafficlight",
-        11: "firehydrant",
-        12: "streetsign",
-        13: "stopsign",
-        14: "parkingmeter",
+        10: "traffic light",
+        11: "fire hydrant",
+        12: "street sign",
+        13: "stop sign",
+        14: "parking meter",
         15: "bench",
         16: "bird",
         17: "cat",
         18: "dog",
         19: "horse",
         20: "sheep",
         21: "cow",
@@ -144,89 +240,123 @@
         23: "bear",
         24: "zebra",
         25: "giraffe",
         26: "hat",
         27: "backpack",
         28: "umbrella",
         29: "shoe",
-        30: "eyeglasses",
+        30: "eye glasses",
         31: "handbag",
         32: "tie",
         33: "suitcase",
         34: "frisbee",
         35: "skis",
         36: "snowboard",
-        37: "sportsball",
+        37: "sports ball",
         38: "kite",
-        39: "baseballbat",
-        40: "baseballglove",
+        39: "baseball bat",
+        40: "baseball glove",
         41: "skateboard",
         42: "surfboard",
-        43: "tennisracket",
+        43: "tennis racket",
         44: "bottle",
         45: "plate",
-        46: "wineglass",
+        46: "wine glass",
         47: "cup",
         48: "fork",
         49: "knife",
         50: "spoon",
         51: "bowl",
         52: "banana",
         53: "apple",
         54: "sandwich",
         55: "orange",
         56: "broccoli",
         57: "carrot",
-        58: "hotdog",
+        58: "hot dog",
         59: "pizza",
         60: "donut",
         61: "cake",
         62: "chair",
-        63: "sofa",
-        64: "pottedplant",
+        63: "couch",
+        64: "potted plant",
         65: "bed",
         66: "mirror",
-        67: "diningtable",
+        67: "dining table",
         68: "window",
         69: "desk",
         70: "toilet",
         71: "door",
-        72: "tvmonitor",
+        72: "tv",
         73: "laptop",
         74: "mouse",
         75: "remote",
         76: "keyboard",
-        77: "cellphone",
+        77: "cell phone",
         78: "microwave",
         79: "oven",
         80: "toaster",
         81: "sink",
         82: "refrigerator",
         83: "blender",
         84: "book",
         85: "clock",
         86: "vase",
         87: "scissors",
-        88: "teddybear",
-        89: "hairdrier",
+        88: "teddy bear",
+        89: "hair drier",
         90: "toothbrush",
-        91: "hairbrush",
+        91: "hair brush",
+    }
+
+    return coco_dict[int(id)]
+
+
+def dota_ids(name: str) -> int:
+    """Return DOTAv2 category ID (18 classes)
+
+    Args:
+        name (int): Category name
+
+    Returns:
+        str: Category ID
+    """
+
+    dota_dict = {
+        "plane": 1,
+        "ship": 2,
+        "storage tank": 3,
+        "baseball diamond": 4,
+        "tennis court": 5,
+        "basketball court": 6,
+        "ground track field": 7,
+        "harbor": 8,
+        "bridge": 9,
+        "large vehicle": 10,
+        "small vehicle": 11,
+        "helicopter": 12,
+        "roundabout": 13,
+        "soccer ball field": 14,
+        "swimming pool": 15,
+        "container crane": 16,
+        "airport": 17,
+        "helipad": 18,
     }
 
-    return coco_dict[int(label)]
+    return dota_dict[str(name).replace("-", " ")]
 
 
-def voc_names(label: int) -> str:
+def voc_names(id: int) -> str:
     """Return VOC category name (20 classes)
 
     Args:
-        label (int): Category ID
+        id (int): Category ID
 
     Returns:
-        name (str): Category name
+        str: Category name
     """
 
     voc_dict = {
         1: "aeroplane",
         2: "bicycle",
         3: "bird",
         4: "boat",
@@ -244,8 +374,8 @@
         16: "potted plant",
         17: "sheep",
         18: "sofa",
         19: "train",
         20: "tv / monitor",
     }
 
-    return voc_dict[int(label)]
+    return voc_dict[int(id)]
```

### Comparing `pixano-0.2.1/LICENSE` & `pixano-0.3.0/LICENSE`

 * *Files identical despite different names*

### Comparing `pixano-0.2.1/README.md` & `pixano-0.3.0/README.md`

 * *Files 18% similar despite different names*

```diff
@@ -1,110 +1,151 @@
 00000000: 3c64 6976 2061 6c69 676e 3d22 6365 6e74  <div align="cent
-00000010: 6572 223e 0a0a 3c69 6d67 2073 7263 3d22  er">..<img src="
-00000020: 696d 6167 6573 2f70 6978 616e 6f5f 6c6f  images/pixano_lo
-00000030: 676f 2e70 6e67 2220 616c 743d 2250 6978  go.png" alt="Pix
-00000040: 616e 6f22 2068 6569 6768 743d 2231 3030  ano" height="100
-00000050: 222f 3e0a 0a2a 2a44 6174 6120 4365 6e74  "/>..**Data Cent
-00000060: 7269 6320 4149 2042 7569 6c64 696e 6720  ric AI Building 
-00000070: 426c 6f63 6b73 2066 6f72 2043 6f6d 7075  Blocks for Compu
-00000080: 7465 7220 5669 7369 6f6e 2041 7070 6c69  ter Vision Appli
-00000090: 6361 7469 6f6e 2a2a 0a0a 5b21 5b4c 6963  cation**..[![Lic
-000000a0: 656e 7365 5d28 6874 7470 733a 2f2f 696d  ense](https://im
-000000b0: 672e 7368 6965 6c64 732e 696f 2f62 6164  g.shields.io/bad
-000000c0: 6765 2f6c 6963 656e 7365 2d43 6543 494c  ge/license-CeCIL
-000000d0: 4c2d 2d43 2d62 6c75 652e 7376 6729 5d28  L--C-blue.svg)](
-000000e0: 4c49 4345 4e53 4529 0a5b 215b 4769 7448  LICENSE).[![GitH
-000000f0: 7562 2076 6572 7369 6f6e 5d28 6874 7470  ub version](http
-00000100: 733a 2f2f 696d 672e 7368 6965 6c64 732e  s://img.shields.
-00000110: 696f 2f67 6974 6875 622f 762f 7265 6c65  io/github/v/rele
-00000120: 6173 652f 7069 7861 6e6f 2f70 6978 616e  ase/pixano/pixan
-00000130: 6f3f 696e 636c 7564 655f 7072 6572 656c  o?include_prerel
-00000140: 6561 7365 7329 5d28 6874 7470 733a 2f2f  eases)](https://
-00000150: 6769 7468 7562 2e63 6f6d 2f70 6978 616e  github.com/pixan
-00000160: 6f2f 7069 7861 6e6f 2f72 656c 6561 7365  o/pixano/release
-00000170: 7329 0a5b 215b 5079 5049 2076 6572 7369  s).[![PyPI versi
-00000180: 6f6e 5d28 6874 7470 733a 2f2f 696d 672e  on](https://img.
-00000190: 7368 6965 6c64 732e 696f 2f70 7970 692f  shields.io/pypi/
-000001a0: 762f 7069 7861 6e6f 295d 2868 7474 7073  v/pixano)](https
-000001b0: 3a2f 2f70 7970 692e 6f72 672f 7072 6f6a  ://pypi.org/proj
-000001c0: 6563 742f 7069 7861 6e6f 2f29 0a5b 215b  ect/pixano/).[![
-000001d0: 5079 7468 6f6e 2076 6572 7369 6f6e 5d28  Python version](
-000001e0: 6874 7470 733a 2f2f 696d 672e 7368 6965  https://img.shie
-000001f0: 6c64 732e 696f 2f62 6164 6765 2f70 7974  lds.io/badge/pyt
-00000200: 686f 6e2d 332e 3130 2d69 6d70 6f72 7461  hon-3.10-importa
-00000210: 6e74 295d 2868 7474 7073 3a2f 2f77 7777  nt)](https://www
-00000220: 2e70 7974 686f 6e2e 6f72 672f 646f 776e  .python.org/down
-00000230: 6c6f 6164 732f 290a 0a2a 2a2a 556e 6465  loads/)..***Unde
-00000240: 7220 6163 7469 7665 2064 6576 656c 6f70  r active develop
-00000250: 6d65 6e74 2c20 7375 626a 6563 7420 746f  ment, subject to
-00000260: 2041 5049 2063 6861 6e67 652a 2a2a 0a0a   API change***..
-00000270: 3c2f 6469 763e 0a0a 0a23 2049 6e73 7461  </div>...# Insta
-00000280: 6c6c 696e 6720 5069 7861 6e6f 0a0a 4173  lling Pixano..As
-00000290: 2050 6978 616e 6f20 7265 7175 6972 6573   Pixano requires
-000002a0: 2073 7065 6369 6669 6320 7665 7273 696f   specific versio
-000002b0: 6e73 2066 6f72 2069 7473 2064 6570 656e  ns for its depen
-000002c0: 6465 6e63 6965 732c 2077 6520 7265 636f  dencies, we reco
-000002d0: 6d6d 656e 6420 6372 6561 7469 6e67 2061  mmend creating a
-000002e0: 206e 6577 2050 7974 686f 6e20 7669 7274   new Python virt
-000002f0: 7561 6c20 656e 7669 726f 6e6d 656e 7420  ual environment 
-00000300: 746f 2069 6e73 7461 6c6c 2069 742e 0a0a  to install it...
-00000310: 466f 7220 6578 616d 706c 652c 2077 6974  For example, wit
-00000320: 6820 636f 6e64 613a 0a0a 6060 6073 6865  h conda:..```she
-00000330: 6c6c 0a63 6f6e 6461 2063 7265 6174 6520  ll.conda create 
-00000340: 2d6e 2070 6978 616e 6f5f 656e 7620 7079  -n pixano_env py
-00000350: 7468 6f6e 3d33 2e31 300a 636f 6e64 6120  thon=3.10.conda 
-00000360: 6163 7469 7661 7465 2070 6978 616e 6f5f  activate pixano_
-00000370: 656e 760a 6060 600a 0a54 6865 6e2c 2079  env.```..Then, y
-00000380: 6f75 2063 616e 2069 6e73 7461 6c6c 2074  ou can install t
-00000390: 6865 2050 6978 616e 6f20 7061 636b 6167  he Pixano packag
-000003a0: 6520 696e 7369 6465 2074 6861 7420 656e  e inside that en
-000003b0: 7669 726f 6e6d 656e 7420 7769 7468 2070  vironment with p
-000003c0: 6970 3a0a 0a60 6060 7368 656c 6c0a 7069  ip:..```shell.pi
-000003d0: 7020 696e 7374 616c 6c20 7069 7861 6e6f  p install pixano
-000003e0: 0a60 6060 0a0a 2320 5573 696e 6720 7468  .```..# Using th
-000003f0: 6520 5069 7861 6e6f 2045 7870 6c6f 7265  e Pixano Explore
-00000400: 720a 0a50 6c65 6173 6520 7265 6665 7220  r..Please refer 
-00000410: 746f 205b 7468 6973 2070 6167 655d 2870  to [this page](p
-00000420: 6978 616e 6f2f 6170 7073 2f65 7870 6c6f  ixano/apps/explo
-00000430: 7265 722f 5245 4144 4d45 2e6d 6429 2066  rer/README.md) f
-00000440: 6f72 2069 6e66 6f72 6d61 7469 6f6e 206f  or information o
-00000450: 6e20 686f 7720 746f 2075 7365 2074 6865  n how to use the
-00000460: 2050 6978 616e 6f20 4578 706c 6f72 6572   Pixano Explorer
-00000470: 2e0a 0a23 2055 7369 6e67 2074 6865 2050  ...# Using the P
-00000480: 6978 616e 6f20 416e 6e6f 7461 746f 720a  ixano Annotator.
-00000490: 0a2a 436f 6d69 6e67 2073 6f6f 6e2e 2e2e  .*Coming soon...
-000004a0: 2a0a 0a23 2043 6f6e 7472 6962 7574 696e  *..# Contributin
-000004b0: 670a 0a49 6620 796f 7520 6669 6e64 2061  g..If you find a
-000004c0: 2062 7567 206f 7220 796f 7520 7468 696e   bug or you thin
-000004d0: 6b20 6f66 2073 6f6d 6520 6d69 7373 696e  k of some missin
-000004e0: 6720 6665 6174 7572 6573 2074 6861 7420  g features that 
-000004f0: 636f 756c 6420 6265 2075 7365 6675 6c20  could be useful 
-00000500: 7768 696c 6520 7573 696e 6720 5069 7861  while using Pixa
-00000510: 6e6f 2c20 706c 6561 7365 205b 6f70 656e  no, please [open
-00000520: 2061 6e20 6973 7375 655d 2868 7474 7073   an issue](https
-00000530: 3a2f 2f67 6974 6875 622e 636f 6d2f 7069  ://github.com/pi
-00000540: 7861 6e6f 2f70 6978 616e 6f2f 6973 7375  xano/pixano/issu
-00000550: 6573 2921 0a0a 546f 2063 6f6e 7472 6962  es)!..To contrib
-00000560: 7574 6520 6d6f 7265 2061 6374 6976 656c  ute more activel
-00000570: 7920 746f 2074 6865 2070 726f 6a65 6374  y to the project
-00000580: 2c20 796f 7520 6172 6520 7765 6c63 6f6d  , you are welcom
-00000590: 6520 746f 2064 6576 656c 6f70 2074 6865  e to develop the
-000005a0: 2066 6978 206f 7220 7468 6520 6665 6174   fix or the feat
-000005b0: 7572 6520 796f 7520 6861 7665 2069 6e20  ure you have in 
-000005c0: 6d69 6e64 2c20 616e 6420 5b63 7265 6174  mind, and [creat
-000005d0: 6520 6120 7075 6c6c 2072 6571 7565 7374  e a pull request
-000005e0: 5d28 6874 7470 733a 2f2f 6769 7468 7562  ](https://github
-000005f0: 2e63 6f6d 2f70 6978 616e 6f2f 7069 7861  .com/pixano/pixa
-00000600: 6e6f 2f70 756c 6c73 2921 0a0a 416e 6420  no/pulls)!..And 
-00000610: 6966 2079 6f75 2077 616e 7420 746f 2063  if you want to c
-00000620: 6861 6e67 6520 7468 6520 6170 706c 6963  hange the applic
-00000630: 6174 696f 6e20 746f 2079 6f75 7220 6c69  ation to your li
-00000640: 6b69 6e67 2c20 6665 656c 2066 7265 6520  king, feel free 
-00000650: 746f 205b 666f 726b 2074 6869 7320 7265  to [fork this re
-00000660: 706f 7369 746f 7279 5d28 6874 7470 733a  pository](https:
-00000670: 2f2f 6769 7468 7562 2e63 6f6d 2f70 6978  //github.com/pix
-00000680: 616e 6f2f 7069 7861 6e6f 2f66 6f72 6b29  ano/pixano/fork)
-00000690: 210a 0a23 204c 6963 656e 7365 0a0a 5069  !..# License..Pi
-000006a0: 7861 6e6f 2069 7320 6c69 6365 6e73 6564  xano is licensed
-000006b0: 2075 6e64 6572 2074 6865 205b 4365 4349   under the [CeCI
-000006c0: 4c4c 2d43 206c 6963 656e 7365 5d28 4c49  LL-C license](LI
-000006d0: 4345 4e53 4529 2e                        CENSE).
+00000010: 6572 223e 0a0a 3c70 6963 7475 7265 3e0a  er">..<picture>.
+00000020: 2020 2020 3c69 6d67 2073 7263 3d22 6874      <img src="ht
+00000030: 7470 733a 2f2f 7261 772e 6769 7468 7562  tps://raw.github
+00000040: 7573 6572 636f 6e74 656e 742e 636f 6d2f  usercontent.com/
+00000050: 7069 7861 6e6f 2f70 6978 616e 6f2f 6d61  pixano/pixano/ma
+00000060: 696e 2f69 6d61 6765 732f 7069 7861 6e6f  in/images/pixano
+00000070: 5f6c 6f67 6f2e 706e 6722 2061 6c74 3d22  _logo.png" alt="
+00000080: 5069 7861 6e6f 2220 6865 6967 6874 3d22  Pixano" height="
+00000090: 3130 3022 2f3e 0a3c 2f70 6963 7475 7265  100"/>.</picture
+000000a0: 3e0a 0a3c 6272 2f3e 0a3c 6272 2f3e 0a0a  >..<br/>.<br/>..
+000000b0: 2a2a 4461 7461 2d63 656e 7472 6963 2041  **Data-centric A
+000000c0: 4920 6275 696c 6469 6e67 2062 6c6f 636b  I building block
+000000d0: 7320 666f 7220 636f 6d70 7574 6572 2076  s for computer v
+000000e0: 6973 696f 6e20 6170 706c 6963 6174 696f  ision applicatio
+000000f0: 6e73 2a2a 0a0a 2a2a 2a55 6e64 6572 2061  ns**..***Under a
+00000100: 6374 6976 6520 6465 7665 6c6f 706d 656e  ctive developmen
+00000110: 742c 2073 7562 6a65 6374 2074 6f20 4150  t, subject to AP
+00000120: 4920 6368 616e 6765 2a2a 2a0a 0a5b 215b  I change***..[![
+00000130: 4769 7448 7562 2076 6572 7369 6f6e 5d28  GitHub version](
+00000140: 6874 7470 733a 2f2f 696d 672e 7368 6965  https://img.shie
+00000150: 6c64 732e 696f 2f67 6974 6875 622f 762f  lds.io/github/v/
+00000160: 7265 6c65 6173 652f 7069 7861 6e6f 2f70  release/pixano/p
+00000170: 6978 616e 6f3f 6c61 6265 6c3d 7265 6c65  ixano?label=rele
+00000180: 6173 6526 6c6f 676f 3d67 6974 6875 6229  ase&logo=github)
+00000190: 5d28 6874 7470 733a 2f2f 6769 7468 7562  ](https://github
+000001a0: 2e63 6f6d 2f70 6978 616e 6f2f 7069 7861  .com/pixano/pixa
+000001b0: 6e6f 2f72 656c 6561 7365 7329 0a5b 215b  no/releases).[![
+000001c0: 5079 5049 2076 6572 7369 6f6e 5d28 6874  PyPI version](ht
+000001d0: 7470 733a 2f2f 696d 672e 7368 6965 6c64  tps://img.shield
+000001e0: 732e 696f 2f70 7970 692f 762f 7069 7861  s.io/pypi/v/pixa
+000001f0: 6e6f 3f63 6f6c 6f72 3d62 6c75 6526 6c61  no?color=blue&la
+00000200: 6265 6c3d 7265 6c65 6173 6526 6c6f 676f  bel=release&logo
+00000210: 3d70 7970 6926 6c6f 676f 436f 6c6f 723d  =pypi&logoColor=
+00000220: 7768 6974 6529 5d28 6874 7470 733a 2f2f  white)](https://
+00000230: 7079 7069 2e6f 7267 2f70 726f 6a65 6374  pypi.org/project
+00000240: 2f70 6978 616e 6f2f 290a 5b21 5b44 6f63  /pixano/).[![Doc
+00000250: 756d 656e 7461 7469 6f6e 5d28 6874 7470  umentation](http
+00000260: 733a 2f2f 696d 672e 7368 6965 6c64 732e  s://img.shields.
+00000270: 696f 2f77 6562 7369 7465 2f68 7474 7073  io/website/https
+00000280: 2f70 6978 616e 6f2e 6769 7468 7562 2e69  /pixano.github.i
+00000290: 6f3f 7570 5f6d 6573 7361 6765 3d6f 6e6c  o?up_message=onl
+000002a0: 696e 6526 7570 5f63 6f6c 6f72 3d67 7265  ine&up_color=gre
+000002b0: 656e 2664 6f77 6e5f 6d65 7373 6167 653d  en&down_message=
+000002c0: 6f66 666c 696e 6526 646f 776e 5f63 6f6c  offline&down_col
+000002d0: 6f72 3d6f 7261 6e67 6526 6c61 6265 6c3d  or=orange&label=
+000002e0: 646f 6373 295d 2868 7474 7073 3a2f 2f70  docs)](https://p
+000002f0: 6978 616e 6f2e 6769 7468 7562 2e69 6f29  ixano.github.io)
+00000300: 0a5b 215b 4c69 6365 6e73 655d 2868 7474  .[![License](htt
+00000310: 7073 3a2f 2f69 6d67 2e73 6869 656c 6473  ps://img.shields
+00000320: 2e69 6f2f 6261 6467 652f 6c69 6365 6e73  .io/badge/licens
+00000330: 652d 4365 4349 4c4c 2d2d 432d 6772 6565  e-CeCILL--C-gree
+00000340: 6e2e 7376 6729 5d28 4c49 4345 4e53 4529  n.svg)](LICENSE)
+00000350: 0a5b 215b 5079 7468 6f6e 2076 6572 7369  .[![Python versi
+00000360: 6f6e 5d28 6874 7470 733a 2f2f 696d 672e  on](https://img.
+00000370: 7368 6965 6c64 732e 696f 2f70 7970 692f  shields.io/pypi/
+00000380: 7079 7665 7273 696f 6e73 2f70 6978 616e  pyversions/pixan
+00000390: 6f3f 636f 6c6f 723d 696d 706f 7274 616e  o?color=importan
+000003a0: 7426 6c6f 676f 3d70 7974 686f 6e26 6c6f  t&logo=python&lo
+000003b0: 676f 436f 6c6f 723d 7768 6974 6529 5d28  goColor=white)](
+000003c0: 6874 7470 733a 2f2f 7777 772e 7079 7468  https://www.pyth
+000003d0: 6f6e 2e6f 7267 2f64 6f77 6e6c 6f61 6473  on.org/downloads
+000003e0: 2f29 0a0a 3c2f 6469 763e 0a0a 0a23 2049  /)..</div>...# I
+000003f0: 6e73 7461 6c6c 696e 6720 5069 7861 6e6f  nstalling Pixano
+00000400: 0a0a 4173 2050 6978 616e 6f20 7265 7175  ..As Pixano requ
+00000410: 6972 6573 2073 7065 6369 6669 6320 7665  ires specific ve
+00000420: 7273 696f 6e73 2066 6f72 2069 7473 2064  rsions for its d
+00000430: 6570 656e 6465 6e63 6965 732c 2077 6520  ependencies, we 
+00000440: 7265 636f 6d6d 656e 6420 6372 6561 7469  recommend creati
+00000450: 6e67 2061 206e 6577 2050 7974 686f 6e20  ng a new Python 
+00000460: 7669 7274 7561 6c20 656e 7669 726f 6e6d  virtual environm
+00000470: 656e 7420 746f 2069 6e73 7461 6c6c 2069  ent to install i
+00000480: 742e 0a0a 466f 7220 6578 616d 706c 652c  t...For example,
+00000490: 2077 6974 6820 3c61 2068 7265 663d 2268   with <a href="h
+000004a0: 7474 7073 3a2f 2f63 6f6e 6461 2e69 6f2f  ttps://conda.io/
+000004b0: 7072 6f6a 6563 7473 2f63 6f6e 6461 2f65  projects/conda/e
+000004c0: 6e2f 6c61 7465 7374 2f75 7365 722d 6775  n/latest/user-gu
+000004d0: 6964 652f 696e 7374 616c 6c2f 696e 6465  ide/install/inde
+000004e0: 782e 6874 6d6c 2220 7461 7267 6574 3d22  x.html" target="
+000004f0: 5f62 6c61 6e6b 223e 636f 6e64 613c 2f61  _blank">conda</a
+00000500: 3e3a 0a0a 6060 6073 6865 6c6c 0a63 6f6e  >:..```shell.con
+00000510: 6461 2063 7265 6174 6520 2d6e 2070 6978  da create -n pix
+00000520: 616e 6f5f 656e 7620 7079 7468 6f6e 3d33  ano_env python=3
+00000530: 2e31 300a 636f 6e64 6120 6163 7469 7661  .10.conda activa
+00000540: 7465 2070 6978 616e 6f5f 656e 760a 6060  te pixano_env.``
+00000550: 600a 0a54 6865 6e2c 2079 6f75 2063 616e  `..Then, you can
+00000560: 2069 6e73 7461 6c6c 2074 6865 2050 6978   install the Pix
+00000570: 616e 6f20 7061 636b 6167 6520 696e 7369  ano package insi
+00000580: 6465 2074 6861 7420 656e 7669 726f 6e6d  de that environm
+00000590: 656e 7420 7769 7468 2070 6970 3a0a 0a60  ent with pip:..`
+000005a0: 6060 7368 656c 6c0a 7069 7020 696e 7374  ``shell.pip inst
+000005b0: 616c 6c20 7069 7861 6e6f 0a60 6060 0a0a  all pixano.```..
+000005c0: 2320 5573 696e 6720 796f 7572 2064 6174  # Using your dat
+000005d0: 6173 6574 730a 0a50 6c65 6173 6520 7265  asets..Please re
+000005e0: 6665 7220 746f 206f 7572 204a 7570 7974  fer to our Jupyt
+000005f0: 6572 206e 6f74 6562 6f6f 6b73 2066 6f72  er notebooks for
+00000600: 205b 696d 706f 7274 696e 675d 286e 6f74   [importing](not
+00000610: 6562 6f6f 6b73 2f64 6174 6173 6574 2f69  ebooks/dataset/i
+00000620: 6d70 6f72 745f 6461 7461 7365 742e 6970  mport_dataset.ip
+00000630: 796e 6229 2061 6e64 205b 6578 706f 7274  ynb) and [export
+00000640: 696e 675d 286e 6f74 6562 6f6f 6b73 2f64  ing](notebooks/d
+00000650: 6174 6173 6574 2f65 7870 6f72 745f 6461  ataset/export_da
+00000660: 7461 7365 742e 6970 796e 6229 2079 6f75  taset.ipynb) you
+00000670: 7220 6461 7461 7365 7473 2e0a 0a23 2055  r datasets...# U
+00000680: 7369 6e67 2074 6865 2050 6978 616e 6f20  sing the Pixano 
+00000690: 6170 7073 0a0a 506c 6561 7365 2072 6566  apps..Please ref
+000006a0: 6572 2074 6f20 7468 6573 6520 6c69 6e6b  er to these link
+000006b0: 7320 666f 7220 7573 696e 6720 7468 6520  s for using the 
+000006c0: 5b50 6978 616e 6f20 4578 706c 6f72 6572  [Pixano Explorer
+000006d0: 5d28 7069 7861 6e6f 2f61 7070 732f 6578  ](pixano/apps/ex
+000006e0: 706c 6f72 6572 2f52 4541 444d 452e 6d64  plorer/README.md
+000006f0: 2920 616e 6420 7468 6520 5b50 6978 616e  ) and the [Pixan
+00000700: 6f20 416e 6e6f 7461 746f 725d 2870 6978  o Annotator](pix
+00000710: 616e 6f2f 6170 7073 2f65 7870 6c6f 7265  ano/apps/explore
+00000720: 722f 5245 4144 4d45 2e6d 6429 2061 7070  r/README.md) app
+00000730: 732e 0a0a 2320 436f 6e74 7269 6275 7469  s...# Contributi
+00000740: 6e67 0a0a 4966 2079 6f75 2066 696e 6420  ng..If you find 
+00000750: 6120 6275 6720 6f72 2079 6f75 2074 6869  a bug or you thi
+00000760: 6e6b 206f 6620 736f 6d65 206d 6973 7369  nk of some missi
+00000770: 6e67 2066 6561 7475 7265 7320 7468 6174  ng features that
+00000780: 2063 6f75 6c64 2062 6520 7573 6566 756c   could be useful
+00000790: 2077 6869 6c65 2075 7369 6e67 2050 6978   while using Pix
+000007a0: 616e 6f2c 2070 6c65 6173 6520 5b6f 7065  ano, please [ope
+000007b0: 6e20 616e 2069 7373 7565 5d28 6874 7470  n an issue](http
+000007c0: 733a 2f2f 6769 7468 7562 2e63 6f6d 2f70  s://github.com/p
+000007d0: 6978 616e 6f2f 7069 7861 6e6f 2f69 7373  ixano/pixano/iss
+000007e0: 7565 7329 210a 0a54 6f20 636f 6e74 7269  ues)!..To contri
+000007f0: 6275 7465 206d 6f72 6520 6163 7469 7665  bute more active
+00000800: 6c79 2074 6f20 7468 6520 7072 6f6a 6563  ly to the projec
+00000810: 742c 2079 6f75 2061 7265 2077 656c 636f  t, you are welco
+00000820: 6d65 2074 6f20 6465 7665 6c6f 7020 7468  me to develop th
+00000830: 6520 6669 7820 6f72 2074 6865 2066 6561  e fix or the fea
+00000840: 7475 7265 2079 6f75 2068 6176 6520 696e  ture you have in
+00000850: 206d 696e 642c 2061 6e64 205b 6372 6561   mind, and [crea
+00000860: 7465 2061 2070 756c 6c20 7265 7175 6573  te a pull reques
+00000870: 745d 2868 7474 7073 3a2f 2f67 6974 6875  t](https://githu
+00000880: 622e 636f 6d2f 7069 7861 6e6f 2f70 6978  b.com/pixano/pix
+00000890: 616e 6f2f 7075 6c6c 7329 210a 0a41 6e64  ano/pulls)!..And
+000008a0: 2069 6620 796f 7520 7761 6e74 2074 6f20   if you want to 
+000008b0: 6368 616e 6765 2074 6865 2061 7070 6c69  change the appli
+000008c0: 6361 7469 6f6e 2074 6f20 796f 7572 206c  cation to your l
+000008d0: 696b 696e 672c 2066 6565 6c20 6672 6565  iking, feel free
+000008e0: 2074 6f20 5b66 6f72 6b20 7468 6973 2072   to [fork this r
+000008f0: 6570 6f73 6974 6f72 795d 2868 7474 7073  epository](https
+00000900: 3a2f 2f67 6974 6875 622e 636f 6d2f 7069  ://github.com/pi
+00000910: 7861 6e6f 2f70 6978 616e 6f2f 666f 726b  xano/pixano/fork
+00000920: 2921 0a0a 0a23 204c 6963 656e 7365 0a0a  )!...# License..
+00000930: 5069 7861 6e6f 2069 7320 6c69 6365 6e73  Pixano is licens
+00000940: 6564 2075 6e64 6572 2074 6865 205b 4365  ed under the [Ce
+00000950: 4349 4c4c 2d43 206c 6963 656e 7365 5d28  CILL-C license](
+00000960: 4c49 4345 4e53 4529 2e0a                 LICENSE)..
```

### Comparing `pixano-0.2.1/pyproject.toml` & `pixano-0.3.0/pyproject.toml`

 * *Files 9% similar despite different names*

```diff
@@ -3,64 +3,68 @@
 build-backend = "hatchling.build"
 
 [project]
 name = "pixano"
 dynamic = ["version"]
 description = 'Data-centric AI building blocks for computer vision applications' 
 readme = "README.md"
-requires-python = ">=3.10"
-license = { file = "LICENSE" }
+requires-python = "~=3.10"
+license = "CeCILL-C"
 authors = [{name = "Pixano Developers", email = "pixano@cea.fr"}]
 keywords = [
   "machine learning",
   "computer vision",
   "data",
   "visualization"
 ]
 classifiers = [
   "Development Status :: 4 - Beta",
   "Programming Language :: Python :: 3.10",
   "License :: CeCILL-C Free Software License Agreement (CECILL-C)",
 ]
 dependencies = [
-  "duckdb ~= 0.7.0",
+  "duckdb ~= 0.8.0",
   "etils ~= 1.1.0",
   "fastapi-pagination ~= 0.11.4",
   "imageio ~= 2.25.0",
   "importlib-resources ~= 5.12.0",
   "ipywidgets ~= 8.0.0",
   "jinja2 ~= 3.1.2",
-  "numpy ~= 1.23.0",
+  "numpy >= 1.23.0",
   "onnx ~= 1.13.0",
-  "onnxruntime ~= 1.14.0",
+  "onnxruntime ~= 1.15.0",
   "opencv-python ~= 4.7.0",
   "pandas ~= 1.5.0",
   "Pillow ~= 9.4.0",
-  "pyarrow ~= 11.0.0",
+  "pyarrow ~= 12.0.0",
   "pycocotools ~= 2.0.0",
   "setuptools ~= 65.6.0",
   "shortuuid ~= 1.0.0",
   "tqdm ~= 4.64.0",
   "uvicorn ~= 0.20.0",
 ]
 
 [project.optional-dependencies]
 documentation = [
   "mkdocs-material ~= 9.1.0",
-  "mkdocstrings-python ~= 0.9.0"
+  "mkdocstrings-python ~= 1.1.0"
 ]
 
 [project.urls]
 Documentation = "https://github.com/pixano/pixano#readme"
 Issues = "https://github.com/pixano/pixano/issues"
 Source = "https://github.com/pixano/pixano"
 
 [project.scripts]
+pixano-annotator = "pixano.apps.annotator.serve:main"
 pixano-explorer = "pixano.apps.explorer.serve:main"
 
 [tool.hatch.build]
 include = ["/pixano"]
 exclude = ["__pycache__"]
-artifacts = ["/pixano/apps/explorer/dist"]
+artifacts = [
+  "/pixano/apps/annotator/dist",
+  "/pixano/apps/explorer/dist"
+]
 
 [tool.hatch.version]
 path = "pixano/__version__.py"
```

